Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
26968674,1,26969028,0,2014-11-17 08:46:02,,36,11020,"<p>I am going to start using reactive programming in my Android project. I am using Kotlin as primary language and now I would like to apply Rx. My first choice was RxAndroid but then I noticed that there is RxKotlin.</p>

<p>As far as I know both are forked from RxJava so RxAndroid probably provides some API for android common tasks. On the other hand RxKotlin support lambas out of the box and allow me avoiding mixing kotlin with java.</p>

<p>Which one is preferred library in that case?   </p>
",1456931,,1456931,,2014-11-17 08:56:37,2016-04-01 03:23:55,Use RxAndroid or RxKotlin when programming in Kotlin for Android?,<android><rx-android><rx-kotlin>,1,1,8,2014-11-18 13:08:24,,CC BY-SA 3.0
29882922,1,29939049,0,2015-04-26 20:08:43,,1,578,"<p>The error in the title appears in Android Studio as a warning bar above all my code: <img src=""https://i.stack.imgur.com/JVvo5.png"" alt=""Error""></p>

<p>Android Studio version: <code>1.1.0</code><br>
Kotlin plugin version for Android Studio: <code>0.11.91.AndroidStudio.4</code><br>
<code>build.gradle</code> file that seems to be using all the most recent versions of the Kotlin libraries:</p>

<pre><code>apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'

android {
    compileSdkVersion 22
    buildToolsVersion ""22.0.1""

    defaultConfig {
        applicationId ""ca.amandeep.simpletransit""
        minSdkVersion 16
        targetSdkVersion 22
        versionCode 1
        versionName ""1.0""
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.0.0'
    compile ""org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version""
    compile 'com.squareup.retrofit:retrofit:1.9.0'
    compile('com.squareup.retrofit:converter-simplexml:1.9.0') {
        exclude module: 'stax'
        exclude module: 'stax-api'
        exclude module: 'xpp3'
    }
    compile 'com.squareup.okhttp:okhttp:2.3.0'
    compile 'com.squareup.okhttp:okhttp-urlconnection:2.3.0'
    compile 'com.google.guava:guava:18.0'
    compile 'com.facebook.stetho:stetho:1.0.1'
    compile 'com.facebook.stetho:stetho-okhttp:1.0.1'
    compile 'com.jakewharton.timber:timber:2.7.1'
    compile 'io.reactivex:rxkotlin:0.21.0'
    compile 'io.reactivex:rxandroid:0.24.0'
    compile 'com.github.techfreak:wizardpager:1.0.0'
}
buildscript {
    ext.kotlin_version = '0.11.91.1'
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath ""org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version""
        classpath ""org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version""
        classpath 'com.jakewharton.hugo:hugo-plugin:1.2.1'
    }
}
repositories {
    mavenCentral()
}

apply plugin: 'com.jakewharton.hugo'
</code></pre>
",137081,,0,,,2016-01-04 18:39:25,Kotlin library 'rxkotlin-0.21.0.jar' has an unsupported format. Please update the library or the plugin,<android><android-studio><kotlin><rx-android><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
34583595,1,34587372,0,2016-01-04 01:25:32,,5,867,"<p>I was having some issues using RxJava and Kotlin earlier. I made some interesting discoveries which I'm still puzzled about. </p>

<p>There is the simple <code>Func1</code> interface in RxJava</p>

<pre><code>public interface Func1&lt;T, R&gt; extends Function {
    R call(T t);
}
</code></pre>

<p>I was trying to add an extension method to an <code>Observable</code>, also an RxJava class. This would collect the emissions into a Google Guava <code>ImmutableListMulitmap</code> using a <code>Func1</code> to map the key off each item. </p>

<pre><code>fun &lt;K,T&gt; Observable&lt;T&gt;.toImmutableListMultimap(keyMapper: Func1&lt;T, K&gt;): Observable&lt;ImmutableListMultimap&lt;K,T&gt;&gt; {
    return this.collect({ ImmutableListMultimap.builder&lt;K,T&gt;()},{ b, t -&gt; b.put(keyMapper.call(t), t)}).map { it.build() }
}
</code></pre>

<p>When I tried to invoke this extension method I could not get it to compile, and it was not understanding the lambda expression at all. </p>

<pre><code>ScheduledItem.all.flatMap { it.rebuildSoftTransactions }
.toImmutableListMultimap { it.id /*compile error */ } .cache()
</code></pre>

<p>However, the strangest thing happened when I modified the extension method to use the <a href=""https://kotlinlang.org/docs/reference/lambdas.html#function-types"">function type</a>.</p>

<pre><code>fun &lt;K,T&gt; Observable&lt;T&gt;.toImmutableListMultimap(keyMapper: (T) -&gt; K): Observable&lt;ImmutableListMultimap&lt;K,T&gt;&gt; {
    return this.collect({ ImmutableListMultimap.builder&lt;K,T&gt;()},{ b, t -&gt; b.put(keyMapper(t), t)}).map { it.build() }
}
</code></pre>

<p>And then everything compiled fine. But this is what puzzled me: How come it did not infer the lambda onto the interface? When I use the standard <code>map()</code> method on the <code>Observable</code> it infers the lambda just fine using the curly bracket <code>{ }</code> syntax. But why does it not work for my extension method above?</p>
",1373258,,0,,,2016-01-04 08:44:23,Behavior with Kotlin Higher-Order Functions and Single-method interfaces?,<lambda><rx-java><kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
34966999,1,34971416,0,2016-01-23 18:14:59,,13,4698,"<p>I'm confused by Kotlin lambda syntax. </p>

<p>At first, I have</p>

<pre><code>.subscribe(
          { println(it) }
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p><strong>which works fine</strong>.</p>

<p>Then I moved the onNext to another class called GroupRecyclerViewAdapter which implements <code>Action1&lt;ArrayList&lt;Group&gt;&gt;</code>. </p>

<pre><code>.subscribe(
          view.adapter as GroupRecyclerViewAdapter
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p>However, I got the error:</p>

<p><a href=""https://i.stack.imgur.com/0GAwv.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/0GAwv.png"" alt=""error""></a></p>

<pre><code>Error:(42, 17) Type mismatch: inferred type is () -&gt; ??? but rx.functions.Action1&lt;kotlin.Throwable!&gt;! was expected
Error:(42, 27) Unresolved reference: it
Error:(43, 17) Type mismatch: inferred type is () -&gt; kotlin.Unit but rx.functions.Action0! was expected
</code></pre>

<p>I can fix the error by changing to:</p>

<pre><code>.subscribe(
          view.adapter as GroupRecyclerViewAdapter
          , Action1&lt;kotlin.Throwable&gt; { println(it.message) }
          , Action0 { println(""completed"") }
      )
</code></pre>

<p><strong>Is there a way to write the lambda without specifying a type?</strong> (<code>Action1&lt;kotlin.Throwable&gt;</code>, <code>Action0</code>) </p>

<p><a href=""https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Observable.java"" rel=""noreferrer"">Note: subscribe is RxJava method</a></p>

<p><strong>Edit 1</strong></p>

<pre><code>class GroupRecyclerViewAdapter(private val groups: MutableList&lt;Group&gt;,
                           private val listener: OnListFragmentInteractionListener?) :
RecyclerView.Adapter&lt;GroupRecyclerViewAdapter.ViewHolder&gt;(), Action1&lt;ArrayList&lt;Group&gt;&gt; {
</code></pre>
",1104902,,1104902,,2016-01-24 22:34:48,2016-01-25 14:19:58,Kotlin lambda syntax confusion,<kotlin><rx-kotlin>,2,3,2,,,CC BY-SA 3.0
35524980,1,35527773,0,2016-02-20 15:04:15,,3,984,"<p>This is working code but I have a few questions as well as a request for advice on improving it. I am new to RxJava and I have not fully wrapped my head around how to chain these type of observables together. </p>

<p>I have two model objects, <code>ListItem</code> and <code>UserInfo</code>. <code>ListItem</code>s exists in a local database and the <code>UserInfo</code> is fetched from the server by using an ID provided from the <code>ListItem</code>. </p>

<p>The <code>UserInfo</code> web service accepts an array of IDs for which it will return a list of <code>UserInfo</code> objects. </p>

<p>The flow of this code is as follows:</p>

<ol>
<li>Load <code>ListItem</code>s from database</li>
<li>Using the <code>ListItem</code>s fetched from the database, check an in memory cache to see if I've already fetched the <code>UserInfo</code> for a particular <code>ListItem</code></li>
<li>For any items whose <code>UserInfo</code> is not cached, fetch them from the network</li>
<li>Place the fetched <code>UserInfo</code> objects into the cache</li>
<li>Re-run step 2 ( the method is <code>loadCachedUserInfo</code>)</li>
<li>Return results to subscriber</li>
</ol>

<p>NOTE: The <code>UserInfo</code> objects should only be fetched for a <code>ListItem</code> if the list has been deemed a <code>isUserList</code>.</p>

<p>Here is the code:</p>

<pre><code>fun itemsInList(list : ATList, parentValue : String? = null, searchString : String? = null, limit : Int = defaultFetchLimit, sortOrder: SortDescriptor? = null) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        val listItems = listItemsInList(list, parentValue = parentValue, searchString = searchString, limit = limit, sortOrder = sortOrder)
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
        }
        return@flatMap Observable.just(listItems)
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap fetchUserInfoForListItems(listItems, list.userIDIndex!!, force = false)
        }
        return@flatMap Observable.just(listItems)
    }
}

fun loadCachedUserInfo(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        for ( listItem in listItems ) {
            listItem.coreUserInfo = coreUserMap[listItem.valueForAttributeIndex(userIDIndex)?.toLowerCase()]
        }
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }
}

fun fetchUserInfoForListItems(listItems : List&lt;ATListItem&gt;, userIDIndex: Int, force: Boolean) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    val itemsToFetch = if ( force ) listItems else listItems.filter { it.coreUserInfo == null }
    val ids = itemsToFetch.map { it.valueForAttributeIndex(userIDIndex) ?: """" }.filter { !it.isEmpty() }
    val records = hashMapOf(""records"" to ids)
    if ( itemsToFetch.count() == 0 ) {
        return Observable.just(listItems)
    }
    return RuntimeDataController.dataService.fetchCoreUserInfo(recordsMap = records)
            .map { json -&gt;
                val recordsArray = json.arrayValue(""records"")
                for ( i in 0..recordsArray.length() - 1) {
                    val coreUserInfo = CoreUserInfo(recordsArray.getJSONObject(i))
                    coreUserMap[coreUserInfo.username.toLowerCase()] = coreUserInfo
                    coreUserMap[coreUserInfo.userID] = coreUserInfo
                    coreUserInfo.externalUserID?.let { coreUserMap[it] = coreUserInfo }
                }
                return@map listItems
            }.flatMap { loadCachedUserInfo(listItems, userIDIndex = userIDIndex) }
}
</code></pre>

<p>The user would initiate the sequence of events by calling:</p>

<p><code>ListController.itemsInList(list)</code></p>

<p>My questions about this code are:</p>

<ol>
<li>Currently <code>loadCachedUserInfo</code> takes in an array of <code>ListItem</code> and returns that same array as an observable after the cached items have been associated with it. This feels wrong to me. I think instead this call should only return the items that have a cached <code>UserInfo</code> associated with it. However, I need to continue passing the full array of <code>ListItem</code> to the next method</li>
</ol>

<p>2.) Do I need to do additional work to support unsubscribing?</p>

<p>3.) This is similar question 1. My <code>fetchUserInfoForListItems</code> takes an array of list items and returns an observable with that same array of list items after they have been fetched and re-run through the cache method. This also feels incorrect to me. I would rather this method return an <code>Observable&lt;List&lt;UserInfo&gt;&gt;</code> for the objects that were fetched. I am not understanding how in <code>itemsInList</code> to then associate the <code>ListItem</code>s with the newly fetched <code>UserInfo</code> and return an Observable of those <code>ListItem</code>s.</p>

<p><strong>Edit</strong>: After writing this post it gave helped me realize a few things. I can flatMap wrap my calls in an Observable.create that can contain the smarts I wanted to take out of my <code>fetchUserInfoForListItems</code>, letting me address question #3. Here is the updated code:</p>

<pre><code> fun itemsInList(list : ATList, parentValue : String? = null, searchString : String? = null, limit : Int = defaultFetchLimit, sortOrder: SortDescriptor? = null) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        val listItems = listItemsInList(list, parentValue = parentValue, searchString = searchString, limit = limit, sortOrder = sortOrder)
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
        }
        return@flatMap Observable.just(listItems)
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
                fetchUserInfoForListItems(listItems, list.userIDIndex!!, force = false).map { userInfoList -&gt;
                    for (coreUserInfo in userInfoList) {
                        coreUserMap[coreUserInfo.username.toLowerCase()] = coreUserInfo
                        coreUserMap[coreUserInfo.userID] = coreUserInfo
                        coreUserInfo.externalUserID?.let { coreUserMap[it] = coreUserInfo }
                    }
                }.flatMap {
                    loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
                }.subscribe {
                    subscriber.onNext(listItems)
                    subscriber.onCompleted()
                }
            }
        }
        return@flatMap Observable.just(listItems)
    }
}

fun loadCachedUserInfo(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        listItems.forEach { listItem -&gt; listItem.coreUserInfo = coreUserMap[listItem.valueForAttributeIndex(userIDIndex)?.toLowerCase()] }
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }
}

fun fetchUserInfoForListItems(listItems : List&lt;ATListItem&gt;, userIDIndex: Int, force: Boolean) : Observable&lt;List&lt;CoreUserInfo&gt;&gt; {
    val itemsToFetch = if ( force ) listItems else listItems.filter { it.coreUserInfo == null }
    val ids = itemsToFetch.map { it.valueForAttributeIndex(userIDIndex) ?: """" }.filter { !it.isEmpty() }
    val records = hashMapOf(""records"" to ids)
    if ( itemsToFetch.count() == 0 ) { return Observable.just(ArrayList&lt;CoreUserInfo&gt;()) }
    return RuntimeDataController.dataService.fetchCoreUserInfo(recordsMap = records)
            .map { json -&gt;
                val userInfo = ArrayList&lt;CoreUserInfo&gt;()
                json.arrayValue(""records"").eachObject { userInfo.add(CoreUserInfo(it)) }
                return@map userInfo
            }
}
</code></pre>
",4586842,,4586842,,2016-02-20 17:25:44,2016-02-20 19:16:44,Using RxJava to join local data with remote ( or cached ) data,<android><rx-java><kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
35612056,1,0,0,2016-02-24 20:10:27,,1,536,"<p>I'm currently using the Android-ReactiveLocation Library (<a href=""https://github.com/mcharmas/Android-ReactiveLocation"" rel=""nofollow"">Github</a>). The <code>LastKnownLocationObservable</code> (<a href=""https://github.com/mcharmas/Android-ReactiveLocation/blob/master/android-reactive-location/src/main/java/pl/charmas/android/reactivelocation/observables/location/LastKnownLocationObservable.java"" rel=""nofollow"">Code</a>) is working as intended. I'm using a <code>flatMap</code> to fetch nearby stations from a db and (because of realm) I'm creating a model from the data. So I have a list of items and I'm creating the new Observable in <code>flatMap</code> with <code>Observable.from(data)</code>.</p>

<p>Then I want to sort the locations, filter them and group them.</p>

<pre><code>.toSortedList()
.flatMap { Observable.from(it) }
.filter { it.distance &lt;= (maxDistance.toDouble() * 1000) }
.groupBy { //Group the stations in categories
    if (it.distance &lt;= maxDistance &amp;&amp; it.favorite) {
        ""nearbyFavorite""
    } else if (it.favorite) {
        ""outOfReachFavorite""
    } else {
        ""nearby""
    }
}
</code></pre>

<p>However the onComplete is never called when I subscribe to the Observable. The Observable just stalls at <code>toSortedList()</code>.</p>

<p>The Subscribe:</p>

<pre><code>.subscribe(object: Subscriber&lt;GroupedObservable&lt;String, NearbyLocationItem&gt;&gt;() {
    override fun onNext(p0: GroupedObservable&lt;String, NearbyLocationItem&gt;?) {
        val locationItems = ArrayList&lt;NearbyLocationItem&gt;()
        p0.subscribe { loc -&gt;
            locationItems.add(loc)
        }
        locations.put(p0.key, locationItems)
    }


    override fun onCompleted() {
        Log.d(javaClass.simpleName, ""Never called"")
    }

    override fun onError(p0: Throwable?) {

    }
}
</code></pre>
",1501857,,0,,,2016-02-24 20:10:27,OnComplete never called with toSortedList() and groupBy(),<android><rx-java><kotlin><rx-android><rx-kotlin>,0,9,0,,,CC BY-SA 3.0
35818449,1,35820705,0,2016-03-05 19:00:58,,4,3689,"<p>I created a function which returns an <code>Observable&lt;String&gt;</code> with file names, but I don't get any event in my subscription where I call this method. Also there is no call of onError, or onComplete <br>
See my code:</p>

<pre><code>fun getAllFiles(): Observable&lt;String&gt; {

    val allFiles = File(""/Users/stephan/Projects/Playground/kotlinfiles/"")
            .listFiles { file -&gt; !file.isDirectory() }
    return observable { subscriber -&gt;
        allFiles.toObservable()
                .map { f -&gt; ""${f.name}"" }
                .doOnNext { println(""Found file $it"") }
                .subscribe { subscriber}
    }
}

fun test() {
    getAllFiles()
            .doOnNext { println(""File name$it"") }
            .subscribe(
                    {n -&gt; println(""File: $n"")},
                    {e -&gt; println(""Damn: $e"")},
                    {println(""Completed"")})
}
</code></pre>

<p>Though everything is being called in the <code>getAllFiles()</code> function, so what am I missing?</p>
",1031556,,0,,,2016-03-06 00:07:43,"rx kotlin subscription not working, not receiving items",<kotlin><rx-kotlin>,1,0,1,,,CC BY-SA 3.0
35995630,1,35998109,0,2016-03-14 18:48:09,,2,605,"<p>I've been playing with Kotlin/RxJava and tried to create an extension method for adding a <code>Subscription</code> to a <code>CompositeSubscription</code>, that would work like:</p>

<pre><code>search.subscribe {
       //do stuff
}.addToComposite(compositeSubscription)
</code></pre>

<p>This is my attempt so far:</p>

<pre><code>fun Subscription.addToComposite(composite: CompositeSubscription) = { composite.add(this) }
</code></pre>

<p>It compiles and runs without errors but doesn't seem to actually add the <code>Subscription</code> to the <code>CompositeSubscription</code>. Am I doing something wrong?</p>
",1607552,,1363438,,2018-01-01 17:34:28,2018-01-01 17:34:28,Can I create a Kotlin extension method for adding an rxJava Subscription to a CompositeSubscription?,<rx-java><kotlin><kotlin-extension><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
36809467,1,0,0,2016-04-23 10:16:23,,6,1909,"<p>I'm using rxAndroid and rxKotlin in my Android app to handle network requests asynchronously. Now I would like to retry a failed network request only after click on Snackbar button.</p>

<p>My code now:</p>

<pre><code>val citiesService = ApiFactory.citiesService

citiesService.cities()
    .subscribeOn(Schedulers.newThread()) // fetch List&lt;String&gt;
    .flatMap { Observable.from(it) }     // convert to sequence of String
    .flatMap { city -&gt;
        citiesService.coordinates(city)  // fetch DoubleArray
            .map { City(city, it) }      // convert to City(String, DoubleArray)
        }
    .toList()
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext {
        listView.setOnItemClickListener { adapterView, view, position, id -&gt;
            onItemClick(it[position])
        }
    }
    .map { it.map { it.getName(activity) } }
    .subscribe(
        { listAdapter = setupAdapter(it) },
        { showErrorSnackbar() }  // handle error
    )

fun showErrorSnackbar() {
        Snackbar.make(listView, getString(R.string.not_available_msg), Snackbar.LENGTH_INDEFINITE)
                .setAction(getString(R.string.snack_retry_btn), {
                    // retry observable
                })
                .show()
    }
</code></pre>

<p>Cities interface for retrofit:</p>

<pre><code>interface CitiesService {

    @GET(""api/v1/cities"")
    fun cities(): Observable&lt;List&lt;String&gt;&gt;

    @GET(""api/v1/cities/{city}/coordinates"")
    fun coordinates(@Path(""city"") city: String): Observable&lt;DoubleArray&gt;
}
</code></pre>

<p>Api factory:</p>

<pre><code>object ApiFactory {

    val citiesService: CitiesService
        get() = retrofit.create(CitiesService::class.java)

    private val retrofit: Retrofit
        get() = Retrofit
            .Builder()
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(BASE_URL)
            .build()
}
</code></pre>

<p>How can I restart the observable in such way?</p>
",4589262,,4589262,,2016-04-23 10:59:33,2017-03-28 21:47:05,RxAndroid - retry observable on click,<android><rx-java><retrofit2><rx-android><rx-kotlin>,1,3,2,,,CC BY-SA 3.0
37421742,1,37423378,0,2016-05-24 18:57:18,,4,2837,"<p>I know this breaks a lot of Rx rules, but I really like <a href=""https://github.com/davidmoten/rxjava-jdbc"" rel=""nofollow"">RxJava-JDBC</a> and so do my teammates. Relational databases are very core to what we do and so is Rx.</p>

<p>However there are some occasions where we do not want to emit as an <code>Observable&lt;ResultSet&gt;</code> but would rather just have a pull-based Java 8 <code>Stream&lt;ResultSet&gt;</code> or Kotlin <code>Sequence&lt;ResultSet&gt;</code>. But we are very accustomed to the RxJava-JDBC library which only returns an <code>Observable&lt;ResultSet&gt;</code>. </p>

<p>Therefore, I am wondering if there is a way I can turn an <code>Observable&lt;ResultSet&gt;</code> into a <code>Sequence&lt;ResultSet&gt;</code> using an extension function, and not do any intermediary collection or <code>toBlocking()</code> calls. Below is all I have so far but my head is spinning now trying to connect push and pull based systems, and I cannot buffer either as the <code>ResultSet</code> is stateful with each <code>onNext()</code> call. Is this an impossible task?</p>

<pre><code>import rx.Observable
import rx.Subscriber
import java.sql.ResultSet

fun Observable&lt;ResultSet&gt;.asSequence() = object: Iterator&lt;ResultSet&gt;, Subscriber&lt;ResultSet&gt;() {

    private var isComplete = false

    override fun onCompleted() {
        isComplete = true
    }

    override fun onError(e: Throwable?) {
        throw UnsupportedOperationException()
    }

    override fun onNext(rs: ResultSet?) {
        throw UnsupportedOperationException()
    }


    override fun hasNext(): Boolean {
        throw UnsupportedOperationException()
    }

    override fun next(): ResultSet {
        throw UnsupportedOperationException()
    }

}.asSequence()
</code></pre>
",1373258,,1373258,,2016-05-24 19:25:19,2016-05-25 05:10:26,"RxJava- Turn Observable into Iterator, Stream, or Sequence",<stream><sequence><rx-java><kotlin><rx-kotlin>,2,3,2,,,CC BY-SA 3.0
38666086,1,38670838,0,2016-07-29 19:19:01,,3,880,"<p>I'm trying to port an RxJava library and leverage extension functions in Kotlin.</p>

<pre><code>fun &lt;T,R: MutableCollection&lt;T&gt;&gt; Observable&lt;T&gt;.collectWhile(factory: (() -&gt; R), condition: (R,T) -&gt; Boolean) =
        compose(Transformers.collectWhile(factory,condition))
</code></pre>

<p>The <code>Transformers.collectWhile()</code> is written in Java and has this signature: </p>

<pre><code>public static &lt;T, R extends Collection&lt;T&gt;&gt; Transformer&lt;T, R&gt; collectWhile(final Func0&lt;R&gt; factory,
            final Action2&lt;? super R, ? super T&gt; collect)
</code></pre>

<p>However, I am getting an issue with mapping the <code>collect</code> argument and I'm not good at generics. How do I express <code>super</code> with a functional type?</p>

<p><strong>UPDATE</strong></p>

<p>Stupid mistake on my part. I should not have been posting on SO late at night. </p>

<p>I was actually targeting this</p>

<pre><code>public static &lt;T, R extends Iterable&lt;?&gt;&gt; Transformer&lt;T, R&gt; collectWhile(final Func0&lt;R&gt; factory,
        final Action2&lt;? super R, ? super T&gt; collect, final Func2&lt;? super R, ? super T, Boolean&gt; condition)
</code></pre>

<p>And this is what I should have done. </p>

<pre><code>fun &lt;T,R: MutableCollection&lt;T&gt;&gt; Observable&lt;T&gt;.collectWhile(factory: (() -&gt; R), action: (R,T) -&gt; Unit, condition: (R,T) -&gt; Boolean) =
    compose(Transformers.collectWhile(factory,action,condition))
</code></pre>
",1373258,,1373258,,2016-07-30 18:02:52,2016-07-30 18:02:52,"Expressing ""super"" generics in Kotlin functional types?",<java><generics><rx-java><kotlin><rx-kotlin>,1,1,1,,,CC BY-SA 3.0
39057409,1,39069635,0,2016-08-20 18:25:27,,0,538,"<p>Here's a fun RxJava problem. </p>

<p>I want to use RxJava backpressure operators to quickly lookup a typed input while each character is being typed, much like Google does on its search page. I went through the <a href=""https://github.com/ReactiveX/RxJava/wiki/Backpressure"" rel=""nofollow"">Backpressure</a> documentation and I came up with this (I am using RxJavaFX/RxKotlinFX to leverage JavaFX). </p>

<pre><code>val myControl: Node = ...
val burstyMulticast = myControl.events(KeyEvent.KEY_TYPED).publish().refCount()
val burstyDebounced = burstyMulticast.debounce(200, TimeUnit.MILLISECONDS)
val burstyBuffered = burstyMulticast.buffer(burstyDebounced)

burstyBuffered
        .flatMap { it.toObservable().map { it.character }.reduce("""") { x,y -&gt; x + y } }
        .subscribe { println(it) }
</code></pre>

<p>This works great. If I type ""Hello"" against the control it will emit the <code>String</code> ""Hello"" after 200 ms of no typing. But if I want this to truly be more responsive, I should actually have some sort of rolling accumulation for each keystroke input.  Then my console output should really look like this:</p>

<pre><code>H
He
Hel
Hell
Hello
</code></pre>

<p>Those should be all my emissions when I type the word ""Hello"", and the 200ms defines how much time should elapse before the accumulation resets. How do I do this?</p>
",1373258,,1373258,,2016-08-22 03:42:44,2016-08-22 03:42:44,RxJava - Backpressuring keyboard inputs?,<javafx><rx-java><kotlin><backpressure><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
40335952,1,0,0,2016-10-31 02:48:00,,8,6455,"<p>I have got <code>Observable&lt;Rates&gt;</code> and Rate is just a simple object: </p>

<pre><code>Rate(val value:String){}
Rates(val rates: List&lt;Rate&gt;)
</code></pre>

<p>and i wanna change that <code>Observable&lt;Rates&gt;</code> into <code>Observable&lt;HashMap&lt;String,Long&gt;</code>. </p>

<p>so for example for rates <code>Rates(arrayOf(Rate(""1""),Rate(""2""), Rate(""3""),Rate(""3""), Rate(""2""),Rate(""2"")))</code> i expect result: </p>

<pre><code>(1 -&gt; 1)
(2 -&gt; 3)
(3 -&gt; 2)
(4 -&gt; 0)
(5 -&gt; 0)
</code></pre>

<p>I start creating something like that : </p>

<pre><code>service.getRates()
        .flatMap {it-&gt; Observable.from(it.rates) }
        .filter { !it.value.isNullOrEmpty() }
        .groupBy {it -&gt; it.value}
        .collect({ HashMap&lt;String,Long&gt;()}, { b, t -&gt; b.put(t.key, t.count???)}
</code></pre>

<p>but I am stuck here and i do not know count all values? and i do not know how to add empty values (0) if there is no 5 of 4. Is there any way to do this using rx? </p>
",1568605,,1137789,,2016-10-31 12:39:27,2016-10-31 12:39:27,How to do a groupBy and collect using RxJava and Kotlin?,<rx-java><reactive-programming><kotlin><rx-kotlin>,3,0,1,,,CC BY-SA 3.0
40630716,1,40661241,0,2016-11-16 11:14:02,,3,1491,"<p>We're trying to observe either a 15s interval, or whenever we're firing <code>onNext</code> on our subject <code>refreshEventsSubject</code>, but without success.</p>

<p>The subject is initiated like so</p>

<p><code>private val refreshEventsSubject = PublishSubject&lt;Long&gt;()</code></p>

<p>And then we try to observe it like this</p>

<p><code>Observable.merge(Observable.interval(0, 15, TimeUnit.SECONDS), refreshEventsSubject)
    .subscribe { ... }</code></p>

<p>We get the events from the interval every 15s, but the subject is not firing after running</p>

<p><code>refreshEventsSubject.onNext(0)</code></p>

<p>Any ideas appreciated.</p>

<p>(Everything is written in Kotlin)</p>
",1639409,,1639409,,2016-11-16 11:35:15,2016-11-17 17:21:24,"RxJava(Kotlin), Observable.amb and PublishSubject is not firing",<android><rx-java><kotlin><rx-kotlin>,2,2,0,,,CC BY-SA 3.0
40818410,1,40819077,0,2016-11-26 12:39:42,,10,17952,"<p>I have some problem. I'm a beginer in RxJava/RxKotlin/RxAndroid, and dont understand some features. For Example:</p>

<pre><code>import rus.pifpaf.client.data.catalog.models.Category
import rus.pifpaf.client.data.main.MainRepository
import rus.pifpaf.client.data.main.models.FrontDataModel
import rus.pifpaf.client.data.product.models.Product
import rx.Observable
import rx.Single
import rx.lang.kotlin.observable
import java.util.*


class MainInteractor {

    private var repository: MainRepository = MainRepository()

    fun getFrontData() {

        val cats = getCategories()
        val day = getDayProduct()
        val top = getTopProducts()

        return Observable.zip(cats, day, top, MainInteractor::convert)
    }

    private fun getTopProducts(): Observable&lt;List&lt;Product&gt;&gt; {
        return repository.getTop()
                .toObservable()
                .onErrorReturn{throwable -&gt; ArrayList() }

    }

    private fun getDayProduct(): Observable&lt;Product&gt; {
        return repository.getSingleProduct()
                .toObservable()
                .onErrorReturn{throwable -&gt; Product()}

    }

    private fun getCategories(): Observable&lt;List&lt;Category&gt;&gt; {
        return repository.getCategories()
                .toObservable()
                .onErrorReturn{throwable -&gt; ArrayList() }
    }

    private fun convert(cats: List&lt;Category&gt;, product: Product, top: List&lt;Product&gt;): FrontDataModel {

    }
}
</code></pre>

<p>Then I'm use <strong>MainInteractor::convert</strong> Android studio tell me next</p>

<p><a href=""https://i.stack.imgur.com/Caoua.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Caoua.jpg"" alt=""enter image description here""></a></p>

<p>I tried a lot of variant and tried to understand what does it want, but no success. Help me please... Best Regards.</p>
",3775934,,3775934,,2019-10-08 10:54:03,2021-01-27 21:18:18,How to zip few observables in Kotlin language with RxAndroid,<android><rx-java><kotlin><rx-android><rx-kotlin>,3,0,1,,,CC BY-SA 4.0
41223466,1,41608056,0,2016-12-19 13:17:20,,2,1378,"<p>RuntimeExceptions are supposed to indicate programming error and I want my application to crash when something inside my observables throws RuntimeException. </p>

<p>What is the best way to do this? Right now I'm considering this solution (it's Kotlin, but I hope it's understandable)</p>

<pre><code>fun &lt;T&gt; Observable&lt;T&gt;.subscribeCrashOnRuntimeException(onNext: (T) -&gt; Unit, onError: (Throwable) -&gt; Unit) {
  this.subscribe({
    onNext(it)
  }, { e -&gt;
    if (e is RuntimeException) {
      throw e
    } else {
      onError(e)
    }
  })
}

fun usageExample() {
  val observable = Observable.just(1)
  observable.subscribeCrashOnRuntimeExceptions(
    { next -&gt; Log.d(""TAG"", ""next: $next"") },
    { e -&gt; Log.d(""TAG"", ""error: $e"") }
  )
}
</code></pre>

<p>But I have doubts about it. For example it is hard to occasionally ""catch"" specific RuntimeExceptions with this solution. Perhaps there is a well known way to deal with situation that I just don't know how to google?</p>
",544406,,697313,,2017-01-12 11:27:52,2017-01-12 11:51:51,RuntimeException handling best practices,<android><rx-java><rx-kotlin>,1,3,1,,,CC BY-SA 3.0
41987704,1,41990290,0,2017-02-01 19:08:56,,1,306,"<p>I thought this is how it works, seems like I'm missing something..</p>

<pre><code>@Test
fun singleCompletes()
{
    val testSubscriber = TestSubscriber&lt;Boolean&gt;()

    Single.just(true)
            .subscribeOn(Schedulers.immediate())
            .subscribe { testSubscriber }

    testSubscriber.assertNoErrors()
    testSubscriber.assertValue(true)
}
</code></pre>

<blockquote>
  <p>java.lang.AssertionError: Number of items does not match. Provided: 1  Actual: 0.</p>
</blockquote>
",2192545,,0,,,2017-02-01 21:40:45,RxKotlin - Single.just() does not emit when subscribing TestSubscriber,<kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
42066066,1,42126960,0,2017-02-06 10:55:51,,83,26971,"<p>Why would I want to use Kotlin's coroutines?</p>
<p>It seems that the RxKotlin library is much more versatile.
Kotlin's coroutines look significantly less powerful and more cumbersome to use in comparison.</p>
<p>I base my opinion on coroutines on <a href=""https://www.youtube.com/watch?v=4W3ruTWUhpw"" rel=""noreferrer"">this design talk by Andrey Breslav (JetBrains)</a></p>
<p>Slideshow from the talk is <a href=""https://www.slideshare.net/abreslav/jvmls-2016-coroutines-in-kotlin"" rel=""noreferrer"">accessible here.</a></p>
<hr />
<p>EDIT (thanks to @hotkey):</p>
<p>Better source on the current state of coroutines <a href=""https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md"" rel=""noreferrer"">here.</a></p>
",3160531,,13363205,,2020-07-26 21:55:18,2021-01-10 10:39:13,How Kotlin coroutines are better than RxKotlin?,<kotlin><rx-kotlin>,5,0,41,,,CC BY-SA 4.0
42727899,1,0,0,2017-03-10 21:20:29,,-1,1460,"<p>So I have an observable with a debounce of 300ms.<br>
It does an API-call after a key-up event.</p>

<p>There's an API-lock in place to prevent future calls until it is completed, but I would also like to check if the observable is running (that's making the API call) and stop it.</p>

<p>How would this be accomplished?</p>
",2368378,,2368378,,2017-03-10 21:40:53,2017-03-10 21:40:53,How do I check if an observable is running and stop it?,<android><thread-safety><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
42772319,1,42774592,0,2017-03-13 19:55:38,,0,87,"<p>I'm trying to write an Android app with Kotlin. Now, I want to show a counter in the ActionBar. I added an item called show_timer for that. Each second, it should count up by one:</p>

<pre><code>override fun onWindowFocusChanged(hasFocus: Boolean) {
    val item = findViewById(R.id.show_timer) as ActionMenuItemView
    PublishSubject.interval(1, java.util.concurrent.TimeUnit.SECONDS, Schedulers.newThread())
            .subscribeBy(onNext = {item.text = it.toString()})

    super.onWindowFocusChanged(hasFocus)
}
</code></pre>

<p>But somehow this doesn't work. It updates the default text to 0, but after that it does nothing. Does someone know why this doesn't work?</p>

<p>Thank you in advance,</p>

<p>Niklas</p>
",7544860,,0,,,2017-03-13 22:30:09,Can't Change Text of ActionMenuItemView with RxKotlin,<android><system.reactive><kotlin><rx-kotlin>,1,2,0,,,CC BY-SA 3.0
42927824,1,0,0,2017-03-21 12:56:54,,0,208,"<p>is it possible to send the same object to subscribers in Rx repeatedly? 
For exmaple this code(on Kotlin): </p>

<pre><code> val exmp = listOf(""–ê"")
        var observable = exmp.toObservable()
            observable.subscribeBy(
                    onNext = {
                        it + ""1""
                        println(it)
                    },
                    onError = { it.printStackTrace() },
                    onComplete = { println(""Done!"") }
            )
</code></pre>

<p>I try to send string value ""A"" repeatedly to method onNext() and get ""A111111"". 
Method replay() of Rx library as I understand starting sending date again for new subsribers. In circle <code>for</code> date from observable not changing, just  method is called several times</p>
",7745622,,0,,,2017-03-21 14:45:36,Repeat sending object to subsriber on Rx,<rx-java><reactive-programming><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
43285064,1,43320828,0,2017-04-07 18:40:43,,20,8756,"<p>I'm trying to test the following RxKotlin/RxJava 2 code:</p>

<pre class=""lang-java prettyprint-override""><code>validate(data)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .flatMap { ... }
</code></pre>

<p>I'm attempting to override the schedulers as follows:</p>

<pre class=""lang-java prettyprint-override""><code>// Runs before each test suite
RxJavaPlugins.setInitIoSchedulerHandler { Schedulers.trampoline() }
RxAndroidPlugins.setInitMainThreadSchedulerHandler { Schedulers.trampoline() }
</code></pre>

<p>However, I get the following error when running the test:</p>

<pre class=""lang-java prettyprint-override""><code>java.lang.ExceptionInInitializerError
...
Caused by: java.lang.NullPointerException: Scheduler Callable result can't be null
    at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39)
    at io.reactivex.plugins.RxJavaPlugins.applyRequireNonNull(RxJavaPlugins.java:1317)
    at io.reactivex.plugins.RxJavaPlugins.initIoScheduler(RxJavaPlugins.java:306)
    at io.reactivex.schedulers.Schedulers.&lt;clinit&gt;(Schedulers.java:84)
</code></pre>

<p>Has anyone experienced this problem? </p>

<hr>

<p>The test worked fine when using RxKotlin/RxJava 1 and the following scheduler overrides:</p>

<pre class=""lang-java prettyprint-override""><code>RxAndroidPlugins.getInstance().registerSchedulersHook(object : RxAndroidSchedulersHook() {
    override fun getMainThreadScheduler() = Schedulers.immediate()
})

RxJavaPlugins.getInstance().registerSchedulersHook(object : RxJavaSchedulersHook() {
    override fun getIOScheduler() = Schedulers.immediate()
})
</code></pre>
",1261256,,1000551,,2019-11-06 10:06:31,2019-11-26 17:20:37,RxJava 2 overriding IO scheduler in unit test,<kotlin><rx-java><rx-kotlin>,4,4,7,,,CC BY-SA 4.0
43564621,1,0,0,2017-04-22 21:06:33,,7,4652,"<p>I'm trying to observe observable on main thread by using:</p>

<pre><code>    // Kotlin Code
    Observable
      .observeOn(AndroidSchedulers.mainThread())
</code></pre>

<p>but I'm getting following error:</p>

<pre><code>    Type Mismatch:
      Required: rx.Scheduler!
      Found: io.reactivex.Scheduler!
</code></pre>

<p>The Observable I'm subscribing to is from a Library that is written in Java and therefore uses RxJava.</p>

<p>Am i being stupid and missing something? I'm puzzeled :$</p>

<p>Thanks in advance :)</p>
",6411538,,0,,,2021-02-19 01:10:08,Cant 'observeOn' main thread with RxKotlin,<android><kotlin><rx-java2><rx-kotlin><kotlin-interop>,4,2,2,,,CC BY-SA 3.0
43681939,1,0,0,2017-04-28 13:54:04,,4,1717,"<p>In a JavaFX Gradle-based application that I develop using RxJava and Kotlin in IntelliJ IDEA 2017.1.2 (Build #IC-171.4249.39), I'm getting an exception:</p>

<blockquote>
  <p>Exception in thread ""JavaFX Application Thread"" java.lang.NoClassDefFoundError: org/reactivestreams/Publisher</p>
</blockquote>

<p>everytime a code like this</p>

<pre><code>return Completable.complete()
</code></pre>

<p>is executed. Following a suggestion of a similar question <a href=""https://stackoverflow.com/questions/43231477/why-i-am-getting-noclassdeffounderror-org-reactivestreams-publisher"">Why I am getting NoClassDefFoundError: org/reactivestreams/Publisher</a>, I've tried to add include the reactive-streams to the <code>dependencies</code> block of my <code>build.gradle</code> script</p>

<pre><code>dependencies {
    compile 'org.jetbrains.kotlin:kotlin-stdlib:1.1.2'
    compile 'org.reactivestreams:reactive-streams:1.0.0'
    compile 'io.reactivex.rxjava2:rxkotlin:2.0.0'
}
</code></pre>

<p>but the problem persists. The dependency tree looks like this one:</p>

<pre><code>compile - Dependencies for source set 'main' (deprecated, use 'implementation ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

compileClasspath - Compile classpath for source set 'main'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

\--- org.jetbrains.kotlin:kotlin-annotation-processing:1.1.2
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
          \--- org.jetbrains:annotations:13.0

kaptTest
\--- org.jetbrains.kotlin:kotlin-annotation-processing:1.1.2
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
          \--- org.jetbrains:annotations:13.0

runtime - Runtime dependencies for source set 'main' (deprecated, use 'runtimeOnly ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

runtimeClasspath - Runtime classpath of source set 'main'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testCompile - Dependencies for source set 'test' (deprecated, use 'testImplementation ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testCompileClasspath - Compile classpath for source set 'test'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testRuntime - Runtime dependencies for source set 'test' (deprecated, use 'testRuntimeOnly ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testRuntimeClasspath - Runtime classpath of source set 'test'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)
</code></pre>

<p>As you can see, <strong>org.reactivestreams:reactive-streams</strong> is present in each environment. </p>

<p>Now, I've managed to resolve the problem by adding manually dependency on a <a href=""https://jar-download.com/?detail_search=g%3A%22io.reactivex.rxjava2%22&amp;g=io.reactivex.rxjava2"" rel=""nofollow noreferrer"">reactive-streams-1.0.0.jar</a>, but I don't like this solution at all. </p>

<p>Could somebody advice a better solution? Thanks!</p>
",2114895,,-1,,2017-05-23 10:31:25,2017-05-08 14:58:51,Exception caused by: java.lang.ClassNotFoundException: org.reactivestreams.Publisher,<intellij-idea><gradle><kotlin><rx-java2><rx-kotlin>,0,1,1,,,CC BY-SA 3.0
43771854,1,43774178,0,2017-05-04 00:00:00,,3,872,"<p>I am trying to get a better understanding of how to do unit tests with Rx-Kotlin, but I have not been able to successfully set the subject to ""completed"". As a result, I am always waiting for the timeout of 5 seconds (the onComplete should be immediate) and then fail on assertComplete.</p>

<p>My understanding of <a href=""http://reactivex.io/RxJava/javadoc/rx/observers/TestSubscriber.html#awaitTerminalEvent()"" rel=""nofollow noreferrer"">awaitTerminalEvent</a> is that it should only block until the onComplete is called. I have also looked into <a href=""http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html"" rel=""nofollow noreferrer"">TestScheduler,</a> but I do not believe that it should be required here. </p>

<p>Any help or documentation that can lead me in the right direction would be much appreciated.</p>

<pre><code>@Test
fun testObservable() {
    val subject = BehaviorSubject.create&lt;Int&gt;()
    subject.onNext(0)

    TestSubscriber&lt;Int&gt;().apply {
        subject.subscribe({
            System.out.println(it)
            subject.onNext(1)
            subject.onComplete()
        })

        this.awaitTerminalEvent(5, TimeUnit.SECONDS)
        this.assertComplete()
        this.assertValue(1)
    }
}
</code></pre>
",2461717,,3903847,,2017-05-04 04:57:25,2017-05-04 04:57:25,Rx-Kotlin awaitTerminalEvent never getting onComplete,<unit-testing><testing><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
43807056,1,43807850,0,2017-05-05 14:04:38,,9,6075,"<p>In an app that connects to bluetooth devices, I am using the following function using RxKotlin:</p>

<pre><code>private fun startBluetoothPair(device: BluetoothDevice) {
    Observable.just(device)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .map {
            var uuid: UUID = BLUETOOTH_UUID
            var socket = it.createRfcommSocketToServiceRecord(uuid)
            socket.connect()
            return socket
        }
        .subscribe {
            // Do something with the BluetoothSocket
        }
}
</code></pre>

<p>This function should simply connect with the bluetoothdevice on the background and then do something with the socket (in the mainthread again). However, the <code>map</code> can't handle the <code>return socket</code> part, telling me there is a <code>Type mismatch</code>, it found a <code>BluetoothSocket</code> where it required a <code>Unit</code>.</p>

<p>What is going wrong here? I thought a map should be able to infer the return type.</p>
",1506976,,0,,,2021-02-03 06:40:33,Rx Kotlin: map function can't infer return type,<android><reactivex><rx-kotlin>,2,3,2,,,CC BY-SA 3.0
43821571,1,43822648,0,2017-05-06 14:22:47,,3,1349,"<p>I have a Observables which emits some numbers and I simply want to take last N elements. </p>

<p>I have following code (I'm using RxKotlin which is simply a wrapper on RxJava):</p>

<pre><code>val list = listOf(1,2,3,4,5,6,7,8,9,10)
Observable.fromIterable(list)
          .buffer(3, 1)
          .lastOrError()
          .subscribe{value -&gt; println(value)}
</code></pre>

<p>Unfortunately the result is <code>[10]</code>, as I looked closer what the buffer operator returns, I saw this:</p>

<pre><code>[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
[9, 10]
[10] 
</code></pre>

<p>is there a way to get last ""full"" buffer -> <code>[8, 9, 10]</code> ?</p>
",2794332,,2794332,,2017-05-06 14:28:01,2017-05-06 16:13:01,Get N last objects emitted by observable in RxJava2,<java><kotlin><reactive-programming><rx-java2><rx-kotlin>,1,0,1,,,CC BY-SA 3.0
43945068,1,0,0,2017-05-12 19:22:03,,1,1291,"<p>(Working in RxKotlin and RxJava, but using metacode for simplicity)</p>

<p>Many <code>Reactive Extensions</code> guides begin by creating an <code>Observable</code> from already available data.  From <a href=""https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"" rel=""nofollow noreferrer"">The introduction to Reactive Programming you've been missing</a>, it's created from a single string</p>

<pre><code>var soureStream= Rx.Observable.just('https://api.github.com/users');
</code></pre>

<p>Similarly, from the frontpage of <a href=""https://github.com/ReactiveX/RxKotlin"" rel=""nofollow noreferrer"">RxKotlin</a>, from a populated list</p>

<pre><code>val list = listOf(1,2,3,4,5)
list.toObservable()     
</code></pre>

<p>Now consider a simple filter that yields an <code>outStream</code>,  </p>

<pre><code>var outStream = sourceStream.filter({x &gt; 3})
</code></pre>

<p>In both guides the source events are declared <em>apriori</em>.  Which means the timeline of events has some form</p>

<pre><code>source: ----1,2,3,4,5-------
out:    --------------4,5---
</code></pre>

<p>How can I modify <code>sourceStream</code> to become more of a pipeline?  In other words, no input data is available during <code>sourceStream</code> creation?  When a source event becomes available, it is immediately processed by out:</p>

<pre><code>source: ---1--2--3-4---5-------
out:    ------------4---5-------
</code></pre>

<p>I expected to find an <code>Observable.add()</code> for dynamic updates</p>

<pre><code>var sourceStream = Observable.empty()
var outStream = sourceStream.filter({x&gt;3})

//print each element as its added 
sourceStream .subscribe({println(it)})
outStream.subscribe({println(it)})

for i in range(5):
    sourceStream.add(i)
</code></pre>

<p>Is this possible?</p>
",4076764,,4076764,,2017-05-12 19:30:10,2017-05-14 01:48:58,How to dynamically update an RX Observable?,<java><rx-java><reactive-programming><rx-kotlin>,1,9,0,,,CC BY-SA 3.0
43945102,1,43945802,0,2017-05-12 19:25:06,,2,2511,"<p>I'm kind of new to Kotlin and I'm trying to Inject a value (in this example it is just an Int but in the real code it is a Provider class)
What am I doing wrong here? and why is x is an unresolved reference?</p>

<pre><code>class Test
@Inject constructor(private val x: Int) {

companion object {
    var y: Int = 0

        @BeforeClass @JvmStatic
        fun beforeClass() {
            y = x * 2
        }
    }
}
</code></pre>
",2811244,,1502352,,2017-05-12 20:19:48,2017-05-12 20:19:48,Inject constructor and companion object,<java><junit><kotlin><guice><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
44211577,1,44211963,0,2017-05-26 23:57:14,,1,96,"<p>In Kotlin the final statement of a function can be interpreted as its return value.</p>

<p>Can a situation like the following example be simplified to be less verbose?</p>

<pre><code>{ text: String -&gt;
  val validated = validateText(text)
  if (validated) {
    actOnValidation()
  }
  validated
}
</code></pre>

<p>A concrete case where I would like to do this is below in an example using RxJava - even if there's a better Rx approach I'm also interested in a pure Kotlin solution if it exists.</p>

<pre><code>fun inputChainObservable(targetField: TextView, chainedField: TextView): Observable&lt;Boolean&gt; {
  return targetField.textChanges()
      .observeOn(AndroidSchedulers.mainThread())
      .map { cs: CharSequence? -&gt;
        val hasInput = validateText(cs.toString())
        if (hasInput) {
          chainedField.requestFocus()
        }
        hasInput
      }
}
</code></pre>
",2087534,,0,,,2017-05-27 01:12:32,"For a Kotlin function used as an expression, is there concise way to operate on and return a value?",<android><rx-java><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
44245780,1,44246048,0,2017-05-29 15:15:43,,1,576,"<p>I'm converting some Java code to Kotlin and I'm having some trouble with <code>flattenAsObservable()</code></p>

<p>Here's what the code looked like in Java:</p>

<pre><code>discogsInteractor.search(query)
    .map(RootSearchResponse::getSearchResults)
    .flattenAsObservable(searchResults -&gt; searchResults)
    .take(12)
</code></pre>

<p>Here's what I have so far in Kotlin:</p>

<pre><code>discogsInteractor.search(query)
    .map { RootSearchResponse::searchResults }
    .flattenAsObservable&lt;SearchResult&gt; { searchResults -&gt; searchResults }
    .take(12)
</code></pre>

<p>It underlines the second <code>searchResults</code> and gives me the following error:</p>

<pre><code>Required: (Mutable)Iterable&lt;SearchResult!&gt;!
Found: KProperty1&lt;RootSearchResponse, List&lt;SearchResult&gt;&gt;!
</code></pre>

<p>I can replace </p>

<pre><code>.map { RootSearchResponse::searchResults }
</code></pre>

<p>with </p>

<pre><code>.map { searchResponse -&gt; searchResponse.searchResults }
</code></pre>

<p>and it will work. How do I correctly method reference? Or what's the reason that I can't in this instance?</p>

<p><strong>RootSearchResponse:</strong></p>

<pre><code>data class RootSearchResponse(val pagination: Pagination,
                              @SerializedName(""results"") val searchResults: List&lt;SearchResult&gt;)
</code></pre>
",4624156,,0,,,2017-05-29 15:31:18,RxKotlin flattenAsObservable(): type mismatch with method reference,<kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
44274144,1,0,0,2017-05-31 01:10:15,,1,99,"<p>This is in Kotlin, but I think anyone who writes Java will be able to understand.</p>

<p>I'm trying to make a stopwatch with Rx and I'm having a little trouble with doing the actual stopping and starting. The big problem is that I don't know how to keep the current time, while modifying it as different actions (starting and stopping) come in. Here's what I've got right now.</p>

<pre><code>fullTime.switchMap { startTime -&gt;
    controlCommands.switchMap { command -&gt;
        when (command) {
            ControlState.PLAY -&gt; Observable.interval(1L, TimeUnit.SECONDS).map {
                ControlState.PLAY
            }
            ControlState.PAUSE -&gt; Observable.just(ControlState.PAUSE)
            else -&gt; Observable.just(ControlState.STOP)
        }
    }
}
</code></pre>

<p>Where <code>fullTime</code> and <code>controlCommands</code> are <code>Observable</code>s that emit events about the current starting time to count down from and say what to do next, respectively. I want to chain off of <code>controlCommands</code> and be able to keep state starting at <code>startTime</code> that will count down when a <code>PLAY</code> event appears, pause when <code>PAUSE</code> appears, and reset at <code>startTime</code> when <code>STOP</code> appears.</p>

<p><code>scan</code> almost works, but I don't know how to stop after the timer hits 0 and <code>PLAY</code> is still being sent every second, since it would be sending duplicate info. Also it doesn't allow a separation between the state and the observed value. So the value I accumulate with <code>scan</code> has to be the same type as the value inside the <code>Observable</code> (if that makes sense).</p>

<p>Any ideas what I should do?</p>
",1828448,,0,,,2017-05-31 05:43:43,Repeating actions on state with RxJava,<java><rx-java><kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
44525885,1,44525981,0,2017-06-13 15:34:49,,6,926,"<p>I've been working through the examples in the book <a href=""https://www.amazon.co.uk/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1497368108&amp;sr=1-1&amp;keywords=reactive%20programming%20with%20rxjava"" rel=""noreferrer"">Reactive Programming with RxJava</a>, which is targeted at version 1 not 2. An introduction to infinite streams has the following example (and notes there are better ways to deal with the concurrency):</p>

<pre><code>Observable&lt;BigInteger&gt; naturalNumbers = Observable.create(subscriber -&gt; {
    Runnabler = () -&gt; {
        BigInteger i = ZERO;
        while (!subscriber.isUnsubscribed()) {
            subscriber.onNext(i);
            i = i.add(ONE);
        }
    };
    new Thread(r).start();
});

...

Subscription subscription = naturalNumbers.subscribe(x -&gt; log(x));
/* after some time... */
subscription.unsubscribe();
</code></pre>

<p>However, in RxJava 2, the lambda expression passed to the <code>create()</code> method is of type <code>ObservableEmitter</code> and this doesn't have an <code>isUnsubscribed()</code> method. I've had a look in <a href=""https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0"" rel=""noreferrer"">What's Different in 2.0</a> and also performed a search of the repository but can't find any such method.</p>

<p>How would this same functionality be achieved in 2.0?</p>

<p><strong>Edited to include solution as given below (n.b. using kotlin):</strong></p>

<pre><code>val naturalNumbers = Observable.create&lt;BigInteger&gt; { emitter -&gt;
    Thread({
        var int: BigInteger = BigInteger.ZERO
        while (!emitter.isDisposed) {
            emitter.onNext(int)
            int = int.add(BigInteger.ONE)
        }
    }).start()
}

val first = naturalNumbers.subscribe { log(""First: $it"") }
val second = naturalNumbers.subscribe { log(""Second: $it"") }

Thread.sleep(5)
first.dispose()
Thread.sleep(5)
second.dispose()
</code></pre>
",8086746,,8086746,,2017-06-13 17:11:05,2017-06-13 17:11:05,RxJava 2 equivalent to isUnsubscribed,<rx-java><rx-java2><rx-kotlin>,1,0,1,,,CC BY-SA 3.0
44578211,1,44587447,0,2017-06-15 22:54:48,,3,1588,"<p>The following code is my attempt to convert an RxJava example into Kotlin. It's supposed to collect a bunch of <code>Int</code>'s into a <code>MutableList</code>, but I get a host of errors.</p>

<pre><code>val all: Single&lt;MutableList&lt;Int&gt;&gt; = Observable
        .range(10, 20)
        .collectInto(::MutableList, MutableList::add)
</code></pre>

<p>The errors:</p>

<pre><code>    Error:(113, 36) Kotlin: Type inference failed: Not enough information to infer parameter T in inline fun &lt;T&gt; MutableList(size: Int, init: (index: Int) -&gt; T): MutableList&lt;T&gt;
Please specify it explicitly.

Error:(113, 49) Kotlin: One type argument expected for interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; defined in kotlin.collections

    Error:(113, 67) Kotlin: None of the following functions can be called with the arguments supplied: 
public abstract fun add(element: Int): Boolean defined in kotlin.collections.MutableList
public abstract fun add(index: Int, element: Int): Unit defined in kotlin.collections.MutableList
</code></pre>

<p>If I change <code>ImmutableList::add</code> to <code>ImmutableList&lt;Int&gt;::add</code>, I get rid of the type argument expected error, which is replaced with:</p>

<pre><code>Error:(113, 22) Kotlin: Type inference failed: fun &lt;U : Any!&gt; collectInto(initialValue: U!, collector: ((U!, Int!) -&gt; Unit)!): Single&lt;U!&gt;!
        cannot be applied to
        (&lt;unknown&gt;,&lt;unknown&gt;)
</code></pre>

<p>This is a straight copy of the following in Java:</p>

<pre><code>Observable&lt;List&lt;Integer&gt;&gt; all = Observable
    .range(10, 20)
    .collect(ArrayList::new, List::add);
</code></pre>

<p>I understand that the first error is telling me it's either inferring the incorrect type and I need to be more explicit (where?), but I thought that <code>::MutableList</code> would be the equivalent of <code>() -&gt; MutableList&lt;Int&gt;</code>. The third error is telling me that it can't call any of the <code>add()</code> methods with the arguments, but again, I thought that <code>MutableList::add</code> is equivalent to <code>{ list, value -&gt; list.add(value) }</code>. The fourth error tells me it can't figure out the types being applied to the <code>collector</code>.</p>

<p>If I use a lambda expression instead, there are no errors:</p>

<pre><code>val all: Single&lt;MutableList&lt;Int&gt;&gt; = Observable
        .range(10, 20)
        .collectInto(mutableListOf(), { list, value -&gt; list.add(value) })

all.subscribe { x -&gt; println(x) }
</code></pre>

<p>I'd appreciate some comments on what I'm doing wrong with the method references, as there's clearly something I've misunderstood (looking through the <a href=""https://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11"" rel=""nofollow noreferrer"">Kotlin Language Reference</a>, I'm wondering if it's even a language feature at this time?). Much appreciated.</p>
",8086746,,8086746,,2017-06-16 06:34:29,2017-06-16 10:51:46,RxKotlin collectInto() MutableList using method references,<kotlin><method-reference><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
44617459,1,44637593,0,2017-06-18 17:03:12,,1,480,"<p>I'm trying to wrap my head around how to implement something in RxJava (2.0). It's for Android and I'm using Kotlin, although the choice of platform and language shouldn't matter here.</p>

<p>The idea is that I'd base some sort of MVP architecture on RxJava. In this implementation I'm thinking about an <code>Activity</code> (could be a <code>Fragment</code> or a custom <code>View</code> as well) exposes a stream of values (<code>Boolean</code>s for simplicity) which indicate lifecycle events, or whether the view is attached or detached.</p>

<p>The underlying idea is basically this:</p>

<pre><code>private val lifecycleEvents = PublishSubject.create&lt;Boolean&gt;()
val screenStates: Observable&lt;Boolean&gt; = lifecycleEvents.hide()

override fun onResume() {
    super.onResume()
    lifecycleEvents.onNext(true) // I'm attached!
}

override fun onPause() {
    lifecycleEvents.onNext(false) // I'm detached!
    super.onPause()
}

override fun onDestroy() {
    lifecycleEvents.onComplete() // I'm gone        
    super.onDestroy()
}
</code></pre>

<p>And then from the other end, the Presenter exposes an <code>Observable</code> that is a stream of objects representing screen states - to be rendered by the View. </p>

<p>(This follows the concept explained in this series <a href=""http://hannesdorfmann.com/android/mosby3-mvi-1"" rel=""nofollow noreferrer"">http://hannesdorfmann.com/android/mosby3-mvi-1</a> - which boils down to the fact that the Presenter feeds the View with standalone objects encapsulating screen states in their entirety rather than multiple different methods on the View). </p>

<p>And then I'd like to bind these two observable streams so that:</p>

<ul>
<li><p>Whenever the View gets detached, input from the Presenter is disregarded (and it's not buffered, so as not to run into any backpressure problems)</p></li>
<li><p>However, once the View gets reattached, it picks up the <em>latest</em> state the Presenter emmitted. In other words, only one state instance is to be buffered at most.</p></li>
</ul>

<p>It would work as follows (assuming the states are of <code>String</code> type for simplicity):</p>

<pre><code>val merged: Observable&lt;String&gt; = ???

val attached = true
val disattached = false        

screenStates.onNext(attached)
fromPresenter.onNext(""state A"")
fromPresenter.onNext(""state B"")

screenStates.onNext(disattached)
fromPresenter.onNext(""state C"") // this won't survive at the end
fromPresenter.onNext(""state D"") // this will ""override"" the previous one.
// as that's the last state from BEFORE the screen is reattached

screenStates.onNext(attached)
// ""state D"" should be replayed at this point, ""state C"" is skipped and lost

fromPresenter.onNext(""state E"")

// what ""merged"" is supposed to have received at this point:
// ""state A"", ""state B"", ""state D"", ""state E""
</code></pre>

<p>I'm not sure what the best, idiomatic solution is. </p>

<p>I tried to implement it as an <code>ObservableTransformer</code>, but I couldn't quite get it right. I believe the transformer should be stateless, whereas my solution gravitated towards explicitly keeping track of what was emmitted and buffering the last element ""manually"" etc., which feels messy and too imperative, so I suppose it's wrong. </p>

<p>I found <a href=""https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableValve.java"" rel=""nofollow noreferrer"">https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableValve.java</a>, but the implementation looks very complex and I can't believe it couldn't be done in a simpler manner (I don't need all the flexibility, I only want something that works for the described usecase).</p>

<p>Any insights would be appreciated, including whether there's something else I should take into consideration still, within the context of Android. Also note that I don't use RxKotlin bindings (I may, I just didn't suppose they should be required here).</p>

<p><strong>EDIT:</strong></p>

<p>Below is my current implementation. As I said, I'm not too happy about it because it's explicitly stateful, and I believe this should be achieved declaratively, leveraging some constructs of RxJava.</p>

<p>I needed to merge two streams of different types, and because <code>combineLatest</code> nor <code>zip</code> didn't quite do it, I resorted to a trick, creating a common wrapper for both distinct type of events. It introduces certain overhead again.</p>

<pre><code>sealed class Event
class StateEvent(val state: String): Event()
class LifecycleEvent(val attached: Boolean): Event()

class ValveTransformer(val valve: Observable&lt;Boolean&gt;) : ObservableTransformer&lt;String, String&gt; {
    var lastStateEvent: Event? = null
    var lastLifecycleEvent = LifecycleEvent(false)

    private fun buffer(event: StateEvent) {
        lastStateEvent = event
    }

    private fun buffer(event: LifecycleEvent) {
        lastLifecycleEvent = event
    }

    private fun popLastState(): String {
        val bufferedState = (lastStateEvent as StateEvent).state
        lastStateEvent = null
        return bufferedState
    }

    override fun apply(upstream: Observable&lt;String&gt;): ObservableSource&lt;String&gt; = Observable
            .merge(
                    upstream.map(::StateEvent).doOnNext { buffer(it) }, 
                    valve.distinctUntilChanged().map(::LifecycleEvent).doOnNext { buffer (it) })
            .switchMap { when {
                it is LifecycleEvent &amp;&amp; it.attached &amp;&amp; lastStateEvent != null -&gt;
                    // the screen is attached now, pump the pending state out of the buffer
                    just(popLastState())
                it is StateEvent &amp;&amp; lastLifecycleEvent.attached -&gt; just(it.state)
                else -&gt; empty&lt;String&gt;()
            } }
}
</code></pre>
",168719,,168719,,2017-06-18 20:35:30,2017-07-01 18:25:29,"Implementation of a ""valve"" for Observable streams, including buffering the last element emmitted before the valve reopened",<android><rx-java><observable><reactive-programming><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
44627173,1,0,0,2017-06-19 09:44:48,,2,1266,"<p>Is there a better / more idiomatic way to use a <code>Maybe</code> type from JavaRx 2 than <code>flatMap</code> and <code>try/catch</code>? The following example takes a <code>Maybe&lt;User&gt;</code> and tries to book them a random ticket for a flight. If the user doesn't exist, return an empty <code>Observable</code>.</p>

<pre><code>fun bookRandomTicketFor(userId: UUID): Observable&lt;Ticket&gt; {
    val agencies = travelAgents() // Observable&lt;TravelAgency&gt;
    val user = findById(userId) // Maybe&lt;User&gt;
    val location = locate() // Observable&lt;GeoLocation&gt;

    return Observable
            .just(user.toObservable())
            .flatMap { usr -&gt;
                try {
                    usr.zipWith(location, { aUser, location -&gt;
                        agencies
                                .flatMap { agency -&gt;
                                    agency
                                            .search(aUser, location) // Observable&lt;Flight&gt;.
                                            .toList() // Convert to List&lt;Flight&gt;.
                                            .toObservable() // And to Observable&lt;List&lt;Flight&gt;&gt;.
                                            .flatMap { flights -&gt; // So it can be shuffled,
                                                Observable.just( // giving a random order.
                                                        shuffle(flights as MutableList&lt;Flight&gt;)[0]
                                                )
                                            }
                                }.firstElement() // Now take the first randomly shuffled Flight.
                    }).flatMap { flight -&gt;
                        book(user.toObservable(), flight.toObservable())
                    }
                } catch (ex: Exception) {
                    Observable.empty&lt;Ticket&gt;()
                }
            }
            .doOnSubscribe { Logger.log(""Random ticket: start for $userId"") }
            .doOnComplete { Logger.log(""Random ticket: exit for $userId"") }
}
</code></pre>

<p>It seems a bit of a fudge to have to convert the <code>Maybe&lt;User&gt;</code> to an <code>Observable</code> and start with an <code>Observable&lt;Observable&lt;User&gt;&gt;</code> that I can then <code>flatMap</code> and <code>try/catch</code>. Just wondering if there is a neater approach to doing this?</p>
",8086746,,3385212,,2017-06-27 14:01:37,2017-06-27 14:01:37,RxJava2 Maybe return empty Observable if no element,<kotlin><rx-java2><rx-kotlin>,0,1,0,,,CC BY-SA 3.0
44640465,1,44640799,0,2017-06-19 21:44:56,,3,736,"<p>I'm trying to get an example working that uses two different timeout values. An initial larger value for the first emission and then shorter values for all subsequent emissions. The example is converted to Kotlin from Java for RxJava v1x, although I am attempting this is v2x (not sure if that makes any difference). </p>

<p>The problem is that the timeout for the first event doesn't throw a <code>TimeoutException</code>. With the value set below 500ms, I'm expecting a stack trace to be printed, but I get output as if no timeout has occurred (subsequent emissions with timeout set to 40ms results in stack trace as expected). What is wrong with the following example that prevents the initial timeout from succeeding?</p>

<pre><code>fun nextSolarEclipse(after: LocalDate): Observable&lt;LocalDate&gt; {
    return Observable
            .just(
                    LocalDate.of(2016, Month.MARCH, 9),
                    LocalDate.of(2016, Month.SEPTEMBER, 1),
                    LocalDate.of(2017, Month.FEBRUARY, 26),
                    LocalDate.of(2017, Month.AUGUST, 21),
                    LocalDate.of(2018, Month.FEBRUARY, 15),
                    LocalDate.of(2018, Month.JULY, 13),
                    LocalDate.of(2018, Month.AUGUST, 11),
                    LocalDate.of(2019, Month.JANUARY, 6),
                    LocalDate.of(2019, Month.JULY, 2),
                    LocalDate.of(2019, Month.DECEMBER, 26)
            )
            .skipWhile { date -&gt;
                !date.isAfter(after)
            }
            .zipWith(
                    Observable.interval(500, 50, TimeUnit.MILLISECONDS),
                    { date, _ -&gt; date }
            )
}

fun main(args: Array&lt;String&gt;) {
    nextSolarEclipse(LocalDate.now())
            .timeout&lt;Long, Long&gt;(
                    { Observable.timer(400, TimeUnit.MILLISECONDS) },
                    { Observable.timer(40, TimeUnit.MILLISECONDS) }
            )
            .subscribe(
                    { println(it) },
                    { it.printStackTrace() },
                    { println(""Completed"") }
            )

    TimeUnit.MILLISECONDS.sleep(2000)
}
</code></pre>

<p><strong>Edit: 20-Jun-17</strong></p>

<p>With Kotlin 1.1.2-5, using IntelliJ, with the suggested alteration applied, I still get the error. Attempting to run the code anyway results, as I would expect, with:</p>

<p><code>Error:(34, 21) Kotlin: Interface Function does not have constructors</code></p>

<p><a href=""https://i.stack.imgur.com/dM3D1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dM3D1.png"" alt=""Interface Function does not have constructors""></a></p>
",8086746,,8086746,,2017-06-20 13:47:03,2017-06-20 13:47:03,RxKotlin (RxJava2) timeout() doesn't throw TimeoutException,<rx-java><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
44709940,1,44722241,0,2017-06-22 21:54:10,,1,86,"<p>Can someone help me find the proper solution for this problem I face? </p>

<ol>
<li>I have a backend service that give me <code>Observables</code> of the data I need, which are <code>Events</code>.</li>
<li>Form the Event I can get an <code>EventGroup</code>, which contains Ids of all events in the same group.</li>
<li>Next I can get all the <code>Event</code>s that are part of this group.</li>
</ol>

<p>However, I get a <code>Observable&lt;List&lt;Observable&lt;Event&gt;&gt;&gt;</code>, where I'd like to get a <code>Observable&lt;List&lt;Event&gt;&gt;</code>. How can I achive this, without actually subscribing to the nested <code>Observables</code>?</p>

<pre><code>val events : Observable&lt;List&lt;Observable&lt;Event&gt;&gt;&gt; = 
   eventProvider.observable
      .flatMap { myBackend.getEventGroup(it.eventGroupId) }
      .map { 
         it.eventIds.map { myBackend.getEvent(it) } 
      }
</code></pre>

<p><strong>TL:DR</strong></p>

<p>How do I get <code>Observable&lt;List&lt;X&gt;&gt;</code> from a <code>Observable&lt;List&lt;Observable&lt;X&gt;&gt;&gt;</code>?</p>
",3108709,,0,,,2017-06-23 13:07:37,RxJava1: How to convert Observable<List<Observable<X>>> to Observable<List<X>>,<rx-java><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
44883593,1,0,0,2017-07-03 10:43:06,,8,22785,"<p>Am using kotlin for developing the application.Now i want to get JSON data from server. </p>

<p>In java am implemented Asyntask as well as  Rxjava for read JSON from Url . Am also search in google but i cant get proper details for my requirement.</p>

<p>How can i  read JSON from Url  using kotlin?</p>
",3710865,,0,,,2021-01-08 00:10:27,How to read JSON from Url using kotlin Android?,<android><kotlin><rx-kotlin>,7,0,2,,,CC BY-SA 3.0
44997284,1,44997285,0,2017-07-09 14:11:35,,0,652,"<p>Docs in the RxKotlin repository on GitHub doesn't specify a way to explicitly depend on the latest RxJava versionn.</p>

<p>If we see the <code>build.gradle</code> file of the library, it as of now uses <code>compile 'io.reactivex.rxjava2:rxjava:2.1.0'</code></p>

<p>But what if we want to keep up with the latest RxJava releases and not the one present in the library.</p>
",4173071,,0,,,2017-07-10 05:23:06,How to specify the version of RxJava when using RxKotlin?,<android><rx-java><kotlin><rx-java2><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
45118207,1,45126490,0,2017-07-15 12:28:01,,-2,228,"<p>I using rxjava 2 in kotlin but it is not compiling how should i resolve it ?</p>

<pre><code>var emailField = name.textChanges().skipInitialValue().toFlowable(BackpressureStrategy.LATEST)
var passField = password.textChanges().skipInitialValue().toFlowable(BackpressureStrategy.LATEST)

Flowable.combineLatest(emailField,passField, BiFunction { t1, t2 -&gt;  t1.isNotEmpty() &amp;&amp; t2.isNotEmpty()    })
</code></pre>

<p><a href=""https://i.stack.imgur.com/HRSUu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HRSUu.png"" alt=""enter image description here""></a></p>
",3700517,,0,,,2017-07-16 08:19:06,Rxjava with kotlin,<android><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
45195799,1,45200122,0,2017-07-19 16:09:42,,1,1181,"<p>I am writing following code snippet to fetch list of saved food from firebase database and then using that list, I am again fetching individual food details from firebase database.</p>

<p>Following code working fine, except i am unable to figure out how to let second flatMap know that emission of first flatMap has finished(All food list has been processed). So I am unable to call <code>onCompleted()</code> method hence unable to detect when whole process finishes.</p>

<p>Have a look at comments in following snippet:</p>

<pre><code>Observable.create&lt;List&lt;PersonalizedFood&gt;&gt; {

            FirebaseDTDatabase.getSavedDietFoodQuery(user.uid).addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onCancelled(p0: DatabaseError?) {

                }

                override fun onDataChange(p0: DataSnapshot?) {
                    val list = ArrayList&lt;PersonalizedFood&gt;()
                    p0?.let {
                        for (dateObject in p0.children) {
                            for (foodItem in dateObject.children) {
                                val food = foodItem.getValue(FBPersonalizedFood::class.java) as FBPersonalizedFood
                                list.add(PersonalizedFood(food))
                            }
                        }
                    }
                    it.onNext(list)
                    it.onCompleted()
                }
            })
        }.subscribeOn(Schedulers.io()).flatMap {
            Observable.from(it) // returning a Observable that emits items of list (""it"" is the list here) 
        }.observeOn(Schedulers.io()).flatMap {
        // How does this flatMap know that emission of all item has been finished so that onCompleted() method could be called.
            personalizedFood -&gt;

            Observable.create&lt;Boolean&gt;{
                FirebaseDTDatabase.getFoodListReference(personalizedFood.foodId).addListenerForSingleValueEvent(object :ValueEventListener{
                    override fun onCancelled(p0: DatabaseError?) {
                        it.onError(p0?.toException())
                    }

                    override fun onDataChange(p0: DataSnapshot?) {
                        if(p0 != null) {
                            val food = p0.getValue(FBFood::class.java)!!
                            val repo = LocalFoodRepository()
                            doAsync {
                                repo.insertFood(this@LoginActivity, Food(food.foodId, food.foodName, food.foodDesc))
                                repo.insertServingDetails(this@LoginActivity, food.servingList.map { it.component2() })
                                repo.saveFood(this@LoginActivity, personalizedFood)
                                it.onNext(true)
                            }

                        }else {
                            it.onNext(false)
                        }
                    }

                })
            }
        }.observeOn(Schedulers.io()).doOnCompleted{
            dismissProgressDialog()
            finish()
        }.doOnError{
            it.printStackTrace()
            dismissProgressDialog()
            finish()
        }.subscribe()
</code></pre>

<p>Thanks.</p>
",5039950,,0,,,2017-07-19 20:08:50,"RxAndroid, How to detect if observable has finished emission",<android><kotlin><rx-java><rx-android><rx-kotlin>,1,3,0,,,CC BY-SA 3.0
45234134,1,0,0,2017-07-21 09:32:04,,-2,1113,"<p>How can I make it in kotlin using for loop?</p>

<pre><code>for (double i = 0; i &lt; 10.0; i += 0.25) {
    System.out.println(""value is:"" + i);
}
</code></pre>
",7602736,,4467208,,2017-07-21 09:32:48,2020-12-05 21:01:18,How do i make a loop like mentioned below in kotlin programming language?,<android><android-studio><kotlin><rx-kotlin><kotlin-interop>,4,4,0,,,CC BY-SA 3.0
45294524,1,45371201,0,2017-07-25 05:23:01,,19,22684,"<p>I initialize my variable like this:-</p>

<pre><code> val user: BehaviorSubject&lt;User?&gt; user = BehaviorSubject.create()
</code></pre>

<p>But I can't do this. IDE throws an error:-</p>

<pre><code>user.onNext(null)
</code></pre>

<p>And doing this, IDE says u will never be null:-</p>

<pre><code>user.filter( u -&gt; u!=null)
</code></pre>
",4908259,,4908259,,2017-07-25 05:36:33,2021-05-19 17:50:57,How to pass null to an Observable with nullable type in RxJava 2 and Kotlin,<android><kotlin><rx-java><rx-java2><rx-kotlin>,7,7,1,,,CC BY-SA 3.0
45380773,1,45382149,0,2017-07-28 19:09:18,,1,234,"<p>I've got a buffered stream, waiting for a predetermined amount of silence time, before publishing a list of elements that have been buffered:</p>

<pre><code>INTEGERS
     .share()
     .buffer(INTEGERS.debounce(DEBOUNCE_TIME,TimeUnit.MILLISECONDS,scheduler))
     .map { durations -&gt;
       ... 
     }
</code></pre>

<p>I'd like to make <code>DEBOUNCE_TIME</code> dynamically adjust depending on the average of the buffered items, but I'm having a hard time figuring out how to achieve this. </p>
",3692626,,3692626,,2017-07-28 19:14:59,2017-07-28 20:46:54,How to dynamically scale debounce of burst emission stream?,<java><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
45404606,1,45405457,0,2017-07-30 20:53:25,,0,920,"<p>I have a custom Android TextView which shows the amount of time left in a game via a CountDownTimer</p>

<pre><code>class CountdownTextView(context: Context, attrs: AttributeSet) : TextView(context, attrs) {

    private lateinit var countDownTimer: CountDownTimer
    private lateinit var onFinishObservable: Observable&lt;Unit&gt;

    fun setTime(initTime: Int) {
        this.text = ""$initTime:00""
        countDownTimer = object : CountDownTimer((initTime *1000).toLong(), 1000) {
            override fun onTick(millisUntilFinished: Long) {
            val minutes = millisUntilFinished / 60000
            val seconds = (millisUntilFinished % 60000) / 1000
            if (seconds / 10 &gt; 0) {
                text = ""$minutes:${(millisUntilFinished % 60000) / 1000}""
            } else {
                text = ""$minutes:0${(millisUntilFinished % 60000) / 1000}""
            }
        }

        override fun onFinish() {

        }
    }


    fun startCountdown() {
        countDownTimer.start()
    }
}
</code></pre>

<p>How do I set up an observable that emits a value when the countDownTimer's onFinish() method is called? I need this so that on the main activity, I can subscribe to that observable and perform the necessary actions when the countdowntimer expires. </p>
",6407499,,0,,,2017-07-30 22:49:16,How to notify Observable when CountdownTimer is finished,<android><kotlin><rx-java><rx-kotlin>,1,0,2,,,CC BY-SA 3.0
45441074,1,45502088,0,2017-08-01 14:48:34,,1,1565,"<p>In order to improve my skills in kotlin, Rx, Retrofit2 I've decided to do a demo project.
The demo project consist to display posts in a recycler view then display details of the post in a detail activity.<br>
I've encountered difficulties displaying data coming from different api call: the user name, the title, the body of the post and the number of comments of the post.</p>

<p>My problem is that I would like to do multiple request and then have all the data needed in order to display them in the detail activity. Which mean doing a call that give me the user name and then a call that give me the number of comments for the post. The title and the body of the post are coming from a request done in the main activity I just transmit it with the bundle to the detail activity.</p>

<p>Api calls:<br>
// return the comments for the post 1<br>
<a href=""http://jsonplaceholder.typicode.com/comments?postId=1"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/comments?postId=1</a> </p>

<p>// return the information of the user 2<br>
<a href=""http://jsonplaceholder.typicode.com/users/2"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/users/2</a>  </p>

<p>// call used to display posts in the main activity<br>
http:/jsonplaceholder.typicode.com/posts</p>

<p>I'm still new on Rx, I was thinking to use a flatMap but I don't know how to use it with Flowable in kotlin..   </p>

<pre><code>var post = viewModel.getPost()
var userStream: Flowable&lt;User&gt; = postService.getUser(post.userId)
var commentsByPostIdCall: Flowable&lt;List&lt;Comment&gt;&gt; = postService.getCommentsByPostId(post.id)

userStream.subscribeOn(Schedulers.io())
        .subscribe(object : Subscriber&lt;User&gt; {
            override fun onError(t: Throwable?) {
                Log.d(this.toString(), "" Read of users failed with the following message: "" + t?.message);
            }

            override fun onNext(user: User) {
                userTextView.text = user.name
                title.text = post.title
                body.text = post.body
            }

            override fun onComplete() {
            }

            override fun onSubscribe(s: Subscription?) {
                if (s != null) {
                    s.request(1)
                }
            }
        })
</code></pre>

<p>I have put the second call in a method <em>getNumberComments</em>:</p>

<pre><code>    private fun getNumberComments(commentsByPostIdCall: Flowable&lt;List&lt;Comment&gt;&gt;): Int {
    var listComments = listOf&lt;Comment&gt;()
    var listCommentSize = 0

     commentsByPostIdCall
             .subscribeOn(Schedulers.io())
             .subscribe(object : Subscriber&lt;List&lt;Comment&gt;&gt; {
                override fun onError(t: Throwable?) {
                    Log.d(this.toString(), "" Read of comments failed with the following message: "" + t?.message);
                }

                override fun onNext(comment: List&lt;Comment&gt;) {
                    listComments = comment
                }

                override fun onComplete() {
                    print(""onComplete!"")
                    listCommentSize = listComments.size
                }

                override fun onSubscribe(s: Subscription?) {
                    if (s != null) {
                        s.request(1)
                    }
                }
            })
    return listCommentSize

}
</code></pre>

<p>Other think that I've noticed is that sometimes the stream didn't go to onComplete, sometimes it remains blocked on onNext. Don't understand why?</p>

<p>Any help will be much appreciate! Thanks a lot :)</p>
",5065580,,5065580,,2017-08-04 15:07:27,2017-08-04 15:07:27,Multiple retrofit2 requests using Flowable in Kotlin,<android><kotlin><retrofit2><rx-kotlin>,2,4,0,,,CC BY-SA 3.0
45489971,1,0,0,2017-08-03 16:34:05,,4,1619,"<p>I am a beginner with rxjava/rxkotlin/rxandroid.</p>

<p>I need to deal with three diferent async-calls in a sequence.
The problem is that the first step returns a <code>Single&lt;LocationResult&gt;</code>, the second a <code>Completable</code>and the third again a <code>Completable</code>.</p>

<p>(Single -> Completable -> Completable)</p>

<p>The problem is now that the last <code>Completable</code> depends on the data of the first <code>Single</code></p>

<p>My current solution:</p>

<p>I think this is a bad solution, but I don't know how to do this right.</p>

<pre><code>val ft = FenceTransaction(applicationContext, apiClient)
        stream
            .flatMap { locationResult -&gt;
                ft.removeAll()
                return@flatMap ft.commit().toSingle({ return@toSingle locationResult })
            }
            .flatMapCompletable {
                ft.recycle()
                ft.setZone(it.location.longitude, it.location.latitude, ZONE_RADIUS)
                val dots = DotFilter().getFilteredDots()
                for (dot in dots) {
                    ft.addDot(dot)
                }
                return@flatMapCompletable ft.commit()
            }
            .subscribeBy(
                onComplete = {
                    ""transaction complete"".logi(this)
                },
                onError = {
                    ""transaction error"".logi(this)
                })
</code></pre>

<p>Is this approch the correct way to do it?</p>

<p>And how should I dispose the <code>Completeables</code>?
Generally when should I dispose <code>Observables</code>?</p>
",6255743,,6255743,,2017-08-03 16:48:11,2018-04-24 19:13:14,"How to chain ""Single - Completeable - Completable"" in rxkotlin?",<android><rx-java2><reactivex><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
45517571,1,45520704,0,2017-08-05 02:09:10,,1,3128,"<p>I am trying to build a presenter that calculates some events within some time period, shows a loading only the first time of loading, and updates the ui when it is done. Because the events can be updated via multiple ways (such as user preferences) I need to be able to tell the presenter that the events were updated and that it has to refresh them again. Here is what I have right now:</p>

<pre><code>                      subject
                            .map&lt;List&lt;UpcomingRowViewModel&gt;&gt; {
                                provider.calculateEventsBetween(TimePeriod.aYearFrom(firstDay))
                            }
                            .doOnSubscribe {
                                view.showLoading()
                            }
                            .observeOn(resultScheduler)
                            .subscribeOn(workScheduler)
                            .subscribe { upcomingRowViewModels -&gt;
                                view.display(upcomingRowViewModels)
                            }
                      subject.onNext(TRIGGER)
</code></pre>

<p>The subject is a <code>PublishSubject</code> of Int. I do the <code>onNext()</code> right after the subscription because I want the data to be refreshed as soon as I subscribe to them. </p>

<p>The above code works wonders in my unit tests and also only when I am running it on a device <em>with the debugger attached</em>. If I just run it (without any debugger), it reaches the <code>view.showLoading()</code> part, but never the <code>provider.calculateEventsBetween(TimePeriod.aYearFrom(firstDay)</code> so the UI gets 'stuck' with the loading. </p>

<p>Any ideas?</p>
",1315110,,0,,,2017-08-05 10:10:50,onNext() never gets called on a PublishSubject,<rx-java><rx-kotlin><publishsubject>,1,0,0,,,CC BY-SA 3.0
45737107,1,45931105,0,2017-08-17 13:55:40,,1,4056,"<p>I am using <code>retorift</code> to hit <code>getAricle</code> api and get list of articles related to the user. <code>getArticle</code> api will throw error if token passed is expired if so then I have to call <code>refreshToken</code> api to get new token then again I have to call the <code>getArticle</code> api </p>

<pre><code> ApiController.createRx().getArticle(token)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ response -&gt; toast(response.body().url) }, { e -&gt;
                println(e.printStackTrace())
                if(e is HttpException &amp;&amp; e.code() in  arrayOf(401,403)){                      
                   //Here I want to call refresh tolken api
                   toast(""Auth error"")
                }
                else
                   toast(R.string.something_went_wrong)
            })
</code></pre>

<p><strong>Edit</strong></p>

<p>Even though given answers showed some direction but those are not a direct answer to my question. This is how solved it but I feel this can be refactored into much better code</p>

<pre><code>ApiController.createRx().getArticle(Preference.getToken())
            .flatMap { value -&gt;
                if (value.code() in arrayOf(403, 401)) {
                    ApiController.refreshToken()
                    ApiController.createRx().getArticle(Preference.getToken())
                } else Observable.just(value)
            }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ response -&gt; println(""Success"") }, { e -&gt;
                e.printStackTrace()
                toast(R.string.something_went_wrong)
            })



fun refreshToken() {
        val token:String?=ApiController.createRx().refreshToken(Preferences.getRefreshToken()).blockingFirst()?.body()?.token
        if (token != null) Preferences.setAuthToken(token)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>I refactored my code to little more cleaner version</p>

<pre><code>Observable.defer { ApiController.createRx().getArticle(Preferences.getToken()) }
            .flatMap {
                if (it.code() in arrayOf(401, 403)) {
                    ApiController.refreshToken()
                    Observable.error(Throwable())
                } else Observable.just(it)
            }
            .retry(1)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({println(""Success"") }, {
              it.printStackTrace()
              toast(R.string.something_went_wrong)
            })



 fun refreshToken() {
        var token: String? = null
        try {
            token = createRx().refreshToken(Preferences.getRefreshToken()).blockingFirst().body()!!.token
        } catch (e: Exception) {
            throw e
        }
        println(""saving token"")
        if (token != null) Preferences.setAuthToken(token)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>Please check my answer for the final refactored code</p>
",2085698,,2085698,,2017-08-29 05:17:22,2017-08-29 05:24:02,RxJava: Execute second observables only if first one throws an error and repeat from the first,<android><rx-java><retrofit2><rx-java2><rx-kotlin>,4,4,0,,,CC BY-SA 3.0
45826626,1,45827707,0,2017-08-22 20:42:18,,1,1485,"<p>I have some methods</p>

<pre><code>Maybe&lt;Foo&gt; getLocalFoo()
Single&lt;List&lt;Foo&gt;&gt; getFooFromInternet()
</code></pre>

<p>And want to check local item and if it's empty then fetch that item from network for example.</p>

<pre><code>storage
            .getLocalFoo()
            .switchIfEmpty { network.getFooFromInternet().map { it[0] }.toMaybe() }
            .subscribe({}, {})
</code></pre>

<p>But seens that code doesn't execute <em>network.getBarcodeTemplates()</em> this function.  </p>
",2093032,,2093032,,2017-08-23 08:02:40,2017-08-23 08:02:40,SwitchIfEmpty not executing maybesource inside,<android><rx-java><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
45834989,1,0,0,2017-08-23 08:52:07,,3,1051,"<p>Let's take two methods written with Rx:</p>

<pre><code>Maybe&lt;Foo&gt; getFooFromLocal
Single&lt;Foo&gt; getFooFromNetwork
</code></pre>

<p>I want to write a chain when we check our local storage for <em>Foo</em>. If we don't have any <em>Foo</em> we should get it from the network then save it to the local storage and again get it from local storage and pass it to our subscriber. </p>

<pre><code>storage
            .getFooFromLocal()
            .switchIfEmpty(network.getFooFromNetwork().map { it[0] }
                    .flatMapCompletable { storage.saveFoo(it) }
                    .andThen(storage.getFooFromLocal()))
                    .subscriber(/**/)
</code></pre>

<p>The problem is that <code>andThen</code> part completes before completable passed into <code>flatMapCompletable</code>. I found out that I can get rid of this problem if I wrap into <code>Maybe.defer{}</code>. But according to the documentation of <code>andThen</code>
it </p>

<blockquote>
  <p>Returns a <code>Maybe</code> which will subscribe to this Completable.</p>
</blockquote>

<p>And maybe is already</p>

<blockquote>
  <p>Represents a <strong>deferred</strong> computation and emission of a maybe value or exception </p>
</blockquote>

<p>So the question is why my <code>andThen</code> part run before completable finished. And what is the best and elegant way to write such chains. </p>

<p>Calls log :</p>

<pre><code>06:05:58.803 getFooFromLocal
06:05:58.804 getFooFromLocal
06:05:58.804 getFooFromNetwork
06:05:59.963 saveFoo
</code></pre>
",2093032,,2093032,,2017-08-23 13:10:22,2017-08-23 13:29:19,AndThen executes before completable finished,<android><rx-java><rx-kotlin>,1,4,0,,,CC BY-SA 3.0
45870757,1,45871210,0,2017-08-24 20:57:23,,0,288,"<p>The question is about RxJava2. </p>

<p>Noticed that zipping <code>Throwable</code> that comes from <code>retryWhen</code> with <code>range</code> emits all items from <code>Observable.range</code> before zipper function has been applied. Also, <code>range</code> emits sequence even if <code>zipWith</code> wasn't called. For example this source code </p>

<pre><code>Observable.create&lt;String&gt; {
        println(""subscribing"")
        it.onError(RuntimeException(""always fails""))
    }
    .retryWhen {
        it.zipWith(Observable.range(1, 3).doOnNext { println(""range $it"") },
                BiFunction { t: Throwable, i: Int -&gt; i })
                .flatMap {
                    System.out.println(""delay retry by $it + second(s)"")
                    Observable.timer(it.toLong(), TimeUnit.SECONDS)
                }
    }./*subscribe*/
</code></pre>

<p>gives the following result </p>

<pre><code> range 1
 range 2
 range 3
 subscribing
 delay retry by 1 + second(s)
 subscribing
 delay retry by 2 + second(s)
 subscribing
 delay retry by 3 + second(s)
 subscribing
 onComplete
</code></pre>

<p>Replacing <code>onError</code> in <code>observable</code> creation also don't eliminate emitting <code>range</code> items. So the question is why it's happening as <code>Range</code> is cold.</p>
",2093032,,61158,,2017-08-24 21:26:48,2017-08-24 21:32:36,Using range in zipWith also emits all items from range sequence before zipper function applied,<reactive-programming><rx-java2><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
45872463,1,45872598,0,2017-08-24 23:43:47,,0,735,"<p>I have a data flow like this:</p>

<pre><code>Observable
    .fromFuture(
        CompletableFuture.supplyAsync { // First remote call returns Future&lt;List&lt;Type&gt;&gt;
            listOf(1, 2, 3, 57005, 5)
        },
        Schedulers.computation()
    )
    .flatMap { it.toObservable() } // I turn that list into a stream of single values to process them one by one
    .map {
        CompletableFuture.supplyAsync { // This remote call may fail if it does not like the input. I want to skip that failures and continue the stream like the fail never occurred.
            if (it == 0xDEAD) {
                throw IOException(""Dead value!"")
            }

            it
        }
    }
    .flatMap {
        Observable.fromFuture(it) // Turn that Futures into a stream of Observables once again
    }
    .doOnNext {
        println(it) // Debug
    }
    .blockingSubscribe()
</code></pre>

<p>I've replaced business logic (that actually return <code>Future</code>s) with <code>CompletableFuture.supplyAsync</code>.
And, yes, this is Kotlin, but I guess you got the intent.</p>

<p>When I comment ""dead"" value (<code>57005</code>, <code>0xDEAD</code>) the output is:</p>

<pre><code>1
4
9
25
</code></pre>

<p>But if that ""dead"" value appears in the stream, it fails:</p>

<pre><code>1
4
9
Exception in thread ""main"" java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:45)
    at io.reactivex.internal.operators.observable.ObservableBlockingSubscribe.subscribe(ObservableBlockingSubscribe.java:86)
    at io.reactivex.Observable.blockingSubscribe(Observable.java:5035)
    at by.dev.madhead.rx.TestKt.main(test.kt:41)
Caused by: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
...
</code></pre>

<p>I'm a newbie in RX, so quickly googled for a solution: <code>onExceptionResumeNext</code>: <code>Observable.fromFuture(it)</code> --> <code>Observable.fromFuture(it).onExceptionResumeNext { Observable.empty&lt;Int&gt;() }</code>. But now my application hangs forever (after producing the output I expect).
Looks like the stream never ends.</p>

<p>Should I ""shutdown"" that <code>Observable</code> somehow or what?
Or, more generally, is it a good approach when working with RX?
Should I rethink it in another way?</p>
",750510,,750510,,2018-12-18 01:14:32,2018-12-18 01:14:32,How to skip exceptions silently in RxJava2?,<rx-java><reactive-programming><rx-java2><rx-kotlin><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
45975091,1,0,0,2017-08-31 06:55:53,,1,408,"<p>I have a problem which I was unable to solve so far
I'm new to RxKotlin so it might be easy. Please have a look at the code:</p>

<pre><code>    override fun infos(): Stream&lt;Info&gt; =
        client.infoAboutItem(identifier)
                .map {
                    val itemId = it.itemId ?: """"
                    val item = client.itemForId(itemId)
                    ClientInfo(client, it, source, item) as Info
                }
                .let { AccessStream(it) }
</code></pre>

<p>Where stream is our self-made collection. Map is a method that allows you to iterate over every item inside that collection.</p>

<p>The problem here is that </p>

<pre><code> client.itemForId(itemId)
</code></pre>

<p>is an http call that returns a Single which is not ideal.</p>

<p>I would want to create an asynchronous call inside map that would return Item instead of Single and then pass it to ClientInfo. The things that I've tried so far was was using subscribing inside the map and using blockingGet() method but this blocks the main thread even if I observe and subscribe on a different thread</p>

<p>So it involves making an asynchronous call for every thing in the collection.</p>

<p>Thanks for help</p>
",1840040,,0,,,2017-08-31 19:59:08,Asynchronous call for every item inside a collection,<java><kotlin><rx-java><rx-kotlin>,2,5,0,,,CC BY-SA 3.0
46224173,1,46224508,0,2017-09-14 16:27:53,,1,320,"<p>Here's a simplified version of what I'm trying to do (using Kotlin and RxJava)</p>

<pre><code>makeServerCall()
                .doOnNext {
                    doStuff(it)
                }
                //TODO: if it == 0, call asyncOperation() and wait for its callback to fire 
                //before running the rest of the stream. Otherwise immediately run the rest
                //of the stream
                .flatMap {
                    observable1(it)
                    observable2(it)
                    Observable.merge(
                            getSpotSearchObservable(observable1),
                            getSpotSearchObservable(observable2)
                }
                .subscribeBy(onNext = {
                allDone()
                    view?
                })
</code></pre>

<p>How do I squeeze in the call to <code>asyncOperation()</code> and make the rest of the stream wait for its callback to fire, but only when a certain condition is met? This seems like it's probably a trivial operation in Rx, but no obvious solution is coming to mind.</p>
",967131,,0,,,2017-09-14 16:47:18,How can I conditionally add an asynchronous operation in the middle of an RxJava stream?,<android><kotlin><rx-java><rx-android><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
46459795,1,46459906,0,2017-09-28 01:58:34,,-2,510,"<p>I'm trying to make a network request using RxKotlin, but keep getting a <code>NetworkOnMainThreadException</code> I'm subscribing on the main thread, so I'm not sure why it's not taking it off of the UI thread.</p>

<p>Here is where I subscribe to the Observable</p>

<pre><code>weatherInteractor.getWeather(lat, lng)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        {response -&gt;
                            try {
                                val jsonData = response.body().string()
                                val currentWeather = getCurrentWeatherData(jsonData)
                                view!!.displayCurrentWeather(currentWeather)
                            } catch (e: JSONException) {
                                Log.d(""Present JSON Exception"", e.message)
                            } catch (e: IOException) {
                                Log.d(""Present IO Exception"", e.message)
                            }
                        },
                        {
                            error -&gt;
                            error.printStackTrace()
                        }
                )
    }
</code></pre>

<p>Here is where I create my Observable</p>

<pre><code>fun getWeather(lat: Double, lng: Double): Observable&lt;Response&gt; {
        val URL = """"
        val client = OkHttpClient()
        val request = Request.Builder()
                .url(URL)
                .build()

        return Observable.create { em -&gt;
            try {
                val response = client.newCall(request).execute()
                em.onNext(response)
                em.onComplete()
            } catch (err: IOException) {
                err.printStackTrace()
                em.onError(err)
            }
        }
    }
</code></pre>
",3079130,,3079130,,2017-09-28 15:56:38,2017-09-28 15:56:38,Getting NetworkOnMainThreadException with RxKotlin,<android><kotlin><rx-java><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
46523605,1,0,0,2017-10-02 10:16:15,,1,763,"<p>Using <code>RxJava2</code> <code>RxKotlin</code> and <code>Room</code>, I need to query the database for an open hunt. That means that I search for a hunt that contains an attribute called <code>closed</code> with value <code>false</code>. Once the hunt has been found, it needs to switch the query to that particular hunt.</p>

<p>I have 2 methods for those queries:</p>

<pre><code>getOpenHunt(teamId:String): Flowable&lt;List&lt;Hunt&gt;&gt;
getHunt(huntId:String): Flowable&lt;List&lt;Hunt&gt;&gt;
</code></pre>

<p>They both return a <code>List</code> because otherwise the query gets stuck when no hunt is found.</p>

<p>My idea is something like</p>

<pre><code>fun queryHunt(teamId:String):Flowable&lt;Optional&lt;Hunt&gt;&gt;{
   getOpenHunt(teamId)
      .map&lt;Optional&lt;Hunt&gt;&gt; {
                Optional.create(it.firstOrNull())
            }
      .switchToFlowableIf ( it is Optional.Some, getHunt(it.element().id)
}

//With switchToFlowableIf's being
fun &lt;E:Any&gt; switchToFlowableIf(condition: (E)-&gt;Boolean, newFlowable: Flowable&lt;E&gt;): Flowable&lt;E&gt;
//It should unsubscribe from getOpenHunt and subscribe to newFlowable
</code></pre>

<p>For reference, here is my <code>Optional</code> class</p>

<pre><code>sealed class Optional&lt;out T&gt; {
class Some&lt;out T&gt;(val element: T) : Optional&lt;T&gt;()
object None : Optional&lt;Nothing&gt;()

fun element(): T? {
    return when (this) {
        is Optional.None -&gt; null
        is Optional.Some -&gt; element
    }
}

companion object {
    fun &lt;T&gt; create(element: T?): Optional&lt;T&gt; {
        return if (element != null) {
            Optional.Some(element)
        } else {
            Optional.None
        }
    }
}
}
</code></pre>

<p>Is there a similar method already built in RxJava2? If not, how would you implement it?</p>
",1354302,,1354302,,2017-10-02 10:41:16,2017-10-02 13:30:56,Change observable on condition met - RxJava2,<android><kotlin><rx-java2><rx-kotlin2>,2,0,0,,,CC BY-SA 3.0
46546041,1,46547211,0,2017-10-03 13:42:01,,0,409,"<p>I'm using Kotlin 1.1.4-3 with Spring-context 5.0.0.RELEASE. </p>

<p>On starting project I get this error:</p>

<pre><code>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'coroutineAnnotationBeanPostProcessor' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/ProxyCoroutineConfiguration.class]: Unsatisfied dependency expressed through method 'coroutineAnnotationBeanPostProcessor' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalCoroutineContextResolver' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/CoroutineContextResolverConfiguration.class]: Unexpected exception during bean creation; nested exception is java.lang.reflect.InvocationTargetException
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:723)
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:458)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1249)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1098)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:502)
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:205)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalCoroutineContextResolver' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/CoroutineContextResolverConfiguration.class]: Unexpected exception during bean creation; nested exception is java.lang.reflect.InvocationTargetException
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:518)
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:251)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1133)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1060)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:809)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:715)
Caused by: java.lang.reflect.InvocationTargetException: null
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotationArguments(ReflectKotlinClass.kt:173)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotation(ReflectKotlinClass.kt:162)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.loadMethodAnnotations(ReflectKotlinClass.kt:97)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.visitMembers(ReflectKotlinClass.kt:87)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectKotlinClass.visitMembers(ReflectKotlinClass.kt:68)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.AbstractBinaryClassAnnotationAndConstantLoader.loadAnnotationsAndInitializers(AbstractBinaryClassAnnotationAndConstantLoader.kt:257)
Caused by: java.lang.TypeNotPresentException: Type rx.Scheduler not present
        at sun.reflect.annotation.TypeNotPresentExceptionProxy.generateException(TypeNotPresentExceptionProxy.java:46)
        at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:84)
        at com.sun.proxy.$Proxy166.value(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotationArguments(ReflectKotlinClass.kt:173)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotation(ReflectKotlinClass.kt:162)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.loadMethodAnnotations(ReflectKotlinClass.kt:97)
Caused by: java.lang.ClassNotFoundException: rx.Scheduler
        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:348)
        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114)
        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125)
        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
        at sun.reflect.annotation.AnnotationParser.parseSig(AnnotationParser.java:439)
        at sun.reflect.annotation.AnnotationParser.parseClassValue(AnnotationParser.java:420)
</code></pre>

<p>It seems spring is looking for <code>rx.Scheduler</code> class but it's not in the classpath. It's obvious that corresponding dependency of <code>rx.Scheduler</code> is not added. but I couldn't find anything relevant on the Internet.</p>

<p>I added RxJava2 (<code>io.reactivex.rxjava2</code>) to project but it didn't work.
 What can I do?</p>

<p>Final Answer - based on Rafal G. response:</p>

<p>This error is because of using <a href=""https://github.com/konrad-kaminski/spring-kotlin-coroutine"" rel=""nofollow noreferrer"">konrad-kaminski/spring-kotlin-coroutine</a> library.
However, I used these dependencies in my project:</p>

<pre><code>  ""org.springframework.kotlin"" % ""spring-kotlin-coroutine"" % ""0.2.2"" exclude(""org.jetbrains.kotlinx"", ""kotlinx-coroutines""),

  ""org.springframework"" % ""spring-context"" % ""5.0.0.RELEASE"",
  ""org.springframework.data"" % ""spring-data-jpa"" % ""2.0.0.RELEASE"",

  // https://mvnrepository.com/artifact/io.reactivex.rxjava2/rxjava
  ""io.reactivex.rxjava2"" % ""rxjava"" % ""2.1.4"",

  // https://mvnrepository.com/artifact/io.reactivex/rxjava
  ""io.reactivex"" % ""rxjava"" % ""1.3.2"",

  // https://mvnrepository.com/artifact/io.projectreactor/reactor-core
  ""io.projectreactor"" % ""reactor-core"" % ""3.1.0.RELEASE""
</code></pre>
",2250391,,2250391,,2017-10-04 10:19:04,2017-10-04 10:19:04,Spring 5 and Kotlin 1.1 Coroutines: Type rx.Scheduler not present,<java><spring><kotlin><rx-kotlin><kotlinx.coroutines>,1,2,0,,,CC BY-SA 3.0
46589849,1,46595044,0,2017-10-05 15:47:35,,0,1134,"<p>Here is short snippet of code:</p>

<pre><code>    val subject = BehaviorSubject.createDefault(emptyList&lt;Int&gt;())
    subject.onNext(Arrays.asList(1, 2, 3))
    subject.flatMapIterable { list: List&lt;Int&gt; -&gt; list }
            .subscribeBy(
                    onNext = { l(""on next"", it) },
                    onComplete = { l(""on complete"") }
            )
</code></pre>

<p>Why <code>onComplete</code> doesn't not call here? What I should do for working this code? Because in original code I can not use <code>.toList()</code> method. </p>
",4981663,,0,,,2017-10-05 21:26:58,RxJava2: onComplete not called with flatMapIterable,<kotlin><rx-java2><rx-kotlin2>,1,5,0,,,CC BY-SA 3.0
46828909,1,46855916,0,2017-10-19 11:32:10,,1,247,"<p>I've encountered a strange problem which I'm struggling to understand. I have written some code that creates an observable from callable. It compiles fine, but as soon as I specify a scheduler for it it changes the return type and doesn't compile.</p>

<p>Here is the code without the subscribeOn (which compiles):</p>

<pre><code>/**
 * Gets all the room bookings for the specified day
 */
override fun getRoomBookingsForDay(date: Date): Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt; =
        Observable.fromCallable {
            Realm.getDefaultInstance().use { realm -&gt;
                // Get all the bookings that begin and end within the specified date
                val dbRoomBookings =
                        realm.where(DBRoomBooking::class.java)
                                .greaterThan(""timeFromUtc"", date)
                                .lessThan(""timeToUtc"", date)
                                .findAllSorted(""timeFromUtc"")

                if (dbRoomBookings.isEmpty()) {
                    emptyList()
                } else {
                    dbRoomBookings.asSequence().map { dbRoomBooking -&gt;
                        makeRoomBookingModel(dbRoomBooking)
                    }.filterNotNull().toList()
                }
            }
        }
</code></pre>

<p>And here is the code with subscribeOn (which doesn't compile):</p>

<pre><code>/**
 * Gets all the room bookings for the specified day
 */
override fun getRoomBookingsForDay(date: Date): Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt; =
        Observable.fromCallable {
            Realm.getDefaultInstance().use { realm -&gt;
                // Get all the bookings that begin and end within the specified date
                val dbRoomBookings =
                        realm.where(DBRoomBooking::class.java)
                                .greaterThan(""timeFromUtc"", date)
                                .lessThan(""timeToUtc"", date)
                                .findAllSorted(""timeFromUtc"")

                if (dbRoomBookings.isEmpty()) {
                    emptyList()
                } else {
                    dbRoomBookings.asSequence().map { dbRoomBooking -&gt;
                        makeRoomBookingModel(dbRoomBooking)
                    }.filterNotNull().toList()
                }
            }
        }.subscribeOn(AndroidRealmSchedulers.realmThread())
</code></pre>

<p>The compile time error message is:</p>

<pre><code>Type mismatch.
Required: Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt;
Found: Observable&lt;List&lt;Model.RoomBooking&gt;!&gt;!
</code></pre>

<p>Surely, specifying the scheduler shouldn't change the type that is being returned? Any ideas?</p>
",5963279,,0,,,2017-10-20 19:17:18,Adding subscribeOn() is changing return type of observable,<android><kotlin><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
47009101,1,0,0,2017-10-30 06:19:00,,0,535,"<p>I am using RxJava 2.* and I want to merge the results of two observables (one from retrofit and another from room) by using zip operator(feel free to suggest better).</p>

<p>Model objects that come from remote server are different from the one coming out of Room Database. </p>

<ol>
<li>I want to map the objects from Remote into that of local </li>
<li>Merge those two results </li>
<li>Display the result.</li>
</ol>

<p>My remote API looks like this : </p>

<pre><code>interface CategoryService{
@GET(""categories"")
fun getCategories(): Observable&lt;List&lt;Category&gt;&gt;
</code></pre>

<p>}</p>

<p>And my Room DAO query looks like this : </p>

<pre><code>@Query(""SELECT * FROM categories ORDER BY id"")
abstract fun categories(): Observable&lt;List&lt;KmagCategory&gt;&gt;
</code></pre>

<p>I have converted Observable> into Observable> like this :</p>

<pre><code>val newCategoryList : Observable&lt;List&lt;KmagCategory&gt;&gt; =settingService.getCategories().flatMap { list -&gt;
            Observable.fromIterable(list)
                    .map { item -&gt; KmagCategory(item.id, item.title, item.slug, item.isFav) }
                    .toList()
                    .toObservable()
        }
</code></pre>

<p>But when I try to zip these two observables like this :</p>

<pre><code>val combinedObservable : Observable&lt;List&lt;KmagCategory&gt;&gt; = Observables.zip(KMagApp.database?.categories()?.categories()!!,newSetting)
</code></pre>

<p>I get <strong>Type inference failed, Expected type mismatch</strong> 
<a href=""https://i.stack.imgur.com/KpPz7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KpPz7.png"" alt=""enter image description here""></a></p>
",2581314,,2581314,,2017-10-30 06:27:26,2017-10-30 08:11:49,Cannot zip Rxjava Observables,<java><android><kotlin><rx-java2><rx-kotlin2>,2,0,0,,,CC BY-SA 3.0
47046329,1,47107834,0,2017-11-01 00:09:01,,9,30689,"<p>I have an object <em>QuickSort</em> that I am attempting to create 2 instances of. When I try to create 2 separate instances I can see that it is only using one instance because I have a count in the <em>QuickSort</em> class that is inaccurate. Kotlin does not use <strong>new</strong> in the syntax, so how would I go about this?</p>

<pre><code>object QuickSort {
      var count = 0;
      quickSortOne(...){
          ...
          count++
          ...
      }
      quickSortTwo(...){
          ...
          count++
          ...
      }
  } 
</code></pre>

<p>Here is how I am attempting to create my 2 instances.My goal is to have <em>quickSort1</em> and <em>quickSort2</em> be 2 separate instances.</p>

<pre><code>var quickSort1 = QuickSort
quickSort1.quickSortOne(...)

var quickSort2 = QuickSort
quickSort2.quickSortTwo(...)
</code></pre>

<p><strong>Attempted Solution</strong>: Converting <em>QuickSort</em> from an object to a class. This still results in the same instance being used as seen by the count of the second method including the first calls count.</p>

<pre><code>class QuickSort {
      var count = 0;
      quickSortOne(...){
          ...
          count++
          ...
      }
      quickSortTwo(...){
          ...
          count++
          ...
      }
  }
</code></pre>

<p>...</p>

<pre><code>var quickSortFirst = QuickSort()
printTest(quickSortFirst.quickSortFirst(arrayList, 0, arrayList.size - 1))

var quickSortLast = QuickSort()
printTest(quickSortLast.quickSortLast(arrayList, 0, arrayList.size - 1))
</code></pre>
",2253682,,2253682,,2017-11-01 03:49:29,2017-11-04 05:42:23,Create New Instance of Kotlin Object,<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin>,4,5,1,,,CC BY-SA 3.0
47173475,1,50465274,0,2017-11-08 07:02:43,,0,1611,"<p><strong>Kotlin Code:</strong></p>

<pre class=""lang-kotlin prettyprint-override""><code>fun &lt;T&gt; Observable&lt;T&gt;.circuitBreaker(): Observable&lt;T&gt; {
  val relay = PublishRelay.create&lt;T&gt;()
  this.subscribe(relay)
  return relay.toFlowable(BackpressureStrategy.LATEST).toObservable()
}
</code></pre>

<p>Above is a Kotlin code which I'm trying to convert into Swift. But, I'm facing an error saying <strong>Cannot convert value of type 'PublishRelay' to expected argument type '(Event&lt;_>) -> Void'</strong></p>

<p><strong>Swift Code:</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension Observable {
  func circuitBreaker&lt;T&gt;() -&gt; Observable&lt;T&gt; {
    let relay = PublishRelay&lt;T&gt;()
    self.subscribe(relay)
    return relay.asObservable()
  }
}
</code></pre>

<p>Any help would be appreciated.</p>
",1083859,,6584288,,2017-11-08 07:09:57,2018-05-22 10:20:39,How to subscribe to PublishRelay from generic observable?,<generics><rx-swift><rx-cocoa><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
47187808,1,0,0,2017-11-08 19:12:29,,2,1720,"<p>When im using the following dependencies in my pom file:</p>

<pre><code>&lt;properties&gt;
    &lt;rxkotlinfx.version&gt;2.2.0&lt;/rxkotlinfx.version&gt;
    &lt;rxkotlin.version&gt;2.1.0&lt;/rxkotlin.version&gt;
    &lt;kotlin.version&gt;1.1.51&lt;/kotlin.version&gt;
    &lt;tornadofx.version&gt;1.7.12&lt;/tornadofx.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.github.thomasnield&lt;/groupId&gt;
        &lt;artifactId&gt;rxkotlinfx&lt;/artifactId&gt;
        &lt;version&gt;${rxkotlinfx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;
        &lt;artifactId&gt;rxkotlin&lt;/artifactId&gt;
        &lt;version&gt;${rxkotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;no.tornado&lt;/groupId&gt;
        &lt;artifactId&gt;tornadofx&lt;/artifactId&gt;
        &lt;version&gt;${tornadofx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-test&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>And running the following code:</p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    val source = listOf(""A"", ""B"", ""C"").toObservable()
            .filter { it == ""B"" }
            .subscribeBy(
                    onNext = { println(it) }
            )
}
</code></pre>

<p>Im getting the following error:</p>

<pre><code>Error:(37, 40) Kotlin: Cannot access class 'io.reactivex.Observable'. Check your module classpath for missing or conflicting dependencies
</code></pre>

<p>Why am I getting this error and what setup of dependencies do I need to be able to work with this stack?</p>
",3139545,,3139545,,2017-11-08 19:29:18,2017-11-09 18:07:28,Kotlin with RxKotlinFX stack gives Cannot access class error,<kotlin><rx-kotlin>,2,1,0,,,CC BY-SA 3.0
47196773,1,0,0,2017-11-09 08:04:50,,0,478,"<p>I'm using RxKotlin together with Retrofit 2</p>

<p>I'm trying figure out how to have dynamic list of observers on a single operation.</p>

<p>The first observer should trigger the operation, and all additional observers should wait until the operation complete/fails</p>

<p>Once the operation complete,I need to make data manipulation (Store in cache/Memory) and then notify all the observers.</p>

<p>Here's what I did:</p>

<pre><code>class UserManager
{
    val observers = ArrayList&lt;Observer&lt;ArrayList&lt;User&gt;&gt;&gt;()
    var isFetchingUsers = false

    fun getUsers(observer: Observer&lt;ArrayList&lt;User&gt;&gt;)
    {
        observers.add(observer)

        if (isFetchingUsers)
        {
            return
        }

        api.getUserList.observeOn(AndroidSchedulers.mainThread()).subscribe(object : Observer&lt;UserListResponse&gt;
        {
            override fun onNext(response: UserListResponse)
            {
                // Do some manipulations on the response and notify all

                observers.forEach {
                    it.onNext(response.getUsers())
                }
            }

            override fun onError(e: Throwable)
            {
                observers.forEach {
                    it.onError(Throwable())
                }
            }

            override fun onComplete()
            {
                isFetchingUsers = false
                observers.clear()
            }

            override fun onSubscribe(d: Disposable)
            {
            }
        })
    }
}
</code></pre>

<p>Here's Retrofit observable creation (this one is in Java..)</p>

<pre><code>   /**
     * Get users
     */
    public Observable&lt;UserListResponse&gt; getUserList()
    {
        return mService.getUserList().subscribeOn(Schedulers.io());
    }
</code></pre>

<p>I'm sure there's a better way for doing this</p>

<p>Thanks!</p>
",1039477,,1039477,,2017-11-09 08:10:38,2017-11-09 18:15:54,RxKotlin - Dynamic observers array,<android><kotlin><rx-java><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
47294290,1,47294652,0,2017-11-14 20:04:16,,0,319,"<p>I have a stream of <code>ResponseMessage</code> which can be of different subtypes. I would like to split the stream into streams where I can handle each type in its own stream.</p>

<p>My first try resulted in this which I can not see working out.</p>

<pre><code>file.readLines()
        .toObservable()
        .map { mapper.readValue(it, ResponseMessage::class.java) }
        .groupBy { when(it) {
            is MarketChangeMessage -&gt; it::class
            else -&gt; it::class
        }}
        .map { it.????? } //How can possible this work?
</code></pre>

<p>My question is now:
What is the idiomatic way to divide a stream into streams on one specific sub type?</p>
",3139545,,2597143,,2018-10-24 13:19:55,2018-10-24 13:19:55,RxJava/RxKotlin split stream depending on subtype,<kotlin><rx-java><rx-kotlin><rx-kotlin2><rx-javafx>,1,0,0,,,CC BY-SA 3.0
47376858,1,0,0,2017-11-19 12:28:54,,1,417,"<p>Im stuck getting the following example working as expected, I have tried using <code>zip</code> and <code>combineLatest</code> and as show below <code>withLatestFrom</code> however non of them gives the expected output.</p>
<pre><code>@Test
fun thereCanBeOnlyOne() {
    val s1 = BehaviorSubject.create&lt;Int&gt;()
    val s2 = BehaviorSubject.create&lt;Int&gt;()

    s2.withLatestFrom&lt;Int, Int, Int&gt;(s1)
            .subscribe { (a, b) -&gt;
                println(&quot;$a - $b&quot;)
            }

    s1.onNext(1)
    s1.onNext(2)
    s2.onNext(1)
    s2.onNext(2)
    s1.onNext(333)
    s2.onNext(444)
}
</code></pre>
<p>What I want is the following to print:</p>
<blockquote>
<p>2 - 1</p>
<p>2 - 2</p>
<p>333 - 444</p>
</blockquote>
",3139545,,-1,,2020-06-20 09:12:55,2017-11-19 12:42:14,Combine two subject only when one changes and get latest from other,<rx-java><rx-java2><reactivex><rx-kotlin><rx-kotlin2>,1,0,0,,,CC BY-SA 3.0
47534447,1,0,0,2017-11-28 14:50:47,,16,9860,"<p>Suppose you want to insert a Completable in your Observable chain, such as for each emitted element, there is a completable that runs and blocks until it completes, what option would you choose? (here the <code>Completable.complete()</code> is just to make an example)</p>

<ol>
<li><p><code>.flatMap { Completable.complete().andThen(Observable.just(it)) }</code></p></li>
<li><p><code>.doOnNext { Completable.complete().blockingAwait() }</code></p></li>
<li><p>something else?</p></li>
</ol>
",1855855,,0,,,2018-04-26 05:27:53,Chain Completable into Observable flow,<rx-java><rx-java2><rx-kotlin><rx-kotlin2>,2,0,0,,,CC BY-SA 3.0
47595813,1,47804468,0,2017-12-01 14:43:49,,0,153,"<p>could you please help me to group by the following json and return a hashMap in kotlin based on date with RxKotlin? is so easy with just kotlin but really stuck for Rxkotlin. thanks</p>

<p>val groupedTransactions =   accountTransactions.transactions
                    ?.groupBy { it.effectiveDate }</p>

<pre><code>""transactions"": [{
        ""id"": ""44e5b2bc484331ea24afd85ecfb212c8"",
        ""effectiveDate"": ""20/07/2017"",
        ""description"": ""Kaching TFR from JOHN CITIZEN&lt;br/&gt;xmas donation"",
        ""amount"": 12.00
    }, {
        ""id"": ""1506aeeb8c3a699b1e3c87db03156428"",
        ""effectiveDate"": ""20/07/2017"",
        ""description"": ""Wdl ATM CBA ATM CIRCULAR QUAY STATION NSW 221092 AUS"",
        ""amount"": -200.00,
        ""atmId"": ""129382""
    }, {
        ""id"": ""9a899bfd978511e9605774e1d5222b67"",
        ""description"": ""Savings"",
        ""effectiveDate"": ""19/07/2017"",
        ""amount"": 10.00
    }, {
        ""id"": ""1a6c48627cecaa2388b702fa33d751ff"",
        ""description"": ""PTAG COCA COLA AMATI"",
        ""effectiveDate"": ""12/07/2017"",
        ""amount"": -2.20
    }, {
        ""id"": ""7ecc19e1a0be36ba2c6f05d06b5d3058"",
        ""description"": ""Wdl ATM CBA ATM TOWN HALL SQUARE NSW 253432 AUS"",
        ""effectiveDate"": ""04/07/2017"",
        ""amount"": -50.00,
        ""atmId"": ""137483""
    }, {
        ""id"": ""b71bf065b640217dad602f86ac047722"",
        ""description"": ""BPAY - Telstra mobile"",
        ""effectiveDate"": ""04/07/2017"",
        ""amount"": -49.00
    },{
        ""id"": ""ef087651eb482bae4624478696f4ad4f"",
        ""description"": ""Transfer from REBECCA SHAW&lt;br/&gt;Lorem ipsum"",
        ""effectiveDate"": ""03/07/2017"",
        ""amount"": 150.00
    }, {
        ""id"": ""8cd283d8b7bacc277f2bae5e26ce6d1e"",
        ""description"": ""Savings"",
        ""effectiveDate"": ""01/07/2017"",
        ""amount"": 200.00
    }, {
        ""id"": ""04117d2d74f5331f3ee4955da27cca7a"",
        ""effectiveDate"": ""28/06/2017"",
        ""description"": ""Transfer - Saturday drinks"",
        ""amount"": -100.00
    }, {
        ""id"": ""821ae63dbe0c573eff8b69d451fb21bc"",
        ""effectiveDate"": ""21/06/2017"",
        ""description"": ""Wdl ATM CBA ATM CIRCULAR QUAY STATION NSW 221092 AUS"",
        ""amount"": -200.00,
        ""atmId"": ""129382""
    }]
</code></pre>
",1820178,,0,,,2017-12-14 01:09:58,rxkotlin groupby is not working,<rx-kotlin2>,1,5,0,,,CC BY-SA 3.0
47730952,1,47731024,0,2017-12-09 17:02:25,,2,818,"<pre><code>class TaskRepo(taskData: TaskData) {

companion object {
    private val repoByTask: LRUMap&lt;String, OrderFormRepo&gt; = LRUMap(2, 10);

     fun getInstance(taskData: TaskData): OrderFormRepo {
        if (notFoundObject(taskData.taskId)) {
            repoByTask[taskData.taskId] = OrderFormRepo(taskData);
        }
        return repoByTask[taskData.taskId];//PROBLEM HERE
    }

    private fun notFoundObject(taskId: String): Boolean {
        if (repoByTask.containsKey(taskId) &amp;&amp; repoByTask[taskId] != null) {
            return false
        }
        return true
    }
}
</code></pre>

<p>}</p>

<p>in getInstance method of companion object I am getting compile time <strong>error:</strong>
<strong>Required TaskRepo and found TaskRepo?</strong></p>
",1412900,,4465208,,2017-12-09 17:51:06,2017-12-09 17:51:06,Required <Object> and found <Object>?,<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin><kotlin-interop>,1,0,0,,,CC BY-SA 3.0
47735111,1,47900911,0,2017-12-10 01:53:59,,-3,82,"<p>could you please help me for this <a href=""https://stackoverflow.com/questions/47595813/rxkotlin-groupby-is-not-working"">rxkotlin groupby is not working</a>? working in rxjava but not kotlin. highly apreciate your help</p>
",1820178,,0,,,2017-12-20 07:33:13,I can't get map from groupby in rxkotlin,<kotlin><rx-java><rx-kotlin>,1,2,0,,,CC BY-SA 3.0
47770059,1,0,0,2017-12-12 10:14:32,,2,3260,"<p>
this is my xml :</p>

<pre><code>&lt;data&gt;

    &lt;variable
        name=""notificationViewmodel""
        type=""com.kdcos.contsync.viewmodel.notification.NotificationViewModel""&gt;&lt;/variable&gt;

&lt;/data&gt;


&lt;RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""
    android:background=""@color/colorpalegrey""&gt;

    &lt;RelativeLayout
        android:id=""@+id/header""
        android:layout_width=""match_parent""
        android:layout_height=""wrap_content""
        android:layout_alignParentTop=""true""
        android:layout_gravity=""center""
        android:background=""#689F38""
        android:gravity=""center""&gt;

        &lt;include
            android:id=""@+id/layout_toolbar""
            layout=""@layout/toolbar_white_bg"" /&gt;
    &lt;/RelativeLayout&gt;


    &lt;LinearLayout
        android:layout_width=""match_parent""
        android:layout_height=""wrap_content""
        android:layout_below=""@+id/header""
        android:layout_marginTop=""20dp""
        android:background=""@drawable/topbottomborder""
        android:orientation=""vertical""&gt;


        &lt;RelativeLayout
            android:layout_width=""fill_parent""
            android:layout_height=""wrap_content""
            android:layout_marginTop=""18dp""
            android:paddingBottom=""20dp""
            android:paddingLeft=""@dimen/margin_20dp""&gt;


            &lt;TextView
                android:layout_width=""match_parent""
                android:layout_height=""wrap_content""
                android:fontFamily=""sans-serif-medium""
                android:lineSpacingExtra=""30sp""
                android:text=""@={notificationViewmodel.getText()}""
                android:textColor=""@color/colorDusk""
                android:textSize=""16sp""
                android:textStyle=""normal"" /&gt;

            &lt;Switch
                android:layout_width=""wrap_content""
                android:layout_height=""wrap_content""
                android:layout_alignParentRight=""true""
                android:paddingRight=""10dp""
                android:onCheckedChanged=""@={notificationViewmodel.checked}""
                android:textColor=""@android:color/black"" /&gt;

        &lt;/RelativeLayout&gt;
    &lt;/LinearLayout&gt;


&lt;/RelativeLayout&gt;
</code></pre>

<p></p>

<p>this is my View Model</p>

<pre><code>class NotificationViewModel(val context: Context, val bus: Bus, val manager: CNotificationManager) : BaseObservable() {
    private var checked: Boolean = false
    fun getToolbarTitle(): String? {
        return manager.getToolbarTitle()
    }

    fun setToolbarTextColor(): Int {
        return ContextCompat.getColor(context, R.color.colorDusk)
    }

    fun isChecked(): Boolean {
        return checked
    }

    fun setChecked(checked: Boolean) {
        this.checked = checked
    }

    fun getText(): String {
        if (isChecked()) {
            return ""Notfication On""
        } else {
            return ""Notification Off""
        }
        notifyChange()
    }
}
</code></pre>

<p>I want to apply data binding in <code>switch</code> so that when I on <code>switch</code> then  <code>textView</code> should display Notification off and checked value should set to true when I off then it <code>textview</code> should display  notification off and checked Boolean variable should set false. please suggest me how I will implement using Data-binding .</p>
",7108422,,5400914,,2017-12-12 11:20:22,2021-02-26 12:18:27,how to implement Switch using Data binding in android,<android><data-binding><kotlin><rx-kotlin>,2,2,0,,,CC BY-SA 3.0
47953791,1,47971299,0,2017-12-23 15:40:44,,3,4148,"<p>I know how to do this in <a href=""https://stackoverflow.com/questions/38811923/how-to-use-rxjava-combinelatest-operator-with-more-than-9-observables"">RxJava 2</a>.</p>

<p>And I know how <a href=""https://stackoverflow.com/questions/42725749/observable-combinelatest-type-inference-in-kotlin"">RxKotlin</a> helps with similar issues.</p>

<p>But it seems that RxKotlin.Observables doesn't have this helper function for the list overload and I cannot figure it out. How would you do this?</p>
",1067763,,0,,,2018-12-12 19:50:43,How to use RxJava2 combineLatest with a list of observables in Kotlin,<kotlin><rx-java2><rx-kotlin2>,3,2,1,,,CC BY-SA 3.0
47993122,1,47993505,0,2017-12-27 13:33:13,,0,59,"<p>I am using firebase in android with some complex data. I need to save references and I'm getting problems with my zip operation, or the way I'm handling RX overall.</p>

<p>I want to create a new <code>A object</code> with information about a certain <code>B</code>, and update my <code>B object</code> to have information about the created <code>A</code>. When the firebase operations have both been successful I will return the <code>Single&lt;A&gt;</code></p>

<pre><code>val singleA = firebaseCall(A(""ABC"", bKey))

val singleB = singleA.flatMap{ a -&gt; firebaseCall(B(aKey)) }

return Single.zip(singleA, singleB, BiFunction { a, b -&gt; a })
</code></pre>

<p>When going through logcat I can see that <code>SingleA</code> get subscribed to twice, and pushes twice to firebase. I want to avoid this!</p>

<p>So, how can I use a zip function on A and B, when B is dependent on A; and not have A being performed twice?</p>
",1570640,,7505436,,2017-12-27 15:16:03,2017-12-27 15:16:03,"How do I avoid .zip(stream1, stream2, BiFun) subscribing to stream1 twice, when stream2 is based on stream1?",<android><firebase-realtime-database><reactive-programming><rx-java2><rx-kotlin>,1,3,0,,,CC BY-SA 3.0
48055716,1,0,0,2018-01-02 04:49:16,,-6,733,"<pre><code> override fun itemclick(position: Int) {
        binding.progressbar.visibility=View.VISIBLE
        binding?.barcode?.setImageBitmap(exchngeViewModel.getQrImageBitmap(qrCodeData[position], this!!.activity!!))
        showDetail(position)
        binding.progressbar.visibility=View.GONE
    }    

fun getQrImageBitmap(data: String, context: Context): Bitmap? {
        bitMap = AppUtils.TextToImageEncode(data, context, bus) 
        return this!!.bitMap
    }
</code></pre>

<p>This is my code i want to display Progress <code>dialog</code> on item click it should dismiss till that time when  <code>getQrImageBitmap</code> and showDetail function  completed but i its not working please suggest me how to achieve this how to show and hide detail on item click.Thanks!! </p>
",7251198,,5110595,,2018-01-02 05:35:42,2018-01-02 05:44:39,How to show Progress dialog and dismiss on Item click,<android><kotlin><rx-java><rx-kotlin>,1,6,0,,,CC BY-SA 3.0
48126761,1,51862452,0,2018-01-06 11:15:03,,6,1742,"<p>I am using RxJava/Kotlin with Room and Retrofit. I am sure I'm not making something write as I just started learning RxJava. The scenario is that I make a call to check if there are favorite records in DB and get them in a List, fetch data from API and insert it in DB, update the DB with the previous favorites list and get all records as an, now updated, List. I get the result in my fragment but each time I get it it's as if I get 1 less favorite item until I get no favorite items.</p>

<p><code>Repository</code></p>

<pre><code>fun getKafaniFromApi(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return apiService.getKafani().toObservable().doOnNext {
        insertKafaniInDb(it)
    }
}

fun getKafaniFromDb(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return kafanaDao.getKafani().toObservable()
}

fun insertKafaniInDb(kafani: List&lt;Kafana&gt;) {
    Observable.fromCallable { kafanaDao.insertAll(kafani) }
            .subscribeOn(Schedulers.io())
            .subscribe {
                Timber.d(""Inserted ${kafani.size} kafani from API in DB..."")
            }
}

fun getFavoriteKafani(): Single&lt;List&lt;Kafana&gt;&gt; {
    return kafanaDao.getFavoriteKafani()
}

fun setKafanaFavorite(kafana: Kafana, isFavorite: Int) {
    return kafanaDao.setFavourite(kafana.name, isFavorite)
}

fun updateFavoriteKafana(kafana: Kafana) {
    return kafanaDao.updateFavoriteKafana(kafana)
}
</code></pre>

<p>And in my <code>viewmodel</code></p>

<pre><code>fun get(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return kafanaRepository.getFavoriteKafani()
            .toObservable()
            .doOnNext { kafaniList = it }
            .flatMap { kafanaRepository.getKafaniFromApi() }
            .doOnNext { kafaniList?.forEach { kafanaRepository.updateFavoriteKafana(it) } }
            .flatMap { kafanaRepository.getKafaniFromDb() }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
}
</code></pre>

<p>I will actually get the list in my fragment but, as I said, it will always be one less favorite until there are none.</p>
",6638520,,0,,,2018-08-15 16:13:16,"Chaining multiple calls RxJava, Room and Retrofit",<android><retrofit2><rx-java2><android-room><rx-kotlin>,1,0,1,,,CC BY-SA 3.0
48129498,1,52319803,0,2018-01-06 16:43:21,,9,5085,"<p>I have issue that I cannot solve. Im trying to .zip(List, ) multiple Singles into one using Kotlin and none of Functions i supply as second argument fits.</p>

<pre><code>    fun getUserFriendsLocationsInBuckets(token: String) {
    roomDatabase.userFriendsDao().getUserFriendsDtosForToken(token).subscribe(
            { userFriends: List&lt;UserFriendDTO&gt; -&gt;
                Single.zip(getLocationSingleForEveryUser(userFriends),
                        Function&lt;Array&lt;List&lt;Location&gt;&gt;, List&lt;Location&gt;&gt; { t: Array&lt;List&lt;Location&gt;&gt; -&gt; listOf&lt;Location&gt;() })
            },
            { error: Throwable -&gt; }
    )
}

private fun getLocationSingleForEveryUser(userFriends: List&lt;UserFriendDTO&gt;): List&lt;Single&lt;List&lt;Location&gt;&gt;&gt; =
        userFriends.map { serverRepository.locationEndpoint.getBucketedUserLocationsInLast24H(it.userFriendId) }
</code></pre>

<p><a href=""https://i.stack.imgur.com/1ByNM.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/1ByNM.png"" alt=""Android studio error""></a></p>
",5396120,,0,,,2018-09-13 18:30:20,RxJava 2.0 and Kotlin Single.zip() with list of singles,<kotlin><rx-java><rx-kotlin>,1,2,1,,,CC BY-SA 3.0
48141978,1,0,0,2018-01-07 22:04:08,,1,60,"<p>I have the following design I'd like to create, but I'm not sure which Rx pattern matches it. The goal is more or less along the lines of a Single, but with a conditional check.</p>

<ul>
<li>There is one <code>Observable&lt;String&gt;</code>, and the possibility of any number of observers.</li>
<li>If a request is first made, the observable will execute some network request taking in the string, then emit a callback (much like a completable/single)</li>
<li>Any subsequent call with the same key will return the same result immediately</li>
<li>However, if 5 minutes has passed and the same call is made, we will refetch the data as it may have expired, then emit it to any listeners. This result will be saved for another 5 minutes, and the cycle repeats.</li>
<li>All data is stored based on the key sent, much like a flyweight pattern. Expiration is based off of the last request time of the specific key.</li>
</ul>

<p>My initial thought was to just make my own class with a concurrent hashmaps. However, this will mean I have to handle a lot of the threading mechanisms myself. I feel like RxJava will be a great solution to this, but I'm not sure if such patterns exist. Does anyone have an idea?</p>

<p>I get that the purpose of a <code>Single&lt;T&gt;</code> is meant to only retrieve a single response, so my terms may not be correct.</p>

<p>The following is my attempt, which I will be updating as I go</p>

<pre><code>/**
 * Created by Allan Wang on 07/01/18.
 *
 * Reactive flyweight to help deal with prolonged executions
 * Each call will output a [Single], which may be new if none exist or the old one is invalidated,
 * or reused if an old one is still valid
 *
 * Types:
 * T    input       argument for caller
 * C    condition   condition to check against for validity
 * R    response    response within reactive output
 */
abstract class RxFlyweight&lt;in T : Any, C : Any, R : Any&gt; {

    /**
     * Given an input emit the desired response
     * This will be executed in a separate thread
     */
    protected abstract fun call(input: T): R

    /**
     * Given an input and condition, check if
     * we may used cache data or if we need to make a new request
     * Return [true] to use cache, [false] otherwise
     */
    protected abstract fun validate(input: T, cond: C): Boolean

    /**
     * Given an input, create a new condition to be used
     * for future requests
     */
    protected abstract fun cache(input: T): C

    private val conditionals = mutableMapOf&lt;T, C&gt;()
    private val sources = mutableMapOf&lt;T, Single&lt;R&gt;&gt;()

    private val lock = Any()

    /**
     * Entry point to give an input a receive a [Single]
     * Note that the observer is not bound to any particular thread,
     * as it is dependent on [createNewSource]
     */
    operator fun invoke(input: T): Single&lt;R&gt; {
        synchronized(lock) {
            val source = sources[input]

            // update condition and retrieve old one
            val condition = conditionals.put(input, cache(input))

            // check to reuse observable
            if (source != null &amp;&amp; condition != null &amp;&amp; validate(input, condition))
                return source

            val newSource = createNewSource(input).cache()

            sources.put(input, newSource)
            return newSource
        }
    }

    /**
     * Open source creator
     * Result will then be created with [Single.cache]
     * If you don't have a need for cache,
     * you likely won't have a need for flyweights
     */
    open protected fun createNewSource(input: T): Single&lt;R&gt; =
            Single.fromCallable { call(input) }
                    .timeout(20, TimeUnit.SECONDS)
                    .subscribeOn(Schedulers.io())

    fun reset() {
        synchronized(lock) {
            sources.clear()
            conditionals.clear()
        }
    }

}
</code></pre>
",4407321,,4407321,,2018-01-07 23:48:21,2018-01-07 23:48:21,Resettable Single Rx pattern,<rx-java2><rx-kotlin2>,0,7,0,,,CC BY-SA 3.0
48225258,1,48225383,0,2018-01-12 11:22:37,,16,19950,"<pre><code>val mutableList1: MutableList&lt;TeamInvitationData?&gt;?
val mutableList2: MutableList&lt;TeamInvitationData?&gt;?
</code></pre>

<p><strong>addAll</strong> method can be use to merge nullable mutable list but, here it throws me compile time error. </p>

<p>Example:</p>

<pre><code>val map1 = listOne?.map { TeamInvitationData(it) }
val map2 = listTwo?.map { TeamInvitationData(it) }
map1.addAll(map2)
</code></pre>

<blockquote>
  <p>Type interface failed ,Please try to specify type argument explicitly.</p>
</blockquote>

<p>Here Any way can I merge this two array , thanks in advance.</p>
",1339473,,1339473,,2018-01-12 12:50:44,2019-12-31 06:22:57,Kotlin merge two nullable mutable list,<android><kotlin><rx-kotlin>,3,4,3,,,CC BY-SA 3.0
48261094,1,48374540,0,2018-01-15 10:28:48,,2,597,"<p>I'm writing a wrapper around FirebaseFirestore snapshot listener that emits the changes using RxKotlin Observable.</p>

<p>I wrote the following class which makes use of create() method to create the observable and emit the changes asynchronously when a new data snapshot is available. </p>

<p>The problem is that I'm leaking memory every time I create an instance of this class and I stop using it. What is the best way to rewrite this class without leaking memory?</p>

<p>Any resources about how to create Observables that can emit objects from listeners would be really helpful!</p>

<pre><code>class DocumentRepository&lt;T : ModelWithMetadata&gt;(
        path: List&lt;String&gt;,
        private val model: Class&lt;T&gt;) {

    private var documentReference: DocumentReference

    val observable: Observable&lt;T&gt;

    private var emitter: ObservableEmitter&lt;T&gt;? = null
    private lateinit var item: T


    init {
        documentReference = FirebaseFirestore.getInstance().collection(path[0]).document(path[1])
        for (i in 2..path.lastIndex step 2)
            documentReference = documentReference.collection(path[i]).document(path[i + 1])

        observable = Observable.create(this::listenChanges)
    }

    private fun listenChanges(emitter: ObservableEmitter&lt;T&gt;) {
        this.emitter = emitter
        documentReference.addSnapshotListener { documentSnapshot, _ -&gt;
            item = documentSnapshot.toObject(this.model)
            this.emitter?.onNext(item)
        }
    }

    fun get() {
        emitter?.onNext(item)
    }

    fun put(item: T) {
        item.updatedAt = TimeExtension.now()
        documentReference.set(item)
    }

    fun delete(item: T) {
        documentReference.delete()
    }
}
</code></pre>
",3723306,,0,,,2018-01-22 04:08:50,Avoid memory leak when Observable.create() to emit listener objects,<google-cloud-firestore><rx-java2><rx-android><reactivex><rx-kotlin>,1,1,1,,,CC BY-SA 3.0
48347759,1,48357786,0,2018-01-19 18:52:09,,0,629,"<p>perform a task with an observable and emit value</p>

<pre><code>private val performTask = io.reactivex.Observable.create&lt;Boolean&gt;({ emitter -&gt;
// do somethinf
    emitter.onNext(true)
    emitter.onComplete()
})
</code></pre>

<p>// this is also another observable with retry. I want to retry 2 times, but only if perform task is successful. </p>

<pre><code>fun &lt;T&gt; io.reactivex.Observable&lt;T&gt;.retryAuth(): Observable&lt;T&gt; {
    return this.retry ({ count, error -&gt; 
        if (count == 2 &amp;&amp; error is ApolloException) {
            // do something with performTask and return the value

        } else false
    })
</code></pre>

<p>just need illustration on achieving this</p>
",3100757,,3100757,,2018-01-20 07:24:39,2018-01-20 15:23:23,execute and return value from observable on retry predicate,<java><android><rx-java><rx-kotlin>,1,2,0,,,CC BY-SA 3.0
48398348,1,48411925,0,2018-01-23 09:35:22,,1,1075,"<p>I have my observables defined like this </p>

<pre><code>    val initLoading = Observable.fromCallable { println(""${System.currentTimeMillis()}"") }
            .subscribeOn(Schedulers.computation())
            .delay(WAIT_TIME, TimeUnit.SECONDS)
            .map { ""loading ${System.currentTimeMillis()}"" }
            .observeOn(AndroidSchedulers.mainThread())

    val click = RxView.clicks(button).map { ""click ${System.currentTimeMillis()}"" }
    initLoading.concatWith(click)
            .subscribeBy(
                    onNext = { println(""result $it"") },
                    onError = { throw it }
            )
</code></pre>

<p><code>initialLoading</code> starts running at Activity's <code>onCreate</code> method. <code>click</code> is executed on button click. I have two cases and first is working, second isn't.</p>

<p><strong>case 1</strong> </p>

<p>activity starts and button is clicked <strong>after</strong> <code>WAIT_TIME</code> seconds. Output: </p>

<pre><code>   01-23 13:08:07.170  I/System.out: 1516698487170
   01-23 13:08:17.174  I/System.out: result loading 1516698497172
   01-23 13:08:29.258  I/System.out: result click 1516698509258
</code></pre>

<p><strong>case 2</strong></p>

<p>activity starts and button is clicked <strong>before</strong> <code>WAIT_TIME</code> period is over. Output</p>

<pre><code>   01-23 13:09:07.392 I/System.out: 1516698547392
   01-23 13:09:17.398 I/System.out: result loading 1516698557395
</code></pre>

<p>so, the problem is that the click event is lost. I want the click event to wait for the loading, and then continue working. in short, case 2 output should be the same as case 1.</p>

<p>How can i chive this using rx operators. I tried <code>merge</code> but it just combines both and click event doesn't wait for loading. </p>

<p>I also tried <code>reply, cache, publish, share</code> but couldn't get the right combination of them to work as I want. </p>
",3904645,,0,,,2018-01-23 22:32:22,RxJava: Combining hot and cold observable to wait for each other,<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>,2,0,1,,,CC BY-SA 3.0
48414894,1,0,0,2018-01-24 04:36:42,,2,2701,"<p>I am new in Spring 5 and Reactive Programming. My problem is creating the export feature for the database by a rest API.
User hits GET request -> Server reads data and returns data as a zip file. Because zip file is large, so I need to stream these data.
My code as below:</p>

<pre><code>    @GetMapping(
    value = ""/export"",
    produces = [""application/octet-stream""],
    headers = [
              ""Content-Disposition: attachment; filename=\""result.zip\"""",
              ""Content-Type: application/zip""])
    fun streamData(): Flux&lt;Resource&gt; = service.export()
</code></pre>

<p>I use curl as below:</p>

<pre><code>curl http://localhost/export -H ""Accept: application/octet-stream""
</code></pre>

<p>But it always returns 406 Not Acceptable.
Anyone helps?</p>

<p>Thank you so much</p>
",5867133,,0,,,2018-01-26 02:25:07,Response zip file with WebFlux,<stream><kotlin><reactive-programming><spring-webflux><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
48423869,1,0,0,2018-01-24 13:39:20,,1,335,"<p>I am developing an app that shows a list of items it fetches from the internet.
I have 2 buttons loadMore and refresh, loadMore - loads the next batch of items, refresh - load the items from the beginning.</p>

<p>I am using MVI (Model View Intent) pattern.
Just to make it simple i created an example using a list of numbers each number will represent a batch of items:</p>

<pre><code>    val loadSubject = BehaviorSubject.create&lt;Unit&gt;()
    val refreshSubject = PublishSubject.create&lt;Unit&gt;()

    val list = loadSubject.scanWith(
            { Observable.just(emptyList&lt;Int&gt;()) },
            { listObservable, _ -&gt;
                listObservable
                        .map { it + ++count }
                        .replay().autoConnect()
            }
    )
            .flatMap { it }
            .filter { it.isNotEmpty() }


    val listSubscription = {
        list.subscribe {
            //do whatever with the list
        }
    }

    refreshSubject.scanWith(
            listSubscription,
            { disposable, _ -&gt;
                disposable.dispose()
                listSubscription()
            }
    ).subscribe()
</code></pre>

<p>So now it would work perfectly but the subscription is in my Intent, I need a method with Rx that would do exact same thing but letting my View subscribe.</p>

<p>What I am trying to get is:</p>

<p>let say my list is <code>[1,2,3]</code></p>

<p>on loadMore press ill get <code>[1,2,3,4]</code></p>

<p>on refresh press ill get <code>[5]</code></p>
",7442122,,544406,,2018-01-25 08:26:31,2018-01-29 22:57:02,Rx how to create a list that updates or refreshes on request,<android><rx-java2><rx-android><rx-kotlin2>,2,6,1,,,CC BY-SA 3.0
48468325,1,48468793,0,2018-01-26 19:33:12,,1,460,"<p>I am writing a method in Kotlin:</p>

<pre><code>fun fetchDepositSession(): Completable =
        Observable.fromIterable(session.accounts)
                .map(DepositSession::DepositAccount)
                .toList()
                .doOnSuccess(depositSession::depositAccounts::set)
                .flatMapObservable(Observable::fromIterable)
                .map(DepositSession.DepositAccount::account::get)
                .toCompletable()
</code></pre>

<p>The line <code>.flatMapObservable(Observable::fromIterable)</code> is causing an error:</p>

<p><a href=""https://i.stack.imgur.com/WKMsm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WKMsm.png"" alt=""enter image description here""></a></p>
",2836797,,0,,,2018-01-26 20:07:28,Generic Function References in Rx and Kotlin -- type inference failed,<android><kotlin><rx-java><rx-java2><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
48528325,1,48528504,0,2018-01-30 18:36:40,,1,321,"<p>This never completes:</p>

<pre><code>Completable.complete()
        .andThen{ Completable.complete() }
        .test()
        .assertComplete()
</code></pre>

<p>This does complete:</p>

<pre><code>Completable.complete()
        .andThen(Completable.complete())
        .test()
        .assertComplete()
</code></pre>

<p>According to Jake Wharton:</p>

<p>""You want <code>andThen(Completable.complete())</code>. Note the use of parenthesis and
not curly braces. The latter creates a lambda that doesn't call its emitter.""</p>

<p>Reference: <a href=""https://github.com/ReactiveX/RxJava/issues/5551"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxJava/issues/5551</a></p>

<p>Can anyone explain this in more detail? I thought I understood lambda's but this has really thrown me. </p>
",5963279,,8073652,,2018-01-30 18:51:51,2018-01-30 18:51:51,RXKotlin Lambda Understanding,<lambda><kotlin><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
48568178,1,0,0,2018-02-01 17:08:04,,1,546,"<p>Currently I'm building a project in Kotlin using RxKotlin. My background with Rx is primarily grounded in RxJS. </p>

<p>A pattern I would regularly use for creating <code>hot observables</code> in Typescript would look something along the lines of this: </p>

<pre><code>  private dataStore: IFoo;
  private dataStoreSubject: BehaviorSubject&lt;IFoo&gt; = new BehaviorSubject(this.dataStore);
  public dataStoreObservable: Observable&lt;IFoo&gt; = Observable.from(this.dataStoreSubject);

  public getNetworkData(): Observable&lt;IFoo[]&gt; {
      return this.http.get()
         .map((response: IResponse) =&gt; {
             this.dataStore = &lt;IFoo[]&gt;response;
             this.dataStoreSubject.next(this.dataStore);
             return this.dataStore;
          });
   }
</code></pre>

<p>This would allow me to expose an <code>Observable</code>, without exposing the <code>Subject</code> and subsequently the <code>subject.next();</code> method.</p>

<p>My question is: What would be the most idiomatic way to establish similar logic in RxKotlin or RxJava?</p>
",6754267,,0,,,2019-02-18 19:59:26,Idiomatically creating hot observables with BehaviorSubject in RxKotlin / RxJava,<java><rxjs><rx-java><rx-java2><rx-kotlin>,1,5,0,,,CC BY-SA 3.0
48570561,1,48570680,0,2018-02-01 19:43:36,,0,461,"<p>I want to build a async operation that iterates chars in given string. I have a char array taken by <code>""mystring"".toCharArray()</code>. I want to iterate each 10th character by using RX.</p>

<p>I know i can do it with <a href=""https://developer.android.com/reference/android/os/AsyncTask.html"" rel=""nofollow noreferrer"">AsyncTask</a> and for-loops but i thought RX would be more elegant solution. I have read <a href=""http://reactivex.io/documentation/operators.html"" rel=""nofollow noreferrer"">documentations</a> but did not recognize how to do it.</p>

<p>Another idea in my mind to create a <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html"" rel=""nofollow noreferrer"">PublishSubject</a> and fire <code>onNext()</code> in  a for-loop that index increments by 10 with subscription.</p>

<p>PS: <code>""mystring""</code> can be much more larger like a json, xml or etc. Please feel free to comment about ram profiling.</p>
",2886507,,2886507,,2018-02-02 06:35:48,2018-02-02 06:35:48,For-loop with RxJava2 or RxKotlin,<android><for-loop><android-asynctask><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 3.0
48689211,1,48689307,0,2018-02-08 15:35:11,,0,163,"<p>I'm developing an android app using room and RxAndroid. The problem is that i'm using the next code to refresh the info in my recycler view.</p>

<pre><code>observable.subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe{adapter.data = it}
</code></pre>

<p>if i implement this in my activity it works like a charm. But i want to create an extension function to make the code cleaner when using flowables from the database. I create this funtion </p>

<pre><code>fun &lt;T&gt; Flowable&lt;T&gt;.uiSubscribe(x : (T) -&gt; Unit)  {
this.subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe{x}
</code></pre>

<p>but when i tried to use it, it does nothing. It doesn't trow an error or anything. Does somebody know a way to archive this? or does somebody know why it is not working?</p>
",5420543,,1843331,,2018-02-08 16:25:45,2018-02-08 16:25:45,How to create a extension function to make rx subscription to flowable cleaner?,<android><kotlin><rx-java2><rx-android><rx-kotlin>,1,1,0,,,CC BY-SA 3.0
48753572,1,48753835,0,2018-02-12 18:57:09,,6,5081,"<pre><code>    Observable.just(1)
            .flatMap(object : Function&lt;Int, Observable&lt;Int&gt;&gt; {
                override fun apply(integer: Int): Observable&lt;Int&gt; {
                    return Observable.just(integer * 10)
                }
            })
            .flatMap(object : Function&lt;Int, Observable&lt;Int&gt;&gt; {
                override fun apply(integer: Int): Observable&lt;Int&gt; {
                    return Observable.just(integer * 20)
                }
            })
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(object : Observer&lt;Int&gt; {
                override fun onComplete() {
                }

                override fun onSubscribe(d: Disposable) {
                }

                override fun onNext(t: Int) {
                    Log.d(""result"", """" + t)
                }

                override fun onError(e: Throwable) {
                    e.printStackTrace()
                }
            })
</code></pre>
",2069407,,0,,,2018-08-01 09:23:17,How can I convert this rxjava/rxkotlin flatMap into lambda expression?,<android><lambda><rx-java><flatmap><rx-kotlin>,2,0,1,,,CC BY-SA 3.0
48845703,1,48851716,0,2018-02-17 20:35:45,,0,1409,"<p>I'm trying to sort the emissions of an <code>Observable</code> using either <code>sorted()</code> or <code>toSortedList()</code>.</p>

<p>Here's my code:</p>

<pre><code>bookshelfUseCase.addedBooks(uid, BookshelfRepositoryContract.READ_LIST)
            .flatMap { Observable.fromIterable(it) }
            .doOnNext { Log.d(""RLP1"", it.toString()) }
            .toSortedList { first, second -&gt; first.timestamp.compareTo(second.timestamp) }
            .toObservable()
            .doOnNext { Log.d(""RLP2"", it.toString()) }
            .subscribe { getView().showBooks(it) }
</code></pre>

<p>Here, I'm comparing the timestamp of each <code>Book</code> to get a sorted list for showing it to the user.</p>

<h2>What's the problem?</h2>

<p>The <code>Observable</code> or <code>Single</code> returned by <code>sorted()</code> or <code>toSortedList()</code> doesn't emit anything. Just blank. Zero emissions.</p>

<p>Here's the output of log printed by the <code>doOnNext()</code> before and after <code>toSortedList()</code> is called:</p>

<pre><code>02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=368593, title=The 4-Hour Workweek, year=2007, author=Author(id=210456, name=Timothy Ferriss), rating=3.85, coverImageUrl=https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png, coverImageUrlSmall=https://s.gr-assets.com/assets/nophoto/book/50x75-a91bf249278a81aabab721ef782c4a74.png, checkInTime=0, timestamp=1518895501664)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=12605157, title=The $100 Startup: Reinvent the Way You Make a Living, Do What You Love, and Create a New Future, year=2012, author=Author(id=3367145, name=Chris Guillebeau), rating=3.85, coverImageUrl=https://images.gr-assets.com/books/1345666854m/12605157.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1345666854s/12605157.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=13497818, title=The Casual Vacancy, year=2012, author=Author(id=1077326, name=J.K. Rowling), rating=3.28, coverImageUrl=https://images.gr-assets.com/books/1509893913m/13497818.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1509893913s/13497818.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=29095176, title=Lyrebird, year=2016, author=Author(id=7116, name=Cecelia Ahern), rating=3.76, coverImageUrl=https://images.gr-assets.com/books/1465023152m/29095176.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1465023152s/29095176.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=31823677, title=Tools of Titans: The Tactics, Routines, and Habits of Billionaires, Icons, and World-Class Performers, year=2016, author=Author(id=210456, name=Timothy Ferriss), rating=4.25, coverImageUrl=https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png, coverImageUrlSmall=https://s.gr-assets.com/assets/nophoto/book/50x75-a91bf249278a81aabab721ef782c4a74.png, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=36204090, title=Crushing It!: How Great Entrepreneurs Build Their Business and Influence‚Äîand How You Can, Too, year=0, author=Author(id=1371305, name=Gary Vaynerchuk), rating=4.58, coverImageUrl=https://images.gr-assets.com/books/1514065832m/36204090.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1514065832s/36204090.jpg, checkInTime=0, timestamp=0)
</code></pre>

<p>As you can see, no logs are being printed after the <code>toSortedList()</code> has been called in the chain.</p>

<p>What could I be missing here?</p>

<p>Any help is highly appreciated. Thanks in advance.</p>
",3922919,,0,,,2018-02-18 12:32:40,Sorting emissions in Rx using sorted() or toSortedList() not working,<android><kotlin><rx-java2><rx-kotlin>,1,2,0,,,CC BY-SA 3.0
48922214,1,48922453,0,2018-02-22 07:55:34,,3,1341,"<p>I have code to listen to exactly three fields using <strong>Observables.combineLatest</strong> </p>

<pre><code>Observables.combineLatest(text_name.asObservable(),text_username.asObservable(), text_email.asObservable()).subscribe({ t -&gt;
            if (t.first.toString() != currentName || t.second.toString() != currentUsername) {
                startActionMode()
            } else {
                finishActionMode()
            }
        })
</code></pre>

<p>but when I add another parameter to the <strong>Observables.combineLatest</strong> it throughs error since only 3 inline-parameters can be passed..</p>

<p>Now I would wish to pass 4 parameters in the parameter list for <strong>Observables.combineLatest</strong>.. I know it should be done using an array or a list, passed in as parameter but It's hard for me to figure it out using <strong>Kotlin</strong>.</p>

<p>Help me out.. Thanks in Advance..</p>
",7813796,,6296561,,2018-02-22 10:03:47,2018-02-22 10:03:47,How to Listen to more than Three Fields in Observables.combineLatest,<android><kotlin><kotlin-android-extensions><rx-kotlin>,1,2,0,,,CC BY-SA 3.0
48960693,1,49162279,0,2018-02-24 08:01:19,,1,401,"<p>I've just learned rxjava, rxkotlin, dagger and retrofit, but I don't know the approach to take when communicating with server/db and how to store information locally.
There are 3 questions at the end. Please help</p>

<pre><code>@Singleton
class MyInteractor @Inject constructor() {

@Inject lateinit var context: Context
@Inject lateinit var restClient: RestClient

private var subscriptions: MutableList&lt;Disposable&gt; = mutableListOf()
private var settingsSubject: BehaviorSubject&lt;SettingsDTO&gt; = BehaviorSubject.create()

fun initData() {
    initSettings()
}

fun unsubscribeAll() {
    subscriptions.forEach({ subscription -&gt; subscription.dispose() })
}

private fun initSettings() {
    val settingsObservable = restClient.getSettings()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())

    val settingsServerSubscription = settingsObservable.subscribe({ response -&gt;
        run {
            settingsSubject.onNext(response.body())
        }
    }, {
       //TODO handle errors
    })
    subscriptions.add(settingsServerSubscription)


    //subscribe database to subject changes
    val settingsDatabaseSubscription = settingsSubject.subscribe { setting -&gt;
        //TODO save or update db
    }
    subscriptions.add(settingsDatabaseSubscription)
}

fun getSettings(callback: SettingsCallback) {
    callback.onFetchedSettings(settingsSubject.value)
}
}
</code></pre>

<ol>
<li>Do I need to save the Disposable subjects and unsubscribe? Or is done automatically? (I'm saving all of the subscriptions in a list then undispose all at once)</li>
<li>Is this the right approach? I'm initializing all settings in the initData method, and call it at creation of an activity. 
The data is stored in a behaviour subject (settingsSubject) and I subscribe on that subject to save changes in database,
so everytime I want to change a setting I'm calling the rest client and then update the subject (db will be updated because of the subscription)</li>
<li>On getSettings method, should I use the callback or just return the settingsSubject value?</li>
</ol>
",6949710,,6949710,,2018-02-24 10:46:47,2018-03-07 22:29:46,What is the right approach using rxkotlin or rxjava in android when communicating with server and db?,<android><dagger-2><rx-kotlin2>,1,0,0,,,CC BY-SA 3.0
48967171,1,48971608,0,2018-02-24 20:17:23,,0,716,"<p>In my application I'm using RxJava2 and new class from Architecture Components ViewModel. In my case, I need to push SQL clause to ViewModel, which will do some magic and return Observable that will give me the data I need. Everything works fine, but I am not sure if I am using RX in the best way. </p>

<p>My data flow:
ViewModel has PublishSubject on which I am pushing SQL's. ViewModel has also Observable which is created by mapping subject. Also, I used distinctUntilChanged on Subject, to prevent from executing the same query again. 
 To cache data I used replay(1).autoconnect(1) on Observable, but that approach had a flaw. Sometimes my Subject pushed Sql when Observable wasn't yet connect, and my data never arrived to me. Should I use BehaviourSubject? Or maybe I shouldn't use replay(1).autoconnect(1) in the first place? Or maybe my whole flow is wrong? Example:</p>

<pre><code>val listSubject: Subject&lt;RawSql&gt; = PublishSubject.create()
val sqlListEmitter: Observable&lt;List&lt;T&gt;&gt; =
        listSubject
                .subscribeOn(Schedulers.computation())
                .map { // SOME MAGIC HERE }
                .replay(1).autoConnect(1, { compositeDisposable.add(it) })
</code></pre>
",7799729,,8551764,,2018-12-02 19:58:28,2018-12-02 19:58:28,Best way to cache data in Android with ViewModel and RxJava2,<android><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
49031599,1,49811981,0,2018-02-28 14:14:42,,3,600,"<p>I was first introduced to reactive programming with <strong>ReactiveCocoa</strong> several years ago. In there they had the notion on <code>RACCommand</code>s, which was carried over to <strong>RxSwift</strong> with the extension library <strong><a href=""https://github.com/RxSwiftCommunity/Action"" rel=""nofollow noreferrer"">Action</a></strong>.</p>
<p>As stated on their GitHub page:</p>
<blockquote>
<p>An action is a way to say &quot;hey, later I'll need you to subscribe to this thing.&quot;</p>
<p>Actions accept a <code>workFactory</code>: a closure that takes some input and produces an observable. When <code>execute()</code> is called, it passes its parameter to this closure and subscribes to the work.</p>
<ul>
<li>Can only be executed while &quot;enabled&quot; (true if unspecified).</li>
<li>Only execute one thing at a time.</li>
<li>Aggregates next/error events across individual executions.</li>
</ul>
</blockquote>
<p>In my experience it is an absolutely <em>indispensable</em> tool in the reactive programming toolbox when doing robust, reactive iOS development.</p>
<hr />
<p>Now we would like to carry this over to <strong>Android</strong> app as well. But after countless hours of research I have not been able to find a corresponding component for either <strong>RxJava</strong> or <strong>RxKotlin</strong>.</p>
<p>The implementation in Swift is relatively straight forward, so we <em>could</em> just port it, but I'd first like to hear if:</p>
<ol>
<li>This really does not exists, and if so</li>
<li>Is there an Android specific reason for this to not exist, i.e. a reason <strong>not</strong> to port it</li>
</ol>
",746968,,-1,,2020-06-20 09:12:55,2018-04-13 07:55:37,RxSwift like Actions for Android,<android><ios><rx-java><rx-swift><rx-kotlin>,1,3,0,,,CC BY-SA 3.0
49076391,1,49077269,0,2018-03-02 19:53:21,,2,148,"<p>I'm facing this problem. Im using room to create the local database of my app. Let's say i have an Entity call User and a UserDao. It looks like this:</p>

<pre><code>@Dao
interface UserDao: BaseDao&lt;User&gt;{
    @Query(""SELECT * FROM user WHERE remote_id = :remoteId"")
    fun getUser(remoteId : Long) : Single&lt;User&gt;
}
</code></pre>

<p>Nothing weird in this point, but what i want to do is be able to Changue the type of return in these  functions. I want this because sometimes i need to get a Single but in other cases i need to get a Flowable. In this two cases the query is the same an the only thing than chagues is the type of return and i don't want to do something like this.</p>

<pre><code>@Dao
interface UserDao: BaseDao&lt;User&gt;{

    @Query(""SELECT * FROM user WHERE remote_id = :remoteId"")
    fun getUserSingle(remoteId : Long) : Single&lt;User&gt;

    @Query(""SELECT * FROM user WHERE remote_id = :remoteId"")
    fun getUserFlowable(remoteId : Long) : Flowable&lt;User&gt;
 } 
</code></pre>

<p>Any idea how to do this in a clean way? </p>
",5420543,,7756492,,2018-04-16 08:43:41,2018-04-16 08:43:41,How to implement different kinds of return to the same query using Room and Android Rx?,<android><rx-android><rx-kotlin2>,2,0,1,,,CC BY-SA 3.0
49188172,1,49189651,0,2018-03-09 06:55:39,,4,1887,"<p>Facing Problem on getting Response in ArrayList. </p>

<p>I have following Respose on String value </p>

<pre><code> var res_message: String = """"
 res_message = ""${result.vehicletypes} ""
</code></pre>

<p>Getting below Value on this String</p>

<pre><code>     [VehicleType(_id=1, vehicleType=Hatchback, __v=0), 
      VehicleType(_id=2, vehicleType=Maruti, __v=0), 
      VehicleType(_id=3, vehicleType=Honda, __v=0), 
      VehicleType(_id=4, vehicleType=Bike, __v=0)] 
</code></pre>

<p>Retrofit Result is </p>

<pre><code> vehicletypes = {ArrayList@6055}  size = 4
 0 = {Model$VehicleType@6058} ""VehicleType(_id=1, 
vehicleType=Hatchback, __v=0)""
 1 = {Model$VehicleType@6059} ""VehicleType(_id=2, 
 vehicleType=Maruti, __v=0)""
  2 = {Model$VehicleType@6060} ""VehicleType(_id=3, 
 vehicleType=Honda, __v=0)""
  3 = {Model$VehicleType@6061} ""VehicleType(_id=4, 
  vehicleType=Bike, __v=0)""
</code></pre>

<p>Below Code snippest sending request to API. </p>

<pre><code>            disposable = apiServices.getVehicle(token)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { result -&gt;


                        res_message = ""${result.vehicletypes} ""
                        Log.d(""Type=="", res_message)
                    },
                    { error -&gt;
                        res_message = ""${error.message}""
                        // validateToken()
                    }
            )
</code></pre>

<p><em>Model Class</em></p>

<pre><code>  data class Vehicles(val success: Boolean, val vehicletypes: List&lt;VehicleType&gt;, val message: String)
  data class VehicleType(val _id: String, val vehicleType: String, val __v: String)
</code></pre>

<p>I want to get this value on Arralist <strong>VehicleType</strong> List on below <strong>vehicleListArray</strong></p>

<pre><code>   private var vehicleListArray: ArrayList&lt;Model.VehicleType&gt;? = null
</code></pre>

<p>How we can achieve this. 
<strong>Thanks in advance.</strong> </p>
",3992260,,3992260,,2018-03-09 08:40:14,2018-03-09 13:04:40,How to get Json Response in Arraylist from List<Item> using RxJava and Kotlin,<android><kotlin><retrofit2><rx-kotlin>,2,1,0,,,CC BY-SA 3.0
49215549,1,49215842,0,2018-03-11 00:51:10,,1,120,"<p>I have an rx chain that calls an API through Retrofit. I subscribe to my API service, with standard rx <code>subscribe({...})</code> method and pass a lambda to it. Unfortunately when  my call is finally completed, all the code I have added to be executed inside lambda is totally ignored. AndroidStudio suggested a fix which basically adds an inline function <code>run</code> to my lamda and... it magically works. I have no idea what's happening. Why does it not work without <code>run</code>? What does <code>run</code> do?</p>

<p>The code follows:</p>

<pre><code>valuesServiceApi.getValues()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ data -&gt;
                run { //&lt;- What's this?
                    val cs = data.creditReportInfo.score
                    view.setCreditScore(cs)
                    Logger.getLogger(""success:"").info(""credit score $cs"")
                }

            })
</code></pre>
",1939370,,0,,,2018-03-11 03:44:54,"Lambda's are ignored until ""run"" is added",<kotlin><rx-kotlin2>,2,0,0,,,CC BY-SA 3.0
49257702,1,49280175,0,2018-03-13 13:40:14,,0,1514,"<p>What I trying to do is listen to socket data and convert into an observable string that my UI can Subscribe this event and do Change on UI </p>

<p>So far I created a class SocketConnection maintain in dagger connection happen properly and received data and able to do with interface correctly, but want to apply with rxkotlin. </p>

<p>Using Socket.io,kotlin</p>

<h3>SocketConnection class</h3>

<pre><code> class SocketConnection : SocketStreamListener {

    private var socket: Socket? = null

   var responseSocket :ResponseHandler?= null
    companion object {
        var instance = SocketConnection()

    }

    override fun createSocket(socketQuery: SocketQuery): Socket? {
        try {
            val okHttpClient = UnsafeOkHttpClient.getUnsafeOkHttpClient()
            IO.setDefaultOkHttpWebSocketFactory(okHttpClient)
            IO.setDefaultOkHttpCallFactory(okHttpClient)
            val opts = IO.Options()
            opts.reconnection = false
            opts.callFactory = okHttpClient
            opts.webSocketFactory = okHttpClient
            opts.query = ""userID="" + socketQuery.userID + ""&amp;token="" + socketQuery.token
            socket = IO.socket(CommonContents.BASE_API_LAYER, opts)
            L.d(""Socket object created"")
        } catch (e: URISyntaxException) {
            L.e(""Error creating socket"", e)
        }
        return socket
    }

    override fun createSocketListener(socket: Socket) {
        L.d(""inside the socket Listner"")
        socket.connect()?.on(Socket.EVENT_CONNECT, {
            L.d(""connected"")
            listenSocketEvents()
            //socketDataListener()
            createMessageListener()

        })?.on(Socket.EVENT_DISCONNECT,
                {
                    L.d(""disconnected"")
                    return@on
                })

    }


    /**
     * function used to listen a socket chanel data
     */
    private fun listenSocketEvents() {


       /* socket?.on(""1502"", { args -&gt;
      // This Will Work 
             L.d(""Socket market depth event successfully"")
            val socketData = args[0] as String
            L.d(socketData)
         //   instance.data = Observable.just(socketData)
            //data!!.doOnNext({ socketData })

            *//*
            data = args[0] as String
             for (i in 0 until arr.size) {
                 arr[i].socketStreamingData(data)
             }*//*

        })*/

    }

// This Will Not Work
    fun socketDataListener(): Observable&lt;String&gt;{
      return Observable.create({
          subscibe -&gt;
         // L.d(""Socket market depth event successfully"")
            socket?.on(""1502"", { args -&gt;
                L.d(""Socket market depth event successfully"")
                val socketData = args[0] as String
                subscibe.onNext(socketData)
            })

        })
    }

  }
</code></pre>

<h3>Repository</h3>

<pre><code>fun getSocketData(): Observable&lt;String&gt; {
   // L.e("""" + SocketConnection.instance.socketDataListener())
    return SocketConnection.instance.createMessageListener()
}
</code></pre>

<h3>ViewModel</h3>

<pre><code>fun getSocketData(): Observable&lt;String&gt;{
    return groupRepository.getSocketData()
}
</code></pre>

<h3>OnFragement (UI)</h3>

<pre><code>private fun getSocketUpdate(){
    subscribe(watchlistViewModel.getSocketData()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({
                L.d(""SocketData :  "" + it.count())

            }, {
                L.e(""Error"")
            }))
}
</code></pre>

<p>In this UI using disposable subscribe method into base class.</p>

<p>Please let me know what i doing wrong thanx in advance </p>
",9054548,,9054548,,2018-03-14 12:14:00,2018-03-14 14:22:45,RxKotlin with Socket.io in Android,<android><socket.io><kotlin><rx-kotlin2>,1,4,0,,,CC BY-SA 3.0
49524051,1,0,0,2018-03-27 23:47:32,,0,343,"<p>Can I use Rx Kotlin + Rx Android without adding Rx Java? Or Rx Kotlin is depended upon Rx Java.</p>
",1268634,,0,,,2018-04-04 14:12:37,Is RxKotlin Depend upon RxJava in Android?,<rx-android><rx-kotlin2>,1,0,0,,,CC BY-SA 3.0
49541333,1,49543422,0,2018-03-28 18:05:30,,0,742,"<p>Let imagine situation on Kotlin, when we try get request but hasn't internet connection and we get error, then show AlertDialog, and we need retry request if user click on ""positive button"".</p>

<p>This method check for exist user by phone number:</p>

<pre><code>override fun checkPhone(phone: String, context: Context) {
    view?.let {
        it.showOrHideProgressBar(true)
        apiManager.checkPhone(phone)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe({ result -&gt;
                    view?.showOrHideProgressBar(false)
                    if (result.user_exists) {
                        view?.showLogin()
                    } else {
                        val code = result.confirmation_code
                        confirmPhone(phone, code, context)
                    }
                }, { error -&gt;
                    handleAnyError(error, context)
                }).addToCompositeDisposable(compositeDisposable)
    }
}
</code></pre>

<p>And here common method for handle errors:</p>

<pre><code>private fun handleAnyError(it: Throwable, context: Context) {
    view?.showOrHideProgressBar(false)
    when (it) {
        is SocketTimeoutException -&gt; showDialogWithException(context)
        is UnknownHostException -&gt; showDialogWithException(context)
        else -&gt; {
            if (it.message.equals(MESS_429)) {
                view?.showAnyError(context.getString(R.string.err_429))
            } else if (it.message.equals(MESS_422)) {
                view?.showAnyError(context.getString(R.string.err_422))
            }
        }
    }
}
</code></pre>

<p>Finally, method to show dialog suggesting retrying request when click positive button:</p>

<pre><code>fun showDialogWithException(context: Context) {
if (!(context as Activity).isFinishing) {
    DialogInternetUtils().showOkDialog(
            context,
            context.getString(R.string.no_internet_connection),
            DialogInterface.OnClickListener
            { dialogInterface, i -&gt;
                dialogInterface?.dismiss()
                if (i == Dialog.BUTTON_NEGATIVE) {
                    dialogInterface!!.dismiss()
                    return@OnClickListener
                } else if (i == Dialog.BUTTON_POSITIVE) {
                    // here handle click button positive, need retry request
                }
            })
}
</code></pre>

<p>}</p>

<p>Please, help me finish handle click on positive button to retry request.
I guess, need handle error in methods <code>.doOnError()</code> or <code>.onErrorResumeNext()</code> but I'm stuck here...</p>
",7369357,,0,,,2018-03-28 20:15:59,"Kotlin, how can retry request if get error when tap on button of dialog",<android><kotlin><kotlin-extension><rx-kotlin>,1,0,0,,,CC BY-SA 3.0
49644088,1,0,0,2018-04-04 06:19:27,,0,414,"<p>This is my code template</p>

<pre><code>getLastMessageSingle()
.flatmap(
    message-&gt;
    if(message.image==null)
        Single.Just(message)
    else
        Single.zip(t1,t2,BiFunction&lt;String,String,String&gt;{
            s1,s2-&gt;
          //body sets data to message

          message
        })
)
//subscribe part
</code></pre>

<p>I found that Single.Just will execute but zip part is never executed. Am i doing any thing wrong or flat function does not support zip in it.</p>

<p>Any help will be appreciated thanks.</p>

<p>Solution:</p>

<p>It was my mistake second single t2 did not produce a response.</p>
",5311864,,5311864,,2018-04-04 06:56:18,2018-04-04 06:56:18,RxKotlin zip inside flatmap,<android><reactivex><rx-kotlin>,2,3,0,,,CC BY-SA 3.0
49683093,1,49683405,0,2018-04-05 23:35:57,,1,437,"<p>my problem is this. I have the next code</p>

<pre><code>Observable.fromIterable(this)
            .flatMap { project -&gt;
                val date = async(CommonPool) {
                    App.db.projectResponseDao().getLastUpdate(project.uid.toString())
                }
                val query = ProjectQuery.builder().id(project.uid.toString()).date(date.await()).build()
                val baseGraphQlUrl = context.getString(R.string.base_graphql_url)
                val apolloCall: ApolloCall&lt;ProjectQuery.Data&gt; = ApiClient.getApolloClient(context.getSessionToken(), baseGraphQlUrl).query(query)
                val remoteObservable: Observable&lt;Pair&lt;Project, Response&lt;ProjectQuery.Data&gt;&gt;&gt; = Observable.combineLatest(
                        Observable.just(project),
                        Rx2Apollo.from(apolloCall),
                        BiFunction { localProject, response -&gt; Pair(localProject, response) })
                remoteObservable
            }
</code></pre>

<p>So, I'm getting a date from a Room table in my android application. I'm using an async method because the room queries need to be done in a different thread from UI. So, with the result, I want to build a new query to a remote database. The problem is I want to be sure that date is already initialized at the moment I create my query. With that in mind, I use await method, but an error is given to me. it said I cant call await function in a no suspend function. So, can you think of a way to solve this? or how to fix it? thank you </p>
",5420543,,1904517,,2018-04-11 06:05:44,2018-04-11 06:05:44,How to use await method inside a flatMap?,<android><kotlin><rx-java><kotlinx.coroutines><rx-kotlin2>,1,0,0,,,CC BY-SA 3.0
49685851,1,49686992,0,2018-04-06 05:20:03,,1,538,"<p>I use RxJava 2 <code>Observable</code> to wrap barcode scanner in one of my app. This snippet show how I subscribe to <code>Observable</code> and listen to it's events</p>

<pre><code>override fun start() {
    disposables.addAll(subscribeToBarcodeReader(), loadUser())
}

private fun subscribeToBarcodeReader(): Disposable {
    return barcodeObservable
        .subscribeOn(bgScheduler)
        .observeOn(mainScheduler)
        .subscribeBy(
                onNext = { barcode -&gt; saveBarcode(barcode) },
                onComplete = { Log.d(TAG, ""Barcode observable complete"") },
                onError = { e -&gt; Log.d(TAG, ""Barcode observable error"", e) }
        )
}
</code></pre>

<p><code>barcodeObservable</code> is object of <code>Observable&lt;Barcode&gt;</code> type. This all works fine on real device with real barcode scanner. Now I want to unit test the <code>saveBarcode()</code> method and try to mock the <code>Observable&lt;Barcode&gt;</code> this way</p>

<pre><code>@RunWith(MockitoJUnitRunner::class)
class OrbFoldersPresenterTests {

    @Mock
    private lateinit var jobService: FolderJobService
    private val bgScheduler = TestScheduler()
    private val mainScheduler = TestScheduler()
    private val barcodeObservable: Observable&lt;Barcode&gt; = Observable.just(Barcode(
            ""2500020109205"", LocalDateTime.now().toString()))
    @Mock
    private lateinit var userStore: UserStore
    @Mock
    private lateinit var prefs: Preferences
    @Mock
    private lateinit var barcodeService: BarcodeReadService

    @Test
    fun testBarcodeSave() {
        val jobId = 201804040001
        val disposables = CompositeDisposable()

        whenever(userStore.authorizedUser()).thenReturn(Maybe.just(User()))

        val presenter = OrbFoldersPresenter(jobId, jobService, disposables, bgScheduler,
                mainScheduler, barcodeObservable, userStore, prefs, barcodeService)
        presenter.start()
    }
}
</code></pre>

<p>I'm expecting that when I call <code>presenter.start()</code> presenter must subscribe to <code>barcodeObservable</code> and receive <code>onNext()</code> event with object I've provided. But this isn't happening. What am I doing wrong? </p>
",1120398,,0,,,2018-04-06 06:49:05,RxJava 2 mock Observable doesn't work,<android><kotlin><rx-java2><rx-kotlin2>,2,0,0,,,CC BY-SA 3.0
49782036,1,49782471,0,2018-04-11 18:22:43,,0,1426,"<p>I have this problem. I'm trying to sync a local database into my android app with a remote app. I'm creating the logic to upload the new info created locally and the server responds with the remote id save it in the server. To archive this, I'm using a method that takes an array of objects an return an Observable which emit the response of the server for each element.
Like this.</p>

<pre><code>val dailyEntries = App.db.dailyEntryDao().getDailyEntriesCreated()
            dailyEntries.sync(context) //Return an observable
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({                        
                        val response = DailyEntry(it)//Creates a daily entry using 
                                                      the response from the server
                        thread {                                
                          App.db.dailyEntryDao().update(response)
                        }
                    }, {
                        it.printStackTrace()
                    }, {
                        uploadEnclosures()
                    })
</code></pre>

<p>How you can see, in the onSuccess from the current observable calls another method. It uses the same logic and is showing ahead. </p>

<pre><code>private fun uploadEnclosures() {
        thread {
            val enclosures = App.db.enclosureDao().getEnclosuresCreated()
            enclosures.sync(context)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        val response = Enclosure(it)
                        thread {                                
                            App.db.enclosureDao().update(response)
                        }
                    }, {
                        it.printStackTrace()
                    }, {
                        uploadSmokeTest()
                    })
        }
    }
</code></pre>

<p>It goes on with all the tables. Always we perform the update of the next table in the onSuccess of the current Observable. It is done like this because i need to make the sync in a specific order.</p>

<p>My question is, Is there a way to merge all these Observables in just one to perform a single Subscribe and controlling each onNext emotion?</p>

<p>Thanks for the answers </p>
",5420543,,0,,,2018-04-11 19:16:21,How to Merge multiple Observables with diferents call backs into one single Stream?,<android><kotlin><rx-java><reactive-programming><rx-kotlin>,1,2,0,,,CC BY-SA 3.0
49810518,1,49811822,0,2018-04-13 06:23:15,,8,2446,"<p>I'm having a scenario where I need to periodically call an API to check for a result. I'm using <code>Flowable.interval</code> to create an interval function which calls the API.</p>

<p>However, I'm having trouble with backpressure. In my example below, a new single is created on each tick in the interval. The desired effect is to only call the API if a call is not already in progress</p>

<pre><code>Flowable.interval(1, 1, TimeUnit.SECONDS).flatMap {
        System.out.println(""Delay $it"")

        //simulates API call
        Single.just(1L).doAfterSuccess {
            System.out.println(""NEW SINGLE!!!"")
        }.delay(4, TimeUnit.SECONDS).doAfterSuccess {
            System.out.println(""SINGLE SUCCESS!!!"")
        }.toFlowable()
    }.subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()).blockingFirst()
</code></pre>

<p>I can solve this using a filter variable like so:</p>

<pre><code>var filter = true

Flowable.interval(1, 1, TimeUnit.SECONDS).filter {
    filter
}.flatMap {

    System.out.println(""Delay $it"")

    Single.just(1L).doOnSubscribe {
        filter = true
    }.doAfterSuccess {
        System.out.println(""NEW SINGLE!!!"")
    }.delay(4, TimeUnit.SECONDS).doAfterSuccess {
        System.out.println(""SINGLE!!!"")
        filter = true
    }.toFlowable()
}.subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()).blockingFirst()
</code></pre>

<p>But it seems like a hacky solution. I've tired applying <code>onBackPressureDrop</code> after the <code>interval</code> function, but it has no effect.</p>

<p>Any suggestions? </p>
",565319,,0,,,2018-04-13 08:12:54,RxJava Flowable.Interval backpressure when flatmap with single,<kotlin><rx-java2><rx-kotlin2>,1,1,0,,,CC BY-SA 3.0
49851127,1,0,0,2018-04-16 06:50:47,,1,280,"<p>I was looking other questions but this one is using a different method.</p>

<p>I‚Äôm using MVVM in my Android app.</p>

<p>Actually this is the way that I‚Äôm getting data from my server: </p>

<ul>
<li>Inject dataManager into viewModel.</li>
<li>viewModel calls dataManager->fetchUsers</li>
<li>fetchUsers make request to server and return an Observable of Several which in this case should be Several but it‚Äôs generic.</li>
<li>viewModel subscribe to this request and expect a Several.</li>
<li>At this point everything works besides Several doesn‚Äôt have a list of User. This several have a list of LinkedTreeMap</li>
</ul>

<p><a href=""https://i.stack.imgur.com/UDn9X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UDn9X.png"" alt=""enter image description here""></a> </p>

<p>I tried to change my dataManager to return a string then map the response in my viewModel but the thing with this is that I will have to do that in every request.</p>

<p>Also I tried to map the request in my dataManager but I got the same link tree map array. </p>

<p>The thing with TypeToken approach is that I have to map in my viewModel. </p>

<p><strong>UPDATED</strong></p>

<p>UsersViewModel</p>

<pre><code> private fun fetchUsers() {
        isLoading.set(false)
        compositeDisposable += dataManager.GET&lt;User&gt;(classJava = User::class)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe( { response -&gt;
                    isLoading.set(false)
                   // Here the response should be a several with a list of users.
                }, { err -&gt;
                    isLoading.set(false)
                })
    }
</code></pre>

<p>GET function:</p>

<pre><code> override fun &lt;T&gt; GET(classJava: KClass&lt;*&gt;): Single&lt;Several&lt;T&gt;&gt; {

    return Rx2AndroidNetworking.get(""EndPoint"")
            .addHeaders(""Authorization"",  apiHeader.protectedAPIHeader.accessToken!!)
            .setOkHttpClient(APIClient.getUnsafeClient())
            .build()
             // Also I tested with
             // .getObjectSingle(Several::class.java) // The thing is that I can't assign the type &lt;T&gt; with this approach.
            .stringSingle
            .map {

                val fromJSON = fromJson&lt;Several&lt;T&gt;&gt;(it)
                fromJSON

            }
}
</code></pre>

<p>fromJson function:</p>

<pre><code>inline fun &lt;reified T&gt; fromJson(json: String): T = Gson().fromJson(json, object: TypeToken&lt;T&gt;() {}.type)
</code></pre>

<p>Several.kt</p>

<pre><code>data class Several&lt;T&gt;(val items: MutableList&lt;T&gt;)
</code></pre>

<p>If I change my GET function to return a String then in UsersViewModel I add a .map like this</p>

<pre><code>private fun fetchUsers() {
        isLoading.set(false)
        compositeDisposable += dataManager.GET&lt;User&gt;(classJava = User::class)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .map(
                    val severalUsers = fromJson&lt;Several&lt;User&gt;&gt;(it)
                    severalUsers 

                )
                .subscribe( { response -&gt;
                    isLoading.set(false)
                   // usersLiveData.value = response
                }, { err -&gt;
                    Log.e(""tag"", ""Ocurred some error"")
                    isLoading.set(false)
                })
    }
</code></pre>

<p>Then I would have a list of Users as expected but What I dont want to do is map the response in UsersViewModel because I would have to do in every single request that expect a list of items.</p>

<p>Is there any way that I could get a several object without map in my viewmodel?</p>
",6606971,,6606971,,2018-04-16 13:40:01,2018-04-16 13:40:01,Kotlin Generic List Parsing,<android><kotlin><android-databinding><kotlin-extension><rx-kotlin>,0,3,0,,,CC BY-SA 3.0
49929073,1,49931641,0,2018-04-19 19:45:02,,0,303,"<p>What I would like to do is create a function which runs another function every second. The second function returns <code>Observables&lt;A&gt;</code> and I want the first function to return <code>Observables&lt;A&gt;</code> as well instead of <code>Observable&lt;Observable&lt;A&gt;&gt;</code></p>

<p>for example:</p>

<pre><code>private A calcA(){
   ...
   return new A(...)
}

public Observable&lt;A&gt; getAs(){
   return Observable.create( subscriber -&gt; {
      Bool condition = ...
      do {
         subscriber.onNext(calcA())
      } while (condition)
      subscriber.onComplete()
   })
}

public Observable&lt;A&gt; pollAs(){
   return Observable.create(subscriber -&gt; {
      do {
         subscriber.onNext(getAs()) // Flatten here I guess
         Thread.sleep(1000)
      } while(true)
   })
</code></pre>

<p>So I would like to do something similar (I tried to write this in a Java-ish way, but I will use Kotlin)</p>
",2092686,,0,,,2018-04-20 20:22:19,Flatten Observable of Observables,<rx-java><observable><reactivex><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
50019891,1,50056968,0,2018-04-25 10:26:22,,0,1039,"<p>My outer <code>RecyclerView</code> crashes either with</p>

<pre><code>IllegalArgumentException: Scrapped or attached views may not be recycled. isScrap:false isAttached:true...
</code></pre>

<p>or</p>

<pre><code>IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first.
</code></pre>

<p>Like the title suggests I have an <code>RecyclerView</code> in the list item layout of the first <code>RecyclerView</code>. This layout is used to display messages and the 
inner <code>RecyclerView</code> to display attachments that come with the message. The inner <code>RecyclerViews</code> visibility is set to either <code>GONE</code> or <code>VISIBLE</code> depending whether the message has any attachments or not. The simplified outer list item layout looks like this</p>

<pre><code>ConstraintLayout
    TextView
    TextView
    TextView
    RecyclerView
</code></pre>

<p>And the part of the adapter that handles the inner <code>RecyclerView</code> looks like this</p>

<pre><code>private fun bindFiles(message: Message?) = with(itemView) {
      if (message != null &amp;&amp; message.attachments.isNotEmpty())
      {
            sent_message_attachments.setAsVisible()
            sent_message_attachments.layoutManager = GridLayoutManager(this.context,Math.min(message.attachments.size,3))
            sent_message_attachments.adapter = AttachmentAdapter(message.attachments)
            sent_message_attachments.itemAnimator = null
            sent_message_attachments.setHasFixedSize(true)
      }
      else{
            sent_message_attachments.setAsGone()
            sent_message_attachments.adapter = null
            sent_message_attachments.layoutManager = null
      }
    }
</code></pre>

<p>The bug has something to do with the way I fetch the attachments in the inner adapter since once I disable the part that start the download process, everything is fine. There's no problem when loading images from the device, but once I start the download process, everything goes to hell. This is the part that handles images and kicks off the download process in the inner adapter. I have functions for videos and for other file types that are pretty much the same exact thing but use slightly different layout.</p>

<pre><code>private fun bindImage(item: HFile?) = with(itemView) {
      if (item != null)
      {
        if (item.isOnDevice &amp;&amp; !item.path.isNullOrEmpty())
        {
          if (item.isGif)
          {
            attachment_image.displayGif(File(item.path))
          }
          else
          {
            attachment_image.displayImage(File(item.path))
          }
        }
        else
        {
          //TODO: Add option to load images manually
          FileHandler(item.id).downloadFileAsObservable(false)
              .subscribeOn(Schedulers.io())
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe(
                  { progress -&gt;
                    //TODO: Show download process
                  },
                  { error -&gt; 
                  error.printStackTrace()
                  //TODO: Enable manual retry 
                  },
                  { notifyItemChanged(adapterPosition)} //onComplete
              )
        }
      }
  }
</code></pre>

<p>I use the same structure as above in my <code>DiscussionListAdapter</code> to load discussion portraits (profile pictures etc.) and it does not have the same issue.</p>

<p>These are the extensions functions used to inflate the viewHolders and to display the images</p>

<pre><code>fun ViewGroup.inflate(layoutRes: Int): View
{
  return LayoutInflater.from(context).inflate(layoutRes, this, false)
}

fun ImageView.displayGif(file:File){
  GlideApp.with(context).asGif().load(file).transforms(CenterCrop(), RoundedCorners(30)).into(this)
}

fun ImageView.displayImage(file:File){
  GlideApp.with(context).load(file).transforms(CenterCrop(), RoundedCorners(30)).into(this)
}
</code></pre>

<p>I've been on this for the past couple of days and just can't get my head around it. Any help in any direction is greatly appreciated. I know my explanations can be a bit all over the place so just ask for clarification when needed :)</p>

<h2>UPDATE</h2>

<p>I have now been able to produce this with a <code>GridLayout</code> as well as with <code>RecyclerView</code>. It's safe to assume that the nested <code>RecyclerViews</code> were not the culprit here. I even tried to ditch the Rx-piece that handled loading the images and created an <code>IntentService</code> for the process, but the same crashes still occur.</p>

<p>With <code>GridLayout</code> I mean that instead of having another adapter to populate the nested <code>RecyclerView</code> I use only one adapter to populate the message and to inflate and populate views for the attachments as well and to attach those views to the nested <code>GridLayout</code>.</p>

<p>The crash happens when I start to download a file and then scroll the view, that is supposed to show the downloaded file, out of the screen. That view should get recycled but for some reason the download process (which in my test cases only takes around 100ms-400ms) causes the app to throw one of the two errors mentioned in the original question. It might be worth noting that I'm using <code>Realm</code> and the adapter takes in a <code>RealmResults&lt;Message&gt;</code> list as it's dataset. My presenter looks for changes in the list and then notifies the adapter when needed (changed due to the implementation of <code>IntentService</code>).</p>

<p>This is how I'm capable to reproduce this time and time again:</p>

<ol>
<li>Open a discussion that has messages with attachments</li>
<li>Start to scroll upwards for more messages</li>
<li>Pass a message with an attachment and scroll it off screen while it's still loading</li>
<li>Crash</li>
</ol>

<p>There is no crash if I stop and wait for the download to complete and everything works as intended. The image/video/file gets updated with a proper thumbnail and the app wont crash if I scroll that out of view.</p>

<h2>UPDATE 2</h2>

<p>I tried swapping the nested <code>ViewGroup</code> for a single <code>ImageView</code> just to see is the problem within the nestedness. Lo and behold! It still crashes. Now I'm really confused, since the <code>DiscussionListAdapter</code> I mentioned before has the same exact thing in it and that one works like a charm... My search continues. I hope someone, some day will benefit from my agony.</p>

<h2>UPDATE 3</h2>

<p>I started to log the parent of every <code>ViewHolder</code> in the <code>onBindViewHolder()</code> function. Like expected I got <code>nulls</code> after <code>nulls</code> after <code>nulls</code>, before the app crashed and spew this out.</p>

<pre><code>04-26 21:54:50.718 27075-27075/com.hailer.hailer.dev D/MsgAdapter: Parent of ViewHolder: android.view.ViewOverlay$OverlayViewGroup{82a9fbc V.E...... .......D 0,0-1440,2168}
</code></pre>

<p>There's a method to my madness after all! But this just poses more questions. Why is <code>ViewOverlay</code> used here? As a part of RecyclerView or as a part of the dark magicians plans to deprive me of my sanity?</p>

<p><strong>Sidenote</strong></p>

<p>I went digging into <code>RecyclerViews</code> code to check if I could find a reason for the <code>ViewOverlay</code>mystery. I found out that <code>RecyclerView</code> calls the adapters <code>onCreateViewHolder()</code> function only twice. Both times providing itself as the <code>parent</code> argument for the function. So no luck there... What the hell can cause the item view to have the <code>ViewOverlay</code> as it's parent? The parent is an immutable value, so the only way for the <code>ViewOverlay</code> to be set as the parent, is for something to construct a new <code>ViewHolder</code> and supply the <code>ViewOverlay</code> as the parent object.</p>

<h2>UPDATE 4</h2>

<p>Sometimes I amaze myself with my own stupidity. The <code>ViewOverlay</code> is used because the items are being animated. I didn't even consider this to be an option since I've set the <code>itemAnimator</code> for the <code>RecyclerView</code> as <code>null</code>, but for some odd reason that does not work. The items are still being animated and that is causing this whole charade. So what could be the cause of this? <em>(How I chose to ignore the moving items, I do not know, but the animations became very clear when I forced the app to download same picture over and over again and the whole list went haywire.)</em></p>

<p>My <code>DiscussionInstanceFragment</code> contains the RecyclerView in question and a nested ConstraintLayout that in turn contains an <code>EditText</code> for user input and a send button.</p>

<pre><code>    val v = inflater.inflate(R.layout.fragment_discussion_instance, container, false)
    val lm = LinearLayoutManager(context)
    lm.reverseLayout = true
    v.disc_instance_messages_list.layoutManager = lm
    v.disc_instance_messages_list.itemAnimator = null
    v.disc_instance_messages_list.adapter = mPresenter.messageAdapter
</code></pre>

<p>This is the piece that handles the initialization of the <code>RecyclerView</code>. I'm most definitely setting the <code>itemAnimator</code> as <code>null</code>, but the animations just wont stop! I've tried setting the <code>animateLayoutChanges</code> xml attribute on the root <code>ConstraintLayout</code> and on the <code>RecyclerView</code> but neither of them worked. It's worth mentioning that I also checked whether the <code>RecyclerView</code> had an <code>itemAnimator</code> in different states of the program, and every time I check the animator, it is null. So what is animating my <code>RecyclerView</code>?!</p>
",5778533,,5778533,,2018-04-26 22:50:31,2018-05-09 10:17:39,Setting RecyclerViews itemAnimator to null does not remove animations,<android><android-recyclerview><kotlin><rx-kotlin>,2,0,0,,,CC BY-SA 3.0
50204067,1,0,0,2018-05-06 20:08:38,,1,89,"<p>Nothing I've tried seems to solve my problem.</p>

<p>I have three buttons with with onClick behavior. Each of these buttons calls the same method <code>launchActivity</code> but with different parameters. <code>launchActivity</code> does some IO with the variables received from the <code>onClick</code> methods and then returns an intent. I would like to be able to implement a RxKotlin/Java Flowable to handle backpressure collectively across the three onClick methods so that I can implement <code>BackpressureStrategy.DROP</code>. So if <code>onClick1</code> was initiated <code>onClick2</code> would be dropped if initated while <code>launchActivity</code> was still processing <code>onClick1</code> on the <code>io()</code> thread.</p>

<pre><code>class ActivityLauncher {
  fun onClick1() {
    val intent = launchActivity(inFile1, outFile1)
    startActivity(intent)
  }

  fun onClick2() {
    val intent = launchActivity(inFile2, outFile2)
    startActivity(intent)
  }

  fun onClick3() {
    val intent = launchActivity(inFile3, outFile3)
    startActivity(intent)
  }

  fun launchActivity(in: File, out: File): Intent {
    // do IO with in and out files and create an intent
    return intent
  }
}
</code></pre>

<p>If I was to implement this as say a Single, I'd implement the <code>onClick</code> methods somewhat like:</p>

<pre><code>fun onClick() {
  Single.fromCallable(launchActivity(inFile, outFile)
      .observeOn(scheduler.io())
      .subscribeOn(scheduler.ui())
      .subscribe { i -&gt; startActivity(i) }
}
</code></pre>

<p>But I can't figure out how to call <code>launchActivity</code> from a shared Flowable that is accessible to all three <code>onClick</code> methods while still allowing them to pass in their unique <code>inFile</code> and <code>outFile</code> variables and enforcing backpressure.</p>

<p>The basic criteria is:</p>

<ul>
<li>Ensure <code>launchActivity</code> is run on the <code>io()</code> thread</li>
<li>Pass the unique arguments from each of the <code>onClick</code> methods to <code>launchActivity</code> each time <code>onClick[#]</code> is run.</li>
<li><code>BackpressureStrategy.DROP</code> is used to ensure only the first click in a series is processed in <code>launchActivity</code></li>
<li>The resulting <code>intent</code> from <code>launchActivity</code> is passed to <code>startActivity</code></li>
</ul>

<p>How do I implement a Flowable to allow this behavior?</p>
",6275844,,472495,,2018-05-08 10:23:30,2018-05-08 10:23:30,Implement shared Flowable in RxKotlin with dynamic parameters,<android><rx-java2><rx-android><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
50293583,1,50294698,0,2018-05-11 13:36:22,,5,3049,"<p>I have a list <code>List&lt;FileModel&gt;</code> </p>

<p><code>FileModel</code> is just a class contains <code>id: Int</code></p>

<p><code>id</code> - is ID of photo file I need to fetch and cast to Bitmap</p>

<p>I have a request:</p>

<pre><code>fun getFile(fileId: Int): Single&lt;ResponseBody&gt;
</code></pre>

<p>This request returns <code>ResponseBody</code> which we can cast to Bitmap</p>

<p>And</p>

<pre><code>fun generatePhoto(responseBody: ResponseBody): Single&lt;Bitmap?&gt;
</code></pre>

<p>What I want is to create a function </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    // Execute getFile(...) for each item in the list
    // Cast getFile(...) result to Bitmap using generatePhoto(...)
    // Return a list of Bitmaps
}
</code></pre>

<p>I've tried something like this but it's completely wrong </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    return Observable.fromIterable(list)
        .flatMap { getFile(it.id) }
        // How to call generatePhoto(...) here?
}
</code></pre>
",4932519,,4932519,,2018-05-11 13:41:37,2018-05-11 14:52:25,RxJava2. Execute a request for every item in a list,<android><kotlin><rx-java2><rx-android><rx-kotlin>,3,2,0,,,CC BY-SA 4.0
50358932,1,0,0,2018-05-15 20:46:38,,0,1155,"<p>I'm using RxJava2 with Kotlin. I don't know why but I always have this error :</p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: An operation is not implemented: not implemented</p>
</blockquote>

<p>So I add to my subscriber the onError callback, but now I have this error (inside the onError) :</p>

<blockquote>
  <p>kotlin.NotImplementedError: An operation is not implemented: not implemented</p>
</blockquote>

<p>This is my code :</p>

<pre><code>override fun getOpenBar(): Observable&lt;List&lt;Bar&gt;&gt; {

    val query: ParseQuery&lt;ParseObject&gt; = ParseQuery.getQuery(""Bar"")
    query.whereEqualTo(""isOpen"",true)
    return ParseObservable.find(query).toList().map { BarMapper.map(it) }.toObservable()
}
</code></pre>

<p>In my presenter :</p>

<pre><code>override fun onAttach(view: V?) {
    super.onAttach(view)
    getView()?.printDate()
    getView()?.showProgress()
    interactor?.getBar()?.compose(schedulerProvider.ioToMainObservableScheduler())?.subscribeBy(
            onNext = {if (it.isEmpty()) getView()?.printNoResult()
            else getView()?.printBarResult(it)
                getView()?.hideProgress()},

            onError = {Log.d(""TEST"",it.toString())}
    )
}
</code></pre>

<p>How to handle correctly error ? Thanks</p>
",4880751,,0,,,2018-05-15 20:46:38,RxJava2 and Kotlin : OnErrorNotImplementedException,<android><kotlin><rx-java2><rx-android><rx-kotlin2>,0,6,0,,,CC BY-SA 4.0
50401536,1,0,0,2018-05-17 22:52:14,,0,132,"<p>The goal of this function is to create a stream that emits values periodically until it encounters one that matches a predicate. </p>

<p>Here is some skeleton code that I've come up with:</p>

<pre><code>class Watcher&lt;T : Any&gt;(
        /**
         * Emits the data associated with the provided id
         */
        private val callable: (id: String) -&gt; T,
        /**
         * Checks if the provided value marks the observable as complete
         */
        private val predicate: (id: String, value: T) -&gt; Boolean
) {

    private val watchPool: MutableMap&lt;String, Observable&lt;T&gt;&gt; = ConcurrentHashMap()

    fun watch(id: String): Observable&lt;T&gt; {
        // reuse obesrvable if exists
        val existing = watchPool[id]
        if (existing != null)
            return existing
        val value = callable(id)
        if (predicate(id, value)) return Observable.just(value)
        // create new observable to fetch until complete,
        // then remove from the map once complete
        val observable = Observable.fromCallable&lt;T&gt; {
            callable(id)
        }.repeatWhen { /* What to put here? */ }.doOnComplete {
            watchPool.remove(id)
        }.distinctUntilChanged()
        watchPool[id] = observable
        return observable
    }

}
</code></pre>

<p>As an example, if I have the following enums:</p>

<pre><code>enum class Stage {
    CREATED, PROCESSING, DELIVERING, FINISHED
}
</code></pre>

<p>And some callable that will retrieve the right stage, I should be able to pass the callable and a predicate checking if <code>stage == FINISHED</code>, and poll until I get the <code>FINISHED</code> event.</p>

<p>The issue I have is in generating an observable when the event received is not a final event. In that case, the observable should continue to poll for events until either it receives an event matching the predicate or until it has no more subscribers.</p>

<p>This observable should:</p>

<ul>
<li>Not poll until it receives at least one subscriber</li>
<li>Poll every x seconds</li>
<li>Mark itself as complete if <code>predicate</code> returns true</li>
<li>Complete itself if it ever goes from >0 subscribers to 0 subscribers</li>
</ul>

<p>The use of watch pools is simply to ensure that two threads watching the same id will not poll twice the number of times. Removal of observables from the map is also just so it doesn't pile up. For the same reason, observables that emit just one variable are not stored for reference.</p>

<p>How do I go about adding the functionality for the points added above?
I will link to one existing <a href=""https://github.com/ReactiveX/RxJava/issues/448"" rel=""nofollow noreferrer"">RxJava Github issue</a> that I found useful, but from what I'm aware, it doesn't allow for predicates dealing with the value emitted by the callable.</p>
",4407321,,0,,,2018-05-18 03:05:16,RxObservable that repeats itself until an expected value is found,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
50536642,1,50566723,0,2018-05-25 20:46:03,,0,266,"<p>I have a scenario where I have a function, scanForTargets, that returns an Observable of type FoundNumber. In FoundNumber I just need an ID field I can grab out of it. As each element comes back in the scanResults Observable, I want to check to see if the name field matches one of the names on a target list. If so, then I want to emit that. For example, if I am looking for numbers 1, and 2, and scanForTargets() emits back 1, 2, 3, and 4, then I want scanForValues to emit back only 1 and 2.</p>

<p>The caveat is that I only want to continue doing this until either:
 1) A time period elapses (in which case I throw and error)
 2) All items on the String list are found before the timeout.</p>

<p>What I have so far looks like this, but I cannot get it to work for me mostly due to the shortcut of stopping once/if all of the targets are found before the timeout. </p>

<pre><code>fun scanForValues(targetList: List&lt;String&gt;): Observable&lt;FoundNumber&gt; {
    val scanResult = scanForTargets()

    return scanResult.doOnNext {scanResult -&gt; Log.d(TAG, ""Found potential target: "" + scanResult.name) }
            .filter(TargetPredicate(targetList)) //See if it's one of those we want
            .timeout(5, TimeUnit.SECONDS) //Wait a max of 5 seconds to find all items
            .doOnError { Log.w(TAG, ""Failed to scan""}"") }
            .map{s-&gt;scanResult.name}  
}

class TargetPredicate(private val targetList: List&lt;String&gt;) : Predicate&lt;ScanResult&gt; { override fun test(scanResult: ScanResult): Boolean {
        if(scanResult == null) {
            return false
        }
        return scanResult.name in targetList 
    }
}
</code></pre>

<p>How can I also add the check to stop if I find all of the items in the list? I can't just add another predicate right?</p>

<p>Thanks.</p>

<p>Update: As requested, here is some data to show what I mean.</p>

<p>Let's say that the scanForTargets() and supporting code looks like this:</p>

<pre><code>var emittedList: List&lt;String?&gt; = listOf(null, ""0"", ""1"", ""2"", ""3"")


fun scanForTargets(): Observable&lt;FoundNumber&gt; = Observable
    .intervalRange(0, emittedList.size.toLong(), 0, 1, TimeUnit.SECONDS)
    .map { index -&gt; FoundNumber(emittedList[index.toInt()]) }

data class FoundNumber(val targetId: String?)
</code></pre>

<p>Now if scanForValues was called with a list of 1 and 2, then it should emit back an Observable of 1 and then 2.</p>
",443654,,443654,,2018-06-05 21:02:28,2018-06-06 08:54:17,Checking a list and timing out if all entries not found in RxJava/RxKotlin,<rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
50625166,1,0,0,2018-05-31 13:10:41,,1,1908,"<p><em>I have seen other questions here related to this error but still not able to fix. Plus I'm asking this question because unlike other questions here, I'm getting this error only when I convert the code to Kotlin from Java.</em></p>

<p>I'm using this same RxJava code in Java, it works fine. 
I converted to Kotlin and it gives this error - </p>

<blockquote>
  <p>Kotlin Compilation Error : None of the following functions can be
  called with the arguments supplied</p>
</blockquote>

<pre><code>var observable : Observable&lt;Bitmap&gt; = Observable.just(bitmap)

var observer:Observer&lt;Bitmap&gt; = Observer&lt;Bitmap&gt;() {
                fun onSubscribe(d: Disposable) {
                    disposable = d
                }
                fun onNext(orientedBitmap:Bitmap) {
                    // do something
                }
                fun onError(e:Throwable) {
                }
                fun onComplete() {

                }
            }

observable.subscribeOn(Schedulers.io())
          .observeOn(AndroidSchedulers.mainThread())

          // It shows the error here
          .subscribe(observer)
</code></pre>

<p>Can anyone explain what's wrong here?</p>
",1724453,,0,,,2018-05-31 14:42:01,Error: None of the following functions can be called with the arguments supplied when converted to Kotlin from Java,<android><kotlin><rx-java><android-bitmap><rx-kotlin>,1,3,0,,,CC BY-SA 4.0
50724513,1,50731185,0,2018-06-06 15:46:08,,7,9651,"<p>I am stuck at this problem, which should be fairly simple. I need subscriber to execute a code block when the <code>Maybe</code> has completed as an <code>Empty Maybe</code>. I found that </p>

<ol>
<li>we can pass default Maybe value or use switchIfEmpty but I feel both are hacky. </li>
<li>Also there is a subscribe function which takes onComplete function (along with handlers for other two events), but onComplete does not take any argument which can be used to find if maybe was completed empty.</li>
<li>Another way could be <code>Maybe.isEmpty.blockingGet()</code>, but it is dirty too.</li>
</ol>

<p>I have tried following (<em>Kotlin Syntax</em>):-</p>

<pre><code>fun &lt;T&gt; Maybe&lt;T&gt;.subscribeWithEmptyHandler(onSuccess: (T) -&gt; Unit, onError: (Throwable) -&gt; Unit, onEmpty: () -&gt; Unit) {
    this.isEmpty.subscribe({ if (it) onEmpty() }, { onError(it) })
    this.subscribe({ onSuccess(it) }, { onError(it) })
}
</code></pre>

<p>But as expected it is running subscription twice, tested here:-</p>

<pre><code>Maybe.create&lt;Int&gt; {
    println(""subscribing"")
    //Remove line below to create Empty Maybe
    it.onSuccess(5)
    it.onComplete()
}
    .subscribeWithEmptyHandler({println(""success"")},{println(""error"")},{println(""empty"")})
</code></pre>

<p>Could somebody please suggest neater way to solve this?</p>
",1699956,,1000551,,2019-01-18 11:23:45,2021-03-14 22:49:50,RxJava Maybe: Any neat way to handle Empty case?,<kotlin><rx-java><rx-kotlin>,3,0,0,,,CC BY-SA 4.0
50727006,1,50747806,0,2018-06-06 18:14:03,,0,57,"<p>I want to look for an entire list of items to be found before I complete and if that entire list isn't found, then an exception (a Timeout or custom one) is to be thrown. Like the built in Observable.timer() but instead of the test passing once the first item is emitted, I want it to require all of the items in a list to be found. </p>

<p>Here is an example. Let's say I have some test function that emits Observable&lt;FoundNumber>. It looks like this:</p>

<pre><code>var emittedList: List&lt;String?&gt; = listOf(null, ""202"", ""302"", ""400"")

data class FoundNumber(val numberId: String?)

fun scanNumbers(): Observable&lt;FoundNumber&gt; = Observable
    .intervalRange(0, 
                   emittedList.size.toLong(), 
                   0, 
                   1, 
                   TimeUnit.SECONDS).map { index -&gt; 
                     FoundNumber(emittedList[index.toInt()]) }
</code></pre>

<p>That function will then be called to get numbers that will be compared to a list of expected numbers. It doesn't matter if there are additional numbers coming from scanForNumbers that aren't in the ""target"" list. They will just be ignored. Something like this:</p>

<pre><code>val expectedNumbers = listOf(""202"", ""302"",""999"")

        scanForNumbers(expectedNumbers)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe { value -&gt; Log.d(TAG, ""Was returned a $value"") }
</code></pre>

<p>So, the expected numbers (202, 302, and 999) don't exactly match with the numbers that will be emitted (202, 302, and 400). So, a timeout SHOULD occur, but with the built in version of Observable.timer(), it will not time out since at least one item was observed.</p>

<p>Here is kind of what I'd like to have. Anyone know how to code this up in RxJava/RxKotlin?</p>

<pre><code>fun scanForNumbers(targets: List&lt;String&gt;): Observable&lt;FoundNumber&gt; {
  val accumulator: Pair&lt;Set&lt;Any&gt;, FoundNumber?&gt; = targets.toSet() to null
    return scanNumbers()
        .SPECIAL_TIMEOUT_FOR_LIST(5, TimeUnit.SECONDS, List)
        .scan(accumulator) { acc, next -&gt;
            val (set, previous) = acc
            val stringSet:MutableSet&lt;String&gt; = hashSetOf()

            set.forEach { stringSet.add(it.toString()) }

            val item = if (next.numberId in stringSet) {
                next
            } else null
            (set - next) to item       // return set and nullable item
        }
        .filter { Log.d(TAG, ""Filtering on ${it.second}"")
                  it.second != null }  // item not null
        .take(targets.size.toLong())         // limit to the number of items
        .map { it.second }                   // unwrap the item from the pair
        .map { FoundController(it.numberId) }  // wrap in your class
}
</code></pre>

<p>How do you code, hopefully using RxJava/Kotlin, a means to timeout on a list as mentioned?</p>
",443654,,443654,,2018-06-06 18:38:20,2018-06-07 18:20:26,How can you create a timer that works on a List in Rx?,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
50937317,1,50937413,0,2018-06-19 21:40:58,,0,1297,"<p>There seems to be a limit to the number of Observables to use as parameters in the zip method for Kotlin. If this is accurate, what is the best alternative?</p>

<p>For instance, when I use 9 parameters it works as expected. When I add a 10th parameter I receive the error <strong>Cannot infer a type for this parameter. Please specify it explicitly</strong></p>

<pre><code>Observable.zip(
            //TODO: parameterize exchange symbols based on pair
            methodOne() as Observable&lt;Any&gt;),
            methodTwo() as Observable&lt;Any&gt;),
            methodThree() as Observable&lt;Any&gt;),
            methodFour() as Observable&lt;Any&gt;),
            methodFive() as Observable&lt;Any&gt;),
            methodSix() as Observable&lt;Any&gt;),
            methodSeven() as Observable&lt;Any&gt;),
            methodEight() as Observable&lt;Any&gt;),
            methodNine() as Observable&lt;Any&gt;),
            { oneResult, twoResult, threeResult, fourResult, fiveResult, sixResult, sevenResult, eightResult, nineResult -&gt;
                    //logic here applying computation to results
            })
            .subscribe(
                    {},
                    {
                        println(String.format(""Error: %s"", it.message))
                    })
            .unsubscribe()
}
</code></pre>
",2253682,,2253682,,2018-06-19 21:46:00,2018-06-19 21:54:55,Is There A Limit to The Number of Observables in .zip Method?,<java><android><kotlin><rx-java><rx-kotlin>,3,0,0,,,CC BY-SA 4.0
50939047,1,50939320,0,2018-06-20 01:43:26,,0,894,"<p>Sorry nooby kotlin question</p>

<pre><code>func someThingElse(): Observable&lt;String&gt; {
   return Observable.just(""aasd"")
} 

fun doSomething(): Observable&lt;Void&gt; {
    return someThisElse().fetch().map { () } 
}
</code></pre>

<p>How do i return an observable of void?
I tried <code>void</code>, <code>Void()</code>, <code>Void</code></p>
",242769,,242769,,2018-06-20 02:01:45,2018-06-20 21:24:17,RXKotlin how do you map to void?,<android><kotlin><rx-java><rx-kotlin>,2,0,0,,,CC BY-SA 4.0
50945144,1,50945458,0,2018-06-20 09:46:04,,0,480,"<p>Here is my Retrofit Interface and creation code:</p>

<pre><code>interface SSApi {
companion object {
    private fun create(): SSApi {
        val httpClient = OkHttpClient().newBuilder()
        val networkInterceptor = Interceptor { chain -&gt;
            val request = chain.request()?.newBuilder()?.addHeader(""api-key"", SSConstants.API_KEY)?.build()
            chain.proceed(request!!)
        }

        val loggingInterceptor = HttpLoggingInterceptor()
        loggingInterceptor.level = HttpLoggingInterceptor.Level.BODY

        httpClient.addNetworkInterceptor(networkInterceptor).addInterceptor(loggingInterceptor)

        val retrofit = Retrofit.Builder()
                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create())
                .baseUrl(SSConstants.BASE_URL)
                .client(httpClient.build())
                .build()

        return retrofit.create(SSApi::class.java)
    }

    val api by lazy {
        SSApi.create()
    }

    var disposable: Disposable? = null
}

@GET
fun getWeatherInfo(@Url url: String): Observable&lt;OpenWeatherMapInfo&gt;
}
</code></pre>

<p>And here is how I use the <code>disposable</code>:</p>

<pre><code>    private fun getWeather() {
    disposable = api
            .getWeatherInfo(SSConstants.OPEN_WEATHER_MAP_API_ENDPOINT)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { results -&gt; Log.i(""Dale"", results.toString())},
                    { error -&gt; Log.i(""Dale"", error.message)}
            )
    }
</code></pre>

<p>When I execute the request, I can see that it my <code>OPEN_WEATHER_MAP_API_ENDPOINT</code> still appends to my <code>baseUrl</code>. </p>

<p>Here is my Constants class for reference:</p>

<pre><code>object SSConstants {
const val OPEN_WEATHER_MAP_API_ENDPOINT = ""api.openweathermap.org/data/2.5/weather?q=Catbalogan,PH&amp;units=metric""
const val BASE_URL = ""https://api.xxx.xxx/""
}
</code></pre>
",6243778,,6243778,,2018-06-20 09:53:29,2018-06-20 10:01:27,Retrofit Dynamic URL still appends to the Base URL,<android><kotlin><retrofit2><rx-android><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
50949942,1,0,0,2018-06-20 13:53:49,,0,68,"<p>I'm working on an Android App. I have a list of photos loaded in memory. I want to make use of Reactive library, so I declare a memory-base datasource where I save the list:</p>

<pre><code>    @Singleton
    class MemoryPhotosSource @Inject constructor() {
         var photos: MutableList&lt;Image&gt; = mutableListOf()
         ...

         // Here is my function to add items to list.
         fun addPhoto(image: Image) {
              photos.add(image)
         }

         // Here is my function to list the items.
         fun listPhotos(): List&lt;Image&gt; = photos

         // Here is my function to remove items from list.
         fun removePhoto(image: Image): Image {
               photos.remove(image)
               return image
         }
    }
</code></pre>

<p>Then, I have a ViewModel where I call these methods:</p>

<pre><code>class CreateDocumentFromPhotosViewModel @Inject constructor(): ViewModel() {
       @Inject
       lateinit var source: MemoryPhotosSource

       fun listImages(): Observable&lt;List&lt;Image&gt;&gt; = Observable.fromCallable {
           source.listPhotos()
       }.applySchedulers()

       fun addImage(image: Image) {
           source.addPhoto(image)
       }

       fun removeImage(image: Image): Image {
           source.removePhoto(image)
           return image
       }
}
</code></pre>

<p>Finally, I subscribe in my application:</p>

<pre><code>    dis add viewModel.listImages()
            .subscribe {
                adapter.data = it
            }

    dis add onDelete
            .map { viewModel.removeImage(it) }
            .map { showSnackbar(parentView, resources.getString(R.string.document_removed), resources.getString(R.string.undo), it)}
            .map { it.subscribe { viewModel.addImage(it) } }
            .subscribe()
</code></pre>

<p>Listing and adding images work nicely. However, when I press the delete button, which publish in the onDelete subject, the snackbar is shown, but no change is performed to the RecyclerView adapter. Debugging, I noticed that the <code>removePhoto</code> function is being called in <code>MemoryPhotosSource</code> class, and the list is being successfuly modified. However, it does not emit the changes, that's why the RecyclerView is not updated. I confirmed this behavior by leaving the application and entering again, which forced the repainting of the Recycler, and then, the removed element didn't show up, as it should be. So, I think the problem is the list doesn't emit the changes when an item is removed. </p>

<p>Does anybody know a way to solve this? Any help would be much appreciated.</p>

<p>Thanks!</p>
",9858922,,0,,,2018-06-20 14:00:04,List not emitting on remove item (RxKotlin),<android><kotlin><reactive-programming><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
50992991,1,51000130,0,2018-06-22 17:31:32,,2,1599,"<p>Can someone please explain me why <code>PublishSubject</code> is not working nicely with <code>firstOrError()</code>?</p>

<p>I'm expecting <code>firstOrError</code> to return a <code>NoSuchElementException</code> when the <code>PublishSubject</code> is created without any value.</p>

<p>I wrote some tests in order to better explain the problem:</p>

<pre><code>@Test
fun `test one`() {
    // THIS TEST FAILS
    val publishSubject = PublishSubject.create&lt;Boolean&gt;()

    val testSubscriber = publishSubject
        // .toFlowable(BackpressureStrategy.LATEST) // With or without this doesn't make any difference
        .firstOrError()
        .test()

    testSubscriber
        .assertNotComplete()
        .assertError(NoSuchElementException::class.java)
}

@Test
fun `test two`() {
    // THIS TEST PASSES
    val flowable = Flowable.empty&lt;Boolean&gt;()

    val testSubscriber = flowable
        .firstOrError()
        .test()

    testSubscriber
        .assertNotComplete()
        .assertError(NoSuchElementException::class.java)
}
</code></pre>
",3096313,,1115491,,2018-06-22 20:51:45,2018-06-23 21:42:48,PublishSubject does not work with firstOrError(),<android><rx-java><rx-java2><rx-kotlin>,1,4,0,,,CC BY-SA 4.0
51072877,1,0,0,2018-06-27 23:49:45,,0,26,"<p>I tried the following:</p>

<pre><code>$ git clone https://github.com/ReactiveX/RxKotlin.git    
$ cd RxKotlin/    
$ gradle build
</code></pre>

<p>It fails with:</p>

<blockquote>
  <p>...FAILURE: Build failed with an exception.</p>
  
  <ul>
  <li><p>Where: Build file '/home/myuser/RxKotlin/build.gradle' line: 13</p></li>
  <li><p>What went wrong: A problem occurred evaluating root project 'rxkotlin'.</p>
  
  <blockquote>
    <p>org/gradle/api/internal/project/AbstractProject</p>
  </blockquote></li>
  </ul>
</blockquote>
",1988515,,0,,,2018-06-28 00:14:16,RxKotlin repo gradle build compilation fails with gradle 4.7 (JDK 1.8),<kotlin><rx-kotlin><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
51110189,1,51110389,0,2018-06-29 22:37:37,,1,107,"<p>I've got an observable: <code>Observable.create&lt;Boolean&gt; {emitter = it}</code>, to which I push some values. I want it to publish a 'false' value, as soon as some specific time period has passed without any value being pushed to that emitter.</p>

<p>How is that possible with RxJava/Kotlin 2?</p>
",2728815,,0,,,2018-06-30 15:02:20,Emit value if specific time has passed after last item,<java><kotlin><rx-java2><rx-android><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
51144111,1,51144570,0,2018-07-02 21:44:56,,0,354,"<p>I have an function in <code>@Dao</code>. Lets call that class <code>DaoClass</code></p>

<p><code>abstract fun getData() : Flowable&lt;List&lt;Data&gt;&gt;</code></p>

<p>Now, I want to check if list of data returned is empty or not. I dug through the DaoClass_Impl (generated at build time) and I found out that the Flowable won't be empty. So, </p>

<p><code>getData().isEmpty</code> will always return false.</p>

<p>So what I did was 
<code>getData().singleOrError().map{it.isEmpty()}</code> to return if the returned list is actually empty. </p>

<p>But I am having problem as the value is not getting emitted.</p>
",1042124,,0,,,2018-07-02 22:48:44,Converting Flowable<List<T>> to Single<Boolean>,<android><kotlin><android-room><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
51185759,1,51186490,0,2018-07-05 07:39:56,,3,3583,"<p>I have code that does blocking operation in while loop (downloads some data from a server). Client does not know how many items are going to be returned in each step. Loop breaks when N items are downloaded.</p>

<pre><code>val n = 10
val list = ArrayList&lt;T&gt;()

while (list.size &lt; n) {
    val lastItemId = list.last()?.id ?: 0
    val items = downloadItems(lastItemId)
    list.addAll(items)
}
</code></pre>

<p><code>downloadItems</code> performs blocking HTTP call and returns list. Now let's assume <code>downloadItems</code> changes and new return type is <code>Observable&lt;Item&gt;</code>. How could I change the code to use RxJava without performing something like <code>blockingGet</code>?</p>
",1740335,,1740335,,2018-07-05 16:54:07,2018-07-05 18:24:13,Converting loop with condition into RxJava stream,<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>,2,0,1,,,CC BY-SA 4.0
51280700,1,51281307,0,2018-07-11 08:28:26,,0,1333,"<p>I have a method that returns an Observable like this:</p>

<pre><code>open fun get(): Observable&lt;Response&gt; {

    return if (condition)
        getDataFromApi()
    else
        getDataFromDb()

}
</code></pre>

<p>and is subscribed as followed:</p>

<pre><code>                get()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(/*a object of class extending DefaultObserver*/)
</code></pre>

<p>I am facing this issue when getDataFromDb() is called and after a while getDataFromApi() is called as per condition. For first call it works fine but on second call onNext is called more then one time with the old data response from getDataFromDb(). Please let me know what I am doing wrong. I am a bit new to RxJava.</p>
",994926,,0,,,2018-07-11 08:59:22,RxJava2 onNext() called multiple times?,<android><kotlin><rx-java2><rx-kotlin2>,1,3,1,,,CC BY-SA 4.0
51330784,1,51331375,0,2018-07-13 18:13:27,,0,293,"<p>Is any way to create an RxJava2 <code>Observable</code> to notify state changes? like:</p>

<pre><code>private var internalState = ""state1""
val state: Observable&lt;String&gt; = Observable(...)
...
fun updateState(newState: String) { ... } // !!! attention: I need to notify all subscribers about this new state
</code></pre>

<p>then use it every where like:</p>

<pre><code>// observe on state
state.subscribe(...)
</code></pre>

<p>this subscription must be called every state updates</p>
",1803735,,0,,,2018-07-13 19:03:01,Rx Kotlin/Java Observable on state,<java><android><kotlin><rx-java2><rx-kotlin2>,1,1,0,,,CC BY-SA 4.0
51368000,1,0,0,2018-07-16 18:25:22,,1,512,"<p>I am using following Kotlin code to generate proxy (This will also generate Rx methods)</p>

<pre><code>@ProxyGen
@VertxGen
interface JobService {
    @Fluent
    fun getCertain(jobId: Int, handler: Handler&lt;AsyncResult&lt;Job?&gt;&gt;): JobService
}
</code></pre>

<p>When I see generated Rx Code it is as follows.</p>

<pre><code>public Single&lt;Job&gt; rxGetCertain(int jobId) { 
   return new io.vertx.reactivex.core.impl.AsyncResultSingle&lt;Job&gt;(handler -&gt; {
     getCertain(jobId, handler);
   });
}
</code></pre>

<p><strong>Issue:-</strong></p>

<p>Unfortunately i am not able to use this in Kotlin as kotlin won't allow null values for non-null fields and it is throwing following exception.</p>

<pre><code>java.lang.IllegalArgumentException: Parameter specified as non-null is null
</code></pre>

<p>How do i force Vertx CodeGen to generate return type as MayBe so that my code works without any issues in kotlin.</p>
",2631567,,0,,,2019-02-01 08:00:01,How to Force Vertx Rx CodeGen To Generate MayBe As Return Type,<kotlin><rx-java2><vert.x><rx-kotlin><codegen>,1,4,0,,,CC BY-SA 4.0
51403135,1,0,0,2018-07-18 13:22:04,,0,221,"<p>I'm new to RxJava and am having a hard time with handling error cases. The application is in Kotlin but it probably won't make much of a difference. The scenario is basically user authentication and then performing an action but if the user is not authorized/has a bad auth token I generate an exception and want to cease processing. Right now I have my function that checks tokens and it looks like this. </p>

<pre><code>fun checkAuthority(authToken: AuthToken, requiredAuthority: Authority): Completable =
    authorityRepository.getAuthorities(authToken)
        .filter { it == requiredAuthority }
        .switchIfEmpty { subscriber -&gt; subscriber.onError(UnauthorizedException(""must have '$requiredAuthority' authority"")) }
        .ignoreElements()
</code></pre>

<p>Then I have a function that looks a bit like this that checks permissions then is supposed to do an operation if they are authorized. </p>

<pre><code>fun create(model: EntityCreate, authToken: AuthToken): Single&lt;Entity&gt; =
    checkAuthority(authToken, CAN_WRITE_ENTITY)
        .andThen(entityRepository.insert(model, OffsetDateTime.now(clock)))
</code></pre>

<p>What I want is that if the UnauthorizedException is generated to not execute the andThen. </p>

<p>Perhaps there is a gap in my understanding of the documentation but I've for instance tried putting <code>doOnError</code> to throw the Throwable before the <code>andThen</code>. I've tried <code>onErrorComplete</code> in the same place. No matter what I do the <code>andThen</code> eventually executes.</p>

<p>What would the pattern look like to abandon the <code>Completable</code> chain should the <code>subscriber.onError</code> line executes? </p>
",674989,,0,,,2018-07-18 13:22:04,RxJava / RxKotlin - andThen still executing if previous step fails. How to stop?,<kotlin><rx-java2><rx-kotlin2>,0,4,0,,,CC BY-SA 4.0
51422390,1,0,0,2018-07-19 12:11:03,,0,1335,"<p>I tried it by the following program but it shows the error that kotlin variable is expected:  </p>

<p>[<img src=""https://i.stack.imgur.com/eQqNp.png"" alt=""enter image description here""></p>
",9921917,,1797950,,2018-07-19 12:28:13,2019-03-14 09:52:37,can we swap two numbers in kotlin using two variables and take input from user?,<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin><kotlin-interop>,4,2,0,,,CC BY-SA 4.0
51499934,1,51502518,0,2018-07-24 13:30:30,,1,131,"<p>I have a problem with RxJava. 
I have a <code>getAll()</code> method, it's returning with a list. It's serves data from Room database.</p>

<pre><code>@Query(""SELECT * from decks ORDER BY id ASC"")
fun getAll(): Flowable&lt;List&lt;DeckEntity&gt;&gt;
</code></pre>

<p><code>DeckEntity</code> have an <code>id</code> and a <code>name</code> field.</p>

<p>I created an another class called it <code>PrepareItem</code>, because I want to box it with more parameter. (It will be an <code>Adapter</code> model) Check it:</p>

<pre><code>data class PrepareItem (
    var deckEntity: DeckEntity,
    var countsOfCards: Int
)
</code></pre>

<p>So, I want to call the <code>getAll()</code> and I want to map it to PrepareItem. It's working yet.</p>

<pre><code>deckRepository.getAll()
                .map {
                    it.map {
                        PrepareItem(it,0)
                    }
                }
</code></pre>

<p>But, there is the <code>countsOfCards is equal 0</code>. I want to make an another repository call, to get the value, and set it. Important! Every value need a single call to repository. So if I have 5 item, than I need to wait until 5 another call finished.</p>

<p>I tried, but I get confused.
(CODE UPDATED)</p>

<pre><code>fun mapper(item: DeckEntity) : Single&lt;PrepareItem&gt; {
    return cardRepository.getDueDatedCardsFromDeck(deckId = item.id!! /*TODO !!*/)
            .map {
                PrepareItem(item, it.size)
            }
}

val call = deckRepository.getAll()
                .flatMapIterable { item-&gt;item }
                .flatMapSingle {
                    mapper(it)
                }.toList()
                .toObservable()
                ...
</code></pre>

<p>The <code>onError</code> or <code>onComplete</code> never called. Why?</p>

<p>Anyone have good idea to How to do it? I want it keep out from repository.
Thank you!</p>

<p><strong>UPDATE:</strong></p>

<p><strong>Solution:</strong></p>

<p>Create a new class</p>

<pre><code>class DeckWithCards {

    @Embedded
    lateinit var deckEntity: DeckEntity

    @Relation(
            entity = CardEntity::class,
            entityColumn = ""deckId"",
            parentColumn = ""id"")
    lateinit var cards: List&lt;CardEntity&gt;

}
</code></pre>

<p>Add new fun to <code>DeckDao</code></p>

<pre><code>@Query(""SELECT * from decks ORDER BY id ASC"")
fun getAllWithCards(): Flowable&lt;List&lt;DeckWithCards&gt;&gt;
</code></pre>

<p>Thats all its works! Thank you for the answer. It helped me a lot !</p>
",5269276,,5269276,,2018-07-24 20:03:10,2018-08-15 11:44:53,RxJava make a call for every single list item,<android><kotlin><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
51667657,1,51671047,0,2018-08-03 07:44:25,,0,2417,"<p>I am using Room with RxJava/RxKotlin Flowable following <a href=""https://medium.com/google-developers/room-rxjava-acb0cd4f3757"" rel=""nofollow noreferrer"">this</a> article. I got it running but the got issue using it with ViewPager with 3 fragments.</p>

<p>I will walk you through my code little bit:</p>

<p>I have a viewpager with tab layout and three fragments(A, B, and favorites). First two fragments contain lists of data which can be added to favorite.</p>

<p>In favorite fragment, I am using Flowable to listen to changes made by A and B and update list accordingly. But what happens is when an item is made favorite in A and B, app crashes because the Flowable subscription in favorite fragment runs even when the fragment is not in foreground.</p>

<p>What I want is to be able to stop the subscription when the fragment is not in foreground and start in foreground.</p>

<p>I tried to stop it in onPause method of favorite fragment but flowable has no unsubscribe or dispose method.</p>

<p>My code is </p>

<pre><code>dbRepository?.getAllImportant()?.subscribeOn(Schedulers.io())
            ?.observeOn(AndroidSchedulers.mainThread())
            ?.subscribe(getFlowableSubscriber())
</code></pre>
",10009226,,10009226,,2018-08-03 10:36:36,2021-06-17 14:10:13,How to unsubscribe from Flowable in RxKotlin/RxJava?,<android-fragments><rx-java><rx-java2><rx-android><rx-kotlin2>,4,2,0,,,CC BY-SA 4.0
51679808,1,0,0,2018-08-03 20:35:48,,2,231,"<p>I use rxjava to read from the room database on the Schedulers.io thread. I've noticed that when my app is killed and reopened it always crashes with </p>

<blockquote>
  <p>Cannot access database on the main thread since it may potentially
  lock the UI for a long period of time.</p>
</blockquote>

<p>I use MVVM architecture with Dagger and instantiate view model with lazy</p>

<pre><code>private val viewModel by lazy { ViewModelProviders.of(this, viewModelFactory).get(StudentsListViewModel::class.java) }
</code></pre>

<p>All my requests to database look like this: </p>

<pre><code>compositeDisposable.add(viewModel.students
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnNext {
                    &lt;I do things here&gt;
                }
                .doOnError { it.printStackTrace() }
                .subscribe()
        )
</code></pre>

<p>I kill disposable onDestroy with </p>

<pre><code>compositeDisposable.apply {
            clear()
            dispose()
        }
</code></pre>

<p>So, why is it crushing on recreate and what is it trying to do on the main thread?</p>

<p>My ModelView class:</p>

<pre><code>class StudentsListViewModel@Inject
constructor(private val studioRepository: StudioRepository): ViewModel() {

val students: Flowable&lt;List&lt;Student&gt;&gt; = studioRepository.students

fun getStudentById(studentId: Int): Maybe&lt;Student&gt; {
    return studioRepository.getStudentById(studentId)
}

fun insertStudent(student: Student): Unit = studioRepository.insertStudent(student)
fun insertStudentFlat(student: Student) = studioRepository.insertStudentFlat(student)

fun updateStudent(student: Student) {
    studioRepository.updateStudent(student)
}

fun deleteAllStudents() {
    studioRepository.deleteAllStudents()
}

fun getStudentsNames(): Flowable&lt;List&lt;String&gt;&gt; = studioRepository.studentNames

val studentsCount: Flowable&lt;Int&gt; = studioRepository.studentsCount

fun getTicketById(ticketId: Int): Maybe&lt;Ticket&gt; {
    return studioRepository.getTicketById(ticketId)
}

fun getTicketByIdFlat(ticketId: Int): Ticket {
    return studioRepository.getTicketByIdFlat(ticketId)
}

fun updateTicket(ticket: Ticket) = studioRepository.updateTicket(ticket)

val activeTicketsStudentIds: Flowable&lt;List&lt;Int&gt;&gt; = studioRepository.activeTicketsStudentIds

fun getClassesByIdFlat(values: List&lt;Int&gt;): List&lt;YClass&gt; = studioRepository.getYclassesByIdFlat(values)

private fun getStudent(studentId: Int): Maybe&lt;Student&gt; = studioRepository.getStudentById(studentId)

private fun getAllActiveTicketsForAStudent(studentId: Int): Maybe&lt;List&lt;Ticket&gt;&gt; = studioRepository.getAllActiveTicketsForAStudent(studentId)

fun archiveStudentByIdAndDeactivateHisTickets(id: Int) {
    getStudent(id)
            .subscribeOn(Schedulers.io())
            .observeOn(Schedulers.io())
            .doOnSuccess {
                it.isArchived = true
                studioRepository.updateStudent(it)
                getAllActiveTicketsForAStudent(id)
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .doOnSuccess { list -&gt;
                            list.forEach {
                                it.actual = false
                                updateTicket(it)
                            }
                        }
                        ?.subscribe()
            }
            .doOnError {
                it.printStackTrace()
            }
            .subscribe()
}
</code></pre>

<p>}</p>

<pre><code>08-03 22:17:45.601 7776-7776/com.labfoodandfriends.nikitagudkovs.jlogOpenClasses E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.labfoodandfriends.nikitagudkovs.jlogOpenClasses, PID: 7776
    java.lang.RuntimeException: **Unable to start activity** ComponentInfo{com.labfoodandfriends.nikitagudkovs.jlogOpenClasses/com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity}: java.lang.RuntimeException: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2778)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856)
        at android.app.ActivityThread.-wrap11(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589)
        at android.os.Handler.dispatchMessage(Handler.java:106)
        at android.os.Looper.loop(Looper.java:164)
        at android.app.ActivityThread.main(ActivityThread.java:6494)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
     Caused by: java.lang.RuntimeException: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at com.labfoodandfriends.nikitagudkovs.jlog.factory.AppViewModelFactory.create(AppViewModelFactory.java:55)
        at android.arch.lifecycle.ViewModelProvider.get(ViewModelProvider.java:134)
        at android.arch.lifecycle.ViewModelProvider.get(ViewModelProvider.java:102)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity$viewModel$2.invoke(StudentsActivity.kt:83)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity$viewModel$2.invoke(StudentsActivity.kt:69)
        at kotlin.SynchronizedLazyImpl.getValue(LazyJVM.kt:74)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.getViewModel(Unknown Source:7)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.observeStudents(StudentsActivity.kt:136)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.onCreate(StudentsActivity.kt:103)
        at android.app.Activity.performCreate(Activity.java:7009)
        at android.app.Activity.performCreate(Activity.java:7000)
        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1214)
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2731)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856)¬†
        at android.app.ActivityThread.-wrap11(Unknown Source:0)¬†
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589)¬†
        at android.os.Handler.dispatchMessage(Handler.java:106)¬†
        at android.os.Looper.loop(Looper.java:164)¬†
        at android.app.ActivityThread.main(ActivityThread.java:6494)¬†
        at java.lang.reflect.Method.invoke(Native Method)¬†
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)¬†
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)¬†
     Caused by: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at android.arch.persistence.room.RoomDatabase.assertNotMainThread(RoomDatabase.java:204)
        at android.arch.persistence.room.RoomDatabase.query(RoomDatabase.java:232)
        at com.labfoodandfriends.nikitagudkovs.jlog.database.dao.StudentDAO_Impl.getStudents(StudentDAO_Impl.java:272)
        at com.labfoodandfriends.nikitagudkovs.jlog.repository.StudioRepositoryImpl.&lt;init&gt;(StudioRepositoryImpl.kt:50)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule.provideStudioRepository(AppModule.kt:26)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule_ProvideStudioRepositoryFactory.get(AppModule_ProvideStudioRepositoryFactory.java:24)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule_ProvideStudioRepositoryFactory.get(AppModule_ProvideStudioRepositoryFactory.java:10)
        at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsListViewModel_Factory.get(StudentsListViewModel_Factory.java:17)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsListViewModel_Factory.get(StudentsListViewModel_Factory.java:8)
        at com.labfoodandfriends.nikitagudkovs.jlog.factory.AppViewModelFactory.create(AppViewModelFactory.java:53)
</code></pre>
",7663625,,7663625,,2018-08-04 14:16:27,2018-08-04 14:16:27,rxJava and app lifecycle error,<android><rx-java><rx-android><android-room><rx-kotlin>,0,11,0,,,CC BY-SA 4.0
51786847,1,51822996,0,2018-08-10 12:44:07,,0,216,"<p>I have an object that generates different strings in the random moments of time, and i need to sudscribe to this generator to take these strings and provide them to ui (maybe it will be multiple subscribers in different activities).
Suppose, i got the following code: </p>

<p>generator:</p>

<pre><code>class Generator {

    private var stringToGenerate = """"

    var subject: BehaviorSubject&lt;String&gt; = BehaviorSubject.create&lt;String&gt;()

    init {
        //seems like these instructions are skipped
        subject
                .subscribeOn(AndroidSchedulers.mainThread())
                .doOnNext { t -&gt; Log.i(""subject doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .observeOn(AndroidSchedulers.mainThread())
                .map { _ -&gt; Log.i(""subject map"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }

        //imitation of async creating of strings in separate thread
        timer(""timerThread"", false, 2000L, 2000L) {
            stringToGenerate = System.currentTimeMillis().toString()
            subject.onNext(stringToGenerate)
        }
    }
}
</code></pre>

<p>One of the activities that must consume generated strings:</p>

<pre><code>class TestActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_test)

        val wrongThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""wrongThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val generator = Generator()
        generator.subject.subscribe(wrongThreadObserver)

        //for correct work illustration
        val correctThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""correctThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val mainThreadSubject = BehaviorSubject.create&lt;String&gt;()
        mainThreadSubject
                .doOnNext { obj -&gt; Log.i(""correctThread doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .subscribeOn(Schedulers.io())
                .observeOn(Schedulers.newThread())
                .subscribe(correctThreadObserver)
        mainThreadSubject.onNext(""test thread"")
        val handler = Handler()
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 2"") }, 1000)
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 3"") }, 2000)
    }
}
</code></pre>

<p>In this case <strong>correctThreadObserver</strong>, created just in activity, works fine, but <strong>wrongThreadObserver</strong> keeps work in timer thread, it seems like it ignoring instructions <strong>subscribeOn, ObserveOn, doOnNext</strong> in Generator, no matter where these instuctions called - in init, in timer thread, in activity by getting object to it from generator - <strong>wrongThreadObserver</strong> still work in timer thread. 
So log is:</p>

<blockquote>
  <p><em>I/correctThread¬†doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/correctThread¬†doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/correctThread¬†doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
</blockquote>

<p>No <code>doOnNext</code> and no main thread for <code>wrongThreadObserver</code>
What i do wrong?</p>
",10208467,,9389285,,2018-08-10 12:58:15,2018-08-13 12:59:37,"RxKotlin - Wrong subscribeOn, observeOn thread changing for Subject out of Activity?",<android><multithreading><kotlin-android-extensions><rx-kotlin><rx-kotlin2>,1,1,0,,,CC BY-SA 4.0
51981476,1,51988382,0,2018-08-23 08:34:43,,0,2866,"<p>My code-</p>

<pre><code>val accessTokenRequest: JsonObjectRequest = JsonObjectRequest(Request.Method.GET, url,
            Response.Listener { response -&gt;
            },
            Response.ErrorListener { error -&gt;
                Toast.makeText(activity,error.toString(), Toast.LENGTH_LONG).show()
            }
    )

    AppController.instance!!.addToRequestQueue(accessTokenRequest)
</code></pre>

<p>Header I wat to put -
""Search""&amp;
""Authorization""</p>
",8188198,,0,,,2018-08-23 14:39:33,How to put header in url using volley in Kotlin?,<kotlin><android-volley><kotlin-android-extensions><kotlin-extension><rx-kotlin>,1,1,0,,,CC BY-SA 4.0
52033814,1,52039569,0,2018-08-27 06:42:41,,3,10049,"<p>I need to parse this information-</p>

<pre><code>[
{
    ""artist"": ""12"",
    ""image"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
}]
</code></pre>

<p>As you can see the first field is different, how to parse below information differently and the first field differently in Kotlin.</p>

<p>I am parsing 1st part as-</p>

<pre><code>response -&gt;

                for (i in 0..(response.length() -1)){

                    /**
                        FIRST SONG
                     **/
                    val song = response.get(0).toString()

                    val listOfSongs = response.toString()

                    val parser = Parser()
                    val stringBuilder = StringBuilder(song)
                    val json: JsonObject = parser.parse(stringBuilder) as JsonObject
                    val firstArtist = json.string(""artist"")
                    val firstImage = json.string(""image"")
                    val intent = Intent(activity,ResultPage::class.java)
                    intent.putExtra(""firstArtist"",firstArtist)
                    intent.putExtra(""firstImage"",firstImage)

                    startActivity(intent)
                    /**
                        FIRST SONG
                    **/


                }
            }
</code></pre>

<p>and am also using KLAXON library here.</p>
",8188198,,0,,,2019-10-30 07:22:49,How to parse below Json data in Kotlin?,<kotlin><android-volley><kotlin-android-extensions><kotlin-extension><rx-kotlin>,2,0,2,,,CC BY-SA 4.0
52096003,1,52096151,0,2018-08-30 11:32:16,,2,1040,"<p>So i have been trying to convert my EditText input  that i get from my TextWatcher to an observable of stream but i cannot convert it.</p>

<p>I am trying the following</p>

<pre><code>etSearch.addTextChangedListener(object: TextWatcher{
        override fun afterTextChanged(p0: Editable?) {
            //I want to create an observable here to send events
               Observable.create(e-&gt;e.next(p0));
        }

        override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {

        }

        override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {

        }
    })
</code></pre>

<p>I am not able to figure out where i should create my events so that i am able to subscribe to it.</p>
",6048312,,0,,,2018-08-30 11:39:42,Convert my EditText Input to an observable stream,<android><kotlin><rx-kotlin>,2,0,1,,,CC BY-SA 4.0
52098683,1,0,0,2018-08-30 13:47:56,,1,78,"<p>I have Extension of EditText where I'm listenig to events from keyboard of EditText. I need to know when user press any button for showing (or not showing) error. So I make Observable for keys (rxbinding2) and I'm getting any press but when I press back button and cursor still in this EditText method onBackPressed doesn`t work.
How to filter onBack pressed?</p>

<pre><code>fun EditText.changeWithFormatting(formatter: (String) -&gt; String): Observable&lt;String&gt; {
    return Observable.merge(
            afterTextChangeEvents()
                    .map { editableText },
            keys()
                    .filter { it.action == KeyEvent.ACTION_UP }
                    .map { editableText }
    )
            .map { changeText(formatter(it.toString())) }
}
</code></pre>
",5555912,,0,,,2018-08-30 14:11:56,OnBackPressed doesn't work when observe EditText KEys,<android><kotlin><rx-android><rx-kotlin><rx-binding>,1,0,0,,,CC BY-SA 4.0
52140160,1,0,0,2018-09-02 18:57:33,,0,222,"<p>I have an Async call, in which callback listener I've put the emitter.onNext(). This async call is inside a for-in (I know the list size). I would like call onComplete() when last element has been emitted in onNext().</p>

<pre><code>for (anItem in itemList) {

     eventsQuery.get()
           .addOnCompleteListener { task -&gt;
               if (task.isComplete) {

                    emitter.onNext(myItemFromTask)

                    if(count == itemList.size){
                         emitter.onComplete()
                    }
                }
           }
 }
</code></pre>

<p>The count, as it is a async call, is not bein incremented in the proper way and the onComplete() is never called.</p>

<p>What is the proper way to handle with this situation? I need the onComplete to show the view and remove the loading/progress bar.</p>
",9697465,,9697465,,2018-09-02 22:02:05,2018-09-02 22:02:05,How to call emitter.onComplete() when emitter.onNext() are on async loop,<android><kotlin><reactive-programming><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
52140410,1,0,0,2018-09-02 19:33:45,,0,1588,"<p>I need to show error view if status is error and <code>call.isEmpty()</code> returns <code>true</code>.</p>

<p>Is there a better way to achieve this result?</p>

<pre><code>val errorVisible = states.asFlowable()
    .map { it.status == Status.ERROR }
    .flatMap { isError -&gt;
        if (isError) call.isEmpty()
        else Flowable.just(false)
    }
</code></pre>

<p><code>call.isEmpty()</code> returns <code>Flowable&lt;Boolean&gt;</code> but can return something else like <code>Single&lt;Boolean&gt;</code>.</p>

<p><strong>EDIT:</strong> Another question, if <code>call.isEmpty()</code> returns <code>Flowable&lt;Boolean&gt;</code> how can I merge two streams (two <code>Flowable&lt;Boolean&gt;</code>s - <code>states.isError</code> and <code>call.isEmpty()</code>) and map it to one <code>Flowable&lt;Boolean&gt;</code> so it's one condition?</p>
",2897341,,2897341,,2018-09-02 20:51:00,2019-11-28 14:25:44,rx - Conditional flatMap / add condition to flowable boolean,<kotlin><rxjs><rx-java><rx-java2><rx-kotlin>,3,2,0,,,CC BY-SA 4.0
52190121,1,0,0,2018-09-05 16:55:30,,0,2333,"<p>I am new to the Rx world so please bear with me.</p>

<p>My code is in Kotlin but a Java code will help also.</p>

<p>I have 2 methods, one of them loads tasks from the database, if there are tasks, I want to send them to the server.</p>

<pre><code>fun getListFromDb(): Single&lt;List&lt;TaskEntity&gt;&gt; {
    return taskEntityDao.getAll()
}

 fun syncTasks(localTasks: TaskSyncRequest): Observable&lt;ApiResponse&lt;List&lt;TaskEntity&gt;&gt;&gt; {
    return taskServices.syncTasks(localTasks)
}
</code></pre>

<p>I know I can use flatmap to chain observables, but just couldn't get it working between Single and Observables.</p>
",10216356,,0,,,2018-09-28 23:32:37,How to chain an Observable with a Single in RxJava?,<rx-java><rx-java2><flatmap><rx-kotlin><rx-kotlin2>,1,4,0,,,CC BY-SA 4.0
52198674,1,0,0,2018-09-06 07:26:51,,0,86,"<p>Having read the article <a href=""http://hannesdorfmann.com/android/mosby3-mvi-1"" rel=""nofollow noreferrer"">MODEL-VIEW-INTENT</a> written by Hannes Dorfmann, I designed my app using the MVI pattern.</p>

<p>This is my design chart of my application.<a href=""https://i.stack.imgur.com/bg0Nz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bg0Nz.png"" alt=""design chart""></a></p>

<p>I have two reusable fragments, BarFragment and ContentFragment. And my activity is made up of those two fragments.</p>

<p>The data flow is:</p>

<p>Step 1: The changeKeywordIntent() method gathers user's input from the search view in BarFragment.</p>

<pre><code>override fun changeKeywordIntent(): Observable&lt;String?&gt; {
    return RxSearchView.queryTextChangeEvents(view!!.search)
            .filter { it.isSubmitted }
            .map { it.queryText().toString() }
}
</code></pre>

<p>Step 2: To reuse the fragment, the intent is not subscribed by render() method directly. </p>

<p>On receiving the intent, the presenter emit an PartialViewState.ChangeKeyword(keyword) object to the partialViewStateSubject first. This partial view state will be reduced to ViewState and then, consumed by all the MvpView's render() method. I.E., the views will show that keyword at a proper position. </p>

<p>This is like a broadcast. </p>

<p>After the PartialViewState.ChangeKeyword(keyword) object has been rendered, the presenter calls a business logic and then emit a PartialViewState.ContentFirstPage(response.body()) start with a PartialViewState.Loading() object. </p>

<p>My question is in this step, Call which RxJava2 method can I ensure that before the second observable emit, the first observable is subscribed? And which method to create the second observable?</p>

<pre><code>intent(EmployeesBarView::changeKeywordIntent).flatMap { keyword -&gt;
            Observable.concat(
                    Observable.just(EmployeesScenarioPartialViewState.ChangeKeyword(keyword) as EmployeesScenarioPartialViewState),
                    Observable.someMethod {
                    // to ensure viewStateSubject.value is the value after PartialViewState.ChangeKeyword(keyword) has been subscribed, I don't know which method I should call
                        Observable.just(viewStateSubject.value).flatMap { viewState -&gt;
                            EmployeeStub.getInstance(activity.baseContext).query(toFilterLogicExpr(viewState.keyword), toOrderByListExpr(viewState.orderBy), toRangeExpr(0, viewState.pageSize), null).toObservable()
                                    .map { response -&gt; EmployeesScenarioPartialViewState.ContentFirstPage(response.body()) as EmployeesScenarioPartialViewState }
                                    .startWith(EmployeesScenarioPartialViewState.Loading())
                                    .onErrorReturn { error -&gt; EmployeesScenarioPartialViewState.Error(error.message) }
                        }
                    })
        }.subscribe(partialViewStateSubject::onNext).addTo(compositeDisposable)
</code></pre>

<p>Step 3: When a PartialViewState object is received, reduce it to a ViewState object and push the ViewState object to viewStateSubject. Key code is</p>

<pre><code>employeesScenarioViewStatePartialSubject
                .scan(initialEmployeesScenarioViewState(), ::reduceEmployeesScenarioViewState)
                .subscribe(employeesScenarioViewStateSubject::onNext)
                .addTo(compositeDisposable)
</code></pre>

<p>Step 4: All presenters subscribe viewStateSubject in bindIntents() method</p>

<pre><code>subscribeViewState(viewStateSubject.observeOn(AndroidSchedulers.mainThread())) { obj, state -&gt; obj.render(state) }
</code></pre>

<p>Step 5: render the viewState object, the code could be skipped in this question.</p>

<p>So my question is in step 2, could anyone help me with that code with RxJava2? Thank you.</p>
",7725586,,7725586,,2018-09-06 07:41:36,2018-12-19 03:56:33,How can I ensure the first Observable is subscribed before the second one emits in RxJava2?,<rx-java2><mosby><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
52198889,1,52231733,0,2018-09-06 07:40:10,,0,362,"<p>I have trying to parse actual response body even if server returns 401 HTTP Exception.</p>

<pre><code>protected inline fun &lt;RESPONSE : ParentResponse&gt; executeNetworkCall(
        crossinline request: () -&gt; Single&lt;RESPONSE&gt;,
        crossinline successful: (t: RESPONSE) -&gt; Unit,
        crossinline error: (t: RESPONSE) -&gt; Unit) {

    request().subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { t: RESPONSE -&gt;
                        errorHandler!!.checkApiResponseError(t)?.let {
                            listener?.onErrorWithId(t.message!!)
                            error(t)
                            return@subscribe
                        }
                        successful(t)
                    }
                    ,
                    { t: Throwable -&gt;
                        listener?.onErrorWithId(t.message!!)
                    }
            )
}
</code></pre>

<p>This is what I have written. It parses response and error very well when both are separate in usual ways. But I want to parse success response when I get even 401 HTTP Exception.</p>

<p>Thanks in advance..</p>

<p>Response with 401 HTTP looks like below.</p>

<pre><code>401 Unauthorized - HTTP Exception 
{""Message"":""Authentication unsuccessful"",""otherData"":""//Some data""}
</code></pre>

<p>By the way I have to check HTTP error code..</p>

<pre><code>if (statusCode==401){
 print(""Authentication unsuccessful"")
}
</code></pre>
",3282461,,0,,,2018-09-08 03:31:55,How to parse success body response on http exception 401?,<android><kotlin><rx-java2><rx-kotlin><android-mvvm>,1,2,0,,,CC BY-SA 4.0
52219187,1,53335756,0,2018-09-07 09:10:07,,4,7885,"<p>Here is my Code that for Volley Request:- </p>

<pre><code>    val searchRequest = object : JsonArrayRequest(Request.Method.GET,url,
            Response.Listener { response -&gt;

                val result = response.toString()


            },
            Response.ErrorListener { error -&gt;
                Toast.makeText(activity, ""Error!"",Toast.LENGTH_LONG)
                        .show()
                Log.d(""ERROR"",error.toString())
            })
    {
        override fun getBody(): ByteArray {

           //   TODO add Body, Header section works  //////////

            return super.getBody()
        }

        override fun getBodyContentType(): String {
            return ""application/json""
        }


        override fun getHeaders() : Map&lt;String,String&gt; {
            val params: MutableMap&lt;String, String&gt; = HashMap()
            params[""Search-String""] = songName
            params[""Authorization""] = ""Bearer ${accessTx.text}""
            return params
        }
    }
    AppController.instance!!.addToRequestQueue(searchRequest)
</code></pre>

<p>I want to add this information in the body section</p>

<p>video_id =  ""BDJIAH"" , 
audio_quality = ""256"" </p>

<p>here is the sample to add above information in the below segment.</p>

<p>{
""video_id"":""ABCDE"",
 ""audio_quality"":""256""
}</p>

<p>Basically, I am facing problem in ByteArray section. That doesn't work for me.</p>
",8188198,,0,,,2020-02-05 06:51:58,How to add Body in Url in Volley request in Kotlin?,<json><kotlin><android-volley><kotlin-android-extensions><rx-kotlin>,2,0,0,,,CC BY-SA 4.0
52255995,1,0,0,2018-09-10 10:39:42,,0,67,"<p>I'm looking to make a sample project with a clean architecture approach and i have some difficulties to transform a single to another.</p>

<p>I have my retrofit service (with a Single) :</p>

<pre><code>@GET(""nearbysearch/json"") fun getNearbyPlaces(@Query(""type"") type: String, @Query(""location"") location: String, @Query(""radius"") radius: Int): Single&lt;GooglePlacesNearbySearchResult&gt;
</code></pre>

<p>And i use it in my repository implementation :</p>

<pre><code>override fun getNearbyPlaces(type: String, location: String, radius: Int): Single&lt;List&lt;Place&gt;&gt; {
    return googlePlacesApi.getNearbyPlaces(type, location, radius)
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.computation())
        .doOnSuccess { googlePlacesNearbySearchResult -&gt; nearbyPlaceListResultMapper.transform(googlePlacesNearbySearchResult) }
}
</code></pre>

<p>In this single, i want to transform my <code>Single&lt;GooglePlacesNearbyResultSearch&gt;</code> to a <code>Single&lt;List&lt;Place&gt;&gt;</code>, and i want to do this with my mapper <code>NearbyPlaceListResultMapper</code></p>

<p>The issue is i don't succeed in having a <code>Single&lt;List&lt;Place&gt;&gt;</code> at the end. I can transform it to an Observable or a Completable but not the Single one.</p>

<p>Can anyone help me to have it in a cleaner way ?</p>

<p>Thanks</p>
",10291684,,0,,,2018-09-10 17:56:22,ReactiveX - Single<T> to Single<R>,<rx-java><retrofit2><reactivex><clean-architecture><rx-kotlin>,1,0,1,,,CC BY-SA 4.0
52331198,1,0,0,2018-09-14 11:38:18,,0,72,"<p>I have following code that works well.</p>

<pre><code>Observable.from(...)
    .map { // List&lt;Object&gt;
        if (My_Condition_is_true) {
            //...
        }
        val newList = getNewListIfConditionIsOkay(it)
        newList.map { item -&gt; toSomethingElse(item) }
    }
    .subscribeBy(myErrorFun) {
        //...
    }
</code></pre>

<p>I feel <code>map</code> operator does not looks cool but I have no idea how to fix it. This is what is in my mind.</p>

<pre><code>Observable.from(...)
        .doOnNext {// List&lt;Object&gt;
            if (My_Condition_is_true) {
                //...
                return getNewListIfConditionIsOkay(it)
            }
            return it
        .map { // List&lt;Object&gt;
            it.map { item -&gt; toSomethingElse(item) }
        }
        .subscribeBy(myErrorFun) {
            //...
        }
</code></pre>

<p>My Observable returns only a list. What is your recommendation? </p>
",513413,,472495,,2018-09-18 09:03:43,2018-09-18 09:03:43,How to pass modified list downstream in RxJava in Android?,<android><rx-java2><rx-kotlin>,2,2,0,,,CC BY-SA 4.0
52358275,1,52358500,0,2018-09-16 20:51:49,,0,3401,"<p>This question is related to Android and life-cycles.
Previously, I would have a series of subjects and subscribe to them on creation.</p>

<p>Upon destruction, I would mark all the subjects as complete, assuming that it disposes all subscribers.</p>

<p>With Android Studio 3.1, I get warnings for any subscriber that ""isn't used"". The solution is to add them to a ""completable disposable"" that I then dispose upon destruction.</p>

<p>Is ""composite disposable"" all I need to properly cancel requests upon destruction? Did my previous way of marking subjects as complete do anything and is it necessary in this case?</p>

<p>As a code example:</p>

<pre><code>val observable: PublishSubject&lt;Int&gt; = PublishSubject.create()
val disposable = observable.subscribe { /* subscription */ }

fun onDestroy() {
    observable.onComplete() // is this line necessary or helpful?
    disposable.dispose()
}
</code></pre>
",4407321,,9530467,,2018-09-17 04:38:22,2018-09-17 04:38:22,Disposing of observables,<android><rx-java2><rx-kotlin2>,2,2,0,,,CC BY-SA 4.0
52387704,1,53049617,0,2018-09-18 13:27:46,,0,233,"<p>I'm trying to set up a DrawerLayout in the MvRx sample project but i am kind of stuck.</p>

<p>Totally new to both epoxy and MvRx in general and i have been playing around for a week now learning about the framework and testing components i need to convert our app to MvRx.</p>

<p><strong>What i am wondering is how you setup a DrawerLayout view using MvRx.</strong></p>

<p>Also the current examples are very comprehensive for noobs. Anyone has a minimalist starter available?</p>

<p>// JQ</p>
",2333802,,4438601,,2018-09-19 06:35:44,2018-10-29 16:12:15,MvRX DrawerLayout + generally more examples wanted,<android><kotlin><drawerlayout><rx-kotlin><epoxy>,1,0,1,,,CC BY-SA 4.0
52435122,1,0,0,2018-09-21 00:45:44,,0,458,"<p><a href=""https://i.stack.imgur.com/FDdi6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FDdi6.png"" alt=""enter image description here""></a></p>

<p>So I have a database in Firebase Cloud Firestore that stores users and tasks. Each user has a number of fields such as name, username,etc. I want to know how to fetch each field that is associated with each user using Kotlin. </p>

<p>I'm trying to get all these accounts so I can display them in an activity called friends, that's why I want to collect all these accounts from the database. Here is a picture of my database to have a clear understanding of what I'm trying to do. </p>
",5730289,,10191554,,2018-09-21 05:03:19,2018-09-21 05:03:19,how to get data from Firebase Cloud Firestore in Kotlin,<android><android-studio><kotlin><google-cloud-firestore><rx-kotlin>,0,3,0,,,CC BY-SA 4.0
52446947,1,52448032,0,2018-09-21 15:31:52,,2,512,"<p>I'm trying to use combineLatest with several RxTextViews and I thought that I was disposing my Disposables properly but it looks like I'm still getting a memory leak.</p>

<pre><code>val one = RxTextView.afterTextChangeEvents(one)
            val two = RxTextView.afterTextChangeEvents(two)
            val three = RxTextView.afterTextChangeEvents(three)
            val four = RxTextView.afterTextChangeEvents(four)
            val five = RxTextView.afterTextChangeEvents(five)

            val disposable = Observables.combineLatest(one, two, three, four, five) { oneEvent, twoEvent, threeEvent, fourEvent, fiveEvent -&gt;
                 //combining happening with these strings: oneEvent.view().text.toString  }
                    .skip(1) 
                    .debounce(1000, TimeUnit.MILLISECONDS)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe {
                        //network call
                    }
            compositeDisposable.add(disposable)
        }
</code></pre>

<p>And then in my <code>onStop</code> I dispose of it.</p>

<pre><code>override fun onStop() {
    super.onStop()
    if (!compositeDisposable.isDisposed) {
        compositeDisposable.dispose()
    }
}
</code></pre>

<p>I read that if some Views are referenced in the onNext() method, then there‚Äôs a potential NullPointerException which is what I believe is happening. Here's my NPE I'm getting:</p>

<pre><code>fatal Exception: java.lang.NullPointerException: view == null
       at com.jakewharton.rxbinding2.internal.Preconditions.checkNotNull(Preconditions.java:27)
       at com.jakewharton.rxbinding2.widget.RxTextView.afterTextChangeEvents(RxTextView.java:159)
       at MyFragment$setUpTextListeners$1.execute(MyFragment.kt:170)
</code></pre>

<p>Here's the fragment I'm using:</p>

<pre><code>private lateinit var viewModel: MyViewModel
private lateinit var binding: FragmentMyThingsBinding

private val compositeDisposable = CompositeDisposable()

override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {

    binding = FragmentMyThingsBinding.inflate(inflater, container, false)
    viewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)
    binding.viewModel = viewModel

    //calls to kick off business logic

    return binding.root
}


override fun onStart() {
    super.onStart()

    setUpTextListeners()
}

override fun onStop() {
    super.onStop()
    if (!compositeDisposable.isDisposed) {
        compositeDisposable.dispose()
    }
}

private fun setUpTextListeners() {

    val one = RxTextView.afterTextChangeEvents(one)
    val two = RxTextView.afterTextChangeEvents(two)
    val three = RxTextView.afterTextChangeEvents(three)
    val four = RxTextView.afterTextChangeEvents(four)
    val five = RxTextView.afterTextChangeEvents(five)

    compositeDisposable.add(Observables.combineLatest(one, two, three, four, five) { oneEvent, twoEvent, threeEvent, fourEvent, fiveEvent -&gt;
            //combine here using oneEvent.view().text.toString  }
            .skip(1)
            .debounce(1000, TimeUnit.MILLISECONDS)
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                //network call
            })

    }
}
</code></pre>
",2752082,,2752082,,2018-09-21 17:28:04,2018-09-23 12:59:32,"Rxjava, combineLatest with RxTextView memory leak",<android><memory-leaks><rx-java><rx-kotlin><rx-binding>,1,0,0,,,CC BY-SA 4.0
52544735,1,0,0,2018-09-27 20:33:27,,2,1004,"<p>I have a data provider that has an <code>Observable&lt;Int&gt;</code> as part of the public API. My class under test maps this into a <code>Observable&lt;String&gt;</code>.</p>

<p>How do I create a mock so that it can send out different values on the data provider's observable?</p>

<p>I can do it using a <code>Fake</code> object, but that is a lot of work that I don't think is necessary with MockK.</p>

<p>Simplified code:</p>

<pre><code>interface DataProvider {
    val numberData:Observable&lt;Int&gt;
}

class FakeDataProvider():DataProvider {

    private  val _numberData = BehaviorSubject.createDefault(0)
    override val  numberData = _numberData.hide()

    // Note: the internals of this class cause the _numberData changes.
    // I can use this method to fake the changes for this fake object,
    // but the real class doesn't have this method.

    fun fakeNewNumber( newNumber:Int ) {
        _numberData.onNext( newNumber )
    }
}

interface ClassUnderTest {
    val stringData:Observable&lt;String&gt;

}
class MyClassUnderTest( dataProvider: DataProvider ):ClassUnderTest {

    override val stringData = dataProvider.numberData.map { ""string = "" + it.toString() }
}

class MockKTests {

    @Test fun testUsingFakeDataProvider() {

        val fakeDataProvider        = FakeDataProvider()
        val classUnderTest          = MyClassUnderTest( fakeDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )

        fakeDataProvider.fakeNewNumber( 1 )
        fakeDataProvider.fakeNewNumber( 2 )
        fakeDataProvider.fakeNewNumber( 3 )

        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }

    // How do you write the mock to trigger the dataProvider observable?
    @Test fun testUsingMockDataProvider() {
        val mockDataProvider        = mockk&lt;DataProvider&gt;()

//        every { ... what goes here ... } just Runs

        val classUnderTest          = MyClassUnderTest( mockDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )


        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }
}
</code></pre>
",5135551,,0,,,2018-11-15 12:33:03,How to use MockK to mock an observable,<rx-kotlin><rx-kotlin2><mockk>,1,0,0,,,CC BY-SA 4.0
52566383,1,52588056,0,2018-09-29 07:58:20,,0,765,"<p>I have a dummy network data source:</p>

<pre><code>    fun networkDataSource(): Single&lt;List&lt;Int&gt;&gt; {
        return Single.just((0 until 100).toList())
                .delay(150, TimeUnit.MILLISECONDS)
    }
</code></pre>

<p>Here is an endless observable. It's main use is that it's calculation should be 'protected', so that <strong>it calculates it's single value only once</strong>. <em>(Here the value is the 1.)</em></p>

<pre><code>    val endless = Observable
            .just(1)
            .observeOn(Schedulers.io())
            .delay(500, TimeUnit.MILLISECONDS)
            // Counts as heavy operation, do not calculate this here once again
            .doOnNext { println(""=&gt; E: Calculated once"") }
            .cache()
            //.doOnNext { println(""=&gt; E: From cache"") }
            .repeat()
</code></pre>

<p>The main stream just simply emits values:</p>

<pre><code>    val mainStream = Observable.range(0, 6)
            .doOnNext { println(""=&gt; M: Main stream $it"") }
</code></pre>

<p>The task:</p>

<p>Zip the 3 observables together, and optimize the network usage, so that it will not be called more than necessary. (Once the number of data - integers in this case - is met.</p>

<p>Approach:</p>

<pre><code>    mainStream
            .concatMap {index -&gt;
                Observables.zip(
                        Observable.just(index),
                        endless,
                        networkDataSource()
                                .toObservable()
                                .doOnNext { println(""#&gt; N: Network data fetch $index"") }
                )
            }
            .doOnNext { println(""=&gt; After concatmap: ${it.first}"") }
            .take(4)
            .doOnNext { println(""=&gt; After take: ${it.first}"") }
            .subscribe(
                    { println(""=&gt; Last onnext"") },
                    { it.printStackTrace() },
                    { synchronized(check) { check.notifyAll() } }
            )
</code></pre>

<p>Finishing the locked thread - only needed for testing:</p>

<pre><code>synchronized(check) {
    check.wait()
}
println(""Ending"")
</code></pre>

<p>Here is the output:</p>

<pre><code>=&gt; M: Main stream 0
=&gt; M: Main stream 1
=&gt; M: Main stream 2
=&gt; M: Main stream 3
=&gt; M: Main stream 4
=&gt; M: Main stream 5
#&gt; N: Network data fetch 0
=&gt; E: Calculated once
=&gt; After concatmap: 0
=&gt; After take: 0
=&gt; Last onnext
#&gt; N: Network data fetch 1
=&gt; After concatmap: 1
=&gt; After take: 1
=&gt; Last onnext
</code></pre>

<p>This the output and it is stuck after the second take. (Doesn't proceed in a minute). My question is, why does that happen? </p>

<p>As a sidenote, if I uncomment the line from the <code>endless</code> observable:</p>

<pre><code>.doOnNext { println(""=&gt; E: From cache"") }
</code></pre>

<p>It is going to flood the console with that line. Why is <code>endless</code> called so many times instead for each iteration?</p>

<p><code>flatMap()</code> is not a solution here, because it does not take <code>take(4)</code> into account and proceeds to finish all network calls.</p>

<p>So how could I make <code>concatMap()</code> work?</p>

<p>(I also added <em>RxJS</em> tag because this is a reactive problem and absolutely not about Kotlin. JS solutions are also welcome, if those functions exist in the RxJava library.)</p>

<p>Edit.:</p>

<p>I looked into the code and the 2 outputs are probably because of the <code>prefetch</code> parameter:</p>

<pre><code>@CheckReturnValue
@SchedulerSupport(SchedulerSupport.NONE)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) {
    return concatMap(mapper, 2);
}
</code></pre>

<p>But I still don't understand how it works. I've only read that <code>concatMap()</code> is <code>flatmap()</code>, but it waits for the results of each.</p>
",4420543,,4420543,,2018-09-29 08:03:25,2018-10-01 09:25:10,RxJava: concatMap() with zip() gets stuck,<kotlin><rxjs><rx-java><rx-java2><rx-kotlin>,1,4,0,,,CC BY-SA 4.0
52603665,1,0,0,2018-10-02 07:20:55,,1,1631,"<p>Rx noobie here: any idea on how to achieve this?:</p>

<p>I have a list of items from the UI and would like to POST them to the server. I need the list of POSTed items back from the server (to use the server-issued IDs, timestamps etc).</p>

<p>Pardon my long examples but here's the code I'm struggle to make work:</p>

<pre><code>/**
 * create each item (POST) in the list and return the list
 * of newly created ones
 */
fun postItems(items: List&lt;Item&gt;): Maybe&lt;List&lt;Item&gt;&gt; {
    // loop through all items, making a network call for each and return the
    // list of POSTed items

    // attempt 1
    // Failed type inference. Expected type mismatch:
    // Expected: Maybe&lt;List&lt;Item&gt;&gt;
    // Found: List&lt;Maybe&lt;Item&gt;&gt;
    return items.map {
        postItem(it)
    }

    // attempt 2: 'extract' each item in resulting observable and
    // shove it back to original list
    return Maybe.just(items.map {
        postItem(it!!)
                // 'extract' item from observable
                .flatMap {
                    // error: Type mismatch.
                    // Required ((Item) -&gt; MaybeSource&lt;out (???...???)&gt;!)!
                    // Found (Item) -&gt; Item
                    it
                }
    })

    // attempt 3: convert a Maybe to Flowable to collect all items from post
    // and emit them as a single list
    // Type mismatch. Required:(((Mutable)List&lt;Item!&gt;) -&gt; SingleSource&lt;out (???...???)&gt;!)!
    // Found: ((Mutable)List&lt;Item!&gt;) -&gt; (Mutable)List&lt;Item!&gt;
    return items.forEach {
        postItem(it!!).toFlowable().toList().flatMap { it }
    }

    // attempt 4: modify attempt 3 with concatMap:
    // Type mismatch. Required:((List&lt;Item!&gt;) -&gt; MaybeSource&lt;out (???...???)&gt;!)!
    // Found: (List&lt;Item!&gt;) -&gt; List&lt;Maybe&lt;Item&gt;&gt;
    return Maybe.just(items)
            // wait for each observable to finish all the work 
            // until the next one is processed
            .concatMap({
                it.map { addItem(it!!) }
            }).toFlowable()
            .toList().toMaybe()

    // attempt 6: blocking call on each API request.
    // results in android.os.NetworkOnMainThreadException
    return Maybe.just(places.map {
        addPlace(it!!).blockingGet()
    })
}

fun postItem(item: Item): Maybe&lt;Item&gt; {
    return networkService.post(item) // async call to API, returns Maybe&lt;Item&gt;
}
</code></pre>

<p><strong>UPDATE</strong></p>

<p>I have tried the approach suggested by @AlexeySoshin below but still have some points of confusion:</p>

<p>I have tried the second, shorter approach but the retrofit call doesn't go thru for some reason :(, i.e the network service endpoints aren't hit). It's slightly modified because I couldn't get rx-kotlin wrapper to work, but I imagine it's roughly equivalent to this:</p>

<pre><code>fun addItems(items: List&lt;Item?&gt;): Flowable&lt;Maybe&lt;Item&gt;&gt; {
    return Flowable.fromIterable(items).map {
        // tried items.toFlowable().map but got 'Unresolved reference toFlowable
        // even after adding rx-kotlin to project via gradle
        return@map postItem(it)
    }
}
</code></pre>

<p>My network service works successfully for a single Item with this code:</p>

<pre><code>// works as expected
fun postOneItem(item: Item): Maybe&lt;Item&gt; {
    return postItem(item)
}

// also works
fun postOneItemFlowable(item: Item): Flowable&lt;Item&gt; {
    return postItem(item).toFlowable()
}


// this variant didn't work
fun postOneItemFlowable(item: Item): Flowable&lt;Maybe&lt;Item&gt;&gt; {
    return Flowable.just(postItem(item))
}
</code></pre>

<p>How to make <code>Flowable&lt;Maybe&lt;Item&gt;&gt;</code> calls go thru successfully? (or <code>Flowable&lt;List&lt;Item&gt;&gt;</code>, which would be closer to what I need eventually)</p>

<p>Finally, how to obtain the actual output list from a
    <code>Flowable&lt;Maybe&lt;Item&gt;&gt;</code>? It would help to see how the <code>.subscribe()</code>
    block might look like to 'extract' that final list. Here is how my current subscribe code looks like:</p>

<pre><code>...
private fun createItem(item: Item) {
    disposables.add(
            addItemUseCase.postOneItem(item)
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        Timber.d(""one item posted: $it"")
                    }, { /* error handler *//})
}
...
</code></pre>
",1145905,,1145905,,2018-10-04 07:58:27,2018-10-04 07:58:27,RxJava: Create items in list and return new list,<java><android><kotlin><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
52642493,1,0,0,2018-10-04 08:39:30,,1,60,"<p>Probably an rx newbee question.</p>

<p>If I have two rx streams, which have some common parts, is there a possibility to extract and to reuse them?</p>

<p>Here is pseudo code example:</p>

<pre><code>someManager.getInfo(id) returns a Single&lt;SometInfo&gt;
</code></pre>

<p>This fun takes an id and should return just a single with status</p>

<pre><code>fun getStatus(id: String): Single&lt;Status&gt; =
    someManager.getInfo(id)
        .flattenAsObservable { it.items }
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
</code></pre>

<p>and this one doesn't take an id but already an object and should check if a status is ok</p>

<pre><code>fun isStatusOk(info: SomeInfo): Single&lt;Boolean&gt; =
    Observable.fromIterable(info.items)
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
        .map { it == Status.OK }
</code></pre>

<p>Thank you in advance</p>
",408780,,408780,,2018-10-04 08:53:42,2018-10-22 10:22:01,Reuse part of RxJava stream,<rx-java><rx-java2><rx-kotlin><rx-kotlin2>,2,3,0,,,CC BY-SA 4.0
52756197,1,52758673,0,2018-10-11 09:03:02,,3,633,"<p>Here is a kotlin activity which should display a list of events (from sample.json)</p>

<pre><code>class TalksActivity : AppCompatActivity(), TalkAdapter.Listener {

private val TAG = TalksActivity::class.java.simpleName

private var mCompositeDisposable: CompositeDisposable? = null
private var mAdapter: TalkAdapter? = null
private var disposable: Disposable? = null
private val mapper = createMapper()

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_talks)
    pbWaiting.visibility = View.VISIBLE

    mCompositeDisposable = CompositeDisposable()

    initRecyclerView()
    loadTalks()
}


private fun initRecyclerView() {
    rv_talks_list.setHasFixedSize(true)
    val layoutManager: RecyclerView.LayoutManager = LinearLayoutManager(this)
    rv_talks_list.layoutManager = layoutManager
    rv_talks_list.adapter = TalkAdapter(ArrayList(Collections.emptyList()), this)
}

private fun loadTalks() {
    disposable = getTalks()
            .subscribeOn(AndroidSchedulers.mainThread())
            .observeOn(Schedulers.io())
            .subscribe ({ result -&gt; handleResponse(result) }, { error -&gt; handleError(error) })
}

private fun handleResponse(talkList: List&lt;Talk&gt;) {
    mAdapter = TalkAdapter(ArrayList(talkList), this)
    rv_talks_list.adapter = mAdapter
    pbWaiting.visibility = View.GONE
}

private fun handleError(error: Throwable) {
    pbWaiting.visibility = View.GONE
    throw error
}

private fun createMapper(): ObjectMapper {
    val mapper = jacksonObjectMapper()
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
    return mapper
}

override fun onItemClick(talk: Talk) {
    startActivity(CountdownActivity.newIntent(this, talk))
}

private fun getTalks() : Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.create&lt;List&lt;Talk&gt;&gt; {
        mapper.readValue(text, collectionType)
    }
}

}
</code></pre>

<p>The problem: When I call <code>loadTalks()</code>, handleResponse(result) or handleError(error) are never called and the screen stay white with only the progressbar running.</p>

<p>I have no error in the console.</p>

<p>Here is my very simple activity_talks.xml</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""
xmlns:app=""http://schemas.android.com/apk/res-auto""
xmlns:tools=""http://schemas.android.com/tools""
android:layout_width=""match_parent""
android:layout_height=""match_parent""
tools:context="".TalksActivity""&gt;

&lt;android.support.v7.widget.RecyclerView
    android:id=""@+id/rv_talks_list""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""
    app:layout_constraintBottom_toBottomOf=""parent""
    app:layout_constraintLeft_toLeftOf=""parent""
    app:layout_constraintRight_toRightOf=""parent""
    app:layout_constraintTop_toTopOf=""parent"" /&gt;

&lt;ProgressBar
    android:id=""@+id/pbWaiting""
    android:layout_width=""wrap_content""
    android:layout_height=""wrap_content""
    android:visibility=""gone""
    app:layout_constraintBottom_toBottomOf=""parent""
    app:layout_constraintEnd_toEndOf=""parent""
    app:layout_constraintHorizontal_bias=""0.5""
    app:layout_constraintStart_toStartOf=""parent""
    app:layout_constraintTop_toTopOf=""parent"" /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre>

<p>What's wrong?</p>

<p>This was working without rxKotlin and observable code.</p>

<p><strong>EDIT</strong></p>

<p>Here is my Adapter:</p>

<pre><code>class TalkAdapter(private val dataList: ArrayList&lt;Talk&gt;, private val listener: Listener) : RecyclerView.Adapter&lt;TalkAdapter.ViewHolder&gt;() {

interface Listener {

    fun onItemClick(talk: Talk)
}

private val colors: Array&lt;String&gt; = arrayOf(""#EF5350"", ""#EC407A"", ""#AB47BC"", ""#7E57C2"", ""#5C6BC0"", ""#42A5F5"")

override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    holder.bind(dataList[position], listener, colors, position)
}

override fun getItemCount(): Int = dataList.count()

override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {

    val view = LayoutInflater.from(parent.context).inflate(R.layout.adapter_talk, parent, false)

    return ViewHolder(view)
}

class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {

    fun bind(talk: Talk, listener: Listener, colors: Array&lt;String&gt;, position: Int) {

        itemView.title.text = talk.title
        itemView.recap.text = talk.summary
        itemView.eventId.text = talk.eventId
        itemView.setBackgroundColor(Color.parseColor(colors[position % 6]))

        itemView.setOnClickListener { listener.onItemClick(talk) }
    }
}
}
</code></pre>

<p><strong>EDIT</strong></p>

<p><em>Found the solution thanks to Demigod answer.</em></p>

<p>When I create an Observable with <code>Observable.create</code> I have to trigger  <code>onNext()</code> and <code>onError()</code> manually. </p>

<p>To fix it, change </p>

<pre><code>private fun getTalks() : Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.create&lt;List&lt;Talk&gt;&gt; {
        mapper.readValue(text, collectionType)
    }
}
</code></pre>

<p>with </p>

<pre><code>private fun getTalks(): Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.fromCallable { mapper.readValue&lt;List&lt;Talk&gt;&gt;(text, collectionType) }
}
</code></pre>

<p>and for better perfs:</p>

<pre><code>private fun getTalks(): Observable&lt;List&lt;Talk&gt;&gt; {
    return Observable.fromCallable {
        val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
        val typeFactory = mapper.typeFactory
        val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
        mapper.readValue&lt;List&lt;Talk&gt;&gt;(text, collectionType)
    }
}
</code></pre>
",2683000,,2683000,,2018-10-11 13:31:17,2018-10-11 13:31:17,Populate a RecyclerView with rxkotlin: The Recyclerview stay empty,<android><android-recyclerview><kotlin><rx-kotlin>,3,0,0,,,CC BY-SA 4.0
52761570,1,0,0,2018-10-11 13:40:18,,0,114,"<p>I've successfully compiled and able to run the app into the device, since I am getting this issue trying to use any JNIs function.</p>

<p>Here is the error which I am stuck at -</p>

<p><a href=""https://i.stack.imgur.com/8AhfN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8AhfN.png"" alt=""enter image description here""></a></p>
",1180661,,0,,,2018-10-11 13:40:18,Cannot resolve corresponding JNI Function | Open CV | Android | Kotlin,<android><kotlin><android-ndk><java-native-interface><rx-kotlin>,0,4,0,,,CC BY-SA 4.0
52973193,1,0,0,2018-10-24 15:49:22,,0,400,"<p>I am trying to bridge some existing rx code and api that uses futures. When I 
manually dispose an observable I would expect onDispose() to be always called. It usually does but when I specify a custom scheduler it sometimes does not get called. My example:</p>

<pre><code>class Work {

private val disposables = CompositeDisposable()

fun getFuture(): ListenableFuture&lt;String&gt; {

    val future = ResolvableFuture.create&lt;String&gt;()

    disposables.add(

            Observable.fromCallable {
                try {
                    Thread.sleep(2000)
                } catch (ex: InterruptedException) {

                }
                ""1""
            }.firstOrError()
                .onErrorReturn { ""2"" }
                .doOnDispose {
                    println(""disposing 1 on ${Thread.currentThread().name}"")
                    //sometimes this dispose does not get called
                    future.set(""2"")
                }
                .subscribeOn(Schedulers.io())
                .doOnDispose {
                    println(""disposing 2 on ${Thread.currentThread().name}"")
                    //only this dispose gets called every time
                    //future.set(""2"")
                }
                .subscribe(Consumer {
                    future.set(""2"")
                })
    )

    return future
}

fun stop() {
    disposables.clear()
}

}

@Test
fun `doOnDispose does not get called`() {
    println(""------------"")

    for (i in 1..100) {

        val work = Work()

        val future = work.getFuture()

        println(""Cancelling"")

        work.stop()

        println(""Getting ${Thread.currentThread().name}"")
        val result = future.get(2, TimeUnit.SECONDS)

        assertEquals(""2"", result)

        println(""------------"")
    }
}
</code></pre>

<p>What happens is only the second onDispose gets called every time. The one before .subscribeOn() is sometimes not called at all.  </p>
",935553,,0,,,2018-10-24 20:52:06,doOnDispose does not get called when subscribing on a background scheduler,<rx-java><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
53034295,1,0,0,2018-10-28 17:32:42,,0,1527,"<p>Unfortunately, I can't understand how to check Observable.</p>

<p>Depending on connection - I want to get my data from network or DB.</p>

<p>I have a method that checks network connection:</p>

<pre><code>companion object {
        fun isConnected() : Observable&lt;Boolean&gt; {
            val connectivityManager = MyApplication.applicationContext().getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val activeNetwork = connectivityManager.activeNetworkInfo
            val isConnectedException = activeNetwork != null &amp;&amp; activeNetwork.isConnectedOrConnecting
            return Observable.just(isConnectedException)
        }
    }
</code></pre>

<p>So if it's true I want to call my network method:</p>

<pre><code>override fun searchGroups(q: String): Observable&lt;List&lt;Group&gt;&gt; {
        return groupApi.searchGroups(GroupSearchRequest(q).toMap())
                .flatMap { groupResponse -&gt; Observable.just(groupResponse.response.items) }
                .doOnNext{ groupList -&gt; groupRepository.insertGroups(groupList)}
    }
</code></pre>

<p>and in the other case I want to call DB method:</p>

<pre><code>override fun getGroupsFromDB(q: String): Observable&lt;List&lt;Group&gt;&gt; {
        return groupRepository.findByName(q)
    }
</code></pre>

<p>Here is my try to do this, but I think there is problem because of nullable interactor, but still don't know what to do.</p>

<pre><code>compositeDisposable.add(
                NetworkManager.isConnected()
                        .flatMap {
                             if (it) {
                                interactor?.searchGroups(q)
                            } else {
                                interactor?.getGroupsFromDB(q)
                            }
                        }
    }
    )
</code></pre>

<p><a href=""https://i.stack.imgur.com/xpHpD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xpHpD.png"" alt=""enter image description here""></a></p>

<p>Could anybody please help me with that ?</p>

<p><strong>UPDATE</strong></p>

<p>So the problem was in nullable object <code>interactor</code>.</p>

<p>Could anybody please suggest the better way to not using <code>!!</code> for <code>interactor</code> object?</p>

<p><a href=""https://i.stack.imgur.com/n6mC6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/n6mC6.png"" alt=""enter image description here""></a></p>
",6812826,,1149924,,2018-11-02 10:45:15,2018-11-02 10:45:15,How to check Observable<Boolean>?,<kotlin><rx-java2><rx-kotlin2>,0,4,0,,,CC BY-SA 4.0
53181063,1,0,0,2018-11-06 22:30:18,,0,124,"<p>I am calling apis using retrofit and rxkotlin. But when I start fragment the app gets crash without any notification or does not show any error msg in the studio logcat. Here is the code.
From here I am call the apis interface</p>

<pre><code>try {
        if (disposable == null) {

            Log.e(""disposable"",""reached"")

            disposable = api.getUsers(api_key,
                    ""json"",
                    ""1"",
                    ""flickr.interestingness.getList"")
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe (
                            {
                                data: FlickrPhoto? -&gt; Log.e(""flickr photo"",data!!.photo?.get(0)?.secret)
                            }

                    )

            Log.e(""disposable1"",""reached"")
        }
    }
    catch (e: Exception){
        Log.e(""flickr fragment"",e.toString())
    }
</code></pre>

<p>Here is the api interface code :</p>

<pre><code>interface API {

@GET(""services/rest"")
fun getUsers(@Query(""format"") format : String,
             @Query(""api_key"") api_key : String,
             @Query(""nojsoncallback"") nojsoncallback : String,
             @Query(""method"") method : String
) : Observable&lt;FlickrPhoto&gt;

companion object{
    fun createView():API{

        Log.e(""apis"",""creatview"")
        try {
            val retrofit = Retrofit.Builder()
                    .baseUrl(""https://api.flickr.com/"")
                    .addCallAdapterFactory(
                            RxJava2CallAdapterFactory.create())
                    .addConverterFactory(
                            GsonConverterFactory.create())
                    .build()


            Log.e(""retrofit"",retrofit.toString())

            return retrofit.create(API::class.java)
        }
        catch (e: Exception){
            Log.e(""api exception"",e.message)
        }
        Log.e(""apis"",""creatview retrofit null"")
        return null!!
    }

}
}
</code></pre>

<p>Here is the logcat:</p>

<pre><code>11-07 03:47:07.527 11627-11627/com.redvelvet.abhi.imagesmapling E/disposable: reached
11-07 03:47:07.529 11627-11627/com.redvelvet.abhi.imagesmapling E/apis: creatview
11-07 03:47:07.620 11627-11627/com.redvelvet.abhi.imagesmapling E/retrofit: retrofit2.Retrofit@ec11d24
11-07 03:47:07.751 11627-11627/com.redvelvet.abhi.imagesmapling E/disposable1: reached
</code></pre>
",7258452,,7258452,,2018-11-06 22:38:12,2018-11-06 22:38:12,App is crashing without showing any error?,<android-studio><retrofit2><rx-android><rx-kotlin2>,0,3,0,,,CC BY-SA 4.0
53281983,1,53283004,0,2018-11-13 13:22:43,,1,252,"<p>i am using rx kotlin newly and didn't understand all of it yet. I am trying to loop over a list of queries, and execute them one by one. in this list i have a special string that once reached, i want to break the loop and perform another function</p>

<p>how can i do this in the below example?</p>

<pre><code>fun runQueries() {

     Observable.fromIterable(queriesTemp)

                    .subscribeOn(Schedulers.computation())
                    .doOnNext { query -&gt;
                        if (query.contains(""COMPLETION OF SDF QUERIES"")) {
                            if (loginStatus == StaticVariables.FT_CASE_NEW_LOGIN) {
                                tasksQueriesTemp = arrayOfNulls(queries.size - queries.indexOf(query))
                                System.arraycopy(queries, queries.indexOf(query), tasksQueriesTemp, 0, tasksQueriesTemp!!.size)
                            }
                          // break the loop here 
                            runOtherQueries()
                             break
                        }
                        if (!TextUtils.isEmpty(query)) {
                            mDatabase.execSQL(query, false, """")
                        }
                        action(tasksQueriesTemp!!.indexOf(query))
                    }
                    .doOnComplete { executeOtherUpdates(tasksQueriesTemp) }
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe()
}

fun runOtherQueries() {
}
</code></pre>
",1950784,,13302,,2019-12-17 21:28:23,2019-12-17 21:28:23,RXKotlin Break Inside doOnNext and Call Another Function,<android><rx-java><rx-kotlin>,1,2,1,,,CC BY-SA 4.0
53307056,1,53307691,0,2018-11-14 18:59:17,,0,712,"<p>What are the differences in the following cases: </p>

<pre><code>fun a(params: String) = Completable.fromAction {
        if (params.isEmpty()) {
            throw EmptyRequiredFieldException() 
        }
    }
</code></pre>

<p>VS</p>

<pre><code>fun b(params: String) = if(params.isEmpty()) 
       Completable.error(EmptyRequiredFieldException()) 
else 
       Completable.complete()
</code></pre>

<p>Specifically in the context of android, if it matters (even though I don't think it does)
Thanks!</p>
",10614184,,0,,,2018-11-14 19:43:23,"In RxJava/RxKotlin, what are the differences between returning a Completable.error(Exception()) and throwing?",<error-handling><kotlin><observable><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
53352838,1,53353032,0,2018-11-17 15:52:14,,1,349,"<p>I am using RxJava/Kotlin <code>Observable#take()</code> to get first 50 items from the list. But <code>#take()</code> operator is not behaving as it should as per Rx docs. </p>

<p>In Rx docs, <code>#take()</code> is defined as:</p>

<blockquote>
  <p>""Emit only the first n items emitted by an Observable""</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/q4oTZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q4oTZ.png"" alt=""enter image description here""></a></p>

<p>I have a function like this:</p>

<p>As we can see the <code>pageSize</code> argument is <code>50</code> </p>

<p><a href=""https://i.stack.imgur.com/DbyoV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DbyoV.png"" alt=""enter image description here""></a></p>

<p>And initial <code>size</code> of the <code>list</code> is <code>300</code> </p>

<p><a href=""https://i.stack.imgur.com/mK0Ai.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mK0Ai.png"" alt=""enter image description here""></a></p>

<p>After that <code>#take(50)</code> is applied to that <code>Observable</code> and at next breakpoint I still get the <strong>full size</strong> list <code>i.e. size = 300</code> </p>

<p><a href=""https://i.stack.imgur.com/hpBBD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hpBBD.png"" alt=""enter image description here""></a></p>

<p>But <code>just for the check</code>, if something is wrong with the debugger or observable, I tried to take only items whose displayName contains ""9"", but this time I get the expected result of <code>smaller list</code> with <code>9</code> in each of their <code>#displayName field</code>.</p>

<p><a href=""https://i.stack.imgur.com/zZOK5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zZOK5.png"" alt=""enter image description here""></a></p>

<p>I believe <code>RxJava/Kotlin's #take()</code> operator is not that crazy and it's just me.</p>
",2581314,,472495,,2019-01-14 20:41:53,2019-01-14 20:41:53,Observable#take(Long) not returning desired size of items in RxJava,<java><kotlin><rx-java><rx-android><rx-kotlin>,2,1,0,,,CC BY-SA 4.0
53360939,1,0,0,2018-11-18 12:35:35,,0,82,"<p>I am working on a feature where I need to filter out the network response data based on local database data.</p>

<p>For example, my network layers return me a list of items and my database layer returns an observable list of ids. Now I want to only return those objects from network layer whose id matches anyone from the database layer response.</p>

<p>Below code fetches data from the network and saves the result to a database(cache).</p>

<pre><code>factory.getRemoteDataStore()
                .searchForVenues(query)
                .toObservable()
                .distinctUntilChanged()
                .flatMap { venues -&gt;
                    factory.getCacheDataStore()
                            .saveVenues(venues)
                            .andThen(Observable.just(venues))
                }
</code></pre>

<p>I also have a method that returns a list of venues that needs to be filtered</p>

<pre><code>factory.getCacheDataStore().getDislikedVenues()
</code></pre>

<p>Now, how do I extend the previous chain to use getDislikedVenues() Observable to filter them from the response of network response?</p>

<p>Sorry for such noob question, I really am struggling with this.</p>
",5421753,,0,,,2018-11-18 14:29:27,Create a filtered observable from 2 observable of list of items in RxJava,<android><rx-java><observable><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
53456441,1,53461407,0,2018-11-24 08:23:26,,2,335,"<p>I have a scenario where we i have an emmiter which constantly emits data like this</p>

<pre><code>fun subscribeForEvents(): Flowable&lt;InkChannel&gt; {
    return Flowable.create&lt;InkChannel&gt;({
        if (inkDevice.availableDeviceServices.contains(DeviceServiceType.EVENT_DEVICE_SERVICE)) {
            (inkDevice.getDeviceService(DeviceServiceType.EVENT_DEVICE_SERVICE) as EventDeviceService).subscribe(object : EventCallback {
                override fun onUserActionExpected(p0: UserAction?) {
                    it.onNext(InkChannel.UserActionEvent(p0))
                }

                override fun onEvent(p0: InkDeviceEvent?, p1: Any?) {
                    it.onNext(InkChannel.InkEvents&lt;Any&gt;(p0, p1))
                }

                override fun onUserActionCompleted(p0: UserAction?, p1: Boolean) {

                }
            }

            )
        }
    }, BackpressureStrategy.BUFFER).share()

}
</code></pre>

<p>now i have a service which i start on application launch and listen to it</p>

<pre><code>  inkDeviceBus.subscribeForEvents()
                .filter { it -&gt; (it as InkChannel.InkEvents&lt;*&gt;).event == InkDeviceEvent.STATUS_CHANGED }
                .map { it -&gt; it as InkChannel.InkEvents&lt;*&gt; }
                .map { it -&gt; it.value.toString() }
                .filter { value -&gt; value == ""CONNECTED"" || value == ""DISCONNECTED"" }
                .map { it -&gt; it == ""CONNECTED"" }
                .subscribeBy { b -&gt;
                    if (b) stopSelf()
                }
</code></pre>

<p>I have another activity MainActivity which is called upon launch where i observe the same event.
Now the issue is only the listener in the service gets the events and the activity is not receiving any events. </p>

<p>Now when i remove the listener form the service then activity starts receiving events. I have used the operator <strong>share</strong> for sharing the observable but it doesn't seem to work</p>
",6048312,,0,,,2018-11-24 18:57:38,share() operator not working for Observable in Rxjava,<android><rx-java2><rx-android><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
53509536,1,53514768,0,2018-11-27 22:59:35,,0,77,"<p>I am trying to convert examples from <a href=""https://www.androidhive.info/RxJava/android-getting-started-with-reactive-programming/#example5"" rel=""nofollow noreferrer"">this article</a> from Java to Kotlin.
I get error from picture at Exmaple 5:</p>

<p><a href=""https://i.stack.imgur.com/Vhp81.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vhp81.png"" alt=""enter image description here""></a></p>

<p>And I noticed, that without map() function I don't get this error</p>

<p><a href=""https://i.stack.imgur.com/ZOVsj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZOVsj.png"" alt=""enter image description here""></a></p>

<p>So, what the point of this error and how to write it right?</p>
",8230672,,0,,,2018-11-28 08:05:37,mapping custom data RxAndroid with Kotlin,<android><kotlin><rx-java><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
53546662,1,0,0,2018-11-29 19:59:20,,1,65,"<p>I'm using RxRoom with Kotlin. In my Dao class 
If I use this: </p>

<p><code>@Insert
    fun insertPaymentRef(paymentRef: PaymentRef): Single&lt;Long&gt;</code></p>

<p>Or this:</p>

<pre><code>@Insert
fun insertPaymentRef(paymentRef: PaymentRef): Completable
</code></pre>

<p>the generated <code>Dao</code> class throws this error </p>

<blockquote>
  <p>error: local variable paymentRef is accessed from within inner class; needs to be declared final</p>
</blockquote>

<p>A sneek peak in the generated class is this:</p>

<pre><code>public Single&lt;Long&gt; insertPaymentRef(PaymentRef paymentRef) {
return Single.fromCallable(new Callable&lt;Long&gt;() {
  @Override
  public Long call() throws Exception {
    __db.beginTransaction();
    try {
      long _result = __insertionAdapterOfPaymentRef.insertAndReturnId(paymentRef);
      __db.setTransactionSuccessful();
      return _result;
    } finally {
      __db.endTransaction();
    }
  }
});
</code></pre>

<p>}</p>

<p>The only time I don't get this error is if I only make my <code>insert</code> call like this:</p>

<pre><code>@Insert(onConflict = OnConflictStrategy.REPLACE)
fun insertPaymentRef(paymentRef: PaymentRef)
</code></pre>

<p>How do I make the <code>INSERT</code> call work in RxRoom: I've included RxRoom dependency and it works because if I try doing <code>GET</code> calls like this </p>

<pre><code>@Query(PaymentRefDbConstants.QUERY_PAYMENT_REF)
fun getPaymentRef(): Single&lt;PaymentRef&gt;
</code></pre>

<p>It works</p>
",7338759,,7338759,,2018-11-30 00:05:05,2018-11-30 00:05:05,RxRoom Kotlin: Generated Dao - error: local variable users is accessed from within inner class; needs to be declared final,<java><android><kotlin><android-room><rx-kotlin>,0,3,0,,,CC BY-SA 4.0
53653297,1,53663648,0,2018-12-06 14:12:15,,1,628,"<p>I'm just starting using RxJava and I'm struggling to figure out how to use observables the right way.</p>

<p>Down below I have a pager and I'd like to call a web service on page scroll avoiding to many useless calls.</p>

<p>So I found that 'debounce' operator is what I am looking for but in my case it's not working and the web service is called everytime.. </p>

<pre><code>v.pager.addOnScrollListener(object : RecyclerView.OnScrollListener() {

    override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) {
        super.onScrollStateChanged(recyclerView, newState)
        if (newState == RecyclerView.SCROLL_STATE_IDLE) {

            val itemPosition : Int = layoutManager.findFirstCompletelyVisibleItemPosition();

            Observable.just(itemPosition).debounce(1500, TimeUnit.MILLISECONDS).map {
                  retrieveUserDetail(userList[itemPosition])
            }.observeOn(AndroidSchedulers.mainThread()).subscribe()

         }
    }
})
</code></pre>

<p>What's wrong with this code?</p>
",517354,,2649012,,2018-12-06 14:25:30,2018-12-07 05:15:24,Android Rx debounce operator,<android><android-viewpager><rx-java2><debounce><rx-kotlin2>,1,6,0,,,CC BY-SA 4.0
53684317,1,53684470,0,2018-12-08 16:04:24,,3,715,"<p>I want to implement method to edit a note, save it to local database (cache) and then send it to the server as a POST request. I am learning RxJava and I wanted to create <code>Observable</code> from the note and then apply transformations on it, like to map it to an Entity model and saving. The issue that my method returns Completable and this chain returns <code>Observable&lt;Completable&gt;</code>. How to unwrap the <code>Completable</code> from this <code>Observable</code> which I used only to start RxJava stuff. Each <code>editNote()</code> methods returns a <code>Completable</code>.</p>

<pre><code> override fun editNote(note: Note): Completable {
    return Observable.just(note)
        .map { mapper.mapToEntity(it) }
        .map { noteEntity -&gt;
            factory.getCacheDataStore().editNote(noteEntity)
                .andThen { factory.getRemoteDataStore().editNote(noteEntity) }
        }
}
</code></pre>

<p>=======================================================</p>

<h1>UPDATE</h1>

<p>Finally, I managed to find ""a solution"" but I am not sure it is correct :-)</p>

<pre><code>override fun editNote(note: Note): Completable {
    return Observable.just(note)
        .map { mapper.mapToEntity(it) }
        .flatMapCompletable { noteEntity -&gt;
            factory.getCacheDataStore().editNote(noteEntity)
                .andThen { factory.getRemoteDataStore().editNote(noteEntity) }
        }
}
</code></pre>
",9188790,,9188790,,2018-12-08 16:19:01,2018-12-08 16:19:33,RxJava/Kotlin Observable method call chain - how to terminate?,<android><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
53693673,1,53693797,0,2018-12-09 15:09:24,,0,85,"<p>I want <code>enable/disable</code> button when code &amp; name is not empty.</p>

<p><strong>My code:</strong></p>

<pre><code>btnAddItem.isEnabled = false

    val codeIsValid = RxTextView.textChanges(txvCode)
        .debounce(350, TimeUnit.MILLISECONDS)
        .map { code -&gt;
            code.isNotEmpty()
        }

    val nameIsValid = RxTextView.textChanges(edtName)
        .debounce(350, TimeUnit.MILLISECONDS)
        .map { name -&gt;
            name.isNotEmpty()
        }

    disposableEnableButtonSave = Observables.combineLatest(codeIsValid, nameIsValid) 
        { b1, b2 -&gt; b1 &amp;&amp; b2 }
        .subscribe {
            if (btnAddItem.isEnabled != it){
                btnAddItem.isEnabled = it //crash here.
            }
        }
</code></pre>

<p>But it error when run:</p>

<p><strong>Logcat:</strong></p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: Animators may only be run on Looper threads<br>
  android.util.AndroidRuntimeException: Animators may only be run on <code>Looper</code> threads</p>
</blockquote>

<p>code crash is <code>enable/disable</code> button.</p>

<pre><code>btnAddItem.isEnabled = it
</code></pre>
",1559039,,5191371,,2018-12-10 07:07:23,2018-12-10 07:07:23,Android rxKotlin crash in subcribe combineLatest,<android><kotlin><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
53761781,1,53764341,0,2018-12-13 12:23:23,,0,140,"<p>I have a State(Enum) that contains (Good, Non-Critical, Critical) values</p>

<p>So requirement is :</p>

<ol>
<li>should trigger when state goes in non-critical state.</li>
<li>should trigger when state goes in critical state.</li>
<li>should trigger when state stays in critical state for 15 seconds.</li>
</ol>

<p>Input : </p>

<pre><code>publishSubject.onNext(""Good"")
publishSubject.onNext(""Critcal"") 
publishSubject.onNext(""Critcal"") 
publishSubject.onNext(""NonCritical"")  
publishSubject.onNext(""Critacal"") 
publishSubject.onNext(""Critical"") 
publishSubject.onNext(""Good"")
and so on...
</code></pre>

<p>See Code Structure for Reference:</p>

<pre><code>    var publishSubject = PublishSubject.create&lt;State&gt;()
    publishSubject.onNext(stateObject)


    publishSubject
            /* Business Logic Required Here ?? */
            .subscribeOn(Schedulers.computation())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                AppLogger.printLog(""Trigger Success --&gt; "")
            }
</code></pre>

<p>Please help,
Thanks in Advance,</p>
",4051419,,4051419,,2018-12-13 13:02:06,2018-12-13 14:49:18,How can I achieve this requirement using Rx Java,<android><rx-java><rx-java2><rx-android><rx-kotlin>,2,5,0,,,CC BY-SA 4.0
53812184,1,54114882,0,2018-12-17 09:22:51,,1,75,"<p>I have the following call to retrieve some data from server and update the UI according to response.</p>

<pre><code>    poiAPIService.getPoiDetails(poiId!!)
            .observeOn(AndroidSchedulers.mainThread())
            .doOnSubscribe { showProgressBar(true) }
            .doFinally { showProgressBar(false) }
            .subscribeOn(Schedulers.io()).subscribe(
                    { poiDetails -&gt;
                        bindPoiDetails(poiDetails)
                    },
                    {
                        (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                    })

}
</code></pre>

<p>It complains about showProgressBar that the Views are only accessable on thread that created them.
If I change the call like this, everything seems to be fine again.</p>

<pre><code>showProgressBar(true)
poiAPIService.getPoiDetails(poiId!!)
        .observeOn(AndroidSchedulers.mainThread())
        .subscribeOn(Schedulers.io()).subscribe(
                { poiDetails -&gt;
                    showProgressBar(false)
                    bindPoiDetails(poiDetails)
                },
                {
                    showProgressBar(false)
                    (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                })

}
</code></pre>
",859742,,0,,,2019-01-10 07:31:07,RxJava/RxKotlin complains about accessing views,<android><rx-java><reactive-programming><rx-kotlin>,2,0,0,,,CC BY-SA 4.0
53910822,1,0,0,2018-12-24 08:10:51,,0,87,"<p>I'v got this method from <a href=""https://developer.android.com/guide/topics/providers/document-provider#open-client"" rel=""nofollow noreferrer"">here</a> and it works well:</p>

<pre><code>@Throws(IOException::class)
fun readTextFromUri(ctx: Context, uri: Uri): String {
    val stringBuilder = StringBuilder()
    ctx.contentResolver.openInputStream(uri)?.use { inputStream -&gt;
        BufferedReader(InputStreamReader(inputStream)).use { reader -&gt;
            var line: String? = reader.readLine()
            while (line != null) {
                stringBuilder.append(""$line\n"")
                line = reader.readLine()
            }
        }
    }
    return stringBuilder.toString()
}
</code></pre>

<p>Then converted it to this method that returns each line using Observable:</p>

<pre><code>fun getUriAsStringObservable(ctx: Context, uri: Uri): Observable&lt;String&gt; {
    return Observable.create {
        try {
            ctx.contentResolver.openInputStream(uri)?.use { inputStream -&gt;
                BufferedReader(InputStreamReader(inputStream)).use { reader -&gt;
                    var line: String? = reader.readLine()
                    while (line != null) {
                        it.onNext(line)
                        line = reader.readLine()
                    }
                    it.onComplete()
                }
            }
        } catch (e: IOException) {
            it.onError(e)
        }
    }
}
</code></pre>

<p>But it didn't work as I expected, after subscribing to it nothing is printed:</p>

<pre><code>getUriAsStringObservable(this, uri)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext {
        print(""Next: $it"")
    }
    .doOnError {
        print(""Error: $it"")
    }
    .doOnComplete {
        print(""completed"")
    }
    .subscribe()
</code></pre>

<p>What is my mistake?</p>
",3678849,,3678849,,2018-12-26 10:25:44,2018-12-27 05:52:11,Custom RxJava Observable emits nothing on subscribe,<observable><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
54028855,1,54029853,0,2019-01-03 19:47:36,,1,933,"<p>I try to write a transformation function which is used with <code>compose()</code> in order to reduce boilerplate code. It's pretty simple like this:</p>

<pre><code>    fun &lt;R&gt; withSchedulers(): ObservableTransformer&lt;R, R&gt; {
        return ObservableTransformer {
            it.subscribeOn(Schedulers.io())
              .observeOn(AndroidSchedulers.mainThread())
        }
    }
</code></pre>

<p>So everytime I want to subscribe to anything on <code>ioThread</code> and listen the result on <code>mainThread</code>, it's just few lines of code:</p>

<pre><code>    Observable.just(1)
        .compose(MyUtilClass.withSchedulers())
        .subscribe()
</code></pre>

<p>But there isn't <code>Observable</code> only, but we also have <code>Single</code>, <code>Completable</code>, <code>Maybe</code> and <code>Flowable</code>. So every time I want to combine them with my <code>withSchedulers()</code> function, I have to transform it into the new type (which I don't expect). </p>

<p>For example,</p>

<pre><code>Completable.fromAction { 
        Log.d(""nhp"", ""hello world"")
    }//.compose(MyUtilClass.withSchedulers()) &lt;-- This is not compiled
            .toObservable() &lt;--- I have to transform it into Observable
            .compose(MyUtilClass.withSchedulers())
            .subscribe()
</code></pre>

<p>So my question is, is there any way to write the above function to use with <code>compose()</code> for any kind of <code>Observable</code> (<code>Single</code>, <code>Completable</code>,...) ? Or we have to write different functions which use <code>ObservableTransformer</code>, <code>SingleTransformer</code>, ....?</p>
",5460066,,0,,,2019-01-03 21:10:18,Customize ObservableTransformer with RxJav/RxKotlin2 when using with compose(),<java><android><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
54040468,1,0,0,2019-01-04 14:04:07,,1,107,"<p>I am trying to do some instrumented tests of a boilerplate code after migrating it to AndroidX. Note that before migration, all of them worked, but after, only unit tests work, the instrumented test crashes on Null Pointer exception, where it shouldnt.</p>

<p>Here is the errror: </p>

<pre><code>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'io.reactivex.Flowable io.reactivex.Flowable.subscribeOn(io.reactivex.Scheduler)' on a null object reference
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.data.interactor.FlowableUseCase.execute(FlowableUseCase.kt:26)
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.ui.browse.BrowseBufferoosViewModel.fetchBufferoos(BrowseBufferoosViewModel.kt:25)
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.ui.browse.BrowseActivity.onCreate(BrowseActivity.kt:40)
</code></pre>

<p>as you see, it's in the declaration of my ""UseCase"" in this case, get bufferoos. For reference, here is the class that fails:</p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/data/src/main/java/org/buffer/android/boilerplate/data/browse/interactor/GetBufferoos.kt"" rel=""nofollow noreferrer"">GetBufferoos</a></p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/data/src/main/java/org/buffer/android/boilerplate/data/interactor/FlowableUseCase.kt"" rel=""nofollow noreferrer"">Flowable Use case</a></p>

<p>Here is the test that fails </p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/mobile-ui/src/androidTest/java/org/buffer/android/boilerplate/ui/browse/BrowseActivityTest.kt"" rel=""nofollow noreferrer"">ActivityTest</a></p>

<p>Here is modules.kt for koin</p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/mobile-ui/src/main/java/org/buffer/android/boilerplate/ui/di/modules.kt"" rel=""nofollow noreferrer"">Modules</a></p>
",4806502,,4806502,,2019-01-04 15:05:45,2019-01-04 15:05:45,Koin testing on Androidx with Activity,<android><kotlin><rx-java><rx-kotlin><koin>,0,7,0,,,CC BY-SA 4.0
54060856,1,0,0,2019-01-06 11:01:10,,0,144,"<p>I've wanted to try RxJava with kotlin to make coding easier, so I've produced this:</p>

<pre><code>fun postAnswers() {
    disposable = getToken.execute().subscribe({ token -&gt;
        questions.forEach { form -&gt;
            val answers = form.answers?.filter { it.isChecked }?.map { it.answer_id }
            disposable = postAnswer.execute(token?.token!!, SavedAnswer(form.form_id, answers)).subscribe({
                //Post live data about success
            }, {
                //Post live data failure
            })
        }
    }, {
        //Post live data failure
    })
}
</code></pre>

<p>But I have an impression it can be done better, but I do not know how. Basically what I am trying to achieve is getting a Token object from database, that returns Flowable Token? and then use it to call postAnswer in a for cycle, because I need to post each answer separately (That's how the API is designed). After that, postAnswer only returns Completable, but I need to let the Activity know (this is from ViewModel code) how many answers were posted</p>

<p>I've thought about using .flatMap or .concat functions, but I am not sure if it will be helpful in this case. Also, do I need to assign getToken.execute() to disposable?</p>

<p>Thank you for your answers</p>

<p>EDIT:</p>

<p>Here is my questions list:</p>

<pre><code>private var questions: List&lt;Form&gt; = emptyList()
</code></pre>

<p>It gets filled by viewModel functions</p>
",4806502,,4806502,,2019-01-06 12:53:22,2019-01-24 23:09:32,Simplify the statement using rxkotlin,<kotlin><retrofit><rx-java><android-room><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
54148150,1,0,0,2019-01-11 14:08:06,,0,259,"<p>onNext method of publishSubject is calling continuously(in uneven time, approximately in 1 milliseconds)
And requirement is to emit these item at every 1 second and data should not loss means should emit each item.</p>

<pre><code>    publishSubject.onNext(""Data1"");
    publishSubject.onNext(""Data2"");
    publishSubject.onNext(""Data3"");
    publishSubject.onNext(""Data4"");
    publishSubject.onNext(""Data5"");
    publishSubject.onNext(""Data6"");
    publishSubject.onNext(""Data7"");
</code></pre>

<p>and so on...
See Code Structure for Reference:</p>

<pre><code>var publishSubject = PublishSubject.create&lt;String&gt;()
publishSubject.onNext(stateObject) // Executing at every milliseconds...


publishSubject
        /* Business Logic Required Here ?? */
        .subscribeOn(Schedulers.computation())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe {
            // Should execute at every 1 second
        }
</code></pre>

<p>Please help, Thanks in Advance,</p>
",4051419,,0,,,2019-01-25 09:30:22,How can we buffer items in each milliseconds and stream each item at constant time interval,<android><kotlin><rx-java><rx-java2><rx-kotlin2>,2,7,0,,,CC BY-SA 4.0
54225878,1,0,0,2019-01-16 21:45:39,,0,422,"<p>I have two different Observables which behaves as</p>

<p>Observable one behavior -> This will get created and one DisposableObserver will get subscribed to it and reacts to items emitted by the Observable One. This will be running continuously until app is closed.</p>

<p>Observable two behavior -> This will get created and get subscribed to a different Observer in a different time and after subscription this should emit values based on values emitted by Observable one after Observable two is subscribed. Once job is done Observable two subscription will be disposed but Observable one should continue.</p>

<p>How can I make second Observable emit values based on Observable one emitted values and dispose it after complete ?</p>
",3416215,,3416215,,2019-01-16 23:55:51,2019-01-17 14:03:55,One Observable should emit items based on another Observable emitted items and both Observables are not connected,<rx-java><rx-java2><rx-kotlin2>,2,0,0,,,CC BY-SA 4.0
54379123,1,0,0,2019-01-26 14:04:51,,0,1070,"<p>I've inherited this codebase which uses RxJava2 and kotlin with a rather peculiar Result pattern for API calls. i.e. all API calls return Singles with a Result object (which is a sealed class of Success and Error types as shown below) i.e.</p>

<pre><code>sealed class Result&lt;T, E&gt; {
    data class Success&lt;T, E&gt;(
            val data: T
    ): Result&lt;T, E&gt;()

    data class Error&lt;T, E&gt;(
            val error: E
    ): Result&lt;T, E&gt;()
}
</code></pre>

<p>Now I'm trying to chain together a bunch of API calls of these but need to terminate the chain on the first Result.Error in it and continue if not.</p>

<p>The only way I can think of is to zip all of the Singles and then have a zipper function that checks the type of each parameter and returns a <code>Result.Error()</code> with the first error it encounters. i.e. something like,</p>

<pre><code>Singles.zip(
    repo1.makeCall1(arg),
    repo1.makeCall2(arg2),
    repo2.makeCall1(arg3)
) { result1, result2, result3 -&gt;
    val data1 = when (result1) {
        is Result.Error -&gt; return@zip Result.Error(result1.error)
        is Result.Success -&gt; result1.data
    }
    val data2 = when (result2) {
        is Result.Error -&gt; return@zip Result.Error(result2.error)
        is Result.Success -&gt; result2.data
    }
    val data3 = when (result3) {
        is Result.Error -&gt; return@zip Result.Error(result3.error)
        is Result.Success -&gt; result3.data
    }

    return@zip Result.Success(MergedData(data1, data2, data3))
}
</code></pre>

<p>which works but looks really weird (and feels like a code smell with this huge ass zipper method). Also does not allow me to chain anything more after the last method (that checks if the Result is a Success / Error).</p>

<p>I feel it would be a lot more readable to be able to chain these calls and terminate on the first error but I don't know enough Rx to do this. Is there an operator or an approach that could help make this better?</p>
",2104070,,2413303,,2019-01-26 14:25:59,2019-01-29 20:27:52,How to break RxJava chain on error Result?,<android><rx-java><reactive-programming><rx-java2><rx-kotlin>,3,0,0,,,CC BY-SA 4.0
54480893,1,54487008,0,2019-02-01 13:50:57,,0,202,"<p>I am writing some repository logic for android application, I have this logic for retrieving data from database and updating the database with data from api immediately after that.</p>

<pre><code>   fun fetchData(): Single&lt;Data&gt; {
    return Single.concatArrayEager(
            fetchFromDb(),
            fetchFromApi())
            .firstOrError()
}
</code></pre>

<p>By the way - database is Room and api is Retrofit. Now what happens is that room emits almost instantly, but for some reason api request is not fired - the second <code>Single</code> doesn't start. </p>

<p>I read the documentation on the eager operator and I am not sure if this is correct behavior. I even tried to delay the database fetch, by like 20 miliseconds - which resulted in that second single being actually fired</p>
",6855603,,0,,,2019-02-01 20:52:51,Single concatArrayEager doesnt subscribe to all sources,<android><rx-java><rx-kotlin>,1,6,0,,,CC BY-SA 4.0
54782735,1,54782844,0,2019-02-20 09:19:39,,2,142,"<p>I'm using a custom repository to get observables for data in a room database, e.g:</p>

<pre><code>fun getUsers(): Observable&lt;List&lt;User&gt;&gt; = userDao.getAll()
        .toObservable()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .doOnError { Logger.error(tag, ""error getting users: ${it.message}"") }
        .doOnNext { Logger.debug(tag, ""fetched ${it.size} users"") }
</code></pre>

<p>In my UI (Fragment) I start the subscription in <code>onResume</code>:</p>

<pre><code>override fun onResume() {
        super.onResume()
        userObserver = repository.getUsers()
            .subscribe {
                // handle user
            }
    }
</code></pre>

<p>And in the <code>onPause</code> I have:</p>

<pre><code>override fun onPause() {
        super.onPause()
        userObserver.dispose()
    }
</code></pre>

<p>Since each time <code>repository.getUsers()</code> is called, I'm creating a new Observable-object. Could this lead to memory leaks and should I rather try to reuse the observer instead of disposing and recreating it?</p>
",7855177,,7855177,,2019-02-20 09:57:42,2019-02-20 09:57:42,Reusing or recreating an observer?,<android><kotlin><android-room><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
55139062,1,55163021,0,2019-03-13 10:01:37,,0,143,"<p>How to implement a <strong>Observable.concatEagerDelayError</strong> or an equivalent in RxJava2/RxKotlin2 ?</p>

<p>There is :</p>

<ul>
<li>Observable.concatEager</li>
<li>Observable.concatDelayError</li>
</ul>

<p>But not :</p>

<ul>
<li>Observable.concatEagerDelayError</li>
</ul>

<p>What i have :</p>

<pre><code>fun getAll(): Observable&lt;List&lt;User&gt;&gt; = Observable.concatArrayDelayError(
    // from db
    userDAO
        .selectAll()
        .subscribeOn(ioScheduler),
    // from api
    userAPI
        .getAll()
        .doOnNext { lstUser -&gt; Completable.concatArray(
            userDAO.deleteAll().subscribeOn(ioScheduler),
            userDAO.save(lstUser).subscribeOn(ioScheduler)
        ) }
        .subscribeOn(ioScheduler)
)
</code></pre>

<p>I want same behaviour but eagerly for selectAll() and getAll() because there is no reason to wait from db to launch network call.</p>
",4911053,,4911053,,2019-03-14 13:35:18,2019-03-14 13:41:31,How to concatEagerDelayError in RxJava2,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
55174860,1,55176706,0,2019-03-15 02:48:59,,7,9939,"<p>I'm confusing about use case for doOnSuccess in rxJava.<br>
Let's see the code:  </p>

<p>Case 1:  </p>

<pre><code>networkApi.callSomething()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())               
    .doOnSuccess(__ -&gt; showLog(SUCCESS))
    .doOnError(__ -&gt; showLog(ERROR))
    .subscribeBy(
             onSuccess = {//Do something}, 
             onError = {//Show log here}
          )
</code></pre>

<p>Case 2:</p>

<pre><code>networkApi.callSomething()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())               
    .subscribeBy(
             onSuccess = {
               //Do something
               showLog(SUCCESS)
             }, 
             onError = {showLog(ERROR)}
          )
</code></pre>

<p>As normal, I think case 2 is fine.<br>
I also have referred some source code in github and I saw some people do like case 1.<br>
I try to ask myself what is the use case for <code>doOnSuccess</code> here ?  </p>

<p>Is there any use case that we need apply <strong><code>doOnSuccess()</code></strong> operator ?</p>
",951917,,0,,,2019-03-15 06:21:37,What is the use case for doOnSuccess vs onSuccess in rxJava,<android><retrofit><rx-java><rx-kotlin>,2,1,0,,,CC BY-SA 4.0
55244285,1,55244679,0,2019-03-19 15:13:18,,0,354,"<p>I'm using the <code>io.reactivex.rxkotlin</code> extension function: </p>

<pre><code>fun &lt;T : Any&gt; Observable&lt;T&gt;.subscribeBy(
        onError: (Throwable) -&gt; Unit = onErrorStub,
        onComplete: () -&gt; Unit = onCompleteStub,
        onNext: (T) -&gt; Unit = onNextStub
        ): Disposable
</code></pre>

<p>And when I use this extension there is a difference if I choose to send a parameter or if I use lambda.
For example</p>

<p><strong>first implementation:</strong></p>

<pre><code>myObservable.subscribeBy { str -&gt;
    // onNext
}
</code></pre>

<p><strong>Second implementation:</strong></p>

<pre><code>myObservable.subscribeBy({ throwable -&gt;
    // onError
})
</code></pre>

<ul>
<li>in the <strong>first implementation</strong> the function is the <code>onNext</code></li>
<li>and in the <strong>second implementation</strong> the function is the <code>onError</code></li>
</ul>

<p>And I'm not sure why.</p>
",4409815,,0,,,2019-03-19 15:34:01,Kotlin pass function as a parameter vs lambda implementation,<kotlin><kotlin-extension><rx-kotlin>,2,0,0,,,CC BY-SA 4.0
55253503,1,55253850,0,2019-03-20 04:14:30,,0,43,"<p>i am trying the upload the image through rxkotlin, my problem is when i close my screen in my application, the uploading process gets terminated because am adding that subscription to my disposal, so when my screen closes or destroys i will be disposing. because of this dispose my job getting terminated, since anyway i need to dispose else it my leads to the memory leak                                                               </p>

<pre><code>fun uploadImage(imagePath : String){
   uploadToServer(imagePath)
        .subscribe()
        .addTo(disposal)   
}

override onCleared(){
   disposal.dispose()
}
</code></pre>

<p>So in this way i doing this, is there is any other way to continue this work, even after the screen destroys or cleared without memory leak ?</p>
",9344496,,0,,,2019-03-20 05:01:53,RxKotlin - Process gets terminated when dispose is called,<android><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
55262210,1,0,0,2019-03-20 13:44:41,,3,803,"<p>For unit testing in kotlin android, I have been using the mocking framework MockK. Have used RxKotlin. I have used Completable observable to notify the ViewModel about the status of API. Based on the completable, the status will be updated to success or failure in ViewModel. My question is how to mock the completable observable of RxKotlin using MockK and check the status in the unit test function based on the mocked completable.</p>

<p><strong>Snippet</strong></p>

<pre><code>val testObserver = TestObserver&lt;T&gt;()

every {
 mocked api call
} return completable

testobserver.assertComplete()
</code></pre>

<p><strong>unknown</strong></p>

<p>How to subscribe the testobserver with the completable return mock function call</p>
",9584758,,4775478,,2019-09-20 19:19:41,2019-09-20 19:19:41,How to mock completable of RxKotlin using MockK(Mock Framework),<android><unit-testing><rx-java2><mockk><rx-kotlin2>,0,2,0,,,CC BY-SA 4.0
55374888,1,55441869,0,2019-03-27 10:23:52,,0,147,"<h2>First, some background (maybe there is a better way of doing this):</h2>

<p>We have a module that emits incoming Bluetooth messages on a specific Observable. We then process this messages, and finally subscribe at the end to send messages forward. This processing could change at some time, which for most of the processing means recreating the intermediate Observables, and all observables that depend on it (as they would be processing invalid data now). </p>

<p>We would like to change it so recreating some part of the processing does not necessitate recreating everything that depends on it, mostly so we don't have to remember at all times what depended on what, and also so that operators with internal state (like buffer, scan or debounce) don't lose this internal state.</p>

<h2>The promising solution:</h2>

<p>By using a switchOnNext operator, we would solve this problem. Whenever an intermediate observable is recreated, we just add that to the origin of the switchOnNext and whoever subscribed to the output of the switchOnNext would instantly get the new results.</p>

<h2>The problem:</h2>

<p>If the processing after the switchOnNext has to change, it will stop getting results until the previous observable changes. This means that we have the oposite problem now. whenever some part changes, we have to recreate everything that it depends on, recursively. This is slightly better (much easier to keep track on what something depends on than everything that depends on it), but observables still lose the internal state as they have to be recreated.</p>

<p>This behavior seems to be against what the documentation says should happen, but it does not explicitly says one way or another.</p>

<h2>Example code:</h2>

<p>This code demonstrates the problem. </p>

<pre><code>import io.reactivex.Observable
import io.reactivex.subjects.PublishSubject

fun main() {
    //Observable of observables
    val publishSubject: PublishSubject&lt;Observable&lt;Int&gt;&gt; = PublishSubject.create()
    //Observable to subscribe to get the most recent values
    val observable: Observable&lt;Int&gt; = Observable.switchOnNext(publishSubject)

    observable.subscribe { println(""1: $it"") }
    //Now 1 is subscribed

    val obsAux1 = PublishSubject.create&lt;Int&gt;()

    observable.subscribe { println(""2: $it"") }
    //Now 1 and 2 are subscribed

    publishSubject.onNext(obsAux1)

    observable.subscribe { println(""3: $it"") }
    //Now 1, 2 and 3 are subscribed

    //Should print out from subscriptions 1, 2 and 3, but only 1 and 2 printed
    obsAux1.onNext(1)

    val obsAux2 = PublishSubject.create&lt;Int&gt;()

    publishSubject.onNext(obsAux2)

    observable.subscribe { println(""4: $it"") }
    //Now 1, 2, 3 and 4 are subscribed

    //Should not print anything
    obsAux1.onNext(2)
    //Should print out from subscriptions 1, 2, 3 and 4, but only 1, 2 and 3 printed
    obsAux2.onNext(3)
} 
</code></pre>

<p>Output of this code:</p>

<pre><code>1: 1
2: 1
1: 3
2: 3
3: 3
</code></pre>

<p>Expected output:</p>

<pre><code>1: 1
2: 1
3: 1 &lt;--- This is missing
1: 3
2: 3
3: 3
4: 3 &lt;--- This is missing
</code></pre>

<p>The first time obsAux1 emits, all three subscriptions should print, but only the ones before it was added to publishSubject print out. </p>

<p>The second time obsAux1 emits, nothing should print as obsAux2 has been inserted already. This works as expected</p>

<p>The first time obsAux2 emits, all four subscriptions should print. The third subscription prints as expected, which should that the subscription worked fine. But the fourth subscription is not printing anything, as it was added after obsAux2 was inserted to publishSubject.</p>
",3879384,,3879384,,2019-03-27 11:42:20,2019-03-31 14:22:06,switchOnNext operator does not emit for subscriptions after last inserted observable,<kotlin><rx-kotlin2>,2,4,0,,,CC BY-SA 4.0
55401079,1,55401736,0,2019-03-28 15:13:54,,0,156,"<p>I am investigating the development of a <code>Kotlin</code> DSL for <code>RxKotlin</code> commands</p>

<p>I have something working however I would to improve my approach to setting Rx <code>Action</code>(s) and <code>Consumer</code>(s).</p>

<p>The Code I have currently resembles this:-</p>

<pre><code>@SequenceDsl
class ExperimentalBuilder {

    companion object {
        private val emptyAction = Action { }
        private val emptyConsumer: Consumer&lt;in Throwable&gt; = Consumer { }
    }


    var uuid: String = """"
    var onError: Consumer&lt;in Throwable&gt; = emptyConsumer
    var onComplete: Action = emptyAction
    var doFinally: Action = emptyAction
    var doLoginRefreshFail: Action = emptyAction

    fun build(): Experimental = Experimental(uuid, onError, onComplete, doFinally, doLoginRefreshFail)

}

import io.reactivex.Single
import io.reactivex.functions.Action
import io.reactivex.functions.Consumer
import io.reactivex.schedulers.Schedulers

data class Experimental(
    val uuid: String,
    val onError: Consumer&lt;in Throwable&gt;,
    val onComplete: Action,
    val doFinally: Action,
    val doLoginRefreshFail: Action
) : Morpheme() {

    override fun execute() {

        Single.just("""")
            .subscribeOn(Schedulers.single())
            .ignoreElement()
            .doOnSubscribe {disposable -&gt; COMPOSITE_DISPOSABLE.add(disposable) }
            .doOnComplete(onComplete)
            .doOnError(onError)
            .doFinally(doFinally)
            .doAfterTerminate(doAfterTerminate())
            .subscribe()
    }
}
</code></pre>

<p>and I use this code as follows:-</p>

<pre><code>  val experimental = Dsl().experimental {
            uuid = ""09876""

            onComplete = Action {
                Log.d(""EXPERIMENT"", ""ON COMPLETE"")
                Log.d(""EXPERIMENT"", ""ON COMPLETE"")
            }

            onError = Consumer {
                    throwable -&gt; Log.e(""EXPERIMENT"", ""ON ERROR"", throwable)
            }

            doFinally =  Action {
                Log.d(""EXPERIMENT"", ""DO FINALLY"")
            }

            doLoginRefreshFail =  Action {
                Log.d(""EXPERIMENT"", ""DO LOGIN REFRESH FAIL"")
            }
        }

        experimental.execute()

        Log.d(""DSL"", ""what $experimental"")
</code></pre>

<p>The code I would like to ""improve"" is this when setting either an <code>Action</code> or <code>Consumer</code></p>

<pre><code>  onComplete = Action {
    Log.d(""EXPERIMENT"", ""ON COMPLETE"")
    Log.d(""EXPERIMENT"", ""ON COMPLETE"")
  }

  onError = Consumer {
    throwable -&gt; Log.e(""EXPERIMENT"", ""ON ERROR"", throwable)
  }
</code></pre>

<p>Is this the only method I can use to set the ""onCompile"" Action?</p>

<p>e.g. Do I have to mention ""Action {}"" or is there a ""short-hand"" version I can use to achieve the same result?</p>
",423199,,0,,,2019-03-28 15:44:31,How to set Rx Action Consumer in Kotlin DSL,<kotlin><dsl><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
55411838,1,55412118,0,2019-03-29 06:45:11,,0,319,"<p>i have a list of some strings, where i need to iterate the list in batch.<br>
Example :</p>

<pre><code>val list = [""a"",""b"",""c"",""d"",""e"",""f""]
Observable.fromIteratable(list)
          .map{
          //here i need to get 4 items at a time
          //like in first iteration i need to get [""a"",""b"",""c"",""d""]
          //in second iteration i need to get [""e"",""f""]
        }
</code></pre>

<p>Is there is any option to do perform this ?</p>
",9344496,,0,,,2019-03-29 07:19:26,Rxjava - Iterate the list with batch,<android><rx-java><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
55437513,1,0,0,2019-03-31 03:02:06,,0,82,"<p>I am using the RXKotlin combineLatest and I have a multiple source. but I am calling this like</p>

<pre><code>Observables.combineLatest(source1, source2)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
        },
        {

        }
    )
</code></pre>

<p>and</p>

<pre><code>Observables.combineLatest(source3, source4)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
        },
        {

        }
    )
</code></pre>

<p>now I just want to ask on how to use the combineLatest to my sources only once.</p>

<p>like this.</p>

<pre><code>Observables.combineLatest(source1, source2, source3, source4)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
            val third = it.third
            val fourth = it.fourth
            //...
        },
        {

        }
    )
</code></pre>

<p>I am always using this combineLatest but only with three parameters and I really don't know how or what should I do when I add more parameters to it.</p>

<p>Any help is appreciated, Thank you.</p>
",5693082,,5693082,,2019-03-31 04:52:19,2019-03-31 04:52:19,How to use combineLatest with multiple sources,<android><kotlin><rx-kotlin>,0,2,0,2019-03-31 04:28:54,,CC BY-SA 4.0
55529892,1,55572460,0,2019-04-05 07:02:44,,0,98,"<p>Basically, I have two <code>Flowables F</code> and <code>G</code> and I want to use <code>combineLatest</code> on them, but I want the combined <code>Flowable</code> to already complete if <code>F</code> completes (even if <code>G</code> is still running).</p>

<p>Here is an example of what I what to achieve with an ugly solution:</p>

<pre><code>fun combineFandGbutTerminateIfFTerminates(F: Flowable&lt;Int&gt;, G: Flowable&lt;Int&gt;) : Flowable&lt;Pair&lt;Int, Int&gt;&gt; {
  val _F = F.share()
  val _G = G.takeUntil(_F.ignoreElements().toFlowable&lt;Nothing&gt;())
  val FandG = Flowables.combineLatest(_F, _G)
  return FandG
}
</code></pre>

<p>We can extract that into and extension function:</p>

<pre><code>fun&lt;T&gt; Flowable&lt;T&gt;.completeWith(other: Flowable&lt;*&gt;) : Flowable&lt;T&gt; {
    return takeUntil(other.ignoreElements().toFlowable&lt;Nothing&gt;())
}
</code></pre>

<p>Is there a nicer way to express that?</p>
",3612643,,3612643,,2019-04-05 07:26:04,2019-04-08 15:12:31,RxJava/RxKotlin: combineLatest that already completes if one source completes (not all),<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
55557230,1,55562345,0,2019-04-07 08:54:57,,2,326,"<p>I have a <code>Flowable&lt;T&gt;</code> and errors that are subtype of <code>IgnoreThisError</code> I want to ignore (resulting in graceful completion), all other errors should be propagated downstream.</p>

<p>Kotlin example:</p>

<pre><code>val f : Flowable&lt;T&gt; = ...
val g = f.onErrorComplete { it is IgnoreThisError }
</code></pre>

<p>This function onErrorComplete is what I need and does not exist...</p>
",3612643,,3612643,,2019-04-07 14:29:21,2019-04-08 15:29:00,RxJava: Ignore some errors in a Flowable,<kotlin><rx-java2><rx-kotlin2>,2,2,0,,,CC BY-SA 4.0
55606278,1,55611376,0,2019-04-10 06:44:33,,0,58,"<p>I have a chain where I do some blocking IO calls (e.g. HTTP-call). I want the blocking call to consume a value, proceed without interrupting, but drop everything that is piling up meanwhile, and then consume the next value in the same manner.</p>

<p>Consider the following example:</p>

<pre><code>fun main() {
  Flowable.interval(100, TimeUnit.MILLISECONDS).onBackpressureLatest().map {
    Thread.sleep(1000)
    it
  }.blockingForEach { println(it) }
}
</code></pre>

<p>From a naive point of view, I would it expect to print something like <code>0, 10, 20, ...</code>, but it prints <code>0, 1, 2, ...</code>.</p>

<p>What am I doing wrong?</p>

<p>EDIT:</p>

<p>I thought about naively adding <code>debounce</code> to eat up the incoming stream:</p>

<pre><code>fun main() {
  Flowable.interval(100, TimeUnit.MILLISECONDS)
    .debounce(0, TimeUnit.MILLISECONDS)
    .map {
      Thread.sleep(1000)
      it
    }
    .blockingForEach { println(it) }
}
</code></pre>

<p>But, now I get a <code>java.lang.InterruptedException: sleep interrupted</code>.</p>

<p>EDIT:</p>

<p>What seems to work is the following:</p>

<pre><code>fun main() {
  Flowable.interval(100, TimeUnit.MILLISECONDS)
    .throttleLast(0, TimeUnit.MILLISECONDS)
    .map {
      Thread.sleep(1000)
      it
    }
    .blockingForEach { println(it) }
}
</code></pre>

<p>The output is as expected <code>0, 10, 20, ...</code>!!</p>

<p>Is that the correct way?</p>

<p>I noted that <code>throttleLast</code> will switch to the Computation-Scheduler. Is there a way to go back to the original scheduler?</p>

<p>EDIT:</p>

<p>I also get an occasional <code>java.lang.InterruptedException: sleep interrupted</code> with that variant.</p>
",3612643,,3612643,,2019-04-10 09:37:36,2019-04-10 11:25:08,Using `onBackpressureLatest` to drop intermediate messages in blocking Flowable,<rx-java2><rx-kotlin2>,1,4,0,,,CC BY-SA 4.0
55606607,1,0,0,2019-04-10 07:04:51,,0,27,"<p>Consider the following example:</p>

<pre><code>fun main() {
  Flowable.interval(1, TimeUnit.MILLISECONDS).map {
    Thread.sleep(1000)
    it
  }.blockingForEach { println(it) }
}
</code></pre>

<p>Do to missing backpressure, I would expect to get a <code>MissingBackpressureException</code> as written in the docs of <code>Flowable.interval</code>.</p>

<p>What am I getting wrong?</p>
",3612643,,0,,,2019-04-10 07:04:51,No `MissingBackpressureException` exception with `Flowable.interval` and blocking chain,<rx-java2><rx-kotlin2>,0,5,0,,,CC BY-SA 4.0
55645167,1,55645276,0,2019-04-12 05:43:20,,7,2300,"<p>What is the difference between <code>rxjava2</code> dependency and <code>rxkotlin</code> dependency.
 If I'm using <code>rxkotlin</code> dependency, should i need to add <code>rxjava2</code> dependency along with that.</p>

<pre><code>implementation 'io.reactivex.rxjava2:rxkotlin:x.y.z'
// do i need to add the below dependencies also?
implementation 'io.reactivex.rxjava2:rxjava:2.2.4'
implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'
</code></pre>
",5351055,,0,,,2020-08-13 12:17:54,What is the difference between rxjava2 and rxkotlin?,<android><kotlin><rx-java2><rx-kotlin>,4,0,0,,,CC BY-SA 4.0
55727396,1,55737305,0,2019-04-17 12:18:07,,0,185,"<p>After struggling for a few days now, on what seems to be a simple task, I come to you guys:)</p>

<p>Idea is simple. I have two streams/observables, 'left' and 'right'.
I want items from 'right' to buffer/collect/aggregate to 'current' item in 'left'.<br>
Thus, each item in 'left' defines a new 'window', while all 'right' items will bind to that window, until a new 'left' item is emitted. So, to visualize:</p>

<p><strong>Task:</strong><br>
'left' &nbsp;&nbsp;&nbsp; : |- A - - - - - B - - C - - - -|<br>
'right' &nbsp; :       |- 1 - 2 - 3 -4 - 5 - 6 - - -|<br>
'result' : |- - - - - - - -x - - -y - - - -z| &nbsp;&nbsp;( <code>Pair&lt;Left, List&lt;Right&gt;&gt;</code>)<br>
<em>Where: <strong>A,1</strong> ; <strong>B,4</strong> (so x) ; <strong>C</strong> (so y) are emitted on the same time</em><br>
<em>So: &nbsp; &nbsp; &nbsp; x = Pair(A, [1,2,3]), &nbsp;&nbsp;y = Pair(B, [4, 5])</em><br>
<em>And: &nbsp; &nbsp;'right' &amp; 'result' complete/terminate when 'left' does</em><br>
<em>So: &nbsp; &nbsp; &nbsp;z = Pair(C, [6]) - emitted as a result of 'left' completing</em>  </p>

<p><strong>----</strong><br>
<strong>EDIT 2 - FINAL SOLUTION!</strong><br>
In order to aggregate 'right' items with the next 'left' and not the previous one, I changed the code to this much shorter/simpler one:  </p>

<pre><code>fun &lt;L, R&gt; Observable&lt;L&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;L, List&lt;R&gt;&gt;&gt; {
    return this.share().run {
        zipWith(right.buffer(this), BiFunction { left, rightList -&gt;
            Pair(left, rightList)
        })
    }
}  
</code></pre>

<p><strong>EDIT 1 - initial solution!</strong><br>
Taken from @Mark's (accepted) answer below, here's what I came up with.<br>
It is separated into smaller methods because I also do <code>multiRightGroupJoin()</code> to join in as many (right) streams as I want.  </p>

<pre><code>fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {
    return this.share().let { thisObservable -&gt;    //use 'share' to avoid multi-subscription complications, e.g. multi calls to **preceding** doOnComplete
        thisObservable.flatMapSingle { t -&gt;        //treat each 'left' as a Single
            bufferRightOnSingleLeft(thisObservable, t, right)
        }
    }
}
</code></pre>

<p>Where:  </p>

<pre><code>private fun &lt;T, R&gt; bufferRightOnSingleLeft(left: Observable&lt;*&gt;, leftSingleItem: T, right: Observable&lt;R&gt;)
    : Single&lt;Pair&lt;T, MutableList&lt;R&gt;&gt;&gt; {

    return right.buffer(left)                              //buffer 'right' until 'left' onNext() (for each 'left' Single) 
        .map { Pair(leftSingleItem, it) }
        .first(Pair(leftSingleItem, emptyList()))   //should be only 1 (list). THINK firstOrError
}  
</code></pre>

<p><strong>----</strong>  </p>

<p><strong>What I got so far</strong><br>
After much reading and the understanding that somehow there's no implementation for this out of the box, I've decided to use <code>groupJoin</code>, mostly using <a href=""https://leecampbell.com/2011/03/14/rx-part-9-join-window-buffer-and-group-join/"" rel=""nofollow noreferrer"">this link</a>, like so: <em>(many problems and places to improve here, don't use this code)</em>  </p>

<pre><code>private fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {

var thisCompleted = false //THINK is it possible to make the groupJoin complete on the left(this)'s onComplete automatically?
val thisObservable = this.doOnComplete { thisCompleted = true }
        .share() //avoid weird side-effects of multiple onSubscribe calls

//join/attach 'right/other' stream to windows (buffers), starting and ending on each 'this/left' onNext
return thisObservable.groupJoin(

    //bind 'right/other' stream to 'this/left'
    right.takeUntil { thisCompleted }//have an onComplete rule THINK add share() at the end?

    //define when windows start/end ('this/left' onNext opens new window and closes prev)
    , Function&lt;T, ObservableSource&lt;T&gt;&gt; { thisObservable }

    //define 'right/other' stream to have no windows/intervals/aggregations by itself
    // -&gt; immediately bind each emitted item to a 'current' window(T) above
    , Function&lt;R, ObservableSource&lt;R&gt;&gt; { Observable.empty() }

    //collect the whole 'right' stream in 'current' ('left') window
    , BiFunction&lt;T, Observable&lt;R&gt;, Single&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt;&gt; { t, rObs -&gt;
        rObs.collect({ mutableListOf&lt;R&gt;() }) { acc, value -&gt;
            acc.add(value)
        }.map { Pair(t, it.toList()) }

    }).mergeAllSingles()
}  
</code></pre>

<p>I also used similar usage to create a <code>timedBuffer()</code> - same as <code>buffer(timeout)</code> but with a timestamp on each buffer(<code>List</code>) to know when it started. Basically by running the same code on an <code>Observable.interval(timeout)</code> (as the 'left')</p>

<p><strong>Problems / Questions (from the easiest to the hardest)</strong>  </p>

<ol>
<li>Is it the best way of doing something like that? Isn't it an overkill?</li>
<li>Is there a better way (must be) for completing the 'result' (and 'right') when 'left' is completed? Without this ugly boolean logic?</li>
<li><p>This usage seem to mess up the order of the rx. See code and print below:  </p>

<pre><code>leftObservable
.doOnComplete {
    log(""doOnComplete - before join"")
 }
.doOnComplete {
    log(""doOnComplete 2 - before join"")
 }
.rightGroupJoin(rightObservable)
.doOnComplete {
    log(""doOnComplete - after join"")
 }
</code></pre></li>
</ol>

<p>Prints (sometimes! Looks like a race condition) the following:<br>
<code>doOnComplete - before join</code><br>
<code>doOnComplete - after join</code><br>
<code>doOnComplete 2 - before join</code>  </p>

<ol start=""4"">
<li><p>On first run of the above code, <code>doOnComplete - after join</code> is not called, on the second time it's called <strong>twice</strong>. Third time is like the first, forth is like the second, etc...<br>
Both 3,4 are ran using this code. Probably has something to do with the subscribe {} usage? Note that I don't hold the disposable.
This stream finishes because I GC the 'left' observable</p>

<pre><code>leftObservable.subscribeOn().observeOn()
.doOnComplete{log...}
.rightGroupJoin()
.doOnComplete{log...}
.subscribe {}  
</code></pre></li>
</ol>

<p>Note1: adding <code>.takeUntil { thisCompleted }</code> after <code>mergeAllSingles()</code> seems to fix #4.   </p>

<p>Note2: After using this method to join multiple streams and applying 'Note1', it's apparent that the onComplete (before the groupJoin() call !!!) will be called as many times as there are 'right' Observables, probably meaning that the cause is the <code>right.takeUntil { thisCompleted }</code>, is it really important to close the 'right' stream?  </p>

<p>Note3: concerning Note1, it seems very much related to takeUntil vs. takeWhile. Using takeWhile lowers the doOnComplete calls, and it's somehow logical. Still trying to figure it out better.</p>

<ol start=""5"">
<li>Can you think of a multiGroupJoin, or in our case, multiRightGroupJoin, other than running zip on groupJoin * rightObservablesCount?</li>
</ol>

<p>Please ask anything you like. I know for a fact the my usage of the subscribe/disposable and the manual onComplete are not the way, I'm just not sure enough what is..</p>
",2774781,,2774781,,2019-04-24 17:39:03,2019-04-24 18:01:18,Rx (RxKotlin) - rightGroupJoin using groupJoin - merge / combine two observables of different types,<rxjs><rx-java><reactive-programming><rx-kotlin><rx-kotlin2>,2,0,1,,,CC BY-SA 4.0
55874840,1,0,0,2019-04-26 20:56:34,,4,2696,"<p>Why do I get different results when unit testing my ViewModel?</p>

<p>I got two tests. When I launch each test individually that's ok but when I launch all tests in a row I got an error.
It's a ViewModel that change state each time I got a return from an 
API. I expect to get <code>android.arch.lifecycle.Observer.onChanged</code> called two times but it's just called once for the second test.
Unit test works fine when I replace <code>verify(view, times(2)).onChanged(arg.capture())</code> with <code>verify(view, atLeastOnce()).onChanged(arg.capture())</code> at the first test.</p>

<p>UserViewModel :</p>

<pre><code>class UserViewModel(
        private val leApi: LeApi
): ViewModel() {
    private val _states = MutableLiveData&lt;ViewModelState&gt;()
    val states: LiveData&lt;ViewModelState&gt;
        get() = _states

    fun getCurrentUser() {
        _states.value = LoadingState
        leApi.getCurrentUser()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        { user -&gt; _states.value = UserConnected(user) },
                        { t -&gt; _states.value = FailedState(t) }
                )
        }
    }
}
</code></pre>

<p>UserViewModelTest :</p>

<pre><code>@RunWith(MockitoJUnitRunner::class)
class UserViewModelTest {

    lateinit var userViewModel: UserViewModel

    @Mock
    lateinit var view: Observer&lt;ViewModelState&gt;

    @Mock
    lateinit var leApi: LeApi

    @get:Rule
    val rule = InstantTaskExecutorRule()

    @Before
    fun setUp() {
        RxAndroidPlugins.setInitMainThreadSchedulerHandler { Schedulers.trampoline() }
        userViewModel = UserViewModel(leApi)
        userViewModel.states.observeForever(view)
    }

    @Test
    fun testGetCurrentUser() {
        val user = Mockito.mock(User::class.java)
        `when`(leApi.getCurrentUser()).thenReturn(Single.just(user))
        userViewModel.getCurrentUser()

        val arg = ArgumentCaptor.forClass(ViewModelState::class.java)
        verify(view, times(2)).onChanged(arg.capture())

        val values = arg.allValues

        assertEquals(2, values.size)
        assertEquals(LoadingState, values[0])
        assertEquals(UserConnected(user), values[1])
    }

    @Test
    fun testGetCurrentUserFailed() {
        val error = Throwable(""Got error"")
        `when`(leApi.getCurrentUser()).thenReturn(Single.error(error))
        userViewModel.getCurrentUser()

        val arg = ArgumentCaptor.forClass(ViewModelState::class.java)
        verify(view, times(2)).onChanged(arg.capture()) // Error occurred here. That's the 70th line from stack trace.

        val values = arg.allValues
        assertEquals(2, values.size)
        assertEquals(LoadingState, values[0])
        assertEquals(FailedState(error), values[1])
    }
}
</code></pre>

<p>Expected :
All tests passed.</p>

<p>Actual :</p>

<pre><code>org.mockito.exceptions.verification.TooLittleActualInvocations: 
view.onChanged(&lt;Capturing argument&gt;);
Wanted 2 times:
-&gt; at com.dev.titi.toto.mvvm.UserViewModelTest.testGetCurrentUserFailed(UserViewModelTest.kt:70)
But was 1 time:
-&gt; at android.arch.lifecycle.LiveData.considerNotify(LiveData.java:109)
</code></pre>
",11417436,,8134164,,2019-04-27 06:04:12,2019-08-25 09:26:08,Unit Test : Observer onChanged should be called twice instead of once,<android><unit-testing><mockito><android-viewmodel><rx-kotlin>,1,4,0,,,CC BY-SA 4.0
55897609,1,55902557,0,2019-04-29 05:46:08,,0,129,"<p>I need to zip more than 3 observables with zip operator in rxkotlin, but when i try to zip more than 3 it shows me compile time error.<br>
<strong>Example</strong></p>

<pre><code> Observables.zip(Observable.just(someFun(0),Observable.just(someFun(1),Observable.just(someFun(2),Observable.just(someFun(3))
</code></pre>

<p>Is there we can zip more than 3 observable ?<br>
Any help</p>
",9344496,,0,,,2019-04-29 11:38:03,Rxkotlin - How to zip more than three observables with zip operator,<rx-java><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
55914451,1,0,0,2019-04-30 05:27:21,,0,45,"<p>I have a three layers in my application <strong>app</strong>, <strong>data</strong>, <strong>domain</strong>, i will be getting my result entity for my <strong>app</strong> from <strong>domain</strong> layer , the result entity class will be implementing with some interface <strong>L1</strong>, my need is when the result reaches app layer i need to replace the interface <strong>L1</strong> which is implemented in result entity  to interface <strong>L2</strong></p>

<p>Example<br>
<strong>Domain</strong></p>

<pre><code>interface L1
</code></pre>

<p>The above interface will not contain any methods or variables </p>

<pre><code>data class Result(val data : Any) : L1
</code></pre>

<p><strong>App</strong> </p>

<pre><code>interface L2
</code></pre>

<p>same as like interface L1</p>

<pre><code>data class Result(val data : Any) : L2
</code></pre>

<p>I am not sure whether i can achieve using rxkotlin, i had a rough idea about it like</p>

<pre><code>@Binds
abstract fun bindL1WithL2(l2 : L2) : L1
</code></pre>

<p>Is there is any solution for this ?<br>
Any help</p>
",9344496,,0,,,2019-04-30 05:27:21,Android - Replacing One interface with other one using rx-kotlin,<android><kotlin><rx-java><rx-kotlin>,0,3,0,,,CC BY-SA 4.0
55963637,1,0,0,2019-05-03 05:11:40,,-1,289,"<p>I am using retrofit2 for making service call in my application, i need to show the progress percentage for the service call which is made using retrofit, the result of the call will be of some JSON object. we know that for downloading files we can use <code>@Streaming</code> and <code>ResponseBody</code> in retrofit for getting progress percent, but am unaware for the JSON response.</p>

<p>Example</p>

<pre><code>@POST(""/getdata"")
fun callSomeApi(@Query(""id"") id : String) : Observable&lt;Data&gt;
</code></pre>

<p>Is there is any option to get progress percent for JSON response using retrofit ?<br>
Any help</p>
",9344496,,0,,,2019-05-03 11:06:58,Android - How to get progress for normal http call using retrofit,<android><kotlin><retrofit2><rx-kotlin>,1,1,1,,,CC BY-SA 4.0
56034425,1,56035352,0,2019-05-08 06:01:34,,4,74,"<p>I will be using observable transformer in my application for converting data from one type to another, so for this use i created a generic class with one parameter <code>&lt;T1&gt;</code> where T1 is the type am expecting to get the output</p>

<p>Example</p>

<pre><code>class Transformer&lt;T1&gt; {

    fun transform(): ObservableTransformer&lt;String, T1&gt; {

        return ObservableTransformer { data -&gt;

            data.map {

                if (T1 is Int) {       //getting compilation error like T1 is not an expression
                    return IntDataType
                }

                if (T1 is Double) { //getting compilation error like T1 is not an expression
                    return DoubleDataType
                }
            }
        }
    }
}
</code></pre>

<p>The above class is the transformer which gets the input as string and convert String to someData type based on given generic type T1<br>
So i will be calling the above like this</p>

<pre><code> getSomeData()
            .compose(Transformer&lt;Double&gt;().tranform())
            .map{ it: double
            } 
</code></pre>

<p>is there is any other solution to perform like this type of transformer ?
Any help</p>
",9344496,,1047418,,2019-05-08 10:04:08,2019-05-08 10:04:08,Android - Generic type as a Expressions In ObservableTransformer,<android><kotlin><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
56053542,1,56054379,0,2019-05-09 06:38:55,,2,560,"<p>Since sealed is like enum object so i decided to use sealed class for network response, were it contains success or failure if it is success it contains data else error message<br>
Example</p>

<pre><code>  sealed class Result {
            sealed class Success : Result() {
                data class F1(val data: Any) : Success()
                data class F2(val data: Any) : Success()
            }

            sealed class Error : Result() {
                data class F1(val error: Any) : Error()
                data class F2(val error: Any) : Error()
            }
        }
</code></pre>

<p>the above Result class has either Success or Failure</p>

<pre><code> getSomeDataFromService()
                .filter {
                    it is Result.Success.F1
                }
                .map { it: Result
                    /*
                    i face problem here,my need is F1 data class but what i
                     got is Result ,i know that i can cast here, 
                    but i am eager to know for any other solution other than casting  
                     */


                }

}
</code></pre>

<p>is there is any other solution ?<br>
Any help</p>
",9344496,,0,,,2019-05-09 07:36:03,Android - Kotlin Sealed class with Rxkotlin filter,<android><kotlin><rx-java><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
56117279,1,0,0,2019-05-13 17:33:37,,1,39,"<p>I'm using rxAndroid with an MVVM architecture. In my Activity, I need to bind my streams then fetch data from the server, which will eventually call the downstream.</p>

<p>My reasoning is the following:<br>
- I need to unsubscribe my streams in <code>onStop()</code> (<code>onDestroy</code> can cause memory leaks).<br>
-> therefore I need to subscribe to them in <code>onStart()</code> (otherwise coming back from background doesn't recreate the stream).<br>
-> therefore I need to fetch my data in or after <code>onStart()</code>, because the stream has to be bound before I can start calling the upstream.  </p>

<p>But in this case, every time I come back to the app after background, it's going to call the fetch method, which is not a behavior I want. Ideally I'd like to call the fetch method once, for example in <code>onCreate()</code>.</p>

<p>How can I nicely deal with this problem? I've tried finding solutions on SO and other websites but no luck.</p>
",10909037,,0,,,2019-09-13 19:21:31,When to subscribe/bind streams in android lifecycle?,<android><kotlin><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
56130742,1,0,0,2019-05-14 12:39:54,,1,64,"<p>I have a chaining operation in my application, Where i have a list of some data, i will iterate through the list with <code>iteratable observable</code> once the iteration completes, i will perform some other operation which does not depends on the previous list, so what i need is in between these two operation i need to block(or barrier) until the first completes and proceed with second one.</p>

<p>Example</p>

<pre><code>Observable.fromIterable(listOf(""A"",""B"",""C"",""D""))
          .map{
            doSomeTask(it)
          } 
   // I need a blocking here, once this iteration completes i will proceed with the below task, but i don't need of toList() to block since i don't want the data,       
          .map{
            doSomeOtherTask()
          }
</code></pre>

<p>Can anyone help me out with this ?</p>
",9344496,,9344496,,2019-05-14 12:58:08,2019-05-14 14:58:43,Block Chain in RxKotlin and Proceed,<android><kotlin><rx-java2><rx-kotlin2>,2,0,0,,,CC BY-SA 4.0
56252342,1,56252954,0,2019-05-22 08:23:21,,0,55,"<p>I am trying to get access_token with RXjava.</p>

<p>I ran the program and called the function that requests the access_token, but the process finishes with code 0.</p>

<p>I think the main thread is dead while connecting the server</p>

<p>my solution was
<code>Thread.sleep(sometime)</code>
to give short time to get the response.</p>

<p>and I also tried </p>

<pre><code>val runnable = Runnable{ getToken() }
val thread = Thread(runnable)
thread.run()
thread.join()
</code></pre>

<p>but it didn't work..</p>

<p>here is my code below</p>

<pre><code>fun main(args : Array&lt;String&gt;) {
    getToken()

//    Thread.sleep(10000) // it works but don't want to do with this
}



fun getToken() {
    val id = ""test""
    val pw = ""test""
    println(id + "" "" + pw)

    val oAuthService = Retrofit.Builder()
        .baseUrl(URL)
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .addConverterFactory(GsonConverterFactory.create())
        .client(httpClient)
        .build()
        .create(OAuthService::class.java)

    oAuthService.getAccessToken(
        CLIENT_ID,
        CLIENT_SECRET,
        id,
        pw
    ).subscribeOn(Schedulers.io())
        .flatMap {
            when(it.error){
                null -&gt; Single.just(TokenDto.Success(it.access_token?:"""", it.expires_int?:0, it.token_type?:"""", it.refresh_token?:""""))
                else -&gt; Single.just(TokenDto.Failure(""failed""))
            }
        }
        .retry { times, throwable -&gt;
            println(throwable)
            times &lt; 3 }
        .subscribeBy(
            onSuccess = {
                println(""onSuccess"")
                when(it){
                    is TokenDto.Success -&gt; {
                        println(""accessToken : ${it.access_token}"")
                    }
                    is TokenDto.Failure -&gt; {
                        println(""failed : ${it.msg}"")
                    }
                }
            },
            onError = {
                println(""onError"")
            }
        )
}


</code></pre>

<p>retrofit</p>

<pre><code>interface OAuthService {

    @FormUrlEncoded
    @POST(""oauth2/token"")
    fun getAccessToken(
        @Field(""client_id"") client_id:String,
        @Field(""client_secret"") client_secret:String,
        @Field(""username"") username:String,
        @Field(""password"") password:String
    ):Single&lt;TokenResponse&gt;
</code></pre>
",11532568,,8200936,,2019-05-22 10:11:38,2019-05-22 10:42:46,main function is dead while rxjava is working. any solution please,<kotlin><rx-java><retrofit2><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
56279571,1,0,0,2019-05-23 16:34:26,,0,85,"<p>I have one observable with a list of String and another with a list of string lists.
I need to reuse first observable until every string is stetted</p>

<p>In short. I need to iterate through every element of the list's list and attach it to first observable list elements</p>

<p>I learned about retryWhen but don't know how to reuse first observable and continue on the second</p>

<pre><code>val cat = sheetsViewer.GOOGLE_SHEETS_ENDPOINT_IMPL.readSpreadSheet(spreadsheetId, ""A4:DA4"")
            .toObservable()
            .flatMap { Observable.fromIterable(it) }


val data = sheetsViewer.GOOGLE_SHEETS_ENDPOINT_IMPL.readSpreadSheet(spreadsheetId, range)
            .toObservable()
            .subscribeOn(Schedulers.computation())
            .flatMap { Observable.fromIterable(it) }
            .map {
                val newList = it.toMutableList()

                while (newList.size != 105)
                    newList.add("""")

                return@map newList
            }
</code></pre>

<p>I have list of strings {""a"", ""b""}
and second {{""a"", ""b""}, {""c"", ""d""}, {""e"", ""f""}}</p>

<p>I expect the output to be {""aa"", ""bb"", ""ca"", ""db"", ""ea"", ""fb""}</p>
",7624868,,8200936,,2019-05-24 11:42:27,2019-05-24 11:42:27,Is there a way to reuse one observable until second will get onComplete() in zip?,<java><kotlin><rx-java2><rx-kotlin2>,2,1,0,,,CC BY-SA 4.0
56343675,1,56343797,0,2019-05-28 13:46:15,,0,81,"<p>I'm using room database and need to add rxKotlin to my project, so when I use this code:</p>

<pre><code>`implementation 'io.reactivex.rxjava2:rxkotlin:2.0.1'`
</code></pre>

<p>I get this error:</p>

<pre><code>`ERROR: Failed to resolve: io.reactivex.rxjava2:rxkotlin:2.0.1`
</code></pre>

<p>how can I fix it?</p>
",9470643,,1000551,,2019-05-28 15:25:07,2019-05-28 15:25:07,"how to fix ""can't resolve rxkotlin"" in android",<android><kotlin><rx-kotlin2>,2,0,0,,,CC BY-SA 4.0
56362602,1,56363137,0,2019-05-29 14:12:05,,3,138,"<p>I have a simple setup to a problem but the solution seems to be more complicated.</p>

<p>Setup: I have a hot observable which originates from a scanner that will emit every number as a different element and an <code>R</code> when a code is complete.</p>

<p>Problem: From this I want a hot observable that emits every full code as 1 element.</p>

<p><a href=""https://i.stack.imgur.com/Rh5Xg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Rh5Xg.png"" alt=""RxMarbles example""></a></p>

<p>I tried playing around with different <code>flatMap</code>, <code>takeUntil</code> and <code>groupBy</code>operators but haven't been able to come to a solution.</p>
",776141,,0,,,2019-05-29 15:41:56,Take elements until a certain character and group them with RxJava,<java><kotlin><rx-java><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
56403533,1,0,0,2019-06-01 02:58:20,,1,276,"<p>When I was trying to upgrade my Android Studio to 3.4, the update does not go smoothly rather, some dependencies break. In my case, the RxJava/RxKotlin dependencies are breaking without giving any clue. Even that is happening randomly as I have RxJava/RxKotlin Code in each of my <strong>4 modules</strong> but the dependency is failing in <strong>only one</strong> module. </p>

<p><a href=""https://i.stack.imgur.com/lmnlZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lmnlZ.png"" alt=""enter image description here""></a></p>

<p><strong>What I tried :</strong>  </p>

<ol>
<li>Invalidate Cache and restart. </li>
<li>Delete /build *module/build/ *module/.gradle/  &amp; .gradle/  </li>
<li>Clean Project     </li>
<li><p>Try find answers on the internet and these are the closest but does not solve the problem. (They did not recommend to upgrade to 3.4)</p>

<p>i) <a href=""https://stackoverflow.com/questions/55742589/unresolved-reference-observable-in-android-studio-3-4"">Unresolved reference: Observable in Android Studio 3.4</a>
<strong>Explains</strong> the <strong>problem</strong> I have <strong>but</strong> the thread is moving to either <strong>not upgrading</strong> the Gradle (Which is last option for me) or making sure RxJava that is being used in the project or any of its library is 2.2.8). For that reason I tried explicitly adding RxJava 2.2.8 (I was not previously as I was getting it inside RxKotlin) and wrote a  resolutionStrategy to force Android studio to use RxJava 2.2.8 like this in that particular module i.e. <strong>domain</strong>, but did not solve the issue :</p>

<pre><code>configurations.all {
       resolutionStrategy.force 'io.reactivex.rxjava2:rxjava:2.2.8'
}
</code></pre>

<p>ii) <a href=""https://github.com/ReactiveX/RxKotlin/issues/216"" rel=""nofollow noreferrer"">RxKotlin is not resolved properly after updating Gradle to 3.4.0</a> which does not yet give any solution. And <strong>I am even suspicious</strong> <strong>if</strong> it's the <strong>issue</strong> with RxJava/<strong>RxKotlin</strong> or the <strong>Gradle plugin</strong> itself. Or even if it's the case with RxKotlin or any other libraries too.   </p></li>
</ol>

<p><strong>Edit: My dependencies in domain module looks like this :</strong> </p>

<pre><code>dependencies {
    implementation Deps.kotlinStdLib
    implementation Deps.rxKotlin
    implementation Deps.dagger
    implementation Deps.timber
    implementation Deps.mobiusCore
    implementation Deps.mapboxGeoJSONCore
}
</code></pre>
",2581314,,472495,,2019-08-11 00:30:01,2019-08-11 00:30:01,"Cannot upgrading gradle Android Studio 3.4., Gradle 5 dependencies break randomly",<android><android-gradle-plugin><rx-java><rx-kotlin2><android-gradle-3.4.0>,1,2,0,,,CC BY-SA 4.0
56424628,1,56432574,0,2019-06-03 09:35:59,,1,68,"<p>I will be using thread executors to do some background work with rxkotlin, I made threadpool size fixed to 3, but my problem is during my background operation it using only one thread out of 3, which slows down my background operation</p>

<p>Executor class</p>

<pre><code> class ThreadExe : Executor{

     companion object {
        private const val THREAD_POOL_SIZE = 3
    }

    private val executor: Executor = 
       Executors.newFixedThreadPool(THREAD_POOL_SIZE)

    override fun execute(runnable: Runnable) {
          executor.execute(runnable)
    }

}
</code></pre>

<p>The above is my executor class responsible for creating thread.<br>
I will be calling my background task like below</p>

<pre><code> getSomeDataFromNetworkProcessWithDB()
    .subscribeOn(Schedulers.from(ThreadExe()))
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe()
</code></pre>

<pre><code>
fun getSomeDataFromNetworkProcessWithDB() {
    Observable.fromIteratable(someDataList())
            .flatMap {
                getSomeNetworkData()
            }
            .flatMap {
                doSomeDbOperation()
            }
}
</code></pre>

<p>my problem with the above code is all these network and db operation is working sequentially with the same thread, since we have give the threadpool of size 3 it must send the 3 network request parallely, but the request is going sequentially<br>
Can anyone help me out this problem ?</p>
",9344496,,9344496,,2019-06-03 10:46:00,2019-06-03 18:17:11,Handling Executors in RxKotlin,<android><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
56547732,1,56556776,0,2019-06-11 16:04:36,,0,172,"<p>How can I collect emitted values from observable to array?</p>

<p><strong>Input:</strong></p>

<pre><code>Observable.just(1,2,3,4,5,6)
</code></pre>

<p><strong>Expected output:</strong></p>

<pre><code>[1,2,3,4,5,6]
</code></pre>
",2543013,,2543013,,2019-06-11 16:57:10,2019-06-12 07:29:11,RxJava collect emitted values to array,<rx-java><rx-java2><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
56569345,1,0,0,2019-06-12 19:42:30,,1,327,"<p>How can I collect emitted items from observable to List when observable never completes?</p>

<p>Example I have something similar so Observable emits series of values, but never completes unless you unsubscribe, because of that <code>.toList()</code> not gonna work.</p>

<pre><code>Observable&lt;User&gt;
 .flatMap {}
 .toList()
</code></pre>

<p>How can I collect All users to List and emit it once after applying flatMap function to it?</p>
",2543013,,0,,,2019-06-12 20:40:43,RxJava Collect emission to list,<android><rx-java><rx-java2><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
56660075,1,0,0,2019-06-19 04:29:48,,1,91,"<p>I have a list of items say for example list of integers, if any of the integer is null, i need to consume the error and proceed with the next item</p>

<p>For example</p>

<pre><code>Observable.fromIterable(listOf(1, 2, 3, null, 5))
                .map {
                    doSomeProcess(it)
                }
                .onErrorReturnItem(-1)
                .subscribeBy(
                        onNext = {
                           print(it)
                        },
                        onError = {

                        },
                        onComplete = {

                        })
</code></pre>

<p>I am expecting the output like this</p>

<pre><code>1
2
3
-1
5
</code></pre>

<p>But my problem is after <code>-1</code> it is not getting proceeded with item <code>5</code>, it stops there, Can anyone help me out with this ?</p>
",9344496,,0,,,2019-06-19 06:49:24,How to handle errors in rxjava chain in android?,<android><rx-java><rx-kotlin><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
56740292,1,0,0,2019-06-24 16:03:53,,0,276,"<p>I've tried some examples with viewmodels and databinding using BehaviorSubjects and other Observables. Now I have real (data class) object in Kotlin, which holds most of the state. It is basically pojo, but independent from viewmodel and has no observables.
I don't understand how can I bind this automatically to ex. TextView in android without creating external observable variables in viewmodel and some boilercode. I'd think this is something very common in mvvm pattern. Or am I missing something totally?</p>
",4070660,,4070660,,2019-06-24 16:17:42,2019-06-25 15:20:03,Model properties binding in android viewmodel,<rx-java><rx-java2><rx-android><rx-kotlin><rx-kotlin2>,1,1,0,,,CC BY-SA 4.0
56771102,1,56778346,0,2019-06-26 10:50:35,,0,234,"<p>I need to handle error globally in my application for network service, i am using Rxjava2CallAdapterFactory in my retrofit service. So In order to handle error globally i searched through various sites and i got a solution. But i do know how this works.</p>

<pre><code>class RxErrorAdapter private constructor() : CallAdapter.Factory() {

    private val original = RxJava2CallAdapterFactory.create()

    override fun get(returnType: Type, annotations: Array&lt;Annotation&gt;, retrofit: Retrofit): CallAdapter&lt;*, *&gt;? {
        return Wrapper&lt;Any&gt;(original.get(returnType, annotations, retrofit)
                ?: return null)
    }

    private class Wrapper&lt;R&gt;(private val wrapped: CallAdapter&lt;R, *&gt;) : CallAdapter&lt;R, Any&gt; {

        override fun responseType(): Type {
            return wrapped.responseType()
        }

        override fun adapt(call: Call&lt;R&gt;): Any {
            val result = wrapped.adapt(call)
        }
    }


    companion object {
        fun create(): CallAdapter.Factory {
            return RxErrorAdapter()
        }
    }
}
</code></pre>

<p>Can anyone explain on this ?</p>
",9344496,,9344496,,2019-06-27 05:33:47,2019-06-27 05:33:47,RxJava2 Error Handling Wrapper For Retrofit Service,<android><retrofit><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
56867353,1,56867985,0,2019-07-03 09:49:17,,2,147,"<p>I need to make a lot of API calls asynchronously and obviously make sure that they all pass so I can handle error/success in a single place.</p>

<p>Is there a way to easily extend Singles.zip() functionality in Kotlin to take more than base 9 parameters (in best case scenario, to make it take any given number of parameters) without doing massive amounts of copy-paste work when writing your own extensions for t10, t11, etc. ?</p>

<p>Well, writing dozens of extensions simply works, but is cumbersome, not very elegant and adds additional work.</p>
",10675759,,0,,,2019-07-03 12:17:18,Extending Rx Singles zip infinitely,<java><android><kotlin><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
57049336,1,57051371,0,2019-07-16 02:32:23,,2,192,"<p>I have a <code>Category</code> data class and a <code>Plan</code> data class.
Each <code>Category</code> has a list of plan ids. There are Categories and Plans stored via Room.  I am trying to construct a local <code>List&lt;Any&gt;</code> where I add each category to a list, and then add each of it's plans.</p>

<p>So for each category, add the category to the list, then add each plan that belongs to that category.</p>

<p>The final result would look something like this...</p>

<pre><code>0 -&gt; a Category
1 -&gt; a Plan
2 -&gt; a Plan
3 -&gt; a Plan
4 -&gt; a Category
5 -&gt; a Plan
</code></pre>

<p>etc.</p>

<p>The following calls sucessfully return an <code>Observable&lt;List&lt;Category&gt;&gt;</code> and an <code>Observable&lt;Plan&gt;</code></p>

<pre><code>AppDatabase
   .getDatabase(context)
   .categoryDao()
   .getAll()

AppDatabase.getDatabase(context).planDao().getPlan(planId)
</code></pre>

<p>Here I am trying to build my list, but it actually never emits when I subscribe to it. No completion, or error. Everything else in the stream get's hit. Why can't I get my final result?</p>

<pre><code>    fun fetchCategoriesAndPlans() {
    val items = mutableListOf&lt;Any&gt;()
    AppDatabase
        .getDatabase(context)
        .categoryDao()
        .getAll()
        .concatMap { listOfCategories -&gt;
            listOfCategories.toObservable()
        }
        .doOnNext { category -&gt;
            items.add(category)
        }
        .concatMap { category -&gt;
            category.getPlanIds()!!.toObservable()
        }
        .flatMap { planId -&gt;
            AppDatabase.getDatabase(context).planDao().getPlan(planId)
        }.collectInto(items, BiConsumer{ list, i -&gt;
            Log.d(TAG, ""Collect into"")
            list.add(i)
        })
        .subscribeBy(
            onSuccess = {
                Log.d(TAG, ""Got the list"")
            },
            onError = {
                Log.e(TAG, ""Couldn't build list ${it.message}"", it)
            })
}
</code></pre>
",629259,,629259,,2019-07-16 02:54:01,2019-07-16 06:38:48,Building a list from two observable sources in RxKotlin/RxJava using collectInto,<android><rx-java2><android-room><collect><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
57063614,1,57928983,0,2019-07-16 18:41:56,,1,372,"<p>1) The code below fails to compile with an error: ""not enough information to infer type variable R""</p>

<pre><code>keywordChanges
  .withLatestFrom(searchParamsSubject)
  .subscribe { (keyword, searchParams) -&gt;
     ...
  }
</code></pre>

<p>2) The code below compiles and works, but I would prefer not to have an empty <code>subscribe()</code> and not to put side effects into the combiner function.</p>

<pre><code>keywordChanges
  .withLatestFrom(searchParamsSubject) { keyword, searchParams -&gt;
    searchParamsSubject.onNext(searchParams.copy(keyword = keyword))
  }
  .subscribe()
</code></pre>

<p>3) Below is the code from the RxKotlin library, that I am trying to call in 1)</p>

<pre><code>/**
 * Emits a `Pair`
 */
inline fun &lt;T, U, R&gt; Observable&lt;T&gt;.withLatestFrom(other: ObservableSource&lt;U&gt;): Observable&lt;Pair&lt;T,U&gt;&gt;
        = withLatestFrom(other, BiFunction{ t, u -&gt; Pair(t,u)  }
</code></pre>

<h3>How could I modify the code in 1) to make it work?</h3>
",133309,,0,,,2019-09-13 18:55:30,"RxKotlin ""withLatestFrom(...)"" compile error: not enough information to infer type variable R",<kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
57132058,1,57132969,0,2019-07-21 09:56:21,,2,393,"<p>I am need that i will be calling a completable method in the chain, after it completes, it needs to continue the chain with <code>Map</code> operator<br>
<strong>Example</strong></p>

<pre><code>Single.just(someOperation())
     .flatMapCompletable{
         completableMethod()
    }
     .map{ // i need to continue here with map or some other operator
         doSomeOperation()
    }
</code></pre>

<p>Can anyone help me out with this ?</p>
",9344496,,0,,,2019-07-21 12:19:52,Convert Rxjava Completable to Map,<android><rx-java><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
57188728,1,0,0,2019-07-24 17:56:16,,1,272,"<p>I am new to Android development, I'm trying to make form validation using RxKotlin and RxBinding.</p>

<p>I need a guidance how to make form validation with more than 9 fields?
Actually I can combine the result using <code>Observable.combinelatest</code>.</p>

<p>This is the code I've been trying:</p>

<pre><code>Observable.combineLatest(profileObserver, shopName, shopAddress, ownerName, idCard, ownerHp, ownerEmail, pin, confirmPin,
                Function9&lt;CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence,
                        Boolean&gt; {profile, name, address, owner, card, hpNumber, email, currentPin, confirmationPin -&gt;
                    return@Function9 isShopNameValid(name.toString()) &amp;&amp; isShopAddressValid(address.toString())
                            &amp;&amp; isOwnerNameValid(owner.toString())
                            &amp;&amp; isIdCardValid(card.toString())
                            &amp;&amp; isOwnerHpValid(hpNumber.toString())
                            &amp;&amp; isOwnerEmail(email.toString())
                            &amp;&amp; isPinValid(currentPin.toString())
                            &amp;&amp; isConfirmPinValid(confirmationPin.toString())
                }).subscribe {
                registrationProcess.isEnabled = it
            }
</code></pre>

<p>I still have 3 more fields to be validated.</p>
",5501860,,8412192,,2019-08-02 07:41:36,2019-09-13 15:01:37,RxKotlin combine latest more than 9 fields,<rx-kotlin>,1,2,0,,,CC BY-SA 4.0
57195965,1,57197257,0,2019-07-25 06:54:21,,0,40,"<p>Suppose I have a <code>BehaviorProcessor</code> which contains some value <code>v</code>.</p>

<p>Now if I want to asynchronously request some data, which would depend on <code>v</code> I would do it like this:</p>

<pre><code>val res = v.flatMapSingle { asyncRequest(it) }
</code></pre>

<p>Now let's log all the invocations of this block (mapper)</p>

<pre><code>val res = v.flatMapSingle {
    println(""mapper"")
    asyncRequest(it)
}
</code></pre>

<p>It will print <code>mapper</code> multiple times, which means <code>asyncRequest</code> is being called multiple times, it seems every time some other dependant stream is being <code>subscribe</code>d to</p>

<p>I am trying to avoid multiple mapper invocations (thus avoiding multiple <code>asyncRequest</code> calls).</p>

<p>Is there a way to do so with standard rxjava2 utils?</p>
",4758683,,1712135,,2019-07-25 07:00:46,2019-07-25 08:13:25,How to avoid multiple mapper calls when using flatMapSingle,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
57251465,1,0,0,2019-07-29 10:03:56,,0,25,"<p>There is a class, it has observable fields. I want to update <code>localData</code></p>

<p>when receiving remote data <code>remoteData</code>, for some reason I can not get data in <code>localData</code>, debugging does not go to a breakpoint even to <code>getIdsInDatumsRemote ()</code>. The <code>identifyDatumsForUpdate ()</code> method gets an empty Observable.</p>

<pre><code>class DiskDatumDataStore {

    var remoteData: Observable&lt;Data&gt;? = null

    var localData: Observable&lt;Data&gt;? = null

    override fun sync() {
        remoteDatums = getChangedRemoteData(lastUpdated!!, 1000)!!
        localDatums = remoteDatums!!.map {
            getIdsInDatumsRemote(it)
        }.map {
            it.map {
                it.toLong()
            }
        }.flatMap {
            getOldLocalData(it)
        }


        identifyDatumsForUpdate(datumsForUpdateLocal, datumsForUpdateRemote)
    }

    override fun getOldLocalData(remoteDatumsIds: List&lt;Long&gt;): Observable&lt;List&lt;DataLayerTypesOfResponsibility&gt;&gt; {
        return Observable.fromCallable { repository.getOldDatum(remoteDatumsIds) }      
    }
}
</code></pre>
",11851604,,11851604,,2019-07-29 10:10:01,2019-07-29 10:31:45,Dependence of one Observable on another RxJava2,<java><kotlin><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
57280030,1,57304034,0,2019-07-30 21:06:01,,0,31,"<p>I've attached a function can be called from multiple viewModels, I'm trying to store each ""restaurant"" to the DB in a central function before returning this observable to a viewModel. </p>

<p>I'm new to rxandroid and I'm wondering if there is a way to perform a non-transformative and non-consuming action on each item before the final onNext() in subscribe(). </p>

<p>(Something like doOnEach() below):</p>

<pre><code>fun getData() : CompositeDisposable {
        return apiProvider!!.loadRestaurants()
            .flatMap { response : RestaurantOuterResponse? -&gt; Observable.fromArray(
                response!!.restaurants
            )}
            .doOnEach() { restaurant : Restaurant -&gt;
                ADBConnection.storeRestaurant(restaurant)
            }
    }
</code></pre>

<p>Two Solutions I've found so far was to:</p>

<ol>
<li>Have a function inside RestaurantOuterResponse to save all the values when the list of ""Restaurants"" is extracted in flatMap(). </li>
<li>Call the ADBConnection.storeRestaurant(restaurant) in onNext() in each individual viewModel.</li>
</ol>

<p>None of these are great solutions, is what I suggested in the right direction? Or is there a better way?</p>
",6382655,,0,,,2019-08-01 07:39:28,Perform non-transformative action on each item in observable before onNext,<android><kotlin><rx-java><rx-java2><rx-kotlin2>,1,1,0,,,CC BY-SA 4.0
57342833,1,57348985,0,2019-08-03 23:48:27,,4,548,"<p>Using a simple RxKotlin Single, I'm receiving either a <code>android.view.ViewRootImpl$CalledFromWrongThreadException</code> exception, or by adding <code>.observeOn(AndroidSchedulers.mainThread())</code>, I'm getting a <code>NetworkOnMainThread</code> exception. </p>

<pre><code>fun loadStaffCalendar() {
        var calendarParser = CalendarParser()
        calendarParser.getSingleBearCal()
            .subscribeOn(Schedulers.io())
            .subscribeBy(
                onError ={error(""Error loading calendar\n${it.message}"")},
                onSuccess = { responseBody -&gt;
                        println(""ResponseBody retrieved"")
                        var staffList = calendarParser.parseStringIntoSchedule(responseBody.string())
                        view.loadToAdapter(staffList)
                         println(staffList)

                }

            )
</code></pre>

<p>I can get the staffList to print in console, but as soon as I try to load it into the View's adapter, it crashes with an CalledFromWrongThread exception.</p>

<p>So here's the crash when I add <code>.observeOn(AndroidSchedulers.mainThread()):</code></p>

<pre><code>Process: com.offbroadwaystl.archdemo, PID: 21809
    io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | android.os.NetworkOnMainThreadException
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
        at io.reactivex.android.schedulers.HandlerScheduler$ScheduledRunnable.run(HandlerScheduler.java:126)
        at android.os.Handler.handleCallback(Handler.java:873)
        at android.os.Handler.dispatchMessage(Handler.java:99)
        at android.os.Looper.loop(Looper.java:193)
        at android.app.ActivityThread.main(ActivityThread.java:6669)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)
     Caused by: android.os.NetworkOnMainThreadException
        at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1513)
        at com.android.org.conscrypt.Platform.blockGuardOnNetwork(Platform.java:415)
        at com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read(ConscryptFileDescriptorSocket.java:527)
        at okio.InputStreamSource.read(Okio.kt:102) 
</code></pre>

<p>No additional network calls are made anywhere. Here's the rest:</p>

<pre><code>class CalendarParser : AnkoLogger {
    fun getSingleBearCal(): Single&lt;ResponseBody&gt; {
        val retrofit: Retrofit = Retrofit.Builder()
            .baseUrl(""https://www.brownbearsw.com/"")
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
            .build()
        val bearApi: BearApi = retrofit.create(BearApi::class.java)

        return bearApi.file
    }

    fun parseStringIntoSchedule(wholeSchedule: String): ArrayList&lt;StaffModel&gt; {
        var dateMap: HashMap&lt;LocalDate, String&gt; = HashMap()
        var endDelim = ""END:VEVENT""
        var events: List&lt;String&gt; = wholeSchedule.split(endDelim)
        var parsedStaffCal: ArrayList&lt;StaffModel&gt; = ArrayList()
        var today = LocalDate.now()
        // :: Pull event date from event data, pull staff list from ""SUMMARY"" line :: //
        events.forEach {
            var tempString = (it.substringAfterLast(""DATE:"", ""FAIL"").take(8))
            var dateTime: LocalDate = eightIntoDateTime(tempString)

            var summary: String = it.substringAfter(""SUMMARY:"", ""FAIL"")
                .let { it.substringBefore(""UID"").replace(""\\n"", ""\n"") }
            dateMap.put(dateTime, summary)
        }

        // ::Filter out all days before today:: //
        dateMap.forEach {
            if (!it.key.isBefore(today)) {
                val staffModel = StaffModel(it.key, it.value)
                parsedStaffCal.add(staffModel)
            }
        }
        //:: Sort chronologically :://
        parsedStaffCal.sortBy { it.localDate }

        return parsedStaffCal
    }

    fun eightIntoDateTime(s: String): LocalDate {
        return if (s.length == 8 &amp;&amp; s.isDigitsOnly()) { // &lt;-=-=-=-=-=- avoid potential formatting exceptions
            val dateString = (""${s.subSequence(0, 4)}-${s.subSequence(4, 6)}-${s.subSequence(6, 8)}"")
            LocalDate.parse(dateString)
        } else LocalDate.parse(""1999-12-31"")
    }  
</code></pre>

<p>Retrofit API:</p>

<pre><code>package com.offbroadwaystl.archdemo.schedule;

import io.reactivex.Single;
import okhttp3.ResponseBody;
import retrofit2.http.GET;
import retrofit2.http.Streaming;

public interface BearApi {
    @Streaming
    @GET(""url.goes.here.ics"")
    Single&lt;ResponseBody&gt; getFile();
}
</code></pre>
",10943915,,10943915,,2019-08-04 16:14:06,2019-08-04 17:53:04,Single causes either Network on Main Thread or View Root from Wrong Thread exceptions,<android><kotlin><rx-kotlin2>,2,3,0,,,CC BY-SA 4.0
57404599,1,57404794,0,2019-08-08 02:58:31,,1,276,"<p>Unfortunately, my REST Delete operation work only for one item. So what I was trying to do is,</p>

<pre><code>Observable.just(items).flatMapIterable { items -&gt; items }.flatMap {
                //call REST DELETE for every item
            }.flatMap {
                // call REST GET
            }
</code></pre>

<p>The problem is the GET call is being called for every item. How can I wait for finishing all the delete done and then perform the GET call? </p>

<p>Thanks in Advance.</p>
",1077539,,3633468,,2019-08-08 09:48:56,2019-08-08 09:48:56,Perform a task for all items in a list and then perform another task in RxJava,<java><android><kotlin><rx-java><rx-kotlin>,3,5,0,,,CC BY-SA 4.0
57469647,1,57480686,0,2019-08-13 00:10:33,,0,160,"<p>I'm trying for some time now to implement an extension function (just becuse it's easier to me) that is capable of delaying both normal item emissions and errors. The existing delay operators only delays normal item emissions, errors are delivered ASAP.</p>

<p>For context, I'm trying to immitate an Android LiveData's behavior (kinda). LiveDatas are a observable pattern implementation that is lifecycle aware. Their observers are only notified if they are in a state where they can process that emission. If they are not ready, the emission is cached in the livedata and delivered as soon as they become ready.</p>

<p>I created a BehaviourSubject that emits the state of my Activities and Fragments when it changes. With that I created a delay operator like this:</p>

<pre><code>fun &lt;T&gt; Flowable&lt;T&gt;.delayUntilActive(): Flowable&lt;T&gt; = delay { lifecycleSubject.toFlowable(BackpressureStrategy.LATEST).filter { it.isActive } }
</code></pre>

<p>and then use it like this</p>

<pre><code>myUseCase.getFlowable(Unit)
                .map { it.map { it.toDisplayModel() } }
                .delayUntilActive()
                .subscribe({
                    view.displaySomethings(
                }, { }).addTo(disposables)
</code></pre>

<p>So even if myUseCase emits when the view is not ready to display somethings, the emission won't reach onNext() until the view does become ready. The problem is that I also want the view to displayError() when onError is triggered, but that too is lifecycle sensitive. If the view isn't ready, the app will crash.</p>

<p>So I'm looking for a way to delay both emissions and errors (onComplete would be good too). Is this possible?
I tried some things with zip, onErrorReturn, delay inside delay, but nothing seemed right. I'd be equally unimpressed if this had a really easy solution I'm overlooking, or is impossible. Any ideas are welcome.</p>

<p>Bonus: any better way to do that for Single and Completable too? currently I'm just converting them to flowable. </p>

<p>Thanks in advance!</p>
",10614184,,10614184,,2019-10-05 03:34:53,2019-10-05 03:34:53,Is it possible to implement an operator like delay but that also delays errors?,<android><rx-java2><reactivex><rx-kotlin>,1,0,1,,,CC BY-SA 4.0
57529032,1,57530072,0,2019-08-16 17:46:49,,1,147,"<p>What I wanted to do is to have a Flowable with a backpressure buffer of one item that keeps the latest one produced from a stream.</p>

<p>I've tried to use Flowable.onBackpressureBuffer(1, () -> {}, BackpressureOverflowStrategy.DROP_OLDEST). However, it doesn't work as I expected</p>

<pre><code>  Flowable.range(0, 10_000)
      .onBackpressureBuffer(1, {}, BackpressureOverflowStrategy.DROP_OLDEST)
      .observeOn(Schedulers.computation())
      .subscribe {
        println(it)
        Thread.sleep(5)
      }
</code></pre>

<p>The output I expected is a sequence of integers, not necessarily contiguous, that should includes the last item 9,999. However, it only printed the first a few contiguous numbers like 0, 1, 2, 3, 4..., different each time, but not the last number 9,999.</p>
",10919945,,0,,,2019-08-16 19:22:41,What's the behavior of onBackpressureBuffer in RxJava2,<java><kotlin><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
57618052,1,57672830,0,2019-08-22 23:13:53,,0,168,"<p>I have 2 observable sources where <code>fetchProductList()</code> returns <code>Observable&lt;Datasource&gt;</code> and other <code>canInvite.execute()</code> takes a value and returns a <code>Single&lt;Boolean&gt;</code>. I need to compose the stream to feed every emission from first source to the second in a way that I can return all the emission from <code>fetchProductList()</code> with the <code>true</code> value as a list. I tried to compose it this way but it looks a bit clunky, Any better/simpler ways to do it?</p>

<pre><code>fetchProductList()
                    .map { dataSource -&gt; dataSource.data }
                    .flatMap{ data -&gt;
                        Observable.from(data.roles.map { role -&gt;
                            canInvite.execute(role.key).map { canInvite -&gt;
                                role to canInvite
                            }
                        })
                    }

                    .compose { it -&gt; Single.merge(it) }
                    .filter { it -&gt; it.second == true}
                    .map { it -&gt; it.first }
                    .toList()
                    .subscribe {
</code></pre>
",2231099,,0,,,2019-08-27 10:36:20,Composing two observable sources using one as a predicate in RxJava,<android><rx-java><reactive-programming><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
57738495,1,57746848,0,2019-08-31 13:39:52,,1,38,"<p>I'm writing messenger server on grpc with rxjava2 stubs, and I stuck on combining my singles.</p>

<p>I'm have tried some sort of</p>

<pre><code>  val user:Single&lt;User&gt; = getUser()
  val conversation:Single&lt;Conversation&gt; = getConversation(user.blockingGet())
  return conversation.map{
      someMethod(user.blockingGet(), conversation.it())
      it
  }
</code></pre>

<p>It looks so unbeauty then all of the examples, so is there a way to combine all of this singles to one line?</p>
",10064300,,0,,,2019-09-01 14:31:18,How to handle a multiple singles?,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
57815436,1,57817329,0,2019-09-06 03:43:44,,0,203,"<p>If in ActivityA, it keep reference to </p>

<pre><code>private val subjectA: PublishSubject&lt;ObjectB&gt; = PublishSubject.create()
private var dispose: Disposable? = null
</code></pre>

<p>Does we need to call onComplete() method of subject in onDestroy() method of Activity</p>

<pre><code>override fun onDestroy() {
    subjectA.onComplete()
    dispose?.dispose()
    super.onDestroy()
}
</code></pre>
",2286345,,2649012,,2019-09-06 06:35:39,2019-09-06 07:11:43,Do we need to call onComplete() of subject in onDestroy() method of activity?,<android><rx-java><rx-java2><rx-kotlin2>,1,2,0,,,CC BY-SA 4.0
57835667,1,0,0,2019-09-07 16:45:00,,0,64,"<p>I am creating an application for fall detection and I am trying to implement RxKotlin to do it. To provide good data processing I'm taking sesnorEvent every 250ms and put it to the buffer (with last 10 seconds). Unfortunately, entire data in the buffer is the same event when I move my phone. Is the problem in my code or it just work like this?</p>

<p>Already I tried to use window and buffer, however, results are the same.
Target API of the app is 28, min API 21. SensorListener is placed in the foreground Service</p>

<pre><code>//initialization of the properties
private val proxy: BehaviorSubject&lt;SensorEvent&gt; = BehaviorSubject.create()
private var mSensorManager: SensorManager? = null
private var mAccelerometer: Sensor? = null
private lateinit var subscribe: Disposable

override fun onCreate() {
        super.onCreate()
        mSensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        mAccelerometer = mSensorManager!!.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        mSensorManager!!.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL)

        subscribe = Observable.interval(250, TimeUnit.MILLISECONDS)
            .map { proxy.value }
            .buffer(1, TimeUnit.SECONDS)
            .map {
                it.map { sensorEvent -&gt; calculateAcceleration(sensorEvent!!) }
            }
            .subscribe {

                    Log.d(""MySensor"", it.toString())

            }
    }

//Here I call onNext also log data for every called event
override fun onSensorChanged(event: SensorEvent?) {
        proxy.onNext(event!!)
        Log.d(""MySensor"", calculateAcceleration(event).toString())
    }



private fun calculateAcceleration(event: SensorEvent): Float {
        val axisX = event.values[0]
        val axisY = event.values[1]
        val axisZ = event.values[2]
        val acceleration = sqrt(axisX.pow(2) + axisY.pow(2) + axisZ.pow(2))
        //Log.d(""MyDataSave"", acceleration.toString())
        return acceleration
    }



</code></pre>

<p>I expect the output of the observable was like [11.234473, 9.768473, 13.23543], however, I get  [9.768473, 9.768473, 9.768473]. Main point is that the values in the buffer should be different after I move the phone during the buffer lifetime, but they are not.</p>
",12035106,,7615937,,2019-12-12 07:38:31,2019-12-12 07:38:31,Observable returns list of the same values,<android><kotlin><observable><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
57874011,1,0,0,2019-09-10 15:31:57,,0,114,"<p>In my project, I use RxJava/RxKotlin bindings to communicate with REST API. The API sometimes returns a list of elements, that need to be altered/mapped, before I can use them.</p>

<p>Currently, mapping of these elements is done by nested <code>.map()</code> and <code>.apply()</code> functions, like this:</p>

<pre><code>fun getSampleObjects(): Single&lt;List&lt;SampleObject&gt;&gt; =
    sampleService.getSampleObjects()
        .map { list -&gt;
            list.map { sampleObject -&gt;
                sampleObject.apply {
                    sampleProperty = otherSampleService.getSampleProperty()
                }
            }
        }
</code></pre>

<p>where <code>sampleService.getSampleObjects()</code> returns and RxKotlin <code>Single&lt;List&lt;SampleObject&gt;&gt;</code></p>

<p>I'm looking for an easier-to-read and more efficient way to archive the same result, possibly without the need to alter data models.</p>
",5930112,,0,,,2019-09-10 20:02:51,Mapping elements of collection from RX Single/Observable,<generics><kotlin><collections><rx-java><rx-kotlin>,1,0,1,,,CC BY-SA 4.0
57882282,1,57883043,0,2019-09-11 04:46:09,,2,2969,"<p>I am using rxjava for some uploading task to server, Whenever task initiated fragment or activity is destroyed i will be disposing the subscription to avoid memory leak, But what i want is even after the fragment/activity destroyed i need to continue the task running in the background, Is there is any way to achieve this ?</p>

<p>Example</p>

<pre><code>doSomeLongRunningBgTaks()
     .subscribe()
     .addTo(compositeDisposal)
</code></pre>

<pre><code>override onDestroy(){
  compositeDisposal.clear()
}
</code></pre>

<blockquote>
  <p>Is it mandatory to dispose the subscription all time ? if not when to use dispose ?</p>
</blockquote>
",9344496,,61158,,2019-09-11 08:48:44,2019-09-11 08:50:11,How to use Rxjava for long running background task,<android><rx-java><rx-java2><rx-kotlin2>,3,1,0,,,CC BY-SA 4.0
57889004,1,0,0,2019-09-11 12:19:02,,3,73,"<p>I am making 2 RX calls that are nested within each other and are co-dependent. There is an issue with the server (which cannot be solved right now for various reasons) which returns errors in the 2nd nested call. </p>

<p>Until this gets solved, I need to have it that if the 2nd call returns an error, the results of the first call are discarded as well. Right now, the entire iterative process stops the moment any of these error responses occur, and so my goal is to skip over them. </p>

<p>Here is what my call structure currently looks like: </p>

<pre><code> fun getAllDynamicUtterances(module: String) {

    var uttList: ArrayList&lt;DynamicUtterance&gt;? = ArrayList()
    rxSubs?.add(
        repository.getDynamicUtterances(module).map{res -&gt;
            res.uttSets.forEach {utt -&gt;
                    utt.module = res.module!!
                    utt.transferInputValues()
                    utt.generateDefaultFlatTree()
                    uttList?.add(utt)
                    insertDynamicUtterance(utt)
                    repository.updateDynamicUtteranceView(utt).blockingForEach {
                        utt.assignSelectionStrings(it)
                        repository.storeDynamicUttPieces(utt.inputUttPieces)
                        utt.uttLinearisations = it.linearisations
                        updateDynamicUtterance(utt)
                    }
            }
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread()).subscribe ({
                allDynamicUtterances?.postValue(uttList)
            },{
                Log.e(""errorHandle"",it.toString())
            })
    )
}
</code></pre>

<p>My thinking is to include an if statement that almost does a ""peek"" of the second call before proceeding, but I'm not sure how to go about it. This is what I came up with so far to give an idea of my thinking: </p>

<pre><code>fun getAllDynamicUtterances(module: String) {

    var uttList: ArrayList&lt;DynamicUtterance&gt;? = ArrayList()
    rxSubs?.add(
        repository.getDynamicUtterances(module).map{res -&gt;
            res.uttSets.forEach {utt -&gt;
                    utt.module = res.module!!
                    utt.transferInputValues()
                    utt.generateDefaultFlatTree()
                if (doesNotReturnError(utt)){ // &lt;- add this
                    uttList?.add(utt)
                    insertDynamicUtterance(utt)
                    repository.updateDynamicUtteranceView(utt).blockingForEach {
                        utt.assignSelectionStrings(it)
                        repository.storeDynamicUttPieces(utt.inputUttPieces)
                        utt.uttLinearisations = it.linearisations
                        updateDynamicUtterance(utt)
                    }
                }
            }
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread()).subscribe ({
                allDynamicUtterances?.postValue(uttList)
            },{
                Log.e(""errorHandle"",it.toString())
            })
    )
}
</code></pre>

<p>and then adding this function, or a function that performs what it is im trying to achieve in any case.</p>

<pre><code>private fun doesNotReturnError(utt: DynamicUtterance): Boolean{
   rxSubs?.add(
       repository.updateDynamicUtteranceView(utt).subscribeOn(Schedulers.io())
           .observeOn(AndroidSchedulers.mainThread())
           .subscribe({
             //cant put a return here :(
           }, {
               Timber.e(it)
           })
   )
    //returning over here will return nothing wont it? 
}
</code></pre>

<p>I welcome comments on how to improve my <em>getAllDynamicUtterances</em> function</p>
",860233,,13860,,2019-09-11 13:51:29,2019-09-13 15:43:34,How can I use the response result of an RXJava call as a condition for an if statement inside another RXJava function?,<android><kotlin><rx-java><okhttp><rx-kotlin>,1,1,0,,,CC BY-SA 4.0
58108921,1,58333082,0,2019-09-26 02:49:50,,1,38,"<p>Basically my Android app have some meta data which need to report to backend server in different scenarios:</p>

<pre><code>data class SearchMetaData(
    val searchId: String?,
    val isRateLimit: Boolean
)
</code></pre>

<p>In order to make the code clean, I make the minimal case as follows. All the report logic are similar, each of the function <code>subscribe</code> the metadata provider and get the value that need to report.</p>

<pre><code>fun logEvent1() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event1.session = sessionMetadata
        ...
        report(event1)
    })
}

fun logEvent2() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event2.session = sessionMetadata
        ...
        report(event2)
    })
}

fun logEvent3() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event3.session = sessionMetadata
        ...
        report(event3)
    })
}
</code></pre>

<p>My concern is every time we change the schema of metadata, we need to update all the <code>logEventX</code> , I was wondering if maybe we could extract all the <code>subscribe</code> in different functions and get the metadata?</p>
",1319619,,13302,,2019-09-29 21:07:34,2019-10-11 01:28:00,RxJava: How to extract same observeOn from different functions?,<android><rx-java><reactive-programming><rx-kotlin>,1,4,0,,,CC BY-SA 4.0
58150946,1,0,0,2019-09-28 23:07:14,,0,155,"<p>Let say that I have a source of number list and observable which can value each number in that list. (Below method are required to be used. They are part of API which I <strong>have to</strong> use)</p>

<pre><code>fun getNumberListSource() : Observable&lt;List&lt;Int&gt;&gt; {...}
fun getOddChecker(value: Int): Observable&lt;Boolean&gt; {...}
</code></pre>

<p>Let say source could look like this:</p>

<pre><code>class NumberSource {

    private val source = BehaviorSubject.create&lt;List&lt;Int&gt;&gt;()

    fun getNumberListSource(): Observable&lt;List&lt;Int&gt;&gt; = source.doOnNext { println(""doOnNext :)"") }

    fun start(){
        Thread {
            Thread.sleep(1000)
            source.onNext(listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
            Thread.sleep(1000)
            source.onNext(listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
            Thread.sleep(1000)

            source.onComplete()
        }.start()

    }
}
</code></pre>

<p>fun getOddChecker(i: Int) : Observable = Observable.just(i%2== 0)</p>

<p>at the end of the stream I need to have lists of odd numbers.
So I done that code:</p>

<pre><code>fun main() {
    val numberSource = NumberSource()
    numberSource.start()
    println(""== started =="")

    numberSource.getNumberListSource()
        .flatMap {
            Observable.fromIterable(it)
                .flatMap (
                    {getOddChecker(it)},
                    {a, b -&gt; a to b}
                )
                .filter { it.second }
                .map { it.first }
                .toList()
                .toObservable()
        }
        .subscribe({ println(""onNext: $it"")},{},{ print(""action:onComplete"")})

}
</code></pre>

<p>above code's output:</p>

<pre><code>== started == 
doOnNext :) 
onNext: [2, 4, 6, 8, 10, 12] 
doOnNext :) 
onNext: [2, 4, 6, 8, 10, 12] 
action:onComplete
</code></pre>

<p>Above code does what I want but I had to use <code>Pair</code> class. The part </p>

<pre><code>        .filter { it.second }
        .map { it.first }
</code></pre>

<p>seems not quite readable.
So is there any operator witch could simplify that code?      </p>
",1461568,,1461568,,2019-09-29 18:18:43,2019-09-29 18:42:26,How to filter list emitted by observable using result from another observable rx kotlin?,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
58290474,1,0,0,2019-10-08 16:29:00,,0,102,"<p>After going through some discussions about when to dispose a <code>CompositeDisposable</code>, I wonder why we can't just add a <code>.dispose()</code> after <code>.subscribe()</code> in code.</p>

<pre><code>Observable.just(0)
    .doOnNext{...}
    .subscribe()
    .dispose()
</code></pre>

<p>What is actually happen if the code is like this? Is it ok to write like this? (instead of <code>.addTo(compositeDisposable)</code>)</p>
",5655480,,0,,,2019-10-08 17:06:16,What is the problem of adding .dispose() after .subscribe(),<android><rx-java2><rx-kotlin2>,1,3,0,,,CC BY-SA 4.0
58492711,1,0,0,2019-10-21 19:07:28,,0,102,"<p>A, B, C are objects</p>

<p>All function calls are made to a Rooms DB</p>

<p>This code snippet is inside a ViewModel</p>

<p>repo = Repository</p>

<p>So I'm making an android app (can't provide details) and for a particular screen I need to do the following.</p>

<p>My first call is repo.getInfo, which returns a Single Observable ListOfA: <code>Single&lt;List&lt;A&gt;&gt;</code> //perform some operations</p>

<p>for every element of ListOfA I need to call another function repo.getB(A) which returns a Single Observable ListOfB: <code>Single&lt;List&lt;B&gt;&gt;</code>  //perform some operations</p>

<p>for every element of ListOfB I need to call another function repo.getC(B) which returns a Single Observable ListOfC: <code>Single&lt;List&lt;C&gt;&gt;</code>  //perform some operations</p>

<p>after I have the required data I need to call another function that combines the data to display on the UI.</p>

<p>Now I can't get this to work. Here's what I've tried. But the flow stops at the line marked THIS LINE and jumps to subscribe block.
Individual calls to the functions work so the data is not the problem.
I'm pretty new at this and quite frankly out of my depth. Any help or hint is appreciated. Thanks</p>

<pre><code>localListOfA = emptyList&lt;A&gt;()
localListOfB = emptyList&lt;B&gt;()
localListOfC = emptyList&lt;C&gt;()
compositeDisposable.add(
    getInfo.map{listOfA -&gt;
        localListOfA.addAll(listofA)
        listOfA.map {elementA -&gt;   ////THIS LINE
            getB(elementA.id).map{listOfB -&gt;
                listOfB.filter {
                    //some logic to select a few objects
                }
            }.map { it // filtered list of B
                localListofB.addAll(it)
                localListOfB.last() //I only need the top element of this list
            }.map{elementB -&gt;
                getC(elementB.id).map{ listOfC -&gt;
                    localListOfC.addAll(listOfC)
                    //do some operations
                }
            }
        }
    }
    .subscribeOn(DEFAULT_CACHED_SCHEDULERS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnError(/*take log*/)
    .subscribe{
        prepareUi()
    }
)
</code></pre>
",12253227,,0,,,2019-10-21 20:42:00,Fetching a Single<List> for all elements of another Single<List> in RxKotlin,<android><rx-java><reactive-programming><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
58512028,1,58512127,0,2019-10-22 20:42:11,,2,501,"<p>I'm trying to create <strong>unit tests</strong> for the method of my ViewModel below, which uses <strong>RxJava/RxKotlin</strong>.</p>

<pre><code>fun doLogin(address: String, serial: String) {
    mLoading.value = true
    mCompositeDisposable.add(
        mRepository
            .doLogin(address, createJsonArray(serial, generatePinJSON()))
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeBy(
                onSuccess = { json -&gt;
                    /** CODE **/
                },
                onError = { error -&gt;
                    /** CODE **/
                }
            )
    )
}
</code></pre>

<p>But when <strong>Schedulers.io()</strong> is invoked in the test method, it throws a NullPointerException.</p>

<p><strong>I've tried to use this approaches below:</strong></p>

<p><a href=""https://medium.com/@dbottillo/how-to-unit-test-your-rxjava-code-in-kotlin-d239364687c9"" rel=""nofollow noreferrer"">https://medium.com/@dbottillo/how-to-unit-test-your-rxjava-code-in-kotlin-d239364687c9</a> (Creating a Rule)</p>

<p><a href=""https://medium.com/@PaulinaSadowska/writing-unit-tests-on-asynchronous-events-with-rxjava-and-rxkotlin-1616a27f69aa"" rel=""nofollow noreferrer"">https://medium.com/@PaulinaSadowska/writing-unit-tests-on-asynchronous-events-with-rxjava-and-rxkotlin-1616a27f69aa</a> (Passing Schedulers to ViewModel)</p>

<p>In both approaches, it says to use <strong>Schedulers.trampoline()</strong> in test method. But it still throwing the error.</p>

<p>I'm running out of options, couldn't figure out why this happening.</p>

<p>Can someone help me?</p>

<p>Thanks.</p>
",7173179,,7173179,,2019-10-22 21:30:55,2019-10-22 21:30:55,Schedulers.io() Throwing NullPointerException in my Unit Tests,<android><unit-testing><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
58733432,1,0,0,2019-11-06 15:22:43,,0,194,"<p>I have this Android Kotlin code with a list of completables that are merged into a bigger one with <code>mergeDelayError()</code>, that has a timeout. When the timeout is reached, I get <code>java.util.concurrent.TimeoutException: The source did not signal an event for 250 milliseconds and has been terminated.</code></p>

<p>How can I tell which one of the small completables on the list reached the timeout without signaling/emitting anything (the actual list has more than two BTW). My ideal solution would replace such exception with something like: <code>Exception: The following operations reached a timeout: Check initial settings, Check server</code>, or at least an specific log line printed out by each timed-out completable.</p>

<p>I have no idea how to do this. My first guess would be simply adding a ""didEmit""  flag to each completable and check them one by one when the timeout is reached on the big completable, but it seems like a bad solution to me. </p>

<p>Any ideas appreciated. Thank you.</p>

<pre><code>        val smallCompletable1 = controller
        .checkInitialSettings()
        .doOnError {
            logError(it)
        }
        .ignoreElement()

        val smallCompletable2 = controller
        .checkServerStatus()
        .doOnError {
            logError(it)
        }
        .ignoreElement()

        val myCompletables: List&lt;Completable&gt; = listOf(
            smallCompletable1,
            smallCompletable2
        )

        val bigDisposable = Completable
        .mergeDelayError(myCompletables)
        .timeout(250, TimeUnit.MILLISECONDS)
        .subscribe(this::handleAllSucceeded, this::handleError)

        composition.add(bigDisposable)
</code></pre>
",1152134,,0,,,2019-11-06 18:33:43,How to tell which Completables in a mergeDelayError did not signal on timeout,<android><observable><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
58788392,1,0,0,2019-11-10 11:55:26,,1,46,"<p>How to get value <code>time</code> from this code </p>

<pre><code>val TAG = MainActivity::class.java.name
TrueTimeRx.build()

    .initializeRx(""time.google.com"")

    .subscribeOn(Schedulers.io())

    .subscribe({ time -&gt;
        Log.v(TAG, ""TrueTime was initialized and we have a time: $time"") },
        { throwable -&gt; throwable.printStackTrace() }

    )
</code></pre>

<p>and put it in this code</p>

<pre><code>helloWorld=findViewById(R.id.helloWorld)

val newTime=getString(R.string.hello, time)
helloWorld.text=newTime
</code></pre>

<p>how to take <code>time</code> from the first part of the code and to put it in the second</p>

<p>code above is in <code>onCreate()</code></p>

<p>and if it's important i have this </p>

<pre><code>internal lateinit var helloWorld: TextView
</code></pre>
",12343312,,9968399,,2019-11-10 12:32:54,2019-11-10 12:55:14,How to pass value,<android><kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
58795905,1,58796309,0,2019-11-11 05:21:00,,1,334,"<p>I've created rx function to call a network call from <code>view-model</code> in android, it parses network on main thread function. </p>

<p>I just change few line of code it worked. but i need to know the reason for this because its use same builder pattern to create a <code>rx-call</code>.
once I tried with changing <code>.doOnSubscribe()</code> ,<code>doOnComplete ()</code>           , <code>.applySchedulers()</code> after the flatmap call it worked? how is  this happened?</p>

<pre><code>fun loadjobs(var countryID:String){
subscription.add(
repository.getMainJobsFromLocal(countryID)
          .doOnSubscribe { postProgress(StatusModel(Status.IN_PROGRESS))}
          .doOnComplete { postProgress(StatusModel(Status.COMPLETED)) }
          .applySchedulers()
          .flatMap {
           if (it.isNullOrEmpty()) {
              repository.getMainJobsFromServer(countryID)
           } else {
              Flowable.just(Response.success(it))
           }
          }
          .subscribe({
            if (it.isResponseOk()) {
             postProgress(StatusModel(Status.SUCCESS))
             mainJobResponse.postValue(it.body())
           } else {
             postProgress(StatusModel(Status.FAILED))
             mainJobResponse.postValue(null)
           }
          }, {
           postProgress(StatusModel(Status.FAILED))
           mainJobResponse.postValue(null)
        }))
}


fun loadjobs(var countryID){
subscription.add(
repository.getMainJobsFromLocal(countryID)
          .flatMap {
           if (it.isNullOrEmpty()) {
             repository.getMainJobsFromServer(countryID).flatMap {
               Flowable.just(it)
             }
           } else {
             Flowable.just(Response.success(it))
           }
          }.doOnSubscribe { postProgress(StatusModel(Status.IN_PROGRESS)) }
            .doOnComplete { postProgress(StatusModel(Status.COMPLETED)) }
            .applySchedulers()
            .subscribe({
              if (it.isResponseOk()) {
                postProgress(StatusModel(Status.SUCCESS))
                mainJobResponse.postValue(it.body())
               } else {
               postProgress(StatusModel(Status.FAILED))
               mainJobResponse.postValue(null)
              }
           }, {
            postProgress(StatusModel(Status.FAILED))
            mainJobResponse.postValue(null)
    }))
}
</code></pre>
",8415366,,2185295,,2019-11-11 06:27:43,2019-11-11 06:27:43,Retrofit - android.os.NetworkOnMainThreadException with RxKotlin,<android><android-viewmodel><flatmap><rx-kotlin>,2,2,0,,,CC BY-SA 4.0
59091578,1,59100045,0,2019-11-28 14:58:57,,1,91,"<p>To start I have the following Moshi json.</p>

<pre><code>@JsonClass(generateAdapter = true)
data class OrderDetails(
    @Json(name = ""_id"") val id: Int,
    @Json(name = ""status"") val status: String,
    @Json(name = ""tableNo"") val tableNo: Int,
    @Json(name = ""serverId"") val serverId: Int?,
    @Json(name = ""items"") val orderItems: List&lt;OrderDetailsItem&gt;
)
</code></pre>

<p>All these fields are expected to have data except for serverId.
This data is fetched from the server where I can allow the user to select order.</p>

<pre><code>onSeletedOrder
   .map { it.orderDetails.serverId } //blows up here apparently.
   .filterNotNull() //have tried this but it doesn't matter.
   .flatMap { findServerBy(it) }
   .map { ""${it.firstname} ${it.lastname}"" }
</code></pre>

<p>When I map to the serverId above I blow up with an NPE.
It's interesting that the map (even though it is optional) does an unsafe cast afterwards.
I'd expect it to maintain the optional-ness after the map.
I'm assuming this is because of the bridging backwards to RxJava.
Curious if anyone has a further explanation on why this is.</p>
",647323,,61158,,2019-11-28 17:01:51,2019-11-29 07:44:37,Unexpected NullPointException with RxKotlin when mapping optionals,<kotlin><rx-java2><rx-kotlin2>,3,3,0,,,CC BY-SA 4.0
59104815,1,59104982,0,2019-11-29 12:27:22,,1,57,"<p>I have this function which gets a parameter and first checks for its value. if it was null then gets its value from the result of fisrtFun() which returns a Single&lt; String>.</p>

<p>after that either that parameter was null or not, it returns the result of secondFun() which gets that parameter as input</p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    return if (userId == null) {
        firstFun().flatMap { id-&gt;
            secondFun(id)
        }
    } else {
        secondFun(id)
    }
}
</code></pre>

<p>But as you see I used if-else blocks and have written secondFun() multiple times</p>

<p>so I tried to make it cleaner </p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    val id = userId ?: fisrtFun().blockingGet()!!
    return secondFun(id)
}
</code></pre>

<p>I want to know if there is a better way to achieve this functionality without using blockingGet() to avoid blocking the thread </p>
",8838667,,0,,,2019-11-29 12:38:33,How to make this block of code written with RxKotlin cleaner and avoid blocking thread?,<android><kotlin><reactive-programming><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
59352476,1,0,0,2019-12-16 07:56:18,,0,62,"<p>I have PublishSubject for observing status change and also I have method with multiple steps, which I execute in another thread. How I can force stop this thread when subject received changes?</p>
",7185703,,0,,,2019-12-16 08:24:12,How to force stop thread,<android><multithreading><kotlin><rx-java><rx-kotlin>,1,1,0,,,CC BY-SA 4.0
59408362,1,0,0,2019-12-19 11:02:03,,0,96,"<p>I am trying to get my head around error handling in rxjava. I thought if i combine a stream of observables for instance in a zip() function that errors emitted by the observables within the zip would break the sequence and bubble up to the  subscriber onError function. However the only error caught there are the ones emmitted in the BiFunction. Errors emitted up the chain causes the system to crash. when i add onErrorReturn to the observable and return a fallback value the system still crashes. So for me that does not work as I expected. What am I missing?</p>

<pre><code>private fun getOneThing (): Single&lt;String&gt; {
    println(""getOneThing"")
    if (isOneBadCondition) {
        throw Exception()      //causes crash
    } else {
        return Single.just(""a string thing"")
    }

}

private fun getAnotherThing(): Single&lt;Boolean&gt; {
    println(""getAnotherThing"")
    if (isAnotherBadCondition) {
        throw Exception()   //causes crash
    } else {
        return Single.just(true)
    }
}

private fun createSomethingElse (): Int {
    println(""createAnother"")
    if (isBadCondition) {
        throw Exception()   //is handled onError
    } else {
        return 2
    }
}

fun errorHandlingTest() {
    Single.zip(
        getOneThing(),           //if I add onErrorReturn here it is not called after error
        getAnotherThing(),       //if I add onErrorReturn here it is not called after error
        BiFunction&lt;String, Boolean, Int&gt; { t1, t2 -&gt;
            createSomethingElse()
        }
    ).subscribeBy(
        onSuccess ={ println(it) },
        onError={ it.printStackTrace() })  //only error thrown by createSomethingElse() are caught here
}
</code></pre>
",1027594,,0,,,2019-12-19 11:02:03,error not bubbling up from observables in rxjava zip function,<error-handling><rx-java2><rx-kotlin2>,0,3,0,,,CC BY-SA 4.0
59523262,1,59525955,0,2019-12-29 21:02:42,,1,259,"<p>TL;DR Looking for recommendations on robust offline support using rx-kotlin. </p>

<p>I've followed a nice <a href=""https://medium.com/@eslam.hussein/dominate-remote-local-data-with-rx-retrofit-room-mvp-f2b13a0ac27b"" rel=""nofollow noreferrer"">guide on offline-support in Android apps</a>. 
It works like this: </p>

<ol>
<li>Load data from the Internet, go to step 3 if error</li>
<li>Store the data in the local database</li>
<li>Load the data from the local database</li>
<li>Display the data in the UI</li>
</ol>

<p>The code is:</p>

<pre><code> Observable.mergeDelayError(
                loadRemoteData()
                    .doOnNext { writeDataToLocalDatabase(it) }
                    .subscribeOn(Schedulers.io()), 
                loadDataFromLocalDatabase()
                    .subscribeOn(Schedulers.io())
            )
</code></pre>

<p>Unfortunately, this approach relies on the database code always working. If the database operations for some reason fail, everything fails, even when the data is loaded successfully from the remote server.</p>

<p>Is there a way I can achieve the following using rx-kotlin/rx-java?:</p>

<ol>
<li>Load data from the Internet, go to step 3 if error</li>
<li>Store the data in the local database</li>
<li>Load the data from the local database</li>
<li><strong>(if steps 2 or 3 failed) Use the data from step 1</strong></li>
<li>Display the data in the UI</li>
</ol>

<p>I'd like to avoid loading the data from the Internet twice. I'm using room + retrofit, if that matters.</p>

<p>EDIT:
Thanks to @MinseongPark, I ended up with the code below. 
The mergeDelayError reports an error only if both the remote and the local source fails, and if the <em>writeDataToLocalDatabase</em> method fails (throws an Exception), then that does not keep the remote data from being reported to the UI. The information about errors in <em>writeDataToLocalDatabase</em> is saved by reporting it  remotely. 
Now, the code is robust to one of the two sources failing, and to writing new entries to the database failing. </p>

<pre><code>        return Observable.mergeDelayError(
            loadRemoteData().doOnNext {
                try {
                    writeDataToLocalDatabase(it)
                } catch (error: Throwable) {
                    Timber.d(error)
                    Crashlytics.logException(error)
                }
            },
            loadDataFromLocalDatabase()
        )
            .subscribeOn(Schedulers.io())
</code></pre>
",788913,,788913,,2019-12-31 16:28:21,2019-12-31 16:28:21,How to implement robust offline support with rx-kotlin?,<android><rx-java><rx-kotlin>,1,3,0,,,CC BY-SA 4.0
59536511,1,0,0,2019-12-30 20:28:20,,1,33,"<p>I wanna fetch data from roomDB when variable changed. When folderName changed and when task changed.
I use <code>MediatorLiveData</code>, but it doesn't work.
How can I fix it?</p>

<p>This is a view model class.</p>

<pre><code> val folderName = ViewModelFolder.selectedFolder // MutableLiveData&lt;String&gt;
 val filteredTasks = MediatorLiveData&lt;LiveData&lt;List&lt;Task&gt;&gt;&gt;()
 init {
   filteredTasks.addSource(folderName) { name -&gt;
     filteredTasks.value = getTasksByFolderIsDone(name, false)
   }
}
</code></pre>

<p>Main activity</p>

<pre><code>taskViewModel.filteredTasks.observe(viewLifecycleOwner, Observer { tasks -&gt;
  tasks?.let { taskAdapter.setTasks(tasks as List&lt;Task&gt;) }
})
</code></pre>
",7359831,,0,,,2019-12-30 20:28:20,Android: want to fetch data from roomDB when 2 variables changed,<android><kotlin><android-room><rx-kotlin>,0,2,0,,,CC BY-SA 4.0
59708108,1,59708986,0,2020-01-12 21:03:49,,2,1150,"<p>I have a problem and I don't know how to resolve it with a better aproach. The problem is that I'm requesting to Spotify Web API and in some methods the artist image is returned and in others only basic artist info is obtained.</p>

<p>I have this two methods:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;SpotifyAlbumDTO&gt;

fun getArtist(artistId: String): Single&lt;SpotifyArtistDTO&gt;
</code></pre>

<p>When I get an album, the artist info doesn't contains the artist image url. So, I need to call the getAlbum() method and use the result to obtain the artistId and then call to getArtist() method. </p>

<p>I have the following method to do all this stuff:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;Album&gt;
</code></pre>

<p>On this method I need to call the previous two to return an Album object (my domain object). The only solution that worked for me it's the following:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;Album&gt; {
  return Single.create { emitter -&gt;
    _spotifyService.getAlbum(albumId).subscribe { spotifyAlbum -&gt;
      _spotifyService.getArtist(spotifyAlbum.artist.id).subscribe { spotifyArtist -&gt;
        val artistImage = spotifyArtist.imageUrl
        spotifyAlbum.artist.image = artistImage
        emitter.onNext(spotifyAlbum.toAlbum())
      }
    }
  }
}
</code></pre>

<p>I think that must exist another better way to do this than concating subscribe calls in other subscribes and creating deeper calls. I also try the following:</p>

<pre><code>_spotifyService.getAlbum(albumId).flatMap { spotifyAlbum -&gt;
  _spotifyService.getArtist(spotifyAlbum.artist.id)
}.flatMap { spotifyArtist -&gt;
  // Here I don't have the album and I can't to asign the image         
}
</code></pre>
",3828964,,0,,,2020-01-13 10:33:15,RXJava/Kotlin - Chaining Single results in one,<rx-java><system.reactive><rx-kotlin>,2,0,1,,,CC BY-SA 4.0
59775506,1,0,0,2020-01-16 18:09:01,,2,517,"<p>So I have the following test that keeps failing with the following error: </p>

<blockquote>
  <p>java.lang.AssertionError: No values (latch = 1, values = 0, errors = 0, completions = 0) </p>
</blockquote>

<pre><code>val ocrProcessor = mockk&lt;FirebaseFormProcessor&gt;()
        val date = listOf(DateTextExtraction())

        every { ocrProcessor.scan(any(), any(), any()) } answers {
            thirdArg&lt;OcrResultCallback&gt;().invoke(date)
        }

        viewModel = FormViewModel(ocrProcessor)

        viewModel.addImage(bitmap)

        viewModel.ocrAlert
            .test()
            .assertValue {
                it == date
            }
            .addTo(disposeBag)
</code></pre>

<p>What this tries to test is the following:</p>

<pre><code>override val ocrAlert: PublishSubject&lt;List&lt;TextExtractionInterface&gt;&gt; = PublishSubject.create()

override fun addImage(bitmap: Bitmap) {
    if (files.value.isEmpty())
        ocrProcessor.scan(bitmap, extract = textExtractionItems) { ocrResult -&gt;
            ocrAlert.onNext(ocrResult)
        }
}
</code></pre>

<p>I am not quite sure what I am doing wrong here but I think it might have to do with threading problems.</p>

<p>edit:</p>

<p>I changed the code to this now:</p>

<pre><code>        val toBeTested = viewModel.ocrAlert
            .subscribeOn(scheduler)
            .observeOn(scheduler)
            .test()

        viewModel.addImage(bitmap)

         toBeTested   
            .assertValue {
                it == date
            }
            .addTo(disposeBag)
</code></pre>
",1453253,,1453253,,2020-01-20 11:09:31,2020-01-20 11:09:31,UnitTesting async code rxjava/rxkotlin fails with latch = 1 error,<android><rx-java2><rx-kotlin>,0,16,1,,,CC BY-SA 4.0
59874945,1,59878149,0,2020-01-23 09:14:08,,0,97,"<p>I want to print at a time of ArrayList.</p>

<p>Before:</p>

<pre><code>class ExampleUnitTest {
    @Test
    fun test(){
        val stringArray = arrayOf(""10"", ""20"", ""30"", ""40"", ""30"", ""20"", ""10"", ""5"", ""20"", ""30"", ""20"", ""30"").map { it }
        println(stringArray.toString())
    }
}

# output is :
[10, 20, 30, 40, 30, 20, 10, 5, 20, 30, 20, 30]
</code></pre>

<p>After:</p>

<pre><code># I Want to output Like this :
10, 20, 30, 40, 30, 20, 10, 5, 20, 30, 20, 30
</code></pre>

<p>How can I do this coding by Reactivex Java(RxJava)</p>

<pre><code># something like... e.g..
Observable ...{
   ... ...
}.subscribeOn(Schedulers.io())
.subscribe({
   ... ...
})
</code></pre>
",12029427,,0,,,2020-10-10 02:07:10,Kotlin: How to Output at a time the ArrayList from Rxjava,<java><android><kotlin><rx-java><rx-kotlin>,2,1,0,,,CC BY-SA 4.0
60065075,1,60095956,0,2020-02-04 20:28:02,,1,62,"<p>Good afternoon.
So I got a list with a list inside like this:</p>

<pre><code>    {
  ""category"" : [
    {
      ""name"": ""Bathroom"",
      ""products"": [
        {
          ""name"": ""Sink01""
        },
        {
          ""name"": ""Shower01""
        }
      ]
    },{
      ""name"": ""Kitchen"",
      ""products"": [
        {
          ""name"": ""Table""
        },
        {
          ""name"": ""Stove""
        }
      ]
    }
  ]
}
</code></pre>

<p>So if the user for example selects the category ""Bathroom"" I want to use rxjava to filter the list of products from the category ""Bathroom"" and if they select the category ""Kitchen"" I want to get the list of products from the category ""Kitchen"".</p>

<p>This is what I've tried so far:</p>

<pre><code>    fun getProducts(category: Category): Single&lt;MutableList&lt;Product&gt;&gt; {
         return service.getProductsByCategories().filter{ response -&gt;
             response.categoriesList.forEach {
                if (it.name == category.name) {
                  category.products
                }
             }
         }
    }
</code></pre>

<p>Right now I am getting ""Typed mismatch. Requieres: <code>Single&lt;MutableList&lt;Product&gt;&gt;</code>, Found: <code>Maybe&lt;MyResponse!&gt;!</code>""</p>

<p>Why is this happening?
What is the correct way to filter?</p>

<p>Thanks in advance.</p>

<p>Greetings</p>
",1344550,,61158,,2020-02-06 14:29:44,2020-02-06 14:29:44,How to do the filter operator from a list of a list in rxjava,<kotlin><rx-java><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
60088358,1,0,0,2020-02-06 05:41:04,,0,78,"<p>I want to emit events after non periodic intervals and I want to set the interval for emission of each event programatically using Rxjava in Android. How do I do that?</p>
",12759574,,208273,,2020-03-12 03:53:25,2020-03-12 03:53:25,Emit events after non periodic intervals using rx java,<java><android><rx-java><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
60162061,1,60162271,0,2020-02-11 04:31:21,,3,1218,"<p>I am calling one api which gives Http status code 400 </p>

<p>This is my NetworkBoundResourceNoDb</p>

<pre><code>public abstract class NetworkBoundResourceNoDb&lt;RequestType&gt; {

    private Observable&lt;Resource&lt;RequestType&gt;&gt; result;

    @MainThread
    protected NetworkBoundResourceNoDb() {
        Observable&lt;Resource&lt;RequestType&gt;&gt; source;
        source = createCall()
            .subscribeOn(Schedulers.io())
            .doOnError(t -&gt; onFetchFailed())
            .observeOn(AndroidSchedulers.mainThread());

        result = Observable.ambArray(source);
    }


    public Observable&lt;Resource&lt;RequestType&gt;&gt; getAsObservable() {return result;}

    protected boolean onFetchFailed() {
        return false;
    }


    @NonNull
    @MainThread
    protected abstract Observable&lt;Resource&lt;RequestType&gt;&gt; createCall();
}
</code></pre>

<p>This is API code </p>

<pre><code>@GET(""api/content/count"")
Observable&lt;List&lt;WordCountData&gt;&gt; wordCount();
</code></pre>

<p>This is repository Function</p>

<pre><code>    fun wordCount(): Observable&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt;? {
    return object : NetworkBoundResourceNoDb&lt;List&lt;WordCountData&gt;&gt;() {

        override fun createCall(): Observable&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt; {
            return courseApi.wordCount()
                .flatMap { learntWords -&gt;
                    Observable.just(
                        if (learntWords == null) Resource.error("""", emptyList())
                        else Resource.success(learntWords)
                    )
                }
        }

    }.asObservable
}
</code></pre>

<p>This is viewmodel Code</p>

<pre><code>private var wordCount = MutableLiveData&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt;()

fun getWordCountLiveData() = wordCount

fun getWordCountList() {
    courseRepository.wordCount()?.subscribe { resource -&gt; getWordCountLiveData().postValue(resource) }
}
</code></pre>

<p>This is my view code</p>

<pre><code>private fun loadWordCount() {
    crViewModel = ViewModelProviders.of(this, viewModelFactory).get(CrViewModel::class.java)
    crViewModel.getWordCountLiveData().observe(this, androidx.lifecycle.Observer {
        resource -&gt; when {
        resource.isLoading -&gt; println(""loading"")
        resource.data != null -&gt; {
            drawChart(resource.data)
        }
        else -&gt; handleErrorResponse()
    }
    })
    crViewModel.getWordCountList()
}
</code></pre>

<p>I need to pass Http Status code to view. i am able to get the error in onFetchfailed in repository while implementing it with throwable parameter but not able to handle it after that</p>

<p>it gives  me ""io.reactivex.exceptions.OnErrorNotImplementedException: HTTP 400 "" Error</p>

<p>please help me thanks in advance  </p>
",6846277,,0,,,2020-02-11 04:58:46,Error Handling of Rxjava in mvvm using retrofit,<android><mvvm><retrofit><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
60227089,1,0,0,2020-02-14 13:15:12,,0,77,"<p>In the android app, the process goes like that: at first, I fetch notes from local SQLite and then make Http calls for each note. I use composite disposable to hold all disposables and release them when activity is destroyed. The code looks something like that:</p>

<pre><code>class MyActivity : AppCompatActivity(){
    var compositeDisposable = CompositeDisposable()

    override fun onResume(){
        updateDatabaseData()
    }

    fun updateDatabaseData(){
        compositeDisposable.add(
            Observable.fromCallable{
                fetchDataFromDatabase()
            }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .flatMap{
                Observable.fromIterable(it)
            }
            .flatMap{
                getUpdateStateObservable(it) // make remote HTTP call for every note in the list from local DB
            }
            .subscribe()
        )
    }

    fun getUpdateStateObservable(note:Note):UpdatedNote{
        Observable.fromCallable(
             // make HTTP call and build some UpdatedNote
        )
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
    }

    fun fetchDataFromDatabase():List&lt;Note&gt;{
        // fetch data from local DB
    }
}
</code></pre>

<p>And this code worked well until the moment when internet connection is lost. So every time HTTP calls in method <code>getUpdateStateObservable</code> is made an error is thrown. And <em>sometimes</em> it results in <code>io.reactivex.exceptions.UndeliverableException</code> pointing at line where network error in <code>getUpdateStateObservable</code> happens. And <em>sometimes it's not</em>. I've tried to use not a pool of threads but a single one as <code>Schedulers.single()</code> when making the HTTP request. And this works well. However, I'd like to process all those requests concurrently to speed them up.</p>

<p>Thanks</p>
",12898466,,9141664,,2020-02-14 13:58:39,2020-02-14 13:58:39,Why do I get UndeliverableException,<java><android><kotlin><rx-java2><rx-kotlin2>,0,2,0,,,CC BY-SA 4.0
60256254,1,0,0,2020-02-17 05:10:11,,0,118,"<p>I am getting:</p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: The exception
  was not handled due to missing onError handler in the subscribe()
  method call</p>
</blockquote>

<p>I had tried to add</p>

<pre><code>.doOnError { error -&gt;
            Log.i(""reverser code error"",error.localizedMessage)
       }.onErrorReturn { err -&gt;
          ""Return method""
     }
</code></pre>

<p>But it's not working.</p>
",8946399,,9141664,,2020-02-17 05:15:47,2020-02-17 05:37:59,How to handle errors on RxKotlin + Graphql,<android><kotlin><graphql><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
60367289,1,60367442,0,2020-02-23 22:01:04,,0,122,"<p>I'm trying to implement redux state update pattern using RXJava</p>

<pre><code>val subject=PublishSubject.create()
val subject1=PublishSubject.create()

// multiple threads posting 
// on subject and subject1 here. Concurrently 


subject.mergeWith(subject1)
       .scan(
             getInitState(),
             {state, event -&gt;
               // state update here 
             }
         )
        .subscribe({state -&gt;
          // use state here
        })
</code></pre>

<p>As you can see, I'm using <code>scan</code> operator to maintain the state. </p>

<p>How can I be sure that the state updates happen sequentially even when multiple threads are producing events? </p>

<p>Is there some mechanism in <code>scan</code> operator which makes the events stand in some queue while waiting for current state update function to finish?</p>

<p><strong>What I have done:</strong></p>

<p>I have successfully implemented this pattern in Android environment. It's really easy because if you always do the state update in </p>

<p><code>AndroidSchedulers.mainThread()</code> </p>

<p>And make state object immutable you are guaranteed to have atomic and sequential state update. But what happens if you don't have dedicated scheduler for state updates? What if you are not on Android?</p>

<p><strong>What I have researched:</strong></p>

<ul>
<li><p>I have read the source code for <code>scan</code> operator and there is no
waiting ""queue"" involved. Just simple state update and emission</p></li>
<li><p>I have also read SerializedSubject source code. There indeed is a waiting queue which serializes emissions. But what happens if I have two subjects? Serializing both of them doesn't mean that they don't interfere with each other.</p></li>
</ul>
",3904645,,0,,,2020-02-23 22:32:47,Ensure sequential state update when using RXJava scan operator,<android><redux><rx-java2><rx-android><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
60603996,1,0,0,2020-03-09 15:44:10,,3,65,"<pre><code>RxJava 2
</code></pre>

<p>I have the following where I am subscribing to 2 observables it works ok. I don't think its the best way. </p>

<p>I only want to subscribe to the second one <code>getSalesInfo</code> if the first one <code>getProductDetails</code> meets a condition. This is just a sample of what I am trying to do. If the condition is not met then nothing more will happen. </p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    getProductDetails()
            .subscribeBy { productDetails -&gt;
                if (productDetails.productID == 1234) {
                    getSalesInfo().subscribeBy {
                        getSalesInfo()
                                .subscribeBy { saleInfo -&gt;
                                    println(saleInfo.salesReference)
                                }
                    }
                }
            }
}

fun getProductDetails(): Observable&lt;ProductDetails&gt; =
        Observable.just(ProductDetails(1234, ""Product One""))

fun getSalesInfo(): Observable&lt;SaleInfo&gt; =
        Observable.just(SaleInfo(""Sales Reference 1""))

data class ProductDetails(val productID: Int,
                          val productDescription: String)

data class SaleInfo(val salesReference: String)
</code></pre>

<p>Another alternative I have found is using <code>flatmap</code> that will return the second <code>SaleInfo</code> observable. I have to return a empty Observable in the else condition which doesn't look right. Is there a better way?</p>

<pre><code>getProductDetails()
            .flatMap { productDetails: ProductDetails -&gt;
                if (productDetails.productID == 1234) {
                    getSalesInfo()
                }
                else {
                    Observable.empty()
                }
            }
            .subscribeBy { saleInfo -&gt;
                println(""Using flatmap ${saleInfo.salesReference}"")
            }
</code></pre>

<p>Many thanks for any suggestions</p>
",70942,,70942,,2020-03-09 15:58:56,2020-03-12 17:56:16,Subscribing to 2 observables but only subscribe to the second one if a condition is true for the first one,<rx-java2><rx-kotlin2>,1,2,0,,,CC BY-SA 4.0
60652490,1,0,0,2020-03-12 10:47:27,,0,123,"<p>I have a function in repository that calls three APIs which return three different type of Objects. </p>

<pre><code>fun scanSource(code: String) =
    firstApi.DataV11Get(code)
        .flatMap {
            firstApi.sccGet(it.sscc)
        }
        .flatMap {
            lastApi.lsccGet(it.id)
        }
</code></pre>

<p>currently it is only returning the result of last API in the ViewModel .Now I want to have result of all of these in viewmodel.</p>

<p>plus the api must be sequential as they are using the data from the last API.</p>

<p>Also each API returns a different Object type.And I want all of three objects once all three calls are finished.</p>

<p>Thanks</p>
",2877863,,0,,,2020-03-12 10:59:50,Combine three APIs' result in RxKotlin,<android><kotlin><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
60653309,1,60655058,0,2020-03-12 11:34:31,,0,380,"<p>I am trying to parse the data from the server to my mobile device and I am using <code>Rx</code> , <code>Kotlin</code> , <code>retrofit</code> for this </p>

<p><strong>ApiInterface.kt</strong></p>

<pre><code>@GET(""api/v1/admin/class/getUsers/learner/{classId}"")
    fun getStudentsRx(
        @Header(""access_token"") accessToken: String,
        @Path(""classId"") apiKey: String
    ): Observable&lt;StudentResultResponse&gt;
</code></pre>

<p><strong>I am trying to subscribe as follows:</strong></p>

<pre><code> private fun getServerDataDisposable(dataService: ApiInterface): Disposable {
        return dataService.getStudentsRx(accessToken,classId)
            .subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeWith(object: DisposableSingleObserver&lt;List&lt;StudentModel&gt;&gt;(), Observer&lt;StudentResultResponse&gt; {

                override fun onSuccess(movies: List&lt;StudentModel&gt;) {
                }

                override fun onError(e: Throwable) {

                }

                override fun onChanged(t: StudentResultResponse?) {
                    TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.
                }

            })
    }
</code></pre>

<p><strong>I am getting error:</strong></p>

<p><a href=""https://i.stack.imgur.com/AaAyf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AaAyf.png"" alt=""enter image description here""></a></p>
",1083093,,0,,,2020-03-12 13:23:28,Using Observable in Kotlin to parse a API response,<android><kotlin><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
60796695,1,0,0,2020-03-22 06:54:06,,0,100,"<p>I am new to Rx and I am making one API call using Rx. It is working but the problem is that it is continuously making the API after I received response or error. I am using the MVVM pattern. </p>

<p>Here is my code how I am observing result in View Model:</p>

<pre><code>val usersList = getGitHubUsersUseCase.getUsers(since.toInt())

        usersList?.subscribeOn(Schedulers.io())
            ?.observeOn(AndroidSchedulers.mainThread())
            ?.subscribe({
                if (it.error == null) {
                    var sinceState = SinceState(since, since.isNotEmpty(), it.users)
                    stateLiveData.postValue(sinceState)
                } else {
                    var sinceState =
                        SinceState(since, since.isNotEmpty(), emptyList(), it.error?.message)
                    stateLiveData.postValue(sinceState)
                }
            }, {
                var sinceState = SinceState(since, since.isNotEmpty(), emptyList(), it.message)
                stateLiveData.postValue(sinceState)
            })
</code></pre>

<p>How do I stop observing once I received a response or an error? Am I missing something?</p>

<p>If I don't stop this continuously making calls, then it makes too many API calls and server start returning:</p>

<blockquote>
  <p>HTTP 403 forbidden</p>
</blockquote>
",4623481,,391691,,2020-03-23 00:01:08,2020-03-23 00:01:08,Android KotlinRx API call making continuously in background,<android><kotlin><rx-kotlin><rx-kotlin2>,1,4,0,,,CC BY-SA 4.0
60905481,1,60930218,0,2020-03-28 18:54:21,,0,44,"<p>I'm failing to get into the ReactiveX mindset or the codebase I am working in is just poorly written.</p>

<p>Suppose I have some Observable A() and I need data from another Observable B() in order to do validation on data coming through A, how do I accomplish this in RxJava (would prefer RxKotlin implementation). Note that both A and B return a Single of a List of objects.</p>

<pre><code>fun B(): Single&lt;List&lt;Bar&gt;&gt; {
  ...
}

fun A() : Single&lt;List&lt;Foo&gt;&gt; {
  Single.just(readRecords()).map { record -&gt;
    // val bar = B.getAll()??? This seems like an anti-pattern and I'm not sure if it would necessarily be right to .subscribe()???

    if (bar.contains(record)) {
      // ... some validation
    }
  }
}
</code></pre>

<p>Update 1: Should emphasize that the validation requires multiple sources so you could have B, C, D, etc.</p>
",10303350,,10303350,,2020-03-30 13:55:31,2020-03-30 14:19:00,Using data from another observable,<rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
61030178,1,61041175,0,2020-04-04 15:12:02,,0,60,"<p>I'm new to RxJava and after a few days of trying everything I could find online I see that I really need help with this one.</p>

<p>I fetch a member in my repository with local and remote sources. I added some operators to return my remote source in priority (via debounce), and to filter out errors so it would return only 1 of the 2 if either remote is not available or the database is empty.</p>

<p>It works fine as long as something is returned by one of my 2 sources, but the problem occurs if both sources returns errors: as I filter out the errors, it doesn't return anything, and my subscribe is never called.</p>

<p>Maybe there is a simple solution but I have not found it so far, could someone help?</p>

<p>Here is my fetchMember() in my Repository:</p>

<pre><code>override fun fetchMember(): Observable&lt;MemberModel?&gt; {
    return Observable.concatArrayDelayError(memberLocalSource.fetchMember(), memberRemoteSource.fetchMember())
            .doOnNext { member -&gt;
                saveMember(member!!)
            }
            .materialize()
            .filter { !it.isOnError }
            .dematerialize { it -&gt; it }
            .debounce(400, TimeUnit.MILLISECONDS)
   }
</code></pre>

<p>And here is my viewmodel:</p>

<pre><code>fun fetchToken(username: String, password: String) {
    val loginDisposable = authApiService.loginWithJWT(username, password)
            .flatMap {
                isAuthenticated = isTokenValid(username, password, it)
                sharedPreferences.setHasValidCredentials(isAuthenticated)
                memberRepository.fetchMember()
            }
            .subscribeOn(Schedulers.io())
            .observeOn((AndroidSchedulers.mainThread()))
            .doOnError { throwable -&gt;
                throwable.printStackTrace()
            }
            .subscribe(
                    { member -&gt; 
                        memberLiveData.value = member
                        this.memberId = member!!.id.toString()
                        this.memberName = member.name.split("" "")[0]
                        if(isAuthenticated) {
                            authenticationState.value = AuthenticationState.AUTHENTICATED_VALID_MEMBER
                        } else {
                            authenticationState.value = AuthenticationState.UNAUTHENTICATED_VALID_MEMBER
                        }
                    },
                    { error -&gt;
                        if(isAuthenticated) {
                            authenticationState.value = AuthenticationState.AUTHENTICATED_INVALID_MEMBER
                        } else {
                            authenticationState.value = AuthenticationState.INVALID_AUTHENTICATION
                        }
                    })
    disposable.add(loginDisposable)
}

private fun isTokenValid(username: String, password: String, authResponse: AuthModel): Boolean {
    return if (authResponse.data != null) {
        false
    } else {
        tokenInterceptor.token = authResponse.token
        val tokenWithCredentials = AuthModel(authResponse.token, null, null, username, password)
        tokenRepository.saveToken(tokenWithCredentials)
        true
    }
}
</code></pre>
",2017921,,2017921,,2020-04-05 07:45:11,2020-04-05 10:27:54,RxJava ConcatArrayDelayError and filters: returning an error only if both sources fail,<android><observable><rx-java2><repository-pattern><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
61201439,1,61202156,0,2020-04-14 05:49:47,,1,70,"<p>Trying to come with a offline-first app, I managed to make a working repository pattern which first check the cache, then the database and finally, the api. I do that like this:</p>

<pre><code>private fun cachedTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }
private fun databaseTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }
private fun apiTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }

Maybe.concat(cachedTopics(), databaseTopics(), apiTopics())
     .firstOrError()
     .subscribeOn(scheduler)
</code></pre>

<p>Now, the thing is that I save partial data in the database (not all topics). If a user is connected to internet and browse the data displayed will only be the data in the database. But that's not all the content a user should access (if they are connected to internet). I'm aware this is due to the <code>.firstOrError()</code> call.</p>

<p><strong>But I wonder if there is a way to concatenate the distinct results of database + api (api might fail and thus return 0 results) and return a Single.</strong> </p>

<h2>Edit</h2>

<p>To be clearer I want something like the following:</p>

<pre><code>IF CACHE IS NOT EMPTY
   RETURN DISTINCT(DB + CACHE)
ELSE
   UPDATE CACHE WITH API RESULT
   RETURN DISTINCT(DB + API)
</code></pre>

<p>Where API calls will automatically result in having nor results if it fails.</p>
",11269045,,11269045,,2020-04-14 07:02:23,2020-04-14 07:16:25,Repository pattern concatenating results in RXKotlin,<android><kotlin><repository-pattern><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
61225108,1,0,0,2020-04-15 09:11:08,,1,92,"<p>If I have 2 apps and the user had logged in one of them. How can I make the user automatically login in the other app? So, one login in either app is sufficient for accessing both of them.</p>

<p>For e.g. like if I have Amazon app I don't have to login in to my Amazon prime app if I am already logged in Amazon app. </p>
",8416125,,9851608,,2020-04-15 12:05:06,2020-04-15 12:05:06,How to have single login in my all other apps like Amazon do,<android><kotlin><rx-kotlin>,1,4,0,,,CC BY-SA 4.0
61399761,1,61400101,0,2020-04-24 01:48:39,,0,102,"<p>Learning android with a two friends and right now we're focusing on just UI portion. One friend gave us the task of creating a display with dashed line divider. We're trying to add it in the Adapter file so it can be loaded in our fragment as part of the recycler view but can't figure out how.</p>

<p>Here's the layout in where the dotted line drawable gets passed in </p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:app=""http://schemas.android.com/apk/res-auto""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""&gt;
    &lt;ImageView
        android:id=""@+id/dashes""
        android:background=""@drawable/dashes_line""
        android:layout_width=""match_parent""
        android:layout_height=""match_parent""/&gt;
&lt;/LinearLayout&gt;
</code></pre>
",13373484,,13373484,,2020-04-24 02:43:35,2020-04-24 02:43:35,Android line divider,<android><kotlin><android-recyclerview><rx-kotlin><data-class>,2,0,0,,,CC BY-SA 4.0
61443660,1,0,0,2020-04-26 15:49:47,,0,374,"<p>I have a drawable that's being displayed in a layout. The drawable has default properties such as color and width. I'm creating a data class to be able to update those when the recycler view is created. The part that fills in the color in the middle is working. But I'm stuck on how to actually update the drawable width and the ImageView margins from the viewHolder.</p>

<p>mydrawable.xml
    
    
        
    </p>

<p>The layout file</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:app=""http://schemas.android.com/apk/res-auto""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""&gt;
    &lt;ImageView
        android:id=""@+id/rect_outline""
        android:src=""@drawable/mydrawable""
        android:layout_width=""match_parent""
        android:layout_height=""match_parent""
        android:layout_gravity=""center""
        android:layout_marginStart=""12dp""
        android:layout_marginEnd=""12dp""
        app:layout_constraintBottom_toBottomOf=""parent""
        app:layout_constraintEnd_toEndOf=""parent""
        app:layout_constraintHorizontal_chainStyle=""spread""
        app:layout_constraintStart_toStartOf=""parent""
        app:layout_constraintTop_toTopOf=""parent""/&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>The data class</p>

<pre><code>data class ImageData(
    val c: String
    val width: Int
    val marginLeft : Int
</code></pre>

<p>)</p>

<p>MyViewHoler.kt</p>

<pre><code>internal class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
fun bind(item: ImageData) {
   itemView.rect_outline.setColorFilter(Color.parseColor(item.c))

}
</code></pre>

<p>}</p>
",13373484,,0,,,2020-04-26 16:53:44,Update Image width and Margins programmatically,<android><kotlin><android-recyclerview><rx-kotlin><data-class>,1,2,0,,,CC BY-SA 4.0
61450873,1,61450938,0,2020-04-27 02:36:04,,0,93,"<p>I'm trying to convert the input streams into the file. So when user selects 1 image, it all works well. But when user selects multiple images, for example 4 then the below code is not working as expected; I see only 2 files path in Log statement. </p>

<pre><code>
compositeDisposable.add(Observable.fromIterable(inputStreamList)
                .map {
                    FileUtils.saveInputStreamToFile(it, directory, 500)
                }.toList()
                .toObservable()
                .subscribeOn(schedulerProvider.io())
                .subscribe({
                    it.forEach {file-&gt;
                        Log.d(""TAG"", ""Path ${file.path}"")
                    }
                    Log.d(""TAG"", ""Size ${it.size}"")
                }, {

                })
        )

</code></pre>

<p>Here's saveInputStreamToFile method </p>

<pre><code>
fun saveInputStreamToFile(input: InputStream, directory: File, height: Int): File? {
        val currentTime = dateFormat.format(Date())
        val imageName = ""_$currentTime""
        val temp = File(directory.path + File.separator + ""flab\$file\$for\$processing"")
        try {
            val final = File(directory.path + File.separator + imageName + "".$IMAGE_JPG"")
            val output = FileOutputStream(temp)
            try {
                val buffer = ByteArray(4 * 1024) // or other buffer size
                var read: Int = input.read(buffer)
                while (read != -1) {
                    output.write(buffer, 0, read)
                    read = input.read(buffer)
                }
                output.flush()
                saveBitmap(decodeFile(temp, height)!!, final.path, IMAGE_JPG, 80)
                return final
            } finally {
                output.close()
                temp.delete()
            }
        } finally {
            input.close()
        }
    }


</code></pre>

<p>I want the next input stream to be taken only once the current input stream is converted to file. How to achieve this? Please help</p>
",3128784,,0,,,2020-04-27 03:02:53,How to make the map wait till the current index item is finished processing and then take the next item for processing using RxJava?,<android><kotlin><rx-java2><rx-android><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
61615794,1,0,0,2020-05-05 14:43:07,,0,132,"<p>I have a publish subject with multiple subscribers: </p>

<p>Here is the class: </p>

<pre><code>class Real {

    private val publisher: PublishSubject&lt;String&gt; = PublishSubject.create()

    fun doPublish() {
        for (i in 1 until 20) {
            publisher.onNext(""$i Hello"")
        }
        publisher.onComplete()
    }

    fun doSubscribe() {
        publisher.subscribe {
            println(""Subscriber1 $it"")
        }

        publisher.subscribe {
            println(""Subscriber2 $it"")
        }

        publisher.subscribe {
            println(""Subscriber3 $it"")
        }

    }
}
</code></pre>

<p>I call <code>doSubscribe()</code> before I call <code>doPublish()</code>
The output is as follows: </p>

<pre><code> Task :Main.main()
Subscriber1 1 Hello
Subscriber2 1 Hello
Subscriber3 1 Hello
Subscriber1 2 Hello
Subscriber2 2 Hello
Subscriber3 2 Hello
Subscriber1 3 Hello
Subscriber2 3 Hello
Subscriber3 3 Hello
Subscriber1 4 Hello
Subscriber2 4 Hello
Subscriber3 4 Hello
Subscriber1 5 Hello
Subscriber2 5 Hello
Subscriber3 5 Hello
Subscriber1 6 Hello
Subscriber2 6 Hello
Subscriber3 6 Hello
Subscriber1 7 Hello
Subscriber2 7 Hello
Subscriber3 7 Hello
Subscriber1 8 Hello
Subscriber2 8 Hello
Subscriber3 8 Hello
Subscriber1 9 Hello
Subscriber2 9 Hello
Subscriber3 9 Hello
Subscriber1 10 Hello
Subscriber2 10 Hello
Subscriber3 10 Hello
Subscriber1 11 Hello
Subscriber2 11 Hello
Subscriber3 11 Hello
Subscriber1 12 Hello
Subscriber2 12 Hello
Subscriber3 12 Hello
Subscriber1 13 Hello
Subscriber2 13 Hello
Subscriber3 13 Hello
Subscriber1 14 Hello
Subscriber2 14 Hello
Subscriber3 14 Hello
Subscriber1 15 Hello
Subscriber2 15 Hello
Subscriber3 15 Hello
Subscriber1 16 Hello
Subscriber2 16 Hello
Subscriber3 16 Hello
Subscriber1 17 Hello
Subscriber2 17 Hello
Subscriber3 17 Hello
Subscriber1 18 Hello
Subscriber2 18 Hello
Subscriber3 18 Hello
Subscriber1 19 Hello
Subscriber2 19 Hello
Subscriber3 19 Hello
</code></pre>

<p>According to above program the first subscriber receives the event first followed by second and third, this is exactly as per the order of subscription. </p>

<p>Is this order of execution guaranteed? As I am not able to find relevant documentation regarding this. </p>
",2822178,,2822178,,2020-05-05 15:51:08,2020-05-06 08:48:23,Order of events received by subscribers of a Publish Subject,<kotlin><rx-java><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
62023546,1,62023948,0,2020-05-26 13:43:52,,0,259,"<p>How do to use operators so that i always get the previous and the current value? If possible i want to avoid creating state outside the pipe.</p>
<pre><code>- time -&gt;
1      2      3      4
|      |      |      |
Operations
       |      |      |
       (1,2)  (2,3)  (3,4)

</code></pre>
<p>Note that every value besides the first and the last one have to appear twice, so a simple buffer won't do.</p>
<p>I thought about combining <code>skip</code> with <code>merge</code> and <code>buffer</code> but merge does not seem to guarantee ordering.</p>
<pre><code>val s = PublishSubject.create&lt;Int&gt;()
s.mergeWith(s.skip(1)).buffer(2).subscribe{i -&gt; print(i)}
s.onNext(1)
s.onNext(2)
s.onNext(3)
s.onNext(4)


</code></pre>
<blockquote>
<p>output:<br />
[1, 2][2, 3][3, 4]</p>
</blockquote>
<pre><code>val o = Observable.just(1,2,3,4)
o.mergeWith(o.skip(1)).buffer(2).subscribe{i -&gt; print(i)}
</code></pre>
<blockquote>
<p>output:<br />
[1, 2][3, 4][2, 3][4]</p>
</blockquote>
<p>(the sole 4 is fine, and expected)</p>
",7479173,,7479173,,2021-07-16 16:33:33,2021-07-16 16:33:33,Rxjava - How to get the current and the previous item?,<kotlin><rx-java><rx-kotlin>,1,1,0,,,CC BY-SA 4.0
62044835,1,0,0,2020-05-27 13:54:28,,0,48,"<p>I believe there is some big gap in my understanding about RxJava</p>

<p>suppose we have this interface:</p>

<pre><code> interface SecretInterface {
    fun getSecretKey(): Single&lt;Int&gt;
  }

  interface Vault {
    fun openSecret(): Single&lt;String&gt;
  }
</code></pre>

<p>and then I have this test:</p>

<pre><code> @Test
  fun should_check_on_this() {
    val mockSecret = mock&lt;SecretInterface&gt; {
      on { this.getSecretKey() }.thenReturn(Single.just(1), Single.just(2),
          Single.just(3))
    }

    val mockVault = mock&lt;Vault&gt; {
      on { this.openSecret() }.thenReturn(Single.error(Exception(""no can do"")),
          Single.just(""secret opened""))
    }

    val complexStuff = mockSecret.getSecretKey().doOnSuccess {
      System.err.println(""onSuccess secret top $it"")
    }.flatMap {
      mockVault.openSecret()
    }.retryWhen {
      it.flatMapSingle {
        mockSecret.getSecretKey().doOnSuccess { System.err.println(""onSuccess secret bottom: $it"") }
      }
    }

    val test = complexStuff.test()
    test.assertValue { it == ""secret opened"" }
    verify(mockSecret, Times(3)).getSecretKey()
  }
</code></pre>

<p>the test failed, because mockSecret.getSecretKey() invocated only twice, but in output:</p>

<pre><code>onSuccess secret top 1
onSuccess secret bottom: 2
onSuccess secret top 1

org.mockito.exceptions.verification.TooFewActualInvocations: 
secretInterface.getSecretKey();
Wanted 3 times:
</code></pre>

<p>things that I can not understand is:</p>

<pre><code>    -It's already resubscribed, but how come still using old value?
    -How I can make it, that every time I resubscribed always return the latest value?
  in this case it should return 3 not 1.
</code></pre>

<p>thank you</p>
",6908091,,0,,,2020-05-27 13:54:28,Rx java subscribe 3 times but invocation only 2 times,<kotlin><rx-java2><rx-kotlin>,0,2,0,,,CC BY-SA 4.0
62216211,1,62217720,0,2020-06-05 13:14:55,,0,364,"<p>So I'm completely new to rx-java/rx-kotlin and haven't heard about it until I where to write a HTTP filter in Micronaut (<a href=""https://docs.micronaut.io/latest/guide/index.html#filters"" rel=""nofollow noreferrer"">https://docs.micronaut.io/latest/guide/index.html#filters</a>) which caught me off guard since I've only done regular JAX-RS filters.</p>

<p>So after doing some trial-and-error I came up with this. </p>

<pre><code> return Flowable.fromPublisher(remoteClient.getPermissions(userId))
        .subscribeOn(Schedulers.io())
        .onErrorReturn { e -&gt;
            logger.error(""Error when fetching users from remote service"", e)
            emptyList()
        }
        .switchMap { permissions -&gt;
            if (permissions.contains(somePermission)) {
                chain.proceed(request)
            } else {
                val response = HttpResponseFactory.INSTANCE.status(
                    HttpStatus.FORBIDDEN,
                    ""No user found""
                )
                Flowable.just(response)
            }
        }
</code></pre>

<p>Code is rewritten but point still stands. There's some room for improvement here.</p>

<p>What I'd like to do is to improve the exception handling and return a 500 in the case an exception is thrown (like if the remote service called by <code>remoteClient</code> isn't reachable. How can I accomplish this? I haven't got anything else to work other than the solution above to return an empty list for the next observer.</p>
",9602455,,9602455,,2020-06-05 13:38:10,2020-06-05 14:30:31,How to handle exception when doing request to external service and return status accordingly in Micronaut filter,<rx-java2><micronaut><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
62258222,1,62260657,0,2020-06-08 08:44:33,,0,941,"<p>I can't convert this method to RxJava3 despite having upgraded the dependencies</p>

<pre><code>fun setSearchField(searchField: EditText) {
        searchDisposable = searchField.afterTextChangeEvents()
            .skipInitialValue()
            .debounce(400, TimeUnit.MILLISECONDS)
            .map { it.editable()?.toString() ?: """" }
            .distinctUntilChanged()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(::onSearchQueryUpdated)
    }
</code></pre>

<p>Type mismatch.
Required:
io.reactivex.rxjava3.disposables.Disposable?
Found:
io.reactivex.disposables.Disposable!</p>

<pre><code>    def retrofit_version = '2.9.0'
    implementation ""io.reactivex.rxjava3:rxjava:3.0.4""
    implementation ""io.reactivex.rxjava3:rxkotlin:3.0.0""
    implementation ""io.reactivex.rxjava3:rxandroid:3.0.0""
    implementation ""com.jakewharton.rxbinding3:rxbinding:3.1.0""
    implementation ""com.squareup.retrofit2:retrofit:$retrofit_version""
    implementation ""com.squareup.retrofit2:converter-gson:$retrofit_version""
    implementation ""com.github.akarnokd:rxjava3-retrofit-adapter:3.0.0""
    implementation ""com.squareup.okhttp3:logging-interceptor:4.7.2""
</code></pre>

<p>How should I accurately clean  the project from RxJava2?</p>

<p>I tried Invalidate caches/Restart: nothing happened.</p>

<p><a href=""https://i.stack.imgur.com/Vy89v.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vy89v.png"" alt=""enter image description here""></a></p>
",13072160,,13072160,,2020-06-08 09:25:33,2020-06-08 11:07:30,Can't migrate accurately from RxJava2 to RxJava3,<android><rx-java2><rx-kotlin><rx-binding><rx-java3>,1,2,0,,,CC BY-SA 4.0
62497713,1,0,0,2020-06-21 11:13:50,,0,41,"<p>I'm trying to do calculating one by one, asynchronously.</p>
<pre><code>fun method1(): Int{
return 2+2
}

fun method2(value: Int): Int{
return value * 2
}

fun method3(value: Int): Int{
return value * 3
}
</code></pre>
<p>Now I want method 2 work after method 1 and take result from her. Also method 3 work after method 2 and take result from her.
Is it possible to do that with rxkotlin and make it in one stream ?</p>
",10405000,,10405000,,2020-06-21 11:22:35,2020-08-10 08:03:31,Combine 3 single results - one stream,<rx-java><reactive-programming><rx-java2><rx-kotlin>,2,0,0,,,CC BY-SA 4.0
62767181,1,62767231,0,2020-07-07 02:19:41,,0,111,"<p>Excuse the pun, had to do it to em.</p>
<p>I have an observable that is declared like so:</p>
<pre><code>Observable
        .interval(20, TimeUnit.MILLISECONDS)
        .subscribe {
            val timeDiff = System.currentTimeMillis() - testSum
            Log.i(&quot;LOG&quot;, &quot;TIME DIFF: $timeDiff&quot;)
            testSum = System.currentTimeMillis()

            mVisualizer.getWaveForm(waveformByteArray)
            onWaveFormDataCaptureManual(waveformByteArray)
        }
</code></pre>
<p>And no matter what I try to do, this observable will not die. disposables.add() (which seems to be the answer in Java) gives me an unresolved reference error. Before that, I can't even save it to a variable either, as that also shows a lot of red on the screen.</p>
<p>FYI I've Googled this problem. Nothing works.</p>
",5196674,,0,,,2020-07-07 02:33:05,To Kill an Observable,<android><kotlin><rx-java><reactivex><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
63131880,1,0,0,2020-07-28 10:18:44,,0,34,"<p>Hello friends to improve the code below; Is there a way to directly &quot;bind&quot; the &quot;event.position&quot; value without having to subscribe?
Or better?</p>
<pre><code>var index: BehaviorRelay&lt;Int&gt; = BehaviorRelay.createDefault(0)

mainViewPager.pageScrollEvents().subscribe(
        { event -&gt;
            index.accept(event.position)
        }
    )
</code></pre>
<p>I think I'm looking for something like the following (This code will not work, just an example);</p>
<pre><code>mainViewPager.pageScrollEvents().position.bind(index)
</code></pre>
",10018819,,13727175,,2020-07-28 14:03:18,2020-07-28 14:03:18,Subscribe with Bind,<android><rx-java><rx-android><rx-kotlin>,0,2,0,,,CC BY-SA 4.0
63499500,1,0,0,2020-08-20 06:32:20,,0,81,"<p>Have been banging my head over this for a while, I am lost here in managing a requirement where I have to use Rx in Kotlin.</p>
<p>Let me explain.</p>
<p>There is a set of ids whose equivalent items needs to be deleted from server and eventually in local based on server success.</p>
<p>Basically</p>
<ol>
<li>Make network call to delete for a single <code>id</code>(Supported network call returns a <code>Completable</code>)</li>
<li>if <code>complete</code>(success) callback is received store the <code>id</code> in a <code>list</code> (memory)</li>
<li>Do step one and two for all <code>id</code> to delete</li>
<li>Once every network call is complete pass the list to delete from local DB</li>
</ol>
<p>So these functions are available which cannot be modified.</p>
<ol>
<li><code>fun deleteId(id: String): Completable { networkCall.deleteId(id) }</code></li>
<li><code>fun deleteIds(ids: List&lt;String&gt;): Unit { localDb.deleteId(ids) }</code></li>
</ol>
<p>This is what I have tried but obviously incomplete and stuck...</p>
<pre class=""lang-kotlin prettyprint-override""><code>val deleted = CopyOnWriteArrayList&lt;String&gt;()
val error = CopyOnWriteArrayList&lt;String&gt;()
items?.filter { it.isChecked }
    ?.map { Pair(it.id, dataManager.deleteId(it.id)) }
    ?.forEach { (Id, deleteOp) -&gt;
        deleteOp.subscribeOn(Schedulers.io())
                .subscribe(object: CompletableObserver {
                    override fun onComplete() { deleted.add(Id) }

                    override fun onSubscribe(d: Disposable) { disposableManager += d }

                    override fun onError(e: Throwable) { error.add(Id) }

                })
    }
</code></pre>
<p>So now there are multiple problems here, One of them is the requirement where I am unable to find a place to know that all requests are completed so as to initiate a localDb delete.</p>
<p>Is there a way where I can use <code>Flowable.fromIterable()</code> or <code>zip</code> or <code>merge</code> somehow following the chain of commands like above to achieve the above scenario?</p>
",1731048,,1731048,,2020-08-20 09:11:35,2020-08-20 13:23:21,How to perform operation based on result of multiple RxJava Completable results,<java><kotlin><rx-java><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
63535869,1,0,0,2020-08-22 11:51:29,,0,100,"<p>I have a scenario where I have to fetch some string asynchronously. I would like to create a method where I can listen to when this value is fetched successfully and then provided to the listener.
Now, this can be done easily via many ways including a callback listener or a lambda.</p>
<p>But what do I use so that all subsequent calls to this method, also provide the string back - without having to fetch it again, as it has already been fetched once. So a solution where the listener is still attached but is provided the value right away since it is available.
I know how to do this via old fashioned callback listeners, where the value is stored and then for subsequent calls it can be returned right away via the callback.</p>
<p>But is there a more compact/sophisticated way to do it, let's say via Rx?</p>
<p>Thanks.</p>
",966739,,0,,,2020-08-23 08:20:53,RxJava/RxKotlin: Wait for value to be fetched async and then provide to all subscribers,<kotlin><asynchronous><listener><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
63574115,1,63574703,0,2020-08-25 07:36:11,,1,85,"<p>I have the following class, which exposes a Single to fetch an ID.</p>
<p>This is used to fetch the ID on init of that class and later others can also use this to get the ID.</p>
<p>Any where else from where I subscribe to this Single, I am able to get the ID. But in the init method here, this method doesn't seem to start and fetch the ID.</p>
<p>Could someone please help me understand what I am missing?
Thanks</p>
<pre><code>class TestClass {

val idObservable: Single&lt;String&gt;
    get() {
        return Single.create {
            fetchId(it)
        }
    }

init {
    idObservable
        .subscribe { success, _ -&gt;
            Log.d(TAG, &quot;Id: $success&quot;)
        }
        .dispose()
}

private fun fetchId(emitter: SingleEmitter&lt;String&gt;) {
    Utils.fetchId(Consumer&lt;String&gt;{
        emitter.onSuccess(it)

    }, Consumer&lt;Throwable&gt;{
        emitter.onSuccess(&quot;&quot;)
    })
}
</code></pre>
<p>}</p>
",966739,,0,,,2020-08-25 08:15:43,"RxKotlin, RxJava: Observable/Single not starting",<observable><rx-java><rx-java2><publish-subscribe><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
63777591,1,63787395,0,2020-09-07 12:25:27,,3,3860,"<p>I am new to Android development with Kotlin and I am struggling on finding any useful documentation on how to create a simple GET and POST requests with the best current practices as possible. I am coming from an Angular development and there we used a reactive development using RxJS.</p>
<p>Normally I would create a service file that would hold all my request functions, then I would use this service in whichever component and subscribe to the observable.</p>
<p>How would you do this in Android? Is there a good started example of things that have to be created. From the first look, everything looks so complicated and over-engineered</p>
",8358839,,0,,,2020-09-08 05:05:18,Simple HTTP request example in Android using Kotlin,<android><kotlin><rx-android><rx-kotlin><rx-kotlin2>,3,1,1,,,CC BY-SA 4.0
64273179,1,0,0,2020-10-09 02:36:34,,0,199,"<p>I am getting callback event from an object twice sometime thrice but I need to collect only one object that will be the latest one. Is it possible with RX kotlin?</p>
",5751854,,0,,,2021-04-26 10:15:27,RXKotlin - How to receive single event,<android><kotlin><rx-java><rx-kotlin2>,3,1,0,,,CC BY-SA 4.0
64296967,1,0,0,2020-10-10 18:41:05,,0,29,"<p>I am really new to Clean Architecture with Kotlin and I have some questions.
I followed this tutorial <a href=""https://android.jlelse.eu/mvp-with-rxjava2-room-koin-6f9492b94500"" rel=""nofollow noreferrer"">https://android.jlelse.eu/mvp-with-rxjava2-room-koin-6f9492b94500</a> and it was pretty clear on a lot of new concepts.</p>
<p>However I am not sure about use case (it is some another name for interactor?)</p>
<p>I am developing in MVP using Room, Retrofit, RxKotlin and Koin.
I fetch some data from an API and I want to deal with this data once I inserted it in my BDD.</p>
<p>UserResponseDAO.kt</p>
<pre><code>@Dao
interface UserResponseDAO {

    @Insert
    fun insertUser(vararg user: UserResponse) : Completable
}
</code></pre>
<p>UserResponsePresenter.kt</p>
<pre><code>class UserResponsePresenter(private val iUserResponseInteractor: IUserResponseInteractor): IUserResponsePresenter, ViewModel() {

    override fun insertUserResponse(userResponse: UserResponse) {
        iUserResponseInteractor.insertUserResponse(userResponse)
    }
} 
</code></pre>
<p>UserResponseInteractor.kt</p>
<pre><code>class UserResponseInteractor(private val iUserResponseRepository: IUserResponseRepository) :
    IUserResponseInteractor {

    override fun insertUserResponse(userResponse: UserResponse) {
        iUserResponseRepository.insertUserResponse(userResponse)
    }
}
</code></pre>
<p>UserResponseRepository.kt</p>
<pre><code>class UserResponseRepository(private val userResponseDAO: UserResponseDAO) :
    IUserResponseRepository {

    private val appUtility: AppUtility by inject()

    @SuppressLint(&quot;CheckResult&quot;)
    override fun insertUserResponse(userResponse: UserResponse) {

        userResponseDAO.insertUser(userResponse)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                {
                    when (userResponse.profilePOJO.role) {
                        Role.CLIENT -&gt; appUtility.redirectToMainPage(MainClientPageActivity())
                        Role.TATTOOIST -&gt; appUtility.redirectToMainPage(MainTattooistActivity())
                        else -&gt; return@subscribe
                    }
                },
                { Log.d(&quot;RxJava&quot;, &quot;Insert Error&quot;) }
            )

    }
}
</code></pre>
<p>AppUtility.kt</p>
<pre><code>class AppUtility(var context: Context) {

    fun redirectToMainPage(activity: Activity) {
        val intent: Intent = Intent(context, activity.javaClass)
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        context.startActivity(intent)
    }
}
</code></pre>
<p>I have no idea if my code in subscribe() from UserResponseRepository.kt is in the right place. And considering that I need the Context to start a new Activity, do I inject it the right way?</p>
<p>Thank you for any piece of advice!</p>
",9684955,,0,,,2020-10-10 18:41:05,Clean Architecture with RxKotlin & Koin - Where to put my logic?,<retrofit><androidx><koin><rx-kotlin><room>,0,0,0,,,CC BY-SA 4.0
64571621,1,64573000,0,2020-10-28 11:10:55,,1,41,"<p>I have a method that returns an Observable. I have this case where, in case of error I need to check error type, and for some specific error I need to return MyObject instead of error.</p>
<p>Example:</p>
<pre><code>    override fun getSomething(param: String): Observable&lt;State&gt; {
        return someInterface.getSingleResult(param)
            .flatMapObservable {
                when(something) {
                    true -&gt; {
                        Observable.just(State.ACTIVE)
                    }
                    false -&gt; {
                        Observable.just(State.PAUSED)
                    }
                }
            }
            .onErrorReturn {
                 if(it is Something) {
                      State.INACTIVE
                 } else {
//                    returns Throwable  &lt;- don;t know how to handle this
                 } 
            } 
    }
</code></pre>
",3524475,,0,,,2020-10-28 16:12:48,Rx how to return Throwable or Object based on error type,<android><kotlin><rx-java2><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
64735549,1,0,0,2020-11-08 06:51:41,,0,25,"<p><a href=""https://i.stack.imgur.com/0mo2bl.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0mo2bl.jpg"" alt=""Image"" /></a></p>
<p>I have got 3 seekbars on my screen, each controlling the R, G, B colour of the background.</p>
<p>I am using the combineLatest operator to combine the Observables.</p>
<p>The issue is that, the background colour only changes when I have all 3 of the seekbars changed.</p>
<p>Which operator should I use if I want the background colour to change, even if I only changing 1 seekbar?</p>
<pre><code>    override fun onStart() {
        super.onStart()

        val redColorStream = createSeekBarRedObservable()
        val greenColorStream = createSeekBarGreenObservable()
        val blueColorStream = createSeekBarBlueObservable()

        val colorPalette = Observable.combineLatest(redColorStream, greenColorStream, blueColorStream) { r,g,b -&gt;
            Color.rgb(r,g,b)
        }

        colorPalette
            .subscribe {
                main_activity.setBackgroundColor(it)
            }
    }
</code></pre>
",11007537,,0,,,2020-11-08 06:51:41,RxKotlin: What is the correct operator in this case?,<android><rx-kotlin>,0,1,0,,,CC BY-SA 4.0
65040953,1,65163363,0,2020-11-27 16:48:09,,0,48,"<p>I have a method which perform network request and return Observable with mutable list of data class.
Sometimes this method fails with 403 error. I need call YouTubeClient.getApiKey() method for getting new Api key and repeat request to network. How to do it? I read a lot of similar topics but didn't find working decision.</p>
<p>This code of utility method, when i try to call retryWhen() method</p>
<pre><code>private fun searchRequestWrapper(query: String): Observable&lt;MutableList&lt;Video&gt;&gt; {
    return youTubeClient.searchRequest(
        YouTubeClient.URL_SNIPPET,
        YouTubeClient.MAX_RESULT, query,
        YouTubeClient.API_KEY
    )
        .retryWhen { errors -&gt; errors
            .zipWith(Observable.range(1, 3)) { error, a -&gt;
                YouTubeClient.getApiKey()
                error
            }
        }
        .map {it.items}
}
</code></pre>
<p>Main method which call utility method inside itself below</p>
<pre><code>fun fetchVideos(query:String) {
    _networkState.set(NetworkState.LOADING)
    Log.e(&quot;NetworkState&quot;, networkState.get()?.status.toString())

    try {
        compositeDisposable.add(
            searchRequestWrapper(query)
            .flatMapIterable {it}
            .flatMap { video -&gt; videoInfoWrapper(video.videoId).subscribeOn(Schedulers.io()) }
            .toList()
            .subscribeOn(Schedulers.io())
            .subscribe({
                Log.e(&quot;new videosId&quot;,it.toString())
                downloadedVideosList.postValue(it)
                _networkState.set(NetworkState.LOADED)
                Log.e(&quot;NetworkState&quot;, networkState.get()?.status.toString())
                _networkState.set(NetworkState.WAITING)
                Log.e(&quot;NetworkState&quot;, networkState.get()?.status.toString())
            },{
                errorHandle(it)
            }))
    }
    catch (e: Exception){
        Log.e(&quot;fetchVideos&quot;,e.message)
    }
}
</code></pre>
",0,user14618921,286934,,2020-11-27 16:51:47,2020-12-06 00:14:20,How to call a method multiple times using RxJava's method retryWhen?,<java><kotlin><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
65217193,1,65217381,0,2020-12-09 12:55:24,,0,27,"<p>could someone help, please?</p>
<p>I have these functions</p>
<pre><code>fun getBooks(): Single&lt;List&lt;Book&gt;&gt; {
    return getCollections()
        .map {
            it.map(::collectonToBook)
        }
}

fun getCollections(): Single&lt;List&lt;Collection&gt;&gt; {
   return db.fetchCollections()
       .filter(::isBook)
}

fun collectonToBook(collection: Collection): Maybe&lt;Book&gt; {
    return collection.toBook()
}
            
</code></pre>
<p>The problem is getBooks returns <code>Single&lt;List&lt;Maybe&lt;Book&gt;&gt;&gt;</code> when I need <code>Single&lt;List&lt;Book&gt;&gt;</code>. Can I do that inside the stream without calling blockingGet?</p>
",1158918,,0,,,2020-12-09 13:05:58,Transform Single<List<Maybe<Book>>> to Single<List<Book>>,<kotlin><rx-java2><rx-kotlin>,1,0,1,,,CC BY-SA 4.0
65289300,1,65504254,0,2020-12-14 12:51:18,,0,32,"<p>My server api looks like this:</p>
<pre><code>data class ArticleDTO(val id: Int, val title: String, val typeId: Int)
data class Type(val id: Int, val name: String) 

interface API {
    fun getArticles(): Single&lt;List&lt;ArticleDTO&gt;&gt;
    fun getTypes(): Single&lt;List&lt;Type&gt;&gt;
}
</code></pre>
<p>And I have one model which I use in UI:</p>
<pre><code>data class Article(val title: String, val typeName: String)
</code></pre>
<p>I created map method:</p>
<pre><code>fun ArticleDTO.toArticle(type: Type) = Article(this.title, typeName = type.name)
</code></pre>
<p>And in the repository class I did this:</p>
<pre><code>fun getArticles() =
    Observables.combineLatest(api.getArticles().toObservable(), api.getTypes().toObservable())
        .flatMap {
            Observable.just(it.first.map { articleDTO -&gt;
                articleDTO
                    .toArticle(it.second.find { type -&gt; type.id == articleDTO.typeId }!!)
            })
        }
</code></pre>
<p>Is there a way to do it better?</p>
<p>And what if my api will looks like this:</p>
<pre><code>interface API {
    fun getArticles(): Single&lt;List&lt;ArticleDTO&gt;&gt;
    fun getTypes(typeId: Int): Single&lt;Type&gt;
}
</code></pre>
",8145152,,0,,,2020-12-30 08:45:12,Which is right way to map few server models into one domains?,<android><rx-java><clean-architecture><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
65587608,1,65588658,0,2021-01-05 22:42:03,,0,21,"<p>I have a queue of items that will send once the server is reachable:<br>
<code>val queueHistory: Observable&lt;QueuedItem&gt;</code></p>
<p>A QueuedItem is:<br>
<code>data class QueuedItem(val item: Item, val sent: Boolean = false)</code></p>
<p>The queueHistory never completes, it just records when an item is being queued to be sent <code>onNext(QueuedItem(item1, false)</code>, and then later records it was sent <code>onNext(QueuedItem(item1, true)</code>.</p>
<p><strong>What I want to do is get a current count of how many unsent items there are.</strong></p>
<p>The main source of my trouble is due to the list not completing, I was initially thinking of using <code>collect</code> but that needs a completed list.</p>
<p>I was playing around with using <code>scan</code> with something like<br>
<code>queueHistory.scan { items: ScannedItems, item -&gt; ScannedItems(arrayOf(*items, item), 0) }</code><br>
Where I could keep the current list of items I have encountered so far, but scan wants everything to be the same type.</p>
<p>Another idea I had was</p>
<pre><code>queueHistory
            .groupBy { it.item }
            .flatMapSingle { it.toList() }
            .map { it.size % 2 }
</code></pre>
<p>But toList() needs a finite list.</p>
<p>Any ideas would be appreciated!</p>
",103777,,0,,,2021-01-06 00:46:28,Applying an operation to all previously emitted items,<rx-java><reactive-programming><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
65818735,1,0,0,2021-01-20 22:40:15,,0,66,"<p>Observable emits trade objects.
How to make operation on each emission into one result object?</p>
<p>Trade(tradeType: String, profit: BigDecimal)
Result(totalProfit: BigDecimal)</p>
<p>Example:</p>
<pre><code>trades
.scan(result: Result, currentTrade: Trade){
  result.totalProfit += currentTrade.profit
}
.subscribe(
 printLn(it.totalProfit)
)
</code></pre>
",1924107,,0,,,2021-01-20 23:29:53,How to collect every observable emittion into one object in rxJava2/rxKotlin2?,<rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
66539018,1,66543084,0,2021-03-09 00:10:54,,0,46,"<p>I have a <code>PublishSubject</code>:</p>
<pre><code>val myPublishSubject = remember {
    PublishSubject.create&lt;Long&gt;().apply {
        doOnNext {
            Logger.debug(TAG) { &quot;Got new Long $it&quot; }
        }
            .takeUntil(someObservable)
            .subscribe()
    }
}
</code></pre>
<p>and I have a service what gets a stream of Long values, somewhere in another function:</p>
<pre><code>while(notFinished){
    val newLong = getSomeLong()
    myPublishSubject.onNext(newLong)
}
</code></pre>
<p>Here, the upper <code>doOnNext{}</code> is logging forever. How can I for instance only allow first 20 Long values? <code>.take(20)</code> did not work!</p>
",15122239,,15122239,,2021-03-09 07:02:37,2021-03-09 08:14:36,How to doOnNext only consumes the first n items of a PublishSubject?,<kotlin><rx-java2><rx-android><android-jetpack-compose><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
66832744,1,66835123,0,2021-03-27 15:01:18,,0,168,"<p>My Question is so clear, I wanna know what is the reason that you prefer using third-party libraries like RxJava or RxKotlin, or using coroutines for setting item click listener for Recyclerview items click, dialogs button or anything else, instead of using Interfaces, is there any performance reason?
what is the difference between these tools?</p>
",9972675,,0,,,2021-03-27 19:06:25,"What is the benefit of using RxJava, RxKotlin, or Even Kotlin coroutines instead of Interfaces for On Click listener?",<android><android-studio><rx-java><kotlin-coroutines><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
67040162,1,67055925,0,2021-04-10 23:25:57,,1,41,"<p>I have a list of recurring elements in Kotlin, say:</p>
<pre><code>val result = arrayListOf&lt;String&gt;(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;BB&quot;)
</code></pre>
<p>I would like to group them by their value along with how many times they appear, so the output would be pairs of:</p>
<pre><code>{&quot;AA&quot;, 2}, {&quot;BB&quot;, 2}, {&quot;CC&quot;, 1}
</code></pre>
<p>I have resolved the problem using in Kotlin as follows:</p>
<pre><code>val ans = result.map { it.value }
            .groupBy { it }
            .map { Pair(it.key, it.value.size) }
            .sortedByDescending { it.second }
</code></pre>
<p>I want to write same code in RxKotlin for learning and tried with the following but do not know how to apply <code>map</code>/<code>flatMap</code> to achieve the result.</p>
<pre><code>val source = Observable.fromIterable(result)
source.groupBy{ it }.subscribe { showresult(it) }
</code></pre>
",1154390,,10082297,,2021-04-10 23:28:30,2021-04-12 09:27:43,RxKotlin COUNT with GROUP BY and return a list,<kotlin><rx-java><rx-kotlin><rx-kotlin2>,1,2,0,,,CC BY-SA 4.0
67128528,1,0,0,2021-04-16 16:00:22,,0,25,"<p>So I have an object of contactId and I convert it to flux and then I query the contact details using each Id respectively and after that convert it to Mono using collectList method and map it to another object let's call it DomainContactDetails like this.</p>
<pre class=""lang-kotlin prettyprint-override""><code>Flux.just(identifier.regContactId, identifier.billingContactId ,identifier.adminContactId, identifier.techContactId)
      .flatMap { resellerGetContact(it) }
      .collectList()
      .map { DomainContactDetails.fromList(it) }
      .toFuture()
</code></pre>
<p>Are there anyways to collect flux element into key map instead of list. for now I'm using index of list to indentify which data belongs to the property</p>
<pre class=""lang-kotlin prettyprint-override""><code>data class DomainContactDetails(
  val registrantContact: ContactInfo,
  val billingContact: ContactInfo,
  val adminContact: ContactInfo,
  val techContact: ContactInfo
) {
  companion object {
    fun fromList(contacts: List&lt;ContactInfo&gt;) = DomainContactDetails(
      registrantContact = contacts[0],
      billingContact = contacts[1],
      adminContact = contacts[2],
      techContact = contacts[3]
    )
  }
}
</code></pre>
<p>I want it to be key map so it might be a bit better like this</p>
<pre class=""lang-kotlin prettyprint-override""><code>fun fromKeyMap(contacts: Map&lt;String, ContactInfo&gt;) = DomainContactDetails(
  registrantContact = contacts[&quot;reg&quot;],
  billingContact = contacts[&quot;bil&quot;],
  adminContact = contacts[&quot;adm&quot;],
  techContact = contacts[&quot;tec&quot;]
)
</code></pre>
",9740664,,8976,,2021-04-17 07:49:20,2021-04-17 07:49:20,How can I convert flux element to a key map mono,<kotlin><reactor><rx-kotlin>,1,0,0,,,CC BY-SA 4.0
67293882,1,67295389,0,2021-04-28 04:42:01,,0,47,"<p>I'm trying to create a BLE service that will scan for devices and using rxKotlin create an observable that will allow another class to observe when a device is found. I'm confused on how to create the observable that will allow another class to subscribe and tutorials are all over the place. Can someone give me a pointer on how to do so or a good tutorial.</p>
<p>Bluetoothservice class callback where devices are discovered</p>
<pre><code>var foundDeviceObservable: Observable&lt;BluetoothDevice&gt; = Observable.create {  }

private val scanCallback = object : ScanCallback() {
    override fun onScanResult(callbackType: Int, result: ScanResult) {
        with(result.device) {
            var foundName = if (name == null) &quot;N/A&quot; else name
            foundDevice = BluetoothDevice(
                foundName,
                address,
                address,
                result.device.type.toString()
            )
            foundDeviceObservable.subscribe {
               //Update Observable value?
            }
        }
    }
}

class DeviceListViewModel(application: Application) : AndroidViewModel(application) {
    private val bluetoothService = BLEService()

    //Where I am trying to do logic with device
    fun getDeviceObservable(){
        bluetoothService.getDeviceObservable().subscribe{ it -&gt;
        
    }
}
</code></pre>
<p><strong>Solution</strong></p>
<p>Was able to find the solution after reading user4097210's reply. Just had to change the found device to</p>
<pre><code>var foundDeviceObservable: BehaviorSubject&lt;BluetoothDevice&gt; = BehaviorSubject.create()
</code></pre>
<p>and then call the next method in the callback</p>
<pre><code>private val scanCallback = object : ScanCallback() {
    override fun onScanResult(callbackType: Int, result: ScanResult) {
        with(result.device) {
            var foundName = if (name == null) &quot;N/A&quot; else name
            foundDevice = BluetoothDevice(
                foundName,
                address,
                address,
                result.device.type.toString()
            )
            foundDeviceObservable.onNext(foundDevice)
        }
    }
}
</code></pre>
",4990578,,4990578,,2021-04-30 00:59:58,2021-04-30 00:59:58,Android BLE RxKotlin,<android><kotlin><rx-java2><rx-kotlin2>,1,0,0,,,CC BY-SA 4.0
67394991,1,0,0,2021-05-05 03:54:49,,0,22,"<p>I'm using kotlin/java to develop android apps and reactiveX is something new to me.</p>
<p>How do we append similar data in an array using reactiveX?</p>
<p>I have this data and I want to merge same dates and append their progress.</p>
<p>So how do we transform this data</p>
<pre><code>{
  &quot;data&quot;: [
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 1
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 5
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 2
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 3
    },
    {
      &quot;date&quot;: &quot;05-06-22&quot;,
      &quot;progress&quot;: 2
    }
  ]
}
</code></pre>
<p>to</p>
<pre><code>{
  &quot;data&quot;: [
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 11
    },
    {
      &quot;date&quot;: &quot;05-06-22&quot;,
      &quot;progress&quot;: 2
    }
  ]
}
</code></pre>
",6104745,,6104745,,2021-05-05 04:19:06,2021-05-05 04:19:06,Merging data in an array using ReactiveX in Android,<android><kotlin><rx-java><reactivex><rx-kotlin>,0,0,0,,,CC BY-SA 4.0
67589564,1,67796289,0,2021-05-18 15:39:43,,0,43,"<p>I'm using refCount to hold onto a BLE connection for 5 mins. This works well until I have a connection issue, refCount still keeps the connection and replay replays the error.</p>
<p>Is there a way I can make either make refCount disconnect as soon as there is an error, or make replay not replay errors?</p>
<pre><code>        bleDevice
            .establishConnection(false)
            .replay(1)
            .refCount(1, 5, TimeUnit.MINUTES)
</code></pre>
",103777,,0,,,2021-06-01 21:36:04,refCount keeping connection even after an error,<rx-java><reactive-programming><rxandroidble><rx-kotlin>,1,4,0,,,CC BY-SA 4.0
67960660,1,67966935,0,2021-06-13 16:52:15,,0,82,"<p>I am a newbie to RXKotlin/RXJava.
I am developing the background service in Android.</p>
<p>In my service, I have</p>
<ul>
<li>Bluetooth socket</li>
<li>TCP Socket</li>
</ul>
<p>Whenever the data is available on the Bluetooth socket, read and write to the TCP socket. And whenever data is received in the TCP socket, write to the Bluetooth socket.</p>
<p>Can someone help me:</p>
<ul>
<li>how to achieve this using Observables?</li>
<li>how to exchange the socket id information?</li>
<li>how to exchange the data?
Thanks</li>
</ul>
",16216084,,2801860,,2021-06-14 18:21:18,2021-06-14 18:21:18,RXKOTLIN/RXJAVA: Communication between the socket using Observables,<android><rx-java><rxjs-observables><rx-kotlin>,1,2,0,,,CC BY-SA 4.0
68191518,1,0,0,2021-06-30 08:54:00,,0,71,"<p>In my Android App I'm trying to save a file with input- and outputStream from the contentResolver. I'm using this saveImageExternal function in a Rx Completable.fromCallable and I got a FileNotFoundException because my uri was wrong, but the onError function from my observer was not called and the Completable completed. Why was onError not called? Can someone explain?</p>
<pre><code>private fun saveImageExternal(file: File, uri: Uri, context: Context) {
        val resolver = context.contentResolver
        val outputStream = FileOutputStream(file)
        val inputStream = resolver.openInputStream(uri)
        val buffer = ByteArray(4096)
        var length: Int
        if (inputStream != null) {
            while (inputStream.read(buffer).also { length = it } &gt; 0) {
                outputStream.write(buffer, 0, length)
            }
            outputStream.flush()
        }

    }
</code></pre>
<pre><code>Completable.fromCallable { saveImageExternal(file, uri, context) }
            .subscribeOn(Schedulers.io())
            .subscribe(object : CompletableObserver{
                override fun onSubscribe(d: Disposable) {
                    Timber.d(&quot;onSubscribe&quot;)
                }

                override fun onComplete() {
                   Timber.d(&quot;onComplete&quot;)
                }

                override fun onError(e: Throwable) {
                    Timber.d(&quot;onError&quot;) // never called 
                }

            })
</code></pre>
",14718579,,14718579,,2021-06-30 09:48:04,2021-06-30 09:48:04,Rx Error Handling in Completable.fromCallable,<android><rx-java><rx-kotlin><rx-java-completable>,0,1,0,,,CC BY-SA 4.0
68667754,1,68668270,0,2021-08-05 13:43:10,,3,50,"<p>I am studying RxKotlin and the question arose: what is the difference between <code>defer()</code>  and  <code>defer{}</code></p>
",14729932,,0,,,2021-08-05 14:14:12,What is the difference between defer() and defer{},<kotlin><rx-java><rx-kotlin>,2,0,0,,,CC BY-SA 4.0
68865912,1,0,0,2021-08-20 17:16:38,,0,26,"<p>Is it possible to call handler right at start of every minute? Mean check current time and call handler only when seconds are 00. Using RX2. Thanks.</p>
<p><code>Observable.interval(1, TimeUnit.MINUTES)</code></p>
",1621111,,0,,,2021-08-20 17:16:38,Call handler right at start of every minute,<android><rx-java2><rx-kotlin>,0,2,0,,,CC BY-SA 4.0
