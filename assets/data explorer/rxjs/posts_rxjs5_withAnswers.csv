Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"32190445","1","34669444","","2015-08-24 19:42:45","","71","18222","<p>I reviewed the following SO question:
<a href=""https://stackoverflow.com/questions/2521277/what-are-the-hot-and-cold-observables"">What are the Hot and Cold observables?</a></p>

<p>To summarize:</p>

<ul>
<li>a cold observable emits its values when it has an observer to consume them, i.e. the sequence of values received by observers is independent of time of subscription. All observers will consume the same sequence of values.</li>
<li>a hot observable emits value independently of its subscriptions, i.e. the values received by observers are a function of the time of subscription.</li>
</ul>

<p>Yet, I feel like hot vs. cold is still a source of confusion. So here are my questions:</p>

<ul>
<li><p>Are all rx observables cold by default (with the exception of subjects)? </p>

<p>I often read that events are the typical metaphor for hot observables, but I also read that <code>Rx.fromEvent(input, 'click')</code> is a cold observable(?).</p></li>
<li><p>Are there/what are the Rx operators which turn a cold observables into a hot observable (apart from <code>publish</code>, and <code>share</code>)?</p>

<p>For instance, how does it work with Rx operator <code>withLatestFrom</code>? Let <code>cold$</code> be a cold observable which has somewhere been subscribed to. Will <code>sth$.withLatestFrom(cold$,...)</code> be a hot observable? </p>

<p>Or if I do <code>sth1$.withLatestFrom(cold$,...), sth2$.withLatestFrom(cold$,...)</code> and subscribe to <code>sth1</code> and <code>sth2</code>, will I always see the same value for both <code>sth</code>?</p></li>
<li><p>I thought <code>Rx.fromEvent</code> creates cold observables but that is not the case, as mentioned in one of the answers. However, I am still baffled by this behaviour: <a href=""https://codepen.io/anon/pen/NqQMJR?editors=101"" rel=""noreferrer"">https://codepen.io/anon/pen/NqQMJR?editors=101</a>. Different subscriptions get different values from the same observable. Wasn't the <code>click</code> event shared?</p></li>
</ul>
","3743222","","1267663","","2020-02-10 18:31:10","2020-02-10 18:31:10","Hot and Cold observables: are there 'hot' and 'cold' operators?","<javascript><angular><rxjs><reactive-programming><rxjs5>","4","2","42","","","CC BY-SA 4.0"
"34669444","2","","32190445","2016-01-08 04:20:08","","91","","<p>I am coming back a few months later to my original question and wanted to share the gained knowledge in the meanwhile.
I will use the following code as an explanation support (<a href=""http://jsfiddle.net/t0qnp28m/1/"" rel=""noreferrer"">jsfiddle</a>): </p>

<pre><code>var ta_count = document.getElementById('ta_count');
var ta_result = document.getElementById('ta_result');
var threshold = 3;

function emits ( who, who_ ) {return function ( x ) {
  who.innerHTML = [who.innerHTML, who_ + "" emits "" + JSON.stringify(x)].join(""\n"");
};}

var messages$ = Rx.Observable.create(function (observer){
  var count= 0;
  setInterval(function(){
    observer.onNext(++count);
  }, 1000)
})
.do(emits(ta_count, 'count'))
.map(function(count){return count &lt; threshold})
.do(emits(ta_result, 'result'))

messages$.subscribe(function(){});
</code></pre>

<p>As mentioned in one of the answers, defining an observable leads to a series of callback and parameter registration. The data flow has to be kicked in, and that is done via the <code>subscribe</code> function.
A (simplified for illustration) detailed flow can be find thereafter.</p>

<p><a href=""https://i.stack.imgur.com/YoDan.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/YoDan.png"" alt=""Simplified flow diagram""></a></p>

<p>Observables are cold by default. Subscribing to an observable will result in an upstream chain of subscriptions taking place. The last subscription leads to the execution of a function which  will handle a source and emit its data to its observer.</p>

<p>That observer in its turn emits to the next observer, resulting in a downstream flow of data, down to the sink observer. The following simplified illustration shows subscription and data flows when two subscribers subscribe to the same observable.</p>

<p><a href=""https://i.stack.imgur.com/e0ZfL.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/e0ZfL.png"" alt=""Cold observable simplified flow diagram""></a></p>

<p>Hot observables can be created either by using a subject, or through the <code>multicast</code> operator (and its derivatives, see Note 3 below).</p>

<p>The <code>multicast</code> operator under the hood makes use of a subject and returns a connectable observable. All subscriptions to the operator will be subscriptions to the inner subject. When <code>connect</code> is called, the inner subject subscribes to the upstream observable, and data flows downstream.
Subjects manipulate internally a list of subscribed observers and multicast incoming data to all subscribed observers.</p>

<p>The following diagram summarizes the situation.</p>

<p><a href=""https://i.stack.imgur.com/6wR8l.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/6wR8l.png"" alt=""Hot observable simplified flow diagram""></a></p>

<p>In the end, it matters more to understand the flow of data caused by the observer pattern and the implementation of the operators.</p>

<p>For instance, if <code>obs</code> is hot, is <code>hotOrCold = obs.op1</code> cold or hot? Whatever the answer is :</p>

<ul>
<li>if there are no subscribers to <code>obs.op1</code>, no data will flow through <code>op1</code>. If there were subscribers to hot <code>obs</code>, that means <code>obs.op1</code> will have possibly lost pieces of data</li>
<li>supposing that <code>op1</code> is not a multicast-like operator, subscribing twice to <code>hotOrCold</code> will subscribe twice to <code>op1</code>, and every value from <code>obs</code> will flow twice through <code>op1</code>.</li>
</ul>

<p>Notes :</p>

<ol>
<li>This information should be valid for Rxjs v4. While the version 5 has gone
through considerable changes, most of it still applies verbatim.</li>
<li>Unsubscription, error and completion flows are not represented, as
they are not in the scope of the question. Schedulers are also not
taken into account. Among other things, they influence the timing of
the data flow, but a priori not its direction and content.</li>
<li>According to the type of subject used for multicasting, there are
different derived multicasting operators:</li>
</ol>

<p><code>
Subject type       | `Publish` Operator          | `Share` operator
------------------ | --------------------------- | -----------------
Rx.Subject         | Rx.Observable.publish       | share
Rx.BehaviorSubject | Rx.Observable.publishValue  | shareValue
Rx.AsyncSubject    | Rx.Observable.publishLast   | N/A
Rx.ReplaySubject   | Rx.Observable.replay        | shareReplay
</code></p>

<p><strong>Update</strong> : See also <a href=""https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339#.hrv9x5pcr"" rel=""noreferrer"">the following articles, here</a><a href=""https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87#.4y6cdylm0"" rel=""noreferrer"">, and there</a>) on that subject by Ben Lesh.</p>

<p>Further details on subjects can be found in this other SO question : <a href=""https://stackoverflow.com/questions/34849873/what-are-the-semantics-of-different-rxjs-subjects"">What are the semantics of different RxJS subjects?</a></p>
","3743222","","3743222","","2018-02-26 16:26:14","2018-02-26 16:26:14","","","","7","","","","CC BY-SA 3.0"
"34794959","1","34799262","","2016-01-14 16:40:24","","3","1566","<p>How can i create an observable sequence of random numbers within a range using the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md"" rel=""nofollow"">rxjs observable</a>?</p>

<p>I can iterate over a range using <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/range.md"" rel=""nofollow""><code>range</code></a>.</p>

<p>For example:</p>

<pre><code>Observable.range(0, 20)
    .flatMap(data =&gt; getImage(data))
    .map(data =&gt; this.image = data);
</code></pre>

<p>However, i would like to have it continuously generate a random number for the sequence until i force it to stop. <strong>Not</strong> just iterate through the values until it is done.</p>

<p>NOTE: I am using <a href=""https://github.com/ReactiveX/RxJS"" rel=""nofollow"">rxjs 5</a>. Which does not have a <code>while</code>.</p>
","427763","","427763","","2016-01-14 17:19:18","2016-01-14 20:37:27","Observerable sequence of random numbers within a range","<javascript><typescript><observable><rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"34799262","2","","34794959","2016-01-14 20:37:27","","4","","<p>This will generate the random number within intervals of time. This is exactly what i needed. </p>

<pre><code>let mySubscription: Subscription&lt;number&gt; = Observable.interval(3000)
    .map(data =&gt; generateRandomNumber(...))
    .subscribe(
        data =&gt; console.log(data),
        error =&gt; console.log(error),
        () =&gt; console.log(""complete"")
    );
</code></pre>

<hr>

<p>To stop the observer, simply unsubscribe from the subscription.</p>

<pre><code>mySubscription.unsubscribe();
</code></pre>

<hr>

<p><code>generateRandomNumber()</code> is a method that just generates a random number for me. It is out of scope of the issue.</p>
","427763","","","","","2016-01-14 20:37:27","","","","2","","","","CC BY-SA 3.0"
"34839057","1","34839338","","2016-01-17 13:49:01","","30","25615","<pre><code>// Part of service
public someEvent: EventEmitter&lt;number&gt; = new EventEmitter();

....

// Component
@Component({
  selector: 'some-component',
  template: `...`
})
export class SomeComponent {
  constructor(public service: Service) {
    this.service.someEvent.subscribe((x) =&gt; {
      // Do something
    });
  }
}
</code></pre>

<p><code>SomeComponent</code> is displayed in <code>/</code> route. When I navigate to different route in my application, and come back again, <code>SomeComponent</code> will subscribe to the event again, causing callback to fire twice. How to subscribe to the event once or unsubscribe on destroy of the component and subscribe again?</p>

<pre><code>// Can't subscribe after.
ngOnDestroy() {
  this.service.someEvent.unsubscribe();
}
</code></pre>
","4777077","","4777077","","2016-01-17 13:57:33","2017-07-25 05:46:44","How to subscribe to event emitter once?","<angular><rxjs><eventemitter><angular2-services><rxjs5>","2","6","5","","","CC BY-SA 3.0"
"34839338","2","","34839057","2016-01-17 14:17:27","","38","","<p>A call to <code>subscribe</code> returns an <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/disposables/disposable.md#disposable-instance-methods"" rel=""noreferrer"">instance of <code>Disposable</code></a>, which has a method <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/disposables/disposable.md#rxdisposableprototypedispose"" rel=""noreferrer""><code>dispose</code></a>.</p>

<p>Or if you are using RxJS 5, <a href=""https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md#subscription-dispose-is-now-unsubscribe"" rel=""noreferrer""><code>dispose</code> has been renamed to <code>unsubscribe</code></a> (thanks @EricMartinez).</p>

<p>And from the <a href=""https://github.com/Reactive-Extensions/RxJS#about-the-reactive-extensions"" rel=""noreferrer"">RxJS docs</a>:</p>

<blockquote>
  <p>...when we're no longer interested in receiving the data as it comes streaming in, we call dispose on our subscription.</p>
</blockquote>

<hr>

<p>Store the result of your call to <code>subscribe</code> and later dispose of the subscription within <code>ngOnDestroy</code>.</p>

<p><strong>RxJS 5:</strong></p>

<pre><code>export class SomeComponent {
  constructor (public service: Service) {
    this.subscription = this.service.someEvent.subscribe((x) =&gt; {...});
  }
  ngOnDestroy () {
      this.subscription.unsubscribe();
  }
}
</code></pre>

<p><strong>RxJS &lt;5:</strong></p>

<pre><code>export class SomeComponent {
  constructor (public service: Service) {
    this.subscription = this.service.someEvent.subscribe((x) =&gt; {...});
  }
  ngOnDestroy () {
      this.subscription.dispose();
  }
}
</code></pre>
","2039244","","2039244","","2017-03-17 15:52:32","2017-03-17 15:52:32","","","","4","","","","CC BY-SA 3.0"
"34849873","1","34860777","","2016-01-18 08:09:30","","23","15164","<p>Documentation for the topic is sparse and it's hard to discover an ""entry-point"" there. </p>
","2546882","","3743222","","2018-02-26 16:24:09","2018-02-26 16:24:09","What are the semantics of different RxJS subjects?","<javascript><rxjs><rxjs5>","1","0","11","","","CC BY-SA 3.0"
"34852776","1","35232636","","2016-01-18 10:45:10","","3","897","<p>On the GitHub <a href=""https://github.com/Reactivex/RxJS#installation-and-usage"" rel=""nofollow"">page</a>, there are instructions only for NPM. When using 
<code>bower search rxjs</code>, I got only the RxJS 4.x results. Does it mean the RxJS 5.x hasn't been ""bowerized"" yet?</p>

<p>Is there a way to do the ${subject}?</p>
","1594980","","","","","2016-02-05 20:07:42","How to add RxJS 5 as a bower dependency","<bower><rxjs5>","1","0","","","","CC BY-SA 3.0"
"34860777","2","","34849873","2016-01-18 17:36:16","","47","","<p>Semantics differ according to the type of subjects. I will divide them in two kinds : vanilla (<code>Rx.Subject</code>), and special-purpose subjects (the other three). The special-purpose subjects share part of the semantics of the vanilla subject with a few caveats due to their specialization (for instance, completion/reconnection behaviour).</p>

<p><strong>Vanilla Rx.Subject semantics</strong></p>

<ol>
<li><p>Key features </p>

<ul>
<li>subjects implement the observer, observable interface (and the disposable interface as they have a <code>dispose</code> handler on their prototype). That means, among other things, they have:

<ul>
<li>observer interface : <code>onNext</code>, <code>onError</code>, <code>onComplete</code> method</li>
<li>observable interface : <code>subscribe</code> method</li>
</ul></li>
<li>you can cast a subject to an observer or to an observable, hiding the implementation of the extra interfaces (cf. <a href=""http://xgrommx.github.io/rx-book/content/observer/observer_instance_methods/asobserver.html"" rel=""noreferrer""><code>.asObserver()</code></a>, and <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/asobservable.md"" rel=""noreferrer""><code>.asObservable()</code></a>) if need be</li>
<li>the subject being an observable, you can subscribe several observers to it. That observable will then broadcast its data to all its observers. Internally the subject maintains an array of observers.</li>
<li>the subject being an observer, you can subscribe it to any observable</li>
<li>the observer and the observable which compose the subject being two distinct entities, you can use them independently of the other if that's your use case.</li>
<li><code>dispose</code>ing a subject will <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md#rxsubjectprototypedispose"" rel=""noreferrer"">unsubscribe all observers and release resources.</a></li>
<li>Subjects do not take a scheduler but rather assume that <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md"" rel=""noreferrer"">all serialization and grammatical correctness are handled by the caller of the subject.</a> </li>
<li>The default behaviour of subjects is to emit <strong>synchronously</strong> their values to the observers, <strong>starting with the first subscribed observer to the last</strong>. In most cases, order will not matter, in others it will.</li>
</ul></li>
</ol>

<p>I quote a key aspect of <a href=""https://github.com/Reactive-Extensions/RxJS/tree/master/doc/designguidelines#31-the-rxjs-grammar"" rel=""noreferrer"">Rxjs contract and grammar</a> :</p>

<blockquote>
  <p>This grammar allows observable sequences to send any amount (0 or more) of onNext messages to the subscribed observer instance, optionally followed by a single success (onCompleted) or failure (onError) message.</p>
</blockquote>

<ul>
<li><p>a vanilla subject (created with <code>new Rx.Subject()</code>) implements that grammar : when <code>onCompleted</code> has been called once, all subsequent calls to <code>onNext</code> are ignored. Second call of <code>onCompleted</code> on the same observer is also ignored. If an observer subscribes to the observable side of the subject, its <code>onComplete</code> callback will immediately be called (<a href=""http://jsfiddle.net/cLf6Lqsn/1/"" rel=""noreferrer"">http://jsfiddle.net/cLf6Lqsn/1/</a>).</p>

<ol start=""2"">
<li><p>Creation</p>

<ul>
<li><code>new Rx.Subject()</code></li>
</ul></li>
</ol>

<p>Returns a subject which connects its observer to its observable (<a href=""http://jsfiddle.net/ehffnbky/1/"" rel=""noreferrer"">jsfiddle</a>). This example is taken from the official <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md"" rel=""noreferrer"">documentation</a> and portrays how to use subjects as proxies. The subject is subscribed to a source (observer side), and is also listened on by observers (observable side). Any call to <code>onNext</code> (observer side) results in the observable side calling <code>onNext</code> with the same value for each of its observers.</p>

<ul>
<li><code>Rx.Subject.create(observer, observable)</code></li>
</ul>

<p>Creates a subject from the specified observer and observable. Those two are not necessarily connected. A good example can be seen in the implementation of <a href=""https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/src/dom/websocket.js"" rel=""noreferrer""><code>Rx.Dom.fromWebSocket</code></a> which returns a subject used to send and receive data from a socket. The observer side of the subject sends data to the socket. The observable side is used to listen on incoming data from the socket. Also, a subject created this way does NOT have a <code>dispose</code> method.</p></li>
</ul>

<p><strong>Specialized Rx.Subject semantics</strong></p>

<ul>
<li>This <a href=""http://reactivex.io/documentation/subject.html"" rel=""noreferrer""><code>reactivex.io</code> documentation</a> covers pretty well most of the semantics of the specialized subjects.</li>
<li>The other interesting points to mention concern behavior past completion.</li>
<li>Sample code illustrating the behaviour are here for <a href=""http://jsfiddle.net/8k4rzf65/2/"" rel=""noreferrer"">async</a>, <a href=""http://jsfiddle.net/kLqv43ad/1/"" rel=""noreferrer"">behavior</a>, <a href=""http://jsfiddle.net/huaqvtma/1/"" rel=""noreferrer"">replay</a></li>
</ul>

<p>Hopefully I did not get too much wrong. I'll be happy to be corrected. Last note, this should be valid for RxJS v4.</p>

<p>For a detailed explanation of the behaviour of cold/hot observables, one can refer to : <a href=""https://stackoverflow.com/questions/32190445/hot-and-cold-observables-are-there-hot-and-cold-operators/34669444#34669444"">Hot and Cold observables : are there &#39;hot&#39; and &#39;cold&#39; operators?</a></p>
","3743222","","-1","","2017-05-23 11:46:51","2016-07-20 11:29:13","","","","1","","","","CC BY-SA 3.0"
"35010182","1","35010346","","2016-01-26 09:04:48","","11","6040","<p>I'm trying to poll a RESTful endpoint to refresh my live chat messages. I know the best approach for a live chat would be Websockets, I'm just trying to understand how RxJS works with Angular 2. </p>

<p>I want to check for new messages every second. I have the following code:</p>

<pre><code>return Rx.Observable
   .interval(1000)
   .flatMapLatest(() =&gt; this.http.get(`${AppSettings.API_ENDPOINT}/messages`))
   .map(response =&gt; response.json())
   .map((messages: Object[]) =&gt; {
      return messages.map(message =&gt; this.parseData(message));
   });
</code></pre>

<p>However my Typescript transpiler is returning this error:</p>

<blockquote>
  <p>Property 'flatMapLatest' does not exist on type 'Observable&lt;number&gt;'</p>
</blockquote>

<p>I'm using RxJS 5.0.0-beta.0</p>

<p>If I use <strong>merge</strong> instead of <strong>flatMapLatest</strong> it doesn't call the API at all. </p>
","2946773","","","user10747134","2019-02-11 03:34:06","2019-02-11 03:34:06","Angular 2 polling with RxJS","<angular><typescript><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"35010346","2","","35010182","2016-01-26 09:14:42","","8","","<p>You need to use <code>switchMap()</code>, there's no <code>flatMapLatest()</code> in RxJS 5.</p>

<p>See <a href=""https://github.com/ReactiveX/RxJS/blob/2b707faa5acf9245eb71e8529ba04b2a0d98ecd6/MIGRATION.md#operators-renamed-or-removed"">Migrating from RxJS 4 to 5</a>... Although docs aren't very clear about <code>switchMap()</code>...</p>

<blockquote>
  <p>Returns a new Observable by applying a function that you supply to each item emitted by the source Observable that returns an Observable, and then emitting the items emitted by the most recently emitted of these Observables.</p>
</blockquote>
","1876949","","1876949","","2016-01-26 09:42:00","2016-01-26 09:42:00","","","","3","","","","CC BY-SA 3.0"
"35094705","1","35095067","","2016-01-29 21:53:19","","5","5875","<p>How can we transform a Subject into an Observable in RxJs 5 ?  This functionality is useful for example when we want to expose the Subject for subscription but don't want to yield control of calling <code>next()</code> on it, and prefer to keep the issuing of new values private.</p>

<p>The docs (see <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/asobservable.md"" rel=""noreferrer"">here</a>) mention something like this:</p>

<pre><code>var subject = new Rx.Subject();

var obs = subject.asObservable();
</code></pre>

<p>But in RxJs 5 this currently does not work (alpha 8), we get the following error:</p>

<pre><code>""TypeError: subject.asObservable is not a function
</code></pre>
","2898867","","","","","2016-02-05 20:09:22","How to transform a Subject into an Observable in RxJs 5","<rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"35095067","2","","35094705","2016-01-29 22:18:53","","4","","<p>RxJS 5 is a rewrite (currently in beta) and has lots of <a href=""https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md"" rel=""nofollow"">renamed/removed methods</a>, among other changes. One of the removed ones is <code>asObservable</code>.</p>

<p>You can get the same functionality by creating an observable with the private subject's subscribe function:</p>

<pre><code>const subj = new rx.Subject();
const exposed = new rx.Observable(fn =&gt; subj.subscribe(fn));
</code></pre>
","345257","","345257","","2016-01-29 22:22:19","2016-01-29 22:22:19","","","","3","","","","CC BY-SA 3.0"
"35118707","1","","","2016-01-31 19:56:36","","0","67","<p>In my Scala coding, I have found the <code>collect</code> method pretty useful. It allows one to both filter and transform items, on one go.</p>

<p>There does not seem to be anything such in RxJS. Have I missed something obvious, or is it considered unnecessary?</p>

<p>The helper I did is trivial:</p>

<p><a href=""https://github.com/akauppi/svg.rx.js/blob/master/src/svg.rx.js#L27-L42"" rel=""nofollow"">https://github.com/akauppi/svg.rx.js/blob/master/src/svg.rx.js#L27-L42</a></p>
","14455","","","","","2016-02-05 20:03:54","RxJS5: how to map and filter on one go - like 'collect' in Scala?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"35141722","1","35141915","","2016-02-01 22:34:43","","40","20111","<p>Its not 100% clear for me how the RxJs 5 <code>share()</code> operator works, see here the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/share.md"">latest docs</a>. Jsbin for the question <a href=""https://jsbin.com/lijemuy/edit?html,js,console"">here</a>.</p>

<p>If I create an observable with a series of 0 to 2, each value separated by one second:</p>

<pre><code>var source = Rx.Observable.interval(1000)
.take(5)
.do(function (x) {
    console.log('some side effect');
});
</code></pre>

<p>And if I create two subscribers to this observable:</p>

<pre><code>source.subscribe((n) =&gt; console.log(""subscriptor 1 = "" + n));
source.subscribe((n) =&gt; console.log(""subscriptor 2 = "" + n));
</code></pre>

<p>I get this in the console: </p>

<pre><code>""some side effect ...""
""subscriptor 1 = 0""
""some side effect ...""
""subscriptor 2 = 0""
""some side effect ...""
""subscriptor 1 = 1""
""some side effect ...""
""subscriptor 2 = 1""
""some side effect ...""
""subscriptor 1 = 2""
""some side effect ...""
""subscriptor 2 = 2""
</code></pre>

<p>I thought each subscription would subscribe to the same Observable, but it does not seem to be the case! Its like the act of subscribing creates a completely separate Observable! </p>

<p>But if the <code>share()</code> operator is added to the source observable:</p>

<pre><code>var source = Rx.Observable.interval(1000)
.take(3)
.do(function (x) {
    console.log('some side effect ...');
})
.share();
</code></pre>

<p>Then we get this:</p>

<pre><code>""some side effect ...""
""subscriptor 1 = 0""
""subscriptor 2 = 0""
""some side effect ...""
""subscriptor 1 = 1""
""subscriptor 2 = 1""
""some side effect ...""
""subscriptor 1 = 2""
""subscriptor 2 = 2""
</code></pre>

<p>Which is what I would expect without the <code>share()</code>. </p>

<p>Whats going on here, how does the <code>share()</code>operator work ?  Does each subscription create a new Observable chain?</p>
","2898867","","3743222","","2016-08-22 16:45:12","2016-11-19 23:04:50","How does the RxJs 5 share() operator work?","<javascript><rxjs><rxjs5>","2","0","3","","","CC BY-SA 3.0"
"35141915","2","","35141722","2016-02-01 22:47:54","","22","","<p>Be careful that you are using RxJS v5 while your documentation link seem to be RxJS v4. I don't remember specifics but I think that the <code>share</code> operator went through some changes, in particular when it comes to completion and resubscription, but don't take my word for it.</p>

<p>Back to your question, as you have shown in your study, your expectations do not correspond to the library design. Observables lazily instantiate their data flow, concretely initiating the dataflow when a subscriber subscribes. When a second subscriber subscribes to the same observable, another new dataflow is started as if it is was the first subscriber (so yes, each subscription creates a new chain of observables as you said). This is what is coined in RxJS terminology as a cold observable and that's the default behaviour for RxJS observable. If you want an observable which sends its data to the subscribers it has at the moment the data arrives, this is coined a hot observable, and one way to get a hot observable is to use the <code>share</code> operator.</p>

<p>You can find illustrated subscription and data flows here : <a href=""https://stackoverflow.com/questions/32190445/hot-and-cold-observables-are-there-hot-and-cold-operators/34669444#34669444"">Hot and Cold observables : are there &#39;hot&#39; and &#39;cold&#39; operators?</a> (this is valid for RxJS v4, but most of it is valid for v5).</p>
","3743222","","-1","","2017-05-23 12:26:14","2016-02-01 22:47:54","","","","0","","","","CC BY-SA 3.0"
"35232636","2","","34852776","2016-02-05 20:07:42","","4","","<p>RxJS 5 has not been added to Bower, no. At this point NPM is recommended. This is primarily because Bower is just a fascade to GitHub and has a variety of other issues. We're also trying to follow the movement of more modern libraries moving away from Bower. There are also CDNs you can use.</p>

<p>If you strongly feel we should support bower <a href=""https://github.com/ReactiveX/RxJS/issues"" rel=""nofollow"">file an issue</a> so the whole community can discuss it. Thus far there hasn't been any demand though.</p>
","135786","","","","","2016-02-05 20:07:42","","","","2","","","","CC BY-SA 3.0"
"35246873","1","35248817","","2016-02-06 21:48:07","","9","6420","<p>According to the RxJS 5 <a href=""https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md#operators-renamed-or-removed"" rel=""noreferrer"">MIGRATION.md</a> it looks like <code>shareReplay()</code> been removed. </p>

<ol>
<li>Why?</li>
<li>Does <code>.publishReplay(1).refCount()</code> faithfully replicate the behaviour? Basically I need to replay the single most recent data set to any new subscribers.</li>
</ol>
","619602","","3743222","","2016-11-18 05:11:19","2017-07-19 10:20:53","shareReplay in RxJS 5","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"35248776","1","","","2016-02-07 01:42:56","","2","591","<p>I have to use an Observable in my tests and this little code:</p>

<pre><code>it(""should emit values"", () =&gt; {
   const f = Observable.of([1, 3, 5]);
   f.subscribe(d =&gt; console.log(d));
});
</code></pre>

<p>gives the following error:</p>

<blockquote>
  <p>TypeError: undefined is not a constructor (evaluating 'Observable_1.Observable.of([1, 3, 5])')</p>
</blockquote>

<p><strong>But</strong> if I put these 2 lines of code <strong>inside a component</strong> (say, in ngOnInit) I see emitted values and <strong>no error</strong>. I wonder if this me or angular 2 has some issues with its testing codebase?</p>

<p>Just in case, these are all imports I use in this particular test file:</p>

<hr>

<pre><code>import {
it,
inject,
injectAsync,
beforeEachProviders,
TestComponentBuilder
} from 'angular2/testing';

import {ComponentFixture, dispatchEvent, fakeAsync, tick} from 'angular2/testing_internal';

import {provide, bind} from 'angular2/core';
import {FormBuilder} from 'angular2/common';
import {By} from 'angular2/platform/browser';
import {Observable} from 'rxjs/Observable';
import {ArrayObservable} from 'rxjs/observable/fromArray';
import {Subject} from 'rxjs/Subject';
import {BehaviorSubject} from 'rxjs/subject/BehaviorSubject';

import {SpyLocation} from 'angular2/src/mock/location_mock';
import {RootRouter} from 'angular2/src/router/router';
import {Router, RouterOutlet, RouterLink, RouteParams, ComponentInstruction, RouteData, Location, ROUTER_PRIMARY_COMPONENT} from 'angular2/router';
import {
RouteConfig,
Route,
AuxRoute,
AsyncRoute,
Redirect
} from 'angular2/src/router/route_config_decorator';
import {RouteRegistry} from 'angular2/src/router/route_registry';
import {DirectiveResolver} from 'angular2/src/core/linker/directive_resolver';
import {ResolvedInstruction} from 'angular2/src/router/instruction';
</code></pre>

<hr>
","2896495","","4375351","","2016-02-08 15:19:57","2016-04-15 07:02:44","Observable.from() in angular 2 tests - errors inside test method","<angularjs><angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"35248817","2","","35246873","2016-02-07 01:51:00","","8","","<p>The short answer :
Quoting Sir Blesh :</p>

<blockquote>
  <p>The problem RxJS 5 is trying to solve is that ConnectableObservables
  should be ""reconnectable"", and <code>refCount</code> should return an observable
  that is cold until subscribed to, then hot until all subscriptions
  have ended, then cold again.</p>
</blockquote>

<p>The issue is that of the behaviour of subjects after completion which prevents a connectable observable to be reconnected when completed. </p>

<p>The long answer : 
<a href=""https://github.com/ReactiveX/RxJS/issues/453"" rel=""noreferrer"">https://github.com/ReactiveX/RxJS/issues/453</a></p>

<p>The current API appears to be the result of a compromise between two visions of the reconnection issue. It would be great if those involved could do a summary of the issues at hand. My understanding is that <code>.publishReplay(1).refCount()</code> should keep the old behaviour, that is that when your number of subscribers reaches 0, the source is disconnected, and you can't replay it. But don't take my word for it, test it, I got lost following the discussion.</p>
","3743222","","","","","2016-02-07 01:51:00","","","","0","","","","CC BY-SA 3.0"
"35274523","1","35274611","","2016-02-08 16:31:21","","4","3607","<p>I have some code that handles all http access in a class that handles adding tokens.  It returns an Observable.   I want to catch errors in that class - in particular authentication problems.  I am an RXjs beginner and can't figure out how to do this and still return an Observable.  A pointer to some fairly comprehensive rxJS 5 documentation (that isn't source code!) would be useful.</p>
","454577","","","","","2016-02-08 16:36:31","Handling Angular 2 http errors centrally","<angular><rxjs5>","1","1","","","","CC BY-SA 3.0"
"35274611","2","","35274523","2016-02-08 16:36:31","","9","","<p>You can leverage the <code>catch</code> operator when executing an HTTP call within a service:</p>

<pre><code>getCompanies() {
  return this.http.get('https://angular2.apispark.net/v1/companies/')
           .map(res =&gt; res.json())
           .catch(res =&gt; {
             // do something

             // To throw another error, use Observable.throw
             // return Observable.throw(res.json());
           });
}
</code></pre>

<p>Another approach could be to extend the HTTP object to intercept errors:</p>

<pre><code>@Injectable()
export class CustomHttp extends Http {
  constructor(backend: ConnectionBackend, defaultOptions: RequestOptions) {
    super(backend, defaultOptions);
  }

  request(url: string | Request, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    console.log('request...');
    return super.request(url, options).catch(res =&gt; {
      // do something
    });        
  }

  get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    console.log('get...');
    return super.get(url, options).catch(res =&gt; {
      // do something
    });
  }
}
</code></pre>

<p>and register it as described below:</p>

<pre><code>bootstrap(AppComponent, [HTTP_PROVIDERS,
    new Provider(Http, {
      useFactory: (backend: XHRBackend, defaultOptions: RequestOptions) =&gt; new CustomHttp(backend, defaultOptions),
      deps: [XHRBackend, RequestOptions]
  })
]);
</code></pre>

<p>What to use really depends on your use case...</p>
","1873365","","","","","2016-02-08 16:36:31","","","","4","","","","CC BY-SA 3.0"
"35282304","1","","","2016-02-09 01:09:46","","4","2106","<p>I've a <strong>subject</strong> called <strong>authenticated</strong> in <strong>_auth</strong> service. </p>

<p>I want to <strong>dispose/unsubscribe</strong> it <strong>if some condition fails</strong> so that this subscribe doesn't call when next value arrives in authenticated subject.</p>

<pre><code>                this.sub = this._auth.authenticated
                .subscribe((loggedIn) =&gt; {
                    if (!loggedIn) {
                        this.sub.dispose(); // doesn't work because this.sub is null
                        this._location.replaceState('/');
                        this._auth.doLogout(); // emits value again in authenticated subject
                    }
                });
</code></pre>

<p>What is the rxjs-5 way of doing it?</p>
","1096949","","","","","2019-10-02 11:58:31","dispose/unsubscribe inside subscribe function block in rxjs","<javascript><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"35305670","1","35310088","","2016-02-10 02:06:00","","7","3311","<p>I'm using Angular 2 to make a directive. I have the following events bound to the host component:</p>

<pre><code>host: {
    '(mouseenter)': 'onMouseEnter($event)',
    '(mouseleave)': 'onMouseLeave($event)'
}
</code></pre>

<p>I also created two streams and listeners on the directive to manage the two events</p>

<pre><code>export class PopupDirective {
    private _mouseEnterStream: EventEmitter&lt;any&gt; = new EventEmitter();
    private _mouseLeaveStream: EventEmitter&lt;any&gt; = new EventEmitter();

    onMouseEnter($event) {
         this._mouseEnterStream.emit($event);
    }

    onMouseLeave($event) {
         this._mouseLeaveStream.emit($event);
    }
}
</code></pre>

<p>I want my <code>subscribe</code> to only be called if the <code>mouseenter</code> event is still active after a fixed delay (i.e., a <code>mouseleave</code> hasn't occured). I tried doing it this way, but it doesn't work (which makes sense, I just don't know how to fix it).</p>

<pre><code>this._mouseEnterStream.flatMap((e) =&gt; {
  return Observable
    .of(e)
    .takeUntil(this._mouseLeaveStream);
}).delay(2000).subscribe(
  () =&gt; console.log('yay, it worked!')
);
</code></pre>

<p>Does anyone with Angular 2 / RxJS experience know how I should approach this?</p>
","1008741","","1008741","","2016-02-10 05:27:49","2019-01-21 16:45:08","Angular 2 RxJS check if mouse event is still active after delay","<angular><rxjs><rxjs5>","2","6","2","","","CC BY-SA 3.0"
"35310088","2","","35305670","2016-02-10 08:27:51","","5","","<p>The GÃ¼nter's answer is exactly what you expect but you should use the <code>of</code> operator instead of the <code>return</code> one that doesn't exist.</p>

<pre><code>this._mouseEnterStream.flatMap((e) =&gt; {
  console.log('_mouseEnterStream.flatMap');
  return Observable
      .of(e)
      .delay(2000)
      .takeUntil(this._mouseLeaveStream);
}).subscribe(
  (e) =&gt; {
    console.log('yay, it worked!');
    console.log(e);
  }
);
</code></pre>

<p>See the corresponding plunkr: <a href=""https://plnkr.co/edit/vP3xRDXxFanqzLEKd3eo?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/vP3xRDXxFanqzLEKd3eo?p=preview</a>.</p>

<p>Also, there is <a href=""https://github.com/angular/angular/issues/13248"" rel=""nofollow noreferrer"">a proposal in Angular</a> that aims to simplify the way observables are created from DOM events using Rx via template syntax.</p>
","1873365","","2135910","","2019-01-21 16:45:08","2019-01-21 16:45:08","","","","5","","","","CC BY-SA 4.0"
"35316583","1","44418812","","2016-02-10 13:28:46","","60","73237","<p>I am quite new to angular and rxjs. 
I am trying to create an angular2 app that gets some data from staticly served text file(Locally on server), which I would like to retrieve and map to Datamodel using Angular2's http provider and rxjs's map at a fixed time <code>interval(5000)</code>. To reflect any changes to the served txt file. </p>

<p>With rxjs 4.x I know you could use <code>Observable.interval(5000)</code> to do the job, but it does not seem to exist in rxjs 5. 
My workaround currently refresh the whole application using <code>&lt;meta http-equiv=""refresh"" content=""5"" &gt;</code> Which reloads the whole page, and thus reloads the data.</p>

<p>So what I would really like is some way to do this working with observables, maybe to check if any changes have happened. or just to reload the data anew.</p>

<p>Any help or other/better way will be very much appreciated.</p>

<p>What I have so far:</p>

<pre><code>@Injectable()
export class DataService {

    constructor(private http:Http){}

    getData(url) {
        return this.http.get(url)
            .map(res =&gt; {
                return res.text();
            })
            .map(res =&gt; {
                return res.split(""\n"");
            })
            .map(res =&gt; {
                var dataModels: DataModel[] = [];
                res.forEach(str =&gt; {
                    var s = str.split("","");
                    if(s[0] !== """") {
                        dataModels.push(new DataModel(s[0], parseInt(s[1]), parseInt(s[2])));
                    }
                });
                return dataModels;
            })
    }
}

@Component({
selector: 'my-app',
template: `Some html to display the data`,
providers: [DataService],
export class AppComponent {

data:DataModel[];

constructor(dataService:DataService) {}

ngOnInit() {
    this.dataService.getData('url').subscribe(
        res =&gt; {
            this.data= res;

        },
        err =&gt; console.log(err),
        () =&gt; console.log(""Data received"")
        );
    }
}
</code></pre>

<p>Dependencies: package.json</p>

<pre><code>""dependencies"": {
  ""angular2"": ""^2.0.0-beta.3"",
  ""bootstrap"": ""^4.0.0-alpha.2"",
  ""es6-promise"": ""^3.0.2"",
  ""es6-shim"": ""^0.33.13"",
  ""jquery"": ""^2.2.0"",
  ""reflect-metadata"": ""^0.1.2"",
  ""rxjs"": ""^5.0.0-beta.0"",
  ""systemjs"": ""^0.19.20"",
  ""zone.js"": ""^0.5.11""
},
""devDependencies"": {
  ""typescript"": ""^1.7.5""
}
</code></pre>

<p>index.html imports: </p>

<pre><code>&lt;script src=""node_modules/es6-shim/es6-shim.min.js""&gt;&lt;/script&gt;
&lt;script src=""node_modules/systemjs/dist/system-polyfills.js""&gt;&lt;/script&gt;

&lt;script src=""node_modules/angular2/bundles/angular2-polyfills.js""&gt;&lt;/script&gt;
&lt;script src=""node_modules/systemjs/dist/system.src.js""&gt;&lt;/script&gt;
&lt;script src=""node_modules/rxjs/bundles/Rx.js""&gt;&lt;/script&gt;
&lt;script src=""node_modules/angular2/bundles/angular2.dev.js""&gt;&lt;/script&gt;
&lt;script src=""node_modules/angular2/bundles/router.dev.js""&gt;&lt;/script&gt;
&lt;script src=""node_modules/angular2/bundles/http.dev.js""&gt;&lt;/script&gt;
</code></pre>
","2374893","","3345644","","2021-01-07 22:54:17","2021-01-07 22:54:17","How to make HTTP request at an interval?","<angular><rxjs5>","6","0","34","","","CC BY-SA 4.0"
"35343183","1","35379655","","2016-02-11 15:19:55","","14","5530","<p>I use <a href=""https://github.com/ReactiveX/RxJS"" rel=""nofollow"">RxJs version 5</a> within my Angular 2 project.
I want to create some observables but I don't want the observables being invoked immediately. </p>

<p>In <a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""nofollow"">version 4</a> you could control the invocation with (for example) the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/controlled.md"" rel=""nofollow"">Controlled</a> command or <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/pausablebuffered.md"" rel=""nofollow"">Pausable Buffers</a>.
But that functionality is not (<a href=""https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md#operators-renamed-or-removed"" rel=""nofollow"">yet</a>) available in version 5.</p>

<p>How can I get the this kind of functionality in RxJs 5?</p>

<p>My ultimate goal is to queue the created observables and invoke them one by one. The next one is only invoked when the previous one is processed successfully.
When one fails, the queue is emptied.</p>

<p><strong>EDIT</strong></p>

<p>With the the comment of @Niklas Fasching I could create a working solution with the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/publish.md"" rel=""nofollow"">Publish</a> operation.</p>

<p><a href=""http://jsbin.com/xiyituqezi/3/edit?js,console"" rel=""nofollow"">JS Bin</a></p>

<pre><code>// Queue to queue operations
const queue = [];

// Just a function to create Observers
function createObserver(id): Observer {
    return {
        next: function (x) {
            console.log('Next: ' + id + x);
        },
        error: function (err) {
            console.log('Error: ' + err);
        },
        complete: function () {
            console.log('Completed');
        }
    };
};

// Creates an async operation and add it to the queue
function createOperation(name: string): Observable {

  console.log('add ' + name);
  // Create an async operation
  var observable = Rx.Observable.create(observer =&gt; {
    // Some async operation
    setTimeout(() =&gt; 
               observer.next(' Done'), 
               500);
  });
  // Hold the operation
  var published = observable.publish();
  // Add Global subscribe
  published.subscribe(createObserver('Global'));
  // Add it to the queue
  queue.push(published);
  // Return the published so the caller could add a subscribe
  return published;
};

// Create 4 operations on hold
createOperation('SourceA').subscribe(createObserver('SourceA'));
createOperation('SourceB').subscribe(createObserver('SourceB'));
createOperation('SourceC').subscribe(createObserver('SourceC'));
createOperation('SourceD').subscribe(createObserver('SourceD'));

// Dequeue and run the first
queue.shift().connect();
</code></pre>
","874249","","874249","","2016-02-12 12:38:34","2016-06-28 13:27:25","RXJS control observable invocation","<typescript><angular><rxjs><rxjs5>","2","3","2","","","CC BY-SA 3.0"
"35379655","2","","35343183","2016-02-13 12:09:31","","6","","<p>You can seperate the start of the observable from subscription to it by <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/publish.md"" rel=""noreferrer"">publishing</a> the observable. The published observable will only be started after calling <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/connect.md"" rel=""noreferrer"">connect</a> on it.</p>

<p>Note that all subscribers will share a single subscription to the observable sequence.</p>

<pre><code>var published = Observable.of(42).publish();
// subscription does not start the observable sequence
published.subscribe(value =&gt; console.log('received: ', value));
// connect starts the sequence; subscribers will now receive values
published.connect();
</code></pre>
","4085941","","","","","2016-02-13 12:09:31","","","","0","","","","CC BY-SA 3.0"
"35413390","1","35531926","","2016-02-15 15:42:13","","2","3152","<p>I'm working with <code>@ngrx/store</code> and I'm displaying notification when request starts or returns an error and hiding it if request is successful. It works as intended, and I wanted to delay initial notification so it's not shown if request ends quickly. I've tried several Observable/Subject operators that work with time:</p>

<ul>
<li>With <code>delay</code> and <code>bufferTime</code> <strong>message</strong> is <code>null</code> which causes an error in  <code>&lt;notification&gt;</code> </li>
<li>Using <code>debounceTime</code> doesn't show initial message, but with slow responses and errors <strong>message</strong> is still <code>null</code></li>
<li><code>throttleTime</code> only shows initial notification and hides it with slow responses</li>
</ul>

<p>Without any of these <code>*ngIf=""(notification |async)""</code> does it's job and <strong>message</strong> is set only if notification isn't <code>null</code>.</p>

<p>I suppose I could just hide <code>&lt;notification&gt;</code> with CSS transition delay, but I was wondering if anyone knows other way to solve this...</p>

<pre><code>@Component({
  template: `&lt;notification [message]=""notification |async"" *ngIf=""(notification |async)""&gt;&lt;/notification&gt;`
})
export class RootRoute {
  constructor(...) {
    this.notification = this.store.select('notification')
      // None of these solve my issue:
      // .delay(250)
      // .throttleTime(250)
      // .debounceTime(250)
      // .bufferTime(250)
  }
}

export class Service {

  private request(method: any, values: any, endpointsUrl: string, actionType: string, storeSelector?) {
    this.store.dispatch({ type: ""SHOW_NOTIFICATION"", payload: {code: 200, message: ""Getting data from server...""} });

    this._http.request(BASE_URL + endpointsUrl, { body: JSON.stringify(values), method: method })
      .map(response =&gt; response.json())
      .map(payload =&gt; ({ type: actionType, payload }))
      .subscribe({
        next: action =&gt; this.store.dispatch(action),
        error: payload =&gt; this.store.dispatch({ type: 'API_ERROR', payload }),
        complete: () =&gt; this.store.dispatch({ type: ""HIDE_NOTIFICATION"" })
      });

    if (storeSelector)
      return this.store.select(storeSelector);
  }

}
</code></pre>
","1876949","","1876949","","2016-02-15 16:10:52","2016-02-21 03:26:42","Issue with Observable/Subject delay/throttle (ngIf & async)","<angular><rxjs5><ngrx>","2","4","","","","CC BY-SA 3.0"
"35513015","1","35513390","","2016-02-19 19:05:10","","16","12328","<p>Trying to render the window size on window resize through a stream in an angular 2 component utilizing an <code>async</code> pipe:</p>

<p><code>&lt;h2&gt;Size: {{size$ | async | json}}&lt;/h2&gt;</code></p>

<pre><code>const windowSize$ = new BehaviorSubject(getWindowSize());
Observable.fromEvent(window, 'resize')
  .map(getWindowSize)
  .subscribe(windowSize$);

function getWindowSize() {
  return {
    height: window.innerHeight,
    width: window.innerWidth
  };
}

@Component({
  selector: 'my-app',
  providers: [],
  template: `
    &lt;div&gt;
      &lt;h2&gt;Size: {{size$ | async | json}}&lt;/h2&gt;
    &lt;/div&gt;
  `,
  directives: []
})
export class App {
  size$ = windowSize$.do(o =&gt; console.log('size:', o));
  constructor() {  }
}
</code></pre>

<p>But the component only renders the initial state and ignores the stream updates.
If you open the console, on window resize, you'll see the updates from that same stream.</p>

<p>Can't understand what i am missing here.</p>

<p>Here's a <a href=""http://plnkr.co/edit/pg4Hkh0xfDRPvtfLwvZN?p=preview"" rel=""noreferrer"">plunker</a></p>
","592641","","215945","","2016-04-20 15:22:26","2021-09-13 17:52:54","""async"" pipe not rendering the stream updates","<angular><rxjs><rxjs5><angular2-changedetection>","3","0","5","","","CC BY-SA 3.0"
"35513390","2","","35513015","2016-02-19 19:26:24","","14","","<p>The event handler is running outside the Angular zone, so Angular change detection doesn't run when an event fires.  Put the event handler inside your component and then it will get monkey-patched along with all of the other asynchronous events, hence Angular change detection will execute after each event (and update the view):</p>

<pre><code>ngOnInit() {
    Observable.fromEvent(window, 'resize')
     .map(getWindowSize)
     .subscribe(windowSize$);
}
</code></pre>

<p><kbd><a href=""http://plnkr.co/edit/z5OriNTq1xqioO94KrEW?p=preview"" rel=""noreferrer"">Plunker</a></kbd></p>

<hr>

<p>Another option, discussed in the comments, is to <a href=""https://stackoverflow.com/a/35106069/215945"">manually run change detection</a> when a view model is updated:</p>

<pre><code>import {Component, ChangeDetectorRef} from 'angular2/core'
...
export class App {
  size$ = windowSize$.do(o =&gt; {
     console.log('size:', o);
     // since the resize event was not registered while inside the Angular zone,
     // we need to manually run change detection so that the view will update
     this._cdr.detectChanges();
  });

  constructor(private _cdr: ChangeDetectorRef) {}
}
</code></pre>

<p><kbd><a href=""http://plnkr.co/edit/eiua3K9aRRFEyxV3vbtP?p=preview"" rel=""noreferrer"">Plunker</a></kbd></p>

<p>Note that you might instead want to try running <code>ApplicationRef.tick()</code> once, say in your root component, which will run change detection on all of the components &ndash; rather than running <code>ChangeDetectorRef.detectChanges()</code> in each component.  (And you might need to wrap <code>tick()</code> inside a <code>setTimeout()</code> method, to ensure that all of the component view models were updated... I'm not sure when all of the <code>do()</code> callback methods will be executed -- i.e., if they all run in one turn of the JavaScript VM, or if multiple turns are involved.)</p>
","215945","","-1","","2017-05-23 12:25:42","2016-02-19 20:04:46","","","","2","","","","CC BY-SA 3.0"
"35519551","1","35519799","","2016-02-20 05:30:25","","2","738","<p>I want to run first authenticate http get function, once its successful, then run another function and then return back Observable, so it can be subscribe and continue using with other methods.</p>

<pre><code>return new Observable(observer =&gt; {
            this.api
                .login(username, password)
                .subscribe(
                    data =&gt; {
                        this.data = this.dataParse(data);
                        observer.next(this.data);
                        observer.complete();
                    });


            // run another http.get to get user profile, before sending back Observable
        });
</code></pre>

<p>I'm not sure how to run another http.get and then return observable. </p>

<p>I can run another function inside .subscribe() method, but then it wont be linked with current Observable</p>
","75799","","","","","2017-01-25 02:21:23","Angular2 Observable","<http><angular><observable><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"35519799","2","","35519551","2016-02-20 06:02:41","","3","","<p>While I have not tried, you need to pipe the response for the login to a chain of operators. Something along these lines:</p>

<pre class=""lang-js prettyprint-override""><code>return this.api
           .login(username, password)
           .map((res:Response) =&gt; res.json())
           .mergeMap(data=&gt; $http.get(data.id));
</code></pre>

<p>You do not need to create a new Observable.</p>
","361151","","1773434","","2017-01-25 02:21:23","2017-01-25 02:21:23","","","","0","","","","CC BY-SA 3.0"
"35521330","1","35522543","","2016-02-20 09:26:12","","0","117","<p>I was looking through the source code of <a href=""https://github.com/ReactiveX/RxJS/blob/master/src/operator/combineLatest.ts"" rel=""nofollow"">RxJS 5 combineLatest</a> and found lots of permutations of a call with numbered parameters.</p>

<p>Why is this done when there are rest parameters?</p>

<p>Are there any upcoming features of TypeScript that will make this less verbose?</p>

<p>I was wondering if it was to do with typing of rest parameters or perhaps intellisense? </p>

<pre><code>export interface CombineLatestSignature&lt;T&gt; {
  &lt;R&gt;(project: (v1: T) =&gt; R): Observable&lt;R&gt;;
  &lt;T2, R&gt;(v2: ObservableInput&lt;T2&gt;, project: (v1: T, v2: T2) =&gt; R): Observable&lt;R&gt;;
  &lt;T2, T3, R&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, project: (v1: T, v2: T2, v3: T3) =&gt; R): Observable&lt;R&gt;;
  &lt;T2, T3, T4, R&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, v4: ObservableInput&lt;T4&gt;, project: (v1: T, v2: T2, v3: T3, v4: T4) =&gt; R): Observable&lt;R&gt;;
  &lt;T2, T3, T4, T5, R&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, v4: ObservableInput&lt;T4&gt;, v5: ObservableInput&lt;T5&gt;, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) =&gt; R): Observable&lt;R&gt;;
  &lt;T2, T3, T4, T5, T6, R&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, v4: ObservableInput&lt;T4&gt;, v5: ObservableInput&lt;T5&gt;, v6: ObservableInput&lt;T6&gt;, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) =&gt; R): Observable&lt;R&gt;;

  &lt;T2&gt;(v2: ObservableInput&lt;T2&gt;): Observable&lt;[T, T2]&gt;;
  &lt;T2, T3&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;): Observable&lt;[T, T2, T3]&gt;;
  &lt;T2, T3, T4&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, v4: ObservableInput&lt;T4&gt;): Observable&lt;[T, T2, T3, T4]&gt;;
  &lt;T2, T3, T4, T5&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, v4: ObservableInput&lt;T4&gt;, v5: ObservableInput&lt;T5&gt;): Observable&lt;[T, T2, T3, T4, T5]&gt;;
  &lt;T2, T3, T4, T5, T6&gt;(v2: ObservableInput&lt;T2&gt;, v3: ObservableInput&lt;T3&gt;, v4: ObservableInput&lt;T4&gt;, v5: ObservableInput&lt;T5&gt;, v6: ObservableInput&lt;T6&gt;): Observable&lt;[T, T2, T3, T4, T5, T6]&gt;;

  &lt;R&gt;(...observables: Array&lt;ObservableInput&lt;any&gt; | ((...values: Array&lt;any&gt;) =&gt; R)&gt;): Observable&lt;R&gt;;
  &lt;R&gt;(array: ObservableInput&lt;any&gt;[]): Observable&lt;R&gt;;
  &lt;R&gt;(array: ObservableInput&lt;any&gt;[], project: (...values: Array&lt;any&gt;) =&gt; R): Observable&lt;R&gt;;
}
</code></pre>
","2800482","","","","","2016-02-20 11:25:28","Why so many permutations of parameters in this TypeScript code","<typescript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"35522543","2","","35521330","2016-02-20 11:25:28","","1","","<p>Rest parameters all have to declared with the same type so it's impossible to accurately model this particular interface with just rest parameters. I don't see any way this interface could be made less verbose without losing useful type information.</p>
","1259938","","","","","2016-02-20 11:25:28","","","","1","","","","CC BY-SA 3.0"
"35531128","1","36276552","","2016-02-21 01:14:54","","16","938","<p>I was watching Matthew Podwysocki event on <a href=""https://www.youtube.com/watch?v=zlERo_JMGCw"">https://www.youtube.com/watch?v=zlERo_JMGCw</a> 29:38</p>

<p>Where he explains how they solved scroll on netflix. Where user scroll for more data as previous data gets cleaned up and more adds up (but scroll back shows previous data again).</p>

<p>I wanted to do similar, but I grabbed netflix demo code: </p>

<pre><code>function getRowUpdates(row) {
  var scrolls = Rx.Observable.fromEvent(document, 'scroll');
  var rowVisibilities = 
    scrolls.throttle(50)
      .map(function(scrollEvent) {
        return row.isVisible(scrollEvent.offset);
      })
      .distinctUntilChanged();

  var rowShows = rowrowVisibilities.filter(function(v) {
    return v;
  });
  var rowHides = rowrowVisibilities.filter(function(v) {
    return !v;
  });

  return rowShows
    .flatMap(Rx.Observable.interval(10))
    .flatMap(function() {
      return row.getRowData().takeUntil(rowHides);
    })
    .toArray();
}
</code></pre>

<p>But I'm bit confused on how to pass new data or page data according to the scroll here..  Can someone give little explanation on how I can do the following:</p>

<ul>
<li>fetch first list (I can do that)</li>
<li>fetch more list as user scroll down (using paging next page)</li>
<li>remove previous fetched data from memory, and refetch on request (scroll up). </li>
</ul>
","75799","","1371131","","2016-02-21 03:36:57","2016-03-31 03:56:40","RxJS Polling for row updates on infinite scroll","<javascript><scroll><xmlhttprequest><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"35531926","2","","35413390","2016-02-21 03:26:42","","1","","<p>I ended up with:</p>

<pre><code>this.store.select('notification')
  .debounceTime(250)
  .subscribe((message: INotification) =&gt; this.notification = message);
</code></pre>

<p>and reverted back to <code>ChangeDetectionStrategy.Default</code> for this component. I guess it's one of the issues with <code>async</code> pipe...</p>
","1876949","","","","","2016-02-21 03:26:42","","","","0","","","","CC BY-SA 3.0"
"35544378","1","35546511","","2016-02-22 01:22:55","","4","219","<p>We have over 500 rows from list on each request, sometimes it's 10 and sometimes its huge.</p>

<p>I want to take that array and only show what is visible on the screen and hide everything else, but has user scroll down it will display other rows and hide previous ones.</p>

<p>This is bit complex, I was watching RxJS video and Netflix did similar. I'm not sure what functions to use to have this effect.</p>

<p><a href=""https://gist.github.com/iBasit/8ceef1db9de945a37559"">https://gist.github.com/iBasit/8ceef1db9de945a37559</a> Netflix example.</p>

<p>Our code:</p>

<pre><code>Observable.fromArray([0,1,2,.....500]).subscribe(row =&gt; show(row));
</code></pre>
","75799","","","","","2016-02-25 07:39:14","Complex RxJS iterator only visible rows","<javascript><scroll><angular><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"35546511","2","","35544378","2016-02-22 05:41:50","","1","","<p>I've written a couple articles (like <a href=""http://qiita.com/kimagure/items/d29ed7b7bdaaf6977b9a"" rel=""nofollow"">this one</a>) and various demos on how to do this ""virtual scrolling thing"", but basically what you need is either static row heights or the ability to determine if a given row will be visible on the screen (<code>Row#isRowVisible</code> in that gist you linked).</p>

<p>Then the easiest way to display rows afterwards is to absolutely position them such that you either multiply the index by your static row height OR calculate where the row should display somehow.</p>

<p><a href=""https://github.com/justinwoo/react-rxjs-scroll/blob/master/src/index.js"" rel=""nofollow"">This</a> is a pretty rough demo of how to do this in React, but the ideas are very similar (you might be able to just copy paste the RxJS code from that or my Cycle.js example). I'd encourage you to try making it yourself though.</p>

<p>Also, 500 items really shouldn't be much of a problem for angular2 (it's really fast), unless you have a ton of elements in each row.</p>
","1784261","","","","","2016-02-22 05:41:50","","","","4","","","","CC BY-SA 3.0"
"35593808","1","","","2016-02-24 05:17:10","","2","3473","<p>I am learning RxJs now days and came accross following two functions which are part of thier helper library</p>

<pre><code>Rx.helpers.identity(x)
</code></pre>

<p>and </p>

<pre><code>Rx.helpers.noop() 
</code></pre>

<p><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/helpers/readme.md"" rel=""nofollow"">According to the RxJs Helpers documentation</a>
for Rx.helpers.identity(x), the documentation says that this is a function which just returns the value that is passed into it unmodified. For Rx.helpers.noop, they say this function really does nothing.</p>

<p>Q: What is the purpose to provide these functions and in which scenario it is useful to use these functions?</p>
","2797765","","","","","2017-03-16 13:36:04","RxJs noop and Identity functions","<rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"35633684","1","35635130","","2016-02-25 17:03:15","","67","99693","<p>My service class, before calling a web service, needs to get a property called <code>dataForUpdate</code> from my state. Currently, I'm doing it like this:</p>

<pre class=""lang-js prettyprint-override""><code>constructor(public _store: Store &lt; AppState &gt; ,
  public _APIService: APIService) {

  const store$ = this._store.select('StateReducer');

  .../...

  let update = this.actions$.filter(action =&gt; action.type == UPDATE)
    .do((action) =&gt; this._store.dispatch({
      type: REDUCER_UPDATING,
      payload: action.payload
    })) **
    * GET STATE ** *= =&gt; .mergeMap(action =&gt; store$.map((state: AppState) =&gt; state.dataForUpdate).distinctUntilChanged(),
      (action, dataForUpdate) {
        return {
          type: action.type,
          payload: {
            employee: action.payload,
            dataForUpdate: dataForUpdate
          }
        };
      }) *
    AND CALL API *= =&gt; .mergeMap(action =&gt; this._APIService.updateEmployee(action.payload.employee, action.payload.dataForUpdate),
      (action, APIResult) =&gt; {
        return {
          type: REDUCER_UPDATED
        }
      })
    .share();


  .../...

  let all = Observable.merge(update, ....);
  all.subscribe((action: Action) =&gt; this._store.dispatch(action));

}
</code></pre>



<p>I'm using angular2-store-example (<a href=""https://github.com/ngrx/angular2-store-example/blob/master/src/app/users/models/users.ts"" rel=""noreferrer"">https://github.com/ngrx/angular2-store-example/blob/master/src/app/users/models/users.ts</a>) as a guide to follow.</p>

<p>I'm wondering if a better (cleaner) way exists?</p>

<p>Live example: <a href=""https://plnkr.co/edit/WRPfMzPolQsYNGzBUS1g?p=preview"" rel=""noreferrer"">https://plnkr.co/edit/WRPfMzPolQsYNGzBUS1g?p=preview</a></p>
","22280","","4812515","","2020-02-24 23:26:45","2021-05-25 16:44:47","How to get current value of State object with @ngrx/store?","<angular><rxjs5><ngrx>","11","0","11","","","CC BY-SA 4.0"
"35635130","2","","35633684","2016-02-25 18:17:51","","79","","<h3>Original answer for @ngrx/store v1.x</h3>

<p><code>@ngrx/store</code> extends <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md"" rel=""noreferrer"">BehaviorSubject</a> and it has a <code>value</code> property you can use.</p>

<pre><code>this._store.value
</code></pre>

<p>that will be the current state of your app, and from there you can select properties, filter, map etc...</p>

<p><strong>update:</strong></p>

<p>Took me a while to figure what's what in your example (: To get current value of <code>dataForUpdate</code>, you can use:</p>

<pre><code>let x = this._store.value.StateReducer.dataForUpdate;
console.log(x); // =&gt; { key: ""123"" }
</code></pre>

<h2>Update for @ngrx/store v2.x</h2>

<p>With the update to version 2, <code>value</code> was removed as described in <a href=""https://github.com/ngrx/store#getstate-getvalue-and-value"" rel=""noreferrer"">docs</a>:</p>

<blockquote>
  <p>The APIs for synchronously pulling the most recent state value out of Store have been removed. Instead, you can always rely on <code>subscribe()</code> running synchronously if you have to get the state value:</p>
</blockquote>

<pre><code>function getState(store: Store&lt;State&gt;): State {
    let state: State;

    store.take(1).subscribe(s =&gt; state = s);

    return state;
}
</code></pre>
","1876949","","1876949","","2016-06-13 15:45:35","2016-06-13 15:45:35","","","","13","","","","CC BY-SA 3.0"
"35683473","1","36584711","","2016-02-28 14:05:23","","0","90","<p>I'm using RxJS5 (<a href=""https://github.com/ReactiveX/RxJS"" rel=""nofollow"">https://github.com/ReactiveX/RxJS</a>) and I'm trying to access the Riot API which has a cap rate of 500 requests every 10 minutes and 10 requests every 10 seconds.</p>

<p>I set up a stream of request objects and I have a subscriber ready to get them and actually request them, but I'm kinda new at RxJS and not sure which operator I should use to cap the requests.</p>
","3052465","","","","","2016-04-12 21:50:01","Using Rxjs5 (Beta) to cap http requests","<rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"35718059","1","35848809","","2016-03-01 08:35:37","","0","3133","<p>I have an array that looks like this</p>

<pre><code>[
  {
    name: 'foo'
    filter: Observable.of(true)
  },
  {
    name: 'bar'
    filter: Observable.of(false)
  }
]
</code></pre>

<p>and I want to return only items whose <code>filter</code> resolves in true, how would I do that in the most efficient and reactive way? I'm using rxjs5 beta2.</p>

<hr>

<p>Note that it's a pseudocode for simplicity sake, in my real case filter is actually an object, that is passed to a validation function, which returns an observable that resolves in <code>true</code> or <code>false</code>.</p>
","301596","","","","","2016-03-07 16:24:13","rxjs5 - filtering array of objects by observable that each object contains","<javascript><typescript><rxjs><observable><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"35740821","1","35762723","","2016-03-02 07:21:01","","1","889","<p>In RxJS version 5, the following code results in the process being terminated after three iterations of both subscriptions:</p>

<pre><code>var Rx = require(""rxjs"");

const published$ = Rx.Observable.interval(1000).publish();

published$.subscribe(index =&gt; {
    console.log(`One: ${index}`);

    if (index == 3) throw new Error(""ded."");
});

published$.forEach(index =&gt; {
    console.log(`Two: ${index}`);
});

published$.connect();
</code></pre>

<p>However, my understanding was that an error thrown in the next handler would simply unsubscribe that particular subscription, and not cause the underlying observable to terminate. My expected output would be that the ""One"" subscription would unsubscribe, but the interval would continue to produce results to the ""Two"" subscription.</p>

<p>This behavior is causing me issues, where I may have multiple subscriptions to an underlying hot observable - yet a single exception thrown on any of those subscriptions causes the underlying observable to completely terminate.</p>

<p>It's especially annoying when I'm in development using hot module reloading, since any programming error in any subscription causes me to have to refresh the entire page to re-start the observable sequences.</p>

<p>Is there a way, without wrapping each of my subscriptions in a try/catch, to have an exception thrown in my next handler to simply unsubscribe that ONE subscription, and not terminate the underlying observable?</p>

<p>------------ EDIT ------------</p>

<p>I've found the behavior that I'm looking for, by setting syncErrorThrowable to true on the subscription object returned by ""subscribe"". It seems that the only time this is ever set to true in the codebase is via the ""do"" operator.</p>

<p>Should I take advantage of this field? I feel pretty dirty using it, but on the other hand I find it strange that the ""do"" operator has different error handling semantics than the ""next"" subscription handler.</p>

<p>Here's the primary block of code affected by this flag:
<a href=""https://github.com/ReactiveX/RxJS/blob/master/src%2FSubscriber.ts#L132"" rel=""nofollow"">https://github.com/ReactiveX/RxJS/blob/master/src%2FSubscriber.ts#L132</a></p>

<p>If it's set to false, this method gets invoked:
<a href=""https://github.com/ReactiveX/RxJS/blob/master/src%2FSubscriber.ts#L179"" rel=""nofollow"">https://github.com/ReactiveX/RxJS/blob/master/src%2FSubscriber.ts#L179</a></p>

<p>Whereas if it's set to true, this method is used instead:
<a href=""https://github.com/ReactiveX/RxJS/blob/master/src%2FSubscriber.ts#L188"" rel=""nofollow"">https://github.com/ReactiveX/RxJS/blob/master/src%2FSubscriber.ts#L188</a> </p>

<p>The difference is that the first method will re-throw the exception back up the callstack, whereas the second one instead propagates the error forward to subsequent subscriptions.</p>

<p>Why does the do operator propagate the error forward, whereas the ""next"" handler bubbles the error back up? This seems odd to me.</p>
","","user19302","","user19302","2016-03-03 00:31:16","2016-03-03 03:37:32","Proper way to deal with errors thrown in ""onNext"" for hot, shared, observables","<javascript><reactive-programming><rxjs><reactive-extensions-js><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"35755806","1","35874866","","2016-03-02 18:56:42","","4","13122","<p>I have a Google geocode service in TypeScript.  I need this method to return a ""GoogleMap"" class, after it fetches the lat/long for a given address.</p>

<p>I created a TypeScript method that returns a ""GoogleMap"" type.  But, I'm getting a </p>

<blockquote>
  <p>function that is neither void nor any must return a value...</p>
</blockquote>

<p>Here's my method:</p>

<pre><code>getLatLongFromAddress(streetAddress: string): GoogleMap {

    this.geoCodeURL = GOOGLE_GEOCODE_BASE_URL + streetAddress +
        ""&amp;key="" + GOOGLE_MAPS_API_KEY;

    this.googleMap = new GoogleMap();

    this.httpService
        .get(this.geoCodeURL)
        .subscribe((data) =&gt; {
            this.googleMap.lat = data.results.geometry.location.lat;
            this.googleMap.long = data.results.geometry.location.lng;

            return this.googleMap;
        },
        (error) =&gt; {
            console.error(this.geoCodeURL + "".  "" + error);

            return Observable.throw(""System encountered an error: "" + error);
        },
        () =&gt; {
            console.info(""ok: "" + this.geoCodeURL);

            return this.googleMap;
        });
}
</code></pre>

<p>I can understand the http call will be async and the flow ought to continue to the bottom of the method, possibly before the response returns data.  To return a ""GoogleMap"", do I need to await this Observable?  How do I go about doing this?  </p>

<p>Thanks!</p>

<p><strong>UPDATE: 4/21/16</strong>
I finally stumbled on an approach that I'm finding some satisfaction.  I know there's a number of posts from developers begging for a ""real"" service.  They want to pass a value to the service and get an object back.  Instead, many of the answers don't fully solve the problem.  The simplistic answer usually includes a subscribe() on the caller's side.  The down-side to this pattern, not usually mentioned, is that you're having to <em>map</em> the raw data retrieved in the service in the caller's callback.  It might be ok, if you only called this service from this one location in your code.  But, ordinarily, you'll be calling the service from different places in your code.  So, everytime, you'll map that object again and again in your caller's callback.  What if you add a field to the object?  Now, you have to hunt for all the callers in your code to update the mapping.  </p>

<p>So, here's my approach.  We can't get away from subscribe(), and we don't want to.  In that vein, our service will return an <code>Observable&lt;T&gt;</code> with an observer that has our precious cargo.  From the caller, we'll initialize a variable, <code>Observable&lt;T&gt;</code>, and it will get the service's <code>Observable&lt;T&gt;</code>.   Next, we'll subscribe to this object.  Finally, you get your ""T""! from your service.  </p>

<p>Take my example, now modified.  Take note of the changes.  First, our geocoding service:</p>

<pre><code>getLatLongFromAddress(streetAddress: string): Observable&lt;GoogleMap&gt; {
  ...
  return Observable.create(observer =&gt; {
      this.httpService
          .get(this.geoCodeURL)
          .subscribe((data) =&gt; {
              ...
              observer.next(this.googleMap);
              observer.complete();
          }
</code></pre>

<p>So, we're wrapping the googleMap object inside the ""observer"".  Let's look at the caller, now:</p>

<p>Add this property: </p>

<pre><code>private _gMapObservable: Observable&lt;GoogleMap&gt;;
</code></pre>

<p>Caller:</p>

<pre><code>getLatLongs(streetAddress: string) {
     this._gMapObservable = this.geoService.getLatLongFromAddress(this.streetAddr);

     this._gMapObservable.subscribe((data)=&gt;{
          this.googleMap = data;
     });
}
</code></pre>

<p>If you notice, there's no mapping in the caller!  you just get your object back.  All the complex mapping logic is done in the service in one place.  So code maintainability is enhanced.  Hope this helps.</p>
","3613907","","3613907","","2016-04-22 00:23:55","2016-04-22 00:23:55","How to Return From Observable in TypeScript Method with Return Type","<return-type><observable><typescript1.7><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"35757733","1","","","2016-03-02 20:48:12","","8","2633","<p>I'm trying to use RxJS for a simple short poll. It needs to make a request once every <code>delay</code> seconds to the location <code>path</code> on the server, ending once one of two conditions are reached: either the callback <code>isComplete(data)</code> returns true or it has tried the server more than <code>maxTries</code>. Here's the basic code:</p>

<pre><code>newShortPoll(path, maxTries, delay, isComplete) {
    return Observable.interval(delay)
    .take(maxTries)
    .flatMap((tryNumber) =&gt; http.get(path))
    .doWhile((data) =&gt; !isComplete(data));
  }
</code></pre>

<p>However, doWhile doesn't exist in RxJS 5.0, so the condition where it can only try the server <code>maxTries</code> works, thanks to the take() call, but the <code>isComplete</code> condition does not work. How can I make it so the observable will next() values until isComplete returns true, at which point it will next() that value and complete().</p>

<p><strong>I should note that <code>takeWhile()</code> does not work for me here. It does not return the last value, which is actually the most important, since that's when we know it's done.</strong></p>

<p>Thanks!</p>
","6009952","","","","","2018-12-20 21:15:09","RxJS 5.0 ""do while"" like mechanism","<javascript><rxjs><rxjs5>","3","2","1","","","CC BY-SA 3.0"
"35762723","2","","35740821","2016-03-03 03:37:32","","0","","<p>No, don't use that field. If you change it back to true, your Subscription will start swallowing errors.</p>

<p>That's a bit of private state we use to know whether the Subscription is being notified synchronously (in the same block as the source Observable's subscribe call), or asynchronously. If an error is thrown from one of the Subscriber's message handlers during synchronous notification, we defer re-throwing it until we've exited the Observable's subscribe callback.[1]</p>

<p>If your handlers throw errors that you want forwarded to your subscription's <code>onError</code> handler, the present guidance is to move them into a <code>do</code> block just above the subscription.</p>

<p>No, I don't agree with this behavior. Here's a few links for context:</p>

<ul>
<li><a href=""https://github.com/zenparsing/es-observable/issues/47"" rel=""nofollow"">https://github.com/zenparsing/es-observable/issues/47</a></li>
<li><a href=""https://github.com/ReactiveX/RxJS/issues/1135"" rel=""nofollow"">https://github.com/ReactiveX/RxJS/issues/1135</a></li>
</ul>

<p>[1] source: I wrote this bit of code.</p>
","3117331","","","","","2016-03-03 03:37:32","","","","0","","","","CC BY-SA 3.0"
"35772998","1","37823072","","2016-03-03 13:04:53","","2","936","<p>I would like to use the <code>onErrorResumeNext</code> feature of RxJS, i.e. to continue to receive events even if an error is received (instead of terminating).</p>

<p>But I can see in the following doc that there is no correspondance in RxJS5: <a href=""https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md"" rel=""nofollow"">https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md</a>.</p>

<p>Is there a workaround to use such feature?
Thanks!</p>
","1873365","","","","","2017-06-26 21:42:03","How to resumeOnError (or similar) in RxJS5","<rxjs5>","2","0","1","","","CC BY-SA 3.0"
"35794378","1","","","2016-03-04 11:01:21","","0","94","<p>According to the <a href=""https://github.com/ReactiveX/RxJS/blob/master/doc/operator-creation.md"" rel=""nofollow"">operator creation guide</a>, i tried to chain some operators i used to an another operator but without any success.</p>

<pre><code>function mySimpleOperator(actionName, iterable$, functionThatReturnAnObservable) {
   return Observable.create(subscriber =&gt; {
     var source = this;
     var subscription = source
       .interval(500)
       .skipUntil(iterable$.filter(({ action }) =&gt; action.type === actionName))
       .take(1)
       .flatMap(functionThatReturnAnObservable)
       .subscribe(value =&gt; {
         try {
           subscriber.next(value);
         } catch(err) {
           subscriber.error(err);
         }
     }, 
     err =&gt; subscriber.error(err),
     () =&gt; subscriber.complete());

     return subscription;
   });
}

Observable.prototype.mySimpleOperator = mySimpleOperator;
</code></pre>

<p>This function simply start an interval and will be skip until the actionName will be emitted.</p>

<p>But when i tried to use my operator</p>

<pre><code>Observable.mySimpleOperator('APP_READY', source$, () =&gt; Observable.of({ type: 'DONE' })
</code></pre>

<p>It throw an error </p>

<pre><code>Observable.mySimpleOperator is not a function
</code></pre>

<p>But if i do the intervall call outside my new operator it works ?!</p>

<pre><code>Observable.interval(500).mySimpleOperatorWithoutIntervall('APP_READY', source$, () =&gt; Observable.of({ type: 'DONE' })
</code></pre>

<p>Any solutions ? :)</p>
","5547464","","5547464","","2016-03-05 23:56:31","2016-03-06 09:02:56","How to chain RxJS5 operators into a new operator?","<javascript><reactive-programming><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"35801890","1","","","2016-03-04 17:05:07","","0","1844","<p>Its said that we can convert anything into stream using rxjs, here i want to convert the data coming from input field into stream and later subscribe to it, there is method in angular2 for this using valueChanges event</p>

<pre><code>this.input.valueChanges.subscribe( 
   (value: string) =&gt; { console.log('sku changed to: ', value); } 
); 
</code></pre>

<p>but when Im trying to create stream in component class like this </p>

<pre><code>Observables.create().subscribe()
</code></pre>

<p>the create is not recognized, also how can i do this in rxjs as value changes into input field, its related to angular2 forms, also what is useful function to create stream for this</p>
","5710014","","215945","","2016-03-04 18:38:36","2016-12-14 21:45:25","rxjs with angular2: into component class how to convert input field data changes to rxjs stream","<angular><reactive-programming><rxjs><angular2-forms><rxjs5>","2","5","","","","CC BY-SA 3.0"
"35847041","1","35848183","","2016-03-07 15:04:51","","2","180","<p>Is there an equivalent of a Promise.all?</p>

<pre><code>let prom1 = doA(); // some promise
let prom2 = doB(); // another promise

// wait for both promises to complete.
Promise.all([prom1, prom2], values =&gt; {
    // do something;
}); 
</code></pre>

<p>Can't piece it together from the docs, various articles suggest ForkJoin, but can't get it working... </p>

<pre><code>let behaviour1 = new BehaviourSubject(0);
let behaviour2 = new BehaviourSubject(1);
let allObserver = new ForkJoinObservable(behaviour1, behaviour2);

behaviour1.subscribe( () =&gt; console.log('i work'));
behaviour2.subscribe( () =&gt; console.log('i work'));
allObserver.subscribe( () =&gt; console.log('i dont work'));
</code></pre>

<p>Might just switch back to the sane world of promises.</p>
","891764","","34397","","2016-03-07 15:10:20","2017-11-03 15:41:31","RXJS5 vs Promise.all","<javascript><rxjs5>","3","0","","","","CC BY-SA 3.0"
"35848183","2","","35847041","2016-03-07 15:55:53","","3","","<p><code>Rx.Observable</code> has a <code>toArray</code> function that can be used to replicate <code>Promise.all</code> behavior: it stores all of the stream's emitted values and waits for the underlying stream's onComplete event to fire. The resulting stream will emit a single item once all of the underlying items have been emitted:</p>

<pre><code>// Instead of Promises, we can model our async actions as observables
const operation1$ = Rx.Observable.just(1);
const operation2$ = Rx.Observable.just(2);

// Merge all our async results into a single stream
const result$ = Rx.Observable.merge(operation1$, operation2$)

// Finally, call toArray to combine all results
result$
    .toArray()
    .subscribe(x =&gt; console.log(x));
// &gt;&gt; [1, 2]
</code></pre>
","2618971","","","","","2016-03-07 15:55:53","","","","1","","","","CC BY-SA 3.0"
"35848809","2","","35718059","2016-03-07 16:24:13","","1","","<p>You can flatMap each item in the array to an Observable stream that will emit a version of the item that replaced the <code>filter</code> property of type <code>Observable&lt;bool&gt;</code> with a <code>bool</code> property.</p>

<pre><code>const data$ = Rx.Observable.from(arr)

  // Convert each item's filter property to type bool
  .flatMap(x =&gt; x.filter.map(condition =&gt; Object.assign({}, x, { filter: condition })))

  // Now we can just filter over the filter property, which is of type bool.
  .filter(x =&gt; x.filter)

  // Each item emitted will have a filter value of true
  .subscribe(x =&gt; console.log(x));
</code></pre>
","2618971","","","","","2016-03-07 16:24:13","","","","0","","","","CC BY-SA 3.0"
"35850409","1","35851722","","2016-03-07 17:45:08","","12","23320","<p>I have service which connects with <code>Subject()</code> to do paging. I'm using <code>next(newData)</code> to pass to subject, which keeps things alive, now I need to use <code>complete()</code> on each ajax call and pass it to subject. but after doing one <code>complete()</code> I'm started get error. </p>

<p>I wanted to know, can we still pass <code>Subject</code> observables still <code>next(newData)</code> if once <code>completed()</code> is already been triggered?</p>
","75799","","3743222","","2016-11-18 05:12:23","2016-11-18 05:12:23","Rxjs Subject next() after complete()","<javascript><rxjs><observable><observer-pattern><rxjs5>","1","0","","","","CC BY-SA 3.0"
"35851722","2","","35850409","2016-03-07 18:57:30","","17","","<p>There is some information on subjects from a former question on stack overflow : <a href=""https://stackoverflow.com/questions/34849873/what-are-the-semantics-of-different-rxjs-subjects/34860777#34860777"">here</a>. I encourage you to review it.</p>

<p>About your specific question, subjects once completed cannot emit any longer. This is part of the contract they abide by. Depending on the logic and flow of your application, you might:</p>

<ul>
<li>decide not to complete the subject (why indeed are you completing it if you still need it later on?)</li>
<li>create a new subject whenever you need one, but then you have to pass it to whoever needs it.</li>
</ul>
","3743222","","-1","","2017-05-23 12:26:17","2016-03-07 18:57:30","","","","2","","","","CC BY-SA 3.0"
"35874866","2","","35755806","2016-03-08 18:13:05","","0","","<p>Your <code>getLatLongFromAddress</code>'s signature says it will return a GoogleMap, however, nothing is ever returned (ie the return value of your function, as it stands, will be undefined).</p>

<p>You can get rid of this compilation error by updating your method signature:</p>

<pre><code>// Return type is actually void, because nothing is returned by this function.
getLatLongFromAddress(streetAddress: string): void {

    this.geoCodeURL = GOOGLE_GEOCODE_BASE_URL + streetAddress +
        ""&amp;key="" + GOOGLE_MAPS_API_KEY;

    this.httpService
        .get(this.geoCodeURL)
        .subscribe((data) =&gt; {
            this.googleMap = new GoogleMap();
            this.googleMap.lat = data.results.geometry.location.lat;
            this.googleMap.long = data.results.geometry.location.lng;
        },
        (error) =&gt; {
            console.error(this.geoCodeURL + "".  "" + error);
            return Observable.throw(""System encountered an error: "" + error);
        },
        () =&gt; {
            console.info(""ok: "" + this.geoCodeURL);
            return this.googleMap;
        });
}
</code></pre>

<p>Additional tidbit, I don't think the onError and onComplete callback return values are used by Rx (looking at the documentation, the signature for these callbacks has a return value of <code>void</code>), although I could be mistaken.</p>
","2618971","","","","","2016-03-08 18:13:05","","","","3","","","","CC BY-SA 3.0"
"35879384","1","","","2016-03-08 22:34:25","","0","29","<p>I'm working with a Typescript Angular2 site that uses RxJS Observables. I am taking a piece of user data and hitting two different API endpoints. I'm <code>.forkJoin</code>ing them together like so</p>

<pre><code>var First: TypeA = this.api.FirstEndpoint(...);
var Second: TypeB = this.api.SecondEndpoint(...);
Observable.forkJoin(First, Second).subscribe((results: (TypeA|TypeB)[]) =&gt; {
    var first = &lt;TypeA&gt;results[0];
    var second = &lt;TypeB&gt;results[1];
    ...
});
</code></pre>

<p>While this technically works, I feel this is a bit clunky. Especially if I join more and more requests or a variable number of requests. Nothing says that <code>results[0]</code> is TypeA or that <code>1</code> is TypeB.</p>

<p>Is there a smoother way to type <code>results</code> or an alternative to <code>forkJoin</code> that will combine requests but keep their responses different (and thus typed more explicitly)?</p>
","160527","","","","","2016-03-17 17:19:35","Indicate an array contains certain types at certain indexes?","<rxjs5><typescript1.8>","1","0","","","","CC BY-SA 3.0"
"35888531","1","35888988","","2016-03-09 10:09:03","","8","27002","<p>For a JWT authentification, I make a post request to get the token using the new <code>Http</code> module working with Observables now.</p>

<p>I have a simple <code>Login</code> component showing the form:</p>

<pre><code>@Component({
selector: 'my-login',
    template: `&lt;form (submit)=""submitForm($event)""&gt;
                &lt;input [(ngModel)]=""cred.username"" type=""text"" required autofocus&gt;
                &lt;input [(ngModel)]=""cred.password"" type=""password"" required&gt;
                &lt;button type=""submit""&gt;Connexion&lt;/button&gt;
            &lt;/form&gt;`
})
export class LoginComponent {
    private cred: CredentialsModel = new CredentialsModel();

    constructor(public auth: Auth) {}

    submitForm(e: MouseEvent) {
        e.preventDefault();
        this.auth.authentificate(this.cred);
    }
}
</code></pre>

<p>I have a <code>Auth</code> service making the request:</p>

<pre><code>@Injectable()
export class Auth {
    constructor(public http: Http) {}

    public authentificate(credentials: CredentialsModel) {
        const headers = new Headers();
        headers.append('Content-Type', 'application/json');

        this.http.post(config.LOGIN_URL, JSON.stringify(credentials), {headers})
            .map(res =&gt; res.json())
            .subscribe(
                data =&gt; this._saveJwt(data.id_token),
                err =&gt; console.log(err)
            );
    }
}
</code></pre>

<p>Works well but now I want to display error messages inside my component so I need to subscribe in 2 places (<code>Auth</code> for managing success and <code>Login</code> for managing error).</p>

<p>I achieved it using <code>share</code> operator:</p>

<pre><code>public authentificate(credentials: CredentialsModel) : Observable&lt;Response&gt; {
    const headers = new Headers();
    headers.append('Content-Type', 'application/json');

    const auth$ = this.http.post(config.LOGIN_URL, JSON.stringify(credentials), {headers})
                            .map(res =&gt; res.json()).share();

    auth$.subscribe(data =&gt; this._saveJwt(data.id_token), () =&gt; {});

    return auth$;
}
</code></pre>

<p>And inside the component:</p>

<pre><code>submitForm(e: MouseEvent) {
    e.preventDefault();
    this.auth.authentificate(this.cred).subscribe(() =&gt; {}, (err) =&gt; {
        console.log('ERROR component', err);
    });
}
</code></pre>

<p>It works but I feel doing it wrong..
I just transpose the way we did it with angular1 and <code>promises</code>, do you see better way to achieve it?</p>
","4717011","","","","","2016-03-09 11:12:41","Angular2: How to subscribe to Http.post observable inside a service and a component properly?","<angular><observable><rxjs5><angular2-http>","2","1","1","","","CC BY-SA 3.0"
"35888988","2","","35888531","2016-03-09 10:29:45","","9","","<p>Why would you subscribe to in <code>sharedService</code>, when this approach can be used !</p>

<pre><code>@Injectable()
export class Auth {
    constructor(public http: Http) {}

    public authentificate(credentials: CredentialsModel) {
        const headers = new Headers();
        headers.append('Content-Type', 'application/json');

            return  this.http.post(config.LOGIN_URL, JSON.stringify(credentials), {headers})      //added return
            .map(res =&gt; res.json());
            //.subscribe(
            //    data =&gt; this._saveJwt(data.id_token),
            //    err =&gt; console.log(err)
            //);
    }
}
</code></pre>

<hr>

<pre><code>@Component({
selector: 'my-login',
    template: `&lt;form (submit)=""submitForm($event)""&gt;
                &lt;input [(ngModel)]=""cred.username"" type=""text"" required autofocus&gt;
                &lt;input [(ngModel)]=""cred.password"" type=""password"" required&gt;
                &lt;button type=""submit""&gt;Connexion&lt;/button&gt;
            &lt;/form&gt;`
})
export class LoginComponent {
    private cred: CredentialsModel = new CredentialsModel();

    constructor(public auth: Auth) {}

    submitForm(e: MouseEvent) {
        e.preventDefault();
        this.auth.authentificate(this.cred).subscribe(
               (data) =&gt; {this.auth._saveJwt(data.id_token)},  //changed
               (err)=&gt;console.log(err),
               ()=&gt;console.log(""Done"")
            );
    }
}
</code></pre>

<p><hr>
<strong><em>Edit</em></strong> <br>still if you want to subscribe in <code>sharedService</code> and <code>component</code> you can surely go with this approach. <strong><em>But I'd not recommend this</em></strong> rather before edited section seems perfect to me.</p>

<p>I can't test it with your code. but look at my <a href=""http://plnkr.co/edit/UMMFk57seNrxqdgyeQIT?p=preview"" rel=""noreferrer"">example here(tested)</a>. click on <code>myFriends tab</code>,check browser console and UI. browser console shows subscription result of <code>sharedService</code> &amp; UI shows subscription result of <code>component</code>.</p>

<hr>

<pre><code>  @Injectable()
  export class Auth {
    constructor(public http: Http) {}

    public authentificate(credentials: CredentialsModel) {
        const headers = new Headers();
        headers.append('Content-Type', 'application/json');

           var sub =  this.http.post(config.LOGIN_URL, JSON.stringify(credentials), {headers})      //added return
            .map(res =&gt; res.json());

           sub.subscribe(
                data =&gt; this._saveJwt(data.id_token),
                err =&gt; console.log(err)
               );

           return sub;
    }
}
</code></pre>

<hr>

<pre><code>export class LoginComponent {
    private cred: CredentialsModel = new CredentialsModel();

    constructor(public auth: Auth) {}

    submitForm(e: MouseEvent) {
        e.preventDefault();
        this.auth.authentificate(this.cred).subscribe(
               (data) =&gt; {this.auth._saveJwt(data.id_token)},  //not necessary to call _saveJwt from here now.
               (err)=&gt;console.log(err),
               ()=&gt;console.log(""Done"")
            );
    }
}
</code></pre>
","3751711","","3751711","","2016-03-09 11:12:41","2016-03-09 11:12:41","","","","5","","","","CC BY-SA 3.0"
"35889795","1","35890385","","2016-03-09 11:05:04","","0","102","<p>Why there is error when im passing argument in the parstInt and isNaN function saying argument of type void is not assignable to type string how can i solve this</p>

<pre><code>var u = rx.Observable.interval(400).take(6).map((i)=&gt;{
['2', 'sdf', '4', '8fj', '6'][i]
});
var x = u.map(function(e){ 
parseInt(e);             //error on e
}).filter(r =&gt; !isNaN(r)) //error on r
</code></pre>
","5710014","","","","","2016-03-09 11:38:51","Error in argument of parstInt and isNaN function","<javascript><arrays><typescript><rxjs><rxjs5>","1","4","","","","CC BY-SA 3.0"
"35890385","2","","35889795","2016-03-09 11:30:34","","0","","<blockquote>
  <p>The map() method creates a new array with the results of calling a provided function on every element in this array. â via <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"" rel=""nofollow"">MDN</a></p>
</blockquote>

<p>Therefore, the <code>.map()</code> callback requires a value to be returned, otherwise it maps the item to <code>undefined</code>. Use either <code>return parseInt(e, 10);</code> inside your <code>function</code> or use an arrow function, which will return by default. (and <a href=""https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/parseInt"" rel=""nofollow"">always use a radix with parseInt</a>)</p>

<pre><code>var u = rx.Observable.interval(400).take(6).map((i) =&gt; {
    return ['2', 'sdf', '4', '8fj', '6'][i]
});

var x = u.map(e =&gt; parseInt(e, 10)).filter(r =&gt; !isNaN(r));
</code></pre>

<p>If you don't need the intermediate step, you can reduce this even further and drop one loop by parsing inside the filter function.</p>

<pre><code>var x = u.filter(r =&gt; !isNaN(parseInt(r, 10)));
</code></pre>

<p><strong>EDIT</strong>
I just realized this is actually a TypeScript question. </p>

<p>The error occurs because the array you use to map your Observable to is one item short. Therefore the mapped array will contain: </p>

<p>['2', 'sdf', '4', '8fj', '6', undefined];</p>

<p>parseInt() expects the first param to be a string. In plain JS, it will try to convert to a string, it seems TypeScript may handle things a little different.</p>

<p>To fix that as well, you could update the callback of your first map like this:</p>

<pre><code>var u = rx.Observable.interval(400).take(6).map((i) =&gt; {
    return ['2', 'sdf', '4', '8fj', '6'][i] ||Â '';
});
</code></pre>
","1042461","","1042461","","2016-03-09 11:38:51","2016-03-09 11:38:51","","","","2","","","","CC BY-SA 3.0"
"35950458","1","36952063","","2016-03-11 21:41:43","","9","4285","<p>How do you load RxJS in an old javascript application which does not use any loaders?<br>
For RxJS 4.x I could simply do it like this:</p>

<pre><code>&lt;script src=""//cdnjs.cloudflare.com/ajax/libs/rxjs/4.0.7/rx.lite.min.js""&gt;&lt;/script&gt; 
</code></pre>

<p>What about RxJS 5? Their documentation assumes that you are using some kind of loader that will take care of everything, but for the intermediate step for legacy application when there is no loader, just files packed at build time?</p>

<p>They also mention ability to create your own bundle by including only the functions you use for ""size-sensitive bundling"" which sounds great.<br>
So should i just create an entry point file and then add it to my build process and use some kind of tool (browserify/gluejs/webmake) to build everything into a single file that as in RxJS4 would expose Rx (or simply Observable) as global variable?, eg:</p>

<pre><code>// run this through some tool to make it available in browser simply as Observable
var Observable = require('rxjs/Observable').Observable;
require('rxjs/add/operator/map');
exports=Observable
</code></pre>
","911849","","","","","2016-04-30 07:24:21","ReactiveX/RxJS 5 in the browser without any loaders?","<javascript><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"35956187","1","35958925","","2016-03-12 09:59:41","","6","14735","<p>I've got an Observable that listens to some user input from a text box. If the observed string's length is >=3 (<code>filter</code>), it executes some HTTP call (<code>switchMap</code>). </p>

<p>Now I'd like to detect somehow if the user input has been filtered. Reason:</p>

<ul>
<li><p>If the HTTP call has been done, it should show the results.</p></li>
<li><p>If the user input got filtered (== is invalid), it should clear the results.</p></li>
</ul>

<p>Here's the code I'd like to have (see: <code>ifFiltered</code>):</p>

<pre><code>this.userInput.valueChanges
    .filter(val =&gt; val &amp;&amp; val.length &gt;= 3)
    .ifFiltered(() =&gt; this.results = [])
    .switchMap(val =&gt; getDataViaHTTP())
    .subscribe(val =&gt; this.results = val);
</code></pre>

<p>I know, I could place that logic within the <code>filter</code> function for this simple example. But what if I have 10 different filters?</p>

<p>Did I miss any method that satisfies my needs?</p>

<p>Thanks in advance!</p>
","1321564","","","","","2020-06-11 02:29:43","RxJs Observable: Execute function if empty/filtered","<filter><angular><rxjs><observable><rxjs5>","5","0","2","","","CC BY-SA 3.0"
"35958925","2","","35956187","2016-03-12 14:33:14","","4","","<p>Either use partition like here <a href=""https://stackoverflow.com/questions/32594357/rxjs-modeling-if-else-control-structures-with-observables-operators"">RxJS modeling if else control structures with Observables operators</a></p>

<p>Or instead of filter use map and pipe the object if the former filter condition is true or null otherwise. so you can catch the null where ever you want in your chain with a filter.</p>

<p>Last option call some function in the else part of the filter function</p>
","406714","","-1","","2017-05-23 12:02:16","2016-03-12 14:33:14","","","","2","","","","CC BY-SA 3.0"
"35980322","1","41582686","","2016-03-14 05:46:32","","35","14950","<p>The following code it's causing me a <code>Observable.combineLatest is not a function</code> using RxJS 5.0:</p>

<pre><code>let Observable = require('rxjs/Observable.js').Observable;
import 'rxjs/add/operator/combineLatest';

Observable
.combineLatest([player, spaceShip], (shotEvents, spaceShip) =&gt; ({
    x: spaceShip ? spaceShip.x : board.canvas.width / 2,
    timestamp: shotEvents.timestamp
}))
</code></pre>

<p>All other Observables are able to be resolved, the only function not being resolved is my <code>combineLatest</code>. I tried <code>observables/combineLatest</code> just for the sake of trying to no avail.</p>

<p>I'm compiling everything using <code>webpack</code> and <code>babel</code>, and the code is able to resolve <code>scan</code>, <code>range</code>, <code>interval</code>, <code>map</code>, and some others. Even <code>flatMap</code> using <code>import 'rxjs/add/operator/mergeMap';</code> worked. </p>

<p>But not <code>combineLatest</code></p>

<p>So if anyone has a working example it would be deeply appreciated. Couldn't find anything else in the docs besides <a href=""https://github.com/ReactiveX/RxJS/blob/master/spec/operators/combineLatest-spec.ts"" rel=""noreferrer"">a unit test that is basically the same thing (an array of observables and a function).</a></p>

<h1>UPDATE APR 04 2018</h1>

<p>On RxJs 5.5 use the following:</p>

<pre><code>import { combineLatest } from 'rxjs/observable/combineLatest'
</code></pre>

<p>Moving forward (RxJs 6) use the following:</p>

<pre><code>import { combineLatest } from 'rxjs'
</code></pre>
","1963929","","7943893","","2020-01-02 14:56:40","2020-01-02 14:56:40","Can't find `combineLatest` in RxJS 5.0","<rxjs><rxjs5>","5","4","1","","","CC BY-SA 3.0"
"35980457","1","39464562","","2016-03-14 05:59:04","","0","710","<p>In RxJS 4.0 I could do something as follows:</p>

<pre><code>let clicks = Observable.fromEvent(board.canvas, 'click'),
    keydowns = Observable.fromEvent(document, 'keydown')
      .filter((e) =&gt; e.keyCode === 32);
  return Observable
    .merge(clicks, keydowns)
    .sample(200).
    .timestamp();
</code></pre>

<p><a href=""https://github.com/ReactiveX/RxJS/blob/master/MIGRATION.md"" rel=""nofollow"">Now that RxJS 5.0 dropped support for <code>timestamp</code></a>, how would this piece of code be done in the migration?</p>
","1963929","","","","","2016-09-13 07:36:40","Timestamp in RxJS 5.0","<rxjs5>","2","0","","","","CC BY-SA 3.0"
"35995812","1","","","2016-03-14 18:57:18","","1","159","<p>So here is the scenario I am attempting to figure out how to implement using rxjs:</p>

<ol>
<li><p>Load some set of metadata from a file/database/etc. Each element in the metadata has an id and additional information - like the location of the actual data. Currently, I am loading all of this metadata at the start of the application, asynchronously. After this data is loaded the Observable calls complete. Eventually I may add a refresh capability</p></li>
<li><p>At some later point in the application, I will need to load specific sets of data based upon what is available in the metadata. I am currently attempting to do this with a function like <strong>fetchData(ids:string[]):Observable</strong>. This is where I am unclear about how to proceed under the rxjs paradigm. I am equally unsure of what to do with requesting a single item using a function like <strong>fetchDatum(id:string):Observable</strong></p></li>
</ol>

<p>I can of course use filter to operate only on those IMetdata items emitted from the IMetadata Observable that match one of the names in the list - but I also need to confirm that ALL requested items are found in the IMetadata Observable emissions, and if not I need to error. </p>

<p>So if someone requests the IMetadata with id = ""Bob"" - but there is no such IMetadata emitted from the source Observable, then it needs to error. Or if they request { ""Shirley"", ""Rex"", ""Samantha"" } and there is no data for ""Rex"" then it should error.</p>

<p>I've considered using a Rx.Subject here, but from what I've read that is generally undesirable under the rxjs paradigm. Please advise on what approaches would work for this scenario under the rxjs paradigm. Thanks!</p>
","6062467","","6062467","","2016-03-15 18:32:44","2016-03-15 23:01:06","Approach to filtering and validating return values with rxjs","<rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"36005237","1","","","2016-03-15 07:45:38","","0","165","<p>Trying to construct a schedule using RxJS v5, where certain events can trigger the schedule to reload.  Currently using 3 sources - schedule$, event$, and userNotification$ (example below).</p>

<p>I've tried a number of different strategies and I'm consistently getting weirdness like recursive reloads when the reloadSchedule event time hits.  Is there a way for downstream data (event$) to cleanly trigger upstream (schedule$) reloads, without any actions/notifications lingering from previous schedule items?</p>

<pre><code>schedule$ = new Rx.BehaviorSubject(
  {schedule:[
    {start:'1pm', end:'2pm', action:'sayhi'},
    {start:'2pm', end:'3pm', action:'sayhi'},
    {start:'3pm', end:'3pm', action:'reloadSchedule'},
    {start:'3:01pm', end:'4pm', action:'sayhi'},
  ]}
);

function loadSchedule(){
  somethingAsync.then((moreData)=&gt;schedule$.next(moreData));
}

event$ = schedule$.flatMap((data)=&gt;{
  return Rx.Observable
    .from(data.schedule)
    .flatMap((event)=&gt;{
      return Rx.Observable.timer(event.start)
      .flatMap(()=&gt;{
        // do actions here once previous actions/notifications finish
        if(event.action === 'reloadSchedule'){
          loadSchedule()
        }
        return Rx.Observable.of(someUserMessage);
      })
    })
})

userNotification$ = Rx.Observable.timer(1000).withLatestFrom(event$)
.flatMap((someUserMessage)={
  // fade message after 5 seconds
});

userNotification.subscribe(()=&gt;{});
</code></pre>
","656259","","656259","","2016-03-26 15:44:46","2016-03-26 16:46:32","How to cleanly architect downstream subscribers that call an upstream reload in RxJS?","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"36013766","1","36014883","","2016-03-15 14:13:10","","0","221","<p>I have a function that takes a ID as parameter and makes HTTP calls, depending on the ID. It returns a Observable. I expected the calls with different parameters to be completely independent, but they influence each other.</p>

<p>I use<br>
RxJS 5.0.0-beta.2<br>
Angular 2.0.0-beta.7 for the http calls<br>
Typescript 1.8.2</p>

<p><strong>Code:</strong>  </p>

<pre><code>getCharacterDetails (id : number) : Observable&lt;CharacterDetails&gt; {
    let keys : SpreadsheetKeys = this.characters[id];
    if (!keys) {
        return null;
    }

    let frontUrl : string = `${BASE_URL}/${CELLS}/${keys.spreadsheetKey}/${keys.frontWorksheetKey}/${OPTIONS}`;
    let backUrl : string = `${BASE_URL}/${CELLS}/${keys.spreadsheetKey}/${keys.backWorksheetKey}/${OPTIONS}`;

    return Observable.forkJoin(

        this.http.get(frontUrl).map(response =&gt; response.json()),
        this.http.get(backUrl).map(response =&gt; response.json()))

        .map((response : any[]) =&gt; {

            let character : CharacterDetails = EMPTY_MODEL;

            console.log(JSON.stringify(character)); // The 1st console.log

            applyFrontSheetToCharacter(response[0], character);
            applyBackSheetToCharacter(response[1], character);

            console.log(JSON.stringify(character)); // The 2nd console.log

            return character;
        });
}
</code></pre>

<p><strong>Expected behavior:</strong>  </p>

<p>I call<br>
<code>getCharacterDetails(1).subscribe((details) =&gt; { this.details = details }));</code><br>
The 1st console.log prints my EMPTY_MODEL.<br>
The 2nd console.log prints the character model for ID 1.  </p>

<p>then I call<br>
<code>getCharacterDetails(2).subscribe((details) =&gt; { this.details = details });</code><br>
The 1st console.log prints my EMPTY_MODEL.<br>
The 2nd console.log prints the character model for ID 2.  </p>

<p><strong>Actual behavior:</strong>  </p>

<p>I call<br>
<code>getCharacterDetails(1).subscribe((details) =&gt; { this.details = details }));</code><br>
The 1st console.log prints my EMPTY_MODEL.<br>
The 2nd console.log prints the character model for ID 1. </p>

<p>then I call 
<code>getCharacterDetails(2).subscribe((details) =&gt; { this.details = details });</code><br>
<strong>The 1st console.log prints the character model for ID 1.</strong> &lt;- Problem<br>
The 2nd console.log prints the character model for ID 2.  </p>

<p><strong>Why are the 2 calls not completely independent? How does the 2nd call even know about the data from the first call?</strong></p>
","4203012","","","","","2016-03-15 15:00:39","Can't create 2 independent Observables with forkJoin","<angular><rxjs5><angular2-http>","1","5","","","","CC BY-SA 3.0"
"36014883","2","","36013766","2016-03-15 15:00:39","","1","","<p>The problem was simply that I completely misused the EMPTY_MODEL. It was basically a class-wide variable that I was editing in the .map() function.
A silly mistake that was unrelated to RxJS, Angular or HTTP</p>
","4203012","","","","","2016-03-15 15:00:39","","","","0","","","","CC BY-SA 3.0"
"36019085","1","36019407","","2016-03-15 18:17:02","","5","2357","<p>I would like to take an Observable&lt;T[]&gt; and convert it to an Observable&lt;T&gt; such that each array from the Observable&lt;T[]&gt; is broken up and the individual elements of the arrays are then emitted, separately, via the Observable&lt;T&gt;.</p>

<p>Is there a standard operator for doing this? I've searched around but haven't found anything. Thanks.</p>

<hr>

<p>After being pointed in the direction of concatMap/flatMap, I came up with the following general solution:</p>

<pre><code>var source: Observable&lt;T[]&gt;;
...
var splitSource = source.flatMap&lt;T&gt;((x:T[]) =&gt; { return Rx.Observable.fromArray(x); });
</code></pre>
","6062467","","3743222","","2016-11-17 15:09:20","2017-02-28 22:48:42","RXJS How to convert Observable<T[]> to Observable<T>","<javascript><rxjs><rxjs5>","2","3","1","","","CC BY-SA 3.0"
"36019407","2","","36019085","2016-03-15 18:35:49","","6","","<p>You could use <code>concatMap</code> like this:</p>

<pre><code>function identity (x) {return x}

var obs_of_array$ = Rx.Observable.return(['1','2','you got it'])
    .concatMap(identity)
</code></pre>

<p>This works because <code>concatMap</code> also accepts arrays (and observables and promises) as the return value of the function selector that you pass as a parameter. Jsbin <a href=""http://jsfiddle.net/09egztku/3/"" rel=""noreferrer"">here</a>, documentation <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/selectmany.md"" rel=""noreferrer"">here</a></p>

<p>So the array passed as parameter becomes the return value from the selector function, and then is flattened by the <code>concatMap</code> operator while respecting the ordering of the array.</p>
","3743222","","3743222","","2016-03-15 19:48:39","2016-03-15 19:48:39","","","","2","","","","CC BY-SA 3.0"
"36026111","1","36064657","","2016-03-16 03:06:35","","0","446","<p>Can not find Rx.Observable.pairs in Rxjs5,
what I need just convert an object into Observable and inspect the change for each property.
any ideas?</p>

<pre><code> var a = { aa: ""aa"", bb: ""bb"" };
   function pairs(obj) {
    // List of object's key-value pairs
    var keyValuePairs = Object.keys(obj).map(key =&gt; ({ key, value: obj[key] }));
    // Convert to an Observable and return
    return Rx.Observable.from(keyValuePairs);
    }

  var xxx = pairs(a);
xxx.subscribe(x =&gt; {
    console.log(x);
})

a.aa = ""mm"";
</code></pre>
","5492052","","5492052","","2016-03-23 09:17:09","2016-03-23 09:17:09","Is there a way to user pairs for Rxjs5?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"36044309","1","36044971","","2016-03-16 18:40:09","","1","321","<p>I have a scenario where I want to fetch some piece of data from a server, and where the user can request a refresh of this data. The rest of the page needs to update to reflect the currently loaded iteration of the data.</p>

<p>I am picturing this where I have a hot Observable that publishes the data that it loads. I don't want to retain all the old iterations of the data as 1. I only care about the latest iteration of the data and 2. it could lead to an out-of-memory exception if the user refreshes enough in a given session.</p>

<p>However, I DO want to retain the last published value so that if I dynamically bring up a new component that needs access to that same data, it isn't sending out a new request unnecessarily. For this I need an Observable to sit ontop of the hot observable which will only retain and emit the last emission from the hot observable. Here's a diagram illustrating this idea:</p>

<pre><code>dataStream     X - - - - - Y - - - - |&gt; 
echoStream     X - - - - - Y - - - - |&gt; 
subscription1  X - - - - - Y - - - - |&gt; 
subscription2          X - Y - - - - |&gt; 
subscription3                  Y - - |&gt;
</code></pre>

<p>echoStream is subscribed to the dataStream. The subscription1, subscription2, and subscription3 are all subscribed to echoStream, but they subscribe at different points. At the time of subscription they get the last value that was emitted from the dataStream, and receive subsequent updates from dataStream.</p>

<p>echoStream is a bit of a mix of a Hot and Cold Observable, having a limited history retention.</p>

<p>Does rxjs provide a standard operator for setting up something like echoStream in the above example?</p>
","6062467","","3743222","","2016-11-14 05:40:46","2016-11-14 05:40:46","Hot & Cold Observables - Last Refresh Value","<javascript><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36044971","2","","36044309","2016-03-16 19:14:25","","2","","<p>For what I understood, you could use the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/sharereplay.md"" rel=""nofollow noreferrer""><code>shareReplay</code></a> operator in this form :</p>
<p><code>echoStream = dataStream.shareReplay(1)</code></p>
<p>As the documentation says:</p>
<blockquote>
<p>Returns an observable sequence that shares a single subscription to the underlying sequence and replays notifications [...]</p>
<p>This operator is a specialization of replay that connects to the connectable observable sequence when the number of observers goes from zero to one, and disconnects when there are no more observers.</p>
</blockquote>
<p>So there are two things done here by this operator. When a subscriber subscribes to the stream, it receives immediately the latest value emitted by the stream (or the n latest values or the values emitted in the Xms time window before now - depending on the arguments you passed when calling the operator). That's the replay functionality. Then there is the automatic unsubscription functionality which kicks in when there is no longer any subscriber to the stream.</p>
<p>If you don't care about automatic unsubscription, you could use the <code>replay</code> operator instead, you will get only the replay functionality. For example:</p>
<p><code>echoStream = dataStream.replay(1)</code></p>
","3743222","","-1","","2020-06-20 09:12:55","2016-03-16 19:20:32","","","","1","","","","CC BY-SA 3.0"
"36064657","2","","36026111","2016-03-17 15:14:25","","0","","<p>You can accomplish this from scratch:</p>

<pre><code>function pairs(obj) {
    // List of object's key-value pairs
    var keyValuePairs = Object.keys(obj).map(key =&gt; ({ key, value: obj[key]}));

    // Convert to an Observable and return
    return Rx.Observable.from(keyValuePairs);
}
</code></pre>
","2618971","","","","","2016-03-17 15:14:25","","","","4","","","","CC BY-SA 3.0"
"36114069","1","","","2016-03-20 13:06:52","","0","446","<p>I want to run <a href=""https://github.com/AngularClass/angular2-examples/blob/master/rx-draggable/directives/draggable.ts"" rel=""nofollow"">this example</a> with <code>rxjs5</code>. But it doesn't work. I've stucked on <a href=""https://github.com/AngularClass/angular2-examples/blob/master/rx-draggable/directives/draggable.ts#L41"" rel=""nofollow"">#41 line</a>. It says that map returns <code>Subject</code> and it doesn't have <code>.takeUntil</code> method. What is the best way to implement it? Thanks</p>
","6089525","","4318868","","2016-03-20 14:00:26","2016-03-20 14:00:26","Convert Subject to Observable","<angular><rxjs><rxjs5>","2","2","","2016-03-20 17:28:15","","CC BY-SA 3.0"
"36141280","1","36142372","","2016-03-21 20:47:41","","15","2771","<p>I have been experimenting with RxJS for two weeks now, and although I love it in principle I just cannot seem to find and implement the correct pattern for managing state. All articles and questions appear to agree:</p>

<ul>
<li><code>Subject</code> should be avoided where possible in favor of just pushing state through via transformations;</li>
<li><code>.getValue()</code> should be deprecated entirely; and</li>
<li><code>.do</code> should perhaps be avoided except for DOM manipulation?</li>
</ul>

<p>The problem with all such suggestions is that none of the literature appears to directly say what you should be using instead, besides ""you'll learn the Rx way and stop using Subject"".</p>

<p>But I cannot find a direct example anywhere that specifically indicates the correct way to perform both additions and removals to a single stream/object, as the consequence of multiple other stream inputs, in a stateless and functional manner.</p>

<p>Before I get pointed in the same directions again, problems with uncovered literature are:</p>

<ul>
<li>The Introduction to Reactive Programming You've been missing: great starting text, but does not specifically address these questions.</li>
<li>The TODO example for RxJS comes with React and involves explicit manipulation of <code>Subject</code>s as proxies for React Stores.</li>
<li><a href=""http://blog.edanschwartz.com/2015/09/18/dead-simple-rxjs-todo-list/"">http://blog.edanschwartz.com/2015/09/18/dead-simple-rxjs-todo-list/</a> : explicitly uses a <code>state</code> object for addition and removal of items.</li>
</ul>

<p>My perhaps 10th rewrite of the standard TODO follows - My prior iterations covered include:</p>

<ul>
<li>starting with a mutable 'items' array - bad as state is explicit and imperatively managed</li>
<li>using <code>scan</code> to concatenate new items to an <code>addedItems$</code> stream, then branching another stream where the removed items were deleted - bad as the <code>addedItems$</code> stream would grow indefinitely.</li>
<li>discovering <code>BehaviorSubject</code>and using that - seemed bad since for each new <code>updatedList$.next()</code> emission, it requires the previous value to iterate, meaning that <code>Subject.getValue()</code> is essential.</li>
<li>trying to stream the result of the <code>inputEnter$</code> addition events into filtered removal events - but then every new stream creates a new list, and then feeding that into the <code>toggleItem$</code> and <code>toggleAll$</code> streams means that each new stream is dependent on the previous, and so causing one of the 4 actions (add, remove, toggle item or toggle all) requires the whole chain to be unnecessarily run through again.</li>
</ul>

<p>Now I have come full circle, where I am back to using both <code>Subject</code> (and just how is it supposed to be successively iterated upon in any way without using <code>getValue()</code>?) and <code>do</code>, as show below. Myself and my colleague agree this is the clearest way, yet it of course seems the least reactive and most imperative. Any clear suggestions on the correct way for this would be much appreciated!</p>

<pre><code>import Rx from 'rxjs/Rx';
import h from 'virtual-dom/h';
import diff from 'virtual-dom/diff';
import patch from 'virtual-dom/patch';

const todoListContainer = document.querySelector('#todo-items-container');
const newTodoInput = document.querySelector('#new-todo');
const todoMain = document.querySelector('#main');
const todoFooter = document.querySelector('#footer');
const inputToggleAll = document.querySelector('#toggle-all');
const ENTER_KEY = 13;

// INTENTS
const inputEnter$ = Rx.Observable.fromEvent(newTodoInput, 'keyup')
    .filter(event =&gt; event.keyCode === ENTER_KEY)
    .map(event =&gt; event.target.value)
    .filter(value =&gt; value.trim().length)
    .map(value =&gt; {
        return { label: value, completed: false };
    });

const inputItemClick$ = Rx.Observable.fromEvent(todoListContainer, 'click');

const inputToggleAll$ = Rx.Observable.fromEvent(inputToggleAll, 'click')
    .map(event =&gt; event.target.checked);

const inputToggleItem$ = inputItemClick$
    .filter(event =&gt; event.target.classList.contains('toggle'))
    .map((event) =&gt; {
        return {
            label: event.target.nextElementSibling.innerText.trim(),
            completed: event.target.checked,
        };
    })

const inputDoubleClick$ = Rx.Observable.fromEvent(todoListContainer, 'dblclick')
    .filter(event =&gt; event.target.tagName === 'LABEL')
    .do((event) =&gt; {
        event.target.parentElement.classList.toggle('editing');
    })
    .map(event =&gt; event.target.innerText.trim());

const inputClickDelete$ = inputItemClick$
    .filter(event =&gt; event.target.classList.contains('destroy'))
    .map((event) =&gt; {
        return { label: event.target.previousElementSibling.innerText.trim(), completed: false };
    });

const list$ = new Rx.BehaviorSubject([]);

// MODEL / OPERATIONS
const addItem$ = inputEnter$
    .do((item) =&gt; {
        inputToggleAll.checked = false;
        list$.next(list$.getValue().concat(item));
    });

const removeItem$ = inputClickDelete$
    .do((removeItem) =&gt; {
        list$.next(list$.getValue().filter(item =&gt; item.label !== removeItem.label));
    });

const toggleAll$ = inputToggleAll$
    .do((allComplete) =&gt; {
        list$.next(toggleAllComplete(list$.getValue(), allComplete));
    });

function toggleAllComplete(arr, allComplete) {
    inputToggleAll.checked = allComplete;
    return arr.map((item) =&gt;
        ({ label: item.label, completed: allComplete }));
}

const toggleItem$ = inputToggleItem$
    .do((toggleItem) =&gt; {
        let allComplete = toggleItem.completed;
        let noneComplete = !toggleItem.completed;
        const list = list$.getValue().map(item =&gt; {
            if (item.label === toggleItem.label) {
                item.completed = toggleItem.completed;
            }
            if (allComplete &amp;&amp; !item.completed) {
                allComplete = false;
            }
            if (noneComplete &amp;&amp; item.completed) {
                noneComplete = false;
            }
            return item;
        });
        if (allComplete) {
            list$.next(toggleAllComplete(list, true));
            return;
        }
        if (noneComplete) {
            list$.next(toggleAllComplete(list, false));
            return;
        }
        list$.next(list);
    });

// subscribe to all the events that cause the proxy list$ subject array to be updated
Rx.Observable.merge(addItem$, removeItem$, toggleAll$, toggleItem$).subscribe();

list$.subscribe((list) =&gt; {
    // DOM side-effects based on list size
    todoFooter.style.visibility = todoMain.style.visibility =
        (list.length) ? 'visible' : 'hidden';
    newTodoInput.value = '';
});

// RENDERING
const tree$ = list$
    .map(newList =&gt; renderList(newList));

const patches$ = tree$
    .bufferCount(2, 1)
    .map(([oldTree, newTree]) =&gt; diff(oldTree, newTree));

const todoList$ = patches$.startWith(document.querySelector('#todo-list'))
    .scan((rootNode, patches) =&gt; patch(rootNode, patches));

todoList$.subscribe();


function renderList(arr, allComplete) {
    return h('ul#todo-list', arr.map(val =&gt;
        h('li', {
            className: (val.completed) ? 'completed' : null,
        }, [h('input', {
                className: 'toggle',
                type: 'checkbox',
                checked: val.completed,
            }), h('label', val.label),
            h('button', { className: 'destroy' }),
        ])));
}
</code></pre>

<h1>Edit</h1>

<p>In relation to @user3743222 very helpful answer, I can see how representing state as an additional input can make a function pure and thus <code>scan</code> is the best way to represent a collection evolving over time, with a snapshot of its previous state up to that point as an additional function parameter.</p>

<p>However, this was already how I approached my second attempt, with <code>addedItems$</code> being a scanned stream of inputs:</p>

<pre><code>// this list will now grow infinitely, because nothing is ever removed from it at the same time as concatenation?
const listWithItemsAdded$ = inputEnter$
    .startWith([])
    .scan((list, addItem) =&gt; list.concat(addItem));

const listWithItemsAddedAndRemoved$ = inputClickDelete$.withLatestFrom(listWithItemsAdded$)
    .scan((list, removeItem) =&gt; list.filter(item =&gt; item !== removeItem));

// Now I have to always work from the previous list, to get the incorporated amendments...
const listWithItemsAddedAndRemovedAndToggled$ = inputToggleItem$.withLatestFrom(listWithItemsAddedAndRemoved$)
    .map((item, list) =&gt; {
        if (item.checked === true) {
        //etc
        }
    })
    // ... and have the event triggering a bunch of previous inputs it may have nothing to do with.


// and so if I have 400 inputs it appears at this stage to still run all the previous functions every time -any- input
// changes, even if I just want to change one small part of state
const n$ = nminus1$.scan...
</code></pre>

<p>The obvious solution would be to just have <code>items = []</code>, and manipulate it directly, or <code>const items = new BehaviorSubject([])</code> - but then the only way to iterate on it appears to be using <code>getValue</code> to expose the previous state, which Andre Stalz (CycleJS) has commented on in the RxJS issues as something that shouldn't really be exposed (but again, if not, then how is it usable?).</p>

<p>I guess I just had an idea that with streams, you weren't supposed to use Subjects or represent anything via a state 'meatball', and in the first answer I'm not sure how this doesn't introduce mass chained streams which are orphaned/grow infinitely/have to build on each other in exact sequence.</p>
","3965819","","3965819","","2016-03-21 23:16:05","2017-07-19 15:59:57","How to manage state without using Subject or imperative manipulation in a simple RxJS example?","<javascript><stream><rxjs><frp><rxjs5>","1","0","7","","","CC BY-SA 3.0"
"36142372","2","","36141280","2016-03-21 21:55:21","","13","","<p>I think you already found a good example with : <a href=""http://jsbin.com/redeko/edit?js,output"" rel=""nofollow noreferrer"">http://jsbin.com/redeko/edit?js,output</a>.</p>

<p>You take issue with the fact that this implementation</p>

<blockquote>
  <p>explicitly uses a state object for addition and removal of items.</p>
</blockquote>

<p>However, thas is exactly the good practice you are looking for. If you rename that state object <code>viewModel</code> for example, it might be more apparent to you.</p>

<h1>So what is state?</h1>

<p>There will be other definitions but I like to think of state as follows:</p>

<ul>
<li>given <code>f</code> an impure function, i.e. <code>output = f(input)</code>, such that you can have different outputs for the same input, the state associated to that function (when it exists) is the extra variable such that <code>f(input) = output = g(input, state)</code> holds and g is a pure function.</li>
</ul>

<p>So if the function here is to match an object representing a user input, to an array of todo, and if I click <code>add</code> on a todo list with already have 2 todos, the output will be 3 todos. If I do the same (same input) on a todo list with only one todo, the output will be 2 todos. So same input, different outputs. </p>

<p>The state here that allows to transform that function into a pure function is the current value of the todo array. So my input becomes an <code>add</code> click, <strong>AND</strong> the current todo array, passed through a function <code>g</code> which give a new todo array with a new todo list. That function g is pure. So <code>f</code> is implemented in a stateless way by making its previously hidden state explicit in <code>g</code>.</p>

<p>And that fits well with functional programming which revolves around composing pure functions.</p>

<h1>Rxjs operators</h1>

<ul>
<li>scan</li>
</ul>

<p>So when it comes to state management, with RxJS or else, a good practice is to make state explicit to manipulate it.</p>

<p>If you turn the <code>output = g(input, state)</code> into a stream, you get <code>On+1 = g(In+1, Sn)</code> and that's exactly what the <code>scan</code> operator does. </p>

<ul>
<li>expand</li>
</ul>

<p>Another operator which generalizes <code>scan</code> is <code>expand</code>, but so far I had very little use of that operator. <code>scan</code> generally does the trick.</p>

<p>Sorry for the long and mathy answer. It took me a while to get around those concepts and that's the way I made them understandable for me. Hopefully it works for you too.</p>
","3743222","","1446845","","2017-07-19 15:59:57","2017-07-19 15:59:57","","","","8","","","","CC BY-SA 3.0"
"36142865","1","36164446","","2016-03-21 22:30:30","","1","520","<p>I am looking for some best-practice suggestions on how to identify which stream is coming in to a <code>merge</code> or <code>combineLatest</code> function in such a way that only the new stream is operated on.</p>

<p>In the context of a TODO app, I have incoming add and remove streams, and I want to combine them so that my list editing can occur within a single stream in a stateless manner. The output is a list that has integrated both add(concat) and remove(filter) events, otherwise you seem to end up with other streams that include all the add or remove events and thus grow infinitely.</p>

<p>Problems encountered include:</p>

<ul>
<li>using <code>merge</code> does not indicate which stream is incoming;</li>
<li>using <code>combineLatest</code> does not indicate which stream has triggered the subscribed stream, so you can't only perform the operations relevant to that stream.</li>
<li>using <code>withLatestFrom</code> results in a new list that does not update the <code>withLatestFrom</code> input source, so unless the next stream also interested in this list subscribes to that list, the list will get out of sync (or you have every new list based on the one before it, which causes needless re-stepping through every transformation for those that happened prior to it...).</li>
</ul>

<p>Currently found approaches that somehow seem sub-optimal include:</p>

<ul>
<li>The Cycle JS TODO app explicitly assigns <code>type</code> properties directly to the created objects of the earlier streams for identification, which I would have thought should be avoided in favor of using RxJS methods that directly identify where the streams come from?</li>
<li>taking the suggestion from <a href=""http://www.jisaacks.com/manipulating-rxjs-streams/"" rel=""nofollow"">http://www.jisaacks.com/manipulating-rxjs-streams/</a> and splitting the output of addition streams and removal streams to <code>[null, {addItem}]</code> and <code>[removeItem, {null}]</code>, such that when using <code>merge</code> for both add and remove events, I could still identify the incoming stream which was being updated, so that I could perform both addition and removal in a single stream (but then I want to add toggle events, etc, but this doesn't seem right either since I'm needing to create stream outputs that are aware of all the other potential streams (ending up with [null, null, myOutput, null, null etc].</li>
</ul>

<p>Any best practice suggestions are very welcome.</p>
","3965819","","3743222","","2016-11-18 05:03:10","2016-11-18 05:03:10","RxJS: correct patterns for identifying stream source in combined stream?","<javascript><stream><rxjs><rxjs5><frp>","2","0","","","","CC BY-SA 3.0"
"36164446","2","","36142865","2016-03-22 20:23:06","","0","","<p>There is no Rxjs method which allows to identify where a stream comes from. Streams do not carry a name on them. If you want one, you need to put it yourself. So find another way to put a name on them if you like none of those two ways. If your question is what is the best practice to put an identifier on an object, then the answer is put an identifier on the damn object. </p>

<p>The way I personally favour is through a curried function :</p>

<pre><code>function label(identifier){return function (x){var obj={};obj[identifier]=x;return obj;};}
</code></pre>

<p>which I use as follows:</p>

<pre><code>source1.map(label('remove')).merge(source2.map(label('add')))
</code></pre>

<p>but really, do as you please, how you do this is a rather minor issue, in my opinion. </p>
","3743222","","","","","2016-03-22 20:23:06","","","","1","","","","CC BY-SA 3.0"
"36188530","1","","","2016-03-23 20:56:26","","0","235","<p>I have a class which extends angular <code>Http</code> class, let's call it <code>MyHttp</code>.
I also have <code>MyJwtHttp</code> class which extends <code>MyHttp</code> class.</p>

<p>I want to be able to return the response as json the problem is that if I'm doing something like this:</p>

<pre><code>myJwtHttp.request(..).map(res=&gt;res.json()
</code></pre>

<p>and the implementation of the <code>request</code> method is:</p>

<pre><code>class MyHttp extends Http {
    request(url,...){
        ..
         ..
    return super.request(url).subscribe(res=&gt; doSomething(res))
    }
}
</code></pre>

<p>The problem here is that the <code>map</code> function is getting invoked before the subscriber of the <code>MyHttp</code> class. This causes the input of the <code>doSomething(res)</code> to be a json and not the response itself..</p>

<p>I have tried using <code>last</code> instead of <code>map</code> but it won't return the json to the caller of the request.</p>

<p>Any idea how to solve this issue?</p>
","2382620","","1873365","","2016-03-23 22:18:49","2016-03-23 22:18:49","angular2: Obserable<Response> response.json() after all subscribes are done","<angular><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"36215011","1","36220015","","2016-03-25 06:16:47","","0","49","<p>code here:</p>

<pre><code>@Injectable()
export class ProjectService {
  create$: Rx.Subject&lt;Response&gt; = new Rx.Subject();
  _create: Rx.Observable&lt;Response&gt; = this.create$.asObservable();
  newProject: Rx.Subject&lt;ProjectInfo&gt; = new Rx.Subject();
  get$: Rx.Subject&lt;any&gt; = new Rx.Subject();
  _get: Rx.Observable&lt;any&gt; = this.get$.asObservable();

  constructor(public _http: Http, public option: HeaderWithToken) {
    this._create = this.newProject.flatMap(project =&gt; {
      console.log(""create"",project);
      return this._http.post(baseURL + ""/project"",
               JSON.stringify(project), this.option.Option);
    });

    this._get = this._http
      .get(baseURL + ""/project"", this.option.Option)
      .do(x=&gt;{
        console.log(""to get"",x);
      })
      .map(res =&gt; res.json());

    this._create
          .map(x=&gt;x.json())
          .filter(res=&gt;res.status==200)
          .subscribe(this.get$);

    this._get.subscribe(x =&gt; {
      console.log(""get:"", x);
    })
  }

  addProject(project: ProjectInfo) {
    this.newProject.next(project);
  }

  getProject() {
    return this._get;
  }
}
</code></pre>

<p>I hope the stream will work as 
1. when I call addProject => emit the value => trigger post request => when post response 200 continue the get request (_get stream) => I can subscribe the get$ stream other place to get all latest data.</p>

<p>actually:
post successfull, but did not go into the get request, it seems that sth wrong with the code </p>

<pre><code>    this._create
    .map(x=&gt;x.json())
    .filter(res=&gt;res.status==200)
    .subscribe(this.get$); 
</code></pre>

<p>Please help!</p>
","5492052","","1873365","","2016-03-25 07:56:35","2016-03-25 12:32:36","Did not execute the stream which subscribed by another subject","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36218920","1","36219394","","2016-03-25 11:17:46","","3","3039","<p>I just installed rxjs 5 beta 3 via <code>npm i rxjs@5.0.0-beta.3</code>.</p>

<p>I have the following example code:</p>

<pre><code>import {Observable} from ""rxjs""

new Observable(o =&gt; o.next(42)).filter(() =&gt; true);
</code></pre>

<p>This code compiles perfectly well when using ts-node for example.</p>

<p>But when looking at this code inside IntelliJ IDEA, the <code>filter()</code> operator is not found.</p>

<p>When using operators on an Observable instance, they are not found either.</p>

<p>The suggested static members of <code>Observable</code> are:</p>

<ul>
<li><code>create()</code></li>
<li><code>if()</code></li>
<li><code>throw()</code></li>
</ul>

<p>The suggested members of an instance of <code>Observable</code> are:</p>

<ul>
<li><code>_isScalar()</code></li>
<li><code>forEach()</code></li>
<li><code>lift()</code></li>
<li><code>subscribe()</code></li>
</ul>

<p>I also tried to import only what I need, but still my IDE tells me that <code>filter()</code> does not exist on the Observable instance:</p>

<pre><code>import {Observable} from ""rxjs/Observable""
import ""rxjs/add/operator/filter""

new Observable(o =&gt; o.next(42)).filter(() =&gt; true);
</code></pre>

<p>Any suggestions how to make IntelliJ IDEA know about the operators?</p>
","558398","","","","","2016-08-15 12:37:49","IntelliJ IDEA does not find operators of Observable in rxjs5","<intellij-idea><typescript><rxjs5>","3","0","","","","CC BY-SA 3.0"
"36219394","2","","36218920","2016-03-25 11:51:42","","4","","<p>Please, check <a href=""https://confluence.jetbrains.com/display/IDEADEV/IDEA+2016.1+EAP"" rel=""nofollow noreferrer"">IDEA 2016.1.2 or higher</a></p>

<p><em>Note</em>: Directory <code>node_modules</code> must be not excluded from the project.
<br>Otherwise, see answer <a href=""https://stackoverflow.com/a/38499577/1057218"">https://stackoverflow.com/a/38499577/1057218</a></p>

<p><em>Note 2</em>: File <code>package.json</code> must contain the direct dependency (or devdependency) '<code>rxjs</code>'</p>
","1057218","","-1","","2017-05-23 11:54:31","2016-08-15 12:37:49","","","","4","","","","CC BY-SA 3.0"
"36220015","2","","36215011","2016-03-25 12:32:36","","0","","<p>I make it works.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>@Injectable()
export class ProjectService {

  _create: Rx.Observable &lt; Response &gt; = new Rx.Observable();
  newProject: Rx.Subject &lt; ProjectInfo &gt; = new Rx.Subject();
  _get: Rx.Observable &lt; any &gt; = new Rx.Observable();
  res$: Rx.Observable &lt; any &gt; = new Rx.Subject().asObservable();

  constructor(public _http: Http, public option: HeaderWithToken) {

    //any new value into the newProject will deliver to post and save as create stream
    //to check the status code in the create stream to close dialog
    this._create = this.newProject
      .flatMap(
        project =&gt; {
          return this._http
            .post(
              baseURL + ""/project"",
              JSON.stringify(project),
              this.option.Option
            );
        });

    this.res$ = this._create
      .filter(res =&gt; res.status == 200)
      .flatMap(x =&gt; {
        DialogServices.getRef()
          .then(x =&gt; {
            x.dispose();
          })
        return this._get;
      })

    //For get all project from DB, will return an array of projectInfo
    this._get = this._http
      .get(baseURL + ""/project"", this.option.Option)
      .map(res =&gt; res.json());

    this.res$.subscribe(x =&gt; {
      cacheProject = x;
      console.log(""cache"", x, cacheProject);
      getAllProjects.next(cacheProject);
    })
  }
  addProject(project: ProjectInfo) {
    this.newProject.next(project);
  }
}</code></pre>
</div>
</div>
</p>
","5492052","","","","","2016-03-25 12:32:36","","","","0","","","","CC BY-SA 3.0"
"36221115","1","36221129","","2016-03-25 13:43:25","","4","3747","<p>Is it possible to concatenate multiple observables?</p>

<p>For example:
I have 3 function:</p>

<pre><code>ensureUserLogged():Observable&lt;boolean&gt;

createEntity():Observable&lt;Entity&gt;

checkEntity():Observable&lt;boolean&gt;
</code></pre>

<p>I would like to do something like:</p>

<pre><code>Observable.combine (ensureUserLogged(), createEntity(), checkEntity()).subscribe (
    checkEntityResult =&gt; console.log (checkEntityResult),
    error =&gt; console.log (error)
);
</code></pre>

<p>or something like:</p>

<pre><code>ensureUserLogged().then (logged =&gt; createEntity()).then (newEntity =&gt; checkEntity ())...
</code></pre>

<p>Otherwise I need to write a ugly piramid:</p>

<pre><code>ensureUserLogged().subscribe (
    res =&gt; {
        createEntity ().subscribe (
            res =&gt; {
                checkEntity ().subscribe (
                    res =&gt; { console.log (""I'm finally here"") },
                    error {}
                )
            },
            err =&gt; {
            }
        );
    },
    err =&gt; {
    }
)
</code></pre>

<p>Is there something to achieve my will?</p>

<p>Thanks</p>
","3471528","","","","","2017-06-20 11:50:30","Concatenate rxjs Observables","<typescript><angular><rxjs><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"36221129","2","","36221115","2016-03-25 13:44:13","","8","","<p>You need to use <code>Observable.forkJoin</code> for <strong>parallel execution</strong>:</p>

<pre><code>Observable.forkJoin(ensureUserLogged(), createEntity(), checkEntity()).subscribe (
  checkEntityResult =&gt; console.log (checkEntityResult),
  error =&gt; console.log (error)
);
</code></pre>

<p><code>checkEntityResult</code> will correspond to an array containing each elements: the first one for the result of <code>ensureUserLogged</code>, ...</p>

<p>To execute things <strong>in series</strong>, you need to use the <code>flatMap</code> operator:</p>

<pre><code>ensureUserLogged().flatMap((resultOfEnsureUserLogged) =&gt; {
  return createEntity();
}).flatMap((resultOfCreateEntity) =&gt; {
  return checkEntity();
}).subscribe((resultOfChekEntity) =&gt; {
  (...)
});
</code></pre>

<p>You can notice that you can mix things. For example something like that:</p>

<pre><code>ensureUserLogged().flatMap((resultOfEnsureUserLogged) =&gt; {
  return Observable.forJoin(createEntity(), checkEntity());
}).subscribe((resultOfCreateEntityAndChekEntity) =&gt; {
  (...)
});
</code></pre>
","1873365","","314472","","2017-06-20 11:50:30","2017-06-20 11:50:30","","","","5","","","","CC BY-SA 3.0"
"36236925","1","36237495","","2016-03-26 15:12:51","","0","1554","<p>using Rxjs I need to do 4 actions in an Angular service and then the component consumes that service function:</p>

<p>-call the function ""ensureHasCache():Observable""</p>

<p>-call the function ""create():Observable""</p>

<p>-take the result of create() and assign a local variable (this._companies.push (newEntity);)</p>

<p>-then return an Observable in order to consume it on the UI</p>

<p>This is my service code where the 4 actions take place:</p>

<pre><code>public create (data:Company):Observable&lt;Company&gt;
{       
    return this.ensureHasCache ().switchMap (res =&gt; {
        return super.create (data);
    }).switchMap ((newEntity:Company) =&gt; {            
        this._companies.push (newEntity);
        return ObservableUtils.fromResult (newEntity);
    });
}       
</code></pre>

<p>As you can see in the last switchMap I need to return an observable but 
actually I already have the result. So I have to call ""fromResult"". 
But in this way I need to create a new observalbe (""fromResult"" creates a new Observable)
even if I actually dont need it.</p>

<p>Is there a more elegat way?</p>

<p>This is the code of fromResult:</p>

<pre><code>public static fromResult&lt;T&gt; (result:T):Observable&lt;T&gt;
{
    return new Observable&lt;T&gt; (obs =&gt; {
        obs.next (result);
        obs.complete ();
    });
}
</code></pre>
","3471528","","3471528","","2016-03-26 15:18:46","2016-03-26 16:04:53","How to use an observable result and then return the observable","<typescript><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36237495","2","","36236925","2016-03-26 16:04:53","","1","","<p>I would do something like that using the <code>do</code> operator of observables:</p>

<pre><code>public create (data:Company):Observable&lt;Company&gt; {       
  return this.ensureHasCache ().switchMap (res =&gt; {
    return super.create (data);
  }).do((newEntity:Company) =&gt; {            
    this._companies.push (newEntity);
  });
} 
</code></pre>
","1873365","","","","","2016-03-26 16:04:53","","","","0","","","","CC BY-SA 3.0"
"36245443","1","","","2016-03-27 08:40:11","","2","2803","<p>I have three Observables that are containing fetched data from the server (all of the same type). For displaying the data nicely I want to add empty data points to the streams so the times align (the time of the recording of the data). Something like this:</p>

<pre><code>Stream 1: 12:30 ------ 15:30 -- 16:00 ----------------- 19:00
Stream 2: 12:30 --------------- 16:00 ------ 17:30 ----------
Stream 3: -------------15:30 -------------------------- 19:00
                    |                            |
                    V                            V
Stream 1: 12:30 ------ 15:30 -- 16:00 ------(17:30)---- 19:00
Stream 2: 12:30 ------(15:30)-- 16:00 ------ 17:30 ----(19:00)
Stream 3:(12:30)-------15:30 --(16:00)------(17:30)---- 19:00
</code></pre>

<p>Parenthesis mean empty.
Is there a good way to do this? Or do I have to change it completely?</p>
","3892684","","","","","2016-04-05 14:22:41","Add data to Observable","<rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"36258006","1","36258935","","2016-03-28 07:36:42","","4","3481","<p>It seems in rxjs 4.x, Rx.Observable.fromCallback accept scope as the second parameter, but in 5.0, this method is changed to Rx.Observable.bindCallback and doesn't accept scope parameter. How to add scope parameter in bindCallback. For example in ES6.</p>

<pre><code>class Test {
  constructor(input) {
    this.input = input;
  }

  callback(cb) {
    return cb(this.input);
  }

  rx() {
    // this works on rx 4.x
    // var observable = Rx.Observable.fromCallback(this.callback, this)();

    // this doesn't work, because this.callback function doesn't use original this, so cannot get this.input
    var observable = Rx.Observable.bindCallback(this.callback)();

    // Work around: Rx.Observable.bindCallback(this.callback)();
    // var me = this;
    // var observable = Rx.Observable.bindCallback((cb) =&gt; {me.callback(cb);})();

    observable.subscribe(
      input =&gt; console.log('get data =&gt; ' + input),
      err =&gt; console.log('get error =&gt;' + err),
      () =&gt; console.log('complete')
    );
   }
  }

  new Test(100).rx();
</code></pre>
","2025792","","4746094","","2017-06-14 20:05:39","2017-06-14 20:05:39","Rx.Observable.bindCallback with scope in rxjs","<javascript><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"36258935","2","","36258006","2016-03-28 08:49:07","","1","","<p>It works for me, when I add this to the constructor</p>

<pre><code>  constructor(input) {
    this.input = input;
    this.callback = this.callback.bind(this)
  }
</code></pre>
","1054992","","","","","2016-03-28 08:49:07","","","","1","","","","CC BY-SA 3.0"
"36271314","1","36288640","","2016-03-28 21:15:13","","8","11338","<p><strong>Hello,</strong></p>

<p>I am using Angular2 beta 12 running in VS2015. When I update to rxjs from 5.0.0-beta.2 to beta.3 I encounter a range of exceptions generally relating to my promises.</p>

<p>E.g.</p>

<ol>
<li>Property <code>map</code> does not exist on type <code>Observable&lt;Response&gt;</code></li>
<li>Property <code>share</code> does not exist in type <code>Observable&lt;Response&gt;</code></li>
<li>Ambient modules declaration cannot specify relative module name</li>
<li>Ambient modules cannot be nested in other modules or namespaces.</li>
</ol>

<p>Package.json</p>

<pre class=""lang-javascript prettyprint-override""><code>{
  ""name"": ""ASP.NET"",
  ""version"": ""0.0.0"",
  ""scripts"": {
    ""tsc"": ""tsc"",
    ""tsc:w"": ""tsc -w"",
    ""lite"": ""lite-server"",
    ""start"": ""concurrent \""npm run tsc:w\"" \""npm run lite\"" ""
  },
  ""dependencies"": {
    ""angular2"": ""2.0.0-beta.12"",
    ""systemjs"": ""0.19.24"",
    ""es6-promise"": ""3.1.2"",
    ""es6-shim"": ""0.35.0"",
    ""reflect-metadata"": ""0.1.3"",
    ""rxjs"": ""5.0.0-beta.3"", // beta.2 allowed project to build
    ""zone.js"":""0.6.6""
  },
  ""devDependencies"": {
    ""gulp"": ""3.9.1"",
    ""gulp-concat"": ""2.6.0"",
    ""gulp-cssmin"": ""0.1.7"",
    ""gulp-uglify"": ""1.5.3"",
    ""rimraf"": ""2.2.8"",
    ""concurrently"": ""2.0.0"",
    ""lite-server"": ""2.1.0"",
    ""typescript"": ""1.8.9""
  }
}
</code></pre>

<p>Issue relates to map function in this code:</p>

<pre><code>import {Injectable} from 'angular2/core';
import {Http, Response} from 'angular2/http';
import {Headers, RequestOptions} from 'angular2/http';
import {Observable}     from 'rxjs/Observable';

import {ApplicationVM} from '../../Applications/ViewModels/Application.ViewModel';

@Injectable()
export class ApplicationService {
    constructor(private http: Http) { }

    private _serviceUrl = './../api/';

    getApplications() {
        return this.http.get(this._serviceUrl + ""applications/active"")
            .map(res =&gt; &lt;ApplicationVM[]&gt;res.json())
           // .map((res: Response) =&gt; res.json())
            .do(data =&gt; console.log(data)) // eyeball results in the console
            .catch(this.handleError);
    }

    private handleError(error: Response) {
        console.log(error);
        return Observable.throw(error.json().error || 'Server error');
    }

}
</code></pre>

<p>In another, the problem is with <code>share()</code></p>

<pre><code> constructor(private _http: Http) {
     console.log(""constructor"");
     this.menulist$ = new Observable(observer =&gt; this._menulistObserver = observer).share();
     this.menuState$ = new Observable(observer =&gt; this._menuStateObserver = observer).share();
     this.menuWidth$ = new Observable(observer =&gt; this._menuWidthObserver = observer).share();}
</code></pre>

<p>I feel this might be important - a range of rxjs files have underlined red for relative references <code>../../Observable</code> (example below is in interval.d.ts)</p>

<pre><code>import { IntervalObservable } from '../../observable/IntervalObservable';
declare module '../../Observable' {
    namespace Observable {
        let interval: typeof IntervalObservable.create;
    }
}
</code></pre>

<p>My boot.ts</p>

<pre><code>///&lt;reference path=""./../node_modules/angular2/typings/browser.d.ts""/&gt;
import {bootstrap}      from 'angular2/platform/browser';
import {ROUTER_PROVIDERS} from 'angular2/router';
import {AppComponent} from './app.component';
import {HTTP_PROVIDERS}    from 'angular2/http';
import 'rxjs/Rx'; // kitchen sink

// Bootstrap the application and reference the required directives
bootstrap(AppComponent, [ROUTER_PROVIDERS, HTTP_PROVIDERS]);
</code></pre>

<p>My html page</p>

<pre class=""lang-html prettyprint-override""><code> &lt;!-- 1. Load libraries --&gt;
    &lt;script src=""~/nodelibs/angular2/bundles/angular2-polyfills.js""&gt;&lt;/script&gt;
    &lt;script src=""~/nodelibs/systemjs/system.src.js""&gt;&lt;/script&gt;
    &lt;script src=""~/nodelibs/typescript/lib/typescript.js""&gt;&lt;/script&gt;
    &lt;script src=""~/nodelibs/rxjs/bundles/Rx.js""&gt;&lt;/script&gt;
    &lt;script src=""~/nodelibs/angular2/bundles/angular2.dev.js""&gt;&lt;/script&gt;

    &lt;script src=""~/nodelibs/angular2/bundles/router.dev.js""&gt;&lt;/script&gt;
    &lt;script src=""~/nodelibs/angular2/bundles/http.dev.js""&gt;&lt;/script&gt;


    &lt;!-- 2. Configure SystemJS --&gt;
    &lt;script&gt;

    var rootPath = ""@Url.Content(""~/"")"";

    System.config({
        //transpiler: 'typescript',
        //typescriptOptions: { emitDecoratorMetadata: true },
        baseURL: rootPath,
        defaultJSExtensions: true,
        packages: {
            app: {
                //format: 'register',
                defaultExtension: 'js'
            }, map: {

                'rxjs/observable/*' : 'nodelibs/rxjs/observable/*.js',
                'rxjs/operators/*' : 'nodelibs/rxjs/operators/*.js',
                'rxjs/*' : 'nodelibs/rxjs/*.js'
            }
        }
    });
    System.import(""/app/boot.js"")
          .then(null, console.error.bind(console));

    &lt;/script&gt;
</code></pre>

<p>I'm stumped and would appreciated some assistance.</p>

<p><strong>Thank, Dan.</strong></p>
","2597212","","540776","","2016-04-18 21:29:17","2016-08-21 15:11:28","Observable errors with Angular2 beta.12 and RxJs 5 beta.3","<typescript><angular><asp.net-core-mvc><observable><rxjs5>","3","0","","","","CC BY-SA 3.0"
"36271899","1","","","2016-03-28 21:55:35","","332","104353","<p>By using Http, we call a method that does a network call and returns an http observable:</p>



<pre class=""lang-js prettyprint-override""><code>getCustomer() {
    return this.http.get('/someUrl').map(res =&gt; res.json());
}
</code></pre>

<p>If we take this observable and add multiple subscribers to it:</p>

<pre class=""lang-js prettyprint-override""><code>let network$ = getCustomer();

let subscriber1 = network$.subscribe(...);
let subscriber2 = network$.subscribe(...);
</code></pre>

<p>What we want to do, is ensure that this does not cause multiple network requests.</p>

<p>This might seem like an unusual scenario, but its actually quite common: for example if the caller subscribes to the observable to display an error message, and passes it to the template using the async pipe, we already have two subscribers.</p>

<p>What is the correct way of doing that in RxJs 5? </p>

<p>Namely, this seems to work fine:</p>

<pre class=""lang-js prettyprint-override""><code>getCustomer() {
    return this.http.get('/someUrl').map(res =&gt; res.json()).share();
}
</code></pre>

<p>But is this the idiomatic way of doing this in RxJs 5, or should we do something else instead? </p>

<p><em>Note : As per Angular 5 new <code>HttpClient</code>, the <code>.map(res =&gt; res.json())</code> part in all examples is now useless, as JSON result is now assumed by default.</em></p>
","2898867","","479251","","2018-01-22 07:58:36","2021-09-08 19:18:26","What is the correct way to share the result of an Angular Http network call in RxJs 5?","<angular><rxjs><angular2-services><rxjs5>","21","6","151","","","CC BY-SA 3.0"
"36272036","1","36316843","","2016-03-28 22:05:38","","25","29302","<p>I'm getting started with RxJs (using the v5 beta), but somehow I can't figure out how to work with <code>distinctUntilChanged</code>. The output from the code below if I run it in babel-node is</p>

<pre><code>[ 'a', 1 ]
{ key: 'a', state: 1 }
Next:  { value: 42 }
Completed
</code></pre>

<p>That is not what I would expect. Why is only one entry passing <code>distinctUntilChanged</code>? I would expect the output to be</p>

<pre><code>[ 'a', 1 ]
[ 'a', 0 ]
[ 'a', 1 ]
{ key: 'a', state: 1 }
{ key: 'a', state: 2 }
{ key: 'a', state: 0 }
{ key: 'a', state: 1 }
Next:  { value: 42 }
Next:  { value: 24 }
Completed
</code></pre>

<p>Here's the code</p>

<pre><code>import {Observable} from 'rxjs'

Observable.of(['a', 1], ['a', 1], ['a', 0], ['a', 1])
  .distinctUntilChanged(x =&gt; x[1])
  .subscribe(x =&gt; console.log(x))

Observable.of({key: 'a', state: 1}, {key: 'a', state: 2}, {key: 'a', state: 0}, {key: 'a', state: 1})
  .distinctUntilChanged(x =&gt; x.state)
  .subscribe(x =&gt; console.log(x))

Observable.of({value: 42}, {value: 42}, {value: 24}, {value: 24})
  .distinctUntilChanged(x =&gt; x.value)
  .subscribe(
    function (x) {
      console.log('Next: ', x)
    },
    function (err) {
      console.log('Error: ' + err)
    },
    function () {
      console.log('Completed')
    }
  )
</code></pre>

<p>The <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/operators.md"" rel=""noreferrer"">links</a> in the v5 docs for these functions appear to be dead </p>

<p>------ edit -----</p>

<p>Some additional debugging: </p>

<pre><code>Observable.of(['a', 1], ['a', 1], ['a', 0], ['a', 1])
  .do(x =&gt; console.log('before', x))
  .distinctUntilChanged(x =&gt; x[1])
  .do(x =&gt; console.log('after', x))
  .subscribe(x =&gt; console.log(x))
</code></pre>

<p>output: </p>

<pre><code>before [ 'a', 1 ]
after [ 'a', 1 ]
[ 'a', 1 ]
before [ 'a', 1 ]
before [ 'a', 0 ]
before [ 'a', 1 ]
</code></pre>
","294632","","294632","","2016-03-29 06:40:31","2016-03-30 18:28:27","How to use RxJs distinctUntilChanged?","<javascript><rxjs><rxjs5>","2","2","2","","","CC BY-SA 3.0"
"36273791","1","36290753","","2016-03-29 01:14:58","","22","42110","<p>I've been trying to get a draggable div working using Angular 2.  I'm using <a href=""https://github.com/AngularClass/angular2-examples/blob/master/rx-draggable/directives/draggable.ts"" rel=""noreferrer"">this example from the angular2-examples repo</a> as a starting point, only really adjusting the code to account for the removal of the <code>toRx()</code> method.  The code works, but it does not account for <code>mouseout</code> events.  This means that if I click on a Draggable div, and move the mouse <em>slowly</em>, the div will move with the mouse.  But if I move the mouse too fast, a <code>mouseout</code> event is sent instead of a <code>mousemove</code> event, and the dragging stops.</p>

<p>How can I keep the drag going after the mouse is moved so far that a <code>mouseout</code> event is fired?  I've tried merging the <code>mouseout</code> event stream with the <code>mousemove</code> one, so that <code>mouseout</code> events are treated just like <code>mousemove</code> ones, but that doesn't work.</p>

<p>I'm using Angular 2.0.0-beta.12.</p>

<pre class=""lang-js prettyprint-override""><code>import {Component, Directive, HostListener, EventEmitter, ElementRef, OnInit} from 'angular2/core';
import {map, merge} from 'rxjs/Rx';

@Directive({
    selector: '[draggable]'
})
export class Draggable implements OnInit {

    mouseup = new EventEmitter();
    mousedown = new EventEmitter();
    mousemove = new EventEmitter();
    mouseout = new EventEmitter();

    @HostListener('mouseup', ['$event'])
    onMouseup(event) {
        this.mouseup.emit(event);
    }

    @HostListener('mousedown', ['$event'])
    onMousedown(event) {
        this.mousedown.emit(event);
        return false; // Call preventDefault() on the event
    }

    @HostListener('mousemove', ['$event'])
    onMousemove(event) {
        this.mousemove.emit(event);
    }

    @HostListener('mouseout', ['$event'])
    onMouseout(event) {
        this.mouseout.emit(event);
        return false; // Call preventDefault() on the event
    }

    constructor(public element: ElementRef) {
        this.element.nativeElement.style.position = 'relative';
        this.element.nativeElement.style.cursor = 'pointer';

        map;
        merge;
        this.mousedrag = this.mousedown.map(event =&gt; {
            return {
                top: event.clientY - this.element.nativeElement.getBoundingClientRect().top
                left: event.clientX - this.element.nativeElement.getBoundingClientRect().left,
            };
        })
        .flatMap(
            imageOffset =&gt; this.mousemove.merge(this.mouseout).map(pos =&gt; ({
                top: pos.clientY - imageOffset.top,
                left: pos.clientX - imageOffset.left
            }))
            .takeUntil(this.mouseup)
        );
    }

    ngOnInit() {
        this.mousedrag.subscribe({
            next: pos =&gt; {
                this.element.nativeElement.style.top = pos.top + 'px';
                this.element.nativeElement.style.left = pos.left + 'px';
            }
        });
    }
}

@Component({
    selector: 'my-app',
    template: `
        &lt;div draggable&gt;
            &lt;h1&gt;Hello, World!&lt;/h1&gt;
        &lt;/div&gt;
        `,
    directives: [Draggable,],
})
export class AppComponent {
}
</code></pre>
","1440562","","106909","","2017-01-13 13:21:51","2018-02-08 21:03:22","How to implement a draggable div in Angular 2 using Rx","<angular><angular2-directives><rxjs5>","4","1","10","","","CC BY-SA 3.0"
"36276552","2","","35531128","2016-03-29 05:59:56","","2","","<p>Here is how I would do it in general lines. If this seems to give you satisfaction, I'll edit and add more details.</p>

<p>Version 2 : (For first one, see edit changes)</p>

<p>Premises :</p>

<ol>
<li>The tag containing the dynamic list will be called ""the zone"".</li>
<li>Each row of the list will be contained in another DIV which can contains anything.</li>
<li>A page is enough rows to cover the zone.</li>
<li>Three javascript ""constants"" : numberOfLinesOnFirstLoad, numberOfLinesOnPageLoad, numberOfLinesToLoadAfter</li>
<li>JavaScript variables to hold required data : rows[page#], heights[page#], currentPageNumber = 1, maxPageNumber = 0</li>
<li>page# : # is the page number</li>
<li>rows[page#] shall contains a way to get them back from database, not real DOM objects.</li>
</ol>

<p>Steps / Events :</p>

<ol>
<li>Add the zone tag.</li>
<li>Load numberOfLinesOnFirstLoad rows.</li>
<li>If total rows height inferior zone height multiplied by three, then load numberOfLinesToLoadAfter rows. Repeat step 3 if rows added, otherwise continue to step 4.</li>
<li>maxPageNumber +=1. Find the next rows that full fills the zone. Add those rows to rows[""page"" + maxPageNumber] (as an array). Calculate the height of those and add it in heights[""page"" + maxPageNumber].</li>
<li>Repeat step 4 until no more rows and then continue to step 6.</li>
<li>When scrolling down and page1 (which means last element of rows[""page1""]) is not visible, add another below : page4. </li>
<li>maxPageNumber += 1. Load numberOfLinesOnPageLoad rows.</li>
<li>If total new rows height inferior zone height, then numberOfLinesToLoadAfter rows. Repeat step 8 if rows added, otherwise put total new rows height in heights[""page"" + maxPageNumber] and the new rows as array in rows[""page"" + maxPageNumber] and continue to the step after entering this one (so either 9 or 11).</li>
<li>Still scrolling down, if page2 is not visible, remove the page1 elements from DOM and adjust scroll position by removing page1.height (heights[""page1""]). </li>
<li>Load page 5 (step 7 and 8).</li>
<li>So now, there is page2 to page5 in the zone which page2 and page5 are not visible. If page3 is fully visible, than page4 is not, otherwise a part of page3 and page4 are visible. (Just to indicate possibilities, but not important)</li>
<li>When scrolling up and page2 is starting to be visible (so last element of rows[""page2""]), load page1 by using rows[""page1""], add page1.height (heights[""page1""]) to scroll position and remove page5 from DOM. Here you can either remove it from variables rows &amp;&amp; heights and maxPageNumber -= 1, but you can also keep them so that reloading this page is done in one process (so loading a page would imply to check if page definition already exists in those variables).</li>
</ol>
","214898","","214898","","2016-03-31 03:56:40","2016-03-31 03:56:40","","","","9","","","","CC BY-SA 3.0"
"36288640","2","","36271314","2016-03-29 15:28:26","","6","","<p>According to Angular's package.json you should use exactly RxJS 5.0.0-beta.2 <a href=""https://github.com/angular/angular/blob/master/package.json#L37"">https://github.com/angular/angular/blob/master/package.json#L37</a></p>
","3415077","","","","","2016-03-29 15:28:26","","","","3","","","","CC BY-SA 3.0"
"36290753","2","","36273791","2016-03-29 17:10:24","","29","","<p>I found the answer to this in <a href=""https://stackoverflow.com/questions/28477146/rxjs-how-do-deal-with-document-events"">RxJs How do deal with document events</a>.  The crux of the problem is that mouse events are only sent to an element when the mouse is over that element.  So we do want the <code>mousedown</code> event limited to specific element, but we have to track <em>global</em> <code>mousemove</code> and <code>mouseup</code> events.  Here's the new code.  Notice the use of the <code>@HostListener</code> decorator on <code>onMouseup</code> and <code>onMousemove</code> specifies the target as <code>document:mouseup</code> and <code>document:mousemove</code>.  This is how the global events are piped into the Rx stream.</p>

<p>The <a href=""https://angular.io/docs/js/latest/api/core/HostListener-var.html"" rel=""noreferrer"">official angular2 documentation for HostListener</a> doesn't mention this <code>target:eventName</code> syntax, but <a href=""https://www.dartdocs.org/documentation/angular2/2.0.0-alpha.24/angular2.angular2/Directive/hostListeners.html"" rel=""noreferrer"">this old dart documentation for 2.0.0-alpha.24</a> does mention it.  It seems to still work in 2.0.0-beta.12.</p>

<pre class=""lang-js prettyprint-override""><code>@Directive({
    selector: '[draggable]'
})
export class Draggable implements OnInit {

    mouseup = new EventEmitter&lt;MouseEvent&gt;();
    mousedown = new EventEmitter&lt;MouseEvent&gt;();
    mousemove = new EventEmitter&lt;MouseEvent&gt;();

    mousedrag: Observable&lt;{top, left}&gt;;

    @HostListener('document:mouseup', ['$event'])
    onMouseup(event: MouseEvent) {
        this.mouseup.emit(event);
    }

    @HostListener('mousedown', ['$event'])
    onMousedown(event: MouseEvent) {
        this.mousedown.emit(event);
        return false; // Call preventDefault() on the event
    }

    @HostListener('document:mousemove', ['$event'])
    onMousemove(event: MouseEvent) {
        this.mousemove.emit(event);
    }

    constructor(public element: ElementRef) {
        this.element.nativeElement.style.position = 'relative';
        this.element.nativeElement.style.cursor = 'pointer';

        this.mousedrag = this.mousedown.map(event =&gt; {
            return {
                top: event.clientY - this.element.nativeElement.getBoundingClientRect().top
                left: event.clientX - this.element.nativeElement.getBoundingClientRect().left,
            };
        })
        .flatMap(
            imageOffset =&gt; this.mousemove.map(pos =&gt; ({
                top: pos.clientY - imageOffset.top,
                left: pos.clientX - imageOffset.left
            }))
            .takeUntil(this.mouseup)
        );
    }

    ngOnInit() {
        this.mousedrag.subscribe({
            next: pos =&gt; {
                this.element.nativeElement.style.top = pos.top + 'px';
                this.element.nativeElement.style.left = pos.left + 'px';
            }
        });
    }
}
</code></pre>
","1440562","","7391","","2018-02-08 21:03:22","2018-02-08 21:03:22","","","","7","","","","CC BY-SA 3.0"
"36316843","2","","36272036","2016-03-30 18:28:27","","36","","<p>I got an answer <a href=""https://github.com/Reactive-Extensions/RxJS/issues/1188"">here</a>. Basically the function signature changed from (key selector, comparator) to (comparator, key selector).</p>

<p>This is how the example is done in v5:</p>

<pre><code>Observable.of(['a', 1], ['a', 1], ['a', 0], ['a', 1])
  .distinctUntilChanged(null, x =&gt; x[1])
  .subscribe(x =&gt; console.log(x))
</code></pre>
","294632","","","","","2016-03-30 18:28:27","","","","0","","","","CC BY-SA 3.0"
"36378709","1","36379139","","2016-04-02 21:07:10","","1","1383","<pre><code>/**
 * Created by darius on 02/04/16.
 */
import { Component } from 'angular2/core';
import { Observable } from 'rxjs/Rx';


@Component({
  styles: [ require('../../style.css') ],
  selector: 'keypresses-per-second',

  template: `

    &lt;div class=""block""&gt;

      &lt;input  type=""text"" (keypress)=""onKeypress($event)""&gt;

      {{keypresses}} &lt;br&gt;
      &lt;input type=""text"" (keypress)=""onKeypressReact($event)""&gt;
      {{keypressesReactive}}
    &lt;/div&gt;
  `
})

export class KeypressesPerSecond {

  ngOnInit() {

    this.nonReactive();

    this.reactiveWay();
  }

  // not reactive
  keypresses = '';
  counter = 0;
  secondsPassed = 0;

  nonReactive(){

    var self = this;

    var int = setInterval(function(){

      console.log(self.counter, 'counter in non reactive')
      self.keypresses += self.counter + ', ';
      self.counter = 0;
      self.secondsPassed++
      if (self.secondsPassed &gt; 30) {
        clearInterval(int);
      }
    }, 1000);
  }

  onKeypress($event){
    console.log($event.keyCode);
    this.counter++;
  }
  // end not reactive

  onKeypressReact() {}

  keypressesReactive = '';
  reactiveCount = 0;

  reactiveWay() {

    console.log('reactive way')

    const keypressObservable$ = Observable.create(observer =&gt; {

      // from template
      this.onKeypressReact = () =&gt; { observer.next('press'); };
    });


    keypressObservable$.subscribe(function(event) {
      self.reactiveCount++;
    });

    var self = this;

    var timer$ = Observable.create(function(observer){

      // is subscribed to this observable
      var subscribed = true;
      var int = setInterval(function() {

        if (subscribed) {
          observer.next(self.reactiveCount);
          self.reactiveCount = 0;
        }

        if (self.secondsPassed &gt; 30) {
          observer.complete();
          clearInterval(int)
        }

      }, 1000);

    })


    timer$.subscribe(
      function (x) {
        console.log('Nextzz: %s', x);
        self.keypressesReactive += x + ', ';
      });

  }

}
</code></pre>

<p>I tried to write reactive and non reactive way of keypresses counter.
Take a look at function reactiveWay()</p>

<p>it works, but I think there might be something wrong.</p>

<p>I done excersizes in there
<a href=""http://reactivex.io/learnrx/"" rel=""nofollow"">http://reactivex.io/learnrx/</a></p>

<p>and there was lot of mapping.</p>

<p>It feels like I I had to map the time event to sequence of key events happened per second. 
But do not get how could I map those.</p>

<p>Something like</p>

<pre><code>// doing this way we could removed some code from timer$, we just need to get an event
var kps$ = timer$.concatMap(function(time) {

  var sum = keypressObservable$.takeUntil(timer$)
    .reduce(function (acc, cur) {
      return acc + cur;
    })

  console.log('sum', sum);

  return sum;
})

// this works, counts the keypresses, but only when pressing at least 1. 
kps$.subscribe(
  function (x) {
    console.log('kps next', x);
    self.keypressesReactive += x + ', ';
  });
</code></pre>

<p>How do I force kps$ to emit 0 sum when no keypresses done in the second if I use the kps$?</p>

<p><strong>Update</strong></p>

<p>Based on the answer, I have done this.</p>

<pre><code>var source = Observable.fromEvent(document.body, 'keypress');

var delayedSource = source.delay(1000);


var obs = source

  .buffer(delayedSource)


  .map((clickBuffer) =&gt; {
    return clickBuffer.length;
  })
</code></pre>

<p>But when I subscribe to the obs, I do not get event each second containing 0 value still. When I press some keys in a second, then I get the number of keys pressed and another event of 0. And then events stop until I press keys again.
What do I need to modify so I get event each second?</p>
","1194854","","1194854","","2016-04-03 08:58:10","2016-04-03 08:58:10","Counting keypresses per second with angular 2 Rxjs","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36379139","2","","36378709","2016-04-02 21:51:26","","3","","<p>I think that you could leverage the buffer operator. It allows to buffer events and sends them after an amount of time. You could then map this list of events to its length.</p>

<pre><code>var source = Observable.fromEvent(document.body, 'keyup');

var obs = source
     .bufferTime(1000).map((clickBuffer) =&gt; {
       return clickBuffer.length;
     });

obs.subscribe((num) =&gt; {
  // Get the number of pressed keys per second
});
</code></pre>

<p>See these links:</p>

<ul>
<li><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/buffer.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/buffer.md</a></li>
<li><a href=""https://stackoverflow.com/questions/33402737/how-to-create-a-rxjs-buffer-that-groups-elements-in-nodejs-but-that-does-not-rel"">How to create a RxJS buffer that groups elements in NodeJS but that does not rely on forever running interval?</a></li>
</ul>
","1873365","","-1","","2017-05-23 12:25:42","2016-04-03 08:29:47","","","","3","","","","CC BY-SA 3.0"
"36382875","1","","","2016-04-03 07:45:47","","0","483","<p>I googled a lot, tried to look at d.ts file but still cannot understand what is wrong. Cannot find example of RxJs5 how to use this function.</p>

<pre><code>var source = Observable.fromEvent(document.body, 'keypress');

    var delayedSource = source.delay(1000);

    var obs = source



      .buffer(() =&gt; {
        return   delayedSource;
      })

      .map((clickBuffer) =&gt; {
        return clickBuffer.length;
      });
</code></pre>

<p>I am getting error:</p>

<p>Error:(166, 15) TS2345: Argument of type '() => Observable&lt;{}>' is not assignable to parameter of type 'Observable'.
 Property '_isScalar' is missing in type '() => Observable&lt;{}>'.</p>

<p>buffer.d.ts looks this, I guess I should understand from this, but I can't.</p>

<pre><code>import { Observable } from '../Observable';
/**
 * Buffers the incoming observable values until the passed `closingNotifier`
 * emits a value, at which point it emits the buffer on the returned observable
 * and starts a new buffer internally, awaiting the next time `closingNotifier`
 * emits.
 *
 * &lt;img src=""./img/buffer.png"" width=""100%""&gt;
 *
 * @param {Observable&lt;any&gt;} closingNotifier an Observable that signals the
 * buffer to be emitted} from the returned observable.
 * @returns {Observable&lt;T[]&gt;} an Observable of buffers, which are arrays of
 * values.
 */
export declare function buffer&lt;T&gt;(closingNotifier: Observable&lt;any&gt;): Observable&lt;T[]&gt;;
export interface BufferSignature&lt;T&gt; {
    (closingNotifier: Observable&lt;any&gt;): Observable&lt;T[]&gt;;
}
</code></pre>

<p>This question came from this:
<a href=""https://stackoverflow.com/questions/36378709/counting-keypresses-per-second-with-angular-2-rxjs/36379139#36379139"">Counting keypresses per second with angular 2 Rxjs</a></p>
","1194854","","-1","","2017-05-23 12:31:32","2016-04-03 08:22:25","How to use RxJS 5 buffer function?","<rxjs5>","1","1","","","","CC BY-SA 3.0"
"36395368","1","36395427","","2016-04-04 05:51:34","","1","5346","<p>Hi i have a simple component and a service.When user clicks on submit button i am calling a service where an async subject emits a value to all its subscribers.I have done it using subject it works fine but i want to do it using Async Subject.I have made a demo here <a href=""http://plnkr.co/edit/tHjPVZ5NurJRWdCM9lbt?p=preview"" rel=""nofollow"">http://plnkr.co/edit/tHjPVZ5NurJRWdCM9lbt?p=preview</a> ...This is my Service...</p>

<pre><code>export class ErrorService{
  latestError:AsyncSubject&lt;&gt;=new AsyncSubject();

  error(){
    this.latestError.next('form submitted');
  }
}
</code></pre>

<p>And this is my component class where i am subscribing the asyncsubject</p>

<pre><code>export class AppComponent { 
  result:any;
  constructor(private service:ErrorService){
    this.service.latestError.subscribe(err=&gt; this.result=err);
  }

  onSubmit() { 
    this.service.error();
  }
}
</code></pre>

<p>But this is throwing error...I dont know where i am doing wrong...Somebody please help me to rectify this error and show me how to use async subject and emit values to its subscribers</p>
","5111411","","1873365","","2016-04-04 05:57:27","2016-04-04 06:20:05","How to use async subject in angular2?","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36395427","2","","36395368","2016-04-04 05:56:56","","4","","<p>You need to include the class this way:</p>

<pre><code>import {AsyncSubject} from 'rxjs/subject/AsyncSubject';

@Injectable()
export class ErrorService{
  latestError:AsyncSubject&lt;&gt;=new AsyncSubject();
  error(){
    this.latestError.next('form submitted');
  }
}
</code></pre>

<p>See this plunkr: <a href=""http://plnkr.co/edit/SAl4YVXKRWpS7OeTYMrd?p=preview"" rel=""nofollow"">http://plnkr.co/edit/SAl4YVXKRWpS7OeTYMrd?p=preview</a>.</p>
","1873365","","1873365","","2016-04-04 06:20:05","2016-04-04 06:20:05","","","","4","","","","CC BY-SA 3.0"
"36404939","1","","","2016-04-04 14:06:44","","0","882","<p>I have a component which has two buttons.when i click on the first button as per the demo in the given plunker below it emits an event and my service function emits an async subject with some values...When i click on another button i am trying to call .next event again but it is throwing some error...I have made a pluker demo here <a href=""http://plnkr.co/edit/wpyV7o9JErdQMzGFZ4wp?p=preview"" rel=""nofollow"">http://plnkr.co/edit/wpyV7o9JErdQMzGFZ4wp?p=preview</a> ...If i use subject it works fine but i dont want to use subject in this case...</p>

<pre><code>export class ErrorService{
  latestError:AsyncSubject&lt;string&gt; = new AsyncSubject();

  Save() {
    this.latestError.next('form submitted');
    this.latestError.complete();
  }

  Update(){
    this.latestError.next('form updated');
    this.latestError.complete();
  }
}
</code></pre>

<p>This is my service class and this is how i am calling .next event for async subject.</p>

<pre><code>  this.service.latestError.subscribe(
err=&gt; {
  console.log('result = '+err);
  this.result=err;
},
err =&gt; {
  console.log('err');
},
() =&gt; {
  console.log('complete');
});
</code></pre>

<p>And this is how i have subscribed the async subject...The click event works fine for the first time but when i click the another button it throws error.Somebody please help me to solve this error...How can i call .next() for second time using my async subject...Thanks in advance</p>
","5397028","","1873365","","2016-04-04 14:17:46","2016-07-05 02:58:10","How to fire .next() for the second time in rxjs async subject?","<angular><rxjs5>","2","0","","","","CC BY-SA 3.0"
"36407741","1","","","2016-04-04 16:13:45","","0","1424","<pre><code>var source = Observable.fromEvent(document.body, 'keypress');


var obs = source

  .bufferTime(1000)

  .map((clickBuffer) =&gt; {

    console.log(clickBuffer)

    return clickBuffer.length;
  })

  .take(3)

;

// when using this function - error after 3rd event
obs.subscribe((num) =&gt; {

});
</code></pre>

<p>I am trying this on angular 2 beta and RxJS 5. It gets 3 events with no problems and calculates the keypresses per second. Why do I get the error? I want it to stop after 3 seconds.</p>

<p>This is the continuation of this question:
<a href=""https://stackoverflow.com/questions/36378709/counting-keypresses-per-second-with-angular-2-rxjs"">Counting keypresses per second with angular 2 Rxjs</a></p>

<p><strong>Update</strong></p>

<p>Found the case how make not throw, defining source different way:</p>

<pre><code>// there are functions in typescript class
// onKeypressReactBuffer is called from angular template on input field keypress
class K {

    onKeypressReactBuffer() {}


    reactiveWay() {

    const source = Observable.create(observer =&gt; {

        // next(1) - we will use this value to add
        this.onKeypressReactBuffer = () =&gt; { 
            observer.next(1);      


            // this make it not throw the error. 
            observer.complete('ha') };
        });

    }
}
</code></pre>

<p>So still question remains - why it does not work with function fromEvent() ? I do not see how to define completed() method on this function also. So it should be some default.</p>

<p>And also - how could I find faster that for Observable.create I needed .complete() from the information the error message gave me? It only recently after hours of thinking popped to my head to try - maybe it needs completed() function. </p>

<p><strong>Update</strong></p>

<p>Actually my last updated code does not work correctly. It just stops giving me error.</p>

<p>What happens with last update is - it emits events of 0 and 3 times if not pressing key. Once pressing - it emits event of sum 1 and stops emitting.</p>

<p><strong>Update:</strong></p>

<p>How to reproduce on web pack starter:</p>

<p>Install angular 2 webpack starter version 5.0.3 (with version 3 also I got the error).</p>

<p><strong>Btw I had to change in package.json from Rxjs beta 4 to beta 2, because it was failing to install otherwise.</strong></p>

<p>And in home.comoponent.ts ngOnInit() function put the code almost same as <a href=""https://jsbin.com/fafuladayi/edit?js,console,output"" rel=""nofollow noreferrer"">https://jsbin.com/fafuladayi/edit?js,console,output</a></p>

<p>only difference is that instead of Rx.Observable use Observable and import the Observable - see the code:</p>

<pre><code>import {Component} from 'angular2/core';
import {AppState} from '../app.service';

import {Title} from './title';
import {XLarge} from './x-large';

import { Observable, Subject } from 'rxjs/Rx';

@Component({
  // The selector is what angular internally uses
  // for `document.querySelectorAll(selector)` in our index.html
  // where, in this case, selector is the string 'home'
  selector: 'home',  // &lt;home&gt;&lt;/home&gt;
  // We need to tell Angular's Dependency Injection which providers are in our app.
  providers: [
    Title
  ],
  // We need to tell Angular's compiler which directives are in our template.
  // Doing so will allow Angular to attach our behavior to an element
  directives: [
    XLarge
  ],
  // We need to tell Angular's compiler which custom pipes are in our template.
  pipes: [ ],
  // Our list of styles in our component. We may add more to compose many styles together
  styles: [ require('./home.css') ],
  // Every Angular template is first compiled by the browser before Angular runs it's compiler
  template: require('./home.html')
})
export class Home {
  // Set our default values
  localState = { value: '' };
  // TypeScript public modifiers
  constructor(public appState: AppState, public title: Title) {

  }

  ngOnInit() {
    console.log('hello `Home` component');
    // this.title.getData().subscribe(data =&gt; this.data = data);


    var source = Observable.fromEvent(document.body, 'keypress');


    var obs = source

        .bufferTime(1000)

        .map((clickBuffer) =&gt; {

          //console.log(clickBuffer.length)

          return clickBuffer.length;
        })

        .take(5)

        ;

    // when using this function - error after 3rd event
    obs.subscribe((num) =&gt; {

      console.log(' home ' + num)

    });


  }

  submitState(value) {
    console.log('submitState', value);
    this.appState.set('value', value);
  }

}
</code></pre>

<p>And Thierry Templier example works, but I want to understand also why does not work the Birowsky example with this starter pack. </p>

<p>Btw I also see that Birowsky uses older version - rxjs@5.0.0-alpha.8 . I tried to include beta.2 with this url, but then I get error Rx not found:
<a href=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.2/dist/global/Rx.js"" rel=""nofollow noreferrer"">https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.2/dist/global/Rx.js</a> in jsbin.com</p>
","1194854","","-1","","2017-05-23 12:17:36","2016-04-12 19:26:37","when using Observable.fromEvent() bufferTime() take(3) and subscribe() - error ""Cannot read property 'splice' of null"" after last event is emitted","<angular><rxjs5>","1","3","","","","CC BY-SA 3.0"
"36444939","1","36453093","","2016-04-06 07:59:55","","1","1046","<p>Having two Observables, one emits a mouseover event (debounced by 500ms) and the other one a mouseout event, I'm looking for a possibility to stop the first Observable (mouseover) from emiting when the second Observable (mouseout) occurs.</p>

<pre><code>let mouseOutObservable = Observable.fromEvent($('.row'), 'mouseout')

Observable.fromEvent($('.row'), 'mouseover')
          .debounceTime(500)
          // .stopEmitingWhen(mouseOutObservable) --&gt; how? possible?
          .subscribe(event =&gt; {
              // show tooltip
              mouseOutObservable.first()
                                .subscribe(() =&gt; {
                                   // destroy tooltip
                                });
          });
</code></pre>
","42659","","42659","","2016-04-06 08:15:04","2017-01-06 14:03:38","How to stop an emited value when another Observable emits?","<javascript><typescript><reactive-programming><rxjs><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"36453093","2","","36444939","2016-04-06 13:47:19","","4","","<p><code>takeUntil</code> does exactly what you want.</p>
","1855065","","","","","2016-04-06 13:47:19","","","","0","","","","CC BY-SA 3.0"
"36523248","1","36523792","","2016-04-09 22:01:17","","2","1208","<p>I'm learning Rx so i dont get quiet well some of the mechanics on Rx, what i want to do i can do it easly with callbacks, but i want to understand Rx.</p>

<p>So what i want to do is, debounce a mouse over event 500ms and show a ui interface, and on mouse out hide that interface, so i have this code:</p>

<pre><code>var outStream = Rx.Observable.fromEventPattern(
          function add (h) {
            asset.events.onInputOut.add(function(){
                h('out');
            });
          }
        );

        var overStream = Rx.Observable.fromEventPattern(
          function add (h) {
            asset.events.onInputOver.add(function(e){
                h('over');
            });
          }
        ).debounce(500);


        var source = Rx.Observable.merge(overStream, outStream);

        source.subscribe(function (x) {
            console.log(x);
          });
</code></pre>

<p>What i want is something like this:</p>

<pre><code>.
.mouse over fired after 500ms
.mouseout
.
.mouse over
.mouse out fired before 500ms trigger cancel mouse over
</code></pre>

<p>I need some directions, thanks in advance.</p>
","2895611","","","","","2016-04-09 23:06:02","RXjs canceling debounce from source","<javascript><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"36523792","2","","36523248","2016-04-09 23:06:02","","7","","<p>I'd use something like this:</p>

<pre><code>var hoverStream = overStream.flatMapLatest(function() {
  return Rx.Observable.timer(500).takeUntil(outStream).map(function() { return 'hover'; })
});
</code></pre>

<p>This says ""map each overStream element into an observable that will yield a single element after 500ms, but stop listening if outStream yields an element before it arrives"". For this to work properly you'll need to remove the <code>debounce</code> from your overStream (and just keep it as a simple stream of all such events).</p>

<p>You could then merge the values into whatever result stream you wanted.</p>
","1855065","","","","","2016-04-09 23:06:02","","","","2","","","","CC BY-SA 3.0"
"36531605","1","36532435","","2016-04-10 15:24:39","","0","1770","<p>I'm trying to use some simple operators on a EventEmitter (from a FormModel.valueChanges) but I don't know how it's suppose to be done.</p>

<p>The class EventEmitter extends from Subject <br>
<code>export declare class EventEmitter&lt;T&gt; extends Subject&lt;T&gt;</code> <br>
so I tried several things:</p>

<p><code>this.patientForm.valueChanges.debounceTime(400)</code>
<code>this.patientForm.valueChanges.source.debounceTime(400)</code>
<code>this.patientForm.valueChanges.asObservable().debounceTime(400)</code>
<code>Observable.create(this.patientForm.valueChanges).debounceTime(400)</code></p>

<p>tried in the constructor and in ngOnInit <br>
the source is always undefined and the operators don't exist in the class.</p>

<p>I have this import <code>import {Observable} from 'rxjs';</code> could be something with that?</p>

<p>(what I'm trying to do is save the form state in a Redux store, but don't want to do it in every keystroke)</p>
","2958374","","","","","2016-04-10 16:34:05","How to use Observables operators with EventEmitter (FormModel.valueChanges) in Angular2","<angular><rxjs><angular2-forms><rxjs5>","2","1","","2016-04-10 16:34:42","","CC BY-SA 3.0"
"36532435","2","","36531605","2016-04-10 16:34:05","","2","","<p>As GÃ¼nter stated, operators aren't by default included</p>

<p>To import the <code>Observable</code> class, just use the following. In this case, you will have all the operators within the <code>Observable</code> class:</p>

<pre><code>import {Observable} from 'rxjs/Rx';
</code></pre>

<p>To only have the <code>debounceTime</code> operator, you could use this:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
import 'rxjs/add/operator/debounceTime';
</code></pre>

<p>Then the right way to use the <code>debounceTime</code> operator is:</p>

<pre><code>this.patientForm.valueChanges.debounceTime(400).subscribe((val) =&gt; {
  (...)
});
</code></pre>

<p>See this article for more details:</p>

<ul>
<li><a href=""https://jaxenter.com/reactive-programming-http-and-angular-2-124560.html"" rel=""nofollow"">https://jaxenter.com/reactive-programming-http-and-angular-2-124560.html</a></li>
</ul>
","1873365","","","","","2016-04-10 16:34:05","","","","1","","","","CC BY-SA 3.0"
"36577900","1","","","2016-04-12 15:34:39","","1","75","<p>I have the following scenario in an Angular 2 app:</p>

<ol>
<li>I have a list of items loaded async into a redux store when the app loads</li>
<li>A user navigates to a route that displays a single item</li>
</ol>

<p>What I'd like to implement using rxjs is if the item the user has requested is already in the store, then simply return it. Otherwise, make an HTTP call to load the specific item requested.</p>

<p>In many cases the item needed will already be in the store, but if they navigate directly into the CRUD page, then there's a chance it's being loaded, but just isn't there yet. If we're using paging, then it's possible it <em>won't</em> be there even if the items have finished loading. In either of those two cases I just want to make an HTTP call directly for the item.</p>

<p>I was hoping to use some sort of observable chain to check the store for the item, and if it's not there immediately, then flatMap using a angular2 http call that'll return the item.</p>

<p>Any I thinking about this right, and is there a simple set of operators that can do this?</p>
","571237","","","","","2016-04-12 15:34:39","Trying to implement a simple ""check the redux store first"" observable in RxJS 5","<angular><rxjs5>","0","0","","","","CC BY-SA 3.0"
"36581597","1","","","2016-04-12 18:47:35","","1","534","<p>is it somehow possible to make an rxjs observable with the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent"" rel=""nofollow"">fromEvent method</a> out of the <a href=""https://github.com/apache/cordova-plugin-network-information"" rel=""nofollow"">cordova network connection plugin</a>.</p>

<p>i am trying that with ionic 2.</p>

<p>i can see, that there are two events (online/offline) in the <a href=""https://github.com/apache/cordova-plugin-network-information"" rel=""nofollow"">cordova network connection plugin</a>. but how to hook into them with rxjs?</p>

<p>something that looks like that:</p>

<pre><code>const offline$ = Observable.fromEvent(CORDOVA_OFFLINE_EVENT);
offline$.subscribe(
    function (connectionType) {
        console.log(""connectionType"", JSON.stringify(connectionType));
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    }
);
</code></pre>
","4021204","","217408","","2016-04-13 14:53:56","2016-04-22 23:50:37","ionic 2 / rxjs5 / cordova network plugin event observable","<typescript><angular><ionic2><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36584711","2","","35683473","2016-04-12 21:50:01","","0","","<p>If you want to balance your requests you can use sample:
<code>
const newRequests = requestStream.sample(Observable.timer(75)); //10*60*60/500 = 72 --&gt; 75 to be sure
</code>
Sample will emit an element from the observable, when the given observable emits</p>
","3892684","","","","","2016-04-12 21:50:01","","","","0","","","","CC BY-SA 3.0"
"36612945","1","","","2016-04-14 02:44:03","","39","24293","<p>I want to create an observable that returns data from a webapi.  I'd like it to return the data immediately, and poll the API every 10 seconds.  The code below shows I'm using the 'interval' method.  But this delays the first set of data by 10 seconds.  How do I get that first flush of data to come down with no initial delay?</p>

<pre class=""lang-typescript prettyprint-override""><code>export class EventService {
    public events$: Observable&lt;Event[]&gt;;
    private _eventsObserver: Observer&lt;Event[]&gt;;
    private pollInterval: number = 5000;

    private _dataStore: {
        events: Event[];
    };

    constructor(private http: Http) {
        this._dataStore = { events: [] };

        this.events$ = new Observable(observer =&gt; this._eventsObserver = observer)
            .startWith(this._dataStore.events)
            .share();
    }

    pollEvents() {
        return Observable.interval(10000)
            .switchMap(() =&gt; {
                return this.http.get('app/resources/data/scheduleevents.json')
                    .map((responseData) =&gt; {
                        return responseData.json();
                    });
            })
            .map((events: Array&lt;any&gt;) =&gt; {
                let result: Array&lt;Event&gt; = [];
                if (events[""data""]) {
                    events[""data""].forEach((event) =&gt; {
                        result.push(event);
                    });
                }
                return result;
            });
    }
}
</code></pre>
","5460932","","3345644","","2018-04-19 20:02:03","2019-07-30 14:03:15","How to get an observable to return data immediately and every 5 seconds thereafter","<rxjs><rxjs5>","6","0","4","","","CC BY-SA 3.0"
"36613167","1","36613646","","2016-04-14 03:07:49","","10","2676","<p>I am using this tutorial <a href=""https://egghead.io/lessons/rxjs-creating-an-observable"" rel=""noreferrer"">https://egghead.io/lessons/rxjs-creating-an-observable</a> which is referencing 2.5.2 rxjs version. </p>

<p>I am referencing the latest <code>rx.umd.js</code> from <code>rxjs@5.0.0-beta.6""</code> npm package <code>&lt;script src=""node_modules/rxjs/bundles/rx.umd.js""&gt;&lt;/script&gt;</code>
And here is the code I am trying to run:</p>

<pre><code>console.clear();

var source = Rx.Observable.create(function(observer){
    setTimeout(function() {
        console.log('timeout hit');
        observer.onNext(42);
        observer.onCompleted();
    }, 1000);

    console.log('started');
});

var sub = source.subscribe(function(x) {
    console.log('next ' + x);
}, function(err) {
    console.error(err);
}, function() {
    console.info('done');
});

setTimeout(function() {
    sub.dispose()
}, 500);
</code></pre>

<p>Here is a console output I am getting.</p>

<pre><code>Console was cleared
script.js:10 started
script.js:22 Uncaught TypeError: sub.dispose is not a function
script.js:5 timeout hit
script.js:6 Uncaught TypeError: observer.onNext is not a function
</code></pre>

<p>plunker: <a href=""https://plnkr.co/edit/w1ZJL64b8rnA92PVuEDF?p=catalogue"" rel=""noreferrer"">https://plnkr.co/edit/w1ZJL64b8rnA92PVuEDF?p=catalogue</a></p>

<p>Is rxjs 5 api is much different from rxjs 2.5 and <code>observer.onNext(42);</code> and <code>sub.dispose()</code> is not longer supported?</p>
","2926340","","","","","2019-07-19 12:17:54","getting rxjs errors when referencing latest rxjs","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"36613646","2","","36613167","2016-04-14 03:59:43","","10","","<p>Update 2018/12:</p>

<p>RxJS v6.x introduced a new, more ""functional"" API. Take a look at the <a href=""https://rxjs-dev.firebaseapp.com/guide/v6/migration"" rel=""nofollow noreferrer"">5>6 migration guide</a> for more info. The original example code still works, but you'll have to import the <code>of</code> operator like so:</p>

<pre><code>// ESM
import { of } from 'rxjs'
// CJS
const { of } = require('rxjs');
</code></pre>

<hr>

<p>Original RxJS 5 answer:</p>

<p>That's right. RxJS 5 was rewritten to improve performance and also conform to the ES7 <code>Observable</code> spec. Check out the <a href=""https://github.com/ReactiveX/rxjs/blob/5.6.0-forward-compat.5/MIGRATION.md#subscription-dispose-is-now-unsubscribe"" rel=""nofollow noreferrer"">RxJS 4->5 migration page</a> on Github.</p>

<p>Here's a working example:</p>

<pre><code>// Create new observable
const one = Observable.of(1,2,3);

// Subscribe to it
const oneSubscription = one.subscribe({
    next: x =&gt; console.log(x),
    error: e =&gt; console.error(e),
    complete: () =&gt; console.log('complete')
});

// ""Dispose""/unsubscribe from it
oneSubscription.unsubscribe();
</code></pre>

<p>A lot of methods got renamed, but the API itself is very easy to transition to.</p>
","1690132","","1690132","","2018-12-01 08:47:22","2018-12-01 08:47:22","","","","1","","","","CC BY-SA 4.0"
"36613758","1","","","2016-04-14 04:13:38","","3","529","<p>I am trying to configure WebStorm to correctly type-hint RxJS 5, but it's not picking up methods on <code>Observable</code>:</p>

<p><a href=""https://i.stack.imgur.com/qxB9i.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qxB9i.png"" alt=""enter image description here""></a></p>

<p>You can see that both <code>.of()</code> and <code>.map()</code> are ""unresolved."" The code executes as expected. What am I missing?</p>
","1690132","","1690132","","2016-04-14 18:34:54","2017-11-28 08:32:16","How to configure RxJS5 typings in WebStorm 2016.1 for added Observable methods?","<webstorm><rxjs5>","0","2","1","","","CC BY-SA 3.0"
"36616165","1","36617337","","2016-04-14 07:15:01","","0","22","<p>Is there a difference between </p>

<pre><code>var source1 = Rx.Observable.of(42);
const oneSubscription = source1.subscribe({
     next: x =&gt; console.log(x)
});
oneSubscription.unsubscribe();
</code></pre>

<p>and</p>

<pre><code>var source2 = Rx.Observable.of(42);
source2.forEach(x =&gt; console.log(x));
</code></pre>

<p>I thought that to create a promise you have to subscribe for it first.</p>

<p>But in case of <code>source2</code> the thing is just working without subscribing.</p>

<p>May be someone ca explain.</p>
","2926340","","","","","2016-04-14 08:16:56","Difference how to access the promise","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36617337","2","","36616165","2016-04-14 08:16:56","","2","","<p>That is because <code>forEach</code> internally subscribes as well.</p>

<pre><code>/**
*  Subscribes an o to the observable sequence.
*  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.
*  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
*  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
*  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
*/
forEach(observer: IObserver&lt;T&gt;): IDisposable;
</code></pre>
","1475346","","","","","2016-04-14 08:16:56","","","","3","","","","CC BY-SA 3.0"
"36654920","1","36656026","","2016-04-15 18:58:34","","10","2425","<p>I want to make a call to a server that can return an authorization fail (401) with Angular2's HTTP class.</p>

<p>The flow of the request should look like that:</p>

<ul>
<li>The user makes a request to the server with myService.getSomething().subscribe()</li>
<li>If the server returns a 401: open a modal window asking the user for his credentials.</li>
<li>The user successfully log back into the application</li>
<li>The modal closes and executes a callback</li>
<li>The callback should retry the initial request (myService.getSomething().subscribe())</li>
</ul>

<p>Here is what I have for the moment:</p>

<pre><code>export class MyService {
    // ...
    public getSomething(): Observable&lt;Response&gt; {
        return this.http.get(url, options).catch((res: any, ob: any) =&gt; this.errorHandler(res, ob));
    }

    public errorHandler(res: Response, ob: Observable&lt;any&gt;): Observable&lt;Response&gt; {
        if (res.status === 401) {
            this.modalService.open(new ModalConfig({
                content: LoginModalComponent,
                close: () =&gt; { ob.retry(1); console.log(""weow"") } // &lt;=close is the callback that should initiate the retry action on the initial request.
            }));
        }
        else {
            return Observable.throw(res.json());
        }
    }
}
</code></pre>

<p>doSomething() is used like that: <code>doSomething().map((r) =&gt; r.json()).subscribe((r) =&gt; ....)</code></p>

<p><strong>Update 1</strong></p>

<p>I modified my code to look like @Thierry Templier's solution.</p>

<pre><code>private errorHandler(res: Response, ob: Observable&lt;any&gt;): Observable&lt;Response&gt; {
    if (res.status === 401) {
        let closedSubject = new Subject();
        this.modalService.open(new ModalConfig({
            content: LoginModalComponent,
            close: () =&gt; { closedSubject.next(res);} // I also tried .complete(), .next(null), .next(true), .next(false)
        }));
        return ob.retryWhen(() =&gt; closedSubject);
    }
    else {
        return Observable.throw(res.json());
    }
}
</code></pre>

<p>Sadly it still doesn't work. The retryWhen is executed right away and doesn't wait for closedSubject.next() to be called. Therefore it starts an infinite loop, spamming the original Observable (the getSomething() function).</p>

<p><strong>Update 2</strong></p>

<p>I created a plunker to demonstrate the infinite loop:</p>

<p><a href=""https://plnkr.co/edit/8SzmZlRHvi00OIdA7Bga"" rel=""noreferrer"">https://plnkr.co/edit/8SzmZlRHvi00OIdA7Bga</a></p>

<p>Warning: running the plunker will spam your console with the string 'test'</p>

<p><strong>Update 3</strong></p>

<p>Following Thierry's correct answer, I tried to find a way to not use the source field since it is protected. After asking on rxjs's issue tracker to make the field public, a contributor replied with a better solution.</p>

<pre><code>public get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    return super.get(url, options).retryWhen((errors: any) =&gt; this.errorHandler(errors));
}
private errorHandler(errors): any {
    return errors.switchMap((err) =&gt; {
        if (err.status === 401) {
            let closedSubject = new Subject();
            this.modalService.open(new ModalConfig({
                content: LoginModalComponent,
                close: () =&gt; { closedSubject.next(err); }
            }));
            return &lt;any&gt;closedSubject;
        }
        else {
            return Observable.throw(err.json());
        }
    });
}
</code></pre>

<p>I avoid using .catch so I don't have to use the source field.</p>
","613568","","613568","","2016-04-19 13:32:17","2019-10-30 19:20:02","How to catch an error on a Request, then open a modal, then retry when modal closes with RxJS","<javascript><typescript><angular><rxjs><rxjs5>","3","1","6","","","CC BY-SA 3.0"
"36656026","2","","36654920","2016-04-15 20:11:09","","9","","<p>I think that you need to return something an observable even in the case of the 401 error:</p>

<pre><code>public errorHandler(res: Response, ob: Observable&lt;any&gt;): Observable&lt;Response&gt; {
    if (res.status === 401) {
        let closedSubject = new Subject();
        this.modalService.open(new ModalConfig({
            content: LoginModalComponent,
            close: () =&gt; {
              closedSubject.next();
        }));
        return ob.retryWhen(() =&gt; closedSubject);
    }
    else {
        return Observable.throw(res.json());
    }
}
</code></pre>

<p>See this article for more details: <a href=""https://jaxenter.com/reactive-programming-http-and-angular-2-124560.html"" rel=""noreferrer"">https://jaxenter.com/reactive-programming-http-and-angular-2-124560.html</a>.</p>

<p><strong>Edit</strong></p>

<p>The problem is that the second parameter of the <code>catch</code> callback isn't the source observable. This source observable corresponds to the value of its <code>source</code> property:</p>

<pre><code>return ob.source.retryWhen((errors) =&gt; closedSubject);
</code></pre>

<p>See the working plunkr: <a href=""https://plnkr.co/edit/eb2UdF9PSMhf4Dau2hqe?p=preview"" rel=""noreferrer"">https://plnkr.co/edit/eb2UdF9PSMhf4Dau2hqe?p=preview</a>.</p>
","1873365","","1873365","","2016-04-18 20:11:57","2016-04-18 20:11:57","","","","6","","","","CC BY-SA 3.0"
"36673287","1","36673406","","2016-04-17 06:14:25","","4","514","<p>I am using Angular 2.</p>

<p>When I have only one element, I can use <code>nativeElement</code> first and then use <code>Observable</code>.</p>

<pre><code>&lt;div #aaa&gt;&lt;/div&gt;

@ViewChild('aaa') private aaa: ElementRef;
ngAfterViewInit() {
  console.log(Observable.fromEvent(this.aaa.nativeElement), 'mouseenter');
}
</code></pre>

<p>But now I have a list, I cannot use same way to do it:</p>

<pre><code>&lt;a *ngFor=""#user of users"" #aaa (mouseenter)=""mouseEnter($event, user)""&gt;
  {{user}}
&lt;/a&gt;

@ViewChild('aaa') private aaa: ElementRef;
ngAfterViewInit() {
  console.log(Observable.fromEvent(this.aaa.nativeElement), 'mouseenter');
}
</code></pre>

<p>It will show the error:</p>

<blockquote>
  <p>EXCEPTION: TypeError: Cannot read property 'nativeElement' of null</p>
</blockquote>

<p>When the mouses move into each element, I want it does different things using Observable. How can I correctly use Observable in this case? </p>
","2000548","","","","","2016-04-18 04:55:21","How to use Observable correctly in a list?","<typescript><angular><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"36673406","2","","36673287","2016-04-17 06:32:29","","5","","<p>In terms of how to do what you're trying to do here, I would suggest: </p>

<pre><code>@Component({
  template: `
    &lt;a *ngFor=""#user of users"" (mouseenter)=""mouseEnters$.next({event: $event, user: user})""&gt;
    {{user}}
  &lt;/a&gt;
  `
})
class YourComponent { 
   mouseEnters$: Subject&lt;data:{event: MouseEvent, user: any}&gt; = BehaviorSubject.create();

   ngAfterViewInit(){ //you don't actually need to wait for afterViewInit anymore
       this.mouseEnters$.subscribe((data:{event:MouseEvent, user: any}) =&gt; /* do whatever */)
   }
}
</code></pre>

<p>In terms of why you're getting the exception you're getting - you can't put a template variable on an element with <code>ngFor</code> on it (which makes sense when you realize that the element is repeated...), and consequently the <code>@ViewChild</code> is null.</p>
","1988693","","1988693","","2016-04-18 04:55:21","2016-04-18 04:55:21","","","","13","","","","CC BY-SA 3.0"
"36701041","1","36701060","","2016-04-18 17:54:46","","31","32734","<p>I am using Angular 2.</p>

<p>When I use either of these two, my program runs well:</p>

<pre><code>import { BehaviorSubject } from 'rxjs/Rx';
import { BehaviorSubject } from 'rxjs';
</code></pre>

<p>However, I try to use the following way:</p>

<pre><code>import { BehaviorSubject } from 'rxjs/subject/BehaviorSubject';
</code></pre>

<p>But I failed, my browser console shows:</p>

<blockquote>
  <p>Uncaught Error: Cannot find module 'rxjs/subject/BehaviorSubject'</p>
</blockquote>

<p>How can I use third way correctly? Thanks</p>
","2000548","","2000548","","2016-04-18 18:09:17","2018-07-21 06:24:19","Cannot find module 'rxjs/subject/BehaviorSubject'","<typescript><angular><rxjs><rxjs5>","1","4","4","","","CC BY-SA 3.0"
"36701060","2","","36701041","2016-04-18 17:55:56","","82","","<pre><code>import {BehaviorSubject} from 'rxjs/BehaviorSubject';
</code></pre>

<p><strong>rxjs 6.x</strong></p>

<pre><code>import {BehaviorSubject} from 'rxjs';
</code></pre>

<p>See also</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/38067580/property-of-does-not-exist-on-type-typeof-observable/38067643#38067643"">Property &#39;of&#39; does not exist on type &#39;typeof Observable</a></li>
<li><a href=""https://stackoverflow.com/a/49665105/3232832"">https://stackoverflow.com/a/49665105/3232832</a></li>
</ul>
","217408","","217408","","2018-07-21 06:24:19","2018-07-21 06:24:19","","","","9","","","","CC BY-SA 4.0"
"36711126","1","36712498","","2016-04-19 07:15:39","","0","455","<p>I am getting an error when page is getting loaded saying </p>

<pre><code>people.ts?9320:22 SyntaxError: Unexpected token 
&lt;(â¦)PeopleComponent.apiService.people.subscribe.error @ people.ts?
9320:22SafeSubscriber.__tryOrUnsub @ VM38600:166SafeSubscriber.error @ 
VM38600:127Subscriber._error @ VM38600:77Subscriber.error @ 
VM38600:57MapSubscriber._next @ VM38955:51Subscriber.next @ 
VM38600:51onLoad @ VM38808:57ZoneDelegate.invokeTask @ 
VM38526:423NgZoneImpl.inner.inner.fork.onInvokeTask @ 
VM38628:36ZoneDelegate.invokeTask @ VM38526:422Zone.runTask @ 
VM38526:320ZoneTask.invoke @ VM38526:490
</code></pre>

<p>Here is my code:</p>

<pre><code>export class PeopleComponent {
    people: any;
    constructor(apiService: Api) {
        apiService.people
            .subscribe({
                next: x =&gt; (this.people = x),
                error: e =&gt; console.error(e), //error line 22 is here!
                complete: () =&gt; console.log('Completed!')
            });
    }
}
</code></pre>

<p>My Api sevice:</p>

<pre><code>import {Injectable} from 'angular2/core';
import { Http } from 'angular2/http';

@Injectable()
export class Api {
  people: any;

  constructor(http: Http) {
    this.people = http.get(require('./people.json'))
      .map(response =&gt; response.json());
  }
}
</code></pre>

<p>Any thoughts?</p>
","2926340","","2926340","","2016-04-19 08:12:04","2016-04-19 08:16:30","Getting error when subscribing to promise","<angular><rxjs5>","1","3","","","","CC BY-SA 3.0"
"36712498","2","","36711126","2016-04-19 08:16:30","","2","","<p>You could try to subscribe this way:</p>

<pre><code>apiService.people
      .subscribe(
        x =&gt; {this.people = x;},
        e =&gt; {console.error(e);},
        () =&gt; {console.log('Completed!');}
      });
</code></pre>

<p>See this documentation:</p>

<ul>
<li><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md"" rel=""nofollow"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md</a></li>
</ul>
","1873365","","","","","2016-04-19 08:16:30","","","","6","","","","CC BY-SA 3.0"
"36714852","1","","","2016-04-19 09:52:46","","0","68","<p>I'm trying to migrate a project from Angular2 <strong>beta1</strong> to Angular2 <strong>beta15</strong> and I have some issues.</p>

<p>I have error message : <strong>'map' property does not exists on 'Observable&lt; Response >'</strong></p>

<p>Example of code with this error :</p>

<pre><code>import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { HelperModule } from './helpers.module';
import { BlogPost } from './model';
import 'rxjs/add/operator/map';

/**
 * Service dealing with blog data
 */
@Injectable()
export class DataService {

    constructor(private http: Http) { }

    /**
     * Call API to list available blog posts
     */
    listBlogPosts() {
        return this.http.get(HelperModule.UrlBuilder.BuildPostListUrl()).map(res =&gt; (&lt;Response&gt;res).json());
    }

}
</code></pre>

<p>Code is available here : <a href=""https://github.com/AdrienTorris/AspNet5Angular2Playground"" rel=""nofollow"">https://github.com/AdrienTorris/AspNet5Angular2Playground</a></p>

<p>EDIT : I'm using <em>rxjs 5.0.0-beta6</em> and <em>typescript 1.8.10</em>, targetting <em>es6</em></p>
","4428633","","4428633","","2016-04-19 09:56:41","2016-04-19 20:21:47","Migration from Angular2 beta1 to Angular2 beta15 - .map() error","<typescript><angular><rxjs><rxjs5><typescript1.8>","2","1","","","","CC BY-SA 3.0"
"36728398","1","","","2016-04-19 20:06:51","","2","1112","<p>I need to cache the result of a request on the first call then read the cached value for subsequent calls.</p>

<p>To achieve that goal, I am using promises and I am chaining them. I have a working solution but I would like to convert it to RxJS's observables instead of Promises.</p>

<p>Here is my working solution:</p>

<pre><code>private currentPromise: Promise&lt;{ [key: string]: any }&gt;;
private cache: any;
public getSomething(name: string): Promise&lt;number&gt;{
  return this.currentPromise = !this.currentPromise ? 
    this._getSomething(name) : 
    new Promise((r) =&gt; this.currentPromise.then(() =&gt; this._getSomething(name).then((res) =&gt; r(res))));
}

private _getSomething(name: string): Promise&lt;any&gt; {
  return new Promise((resolve) =&gt; {
    if (this.cache[name]) {
      this.messages.push(""Resolved from cache"");
        resolve(this.cache[name]);
      } else {
        // Fake http call. I would use Angular's Http class.
        setTimeout(()=&gt; {this.messages.push(""Resolved from server""); this.cache[name] = name; resolve(this.cache[name]); }, 2000 );
      }
  });
}

this.getSomething(""thing1"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing1"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing2"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing2"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing1"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing2"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing1"").then((res)=&gt;this.messages.push(res));
this.getSomething(""thing2"").then((res)=&gt;this.messages.push(res));
</code></pre>

<p>You can test it on this plunkr: <a href=""https://plnkr.co/edit/j1pm2GeQf6oZwRvbUsXJ?p=preview"" rel=""nofollow"">https://plnkr.co/edit/j1pm2GeQf6oZwRvbUsXJ?p=preview</a></p>

<p>How do I achieve the same thing with RxJS 5 beta?</p>

<p><strong>Update</strong></p>

<p>Following Bergi's comments I updated my plunkr and my code to bring it closer to my real case</p>
","613568","","613568","","2016-04-19 21:09:43","2016-04-20 17:02:08","How to dynamically chain function calls using RXJS?","<javascript><typescript><promise><rxjs><rxjs5>","1","8","","","","CC BY-SA 3.0"
"36733650","1","36734360","","2016-04-20 04:09:40","","1","224","<p>I am using Angular 2.</p>

<p>Right now I know this way to select a DIV item:</p>

<pre><code>&lt;div #aaa&gt;
&lt;/div&gt;

@ViewChild('aaa') private aaa: ElementRef;
ngAfterViewInit() {
  let item = this.aaa.nativeElement;
  item.style.top = '10px';
}
</code></pre>

<p>Is there a RxJS Observable way to select that item, then do something like <code>item.style.top = '10px';</code>? Thanks</p>
","2000548","","2000548","","2016-04-20 04:19:40","2016-04-20 05:11:27","How to use RxJS Observable way to select a DIV?","<typescript><angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"36734360","2","","36733650","2016-04-20 05:11:27","","1","","<p>What about</p>

<pre><code>&lt;div [style.top.px]=""someProp""&gt;&lt;/div&gt;

someMethod() {
  this.someProp = 10;
}
</code></pre>
","217408","","","","","2016-04-20 05:11:27","","","","4","","","","CC BY-SA 3.0"
"36753392","1","","","2016-04-20 19:29:27","","2","782","<p>In the following code, I create a simple observable that produces one value and then complete. Then I share that observable replaying the last item and suscribe 3 times. The first right after, the second one before the value is produced and the third time after value is produced and the observable has completed.</p>

<pre><code>let i = 0;
let obs$ = Rx.Observable.create(obs =&gt; {
  console.log('Creating observable');
  i++;
  setTimeout(() =&gt; {
     obs.onNext(i);
     obs.onCompleted();
  }, 2000);
}).shareReplay(1);

obs$.subscribe(
  data =&gt; console.log(`s1: data = ${data}`),
  () =&gt; {},
  () =&gt; console.log('finish s1')
);

setTimeout( () =&gt; {
  obs$.subscribe(
    data =&gt; console.log(`s2: data = ${data}`),
    () =&gt; {},
    () =&gt; console.log('finish s2')

  );  
}, 1000);

setTimeout( () =&gt; {
  obs$.subscribe(
    data =&gt; console.log(`s3: data = ${data}`),
    () =&gt; {},
    () =&gt; console.log('finish s3')

  );  
}, 6000);
</code></pre>

<p>You can <a href=""http://jsbin.com/vuzinihono/2/edit?js,console"" rel=""nofollow"">execute this on jsbin</a></p>

<p>This results in the following marble diagram</p>

<pre><code>Actual
s1: -----1$
s2:   \--1$
s3:           \1$
</code></pre>

<p>But I would expect </p>

<pre><code>Expected
s1: -----1$
s2:   \--1$
s3:           \----2$
</code></pre>

<p>I can understand why someone would like to have the first behaviour, but my reasoning is that, unlike this example, where I'm returning a number, I could be returning an object susceptible to unsubscribe behaviour, for example a database connection. If the above marble diagram represents a database connection, where in the dispose method I call a <code>db.close()</code>, on the third subscription I would have an exception, because I'm receiving as value a database handler that was released. (because when the second subscription finished refCount = 0 and the source is disposed).</p>

<p>Also another weird thing this example has, is that even it's resolving with 
the first value and completing just after, its subscribing to the source twice (as you can see by the duplicated ""Creating observable"")</p>

<p>I know <a href=""https://github.com/ReactiveX/rxjs/issues/453"" rel=""nofollow"">this github issue</a> talks about this but what I'm missing is:</p>

<p>How can achieve (both in RxJs4 and 5) a shared observable that can replay the last item if the source observable hasn't completed, and if its done (refCount = 0), recreate the observable.</p>

<p>In RxJs5 I think the share method solves the reconnecting part of my problem, but not the sharing part.</p>

<p>In RxJs4 I'm clueless</p>

<p>If possible I would like to solve this using existing operators or subjects. My intuition tells me I would have to create a different Subject with such logic, but I'm not quite there yet.</p>
","832361","","832361","","2016-04-22 15:29:07","2016-04-22 17:04:42","How can I achieve a shareReplay with reconnection?","<javascript><reactive-programming><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"36759582","1","","","2016-04-21 04:19:39","","0","740","<p>I am using <code>@ngrx/store</code> and I am grabbing a slice of the state from the store.</p>

<p>I have a component that wants to display that slice. However, with the <code>{{ obs$ | async}}</code> present in the template, the entire template is not rendered. If I remove the <code>{{ obs$ | async }}</code> then <code>SLICE:</code> is rendered.</p>

<p>Any idea on why this is the case or how to diagnose the issue? The JS console isn't showing me any errors.</p>

<pre><code>@Component({
  selector: 'slice',
  template: `SLICE: {{ obs$ | async }}
})
export class Slice {
  obs$: Observable&lt;any&gt;
  constructor(private store:Store&lt;any&gt;) {
    this.obs$ = this.store.select(s =&gt; s.slice);
  }
}
</code></pre>
","1392862","","","","","2016-04-21 07:02:27","angular2 viewing observable with async pipe not rendering","<angular><rxjs5>","1","7","","","","CC BY-SA 3.0"
"36812714","1","36815231","","2016-04-23 15:30:03","","10","15685","<p>I am trying to display server-sent events emitted values in an angular 2 /RxJs app.</p>

<p>The backend regularly sends individual strings to the client through server-sent events.</p>

<p>I am not sure how to deal with the retrieved values on the angular 2/RxJs side.</p>

<p>Here is my client (a ng component):</p>

<pre><code>import {Component, OnInit} from 'angular2/core';
import {Http, Response} from 'angular2/http';
import 'rxjs/Rx';
import {Observable}     from 'rxjs/Observable';

@Component({
    selector: 'my-app',
    template: `&lt;h1&gt;My second Angular 2 App&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li *ngFor=""#s of someStrings | async""&gt;
           a string: {{ s }}
        &lt;/li&gt;
    &lt;/ul&gt;
    `
})
export class AppComponent implements OnInit {

    constructor(private http:Http) {
    }

    errorMessage:string;
    someStrings:string[];

    ngOnInit() {
        this.getSomeStrings()
            .subscribe(
                aString =&gt; this.someStrings.push(aString),
                error =&gt; this.errorMessage = &lt;any&gt;error);
    }

    private getSomeStrings():Observable&lt;string&gt; {
        return this.http.get('interval-sse-observable')
            .map(this.extractData)
            .catch(this.handleError);
    }

    private extractData(res:Response) {
        if (res.status &lt; 200 || res.status &gt;= 300) {
            throw new Error('Bad response status: ' + res.status);
        }
        let body = res.json();
        return body || {};
    }

    private handleError(error:any) {
        // In a real world app, we might send the error to remote logging infrastructure
        let errMsg = error.message || 'Server error';
        console.error(errMsg); // log to console instead
        return Observable.throw(errMsg);
    }
}
</code></pre>

<p>The backend method is as follows (and uses RxJava):</p>

<pre><code>   @ResponseStatus(HttpStatus.OK)
   @RequestMapping(method = RequestMethod.GET, path = ""interval-sse-observable"")
    public SseEmitter tickSseObservable() {
        return RxResponse.sse(
                Observable.interval(5, TimeUnit.SECONDS, Schedulers.io())
                        .map(tick -&gt; randomUUID().toString())
        );
    }
</code></pre>

<p>I just noticed that the app hangs on the request and that nothing is displayed on the page.</p>

<p>I suspect there is an issue with my use of the map method i.e. <code>.map(this.extractData)</code>.</p>

<p>I would just like to add the incoming strings to the array and display that array in the template which would update as the strings come in.</p>

<p>Can anyone please help?</p>

<p><strong>edit</strong>: Here is a working solution (thanks to Thierry's answer below):</p>

<pre><code>import {Component, OnInit} from 'angular2/core';
import 'rxjs/Rx';

@Component({
    selector: 'my-app',
    template: `&lt;h1&gt;My second Angular 2 App&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li *ngFor=""#s of someStrings""&gt;
           a string: {{ s }}
        &lt;/li&gt;
    &lt;/ul&gt;
    `
})
export class AppComponent implements OnInit {

    someStrings:string[] = [];

    ngOnInit() {
        let source = new EventSource('/interval-sse-observable');
        source.addEventListener('message', aString =&gt; this.someStrings.push(aString.data), false);
    }
}
</code></pre>
","536299","","536299","","2016-04-24 08:46:19","2018-08-24 15:09:56","Using RxJs and Angular 2 in order to deal with server-sent events","<angular><server-sent-events><rxjs5>","3","1","5","","","CC BY-SA 3.0"
"36815231","2","","36812714","2016-04-23 19:10:01","","10","","<p>You can't use the Http class of Angular2 to handle server side events since it's based on the XHR object.</p>

<p>You could leverage the EventSource object:</p>

<pre><code>var source = new EventSource('/...');
source.addListener('message', (event) =&gt; {
  (...)
});
</code></pre>

<p>See these articles:</p>

<ul>
<li><a href=""https://dzone.com/articles/html5-server-sent-events"" rel=""noreferrer"">https://dzone.com/articles/html5-server-sent-events</a></li>
<li><a href=""http://www.nurkiewicz.com/2015/07/server-sent-events-with-rxjava-and.html?m=1"" rel=""noreferrer"">http://www.nurkiewicz.com/2015/07/server-sent-events-with-rxjava-and.html?m=1</a></li>
</ul>
","1873365","","217408","","2016-04-23 20:03:39","2016-04-23 20:03:39","","","","1","","","","CC BY-SA 3.0"
"36827270","1","36827897","","2016-04-24 18:36:25","","8","13258","<p>I would like to create a RxJs Observable from an EventSource (server sent events).</p>

<p>I tried the following:</p>

<pre><code>import {Component, OnInit} from 'angular2/core';
import {Subject, Observable}  from 'rxjs/Rx';

@Component({
    selector: 'my-app',
    template: `&lt;h1&gt;My second Angular 2 App&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li *ngFor=""#s of someStrings""&gt;
           a string: {{ s }}
        &lt;/li&gt;
    &lt;/ul&gt;
    `
})
export class AppComponent implements OnInit {

    someStrings:string[] = [];

    ngOnInit() {
        let eventSource = new EventSource('/interval-sse-observable');
        let observable = Observable.create(eventSource);
        observable.subscribe({
            next: aString =&gt; this.someStrings.push(aString.data),
            error: err =&gt; console.error('something wrong occurred: ' + err)
        });
    }
}
</code></pre>

<p>But I get the following exception:</p>

<pre><code>EXCEPTION: Error: Uncaught (in promise): EXCEPTION: TypeError: this._subscribe is not a function in [null]
ORIGINAL EXCEPTION: TypeError: this._subscribe is not a function
ORIGINAL STACKTRACE:
TypeError: this._subscribe is not a function
    at Observable.subscribe (https://cdnjs.cloudflare.com/ajax/libs/angular.js/2.0.0-beta.15/Rx.js:11210:29)
    at AppComponent.ngOnInit (http://localhost:8080/scripts/app.component.ts!transpiled:30:28)
    at AbstractChangeDetector.ChangeDetector_HostAppComponent_0.detectChangesInRecordsInternal (viewFactory_HostAppComponent:21:99)
    at AbstractChangeDetector.detectChangesInRecords (https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js:9689:14)
    at AbstractChangeDetector.runDetectChanges (https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js:9672:12)
    at AbstractChangeDetector.detectChanges (https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js:9661:12)
    at ChangeDetectorRef_.detectChanges (https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js:5280:16)
    at https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js:13048:27
    at Array.forEach (native)
    at ApplicationRef_.tick (https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js:13047:34)
</code></pre>

<p>For completeness' sake, here is the contents of my index.html:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
&lt;head&gt;
    &lt;meta charset=""UTF-8""&gt;
    &lt;title&gt;sse demo&lt;/title&gt;
    &lt;!-- 1. Load libraries --&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/angular.js/2.0.0-beta.15/angular2-polyfills.js""&gt;&lt;/script&gt;
    &lt;script src=""https://code.angularjs.org/tools/system.js""&gt;&lt;/script&gt;
    &lt;script src=""https://code.angularjs.org/tools/typescript.js""&gt;&lt;/script&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/angular.js/2.0.0-beta.15/Rx.js""&gt;&lt;/script&gt;
    &lt;script src=""https://code.angularjs.org/2.0.0-beta.15/angular2.dev.js""&gt;&lt;/script&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/angular.js/2.0.0-beta.15/http.dev.js""&gt;&lt;/script&gt;

    &lt;!-- 2. Configure SystemJS --&gt;
    &lt;script&gt;
        System.config({
            transpiler: 'typescript',
            typescriptOptions: { emitDecoratorMetadata: true }
        });
        System.import('./scripts/app.ts')
                .then(null, console.error.bind(console));
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;my-app&gt;Loading...&lt;/my-app&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Can someone please help?</p>

<p><strong>edit 1</strong>: Following Yurzui's advice, I modified my code as follows:</p>

<pre><code>ngOnInit() {
    let observable = Observable.create(observer =&gt; {
        const eventSource = new EventSource('/interval-sse-observable');
        eventSource.onmessage = x =&gt; observer.next(console.log(x));
        eventSource.onerror = x =&gt; observer.error(console.log('EventSource failed'));

        return () =&gt; {
            eventSource.close();
        };
    });
    observable.subscribe({
        next: aString =&gt; this.someStrings.push(aString.data),
        error: err =&gt; console.error('something wrong occurred: ' + err)
    });
}
</code></pre>

<p>It does log the first message in the console as follows:</p>

<pre><code>MessageEvent {isTrusted: true, data: ""c374a15b-b37d-498e-8ab0-49643b79c1bb"", origin: ""http://localhost:8080"", lastEventId: """", source: nullâ¦}bubbles: falsecancelBubble: falsecancelable: falsecurrentTarget: EventSourcedata: ""c374a15b-b37d-498e-8ab0-49643b79c1bb""defaultPrevented: falseeventPhase: 0isTrusted: trueisTrusted: truelastEventId: """"origin: ""http://localhost:8080""path: Array[0]ports: nullreturnValue: truesource: nullsrcElement: EventSourcetarget: EventSourcetimeStamp: 6257.125type: ""message""__proto__: MessageEvent
Rx.js:10982 Uncaught TypeError: Cannot read property 'data' of undefinedSystem.register.exports_1.execute.AppComponent.ngOnInit.observable.subscribe.next @ app.component.ts:29SafeSubscriber.__tryOrUnsub @ Rx.js:10979SafeSubscriber.next @ Rx.js:10934Subscriber._next @ Rx.js:10894Subscriber.next @ Rx.js:10871System.register.exports_1.execute.AppComponent.ngOnInit.Rx_1.Observable.create.eventSource.onmessage @ app.component.ts:21
</code></pre>

<p>Now if instead of logging the <code>x</code> variable in the console I just pass it to the next method as follows:</p>

<pre><code>eventSource.onmessage = x =&gt; observer.next(x);
</code></pre>

<p>The server sent events are retrieved by the client (I see them in the chrome dev tools) but nothing is displayed in the template indicating the array of strings is not populated...</p>

<p>By the way I had to remove the <code>JSON.parse(x.data)</code> as it was causing an error.</p>
","536299","","536299","","2016-04-24 20:06:01","2019-07-31 13:22:34","Creating an RxJS Observable from a (server sent) EventSource","<typescript><angular><rxjs5><eventsource>","2","1","5","","","CC BY-SA 3.0"
"36827897","2","","36827270","2016-04-24 19:30:51","","17","","<p>You could use the following code to manually create Observable for EventSource stream:</p>

<pre><code>export class AppComponent implements OnInit {
  someStrings:string[] = [];

  constructor(private zone: NgZone) {}

  ngOnInit(){
    const observable = Observable.create(observer =&gt; {
      const eventSource = new EventSource('/interval-sse-observable');
      eventSource.onmessage = x =&gt; observer.next(x.data);
      eventSource.onerror = x =&gt; observer.error(x);

      return () =&gt; {
        eventSource.close();
      };
    });

    this.subscription = observable.subscribe({
      next: guid =&gt; {
        this.zone.run(() =&gt; this.someStrings.push(guid));
      },
      error: err =&gt; console.error('something wrong occurred: ' + err)
    });
  }
}

// somewhere
// this.subscription.unsubscribe()
</code></pre>

<p>Don't forget to import the NgZone class:</p>

<pre><code>import {Component, OnInit, NgZone} from '@angular/core';
</code></pre>

<p>See also <a href=""https://stackoverflow.com/questions/31706948/angular2-view-not-changing-after-data-is-updated/31781009#31781009"">Angular2 View Not Changing After Data Is Updated</a></p>
","5485167","","5485167","","2018-02-04 05:46:59","2018-02-04 05:46:59","","","","7","","","","CC BY-SA 3.0"
"36855367","1","36856886","","2016-04-26 04:38:34","","2","851","<p>I'm trying to do something basic, but it's completely eluding me. I'm trying to create an <code>Observable</code> from <code>rxjx/observable/dom/webSocket</code> in <a href=""https://github.com/ReactiveX/rxjs"" rel=""nofollow"">RxJS5</a>, but I'm not using typescript, or es6 modules... just plain 'ole good commonJS.  I've managed to patch the Observable properly according to the docs, but whenever I try to pass in the string expected for the subject, I get the error:</p>

<p><code>no WebSocket constructor can be found</code>, <a href=""https://github.com/ReactiveX/rxjs/blob/fd0823b99db92d1e214052ad506904b0d744d494/src/observable/dom/WebSocketSubject.ts#L52-L68"" rel=""nofollow"">[source]</a>.</p>

<p>I haven't had time to dig into TypeScript yet, but from what I can tell, I've satisfied the conditions of the constructor, and I've also taken a look at the test spec, and <a href=""https://github.com/ReactiveX/rxjs/blob/fd0823b99db92d1e214052ad506904b0d744d494/spec/observables/dom/webSocket-spec.ts#L34"" rel=""nofollow"">they use the function in the same way</a> <code>Observable.webSocket('ws://host:port');</code> I'm trying to, but I <em>still</em> get an error.</p>

<p>I've tried:</p>

<pre><code>var Rx = require('rxjs/Rx');
require('rxjs/Rx.dom').webSocketSubject; //also tried just using `.webSocket`

var source = Rx.Observable.webSocket('ws://localhost:53311');

source.subscribe();
</code></pre>

<p>I've also tried passing an object to <code>Rx.Observable.webSocket</code>:</p>

<pre><code>var source = Rx.Observable.webSocket({
  url: 'ws://host:port'
});
</code></pre>

<p>Can anyone help me figure out how to use the <code>webSocket</code> Observable that's <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/add/observable/dom/webSocket.ts"" rel=""nofollow"">available via rxjs5</a>, when consuming from commonJS? (node v5.11)</p>
","1106939","","","","","2016-04-26 06:28:34","rxjs5 - no WebSocket constructor can be found","<typescript><commonjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36856886","2","","36855367","2016-04-26 06:28:34","","2","","<p>This isn't about TypeScript, you may need provide constructor to websocket to WebSocketSubject. </p>

<p>In test case, <a href=""https://github.com/ReactiveX/rxjs/blob/fd0823b99db92d1e214052ad506904b0d744d494/spec/observables/dom/webSocket-spec.ts#L14"" rel=""nofollow"">https://github.com/ReactiveX/rxjs/blob/fd0823b99db92d1e214052ad506904b0d744d494/spec/observables/dom/webSocket-spec.ts#L14</a> specifies it in root to globally override websocket, while it's also possible to provide it as config object like </p>

<pre><code>var ws = require('websocket');

socket = new WebSocketSubject({
  url: 'ws://....',
  WebSocketCtor: ws.w3cwebsocket
});
</code></pre>

<p>Even required in TypeScript or ES15 RxJS module as well.</p>
","2742189","","","","","2016-04-26 06:28:34","","","","2","","","","CC BY-SA 3.0"
"36863333","1","36864628","","2016-04-26 11:15:40","","4","3555","<p>I am trying to convert a plain <code>string[]</code> into a <code>Observable&lt;string[]&gt;</code> and concat it to an existing <code>Observable&lt;string[]&gt;</code>.</p>

<p>I will then use an angular2 <code>async</code> pipe in order to display the <code>Observable</code>.</p>

<p>Here is my code:</p>

<pre><code>import {Injectable} from ""angular2/core"";
import {Observable} from ""rxjs/Observable"";
import 'rxjs/Rx';


@Injectable()
export class AppService {

    constructor() {
        console.log('constructor', 'appService');
        this.constructSomeObservable();
    }

    someObservable$:Observable &lt;string[]&gt;;

    constructSomeObservable() {
        this.someObservable$ = Observable.create(observer =&gt; {
            const eventSource = new EventSource('/interval-sse-observable');
            eventSource.onmessage = x =&gt; observer.next(JSON.parse(x.data));
            eventSource.onerror = x =&gt; observer.error(console.log('EventSource failed'));
            return () =&gt; {
                eventSource.close();
            };
        });

        this.someObservable$.subscribe(
            theStrings=&gt; {
                console.log(theStrings);
                //Somehow convert the plain array of strings to an observable and concat it to this.someObservable$ observable...
            },
            error=&gt;console.log(error)
        );
    }
}
</code></pre>

<p>Can anyone please help?</p>

<p>Furthermore, I want to ensure that the service instance <code>Observable&lt;string[]&gt;</code> is continuously updated as the EventSource is called repeatedly. Is my subscribe logic in the right place?</p>

<p><strong>edit 1</strong>: I tried to use RxJS <code>concat</code> operator as follows:</p>

<pre><code>    this.someObservable$.subscribe(
        theStrings=&gt; {
            console.log(theStrings);
            this.someObservable$ = this.someObservable$.concat(Observable.create(theStrings));
        },
        error=&gt;console.log(error)
    );
 }
</code></pre>

<p>together with the angular2 <code>async</code> pipe:</p>

<pre><code>&lt;ul&gt;
    &lt;li *ngFor=""#s of appService.someObservable$ | async""&gt;
       a string: {{ s }}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>and nothing gets displayed on the page; the strings just get displayed on the console...</p>

<p>What I am getting wrong?</p>

<p><strong>edit 2</strong>: The app is available on github <a href=""https://github.com/balteo/demo-angular2-rxjs"" rel=""nofollow"">here</a></p>

<p><strong>edit 3</strong>: I have taken into account Thierry's advice, especially the use of the <code>async</code> pipe in order to subscribe as well as the usage of the scan operator.</p>

<p>The only remaining issue now is that I need to click on the router link in order for the strings to render on the template... The template does not update automatically...</p>

<p>See project on github and relevant tag: <a href=""https://github.com/balteo/demo-angular2-rxjs/tree/36864628/536299"" rel=""nofollow"">https://github.com/balteo/demo-angular2-rxjs/tree/36864628/536299</a></p>
","536299","","536299","","2016-04-26 13:06:46","2016-04-26 13:06:46","Convert a plain string[] into a Observable<string[]> and concat it to another Observable<string[]> using RxJS 5","<angular><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"36864628","2","","36863333","2016-04-26 12:12:54","","4","","<p>I would leverage the <code>scan</code> operator to do that. Here is a sample:</p>

<pre><code>@Component({
  selector: 'app'
  template: `
    &lt;div&gt;
      &lt;div *ngFor=""#elt of someObservable$  | async""&gt;{{elt.name}&lt;/div&gt;
    &lt;/div&gt;
  `
})
export class App {
  constructor() {
    this.someObservable$ = Observable.create((observer) =&gt; {
      const eventSource = new EventSource('/interval-sse-observable');
      eventSource.onmessage = x =&gt; observer.next(JSON.parse(x.data));
      eventSource.onerror = x =&gt; observer.error(console.log('EventSource failed'));
      return () =&gt; {
        eventSource.close();
      };
    })
    .startWith([])
    .scan((acc,value) =&gt; acc.concat(value));
  }
}
</code></pre>

<p>Here is the corresponding plunkr: <a href=""https://plnkr.co/edit/St7LozX3bnOBcoHaG4uM?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/St7LozX3bnOBcoHaG4uM?p=preview</a>.</p>

<p>See this question for more details:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/36686465/angular-2-asynpipe-isnt-working-with-an-observable"">Angular 2 AsynPipe isn&#39;t working with an Observable</a></li>
</ul>
","1873365","","-1","","2017-05-23 10:30:53","2016-04-26 12:12:54","","","","6","","","","CC BY-SA 3.0"
"36952063","2","","35950458","2016-04-30 07:24:21","","10","","<p>As same as RxJS 4, RxJS 5 also provides umd builds via cdn can be embeded without requiring any module loader like </p>

<pre><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.6/dist/global/Rx.umd.js""&gt;&lt;/script&gt;
</code></pre>

<p>then <code>Rx</code> will be global variable you can access anywhere.</p>

<p>You may refer CDN hosted build description at <a href=""https://github.com/ReactiveX/rxjs#cdn"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs#cdn</a> .</p>
","2742189","","","","","2016-04-30 07:24:21","","","","1","","","","CC BY-SA 3.0"
"36959160","1","37103636","","2016-04-30 19:18:21","","11","1088","<p>In <a href=""https://www.npmjs.com/package/@reactivex/rxjs""><code>@reactivex/rxjs</code> package</a> it is suggested that scoped package should be used:</p>

<blockquote>
  <p>npm install @reactivex/rxjs</p>
</blockquote>

<p>And UMD module is available through npmcdn as</p>

<pre><code>https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.7/dist/global/Rx.umd.js
</code></pre>

<p>However, <a href=""https://www.npmjs.com/package/rxjs"">unscoped <code>rxjs</code> package</a> has got published 5.x versions too but README also suggests</p>

<blockquote>
  <p>npm install @reactivex/rxjs</p>
</blockquote>

<p>And UMD module is available as</p>

<pre><code>https://npmcdn.com/rxjs@5.0.0-beta.7/bundles/Rx.umd.js
</code></pre>

<p>Both refer to <code>git+ssh://git@github.com/ReactiveX/RxJS.git</code> repository, but package contents look totally different.</p>

<p>Why do their trees differ so much? What is the practical difference between those two? Is there a reason why one of them should be favoured at this moment?</p>
","3731501","","","","","2016-05-08 18:55:34","@reactivex/rxjs and rxjs NPM packages for RxJS 5","<npm><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"36968048","1","36968575","","2016-05-01 14:57:07","","3","584","<p>Hi I'm building a small stackoverflow-like forum and I'm trying to implement a simple text-filter for my threads-titles.</p>

<p>I've recently started learning about rxjs and pipes so this is what I came up so far with 2 issues</p>

<ol>
<li>I'm not sure which method I should use to to parse the title, i'm currently using string.include() but it's not working correctly (e.g. if I type who, then ""how"" shows, if I type ""how"" then ""who"" shows...</li>
</ol>

<p><strong>UPDATE: Sofar the major error seems to be that the pipe only receives the first letter...but no clue on what causes it.</strong></p>

<ol start=""2"">
<li>I'm using a pure pipe and the property gets passed to it via an subject,not sure if this is the best practice way...</li>
</ol>

<p><a href=""https://plnkr.co/edit/VViLYFd5oFTwNqP9eoZi?p=preview"" rel=""nofollow"">https://plnkr.co/edit/VViLYFd5oFTwNqP9eoZi?p=preview</a></p>

<p>Thanks for help and suggestions</p>

<p>Component</p>

<pre><code>@Component({
  selector: 'dashboard-main',
  pipes:[FilterTitle],
  template:`
  &lt;input type=""text"" id=""title"" [(ngModel)]=""binding"" (keyup)=""trigger()""&gt;
  &lt;h3&gt;{{binding}}&lt;/h3&gt;
  &lt;hr&gt;
  &lt;h3&gt;{{testText}}&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li *ngFor=""#thread of threadlist | filterTitle:testText""&gt;{{thread.title}}&lt;/li&gt;
&lt;/ul&gt;
  `
})
export class DashboardMainComponent implements OnInit{

  binding:string='Input';
  text$:Subject&lt;string&gt; = new Subject&lt;string&gt;();
  testText:string="""";

  ngOnInit():any {
    this.text$.debounceTime(500).distinctUntilChanged().subscribe( text =&gt; this.setText(text))
  }

  trigger(){
    this.text$.next(this.binding);
  }

  setText(text:string){
    console.log(text);
    this.testText = text;
  }

  threadlist=[
    {
      title:'Who are you?'
    },
     {
      title:'How are you?'
    },
     {
      title:'Where are you?'
    }
    ]
}
</code></pre>

<p>Pipe</p>

<pre><code>@Pipe({
  name:'filterTitle',

})

export class FilterTitle implements PipeTransform{
    transform(array:any[], [search]):any {
      if(search ===''){
        return array
      }
      return array.filter(thread =&gt; {
        return thread.title.includes(search)
      })
    }
}
</code></pre>
","5342949","","5342949","","2016-05-01 15:34:29","2016-05-02 12:39:59","angular2 rxjs filter threads with input text","<text><filter><angular><rxjs5><angular2-pipe>","1","2","","","","CC BY-SA 3.0"
"36968575","2","","36968048","2016-05-01 15:45:19","","2","","<p>The parameter declaration in the pipe was wrong. It should be</p>

<pre><code>transform(array:any[], search):any {
</code></pre>

<p>instead of</p>

<pre><code>transform(array:any[], [search]):any {
</code></pre>

<p>Since beta.16 pipes don't get an array or parameters passed anymore. Each value is passed as a distinctive parameter <a href=""https://github.com/angular/angular/blob/master/CHANGELOG.md#200-beta16-2016-04-26"" rel=""nofollow"">https://github.com/angular/angular/blob/master/CHANGELOG.md#200-beta16-2016-04-26</a></p>

<p><a href=""https://plnkr.co/edit/aQYnRkmKbIRo1Vptujjh?p=preview"" rel=""nofollow""><strong>Plunker example</strong></a></p>
","217408","","217408","","2016-05-02 12:39:59","2016-05-02 12:39:59","","","","4","","","","CC BY-SA 3.0"
"36979451","1","","","2016-05-02 09:46:04","","7","763","<p>I have a webapp project which uses rxjs5 to implement a <a href=""https://facebook.github.io/react/docs/flux-overview.html"">flux</a> and I am currently looking for solutions to write unit tests on it.</p>

<p>In fact, I have implemented custom observables inside, for example :</p>

<pre><code>function getActivityObservable(events, timeout) {
  return Observable.create((observer) =&gt; {
    const deb = debounce(() =&gt; observer.next(false), timeout || DEFAULT_TIMEOUT);
    const sub = events.subscribe((e) =&gt; {
      if (!e) {
        deb.cancel();
        observer.next(false);
      } else {
        observer.next(true);
        deb(e);
      }
    });

    return () =&gt; {
      if (sub) sub.unsubscribe();
      if (deb) deb.cancel();
    };
  }).distinctUntilChanged();
}
</code></pre>

<p>I would like to test it using the <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md"">marble testing way</a> and write something like (i took a sample example from rxjs repository)</p>

<pre><code>  describe(""getActivityObservable"", () =&gt; {
    it(""should debounce by selector observable"", () =&gt; {
      const e1 =   hot(""--a--bc--d----|"");
      const e1subs =   ""^             !"";
      const expected = ""----a---c--d--|"";

      expectObservable(e1.debounce(getTimerSelector(20))).toBe(expected);
      expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
  });
</code></pre>

<p>My question is: </p>

<p>Is it possible to use marble testing method (with operators like <code>hot</code>, <code>cold</code> and so on...) outside the rxjs5 project. I don't figure out how to use this nice tool in my project.</p>

<p>Thank you for your help.</p>
","5677936","","","","","2016-09-11 12:31:01","Using marble testing rxjs5 method inside another project","<javascript><unit-testing><jasmine><karma-runner><rxjs5>","1","3","3","","","CC BY-SA 3.0"
"36986548","1","36989035","","2016-05-02 15:52:11","","111","71302","<p>I am wondering what is the use of <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/asobservable.md"" rel=""noreferrer""><code>asObservable</code></a>:</p>

<p>As per docs: </p>

<blockquote>
  <p>An observable sequence that hides the identity of the
  source sequence.</p>
</blockquote>

<p>But why would you need to hide the sequence?</p>
","2040670","","1788806","","2018-11-22 11:04:26","2021-09-08 12:42:33","When to use asObservable() in rxjs?","<rxjs><rxjs5>","3","0","42","","","CC BY-SA 4.0"
"36989035","2","","36986548","2016-05-02 18:20:19","","213","","<h2>When to use Subject.prototype.asObservable()</h2>
<p>The purpose of this is to prevent leaking the &quot;observer side&quot; of the Subject out of an API. Basically to prevent a leaky abstraction when you don't want people to be able to &quot;next&quot; into the resulting observable.</p>
<h3>Example</h3>
<p>(NOTE: This really isn't how you should make a data source like this into an Observable, instead you should use the <code>new Observable</code> constructor, See below).</p>
<pre class=""lang-js prettyprint-override""><code>const myAPI = {
  getData: () =&gt; {
    const subject = new Subject();
    const source = new SomeWeirdDataSource();
    source.onMessage = (data) =&gt; subject.next({ type: 'message', data });
    source.onOtherMessage = (data) =&gt; subject.next({ type: 'othermessage', data });
    return subject.asObservable();
  }
};
</code></pre>
<p>Now when someone gets the observable result from <code>myAPI.getData()</code> they can't <code>next</code> values in to the result:</p>
<pre class=""lang-js prettyprint-override""><code>const result = myAPI.getData();
result.next('LOL hax!'); // throws an error because `next` doesn't exist
</code></pre>
<h3>You should usually be using <code>new Observable()</code>, though</h3>
<p>In the example above, we're probably creating something we didn't mean to. For one, <code>getData()</code> isn't lazy like most observables, it's going to create the underlying data source <code>SomeWeirdDataSource</code> (and presumably some side effects) immediately. This also means if you <code>retry</code> or <code>repeat</code> the resulting observable, it's not going to work like you think it will.</p>
<p>It's better to encapsulate the creation of your data source within your observable like so:</p>
<pre class=""lang-js prettyprint-override""><code>const myAPI = {
  getData: () =&gt; return new Observable(subscriber =&gt; {
    const source = new SomeWeirdDataSource();
    source.onMessage = (data) =&gt; subscriber.next({ type: 'message', data });
    source.onOtherMessage = (data) =&gt; subscriber.next({ type: 'othermessage', data });
    return () =&gt; {
      // Even better, now we can tear down the data source for cancellation!
      source.destroy();
    };
  });
}
</code></pre>
<p>With the code above, any behavior, including making it &quot;not lazy&quot; can be composed on top of the observable using RxJS's existing operators.</p>
","135786","","9834715","","2020-07-27 19:38:13","2020-07-27 19:38:13","","","","8","","","","CC BY-SA 4.0"
"36993248","1","36994787","","2016-05-02 23:32:03","","8","2234","<p>I am trying to do something very simple, just log the event.clientX on mouseover, and this is the module code:</p>

<pre><code>import { Observable, Subject } from 'rxjs';
import StarSky from './starsky';
import constants from '../constants/index';

const HERO_Y = constants.HERO_Y(StarSky.canvas);

export const StarShip = Observable.fromEvent(StarSky.canvas,'mousemove')
  .map((event)=&gt; {
    return {
      x: event.clientX,
      y: HERO_Y
    }
  })
  .startWith({
    x: StarSky.canvas.width /2,
    y: HERO_Y
  })
</code></pre>

<p>Then I subscribe to it later, likeso:</p>

<pre><code>StarShip.subscribe(x =&gt;  console.log(x));
</code></pre>

<p>What is happening is that typescript compiler keeps throwing an error of this particular kind:</p>

<pre><code>Property clientX does not exist on type {}
</code></pre>

<p>I am guessing because its still an empty Rx Subject, and clientX is not yet still there as it needs to be initialised via mouseover. This is kind of silly because if I remove <code>.clientX</code>, and leave <code>event</code> there as <code>x</code>, it logs out with no problems.</p>

<p>How to combat this incompatibility and work around this error?</p>

<p><strong>EDIT:</strong> </p>

<p>I am sorry, just found out that the solution is to put type declaration</p>

<pre><code>(event: MouseEvent) =&gt; { ... }
</code></pre>

<p>Just like this.</p>
","3939255","","","","","2016-05-03 02:50:04","RxJs / Typescript throws 'property clientX does not exist on type {}'","<typescript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"36994787","2","","36993248","2016-05-03 02:50:04","","16","","<blockquote>
  <p>'property clientX does not exist on type {}'</p>
</blockquote>

<p>This is because the observable is not typed: </p>

<pre><code>Observable.fromEvent(StarSky.canvas,'mousemove')
</code></pre>

<p>You can add an annotation as a generic param: </p>

<pre><code>Observable.fromEvent&lt;MouseEvent&gt;(StarSky.canvas,'mousemove')
</code></pre>

<p>Or the callback as you have done. </p>
","390330","","","","","2016-05-03 02:50:04","","","","0","","","","CC BY-SA 3.0"
"36994941","1","36995221","","2016-05-03 03:08:09","","2","1205","<p>I have the following:</p>

<h2>angular2 (NameCmp)</h2>

<pre><code>import {
    OnInit, Component, ChangeDetectionStrategy, ViewChild, ElementRef,
    AfterViewInit
} from 'angular2/core'
import {Observable} from 'rxjs/Observable';

..
export class NameCmp implements AfterViewInit{
....
  @ViewChild('card')
  card: ElementRef;
  mouseMoves$: Observable&lt;MouseEvent&gt;;

  ngAfterViewInit(): void {
  this.mouseMoves$ = Observable.fromEvent(this.card.nativeElement, 'mousemove');

    this.mouseMoves$.subscribe( event =&gt; console.log('logging mousemove'));

  console.log('after view init')
}
</code></pre>

<h2>.html</h2>

<pre><code>...
&lt;md-card #card&gt;
  &lt;md-card-content&gt;
    &lt;md-input
        required
        placeholder = ""Title""
        [ngFormControl] = ""titleCtrl""&gt;&lt;/md-input&gt;
  &lt;/md-card-content&gt;
&lt;/md-card&gt;
</code></pre>

<p>However, although the <code>console.log('after view init')</code> prints to the console, the <code>console.log('logging mousemove'));</code> statement does not.</p>

<p>Thanks</p>
","2258442","","","","","2016-05-03 04:50:14","How to observe mousemoves with angular2 and angular rxjs","<angular><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"36995221","2","","36994941","2016-05-03 03:43:36","","5","","<p>Your code is fine, you just need to import <code>fromEvent</code></p>

<pre><code>import ""rxjs/add/observable/fromEvent"";
</code></pre>

<p>or import <code>Observable</code> from <code>Rx</code></p>

<pre><code>import {Observable} from 'rxjs/Rx';
</code></pre>

<p>Check this <a href=""http://plnkr.co/edit/WaDoBXBw1K8ugsiuIARc?p=preview"" rel=""nofollow"">plunk</a></p>

<p><strong>Update</strong>
In order to get a reference of the nativeElement of the referenced component. e.g. get the nativeElement of the <code>md-card</code>, you need to pass the object <code>{read:ElementRef}</code> to <code>ViewChild()</code></p>

<pre><code>@ViewChild('card', {read: ElementRef})
</code></pre>

<p><a href=""http://plnkr.co/edit/5EgXVim2CMQo8cpulLBB?p=preview"" rel=""nofollow"">Check this plunk</a></p>
","3125880","","3125880","","2016-05-03 04:50:14","2016-05-03 04:50:14","","","","7","","","","CC BY-SA 3.0"
"37013041","1","","","2016-05-03 19:43:58","","3","1689","<p>using rxjs beta2 my project works great, but updating to beta6 I get a long list of compile error:</p>

<pre><code>component.ts(34,18): error TS2339: Property 'finally' does not exist on type 'Observable&lt;T[]&gt;'.
....
....
.component.ts(51,10): error TS2339: Property 'switchMap' does not exist on type 'Observable&lt;Company&gt;'.
....
....
service.ts(24,18): error TS2339: Property 'map' does not exist on type 'Observable&lt;Response&gt;'
....
....
node_modules/rxjs/add/observable/range.d.ts(2,16): error TS2435: Ambient modules cannot be nested in other modules.
node_modules/rxjs/add/observable/range.d.ts(2,16): error TS2436: Ambient module declaration cannot specify relative module name.
node_modules/rxjs/add/operator/catch.d.ts(2,16): error TS2435: Ambient modules cannot be nested in other modules.
node_modules/rxjs/add/operator/catch.d.ts(2,16): error TS2436: Ambient module declaration cannot specify relative m
..
</code></pre>

<p>I'm importing Observables like this:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
</code></pre>

<p>What am I doing wrong?</p>

<p>Thanks a lot</p>

<p><strong>EDIT</strong>
using rc1 rxjs beta6 works.
But I had to cast the result on all my observables.
Before I could use:</p>

<pre><code>this._couseSourcesSvc.readAll ()
    .finally (() =&gt; sourcesSpinner.hide ())
    .subscribe (
        res =&gt; {
            this.sources = res;
        }
</code></pre>

<p>But now I have to use:</p>

<pre><code>this._couseSourcesSvc.readAll ()
    .finally (() =&gt; sourcesSpinner.hide ())
    .subscribe (
        (res:Sources[]) =&gt; {
            this.sources = res;
        }
</code></pre>

<p>As you can see I have to cast the result or I get a compile error
<em>(res:Sources[])</em></p>

<pre><code>Type '{}' is not assignable to type 'DocumentSource[]'.
</code></pre>

<p>Is this normal?</p>
","3471528","","3471528","","2016-05-19 10:29:04","2016-05-19 10:29:04","Compile error using beta6","<angular><rxjs><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"37015363","1","37032637","","2016-05-03 22:19:15","","5","533","<p>I have an Observable that is based on some events and at some point does some expensive computation. I would like to render the results from that Observable in multiple different places. If I naively subscribe to this Observable in two places I will end up doing the expensive computation twice. Here is a code snippet to drive my point home:</p>

<pre><code>var s = new rx.Subject();
var o = s.map(x =&gt; { console.log('expensive computation'); return x });
o.subscribe(x =&gt; console.log('1: ' + x));
o.subscribe(x =&gt; console.log('2: ' + x));
s.next(42);
</code></pre>

<p>The output is:</p>

<pre><code>expensive computation
1: 42
expensive computation
2: 42
</code></pre>

<p>I would like to perform the expensive computation in the map only once. <code>share</code> accomplishes this, but it makes it so late-arriving subscribers do not get the current value to render. In previous RxJS versions, <code>shareValue</code> allowed late-arriving subscribers to get the current value. However, it appears that this was renamed to <code>shareBehavior</code> in RxJS 5 and then removed altogether:</p>

<p><a href=""https://github.com/ReactiveX/rxjs/pull/588"" rel=""nofollow"">https://github.com/ReactiveX/rxjs/pull/588</a></p>

<p><a href=""https://github.com/ReactiveX/rxjs/pull/712"" rel=""nofollow"">https://github.com/ReactiveX/rxjs/pull/712</a></p>

<p>There is a long discussion in <a href=""https://github.com/ReactiveX/RxJS/issues/453"" rel=""nofollow"">this issue</a> where it was decided that they would 'Remove shareBehavior and shareReplay to prevent user confusion.' I don't understand what the potential for confusion was (so maybe that means I am one of the users saved by this decision?).</p>

<p><code>publishBehavior</code> also looks promising but I don't fully understand <code>publish</code> and it seems like it adds more complexity than I need or want.</p>

<p>Anyway, I would like to know if there is a recommended way to accomplish this in RxJS 5. The <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""nofollow"">migration doc</a> doesn't provide any recommendations.</p>
","901387","","901387","","2016-05-03 22:26:05","2016-05-04 15:54:11","Accomplishing shareValue/shareBehavior","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"37032637","2","","37015363","2016-05-04 15:54:11","","5","","<p>After some more research I've found that the behavior I've described can be implemented with</p>

<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-publishBehavior"" rel=""noreferrer""><code>.publishBehavior(startValue)</code></a><code>.refCount()</code>.</p>

<p>This discovery is based on the fact that <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-share"" rel=""noreferrer""><code>share()</code></a> is an alias for <code>publish().refCount()</code>. I still don't fully understand <code>publish()</code> but this seems to have the desired effect in practice.</p>

<p>Similar is <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-cache"" rel=""noreferrer""><code>cache(1)</code></a> (which is an alias for <code>publishReplay(1).refCount()</code>). It has a similar effect as <code>publishBehavior(defaultValue).refCount()</code> except that it does not start with a default value. So if no items have been emitted, new subscribers will not immediately receive a value.</p>
","901387","","","","","2016-05-04 15:54:11","","","","0","","","","CC BY-SA 3.0"
"37041230","1","","","2016-05-05 02:17:00","","0","2515","<p>What is the best way to write following code in RxJs. Assuming getSomethingFromDb( ) returns an observable. <strong>Note: I do not want to use IF from my RXJS code</strong></p>

<pre><code>let something:any = getSomethingFromDatabsae( )

if(&lt;value inside something observable is not undefined&gt;){
   doThis( );
} else {
   doThat( );
}
</code></pre>

<p><strong>Edit: I am going to make my question more interesting. What if my code is more complex like this, how to implement this without using if statements in RxJS. ( more declartively )</strong></p>

<pre><code>let observable:any = getSomethingFromDatabsae( )

if(&lt;value inside observable is not undefined&gt;){
   doThis( );
} else if(&lt;value inside observable is ""one""&gt;) {
   doFirstThing( );
}else if(&lt;value inside observable is ""two""&gt;) {
   doSecondThing( );
}
</code></pre>
","2797765","","2797765","","2016-05-05 15:39:52","2016-05-17 10:28:48","RxJs alternate for if then else statement","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"37057872","1","56232821","","2016-05-05 18:37:05","","1","1344","<p>If I have a component with a property of:</p>

<pre><code>import { Component, OnInit } from 'angular2/core';
import { CarService } from 'someservice';

@Component({
    selector: 'car-detail',
    templateUrl: './app/cars/car.component.html'
})

export class CarComponent implements OnInit {

    model: Observable&lt;Car&gt;;

    constructor(
        private _carService: CarService
    ) { }

    ngOnInit() {
        // begin benefit setup
        this.model = this._carService.get(5);
    }
}
</code></pre>

<p>for instance, and I want to in my view use an async pipe to subscribe to that and use the properties as text, how can you actually subscribe to it? For instance:</p>

<pre><code>&lt;template #mycar = ""model | async"" &gt;
    &lt;p&gt;{{ myCar?.make }}&lt;/p&gt; 
&lt;/template&gt;
</code></pre>

<p>I am new to Angular2 and not sure if I am doing something wrong or not.</p>
","113329","","113329","","2016-05-05 18:52:36","2019-05-21 07:03:58","How to consume single Observable property in view from Angular2 component using async pipe?","<asynchronous><typescript><angular><observable><rxjs5>","2","8","","","","CC BY-SA 3.0"
"37071528","1","","","2016-05-06 11:44:07","","0","547","<p>Using rxjs 5, I want to subscribe to an observable and begin the stream with the last emitted value. The operator '.cache' is supposed to be built for this (I think) but I can't get it to work. I did a small test where fire an observable (by clicking a button) then subscribe to it 3 seconds later. In theory, I should get that click emission upon subscription, but I don't. </p>

<p><a href=""https://github.com/ReactiveX/RxJS/commit/4308a04"" rel=""nofollow"">https://github.com/ReactiveX/RxJS/commit/4308a04</a></p>

<p><a href=""http://codepen.io/BradLee/pen/VaqreL"" rel=""nofollow"">http://codepen.io/BradLee/pen/VaqreL</a></p>

<pre><code>let btn = document.querySelector(`btn`),
    btn$ = Rx.Observable.fromEvent(btn, `click`)
             .cache(1);

setTimeout(() =&gt; { 
    btn$.subscribe(evt =&gt; console.log('fired') );
}, 3000);
</code></pre>
","4165012","","","","","2016-05-14 05:56:27","rxjs5 get last emitted value upon subscription","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"37103636","2","","36959160","2016-05-08 18:55:34","","4","","<p>doubled check <strong>now</strong> and they appears to be the same file</p>

<pre><code>$ wget https://npmcdn.com/rxjs@5.0.0-beta.7/bundles/Rx.umd.js -q -O rxjs
$ wget https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.7/dist/global/Rx.umd.js -q -O reativx-rxjs
$ diff rxjs reativx-rxjs 
$ 
</code></pre>
","4466350","","","","","2016-05-08 18:55:34","","","","3","","","","CC BY-SA 3.0"
"37109928","1","37109979","","2016-05-09 07:26:02","","4","4559","<p>in my <strong>service.component.j</strong>s I return an observable of an array of Student from the http call. Student object has a property called age, </p>

<p>student.ts</p>

<pre><code>export class Student {
  id: number;
  name: string;
  age:number;
}
</code></pre>

<p>service.componnet.js</p>

<pre><code>getStudents (): Observable&lt; Student[]&gt; 
</code></pre>

<p>In the <strong>studentManagement.component.ts</strong> which is an observer to the observable above, I want to sum the age of the students. I know I can put a sum() in source (which is less preferred, as I also need to display other info of the Students in the page, such as id, name ,individual age as well.) or calculate it from _studentList. Besides these two, any other way?</p>

<pre><code>private _studentList:Student[]=[];

    .subscribe(
            returnedStudents =&gt; {
              console.log(returnedStudents);
              this._studentList = returnedStudents;
            },
            erroMsg =&gt; this._errorMessage = erroMsg
          ) 
</code></pre>
","1405511","","3795501","","2016-05-09 10:20:43","2016-05-09 10:20:43","Angular2 - sum the values of a property in the Object sent from an observerable","<javascript><typescript><angular><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"37109979","2","","37109928","2016-05-09 07:29:14","","6","","<p>You could use <code>map</code> on the Observable to return the sum.</p>

<pre><code>getStudents().map(arr =&gt; arr.reduce((a, b) =&gt; a + b.age, 0));
</code></pre>

<p>Here we reduce the inner Array to the sum of the age property of the students. Now what we have is a <code>Observable&lt;number&gt;</code>, which will emit the sum of the ages.</p>

<p>If you want to display both:</p>

<pre><code>getStudents (): Observable&lt; Student[]&gt; {
   return this.http.get(/*...*/).share();
}

getAgeSum(): Observable&lt;number&gt; {
    return this.studentsObservable
       .map(arr =&gt; arr.reduce((a, b) =&gt; a + b.age, 0));
}
</code></pre>

<p>We have to call share here, so that the Observable becomes hot and doesn't do the HTTP Request twice. </p>
","3795501","","3795501","","2016-05-09 08:50:57","2016-05-09 08:50:57","","","","2","","","","CC BY-SA 3.0"
"37137669","1","","","2016-05-10 11:48:28","","1","613","<p>I am trying to get time expiry cache to work for an observable that abstracts a ""request-response"", using <code>postMessage</code> and <code>message</code> events on the window.</p>

<p>The remote window expects a message <code>getItemList</code> and replies to it with a message of type <code>{type: 'itemList', data: []}</code>.</p>

<p>I would like to model the <code>itemList$</code> observable in such a way that it caches the last result for 3 seconds, so that no new requests are made during that time, however, I cannot think of a way to achieve that in an elegant (read, one observable â no subjects) and succint manner.</p>

<p>Here is the example in code:</p>

<pre><code>const remote = someIframe.contentWindow;
const getPayload = message =&gt; message.data;
const ofType = type =&gt; message =&gt; message.type === type;

// all messages coming in from the remote iframe
const messages$ = Observable.fromEvent(window, 'message')
  .map(getPayload)
  .map(JSON.parse);

// the observable of (cached) items
const itemList$ = Observable.defer(() =&gt; {
    console.log('sending request');

    // sending a request here, should happen once every 3 seconds at most
    remote.postMessage('getItemList');

    // listening to remote messages with the type `itemList`
    return messages$
      .filter(ofType('itemList'))
      .map(getPayload);
  })
  .cache(1, 3000);

/**
 * Always returns a promise of the list of items
 * @returns {Promise&lt;T&gt;}
 */
function getItemList() {
  return itemList$
    .first()
    .toPromise();
}


// poll every second
setInterval(() =&gt; {
  getItemList()
    .then(response =&gt; console.log('got response', response));
}, 1000);
</code></pre>

<p>I am aware of <a href=""https://stackoverflow.com/questions/26475317/how-to-implement-time-expiry-hot-observable-in-rxjs-or-general-in-reactive-exte"">the (very similar) question</a>, but I am wondering if anyone can come up with a solution without explicit subjects.</p>

<p>Thank you in advance!</p>
","6314750","","-1","","2017-05-23 11:44:22","2016-07-27 11:30:47","RxJS 5 Timed Cache","<caching><rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"37150891","1","37152430","","2016-05-11 00:02:27","","5","1869","<p>I am trying to use a RxJS <code>BehaviorSubject</code> that contains a <code>boolean</code> representing whether or not a user is connected/logged in the application.</p>

<p>Here is the component that subscribes to the new <code>BehaviorSubject</code> value i.e. <strong><code>true</code></strong> when the user has authenticated:</p>

<pre><code>import {Component, OnInit} from '@angular/core';
import {CollapseDirective} from 'ng2-bootstrap';
import {PublicNavbarComponent} from './public.navbar.component';
import {PrivateNavbarComponent} from './private.navbar.component';
import {SessionService} from '../../session/session.service';

@Component({
    selector: 'navbar',
    templateUrl: 'app/shared/components/navbar.component.html',
    providers: [SessionService],
    directives: [PublicNavbarComponent, PrivateNavbarComponent, CollapseDirective]
})
export class NavbarComponent implements OnInit {

    constructor(private sessionService:SessionService) {
    }

    ngOnInit() {
        this.sessionService.authenticated$.subscribe({
            next: (value)=&gt; this.isAuthenticated = value
        });
    }

    isAuthenticated:boolean = false;

    isCollapsed:boolean = true;
}
</code></pre>

<p>Here is the class/service containing the <code>BehaviorSubject</code>:</p>

<pre><code>import {Injectable} from '@angular/core';
import {Http, Headers, RequestOptions} from '@angular/http';
import {Credentials} from '../shared/models/credentials.model';
import {BehaviorSubject} from 'rxjs/BehaviorSubject';
import 'rxjs/Rx';

@Injectable()
export class SessionService {

    authenticated$:BehaviorSubject&lt;boolean&gt; = new BehaviorSubject(false);
    currentUserAccount;

    constructor(private http:Http) {
    }

    signin(credentials:Credentials) {
        let headers = new Headers({'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'});
        let options = new RequestOptions({headers: headers});
        this.http.post('/api/signin', 'username=' + credentials.username + '&amp;password=' + credentials.password, options)
            .subscribe(response=&gt;
                this.setPersonalInfo(response.headers.get('x-auth-token'))
            );
    }

    setPersonalInfo(sessionToken) {
        localStorage.setItem('authenticated', 'true');
        localStorage.setItem('sessionToken', sessionToken);
        this.authenticated$.next(true);//next() from false to true
        this.http.get('/api/utils/current-useraccount')
            .subscribe(param =&gt; this.currentUserAccount = param);
    }
}
</code></pre>

<p>However this does not have the expected behavior: it seems that <code>authenticated$</code> from session service is only true within <code>setPersonalInfo</code> function and <code>isAuthenticated</code> from <code>NavbarComponent</code> isn't notified at all when <code>this.authenticated$.next(true)</code> is invoked.</p>
","536299","","","","","2016-05-11 05:54:40","Issue with RxJs BehaviorSubject's subscriber not being notified of value change","<typescript><angular><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"37152430","2","","37150891","2016-05-11 03:07:04","","7","","<p>It seems like you have multiple instances of <code>SessionService</code>. e.g. you provided it more than once and the instance that you call <code>signin</code> in is not the same instance as the one you injected in <code>NavbarComponent</code>.</p>

<p>It depends on your project design how you provide your services. Usually session services are singletons.<br>
I recommend removing <code>providers: [SessionService],</code> from <code>NavbarComponent</code>.</p>
","3125880","","","","","2016-05-11 03:07:04","","","","0","","","","CC BY-SA 3.0"
"37155781","1","","","2016-05-11 07:25:08","","5","6500","<p>I use RxJS 4 to create Hot Observable like describe in the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables"" rel=""noreferrer"">official documentation</a></p>

<p>But the <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""noreferrer"">RxJS 5 migration guid</a> doesn't explain how to create Hot Observable.</p>

<pre><code>const source = Observable.create((observer) =&gt; {
  asynCall((data) =&gt; {
    observer.onNext(data)
  })
})
const published = source.publish()
published.connect()
published.subscribe((data) =&gt; {
  console.log(data)
})
</code></pre>

<p>With Rx5 I've got the following error:</p>

<p>Uncaught TypeError: source.publish is not a function(â¦)</p>
","4177268","","4177268","","2016-06-07 12:21:33","2021-02-04 15:35:12","How to create Hot Observable in RxJS 5","<javascript><rxjs><rxjs5>","2","3","3","","","CC BY-SA 3.0"
"37184262","1","","","2016-05-12 10:29:36","","2","123","<p>How can i use Rx.DOM in rxjs5, specially Rx.DOM.jsonpRequest ?</p>

<p>this is a simple implementation, but i wanna use jsonpRequest : </p>

<pre><code>function JSONP(url, callbackName) {
  return Rx.Observable.create(observer =&gt; {
    window.[callbackName] = res =&gt; {
      observer.next(res);
      observer.complete();
    };

    let script = document.createElement('script');
    let head = document.getElementsByTagName('head')[0];

    script.src = url;
    head.appendChild(script);
  }).retry(3);
}
</code></pre>
","4104221","","","","","2016-05-12 10:29:36","rx.DOM in rxjs5","<rxjs><rxjs5>","0","0","","","","CC BY-SA 3.0"
"37217759","1","37217815","","2016-05-13 19:18:23","","2","2545","<p>I am using <strong>Angular2</strong>. I have a <code>BehaviorSubject</code>.</p>

<pre><code>isOpen$: Subject&lt;boolean&gt; = new BehaviorSubject&lt;boolean&gt;(true);
</code></pre>

<p>When I use like this to get latest value</p>

<pre><code>isOpen$.getValue()
</code></pre>

<p>It works well, but the terminal gives me the warning:</p>

<blockquote>
  <p>Property <code>'getValue'</code> does not exist on type <code>'Subject&lt;boolean&gt;'</code></p>
</blockquote>

<p>How can I solve this?</p>
","2000548","","2410379","","2016-05-13 19:24:35","2016-05-13 19:24:35","Property 'getValue' does not exist on type 'Subject<boolean>'","<typescript><angular><rxjs5>","2","0","","","","CC BY-SA 3.0"
"37217815","2","","37217759","2016-05-13 19:22:00","","4","","<p>You are defining it as a <code>Subject&lt;boolean&gt;</code> but assigning it from <code>BehaviorSubject&lt;boolean&gt;(true)</code>. In <strong>TypeScript</strong> the type of the property is redundant when you assign it. Remove the declaration like this:</p>

<pre><code>isOpen$ = new BehaviorSubject&lt;boolean&gt;(true);
</code></pre>

<p>Then the static analyzer will correctly handle it as you'd expect. The type <code>Subject&lt;boolean&gt;</code> does not contain the <code>getValue</code> method.</p>
","2410379","","","","","2016-05-13 19:22:00","","","","1","","","","CC BY-SA 3.0"
"37218114","1","37223392","","2016-05-13 19:39:19","","6","4174","<p>I am using Angular 2 and RxJS 5.</p>

<p>Is there any difference between these two:</p>

<p>And which should be used first? Thanks</p>

<pre><code>isOpen$ = new BehaviorSubject&lt;boolean&gt;(true);
</code></pre>

<p>and</p>

<pre><code>isOpen$ = BehaviorSubject.create(true);
</code></pre>
","2000548","","2000548","","2016-05-13 19:41:11","2016-05-14 06:25:39","Difference between 'new BehaviorSubject' and 'BehaviorSubject.create'","<angular><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"37223392","2","","37218114","2016-05-14 06:22:20","","10","","<p><a href=""https://github.com/ReactiveX/rxjs/blob/master/src/BehaviorSubject.ts"" rel=""noreferrer""><code>BehaviorSubject</code></a> doesn't have a <code>create</code> method, so I am guessing that is being exposed by the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts"" rel=""noreferrer""><code>Subject</code></a> base class. </p>

<p><em>Use the constructor</em>.
You should be using the constructor of the <code>BehaviorSubject</code> in this case. The <code>create</code> method is used to combine an <code>Observer</code> and <code>Observable</code>.</p>

<p>For instance, you could convert a <code>WebSocket</code> into a <code>Subject</code> by doing:</p>

<pre><code>var webSocket = new WebSocket(url);

var observer = Observer.create(next =&gt; webSocket.send(JSON.stringify(next)));
var observable = Observable.fromEvent(webSocket, 'message', m =&gt; JSON.parse(m.data));

var subject = Subject.create(observer, observable);
</code></pre>
","2521865","","","","","2016-05-14 06:22:20","","","","0","","","","CC BY-SA 3.0"
"37227272","1","37228059","","2016-05-14 13:29:32","","1","316","<p>I have a component that is supposed to retrieve data from a service. </p>

<p>Here is my component:</p>

<pre><code>@Component({
    templateUrl: 'app/dashboard/useraccount/firstname/useraccount-firstname.component.html',
    directives: [ROUTER_DIRECTIVES],
    pipes: [TranslatePipe]
})
export class UserAccountFirstNameComponent implements OnInit {

    currentUserAccount:Object;
    errorMessage:string;

    constructor(private userAccountService:UserAccountService) {
    }

    ngOnInit() {
        this.userAccountService.getCurrentUserAccount()
            .subscribe(
                param=&gt; this.currentUserAccount = param,
                error =&gt; this.errorMessage = &lt;any&gt;error
            );
    }

    updateFirstName() {
        this.userAccountService.updateFirstName(this.currentUserAccount);
    }

}
</code></pre>

<p>Here is the corresponding service:</p>

<pre><code>@Injectable()
export class UserAccountService {

    constructor(private http:Http) {
    }

    getCurrentUserAccount():Observable&lt;Object&gt; {
        return this.http.get('/api/useraccount')
            .map(this.mapUserAccount)
            .catch(this.handleError);
    }

    updateFirstName(currentUserAccount) {
        this.http.patch('/api/useraccount/firstname/' + currentUserAccount.firstName, null);
    }

    private mapUserAccount(res:Response) {
        console.log(res.json());
        return res.json();
    }

    private handleError(error:any) {
        // In a real world app, we might use a remote logging infrastructure
        let errMsg = error.message || 'Server error';
        console.error(errMsg); // log to console instead
        return Observable.throw(errMsg);
    }
</code></pre>

<p>Here is how the provider for the <code>UserAccountService</code>:</p>

<pre><code>bootstrap(MainComponent, [ROUTER_PROVIDERS,
    HTTP_PROVIDERS,
    TRANSLATE_PROVIDERS,
    SessionService,
    UserAccountService,
    TranslateService,
    provide(RequestOptions, {useClass: ApplicationRequestOptions}),
    provide(LocationStrategy, { useClass: HashLocationStrategy }),
    provide(TranslateLoader, {
        useFactory: (http:Http) =&gt; new TranslateStaticLoader(http, 'assets/i18n', '.json'),
        deps: [Http]
    })]);
</code></pre>

<p>Here is the relevant part from the template:</p>

<pre><code>&lt;input type=""text""
       ngControl=""firstName""
       #firstName=""ngForm""
       required
       minlength=""2""
       maxlength=""35""
       pattern_=""FIRST_NAME_PATTERN""
       [(ngModel)]=""currentUserAccount.firstName""
       placeholder=""{{'FIRST_NAME_FORM.NEW_FIRST_NAME'| translate }}""
       class=""form-control""/&gt;
</code></pre>

<p>The issue is that by the time the template is rendered, <code>currentUserAccount</code> is still <code>undefined</code> in ngModel...</p>

<p>Can anyone please help?</p>

<p>P.S. I am puzzled as my use case (having a component calling a service method that uses http) is very similar to the angular sample provided here: <a href=""http://plnkr.co/edit/DRoadzrAketh3g0dskpO?p=preview"" rel=""nofollow"">http://plnkr.co/edit/DRoadzrAketh3g0dskpO?p=preview</a></p>
","536299","","","","","2016-05-14 15:08:50","Issue with angular 2 component not subscribing to observable in service in due time","<angular><angular2-services><rxjs5>","1","4","","2016-10-19 05:11:31","","CC BY-SA 3.0"
"37228059","2","","37227272","2016-05-14 14:48:13","","1","","

<p>Angular resolves bindings already before <code>ngOnInit()</code>. You you just invoke the async call to the server to fetch the data, which will arrive eventually (and execute the callback you passed to <code>this.userAccountService.getCurrentUserAccount().subscribe(...)</code></p>

<p>To avoid an error when <code>currentUserAccount</code> is still <code>null</code> when Angular binds the view you can use the Elvis or safe navigation operator <code>?.</code> for parent-to-view binding <code>[]</code> but not for event-to-parent binding <code>()</code> this isn't supported (there are discussions to add support for this) You can use this more verbose style though:</p>

<pre class=""lang-ts prettyprint-override""><code>&lt;input type=""text""
       ngControl=""firstName""
       #firstName=""ngForm""
       required
       minlength=""2""
       maxlength=""35""
       pattern_=""FIRST_NAME_PATTERN""
       [ngModel]=""currentUserAccount?.firstName""
       (ngModelChange)=""currentUserAccount ? currentUserAccount.firstName = $event : null""
       placeholder=""{{'FIRST_NAME_FORM.NEW_FIRST_NAME'| translate }}""
       class=""form-control""/&gt;
</code></pre>
","217408","","217408","","2016-05-14 15:08:50","2016-05-14 15:08:50","","","","9","","","","CC BY-SA 3.0"
"37264778","1","37265328","","2016-05-16 23:28:43","","9","21816","<p>The complete callback does not work as expected. Let me explain:</p>

<p>See this picture, note the <code>complete</code> callback in <code>subscribe</code> method.
This <code>complete</code> function is only called when the <code>observerOrNext</code> is called. When some error happens, the <code>complete</code> is not called. This is right? There are another method to get a callback that always  is called when the process finish?</p>

<p><a href=""https://i.stack.imgur.com/GBW4V.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/GBW4V.jpg"" alt=""enter image description here""></a></p>

<p>Example:</p>

<p><strong>When success:</strong></p>

<pre><code>this.getData(params)
    .subscribe(
        successData =&gt; {
            // this is called
        },
        error =&gt; {
            // this is not called. Ok!
        },
        () =&gt; { // when complete
            // this is called, ok!
        }
    );
</code></pre>

<p><strong>When error:</strong></p>

<pre><code>this.getData(params)
    .subscribe(
        successData =&gt; {
            // this is not called, ok!
        },
        error =&gt; {
            // this is called. Ok! Yeah!
        },
        () =&gt; { // when complete
            // this is not called, why god??
        }
    );
</code></pre>
","5660495","","1624684","","2016-05-17 02:29:40","2021-08-11 09:28:37","Complete callback in Observable.prototype.subscribe in Angular 2","<javascript><angularjs><angular><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"37265328","2","","37264778","2016-05-17 00:39:11","","4","","<p>I think what you are looking for is the <code>.finally</code> function. </p>

<blockquote>
  <p>Invokes a specified action after the source observable sequence terminates gracefully or exceptionally. There is an alias called finallyAction for browsers &lt; IE9</p>
</blockquote>

<p>Here's an example: <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/finally.md"" rel=""nofollow noreferrer"">finally.md</a>.</p>
","1624684","","11673149","","2019-08-19 09:33:02","2019-08-19 09:33:02","","","","0","","","","CC BY-SA 4.0"
"37275330","1","","","2016-05-17 11:50:26","","1","405","<p>rxjs: 5.0.0-beta.2
Typescript: 1.8
Angular2: beta-9</p>

<p>I'm trying to mock a http service class but run into problems when extending the class as described in angular 2 docs.</p>

<p>Seems like you can't override a method that returns an typed observable? What am I missing? </p>

<pre><code>import {Observable} from ""rxjs/Observable"";
import {IQuery} from ""../Query"";
import {Http} from ""angular2/http"";

export interface IQuery&lt;TResult&gt; {        
}

export class A {
    public test = &lt;T&gt;(q: IQuery&lt;T&gt;): Observable&lt;T&gt; =&gt; {
        var queryName = this.getName(query);
        var url = `api/query/${queryName}`;
        return this.httpPost&lt;TResult&gt;(url, query);
    };
}

export class AMock extends A {
    public test = &lt;T&gt;(q: IQuery&lt;T&gt;): Observable&lt;T&gt; =&gt; {
        return mockObservable;
    };
}

Severity    Code    Description Project File    Line    Suppression State
Error   TS2415  Class 'AMock' incorrectly extends base class 'A'.
  Types of property 'test' are incompatible.
    Type '&lt;T&gt;(q: IQuery&lt;T&gt;) =&gt; Observable&lt;T&gt;' is not assignable to type '&lt;T&gt;(q: IQuery&lt;T&gt;) =&gt; Observable&lt;T&gt;'.
      Type 'Observable&lt;any&gt;' is not assignable to type 'Observable&lt;any&gt;'.
        Property 'source' is protected but type 'Observable&lt;T&gt;' is not a class derived from 'Observable&lt;T&gt;'.    TypeScript Virtual Projects
</code></pre>

<p>Works if return type is T but not <code>observable&lt;T&gt;</code>. </p>

<p>Thanks!</p>
","6059709","","6059709","","2016-05-18 07:49:33","2016-05-18 14:12:10","Extending method with generic obeservable as return type","<rxjs5><typescript1.8><angular2-testing>","1","3","","","","CC BY-SA 3.0"
"37306671","1","37307639","","2016-05-18 17:39:44","","4","1542","<p>In angular 2 app every request to API has header with token, in case token has expired API responds with 401 http code. I have a method to update token, but how I can resend previous request pausing others while a new token is in the process of getting? </p>
","2247766","","","","","2016-05-18 19:19:13","Resend request angular 2","<angular><rxjs5><angular2-http>","1","0","","","","CC BY-SA 3.0"
"37307639","2","","37306671","2016-05-18 18:36:24","","2","","<p>You could extend the <code>Http</code> class for this this way, catch the error using the <code>catch</code> operator of observables:</p>

<p>An approach could be to extend the HTTP object to intercept errors:</p>

<pre><code>@Injectable()
export class CustomHttp extends Http {
  constructor(backend: ConnectionBackend, defaultOptions: RequestOptions) {
    super(backend, defaultOptions);
  }

  request(url: string | Request, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    console.log('request...');
    return super.request(url, options).catch(res =&gt; {
      // do something
    });        
  }

  get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    console.log('get...');
    return super.get(url, options).catch(res =&gt; {
      // do something
    });
  }
}
</code></pre>

<p>and register it as described below:</p>

<pre><code>bootstrap(AppComponent, [HTTP_PROVIDERS,
    new Provider(Http, {
      useFactory: (backend: XHRBackend, defaultOptions: RequestOptions) =&gt; new CustomHttp(backend, defaultOptions),
      deps: [XHRBackend, RequestOptions]
  })
]);
</code></pre>

<p>Within the callback defined in the <code>catch</code> operator, you could call your method to update the token, get the result, set the new token on the source request and execute it again. This would be completely transparent.</p>

<p>Here is a sample:</p>

<pre><code>get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    return super.get(url, options).catch(res =&gt; {
      if (res.status === 401) {
        return this.getToken().flatMap(token =&gt; {
          var sourceOptions = options || {};
          var headers = sourceOptions.headers || new Headers();
          headers.append('Authorization', token); // for example
          return super.get(url, options);
        });
      }

      return Observable.throw(res);
    });
  }
</code></pre>

<p><strong>Edit</strong></p>

<p>To ""pause"" other requests you need to implement some caching within the <code>getToken</code> method using the <code>do</code> and <code>share</code> operators:</p>

<pre><code>getToken() {
  if (hasTokenExpired()) {
    this.token = null;
    this.tokenObservable = null;
  }

  if (this.token) {
    // Gotten the new token
    return Observable.of(this.token);
  } else if (this.tokenObservable) {
    // Request in progress...
    return this.tokenObservable;
  } else {
    // Execute the ""refresh token"" request
    return this.get('/refreshToken')
      .map(res =&gt; res.json)
      .do(token =&gt; {
        this.token = token;
        this.tokenObservable = null;
      })
      .share();
  }
}
</code></pre>
","1873365","","1873365","","2016-05-18 19:19:13","2016-05-18 19:19:13","","","","3","","","","CC BY-SA 3.0"
"37317580","1","37317620","","2016-05-19 08:16:14","","3","1983","<p>I have a code to get request. It's compiling and working but I have an error in console.</p>

<pre><code>public get&lt;T&gt;(url: string, headers: Headers = this.jsonHeaders()): Observable&lt;T&gt; {
        return this._http.get(url, { headers: headers })
                   .catch((err: Response, caught: Observable&lt;T&gt;) =&gt; {
                       if (err.status === 401) {
                           this._router.navigate([""/auth/login""]);
                           return Observable.throw(""401 Unauthorized"");
                       }
                       return caught;
                   })
                   .map(res =&gt; &lt;T&gt;this.toJSON(res));
    }
</code></pre>

<p>error:</p>

<pre><code>error TS2345: Argument of type '(err: Response, caught: Observable&lt;T&gt;) =&gt; ErrorObservable | Observable&lt;T&gt;' is not assignable to parameter of type '(err: any, caught: Observable&lt;Response&gt;) =&gt; Observable&lt;any&gt;'.
  Types of parameters 'caught' and 'caught' are incompatible.
    Type 'Observable&lt;Response&gt;' is not assignable to type 'Observable&lt;T&gt;'.
      Type 'Response' is not assignable to type 'T'.
</code></pre>

<p>I tried cast it to  but it's not helped</p>
","3110920","","","","","2016-05-19 08:17:46","Angular2 catch request error","<ajax><angular><request><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"37317620","2","","37317580","2016-05-19 08:17:46","","9","","<p>You use the following:</p>

<pre><code>.catch((err: Response, caught: Observable&lt;T&gt;) =&gt; {
  if (err.status === 401) {
    this._router.navigate([""/auth/login""]);
    return Observable.throw(""401 Unauthorized"");
  }
  return Observable.throw(caught); // &lt;-----
})
</code></pre>
","1873365","","","","","2016-05-19 08:17:46","","","","7","","","","CC BY-SA 3.0"
"37458208","1","37460324","","2016-05-26 10:29:14","","4","4530","<p>I'm using rxJS Observable Interval to refresh the data being fetched. I can't figure out the way to change the interval setting. I've seen something about using the Subject class provided by rxJS but I can't manage to get it to work. </p>

<p>I provided an simplified example in this <a href=""https://plnkr.co/edit/Q95dkt"" rel=""nofollow"">plunk</a></p>

<p>In the AppComponent I have this method. </p>

<pre><code>getTime() {
        this.timeService.getTime(this.refreshInterval)
          .subscribe(t =&gt; {
            this.currentTime = t;
            console.log('Refresh interval is: ' + this.refreshInterval);
          }
        );
}
</code></pre>

<p>And in the service component I currently have this code. </p>

<pre><code>getTime(refreshInterval: number) {
  return Observable.interval(refreshInterval)
        .startWith(0)
        .map((res: any) =&gt; this.getDate())
        .catch(this.handleError)
}
</code></pre>

<p>Can someone perhaps provide me with a working example it would be great! </p>
","799520","","","","","2018-03-12 15:59:05","Angular 2 - How to change the interval of an RxJS Observable","<angular><rxjs><observable><rxjs5>","3","0","3","","","CC BY-SA 3.0"
"37459603","1","37459730","","2016-05-26 11:29:57","","0","958","<p>I want to change all of my EventEmitter to Subjects since it is the recommended way to share variables and states instead of emitting an event.</p>

<p>But now I've got a problem and I just don't understand how to solve it. Here is the sample code:</p>

<pre><code>@Injectable()
export class TicketsService implements OnInit {
    private _url = ""http://127.0.0.1:3000/api/getAllTickets"";
    private _refreshTickets:Subject&lt;JSON&gt; = new Subject&lt;JSON&gt;();
    public allTickets:JSON;

    private _url_postNewTicket = ""http://127.0.0.1:3000/api/postNewTicket"";    

    constructor(private _http:AuthHttp) {
        this.allTickets = this._refreshTickets
            .mergeMap(() =&gt; this._http.get(this._url))
            .map((res:Response) =&gt; res.json())
            .cache();

    }

    refreshAllTickets() {
        console.log(""refresh all tickets.."");
        this._refreshTickets.next(null);
    }
}
</code></pre>

<p>The compiler gives me the following error:</p>

<blockquote>
  <p>public/angular/app/tickets.service.ts(26,9): error TS2322: Type 'Observable' is not assignable to type 'JSON'.
  [1]   Property 'parse' is missing in type 'Observable'.</p>
</blockquote>

<p>I guess I could write <code>allTickets:JSON</code> as <code>allTickets:any</code> but in the component I use <strong>ngFor</strong> to iterate - so I get the error from ngFor that it needs an array.</p>

<p>Thanks in advance!</p>
","3592039","","1205871","","2017-01-25 19:26:28","2017-01-25 19:26:28","Type 'Observable<any>' is not assignable to type 'JSON' in angular2 with rxjs5","<json><angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37459730","2","","37459603","2016-05-26 11:35:25","","1","","<p>You can change <code>allTickets</code> to be of type: <code>Observable&lt;any&gt;</code> and then in your <strong>ngFor</strong> binding you can use the async pipe like so:</p>

<pre><code>*ngFor=""let ticket of allTickets | async""
</code></pre>
","3960316","","","","","2016-05-26 11:35:25","","","","1","","","","CC BY-SA 3.0"
"37460324","2","","37458208","2016-05-26 12:02:41","","1","","<p>As I understand from your plnkr, your goal is to allow user to modify timer intervals.</p>

<p>You expect, that change of refreshInterval will change declared stream of rxJs:</p>

<pre><code>    this.timeService.getTime(this.refreshInterval)
      .subscribe(t =&gt; {
        this.currentTime = t;
        console.log('Refresh interval is: ' + this.refreshInterval);
      }
    );
</code></pre>

<p>and this is wrong.</p>

<p>every time, you update refreshInterval, you need to:</p>

<ul>
<li>unsubscribe or destroy previous stream. </li>
<li>create new stream and
subscribe again</li>
</ul>
","5328302","","","","","2016-05-26 12:02:41","","","","1","","","","CC BY-SA 3.0"
"37517649","1","","","2016-05-30 04:30:47","","0","204","<p>I'm a bit new to RxJS and it is kicking my ass, so I hope someone can help!</p>

<p>I'm using RxJS(5) on my express server to handle behaviour where I have to save a bunch of <code>Document</code> objects and then email each of them to their recepients. The code in my <code>documents/create</code> endpoint looks like this:</p>

<pre><code>    // Each element in this stream is an array of `Document` model objects: [&lt;Document&gt;, &lt;Document&gt;, &lt;Document&gt;] 
    const saveDocs$ = Observable.fromPromise(Document.handleCreateBatch(docs, companyId, userId));

    const saveThenEmailDocs$ = saveDocs$
      .switchMap((docs) =&gt; sendInitialEmails$$(docs, user))
      .do(x =&gt; {
        // Here x is the `Document` model object
        debugger;
      });

    // First saves all the docs, and then begins to email them all.
    // The reason we want to save them all first is because, if an email fails,
    // we can still ensure that the document is saved
    saveThenEmailDocs$
      .subscribe(
        (doc) =&gt; {
          // This never hits
        },
        (err) =&gt; {},
        () =&gt; {
          // This hits immediately.. Why though?
        }
      );
</code></pre>

<p>The <code>sendInitialEmails$$</code> function returns an Observable and looks like this:</p>

<pre><code>  sendInitialEmails$$ (docs, fromUser) {
    return Rx.Observable.create((observer) =&gt; {

      // Emails each document to their recepients
      docs.forEach((doc) =&gt; {
        mailer.send({...}, (err) =&gt; {
          if (err) {
            observer.error(err);
          } else {
            observer.next(doc);
          }
        });
      });

      // When all the docs have finished sending, complete the
      // stream
      observer.complete();
    });
  });
</code></pre>

<p>The problem is that when I subscribe to <code>saveThenEmailDocs$</code>, my <code>next</code> handler is never called, and it goes straight to <code>complete</code>. I have no idea why... Inversely if I remove the <code>observer.complete()</code> call from <code>sendInitialEmails$$</code>, the <code>next</code> handler is called every time and the <code>complete</code> handler in subscribe is never called.</p>

<p>Why isn't the expected behaviour of <code>next</code> <code>next</code> <code>complete</code> happening, instead it's one or the other... Am I missing something?</p>
","4420537","","4420537","","2016-05-30 04:36:39","2016-07-26 20:53:50","Why is my RxJS Observable completing right away?","<node.js><express><reactive-programming><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"37541560","1","37542744","","2016-05-31 09:15:03","","7","2098","<p>I would expect that my case is common but can't really find anything appropriate. What I want to achieve, in <code>Angular2</code> / <code>RxJS 5</code> is this:</p>

<pre><code>source:   ---1--2--3--4---------5--------6-|--&gt;
notifier: -o------------o-----o---o--o-o------&gt;
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
output:   ---1----------2-----3---4--5---6-|--&gt;
</code></pre>

<p>So, I have a source Observable that emits values, and I want each of them to get into the output only when a second Observable (call it notifier) emits. It's like one event from the notifier means ""allow next to pass through"".</p>

<p>I tried <code>delayWhen</code>, but my main problem with this is that all the source values are waiting for the same one event from the notifier, so for example if 3 source values are ""queued"" and notifier emits once, all 3 values pass through, which is not what I want.</p>
","1118323","","","","","2016-05-31 10:49:16","Emit next value from the source Observable when another Observable, the notifier, emits","<angular><reactive-programming><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"37542744","2","","37541560","2016-05-31 10:08:34","","2","","<p>The answer is <code>zip</code>:</p>

<pre><code>const valueStream = 
    Rx.Observable.from([0, 1, 2, 3, 4, 5, 6]);

const notificationStream = 
    Rx.Observable.interval(1000).take(7);


Rx.Observable
    .zip(valueStream, notificationStream, (val, notification) =&gt; val)
    .subscribe(val =&gt; console.log(val));
</code></pre>

<p>Working example <a href=""http://jsbin.com/diqinuwole/1/edit?js,console"" rel=""nofollow"">here</a>. </p>

<p>This produces a value when a pair is produced from both streams. So the example will print a value from <code>valueStream</code> when <code>notificationStream</code> produces a value.</p>
","1827926","","1827926","","2016-05-31 10:49:16","2016-05-31 10:49:16","","","","0","","","","CC BY-SA 3.0"
"37567851","1","","","2016-06-01 11:51:39","","0","56","<p>Suppose we have a function getIds() which takes an array of some ids
like this:</p>

<pre><code>getIds([4, 1, 32]);
</code></pre>

<p>This function will delay HTTP call for 100ms. But during 100ms if this
same function is called again:</p>

<pre><code>getIds([1, 8, 5]);
</code></pre>

<p>It will reset the 100ms timer and keep merging the passed ids. It will
send HTTP request only if it's not called by anyone for more than 100ms.</p>

<p>I am new to RxJS and here's my attempt to solve this problem but I have
a feeling that there could be better solution for this problem.</p>

<p><a href=""https://jsfiddle.net/iFadey/v3v3L0yd/2/"" rel=""nofollow"">https://jsfiddle.net/iFadey/v3v3L0yd/2/</a></p>

<pre><code>function getIds(ids) {
  let observable = getIds._observable,
      subject = getIds._subject;

  if (!observable) {
    subject = getIds._subject = new Rx.ReplaySubject();
    observable = getIds._observable = subject
      .distinct()
      .reduce((arr, id) =&gt; {
        arr.push(id);
        return arr;
      }, [])
      // Some HTTP GET request will go here
      // whose results may get flatMapped here
      .publish()
      .refCount()
      ;
  }

  ids.forEach((id) =&gt; {
    console.log(id);
    subject.next(id);
  });

  clearTimeout(getIds._timer);
  getIds._timer = setTimeout(() =&gt; {
    getIds._observable = null;
    getIds._subject = null;
    subject.complete();
  }, 100);

  return observable;
}

getIds([1, 2, 3])
.subscribe((ids) =&gt; {
  console.log(ids);
});

getIds([3, 4, 5])
.subscribe((ids) =&gt; {
  console.log(ids);
});
</code></pre>

<p><strong>edit:</strong>
I am looking for an operator which behaves like debounce but without dropping previous values. Instead it must queue them.</p>
","3318915","","3318915","","2016-07-29 17:43:37","2016-07-29 17:43:37","Keep delaying HTTP request until new params are arriving","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37578627","1","","","2016-06-01 20:57:02","","1","814","<p>The following code will close the connection, event further observers exists on the myWebSocketSubject:</p>

<pre><code>myWebSocketSubject.Observable.webSocket('ws://mysocket');
myWebSocketSubject.subscribe();
myWebSocketSubject.multiplex(..).subscribe().unsubscribe()
// the connection closed now
</code></pre>

<p>My expectation was, that the connection gets closed with the last unsubscribe() call (and not with the first one).</p>

<p><strong>Use Case</strong></p>

<p>If I get it right, with the <code>multiplex(..)</code> operator, on create and complete a message is send to the socket, which e.g. allows to un-/subscribe on server side to specific event.</p>

<p>My preferred Web Socket service could therefore look like as below. There exists only one connection, and this single connection provides several streams. On first subscription to the web socket the connection gets created; and with the last unsubscribe call the connection gets closed. For each data-stream a un-/subscribe message is sent once.</p>

<p>I haven't found a solution to use the <code>WebSocketSubject.multiplex(..)</code> method...</p>

<p>Preferred Example Web Socket Service</p>

<pre><code>export class WebSocketService {
    connection: WebSocketSubject&lt;any&gt;;
    constructor() {
        this.connection = Observable.webSocket&lt;any&gt;(_createConfig())
    }

    dataStream(eventType: string): Observable&lt;WebSocketMessage&gt; {
        return connection.multiplex(
            () =&gt; new WebSocketMessage(""WebSocket.Subscribe."" + eventType),
            () =&gt; new WebSocketMessage(""WebSocket.Unsubscribe."" + eventType),
            message =&gt; (message.type == eventType)
        )
        .retry() // reconnect on error and send subscription messages again
        .share(); // send messages on last/fist un-/subscribe on this stream
    }
    // ...
}

export class WebSocketMessage {
    type: string;
    data: any;
    constructor(command: string, data?:any) {
        this.type = command;
        this.data = data || undefined;
    }
}
</code></pre>

<p>I have written the following test case which fails...</p>

<pre><code>it('should able to handle multiple subscriptions', () =&gt; {
      const subject = Observable.webSocket(&lt;any&gt;{url: 'ws://mysocket'});
      const sub1 = subject.subscribe();
      const sub2 = subject.subscribe();

      const socket = MockWebSocket.lastSocket;
      socket.open();

      sinon.spy(socket, 'close');

      sub1.unsubscribe();
      // Fails, because the socket gets closed on first unsubscribe
      expect(socket.close).have.not.been.called;

      sub2.unsubscribe();
      expect(socket.close).have.been.called;
    });
</code></pre>

<p>If I get it right the <code>share</code> operator would do the trick. But after using the operator, the multiplex method is not available.</p>

<p>Thanks for any feedback, input, ...!</p>
","3254861","","3254861","","2016-06-02 08:51:18","2020-09-20 19:35:34","myWebSocketSubject.multiplex(..).subscribe().unsubscribe() closes connection, event further observers exists","<websocket><rxjs5>","0","0","","","","CC BY-SA 3.0"
"37607398","1","","","2016-06-03 06:30:27","","8","1000","<p>I want to use DOM in angular project like this </p>

<pre><code>Rx.DOM.jsonpRequest
</code></pre>

<p>but DOM is not available on Rx which Im importing like this </p>

<pre><code>import Rx = require('rxjs'); 
</code></pre>

<p>I also tried to import rxjs dom but error was can not find module, I installed rxjs-dom like this</p>

<pre><code>npm install rx-lite-dom
</code></pre>

<p>but Im unable to import it so that I can DOM on Rx object</p>
","5710014","","2528234","","2017-05-18 18:09:01","2017-09-25 12:51:43","Angular2: How to import rx-dom","<angular><rxjs><reactive-programming><rxjs5>","1","1","","","","CC BY-SA 3.0"
"37623920","1","37624358","","2016-06-03 21:45:01","","0","61","<p>I am using <strong>ngrx/router</strong>.</p>

<p>I have a <code>LoginGuard</code>, when I open a page which needs to login, the LoginGuard runs before <code>isSignedIn</code> is set to true. So at that time <code>isSignedIn</code> is <code>undefined</code>.</p>

<pre><code>@Injectable()
export class LoginGuard implements Guard {
  constructor(private _router: Router, private _userService: UserService) { }

  protectRoute({ route, params, isTerminal }: TraversalCandidate): Observable&lt;boolean&gt; {
    return this._userService.checkSignedIn()
      .map(isSignedIn =&gt; {
        if (!isSignedIn) {
          this._router.replace('/landing');
          return false;
        } else {
          return true;
        }
      }).first();
  }
}
</code></pre>

<p>I set <code>isSignedIn</code> to <code>true</code> in the beginning of the app, which is the earliest place in my mind.</p>

<pre><code>class App implements OnInit {
  ngOnInit() {
    // I set isSignedIn in UserService to true here after I got user info from the server
  }
}
</code></pre>

<p>But maybe it is not early enough? So how can I set <code>isSignedIn</code> to <code>true</code> before <strong>Guard</strong> runs? Thanks</p>
","2000548","","2000548","","2016-06-04 18:34:49","2016-06-04 18:34:49","How to set isSignedIn to true before Guard runs?","<typescript><angular><router><rxjs5><ngrx>","1","2","","","","CC BY-SA 3.0"
"37624358","2","","37623920","2016-06-03 22:29:48","","0","","<p>My app actually uses a service checking access in an async way. </p>

<p>@rtytgat gives a solution. And thanks!</p>

<blockquote>
  <p>Check with the Guard, if not logged in send them to 'logging in' page,
  and send them back when login has been confirmed.</p>
</blockquote>
","2000548","","2000548","","2016-06-03 23:54:05","2016-06-03 23:54:05","","","","0","","","","CC BY-SA 3.0"
"37626121","1","37664358","","2016-06-04 03:43:07","","1","208","<p>This is how I use <code>routerCanDeactivate</code> in deprecated router:</p>

<pre><code>import { CanDeactivate, ComponentInstruction } from '@angular/router-deprecated';

export class CallComponent implements CanDeactivate {
  routerCanDeactivate(next: ComponentInstruction, prev: ComponentInstruction) {
    // ...
  }
}
</code></pre>

<p>How to do same thing that  does in <strong>ngrx/router</strong>? I didnât find any document.</p>

<p>Thanks</p>
","2000548","","2000548","","2016-06-04 18:34:21","2016-06-07 00:35:39","How to do routerCanDeactivate in ngrx/router?","<typescript><angular><router><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"37633676","1","37633810","","2016-06-04 18:30:56","","2","6741","<p>I am using <strong>ngrx/router</strong>.</p>

<p>When I open <code>http://localhost/set-new-password/abc</code>, the <code>RouteParams</code> works well. I can get the string <code>token</code> I want.</p>

<pre><code>const landingRouter: Routes = [
  { path: '/set-new-password/:token', component: SetNewPasswordComponent },
];

export class SetNewPasswordComponent implements OnInit {
  token: string = '';

  constructor(private _routeParams$: RouteParams) {}

  ngOnInit()
  {
    this._routeParams$
      .pluck('token')
      .subscribe(token =&gt; {
        console.log(typeof token); // Console: ""string""
        console.log(token);        // Console: ""abc""
        this.token = token;        // Terminal: Type '{}' is not assignable to type 'string'.
      });
  }
}
</code></pre>

<p>However, I got this warning in my terminal:</p>

<blockquote>
  <p>Type '{}' is not assignable to type 'string'.</p>
</blockquote>

<p>I know I can use <code>this.token = String(token);</code> to get rid of it.</p>

<p>But why does this warning show? Can someone explain a little bit for me?  Thanks</p>
","2000548","","2000548","","2016-06-04 19:31:32","2016-06-04 19:31:32","Type '{}' is not assignable to type 'string'","<typescript><angular><router><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"37633810","2","","37633676","2016-06-04 18:48:32","","5","","<p>Get help from @brandonroberts to @MikeRyan52's original answer, and thanks!</p>

<blockquote>
  <p>Two reasons why this won't work:</p>
  
  <ol>
  <li><p>We don't actually know the shape of the params object until runtime,
  so there's not a good type to describe it</p></li>
  <li><p>pluck('id') can't be well typed anyways since the string selector
  isn't known</p></li>
  </ol>
  
  <p>Solution would be to explicitly type pluck():</p>

<pre><code>params$.pluck&lt;string&gt;('id')
</code></pre>
</blockquote>

<p>So my situation is changing to:</p>

<pre><code>this._routeParams$
  .pluck&lt;string&gt;('token')
  .subscribe(token =&gt; this.token = token);
</code></pre>
","2000548","","","","","2016-06-04 18:48:32","","","","0","","","","CC BY-SA 3.0"
"37664358","2","","37626121","2016-06-06 18:24:19","","0","","<p>So right now, there is no such feature in <strong>ngrx/router</strong>. I created an issue on GitHub, you can track it here.</p>

<p><a href=""https://github.com/ngrx/router/issues/127"" rel=""nofollow"">https://github.com/ngrx/router/issues/127</a></p>
","2000548","","2000548","","2016-06-07 00:35:39","2016-06-07 00:35:39","","","","0","","","","CC BY-SA 3.0"
"37674363","1","37674661","","2016-06-07 08:35:03","","4","226","<p>I'm working at a TypeScript autocomplete component (for Angular 2, although this is not core to question) and I'd like to manage most (or all) of it through observables in RxJs (5.0.0-beta.8). I'm having problems with tracking current item position in the list of suggestions when acting through up/down arrow keys: the index remains stuck at 0. </p>

<p>All the following logic is set aside in a separate <code>class</code> that receives input observables and produces output observables to subscribe to (that's why is not strictly related to Angular 2). Client code subscribes to output observables correctly.</p>

<p>Here's some code:</p>

<pre class=""lang-ts prettyprint-override""><code>// Component responsible for managing only the list of suggestions
// It receives inputs from text field and it produces outputs 
// as current index in list, when to hide list, etc.
class AutocompleteListDriver {
  currentIndex$: Observable&lt;number&gt;;
  doClose$: Observable&lt;void&gt;;
  // ...

  constructor(...
    matches$: Observable&lt;string[]&gt;, // list of suggestions matching text in field
    keyUp$: Observable&lt;KeyboardEvent&gt;, // keyup events from text field
    keyDown$: Observable&lt;KeyboardEvent&gt;, // keydown events from text field
    ...) {

    const safeMatches$ = matches$
      .startWith([]);  // start with a clear, known state internally

    // when list is empty, component is hidden at rest:
    // detect keys only when component is visible
    const isActive$ = safeMatches$
      .map(matches =&gt; matches.length !== 0);

    const activeKeyUp$ = keyUp$
      .withLatestFrom(isActive$)
      .filter(tuple =&gt; tuple[1]) // -&gt; isActive
      .map(tuple =&gt; tuple[0]);   // -&gt; keyboardEvent

    this.currentIndex$ = safeMatches$
      .switchMap(matches =&gt; {
        const length = matches.length;
        console.log('length: ' + length);

        const initialIndex = 0;

        const arrowUpIndexChange$ = activeKeyUp$
          .filter(isArrowUpKey)
          .map(_ =&gt; -1);

        const arrowDownIndexChange$ = activeKeyUp$
          .filter(isArrowDownKey)
          .map(_ =&gt; +1);

        const arrowKeyIndexChange$ = Observable
          .merge(arrowUpIndexChange$, arrowDownIndexChange$)
          .do(value =&gt; console.log('arrow change: ' + value));

        const arrowKeyIndex$ = arrowKeyIndexChange$
          .scan((acc, change) =&gt; {
            // always bound result between 0 and length - 1
            const index = limitPositive(acc + change, length);

            return index;

          }, initialIndex)
          .do(value =&gt; console.log('arrow key index: ' + value))
          .startWith(0);

        return arrowKeyIndex$;
      })
      .do(value =&gt; console.log('index: ' + value))
      .share();
  }
}
</code></pre>

<p>The idea is that everytime a new list of matches (suggestions) is emitted, current index in list should start a new <em>""sequence""</em>, so to say. Each of those sequences starts from 0, listens for increments/decrements due to arrow down/up keys, accumulate those by taking care not to go beyond lower/upper limits.</p>

<p><em>To start a new sequence</em> to me it translates to <code>switchMap</code>. But with such code, console only shows: </p>

<pre><code>length: 5
index: 0
</code></pre>

<p>and arrow up/down keys are not detected at all (tried inserting other logs on <code>arrowDownIndexChange$</code>), so no more logs and no effect in final component. It's like if their observables are not <em>subscribed</em> anymore, but as far as I know <code>switchMap</code> should subscribe to the latest generated sequence and drop/unsubscribe from all previous ones.</p>

<p>Just to try, I used <code>mergeMap</code> instead: in this case arrow keys are detected, but of course the problem is that all sequences (due to previous moments when matches where set) are merged together and their values overlaps each other. Apart from this being incorrect anyway, from time to time the matches list will go empty, so there's always a point where current index sequence always stays at 0. This sequence merges and overlaps with all the others, giving a net result of index stuck at 0.</p>

<p>What am I doing wrong?</p>
","540776","","","","","2016-06-09 08:53:34","Track current position in typeahead list with observables","<typescript><angular><reactive-programming><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"37674661","2","","37674363","2016-06-07 08:48:40","","3","","<p>Ok. Apparently my former findings through rxjs docs where wrong (and of course I got this <strong>after</strong> writing down the question, then looking for more insights). </p>

<p>It seems that <code>switchMap</code> is not the right tool for the case. What I should use is <code>switch()</code> instead. And this should not come as a surprise, coming from a .Net Reactive Extensions background... but I don't know why the naming changes between languages often catch me wrong.</p>

<p>Working solution should be instead:</p>

<pre class=""lang-ts prettyprint-override""><code>this.currentIndex$ = safeMatches$
  // use map to generate an ""observable of observables""
  // (so called higher-order observable)
  .map(matches =&gt; {
    const length = matches.length;
    // ...
  })
  // ""unwrap"" higher order observable, by always 
  // keeping subscribed to the latest inner observable
  .switch()
  .do(value =&gt; console.log('index: ' + value))
</code></pre>

<p><strong>EDIT</strong><br>
That was not enough. I also had to drop <code>activeKeyUp$</code> in favour of raw <code>keyUp$</code>. </p>

<p>If anyone has other suggestions (or explanations on current behaviour, e.g. activeKeyUp/keyUp), please feel free to answer.</p>

<p><strong>EDIT #2</strong><br>
Thanks to @paulpdaniels comment: it turns out that the only real issue was that <code>activeKeyUp$</code> Vs <code>keyUp$</code> bug. Replacing <code>map().switch()</code> with <code>switchMap()</code> did not harm functionality in any way.</p>
","540776","","540776","","2016-06-09 08:53:34","2016-06-09 08:53:34","","","","2","","","","CC BY-SA 3.0"
"37678987","1","","","2016-06-07 12:09:20","","1","221","<p>I have an ajax call for an insert operation. I need to update a grid (future there might be many) once the ajax call completed. How to do this using Rx Js.</p>

<p>I have done something with event based but it won't work out for my case.</p>

<p>NOTE: save ajax call is in different script file.</p>

<pre><code>var submitButton = document.querySelector('.btn-primary');
var refresh1ClickStream = Rx.Observable.fromEvent(submitButton, 'click');
var requestStream = refresh1ClickStream.startWith('startup click')
    .map(function () {
        var max = 10;
        return 'http://localhost/.../GetPayments';
    });
var responseStream = requestStream
    .flatMap(function (requestUrl) {
        return Rx.Observable.fromPromise($.getJSON(requestUrl));
    });


function createSuggestionStream(closeClickStream) {
    return closeClickStream.startWith('startup click')
        .combineLatest(responseStream,
            function (click, data) {
                return data;
            }
        )
        .merge(
            refresh1ClickStream.map(function () {
                return null;
            })
        )
        .startWith(null);
}

var paymentStream = createSuggestionStream(refresh1ClickStream);
//var pfaStream = createSuggestionStream(refresh1ClickStream);

// Rendering ---------------------------------------------------
function renderSuggestion(payments, selector) {
    //render grid
}


paymentStream.subscribe(function (payment) {
    renderSuggestion(payment, 'payment1');
});

//pfaStream.subscribe(function (pfa) {
//    renderSuggestion(pfa, 'tblPayFromAccount');
//});
</code></pre>
","4768174","","","","","2016-06-07 12:09:20","Rx Js - create an observer for $.ajax Complete()","<ajax><reactjs><reactive-programming><rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"37754499","1","37762551","","2016-06-10 17:57:05","","1","359","<p>Following this course <a href=""https://www.pluralsight.com/courses/angular-2-getting-started"" rel=""nofollow"">https://www.pluralsight.com/courses/angular-2-getting-started</a> and github materials <a href=""https://github.com/DeborahK/Angular2-GettingStarted/blob/master/APM%20-%20Final/app/products/product.service.ts"" rel=""nofollow"">product.service</a> in that course trying to 
avoid calling http.get() request every time I click the link.
I think it is a big waste to load file every time instead of saving it as an object in memory.</p>

<p>Trying to replace this code:</p>

<pre><code>    getProducts(): Observable&lt;IProduct[]&gt; {
    return this._http.get(this._productUrl)
        .map((response: Response) =&gt; &lt;IProduct[]&gt; response.json())
        .do(data =&gt; console.log('All: ' +  JSON.stringify(data)))
        .catch(this.handleError);
}
</code></pre>

<p>with this one:</p>

<pre><code>    public _observable: Observable&lt;IProduct[]&gt;;

    getProducts(): Observable&lt;IProduct[]&gt; {
    console.log('_observable before: ' + (this._observable));
    if(this._observable===undefined){
        console.log('_observable inside 1: ' + (this._observable));
        this._observable=this._http.get(this._productUrl)
            .map((response: Response) =&gt; &lt;IProduct[]&gt; response.json())
            .do(data =&gt; console.log('All inside observable: ' +  JSON.stringify(data)))
            .catch(this.handleError);
        console.log('_observable inside 2: ' + (this._observable));
    }

    console.log('_observable after: ' + (this._observable));
    return this._observable;
}
</code></pre>

<p>this line should never be called if <code>this._observable</code> is underfined   <code>this._observable=this._http.get(this._productUrl)</code>  </p>

<p>BUT IT IS CALLED!!!!</p>

<p>In a chrome console:</p>

<pre><code>_observable before: [object Object]
product.service.ts:25 _observable after: [object Object]
product.service.ts:20 All inside observable:...
</code></pre>

<p>Last line shouldn't appear!</p>
","5148638","","215945","","2016-06-12 02:59:25","2016-06-12 02:59:25","How to cache and share Http get() response?","<angular><rxjs5><angular2-http>","3","4","","2016-06-12 09:00:47","","CC BY-SA 3.0"
"37759888","1","37760757","","2016-06-11 04:22:58","","3","2914","<p>I have some pre-defined events set to occur at specific times.
And I have a timer, like this:</p>

<pre><code>const timer = Rx.Observable.interval(100).timeInterval()
    .map(x =&gt; x.interval)
    .scan((ms, total) =&gt; total + ms, 0)
</code></pre>

<p>The timer emits something close to 100,200,300,400,500 (although in reality it's more like 101,200,302,401,500...which is totally fine)
I also have some stuff I want to do at certain times. For example, let's say I want to do stuff at the following times:</p>

<pre><code>const stuff = Rx.Observable.from([1000, 2000, 2250, 3000, 5000]);
</code></pre>

<p>What I'd like is to combine ""stuff"" and ""timer"" in such a way that the resulting stream emits a value once per time defined in ""stuff"" at that time (or ever so slightly later). in this case, that would be t=1000 ms, 2000 ms, 2250 ms, 3000 ms and 5000 ms. Note: the 2250 guy should emit around time 2300 because of the interval size. that's fine. they just can't come early or more than once.</p>

<p>I have one solution, but it's not very good. it re-starts ""stuff"" every single step (every single 100 ms in this case) and filters it and takes 1. I would prefer that, once an event is emitted from ""stuff"", that it be gone, so subsequent filters on it don't have those values.</p>

<p>In the real application, there will be stuff and stuff2 and maybe stuff3...(but I will call them something else!)</p>

<p>Thanks in advance! I hope that was clear.</p>
","2073082","","","","","2021-01-22 16:29:12","RxJs: How to emit events at predefined times?","<events><rxjs><rxjs5><timed>","2","0","","","","CC BY-SA 3.0"
"37760757","2","","37759888","2016-06-11 06:38:41","","6","","<p>If I've understood what you're after correctly, this should be achievable with a simple projection:</p>

<pre><code>const times$ = stuff.flatMap(x =&gt; Rx.Observable.timer(x));
</code></pre>

<p>Here's a working sample: <a href=""https://jsbin.com/negiyizibu/edit?html,js,console,output"" rel=""noreferrer"">https://jsbin.com/negiyizibu/edit?html,js,console,output</a></p>

<p>Edit</p>

<p>For the second requirement, try something like this:</p>

<pre><code>const times$ = Rx.Observable
                 .from([{""val"":""jeff"", ""t"": 1000}, {""val"":""fred"", ""t"": 2500}])
                 .flatMap(x =&gt; Rx.Observable.timer(x.t).map(y =&gt; x.val));
</code></pre>

<p><a href=""https://jsbin.com/cegijudoci/edit?js,console,output"" rel=""noreferrer"">https://jsbin.com/cegijudoci/edit?js,console,output</a></p>
","1855065","","1855065","","2016-06-11 10:40:39","2016-06-11 10:40:39","","","","6","","","","CC BY-SA 3.0"
"37762551","2","","37754499","2016-06-11 10:17:04","","1","","<p>To avoid file being loaded you need to include to lines of code inside if statements:</p>

<pre><code>            .publishReplay(1)
            .refCount()
</code></pre>

<p>The full code goes here:</p>

<pre><code>    getProducts(): Observable&lt;IProduct[]&gt; {
    console.log('_observable before: ' + (this._observable));
    if(this._observable===undefined){
        console.log('_observable inside 1: ' + (this._observable));
        this._observable=this._http.get(this._productUrl)
            .map((response: Response) =&gt; &lt;IProduct[]&gt; response.json())
            .publishReplay(1)
            .refCount()
            .do(data =&gt; console.log('All inside observable: ' +  JSON.stringify(data)))
            .catch(this.handleError);
        console.log('_observable inside 2: ' + (this._observable));
    }

    console.log('_observable after: ' + (this._observable));
    return this._observable;
}
</code></pre>
","5148638","","","","","2016-06-11 10:17:04","","","","0","","","","CC BY-SA 3.0"
"37768680","1","","","2016-06-11 21:30:52","","2","882","<p>I am still learning RXJS(just started), I know my question would be of starters. I am trying to combine two responses from external call. Say I make call1 and call2 and I should be able to subscribe with one combined response. </p>

<p>Below is my code</p>

<pre><code>var arrayWeather =['http://apidev.accuweather.com/currentconditions/v1/250111.json?language=en&amp;apikey=hoArfRosT1215', 'http://apidev.accuweather.com/currentconditions/v1/4-204108_1_AL.json?language=en&amp;apikey=hoArfRosT1215'];
var refreshClickStream = Rx.Observable.fromEvent(document.querySelector('.refresh'), 'click');

refreshClickStream.subscribe(function(e){
  Rx.Observable.fromArray(arrayWeather)
    .flatMap(function(datathings){ 
        return Rx.DOM.Request.get(datathings)
    })
    .subscribe(function(data){
        console.log(data.response);
    });
});
</code></pre>
","1577298","","","","","2016-06-11 21:37:54","Combine two ajax response in RXJS","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37771855","1","37777382","","2016-06-12 07:42:06","","75","116887","<p>I'm learning RxJS and Angular 2. Let's say I have a promise chain with multiple async function calls which depend on the previous one's result which looks like: </p>

<pre><code>var promiseChain = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(1);
  }, 1000);
}).then((result) =&gt; {
  console.log(result);

  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(result + 2);
    }, 1000);
  });
}).then((result) =&gt; {
  console.log(result);

  return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
      resolve(result + 3);
        }, 1000);
  });
});

promiseChain.then((finalResult) =&gt; {
  console.log(finalResult);
});
</code></pre>

<p>My attempts at doing the same solely using RxJS without the use of promises produced the following:</p>

<pre><code>var observableChain = Observable.create((observer) =&gt; {
  setTimeout(() =&gt; {
    observer.next(1);
    observer.complete();
  }, 1000);
}).flatMap((result) =&gt; {
  console.log(result);

  return Observable.create((observer) =&gt; {
    setTimeout(() =&gt; {
      observer.next(result + 2);
      observer.complete()
    }, 1000);
  });
}).flatMap((result) =&gt; {
  console.log(result);

  return Observable.create((observer) =&gt; {
    setTimeout(() =&gt; {
      observer.next(result + 3);
      observer.complete()
    }, 1000);
  });
});

observableChain.subscribe((finalResult) =&gt; {
  console.log(finalResult);
});
</code></pre>

<p>It yields the same output as the promise chain. My questions are</p>

<ol>
<li><p>Am I doing this right? Are there any RxJS related improvements that I can make to the above code</p></li>
<li><p>How do I get this observable chain to execute repeatedly? i.e. Adding another subscription at the end just produces an additional 6 though I expect it to print 1, 3 and 6.</p>

<p>observableChain.subscribe((finalResult) => {
  console.log(finalResult);
});</p>

<p>observableChain.subscribe((finalResult) => {
  console.log(finalResult);
});</p>

<p>1
3
6
6</p></li>
</ol>
","454378","","3743222","","2016-09-07 11:43:32","2016-09-07 11:43:32","Chaining Observables in RxJS","<javascript><promise><reactive-programming><rxjs><rxjs5>","1","1","16","","","CC BY-SA 3.0"
"37773493","1","","","2016-06-12 11:05:04","","1","3800","<p>I have a class that when instantiated makes some web service calls, pseudo code below:</p>

<pre><code>Rx.Observable.fromPromise(jQuery.getJSON('https://api.github.com/users'))
 .flatMap(function () {
   return Rx.Observable.fromPromise(jQuery.getJSON('https://api.github.com/users'));  
 });
</code></pre>

<p>The same class is listening for an onclick event.</p>

<p>When this even is triggered, if the original web service calls are complete: do something</p>

<p>If they are <em>not</em> complete, wait for them to complete, before doing something.</p>

<p>I was wondering how to achieve this with the rxjs approach? rather than setting variables and using if statements.</p>
","816444","","","","","2016-06-20 00:36:02","checking if rxjs observable is complete","<rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"37777382","2","","37771855","2016-06-12 17:55:24","","58","","<p>About promise composition vs. Rxjs, as this is a frequently asked question, you can refer to a number of previously asked questions on SO, among which :</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/37748241/how-to-do-the-chain-sequence-in-rxjs/37748799#37748799"">How to do the chain sequence in rxjs</a></li>
<li><a href=""https://stackoverflow.com/questions/34701304/rxjs-promise-composition-passing-data/34701912#34701912"">RxJS Promise Composition (passing data)</a></li>
<li><a href=""https://stackoverflow.com/questions/34523338/could-anyone-give-me-a-sample-of-rxjs-sequence-equvalent-to-promise-then"">RxJS sequence equvalent to promise.then()?</a></li>
</ul>

<p>Basically, <code>flatMap</code> is the equivalent of <code>Promise.then</code>.</p>

<p>For your second question, do you want to replay values already emitted, or do you want to process new values as they arrive? In the first case, check the <code>publishReplay</code> operator. In the second case, standard subscription is enough. However you might need to be aware of the cold. vs. hot dichotomy depending on your source (cf. <a href=""https://stackoverflow.com/questions/32190445/hot-and-cold-observables-are-there-hot-and-cold-operators"">Hot and Cold observables : are there &#39;hot&#39; and &#39;cold&#39; operators?</a> for an illustrated explanation of the concept)</p>
","3743222","","-1","","2017-05-23 12:34:47","2016-06-12 17:55:24","","","","2","","","","CC BY-SA 3.0"
"37782063","1","37782286","","2016-06-13 04:57:04","","0","41","<p>I have a list of products. Each product has an <code>id</code> and <code>description</code>.</p>

<pre><code>&lt;div *ngFor=""let product of products""&gt;
  &lt;input type=""text"" [ngModel]=""product.description"" (ngModelChange)=""onEdit($event, product.id)""&gt;
&lt;/div&gt;
</code></pre>

<hr>

<pre><code>editStream: EventEmitter&lt;any&gt; = new EventEmitter();

ngOnInit() {
  this.editStream
    .debounceTime(1000)
    .distinctUntilChanged()
    .mergeMap(x =&gt; Observable.of(x))
    .subscribe(x =&gt; {
      // based on product id, update its description in the database
    });

}

private onEdit(description: string, id: string) {
  this.editStream.emit({ description, id });
}
</code></pre>

<p>It works well when I edit one product's description.</p>

<p>However, if I edit <code>product1</code>'s description, then edit <code>product2</code>'s description immediately (time interval is less than 1s), only <code>product2</code>'s description will be updated.</p>

<p>I guess this is because <code>product2</code>'s event overwrites <code>product1</code>'s event, and I only subscribe at one place.</p>

<p>How can I solve this? Thanks</p>
","2000548","","2000548","","2016-06-13 05:44:52","2016-06-13 05:46:32","How to avoid overwriting event when productId is different?","<typescript><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37782286","2","","37782063","2016-06-13 05:19:44","","2","","<p>If you want to use <code>distinctUntilChanged()</code> you need a different <code>Observable</code> for each <code>product</code>. </p>

<pre><code>this.products.forEach(p =&gt; this.editStreams.push(new EventEmitter())
</code></pre>



<pre><code>&lt;div *ngFor=""let product of products let i=index""&gt;
  &lt;input type=""text"" [ngModel]=""product.description"" (ngModelChange)=""onEdit($event, i, product.id)""&gt;
&lt;/div&gt;
</code></pre>



<pre><code>private onEdit(description: string, id: string) {
  this.editStreams[i].emit({ description, id });
}
</code></pre>
","217408","","217408","","2016-06-13 05:46:32","2016-06-13 05:46:32","","","","5","","","","CC BY-SA 3.0"
"37798320","1","","","2016-06-13 20:10:30","","2","1737","<p>I'm creating an angular2 app and I've got a service that I want to be able to write to in one component and then read/update it in other components (routes).  </p>

<p>Here's what my service looks like currently: </p>

<pre><code>import { Injectable } from '@angular/core';
import { Filer } from './filer.model';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';

@Injectable()
export class FilerService {
  public _filer: Subject&lt;Filer&gt;;

  constructor() {
    this._filer = new Subject();
  }

  setSelected(ret: Filer) {
    let temp = ret;
    this._filer.next(temp);
  }

  get selected(): Observable&lt;Filer&gt; {
    return this._filer.asObservable();
  }

}
</code></pre>

<p>since I'm using <code>Subject</code>, only components that are subscribed will be able to see any values.  I tried changing it to a <code>BehaviorSubject</code>, based on the rxjs docs.  Here's what that looks like:</p>

<pre><code>import { Injectable } from '@angular/core';
import { Filer } from './filer.model';
import { Observable } from 'rxjs/Observable';
import { Observer } from 'rxjs/Observer';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

@Injectable()
export class FilerService {
  public _filer: BehaviorSubject&lt;Filer&gt;;

  constructor() {
    this._filer = new BehaviorSubject({});
  }

  setSelected(ret: Filer) {
    let temp = ret;
    this._filer.onNext(temp);
  }

  get selected(): Observable&lt;Filer&gt; {
    return this._filer.asObservable();
  }

}
</code></pre>

<p>However, I get <code>Property 'onNext' does not exist on type 'BehaviorSubject&lt;Filer&gt;'.</code>, so I'm not sure where to go from here.  Any ideas? </p>

<p>I'm on rxjs 5.0.0-beta.6.</p>
","1226755","","","","","2016-10-23 12:38:12","Property 'onNext' does not exist on type 'BehaviorSubject<Filer>'","<angular><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"37816907","1","37820557","","2016-06-14 15:58:23","","4","1511","<p>When two subscribers subscribe to an observable:</p>

<pre><code>  let s = Observable.interval(1000).take(2).do(x =&gt; console.log('hey'));
  s.subscribe(n =&gt; console.log('subscriber  1 = ' + n));
  s.subscribe(n =&gt; console.log('subscriber  2 = ' + n));
</code></pre>

<p>The console logs the following: </p>

<blockquote>
  <p>'hey'
   'subscriber  1 = 0'
   'hey'
   'subscriber  2 = 0'
   'hey'
   'subscriber  1 = 1'
   'hey'
   'subscriber  2 = 1'</p>
</blockquote>

<p>Using <code>.share()</code>:</p>

<pre><code>let s = Observable.interval(1000).take(2).do(x =&gt; console.log('hey')).share();
  s.subscribe(n =&gt; console.log('subscriber  1 = ' + n));
  s.subscribe(n =&gt; console.log('subscriber  2 = ' + n));
</code></pre>

<p>the console logs:</p>

<blockquote>
  <p>'hey'
   'subscriber  1 = 0'
   'subscriber  2 = 1'
   'hey'
   'subscriber  1 = 0'
   'subscriber  2 = 1'</p>
</blockquote>

<p>So, i managed to share the same data to more than 1 subscribers.
Executing the following test: </p>

<pre><code>let s = Observable
    .from([-1, 0, 1, 2, 3])
    .filter(v =&gt; v &gt; 0)
    .do(v =&gt; console.log('from', v));

  s.filter(v =&gt; v % 3 === 0)
    .subscribe(v =&gt; console.log('---0---', v));
  s.filter(v =&gt; v % 3 === 1)
    .subscribe(v =&gt; console.log('---1---', v));
  s.filter(v =&gt; v % 3 === 2)
    .subscribe(v =&gt; console.log('---2---', v));        
</code></pre>

<p>logs: </p>

<blockquote>
  <p>'from', 1 'from', 2 'from', 3 '---0---',3 'from', 1 '---1---',1
  'from', 2 'from', 3 'from', 1 'from', 2 '---2---', 2 'from', 3</p>
</blockquote>

<p>Once again, i used <code>share()</code>:</p>

<pre><code> let s = Observable
    .from([-1, 0, 1, 2, 3])
    .filter(v =&gt; v &gt; 0)
    .do(v =&gt; console.log('from', v))
    .share();

  s.filter(v =&gt; v % 3 === 0)
    .subscribe(v =&gt; console.log('---0---', v));
  s.filter(v =&gt; v % 3 === 1)
    .subscribe(v =&gt; console.log('---1---', v));
  s.filter(v =&gt; v % 3 === 2)
    .subscribe(v =&gt; console.log('---2---', v));
});
</code></pre>

<p>Even though i used <code>share()</code>, the from data were logged in exactly the same way as the previous attempt without <code>share()</code> (from 1 from 2 from 3 were logged 3 times each, 1 for each subscriber).</p>

<p>So, what's the difference between the observables in these examples?</p>

<p>How can i share the data in the second case?</p>
","3757195","","3757195","","2016-06-14 16:52:13","2016-06-14 19:55:51","One Observable, Multiple Subscribers, Different cases, Different share() behavior using rxjs5","<javascript><angular><reactive-programming><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37820557","2","","37816907","2016-06-14 19:29:20","","3","","<p>With Rxjs 4 you should see <code>from 1 from 2 from 3</code> only once. However, you will only have one filter logging. <code>Rx.Observable.from(array)</code> is emitting its sequence synchronously. As such, when <code>s.filter(v =&gt; v % 3 === 0).subscribe(v =&gt; console.log('---0---', v));</code> is executed, your <code>s</code> observable is already completed. You can see that here : <a href=""http://jsfiddle.net/mLra2nL4/"" rel=""nofollow"">[jsfiddle]</a>. Output is :</p>

<pre><code>from 1
from 2
from 3
---0--- 3
</code></pre>

<p>In Rxjs 5, the <code>share</code> operator now restarts the source when it has ended AND a new subscriber subscribes.  At the second filter, <code>s</code> is restarted. So you go three times through the source sequence production process. </p>

<p>To convince you of that, turn your synchronous sequence into an asynchronous sequence : <a href=""http://jsfiddle.net/1rqqvt28/"" rel=""nofollow"">jsfiddle</a>. You should now get, which is what you expected :</p>

<pre><code>from 1
---1--- 1
from 2
---2--- 2
from 3
---0--- 3
</code></pre>

<p>Curiously enough, this is not documented in the <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""nofollow"">migration guide</a>. You can however find some information about what motivated the changes <a href=""https://github.com/ReactiveX/rxjs/issues/453#issuecomment-145165630"" rel=""nofollow"">here</a> and <a href=""https://github.com/ReactiveX/rxjs/issues/453#issuecomment-152276434"" rel=""nofollow"">here</a> (in short you get improved <code>repeat</code> and <code>retry</code> semantics).</p>

<p>That said, you can still have the Rxjs 4 <code>share</code> operator by using <code>publish().refCount()</code>. But as explained before, your second filter will see no data because the source will already have completed. See here : <a href=""http://jsfiddle.net/7nbww2av/"" rel=""nofollow"">jsfiddle</a>. </p>
","3743222","","3743222","","2016-06-14 19:55:51","2016-06-14 19:55:51","","","","0","","","","CC BY-SA 3.0"
"37822012","1","37822541","","2016-06-14 21:01:12","","1","574","<p>I normally use scan like this:</p>

<p><code>Observable.interval(10).take(10).scan((acc, x) =&gt; acc.concat(x), []).subscribe...</code></p>

<p>Now, in the first parameter of scan, instead of a synchronous method I want to pass a method that gets (acc, x) and returns Observable of new acc. (eg. a method that saves to dB and returns the saved object with info that comes from db, like revision number, which is then added in the accumulator).</p>

<p>I found the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeScan"" rel=""nofollow"">mergeScan operator</a> which seems to have exactly the signature I want, but I cant find any example and when I try it I get <code>Property 'mergeScan' does not exist on type Observable&lt;number&gt;</code>.</p>

<p>What I tried is this:</p>

<pre><code>Observable.interval(10).take(10)
        .mergeScan((acc, x) =&gt; Observable.of(acc.concat(x)), [])
        .subscribe(x =&gt; console.log(x));
</code></pre>

<p>I'm using rxjs5 in Angular2</p>
","1118323","","","","","2016-06-14 21:36:27","Scan operator with asynchronous code","<angular><reactive-programming><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37822541","2","","37822012","2016-06-14 21:36:27","","2","","<p>I can see this operator in the version 5.0.0-beta.6 of Rxjs.</p>

<p>Do you try to import the operator this way:</p>

<pre><code>import 'rxjs/add/operator/mergeScan';
</code></pre>
","1873365","","","","","2016-06-14 21:36:27","","","","0","","","","CC BY-SA 3.0"
"37823072","2","","35772998","2016-06-14 22:20:19","","1","","<p>I've been looking for that operator too! I came up with a solution for my needs that I hope will help yours. It's not the best solution most likely, but I hope it can help until a better solution can be found by some others on here, or until this operator is added back in 5.0 (hopefully!) :) </p>

<pre><code>var Observable = Rx.Observable;

var source1 = Observable.create(function(observer){
    observer.error();
});
var source2 = Observable.create(function(observer){
    observer.next('Continuing on');
    observer.complete();
});


var stream = source1.catch(function(data){
  return source2;
});



stream.subscribe(function(data){
  console.log(data);
});
</code></pre>

<p>JS Bin Example: <a href=""https://jsbin.com/qadozoveta/edit?html,js,console"" rel=""nofollow"">https://jsbin.com/qadozoveta/edit?html,js,console</a></p>
","3881882","","","","","2016-06-14 22:20:19","","","","0","","","","CC BY-SA 3.0"
"37839198","1","37839803","","2016-06-15 15:05:29","","2","570","<p>I'm trying to write a basic angular 2 app, which uses the new version of RxJS -> ""rxjs"": ""5.0.0-beta.6"".</p>

<p>I have followed the instructions from the <a href=""https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#bidirectional-service"" rel=""nofollow"">cookbook</a>, trying to make a notifications service, which any part of my app could call to show a message.</p>

<p>The issue I'm having is that when I call <code>.next()</code> to add the next notification, this is not picked up by the subscription. The <code>this.displayMessage(notification);</code> line doesn't run after a call to <code>newNotification</code>. I added the BehaviourSubject type to my code (as opposed to the Subject used in the tutorial) and found the initial value was picked up by the subscription - the <code>this.displayMessage(notification);</code> was called successfully on initialization. This makes me think it is something to do with how/where I am calling .next() in the <code>NotificationService</code> class.</p>

<p>Here are the relevant classes:</p>

<p><strong>NotificationService:</strong></p>

<pre class=""lang-js prettyprint-override""><code>import { Injectable } from '@angular/core';
import { BehaviorSubject }    from 'rxjs/BehaviorSubject';
import { Notification } from '../notification/notification';

@Injectable()
export class NotificationService {
  // Observable string sources
  private notificationSource = new BehaviorSubject&lt;Notification&gt;(new Notification({message:""test"", priority:-1}));
  notifications$ = this.notificationSource.asObservable();

  newNotification(message: string, priority: number) {
    this.notificationSource.next(new Notification({ message, priority }));
  }

}
</code></pre>

<p><strong>MessageComponent:</strong></p>

<pre class=""lang-js prettyprint-override""><code>import { Component, OnDestroy, OnInit } from '@angular/core';

import { Notification } from '../notification/notification';
import { NotificationService } from '../notification.service/notification.service';
import {MdIcon, MdIconRegistry} from '@angular2-material/icon';
import { Subscription }   from 'rxjs/Subscription';

@Component({
  selector: 'message-container',
  styleUrls: ['./app/message/message.component.css'],
  templateUrl: './app/message/message.component.html',
  directives: [MdIcon],
  providers: [NotificationService, MdIconRegistry]

})
export class MessageComponent implements OnDestroy, OnInit {
  notification: Notification;
  subscription: Subscription;
  constructor(
    private notificationService: NotificationService) {
    this.notificationService = notificationService;
  }
  ngOnInit() {
    this.subscription = this.notificationService.notifications$.subscribe(
      notification =&gt; {
        this.displayMessage(notification);
      }, err =&gt; console.log(err), () =&gt; console.log(""completed: ""));
  }

  displayMessage(notification: Notification) {
    this.notification = notification;
    window.setTimeout(() =&gt; { this.notification = null }, 3000);
  }
  ngOnDestroy() {
    // prevent memory leak when component destroyed
    this.subscription.unsubscribe();
  }
}
</code></pre>

<p>If anyone has any ideas about other things to try that would be great.
Many thanks</p>

<p>Edit:
full repo here:
<a href=""https://github.com/sandwichsudo/sentry-material/tree/notifications/src/app"" rel=""nofollow"">https://github.com/sandwichsudo/sentry-material/tree/notifications/src/app</a></p>
","1652270","","1652270","","2016-06-15 15:40:35","2016-06-15 15:40:35","RxJS .next() failing silently in Angular 2 App","<angular><rxjs5><subject-observer>","1","0","1","","","CC BY-SA 3.0"
"37839803","2","","37839198","2016-06-15 15:33:06","","2","","<p>GitHub doesn't find <code>NotificationService</code> in your repository. </p>

<p>I assume that you are providing <code>NotificationService</code> more than once and therefore different instances are created with the result that you are subscribing to one instance and sending on another instance.</p>

<p>Ensure you have <code>NotificationService</code> either <strong>only</strong> in <code>bootstrap(AppComponent, [NotificationService, ...])</code> <strong>or only</strong> in <code>providers: [NotificationService]</code> in your <code>AppComponent</code>. Remove it from <code>providers: [...]</code> from all other components and directives.</p>
","217408","","","","","2016-06-15 15:33:06","","","","7","","","","CC BY-SA 3.0"
"37903474","1","37904341","","2016-06-19 02:39:14","","0","244","<p>I have some RxJS code using mongo to perform queries. Works fine in RxJS v4 but as I am migrating to v.5 I am running into issues.</p>

<p>Here's some simplified code:</p>

<pre><code>// Get a mongo connection
getDb() {
  var connect = Rx.Observable.bindNodeCallback(mongodb.connect)
  return connect(this.options.connection.uri, this.options.connection.options)
}

// Query
return getDb()
  .flatMap((db) =&gt; {
    var c = db.collection('foo')
    var obs = Rx.Observable.bindNodeCallback(c.insertMany, c)
    return obs(docs)
  })
  .subscribe(...)
</code></pre>

<p>Every time I try some sort of query it fails with various errors. All the errors are related to an <code>options</code> object not existing inside the Mongo code. I think this may be a context issue but I am not sure.</p>

<p>The query above yields (in the code, undefined is a mongo collection options object)</p>

<pre><code>Uncaught TypeError: Cannot read property 'serializeFunctions' of undefined
at BoundNodeCallbackObservable.Collection.insertMany[as callbackFunc](node_modules / mongodb / lib / collection.js: 482: 74)
</code></pre>

<p>A similar query yields:</p>

<pre><code>TypeError: Cannot read property 'options' of undefined
at BoundNodeCallbackObservable.Collection.remove[as callbackFunc](node_modules / mongodb / lib / collection.js: 1223: 12)
</code></pre>

<p><strong>Update</strong> When I wrap it manually things work:</p>

<pre><code>var obs = Rx.Observable.create(function(observer) {
   c.insertMany(docs, function(err, res) {
     if (err) { observer.error(err) } else {
       observer.next(res);
       observer.complet();
      }
    })
  })
  return obs

 // This doesn't:
 var obs = Rx.Observable.bindNodeCallback(c.insertMany, c)
 return obs(docs)
</code></pre>
","856498","","856498","","2016-06-19 05:43:54","2016-06-19 05:47:43","RxJS5 Mongo issue","<mongodb><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"37904341","2","","37903474","2016-06-19 05:47:43","","2","","<p>Ok. Turns out <code>bindNodeCallback</code> and <code>bindCallback</code> do not allow for context to be passed. So we need to do this:</p>

<pre><code>c.insertMany = c.insertMany.bind(c)
var obs = Rx.Observable.bindNodeCallback(c.insertMany)
</code></pre>
","856498","","","","","2016-06-19 05:47:43","","","","2","","","","CC BY-SA 3.0"
"37917213","1","","","2016-06-20 07:55:08","","1","186","<p>We don't really (standard REST apis to my knowledge) keep looking for values of the response over a period of time, unless the response is huge. </p>

<p>Can somebody guide me as (why?) a Http response is modeled as Observable?</p>

<p>What am I missing?</p>
","2371715","","","","","2016-06-20 07:55:08","What is the purpose of defining Http response as Observable in Angular 2?","<angular><rxjs><observable><rxjs5>","0","5","","2016-06-20 07:56:21","","CC BY-SA 3.0"
"37926371","1","37931742","","2016-06-20 15:31:31","","1","1290","<p>I am trying to schedule a long polling mechanism. And I was wondering if I could leverage Schedulers for that.</p>

<p>Here's what I have been thinking so far.</p>

<ol>
<li><p>Schedule via timer, but only enqueue next iteration if previous iteration has already finished.</p></li>
<li><p>Enqueue next iteration as previous iteration is finishing.</p></li>
</ol>

<p>I have been looking at existing schedulers, but I am not really sure which one to pick and what to overload.</p>

<p>And last but not least - as I am a novice in Rx world - what are the advantages that the use of Scheduler would offer vis-a-vis ""roll your own"" approach.</p>
","861170","","","","","2016-06-20 20:59:56","How do I - Long polling and Schedulers?","<angular><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"37931742","2","","37926371","2016-06-20 20:59:56","","4","","<p>Something like this:</p>

<pre><code>Observable.interval(500)
.exhaustMap(() =&gt; this.load()) //previously flatMapFirst, creates new observable only if previous has ended
.map(r =&gt; resource.json)
.distinctUntilChanged() //optional tracking changes
.startWith(0); 
</code></pre>
","491265","","","","","2016-06-20 20:59:56","","","","1","","","","CC BY-SA 3.0"
"37959306","1","","","2016-06-22 05:32:20","","0","355","<p>Suppose I requested for data in angularfire2 like this:</p>

<pre><code>var ref = new Firebase(""firebase url"");
</code></pre>

<p>Now how can I apply rxjs operator like map operator to the data coming </p>
","5710014","","","","","2016-09-16 14:44:54","How to apply rxjs operator to data got from angularfire2","<firebase><angularfire><firebase-realtime-database><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"37992519","1","","","2016-06-23 13:04:58","","1","925","<p>I am creating Observable from Array.</p>

<p>When I use simple ""map"" without the   + "" is a number"" addition, all works</p>

<p>How to make the Observable transform data with this addition.</p>

<p>This is crucial part for me to use rxjs for tracking the state and enfoce immutability, I will only change the state and rxjs complex functions will parse the data realtime.</p>

<p>I know there are some solutions, but I need this simple example to work somehow. </p>

<p>Anyone?</p>

<pre><code>import { Component } from '@angular/core';
import * as Rx from 'rxjs/Rx'
import { Observable } from 'rxjs'

@Component({
  selector: 'my-app',
  template: `
    &lt;button (click)=""addToArray()""&gt;Add&lt;/button&gt;
    &lt;ul&gt;
      &lt;li *ngFor=""let item of data$ | async""&gt;{{ item }}&lt;/li&gt;
    &lt;/ul&gt;


  `
})
export class AppComponent {

  data = [""one"",""two"",""three""]
  data$: Observable&lt;Array&lt;string&gt;&gt;;

  ngOnInit() {
    this.data$ = Rx.Observable.from(this.data)
      .map(data =&gt; {
        return data + "" is a number""
      })
  }

  addToArray() {
    this.data.push('more numbers')
  }
}
</code></pre>

<p>The .from manual: <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/from.md"" rel=""nofollow"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/from.md</a></p>
","6024613","","","","","2016-07-02 10:20:10","Mapped Array to Observable, updating Array propagate to Observable?","<typescript><angular><rxjs><rxjs5>","0","6","","","","CC BY-SA 3.0"
"38005750","1","38007053","","2016-06-24 04:45:24","","1","6291","<p>In <code>ngOnInit()</code> I have ""return x"" which I want to put into <code>Observable</code>, then perform transformations and return again in the same format.</p>

<p>Here is the working plunker: <a href=""http://plnkr.co/edit/z26799bSy17mAL4P5MiD?p=preview"" rel=""nofollow"">http://plnkr.co/edit/z26799bSy17mAL4P5MiD?p=preview</a></p>

<pre><code>import {Component} from '@angular/core'
import { Observable } from 'rxjs'
import * as Rx from 'rxjs/Rx'

@Component({
  selector: 'my-app',
  providers: [],
  template: `
    &lt;div&gt;
      &lt;h2&gt;{{name}}&lt;/h2&gt;

      &lt;button (click)=""addToArray()""&gt;Add&lt;/button&gt;
      &lt;ul&gt;
        &lt;li *ngFor=""let item of data$ | async""&gt;{{ item }}&lt;/li&gt;
      &lt;/ul&gt;

    &lt;/div&gt;
  `,
  directives: []
})
export class App {

  data = [""one"",""two"",""three""]
  data$: Observable&lt;Array&lt;string&gt;&gt;;

  constructor() {
    this.name = 'Angular2 array to observable example'
  }

  ngOnInit() {
    this.data$ = Rx.Observable.of(this.data)
      .map(data =&gt; {
        let x = data
        x.push(""4"")

        ///
        ///  TRANSFORM X IN THIS SECTION OF THE CODE
        ///  HERE BY PUTTING IT INTO OBSERVABLE
        ///  PERFORMING TRANSFORMATIONS AND
        ///  RETURNING THE DATA TO BE RENDERED IN TEMPLATE
        ///

        return x
      })
  }

  addToArray() {
    this.data.push('more numbers')
  }      
}
</code></pre>
","6024613","","1679310","","2016-06-24 06:40:54","2016-06-24 08:07:43","Convert Array to Observable, perform transformations and return again as Array?","<typescript><angular><rxjs><rxjs5><reactive-extensions-js>","1","4","","","","CC BY-SA 3.0"
"38007053","2","","38005750","2016-06-24 06:38:29","","1","","<p>There is <a href=""http://plnkr.co/edit/l1ASlbJvA12LcDyLvBFd?p=preview"" rel=""nofollow"">an adjusted and wirking plunker</a></p>

<p>I would implement that with an <code>EventEmitter</code> and few operators, mostly </p>

<ul>
<li><a href=""http://reactivex.io/documentation/operators/startwith.html"" rel=""nofollow"">startWith</a> and </li>
<li><a href=""http://reactivex.io/documentation/operators/scan.html"" rel=""nofollow"">scan</a></li>
</ul>

<p>adjusted code</p>

<pre><code>  data = [""one"",""two"",""three""]
  data$: Observable&lt;string[]&gt;;
  protected emitter = new EventEmitter&lt;string[]&gt;(); 

  constructor() {
    this.name = 'Angular2 array to observable example'
    this.data$ = this.emitter
      .startWith(this.data)
      .scan((orig, item) =&gt; orig.concat(item))
  }

  ngOnInit() {
    // this.data$ = Rx.Observable.of(this.data)
    //  .map(data =&gt; {
    //    let x = data
    //    x.push(""4"")
    //    return x
    //  })
  }

  addToArray() {
    //this.data.push('more numbers')
    this.emitter.emit(""forth"")
  }
</code></pre>

<p>Check it <a href=""http://plnkr.co/edit/l1ASlbJvA12LcDyLvBFd?p=preview"" rel=""nofollow"">here</a></p>

<h3>EXTEND</h3>

<p>Much <a href=""http://plnkr.co/edit/yqZEjzIcclSSKFmBxXYp?p=info"" rel=""nofollow"">more complex plunker</a></p>

<p>There is much more complex solution.. just profiting from Observable and its 
Operators. It is ready to <strong>add</strong> and <strong>delete</strong> items:</p>

<pre><code>  data = [""one"",""two"",""three""]
  data$: Observable&lt;string[]&gt;;
  protected emitter = new EventEmitter&lt;string[]&gt;(); 
  protected toDelete = new Rx.BehaviorSubject&lt;string[]&gt;([])
    .scan((orig, item) =&gt; orig.concat(item));

  constructor() {
    this.name = 'Angular2 array to observable example'
    this.data$ = this.emitter
      // start
      .startWith(this.data)
      // return array
      .scan((orig, item) =&gt; orig.concat(item))
      // adjust each source string with a prefix
      .map((coll: string[]) =&gt; {
        let adjusted: string[] = []
        coll.forEach(item =&gt; {
          adjusted.push(""x"" + item)
        })
        return adjusted;
      })
      // now consume also array of items to be deleted
      .combineLatest(this.toDelete)
      // just those which were not delted
      .map(([all, toDelete]:[string[], string[]]) =&gt;{
        let result = all.filter( function( el ) {
          return toDelete.indexOf( el ) &lt; 0;
        });
        return result;
      })
  }

  counter: int = 0;
  addToArray() {
    this.emitter.emit(`other${++this.counter}`)
  }

  deleteFromArray(removeString) {
    this.toDelete.next(removeString)
  }
</code></pre>

<p>Check it in <a href=""http://plnkr.co/edit/yqZEjzIcclSSKFmBxXYp?p=info"" rel=""nofollow"">action here</a></p>

<h3>Let's do another EXTEND</h3>

<p>There is a <a href=""http://plnkr.co/edit/wFMcjL5l2a4KW1cusXbz?p=preview"" rel=""nofollow"">final plunker with lot of <strong><code>data: string\[\]</code></strong> array handling</a></p>

<p>We can now even track the changes and let them adjust original data array, and even use the RESET function, to start from new begining. This is the adjusted code:</p>

<pre><code>  data = [""one"",""two"",""three""]
  data$: Observable&lt;string[]&gt;;
  protected emitter: EventEmitter&lt;string[]&gt;;
  protected toDelete: Rx.BehaviorSubject&lt;string[]&gt;;

  constructor() { 
    this.initEmitters();  
    this.data$ = this.createObservable(this.data);
  }

  initEmitters() {
    this.emitter = new EventEmitter&lt;string[]&gt;(); 
    this.toDelete = new Rx.BehaviorSubject&lt;string[]&gt;([])
      .scan((orig, item) =&gt; orig.concat(item));
  }

  createObservable(initData)
  {
    let observable = this.emitter
      // start
      .startWith(initData)
      // return array
      .scan((orig, item) =&gt; orig.concat(item))
      // adjust each source string with a prefix
      .map((coll: string[]) =&gt; {
        let adjusted: string[] = []
        coll.forEach(item =&gt; {
          adjusted.push(""x"" + item)
        })
        return adjusted;
      })
      // now consume also array of items to be deleted
      .combineLatest(this.toDelete)
      // just those which were not delted
      .map(([all, toDelete]:[string[], string[]]) =&gt;{
        let result = all.filter( function( el ) {
          return toDelete.indexOf( el ) &lt; 0;
        });
        return result;
      })

      observable
        .subscribe((currentData) =&gt; {
          this.data.length = 0;
          [].push.apply(this.data, currentData)
        });

      return observable;
  }

  counter: int = 0;
  addToArray() {
    this.emitter.emit(`other${++this.counter}`)
  }

  deleteFromArray(removeString) {
    this.toDelete.next(removeString)
  }

  resetArray() {
    this.initEmitters();  
    this.data$ = this.createObservable(['ten','eleven'])
  }
</code></pre>

<p>Test that <a href=""http://plnkr.co/edit/wFMcjL5l2a4KW1cusXbz?p=preview"" rel=""nofollow""><code>array</code> vs <code>obesrvable</code> in action here</a></p>
","1679310","","1679310","","2016-06-24 08:07:43","2016-06-24 08:07:43","","","","8","","","","CC BY-SA 3.0"
"38022219","1","","","2016-06-24 21:14:12","","2","990","<p>I'm trying to bundle up a project with rollup that depends on RxJS (v5). What I'd like is for rollup to tree-shake and only include the RxJS modules I'm using. </p>

<p>I think I'm close, but it's leaving in the following from <code>system-observable</code>:</p>

<pre><code>module.exports = require('./ponyfill')(global || window || undefined);
</code></pre>

<p>Sample repo is <a href=""https://github.com/martypdx/rollup-rxjs"" rel=""nofollow"">here</a>.</p>

<p>I'm currently using <code>npm i rxjs-es</code>, I know there are other rxjs installs, but I'm assuming that's the right one.</p>

<p>Here's what I'm currently doing:</p>

<pre><code>const rollup = require( 'rollup' );
const nodeResolve = require( 'rollup-plugin-node-resolve' );
const commonjs = require( 'rollup-plugin-commonjs' );

// found this online, it does seem to correctly rewrite the rxjs paths
// but is it helping or hurting?
class RollupRx {

    constructor( options ){
        this.options = options;
    }

    resolveId( id ){
        if(id.startsWith('rxjs/')){
            return `${__dirname}/node_modules/rxjs-es/${id.replace('rxjs/', '')}.js`;
        }
    }
}

const rollupRx = config =&gt; new RollupRx( config );

rollup.rollup({
    entry: 'index.js',
    plugins: [
        rollupRx(),
        nodeResolve({ jsnext: true, main: true }),
    ]
}).then( bundle =&gt; {
    bundle.write({
        format: 'iife',
        dest: 'bundle.js'
    });
}).catch( err =&gt; console.error( err ) );
</code></pre>

<p><strong>UPDATE:</strong> If I rewrite RxJS's sole dependency <code>symbol-observable</code> to be ES6 modules then it works.</p>

<p>Questions I have are:</p>

<ul>
<li>Should rollup (and some plugins/config) have handle the transition to grab a CJS dependecy? Or should a PR be made to <code>symbol-observable</code> to make es6?</li>
<li>Is the custom plugin to rewrite <code>rxjs-es</code> import paths necessary? Or is there an existing plugin or config that would do this?</li>
</ul>

<p><strong>UPDATE 2:</strong> Looks like <code>symbol-observable</code> already did this about a week ago, but npm is installing older version. (<a href=""https://github.com/ReactiveX/rxjs/issues/1785"" rel=""nofollow"">https://github.com/ReactiveX/rxjs/issues/1785</a>)</p>
","1144502","","1144502","","2016-06-26 18:02:13","2016-06-26 18:02:13","Bundle only used modules of RxJS using rollup","<rxjs5><rollupjs>","0","0","","","","CC BY-SA 3.0"
"38025123","1","42574558","","2016-06-25 04:58:27","","14","1867","<p>I'm reading the rxjs manual, I'm a little confused about what's the difference between multicast and publish operators. They seem very similar.</p>
","2303252","","","","","2017-03-03 09:00:34","What's the difference between publish and multicast operator in rxjs 5?","<rxjs5>","2","0","3","","","CC BY-SA 3.0"
"38035214","1","38035296","","2016-06-26 04:32:17","","0","1332","<p>I am using <strong>ngrx/effects</strong>. I got this error:</p>

<blockquote>
  <p>ORIGINAL EXCEPTION: TypeError: unknown type returned</p>
</blockquote>

<p>This is part of my codes:</p>

<pre><code>  this.store.dispatch({ type: CHAT_LOAD_MESSAGES, payload: chatId });

  @Effect() loadMessages$ = this.updates$
    .whenAction(CHAT_LOAD_MESSAGES)
    .map&lt;string&gt;(toPayload)
    .do(chatId =&gt; console.log('chatId', chatId))    // Here I can get chatId
    .switchMapTo(chatId =&gt; this.chatService.loadMessages(chatId))  // The error comes out because of this line
    .do(res =&gt; console.log('res', res))             // This didn't run
    .map((messages: Message[]) =&gt; ({ type: CHAT_LOAD_MESSAGES_SUCCESS, payload: messages }));
</code></pre>

<hr>

<pre><code>  loadMessages(chatId: string): Observable&lt;Message[]&gt; {
    // This is what I am using to test right now.
    // Maybe this line is wrong? How can I write correct simulation?
    return Observable.of([{ id:1, content:'Hi' });
  }
</code></pre>

<p>What may cause this? Thanks</p>
","2000548","","2000548","","2016-06-26 04:51:33","2016-06-26 04:51:33","TypeError: unknown type returned","<typescript><angular><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"38035296","2","","38035214","2016-06-26 04:47:45","","0","","<p>Thanks for @apreg point out my error on Gitter.</p>

<p>I should change <code>switchMapTo</code> to <code>switchMap</code>.</p>

<p>The official document and explanation of <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow"">switchMap</a> and <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMapTo"" rel=""nofollow"">switchMapTo</a>.</p>
","2000548","","","","","2016-06-26 04:47:45","","","","0","","","","CC BY-SA 3.0"
"38035540","1","38035964","","2016-06-26 05:34:07","","1","62","<p>I have a function <code>loadMessages</code>, I want it return an <code>Observable</code>.</p>

<pre><code>  loadMessages(chatId: string): Observable&lt;Message[]&gt; {
    console.log('1');

    this.autorun(() =&gt; {
      const handle = this.subscribe('messages', chatId);

      if (handle.ready()) {
        console.log('2');

        const messages = Messages.find().fetch();
        return Observable.of(messages);  // here return is not for this function, which is useless
      }
    });

    console.log('3');  // I don't want this line run immediately

    // I wish I can return here, but I cannot
  }
</code></pre>

<p>How can I return to the function level?</p>

<p>Also, right now the order is 1 -> 3 -> 2. Is there any way to run 1 -> 2, and wait there until I get the data?</p>
","2000548","","2000548","","2016-06-26 05:50:49","2016-06-26 06:56:47","How to return to the function level?","<meteor><typescript><angular><rxjs5><angular2-meteor>","1","0","0","","","CC BY-SA 3.0"
"38035964","2","","38035540","2016-06-26 06:56:47","","3","","<p>You can try something like this:</p>

<pre><code>loadMessages(chatId: string): Observable&lt;Message[]&gt; {
  console.log('1');

  return Observable.create(observer =&gt; {
    this.autorun(() =&gt; {
      const handle = this.subscribe('messages', chatId);

      if (handle.ready()) {
        console.log('2');

        const messages = Messages.find().fetch();
        observer.next(messages)
      }
    });
  });
}
</code></pre>

<p>Very simple example is here <a href=""http://plnkr.co/edit/GADtB8QCTnNubtRu9SFv?p=preview"" rel=""nofollow"">http://plnkr.co/edit/GADtB8QCTnNubtRu9SFv?p=preview</a></p>
","5485167","","","","","2016-06-26 06:56:47","","","","0","","","","CC BY-SA 3.0"
"38061506","1","38061551","","2016-06-27 19:13:18","","1","261","<p>Ok this has been bugging me for a while, wondering if any one could show me a good way of chaining Observables between multiple services.</p>

<p>In the example below in the Auth class what would be a good way of creating an Observable from the <code>this.api.postSignIn()</code> so the <code>signInSubmit()</code> can subscribe to it back in the component? It is worth noting that <code>this.api.postSignIn()</code> is subscribing to an Angular2 http request.</p>

<p>Is this a bit of an anti pattern and is there better ways of doing this?</p>

<p>Basically the functionality I would like to achieve is:</p>

<ul>
<li>Component - responsible for collecting the sign in data and sending it to the auth service in the correct format. Then once the Auth sign in is complete navigate to the admin page.</li>
<li><p>Service - Make api call to get token, set token via the token service and set <code>isSignedIn</code> bool then defer control back to the calling component.</p>

<pre><code>@Component({...})
export class SignIn {
   private signIn:SignInModel = new SignInModel();

    constructor(private auth:Auth, private router:Router) {
    }

    ngOnInit() {
    }

    signInSubmit() {
        this.auth.signIn(this.signIn)
            .subscribe(
                () =&gt; {
                    this.router.navigate(['/admin']);
                }
           )
    }

}

@Injectable()
export class Auth {
    private isSignedIn:boolean = false;

    constructor(private api:Api, private tokenService:TokenService) {

    }

    public signIn(signIn:SignInModel) {

       return this.api.postSignIn(signIn)
            .subscribe(
                response =&gt; {
                    this.tokenService.set(new TokenModel(response.token));
                    this.isSignedIn = true;
                },
                error =&gt; {
                    console.log(error);
                }
            );
    }

    public signOut() {

   }
}
</code></pre></li>
</ul>
","1804444","","1804444","","2016-06-27 19:33:05","2016-06-27 19:33:05","How to chain/combine Observables","<javascript><angular><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38061551","2","","38061506","2016-06-27 19:16:14","","2","","<p>I would leverage the <code>do</code> and <code>catch</code> operators instead of subscribing within the <code>signIn</code> method.</p>

<p>Here is the refactored <code>signIn</code> method:</p>

<pre><code>public signIn(signIn:SignInModel) {
   return this.api.postSignIn(signIn)
        .do(
            response =&gt; {
                this.tokenService.set(new TokenModel(response.token));
                this.isSignedIn = true;
            })
        .catch(
            error =&gt; {
                console.log(error);
            }
        );
}
</code></pre>

<p>In your case, you can't subscribe on the returned object of this method since the <code>subscribe</code> method returns a subscription and not an observable. So you can't subscribe on it...</p>
","1873365","","","","","2016-06-27 19:16:14","","","","2","","","","CC BY-SA 3.0"
"38081878","1","38082208","","2016-06-28 16:42:48","","63","43083","<p>I have a Service and a component that uses it:</p>

<ul>
<li><code>PagesService</code></li>
<li><code>PagesListComponent</code></li>
</ul>

<p>In the <code>PagesService</code> I have an array of <code>Pages</code>. I notify changes in the array via a <code>BehaviorSubject</code> which both of them are subscribed to.</p>

<p>The <code>PagesService</code> are provided at <code>bootstrap</code>, to have just one instance shared. That's because I need to keep the array, instead of downloading the pages everytime they are needed.</p>

<p>The code is the following:</p>

<p><strong>pages.service.ts</strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs/Rx';
import { Http, Response } from '@angular/http';

import { Page } from './../models/page';

@Injectable() export class PagesService {

    public pages$: BehaviorSubject&lt;Page[]&gt; = new BehaviorSubject&lt;Page[]&gt;([]);
    private pages: Page[] = [];

    constructor(private http: Http) { }

    getPagesListener() {
        return this.pages$;
    }
    getAll() {
        this.http.get('/mockups/pages.json').map((res: Response) =&gt; res.json()).subscribe(
            res =&gt; { this.resetPagesFromJson(res); },
            err =&gt; { console.log('Pages could not be fetched'); }
        );
    }

    private resetPagesFromJson(pagesArr: Array&lt;any&gt;) {
        // Parses de Array&lt;any&gt; and creates an Array&lt;Page&gt;
        this.pages$.next(this.pages);
    }
}
</code></pre>

<p><strong>pages_list.component.ts</strong></p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router-deprecated';
import { BehaviorSubject } from 'rxjs/Rx';

import { PagesService } from '../../shared/services/pages.service';
import { GoPage } from '../../shared/models/page';

@Component({
    moduleId: module.id,
    selector: 'go-pages-list',
    templateUrl: 'pages_list.component.html',
    styleUrls: ['pages_list.component.css']
})
export class PagesListComponent implements OnInit {
    pages$: BehaviorSubject&lt;GoPage[]&gt;;
    pages: GoPage[];
    constructor(private pagesService: PagesService, private router: Router) { }

    ngOnInit() {
        this.pages$ = this.pagesService.getPagesListener();
        this.pages$.subscribe((pages) =&gt; { this.pages = pages; console.log(pages) });
        this.pagesService.getAll();
    }
    ngOnDestroy() {
        this.pages$.unsubscribe();
    }
}
</code></pre>

<p>This works fine the first time, both the subscription onInit and de unsubscription onDestroy. But when I return to the list and try to subscribe again (to fetch the current value of pages[] and listen for future changes), it <strong>fires the error</strong> <code>EXCEPTION: ObjectUnsubscribedError</code>.</p>

<p>If I don't unsubscribe, everytime I enter to the list, a new subscription is stacked, and all of them are fired when a next() is received.</p>
","3529185","","","","","2017-11-16 13:06:23","ObjectUnsubscribedError when trying to prevent subscribing twice","<typescript><angular><rxjs><rxjs5>","2","0","11","","","CC BY-SA 3.0"
"38082208","2","","38081878","2016-06-28 17:02:27","","111","","<p>I would get the subscription and unsubscribe on it this way and not on the subject directly:</p>

<pre><code>ngOnInit() {
  this.pages$ = this.pagesService.getPagesListener();
  this.subscription = this.pages$.subscribe((pages) =&gt; { // &lt;-------
    this.pages = pages; console.log(pages);
  });
  this.pagesService.getAll();
}

ngOnDestroy() {
    this.subscription.unsubscribe(); // &lt;-------
}
</code></pre>
","1873365","","","","","2016-06-28 17:02:27","","","","4","","","","CC BY-SA 3.0"
"38084904","1","38362253","","2016-06-28 19:38:09","","4","701","<p>I am using <strong>ngrx/store</strong>, <strong>ngrx/effects</strong>, and <strong>ngrx/router</strong>.</p>

<p>My effects are like this:</p>

<pre><code> @Effect() loadOneProduct$ = this.updates$
    .whenAction(LOAD_ONE_PRODUCT)
    .switchMap(() =&gt; this.productService.loadOneProduct())
    .map(oneProduct =&gt; ({ type: LOAD_ONE_PRODUCT_SUCCESS, payload: oneProduct }));

 @Effect() loadOneWorker$ = this.updates$
    .whenAction(LOAD_ONE_WORKER)
    .switchMap(() =&gt; this.workerService.loadOneWorker())
    .map(oneWorker =&gt; ({ type: LOAD_ONE_WORKER_SUCCESS, payload: oneWorker }));
</code></pre>

<p>In the beginning, the store state is like this:</p>

<pre><code>{
  company: { name: 'Google' },
  products: {},
  workers: {}
}
</code></pre>

<p>1) After running <code>this.store.dispatch({ type: LOAD_ONE_PRODUCT });</code>, it becomes like this:</p>

<pre><code>{
  company: { name: 'Google' },
  products: {
    oneProduct: {
      label: 'Phone'
    } 
  },
  workers: {}
}
</code></pre>

<p>2) After running <code>this.store.dispatch({ type: LOAD_ONE_WORKER });</code>, it becomes like this:</p>

<pre><code>{
  company: { name: 'Google' },
  products: {
    oneProduct: {
      label: 'Phone'
    } 
  },
  workers: {
    oneWorker: {
      name: 'Tom'
    } 
  },
}
</code></pre>

<p>3) Next when I go to another PAGE,</p>

<pre><code>{{store|async|json}}

ngOnInit()
{
   this.subscription = this.store
      .select(x =&gt; x.products &amp;&amp; x.products.oneProduct)
      .subscribe(oneProduct =&gt; {
        // Got undefined here. I suppose I can get the latest value from the store
        console.log(oneProduct);
      });

    // Everything will become correct if I `dispatch` any action
    // And I created a action called TEST, no reducer for it, which means won't change store state, also works
}
</code></pre>

<p>And now <code>{{store|async|json}}</code> shows:</p>

<pre><code>{
  company: { name: 'Google' },
  products: {},
  workers: {}
}
</code></pre>

<p>All my states goes back to the initial state. Not only <code>products</code> disappears, but also <code>workers</code> disappears. (NOTE: <code>workers</code> also disappears.)</p>

<p><strong>(However, in Chrome Extention Redux Tools, the state tree shows correct all the time.)</strong></p>

<p>If I add a button and manually use ChangeDetectorRef, do <code>this._cdRef.detectChanges();</code>, <code>{{store|async|json}}</code> still shows initial state. (So seems not related with zone)</p>

<p>However, if I dispatch some actions after, both <code>products</code> and <code>workers</code> will come back to the state. And <code>{{store|async|json}}</code> shows correctly too.</p>

<p>Since in Chrome Extention Redux Tools, the state tree shows correct all the time. So I guess it just does not load correctly. My question is when the page changes, what can trigger loading all store states? Thanks</p>
","2000548","","2000548","","2016-07-10 18:06:25","2016-10-14 18:04:28","When the page changes, what can trigger loading all store states?","<typescript><angular><rxjs5><ngrx>","1","5","0","","","CC BY-SA 3.0"
"38086966","1","38089623","","2016-06-28 21:56:59","","1","5307","<p>Is there a way to do this same functionality without ""interval()"" part?</p>

<p>I just want to connect the array to an observable, and then just update the array, and the observable to watch that array and react.</p>

<p>If this is good solution, is there a way to implement, and where, the .distinctUntilChanged() into this so that it does not emit new values if the data is the same, then this ""interval(10)"" will not be the bottleneck.</p>

<p>Here is the Plunker: <a href=""http://plnkr.co/edit/xlWSTz8gNfByTnT1REw5?p=preview"" rel=""nofollow"">http://plnkr.co/edit/xlWSTz8gNfByTnT1REw5?p=preview</a></p>

<pre><code>import {Component} from 'angular2/core';
import * as Rx from 'rxjs/Rx'

@Component({
    selector: 'a-webapp',
    template:`

    &lt;div&gt;
    &lt;h2&gt;{{name}}&lt;/h2&gt;

    &lt;button (click)=""addToArray()""&gt;Add&lt;/button&gt; &lt;button (click)=""resetArray()""&gt;Reset&lt;/button&gt;
    &lt;ul&gt;
        &lt;li *ngFor=""let item of latest$ | async""&gt;{{ item | json  }}&lt;/li&gt;
    &lt;/ul&gt;

    {{ data | json }}

    &lt;/div&gt;

    `
})
export class AppComponent {

    data = [""one"", ""two"", ""three""]
    data$: Rx.Observable&lt;Array&lt;string&gt;&gt;;
    latest$: Rx.Observable&lt;Array&lt;string&gt;&gt;;

    constructor() {}

    ngOnInit() {

        this.data$ = Rx.Observable.interval(10).concatMap(y =&gt; {
            return Rx.Observable.of(this.data)
        })

        this.latest$ = Rx.Observable.combineLatest(this.data$, (data) =&gt; {
            return data.map(d =&gt; {
                return d + "" is a number""
            })
        })
    }

    addToArray() {
        this.data.push('more numbers')
    }

    resetArray() {
        this.data = [""one"", ""two"", ""three""]
    }

}
</code></pre>
","6024613","","","","","2016-06-29 02:58:16","Connect Array to Observable without .interval() in Angular2 Typescript","<typescript><angular><rxjs><rxjs5>","1","0","3","","","CC BY-SA 3.0"
"38089623","2","","38086966","2016-06-29 02:58:16","","14","","<blockquote>
  <p>""... and the observable to watch that array and react""</p>
</blockquote>

<p>I think it's better to have the observable emitted a new value everytime that array changes</p>

<p>In your case:</p>

<pre><code>export class AppComponent {
  data = [""one"", ""two"", ""three""];
  data$: Rx.BehaviorSubject&lt;Array&lt;string&gt;&gt;; // or data$: Rx.Subject&lt;Array&lt;string&gt;&gt;
  latest$: Rx.Observable&lt;Array&lt;string&gt;&gt;;

  constructor() {}

  ngOnInit() {
    this.data$ = new Rx.BehaviorSubject&lt;Array&lt;string&gt;&gt;(this.data);

    this.latest$ = this.data$.map(data =&gt; data.map(
      d =&gt; """" + d + "" is a number""
    ));
  }

  addToArray() {
    this.data.push('more numbers');
    this.data$.next(this.data);
  }

  resetArray() {
    this.data = [""one"", ""two"", ""three""];
    this.data$.next(this.data);
  }
}
</code></pre>
","6507432","","","","","2016-06-29 02:58:16","","","","2","","","","CC BY-SA 3.0"
"38108814","1","","","2016-06-29 19:47:01","","1","4137","<p>Having a bit of trouble working with the <code>Subject</code> exposed by <code>Rx.Observable.webSocket</code>. While the WebSocket does become reconnected after <code>complete</code>, subsequent subscriptions to the <code>Subject</code> are immediately completed as well, instead of pushing the next messages that come over the socket.</p>

<p>I think I'm missing something fundamental about how this is supposed to work.</p>

<p>Here's a requirebin/paste that I hope illustrates a bit better what I mean, and the behavior I was expecting. Thinking it'll be something super simple I overlooked. </p>

<p><a href=""http://requirebin.com/?gist=e68ddecede95b00003001bc2cc1f8a04"" rel=""nofollow"">Requirebin</a></p>

<pre><code>var Rx = require('rxjs')

var subject = Rx.Observable.webSocket('wss://echo.websocket.org')

subject.next(JSON.stringify('one'))

subject.subscribe(
    function (msg) {
        console.log('a', msg)
    }, 
    null,
    function () {
        console.log('a complete')
    }
)

setTimeout(function () {
    subject.complete()
}, 1000)

setTimeout(function () {
    subject.next(JSON.stringify('two'))
}, 3000)

setTimeout(function () {
  subject.next(JSON.stringify('three'))

  subject.subscribe(
      function (msg) {
          // Was hoping to get 'two' and 'three'
          console.log('b', msg)
      }, 
      null,
      function () {
          // Instead, we immediately get here.
          console.log('b complete')
      }
  )
}, 5000)
</code></pre>
","508714","","508714","","2016-06-29 20:05:55","2017-02-14 14:02:19","Rx.Observable.webSocket() immediately complete after reconnect?","<websocket><rxjs5>","2","1","","","","CC BY-SA 3.0"
"38159757","1","38159937","","2016-07-02 11:43:25","","0","166","<p>I am importing like this:</p>

<pre><code>import { Observable } from 'rxjs' ;
</code></pre>

<p>or</p>

<pre><code>import { Observable } from 'rxjs/Rx' ;
</code></pre>

<p>And declared a property like this</p>

<pre><code>ob : Observable&lt;any&gt;;
</code></pre>

<p>When I write <code>this.ob.fromarray()</code> in my constructor I'm only getting IntelliSense for <code>subscribe</code> and 2 or 3 other functions, not <code>fromarray</code> which is required.</p>
","5710014","","1324","","2016-07-02 20:36:46","2016-07-02 20:36:46","Why am I only getting a few functions when I'm importing rxjs/Rx","<typescript><angular><rxjs><angular2-template><rxjs5>","2","0","","","","CC BY-SA 3.0"
"38159937","2","","38159757","2016-07-02 12:03:31","","1","","<p>You probably want to import the whole ReactiveXJS package like this:</p>

<pre class=""lang-js prettyprint-override""><code>import 'rxjs/Rx';
</code></pre>

<p>On the other hand <code>Observable.fromArray(arr: Array&lt;any&gt;)</code> is a static method - you can't use it on an instance. The documentation though says, that this method is deprecated and one should use <code>Observable.from()</code> now.</p>

<p>Use it like so for instance:</p>

<pre class=""lang-js prettyprint-override""><code>//our root app component
import {Component} from '@angular/core';
import {Observable} from 'rxjs/Rx';
import 'rxjs/Rx';

@Component({
  selector: 'my-app',
  providers: [],
  template: `
    &lt;div *ngFor=""let item of output""&gt;{{item}}&lt;/div&gt;
  `,
  directives: []
})
export class App {
  ob: Observable&lt;any&gt;;

  someArray: Array&lt;number&gt; = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
  output: Array&lt;number&gt; = [];

  constructor() {
    this.ob = Observable.from(this.someArray);

    this.ob.subscribe((data) =&gt; {
      this.output.push(data);
    });
  }
}
</code></pre>
","1961059","","1961059","","2016-07-02 13:00:01","2016-07-02 13:00:01","","","","15","","","","CC BY-SA 3.0"
"38168581","1","","","2016-07-03 09:30:38","","47","13927","<p>When trying to extend a class from a class in a <code>node_modules</code> the typescript compiler throws a error saying: </p>

<p><code>Property 'source' is protected but type 'Observable&lt;T&gt;' is not a class derived from 'Observable&lt;T&gt;'.</code> </p>

<p>This only happens when the base class is from a <code>node_module</code>.</p>

<p>The base class looks like:</p>

<pre><code>import {Observable} from ""rxjs/Observable"";
export abstract class TestBase&lt;T&gt; {

    request(options: any):Observable&lt;T&gt; {
        return Observable.throw(new Error('TestBase is abstract class. Extend it and implement own request method'));
    }
}
</code></pre>

<p>Subclassing it in a project:</p>

<pre><code>import {Observable} from ""rxjs/Observable"";
import {TestBase} from ""@org/core"";

class SocketResponse {

}

class Socket {
    request(): Observable&lt;SocketResponse&gt; {
        return new Observable.of(new SocketResponse());
    }
}

export class Sub extends TestBase&lt;SocketResponse&gt; {
    request(options:any):Observable&lt;SocketResponse&gt; {
        return new Socket().request();
    }
}
</code></pre>

<p>If the base class (<code>TestBase</code>) is moved from the <code>node_module</code> to the project it self and change the import to look like
<code>import {TestBase} from ""./base"";</code> The error disappears.</p>

<p>Is this due to that the compiles creates the types in different scopes for each module? I'm completely lost here.</p>

<p><strong>Update:</strong></p>

<p>This seems to only happen when linking the <code>node_modules</code> with <code>npm link</code>.
Seems like one possible workaround for the moment is to instead of returning a type in the base class to return a interface.</p>

<p>More information can be found here:</p>

<p><a href=""https://github.com/Microsoft/TypeScript/issues/6496"">https://github.com/Microsoft/TypeScript/issues/6496</a></p>

<p><a href=""https://github.com/ReactiveX/rxjs/issues/1744"">https://github.com/ReactiveX/rxjs/issues/1744</a></p>
","183893","","183893","","2016-07-05 07:51:56","2019-10-23 23:41:10","'Observable<T>' is not a class derived from 'Observable<T>'","<typescript><rxjs5>","9","3","6","","","CC BY-SA 3.0"
"38188236","1","","","2016-07-04 15:33:16","","0","783","<p>I have been reading this code if I will replace scan with map I get can not get property ""getTime"" of undefined, why is it happening I assume that both operator takes an item emits from observable and apply some function on it</p>

<pre><code>this.clock = Observable.merge(
        this.click$,
        Observable.interval(5000)
    )
        .startWith(new Date())
        .map((acc : Date)=&gt; {
            const date = new Date(acc.getTime());
             date.setSeconds(date.getSeconds() + 1);
            return date;
        });
</code></pre>
","5710014","","5710014","","2016-07-04 15:41:37","2016-07-04 15:41:37","Rxjs: The scan operator","<angular><rxjs><angular2-template><angular2-directives><rxjs5>","1","5","","","","CC BY-SA 3.0"
"38240121","1","","","2016-07-07 07:47:26","","2","370","<p>I have a piece of code that worked perfectly until the latest Angular 2 update. Among other things, it uses Http requests &amp; Observables.</p>

<p>I updated to RC4, import all RxJS operators (to make sure it works) and I get Error: SecurityError: DOM Exception 18</p>

<p>Any idea why and how I can fix this?</p>

<p>Simplified code snippet: </p>

<pre><code>logIn(email: string, pass: string): Observable&lt;boolean&gt; {
  return Observable.create((observer: Observer&lt;boolean&gt;) =&gt; {
    let body = {
      email: email,
      pass: pass
    };

    this.http.post(this.origin + ""/auth/logIn"", JSON.stringify(body), this.requestArguments())
      .subscribe((res: Response) =&gt; {
        observer.next(res.json()[""isLoggedIn""]);
        observer.complete();
      })
  })
}
</code></pre>

<p>Where </p>

<pre><code>this.origin = window.location.origin + ""/api""
</code></pre>

<p>Weirdly: </p>

<p>Safari throws the exception</p>

<p>Chrome doesn't, but the page seems to get stuck</p>

<p>Firefox works properly.</p>

<p>And all of this is sporadic.. sometimes it works, sometimes it doesn't.</p>
","354564","","1873365","","2016-07-13 12:53:11","2016-07-16 19:18:24","Angular 2 RC4 RxJS Crash","<typescript><angular><rxjs><rxjs5>","1","8","","","","CC BY-SA 3.0"
"38291783","1","","","2016-07-10 12:18:34","","121","219410","<p>I dont know how to extract value from Observable to be returned by function in which Observable is present. I need just a value from it to be returned, nothing else.</p>

<p>Current version which works</p>

<pre><code>function getValueFromObservable() {
    this.store.subscribe(
        (data:any) =&gt; {
            console.log(data)
        }
    )
}
getValueFromObservable()
</code></pre>

<p>I need this to work, function to return value, and then:</p>

<pre><code>function getValueFromObservable() {
    this.store.subscribe(
        (data:any) =&gt; {
            return data
        }
    )
}
console.log(getValueFromObservable())
</code></pre>

<p>What am I doing wrong here?</p>
","6024613","","3001761","","2017-11-13 22:49:27","2021-04-15 20:54:00","How to return value from function which has Observable subscription inside?","<typescript><angular><rxjs><rxjs5>","10","7","29","","","CC BY-SA 3.0"
"38333066","1","38333575","","2016-07-12 15:24:22","","1","3733","<p>I am using <strong>@ngrx/effects</strong> with <strong>@angular/router</strong>. (Angular 2 version RC4)</p>

<p>If I add this line <code>private router: Router</code> in the effects:</p>

<pre><code>@Injectable()
export class RouterEffects {
  constructor(
    private updates$: StateUpdates&lt;AppState&gt;,
    private router: Router   // &lt;- this line
  ) {}
}
</code></pre>

<p>I will get this error:</p>

<blockquote>
  <p>EXCEPTION: Cannot instantiate cyclic dependency! (Token Application
  Initializer -> Token @ngrx/effects Bootstrap Effects -> Router ->
  ApplicationRef -> ApplicationRef_)</p>
</blockquote>

<p>How can I solve this? Thanks</p>
","2000548","","2000548","","2016-07-12 16:06:50","2016-07-16 05:14:14","Cannot instantiate cyclic dependency","<typescript><angular><angular2-routing><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"38333575","2","","38333066","2016-07-12 15:48:01","","0","","<p>Thanks Anthony @qdouble and Mike Ryan @MikeRyan52 on gitter.</p>

<p><a href=""https://gitter.im/ngrx/effects?at=57850fc0b79455146fa4236f"" rel=""nofollow"">https://gitter.im/ngrx/effects?at=57850fc0b79455146fa4236f</a></p>

<blockquote>
  <p>Application initializers will be deprecated in the next RC. So it will
  probably be fixed around then.</p>
</blockquote>

<p>And Anthony's walkaround way is here:
<a href=""https://gitter.im/ngrx/effects?at=576ff574bb1de91c546fde19"" rel=""nofollow"">https://gitter.im/ngrx/effects?at=576ff574bb1de91c546fde19</a></p>
","2000548","","2000548","","2016-07-16 05:14:14","2016-07-16 05:14:14","","","","0","","","","CC BY-SA 3.0"
"38340541","1","38344020","","2016-07-12 23:49:08","","15","4061","<p>The example and explanation of the <code>let</code> operator (<a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/let.md"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/let.md</a>) is not clear. Anyone has a good example/explanation how the <code>let</code> operator works, and when we should use it?</p>
","401353","","","","","2016-07-13 06:23:05","How to use Rx.Observable.prototype.let operator?","<rxjs><rxjs5>","1","0","3","","","CC BY-SA 3.0"
"38344020","2","","38340541","2016-07-13 06:23:05","","39","","<p><strong>&tldr;</strong></p>

<p>It is a convenience function for being able to compartmentalize logic and inject it into a pipeline.</p>

<p><strong>Longer Explanation</strong></p>

<p>The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/src/core/linq/observable/let.js"">source</a> is probably the most definitive explanation. It is really just passing a function which gets called with a source <code>Observable</code>.</p>

<pre><code>Rx.Observable.prototype.let = function(fn) {
  return fn(this);
}
</code></pre>

<p>The utility of this is that we can create or pre-define a pipeline that you want to reuse for multiple sources. Consider a common trope for Rx, the reactive search bar:</p>

<pre><code>// Listen to a key up event on the search bar 
// and emit the value of the search
Rx.Observable.fromEvent(searchBar, 'keyup', e =&gt; e.target.value)
  // Don't search too eagerly
  .filter(text =&gt; text.length &gt; 3)
  .debounceTime(500)
  //Search logic
  .flatMap(text =&gt; $.getJSON(`my/search/api?q=${text}`))
  .flatMap({results} =&gt; results)
  //Handler
  .subscribe(appendToList);
</code></pre>

<p>The above should give a basic sense of the structure of how a pipeline might be created. If we wanted to try and abstract some of this logic either to clean up the code or to be able to use it elsewhere it can be a little tricky, because it usually means creating a new operator (and that has its own headaches). </p>

<p>The solution is a relatively simple approach of pulling common logic into a function that can be passed a source <code>Observable</code> and will return a new <code>Observable</code> with that logic applied.</p>

<p>So the above might become:</p>

<pre><code>//Defined in pipelines.js
function filterBuilder(minText, debounceTime) {
  return (source) =&gt; 
    source.filter(text =&gt; text.length &gt; minText)
          .debounce(debounceTime);
}

function queryBuilder(baseUrl) {
  return (source) =&gt; 
    source.flatMap(text =&gt; $.getJSON(`${baseUrl}?q=${text}`))
          .flatMap({results} =&gt; results);
}


//In your application code

Rx.Observable.fromEvent(searchBar, 'keyup', e =&gt; e.target.value)
  .let(filterBuilder(3, 500))
  .let(queryBuilder('my/search/api'))
  .subscribe(appendResults);
</code></pre>
","2521865","","","","","2016-07-13 06:23:05","","","","5","","","","CC BY-SA 3.0"
"38350365","1","38350956","","2016-07-13 11:25:15","","1","771","<p>I made stream of array using Observable.from() in the constructor and subscribed it in the constructor too, the array is getting update but subscription method is not working i think, I'm not getting console.log for the data, here is the code</p>

<pre><code>@Component({
    selector: 'my-app',
    template: `
        &lt;input type=""text"" required 
        [(ngModel)]=""inputValue"" name=""inputValue"" &gt;  
        &lt;button (click)=""addto()""&gt;submit&lt;/button&gt;  
     })
</code></pre>

<p>this is class</p>

<pre><code>export class first{

 proxySubject;
 inputValue: string;
 array = [];

constructor(){
this.proxySubject = Observable.from(this.array)
this.proxySubject.subscribe(function(data){
       console.log(data))
}

addto(){     
    this.array.push(this.inputValue)
} 
}
</code></pre>
","5710014","","","","","2017-11-30 23:41:48","Rxjs: Why this stream of array not recieving new values","<angular><system.reactive><rxjs><rxjs5><subject>","2","2","","","","CC BY-SA 3.0"
"38350956","2","","38350365","2016-07-13 11:51:07","","3","","<p><code>Observable.from()</code> checks mentioned array only once, every time you create a new subscribtion to given observable. What you are looking for is an observable array. One of the approaches can be creating  custom <code>addItem()</code> function which will <code>.push()</code> new item to an array and the call <code>mySubject.next(myArray)</code>. With this setup you can subscribe to <code>mySubject</code> to get notified whenever the content of array changes.</p>

<p>EDIT:</p>

<pre><code>myArray = [];

mySubject = new BehaviourSubject(myArray); // store last version for new subscribtions

addItem(item) {
  myArray.push(item);
  mySubject.next(myArray)
}

mySubject.subscribe(arr =&gt; console.log(arr))
</code></pre>

<p>EDIT 2 - observer:</p>

<pre><code>// doesnt really help anything
let myObserverRefference;

observable = Observable.create(function (observer) {
  myObserverRefference = observer;
});

addItem() {
   myObserverRefference.next(myArray);
}
</code></pre>
","2650426","","2650426","","2016-07-14 08:30:52","2016-07-14 08:30:52","","","","10","","","","CC BY-SA 3.0"
"38362253","2","","38084904","2016-07-13 21:47:03","","0","","<p>Seems like an Angular 2 issue:</p>

<p>Check <a href=""https://github.com/ngrx/store/issues/171"" rel=""nofollow"">https://github.com/ngrx/store/issues/171</a></p>

<p>and fixed by</p>

<p><a href=""https://github.com/angular/angular/commit/a46437c57d0c6a2cffb8256cc9e4f1ab69fef4ea"" rel=""nofollow"">https://github.com/angular/angular/commit/a46437c57d0c6a2cffb8256cc9e4f1ab69fef4ea</a></p>
","2000548","","2000548","","2016-10-14 18:04:28","2016-10-14 18:04:28","","","","0","","","","CC BY-SA 3.0"
"38386832","1","46749709","","2016-07-15 02:07:15","","0","283","<p>Im developing a small app with angular2 and I installed Rxjs 5.
In every tutorial there is a diffrent way to import the Rxjs libary.
The code to import in <a href=""https://angular.io/docs/ts/latest/guide/server-communication.html#!#rxjs"" rel=""nofollow"">angular2 web</a> is not working; I mean that Websotrm doesn't recognize Observable or any of its functions (from,subscribe,...).</p>

<ol>
<li>What do I need to do to fix that?</li>
<li>If I import everything from Rxjs, does the load of the website will be slower? (I won't have more then 2- classes)</li>
<li>(Webstorm question) How to I make webstorm to autocomplete the name of the functions with out pressing alt+space</li>
</ol>
","806963","","","","","2017-10-14 21:55:07","Basic questions about Rxjs","<javascript><angular><npm><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"38401085","1","38401296","","2016-07-15 16:33:44","","2","1555","<p>With promisses its easy becouse I can tell to the function that the return type of void function is Promise (I hope im right about it).</p>

<p>I want to do the same with Observables so it will be something like:</p>

<pre><code>import {Observable, Subject} from ""rxjs/Rx""

...
private personArray:Person[] = PERSONS; ///some persons in other file.
...

///This fucntion remove one person from my service.

public remove(id:number):Observable&lt;void&gt; {
    this.personArray = this.personArray.filter(person1=&gt;person1.id !== id);
    return Observable.from(); ???
  }
</code></pre>

<ol>
<li>The subscriber won't know if the first line throw an error. I'm sure there is a better way to do that and I will be heppy to see any other sulotions for this.</li>
<li>How can I make this code work?</li>
</ol>

<p>Thanks.</p>
","806963","","","","","2016-07-15 20:12:29","Should we subscribe to a void function and how?","<javascript><angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"38401296","2","","38401085","2016-07-15 16:46:11","","1","","<p>If you just want the OnCompleted message, use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-empty"" rel=""nofollow""><code>Observable.empty()</code></a>. If an error happens, you can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-throw"" rel=""nofollow""><code>Observable.throw(...)</code></a>:</p>

<pre><code>public remove(id:number):Observable&lt;void&gt; {
  try {
    this.personArray = this.personArray.filter(person1=&gt;person1.id !== id);
    return Observable.empty();
  } catch (e) {
    return Observable.throw(e);
  }
}
</code></pre>

<p>Alternatively, you could use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-defer"" rel=""nofollow""><code>.defer()</code></a>. If your function throws an exception, the OnError will be (automatically) thrown instead:</p>

<pre><code>public remove(id:number):Observable&lt;void&gt; {
  return Observable.defer(() =&gt; {
    this.personArray = this.personArray.filter(person1=&gt;person1.id !== id);
    return Observable.empty();
  });
}
</code></pre>
","1850609","","1850609","","2016-07-15 18:08:39","2016-07-15 18:08:39","","","","6","","","","CC BY-SA 3.0"
"38404074","1","38404122","","2016-07-15 19:49:25","","2","11238","<p>I'd like to filter an observable, but am getting unexpected results.</p>

<p>I am using the following import statements:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/of';
</code></pre>

<p>This example returns nothing:</p>

<pre><code>Observable.of([0, 1, 2, 3, 4, 5])
.filter((x: any) =&gt; x % 2 === 0)
.subscribe(data =&gt; console.log(data));
</code></pre>

<p>This example returns the entire result set [0,1,2,3,4,5]:</p>

<pre><code>Observable.of([0, 1, 2, 3, 4, 5])
.filter((x: number[], idx) =&gt; x[idx] % 2 === 0)
.subscribe(data =&gt; console.log(data));
</code></pre>

<p>Does anyone see syntax errors and/or something I am missing?  Thank you!</p>
","6595755","","","","","2016-07-15 19:52:42","Angular2 Observable Filter","<filter><angular><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38404122","2","","38404074","2016-07-15 19:52:42","","2","","<p>You need to use <code>from</code> if you want to pass values as iterable (array in current case)</p>

<pre><code>import 'rxjs/add/observable/from';

Observable.from([0, 1, 2, 3, 4, 5])
.filter((x: any) =&gt; x % 2 === 0)
.subscribe(data =&gt; console.log(data));
</code></pre>

<p>Or if you want stick with <code>of</code> pass values as arguments</p>

<pre><code>Observable.of(0, 1, 2, 3, 4, 5)
.filter((x: any) =&gt; x % 2 === 0)
.subscribe(data =&gt; console.log(data));
</code></pre>
","351705","","","","","2016-07-15 19:52:42","","","","0","","","","CC BY-SA 3.0"
"38450193","1","38473650","","2016-07-19 05:29:07","","0","115","<p>I have a function that returns something like <code>Observable&lt;[number, Array&lt;DataItem&gt;]&gt;</code>. Is it possible to write some function that returns <code>Observable&lt;[number, Array&lt;PageWithDataItems&gt;]</code> using some Observable functions, given a function <code>chunk</code> (chunks the DataItem array according to page size) and a simple constructor that creates a PageWithDataItems with a chunked DataItem array. 
What I have is some code that subscribes to <code>Observable&lt;[number, Array&lt;DataItem&gt;]&gt;</code> and then creates a new Observable, but I am hoping it would be possible to do the same with <code>map, mapTo, switchMap</code> or similar. I am a bit lost in all the Observable functions, so any help? </p>
","1461472","","","","","2016-07-20 06:18:44","Observable function to returned a chunked array","<javascript><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"38456548","1","","","2016-07-19 10:55:08","","0","541","<p>There is a input text that for each change, he get from my service the search results.
My serivce returns : Observable that contain all the results. It will return <strong>multiple persons</strong>.</p>

<p>tamplate.html:</p>

<pre><code>&lt;input type=""text"" id=""inputSearch""&gt;
...
&lt;tr *ngFor=""let person of items$ | async"" ...
...
</code></pre>

<p>Code:</p>

<pre><code>import { Component ,OnInit} from '@angular/core';
import {Control} from '@angular/common';
import {PersonService} from ""./person.service"";
import {Person} from ""./person.class"";
import {Observable} from ""rxjs/Rx""

@Component({
  selector: 'contact-table',
  moduleId: module.id,
  templateUrl: 'contact-table.component.html',
  styleUrls: ['contact-table.component.css']
})
export class ContactTable implements OnInit {
  private items$: Observable&lt;Person[]&gt;;
  private inputChanged$:Observable&lt;{}&gt;;

  constructor(private _PersonService:PersonService) {}

  public ngOnInit() {
    this.inputChanged$=Observable.fromEvent(document.getElementById(""inputSearch""), 'input');
    this.items$= this.inputChanged$
      .map((event:any)=&gt;event.target.value)
      .switchMap((value:string) =&gt;{
        return this._PersonService.getPersons(); &lt;&lt;-- it gets here!****
      })
      .toArray();
    this.items$.subscribe((persons:Person[])=&gt;{
      console.log(persons); &lt;&lt;-- it doesn't gets here!****
    });
  }
}
</code></pre>

<p><strong>Update1:</strong></p>

<p>By GÃ¼nter ZÃ¶chbauer tip, I added menual subscription in the last line of the method but that code is never excuted and nothing gets logged. Any idea why?</p>

<p><strong>Update2:</strong>
I added the full ts file of my code.</p>

<p><strong>Updated3:</strong></p>

<p>Solved - But don't know why: ( I moved toArray() )</p>

<pre><code>  public ngOnInit() {
    this.inputChanged$=Observable.fromEvent(document.getElementById(""inputSearch""), 'input');
    this.items$= this.inputChanged$
      .map((event:any)=&gt;event.target.value)
      .switchMap((value:string) =&gt;{
        return this._PersonService.getPersons().toArray(); &lt;&lt;-- moved here
      }); &lt;&lt;-insead of here.

    this.items$.subscribe((persons:Person[])=&gt;{
      console.log(persons); &lt;&lt;-- it doesn't gets here!****
    });
</code></pre>

<p>Any idea why it made any diffrence?</p>
","806963","","806963","","2016-07-19 11:50:56","2016-07-19 11:50:56","*ngFor | async doesn't work","<javascript><angular><rxjs5>","0","16","","","","CC BY-SA 3.0"
"38473650","2","","38450193","2016-07-20 06:18:44","","1","","<p>I am not entirely sure what you are going for here, but I gave it a shot:</p>

<pre><code>// stream would be your data... just random chunks of numbers as an example here.
const stream = Rx.Observable.range(0, 480).bufferWithCount(100).select(d =&gt; [Math.random() * 100, d]);

class DataChunk&lt;T&gt; {
    constructor(public data: Array&lt;T&gt;) { }
}

const pageSize = 10;

stream
    // I do not understand what the 'number' in your [number, Array&lt;DataItem&gt;]
    // represents. But it is the 'someNumber' item here.. 
    .map(d =&gt; ({someNumber: &lt;number&gt;d[0], data: &lt;number[]&gt;d[1]}))
    .map(d =&gt; ({
        someNumber: d.someNumber,
        pages: Ix.Enumerable
            .fromArray(d.data)
            .select((item, idx) =&gt; ({ pageNr : idx % pageSize, item: item }))
            .groupBy(i =&gt; i.pageNr)
            .select(pageItems =&gt; new DataChunk(pageItems.select(i =&gt; i.item).toArray()))
            .toArray() 
    }))
    .subscribe(dataInfo =&gt; {
        // here each dataInfo sent down the stream will have been split up in to chunks
        // of pageSize
        log('Data recieved: ');
        log('  someNumber: ' + dataInfo.someNumber);
        log('  page count: ' + dataInfo.pages.length);
    });
</code></pre>

<p>Working example on <a href=""https://jsfiddle.net/qdyvc7z4/"" rel=""nofollow"">jsfiddle</a>.</p>

<p>I used <a href=""https://github.com/Reactive-Extensions/IxJS"" rel=""nofollow"">IxJS</a> to do the chunking. It works similarly to RxJS but operates on collections (e.g. arrays) and not streams of evens like RxJS. I hope this was close to what you wanted, your question is not entirely clear.</p>
","1827926","","","","","2016-07-20 06:18:44","","","","0","","","","CC BY-SA 3.0"
"38503485","1","38534453","","2016-07-21 11:49:12","","1","1704","<p>There is a websocket echo service, which send and receive messages:</p>

<pre><code>@Injectable()
export class NotificationsService {
  private ws = new $WebSocket('wss://echo.websocket.org');

  wsSendMessage(message: string = `Message ${Math.random()}`): void {
    this.ws.send(message);
  }

  wsGetMessages(): Observable&lt;string&gt; {
    return Observable.from(this.ws.getDataStream())
      .map((res: any) =&gt; res.data);
  }
}
</code></pre>

<p>Notifications component subscribes to this observable and shows all the messages in the notification dropdown panel:</p>

<pre><code>  getMessages(): void {
    this.notificationsService.wsGetMessages().subscribe(
        (message: string) =&gt; {
          this.messages.unshift(message);
        },
        (err: any) =&gt; console.log(err)
    );    
  }
</code></pre>

<p>I need to show the number of unread messages in the navbar component and set it to 0, when the notification dropdown panel is opened. And I have no ideas about how to do it, so I need your help...</p>

<p><strong>P.S.</strong> </p>

<p>Now websocket echo service is:</p>

<pre><code>@Injectable()
export class NotificationsService {
  private ws = new $WebSocket('wss://echo.websocket.org');

  wsSendMessage(message: string = `Message ${Math.random()}`): void {
    this.ws.send(message);
  }

  wsGetMessages(): Observable&lt;Object&gt; {
    return Observable.from(this.ws.getDataStream())
      .map((res: any) =&gt; res.data);
  }

  messagesReadStream(msgArray: Object[]): Observable&lt;Object&gt; {
    return Observable.from(msgArray);
  }
}
</code></pre>

<p>and notifications component is:</p>

<pre><code>export class Notifications implements OnInit {
  messagesAll:string[] = [];
  messagesRead:string[] = [];
  newMessagesNumber:number = 0;

  constructor(private notificationsService: NotificationsService) {
  }

  addMessage(): void {
    this.notificationsService.wsSendMessage();
  }

  getMessages(): void {
    this.notificationsService.wsGetMessages()
      .subscribe(
        (message: any) =&gt; this.messagesAll.unshift(message),
        (err: any) =&gt; console.error(err)
      );
  }

  readMessages(): void {
    this.messagesRead = this.messagesAll.slice();

    this.notificationsService.messagesReadStream(this.messagesRead)
      .switchMap(() =&gt; 
        this.notificationsService
          .wsGetMessages()
          .scan((unread, _) =&gt; unread + 1, 0)    
          .startWith(0))
      .subscribe(
        (count: number) =&gt; this.newMessagesNumber = count,
        (err: any) =&gt; console.error(err)
      );    
  }

  ngOnInit(): void {
    this.getMessages();
  }  
}
</code></pre>

<p>with template: </p>

<pre><code>&lt;button type=""button"" class=""btn btn-primary-outline btn-sm"" (click) = ""addMessage()""&gt;
  Add message
&lt;/button&gt;  

&lt;button type=""button"" class=""btn btn-primary-outline btn-sm"" (click) = ""readMessages()""&gt;
  Read messages
&lt;/button&gt;  

&lt;div style=""margin-top: 1rem""&gt;
  &lt;span class=""circle bg-warning fw-bold""&gt;
      {{newMessagesNumber}}
  &lt;/span&gt;  
&lt;/div&gt;
</code></pre>

<p>And now if I click <code>button 'Add message'</code> my counter doesn't change value from <code>0</code>. And only if I click <code>button 'Add message'</code>, then click <code>button 'Read messages'</code> and then click <code>button 'Add message'</code> again counter starts working good. Can you explain, what the problem is?</p>
","4802333","","4802333","","2016-07-25 12:30:13","2016-07-25 12:30:13","How to create an observable of the unread messages from the observable of all the messages","<angular><reactive-programming><rxjs><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"38503598","1","","","2016-07-21 11:54:50","","0","793","<p>I've been trying to make a simple relation between an angular 2 component and service, but I can't figure it out how to do so using Observable.</p>

<p>My component <code>HeroViewerComponent</code> subscribes to the router parameter <code>id</code> and passes it to a service <code>HeroService</code> to get <code>Hero</code> when the service get it from the server. <code>HeroService</code> has a method called <code>getHeroSubscription</code> that takes an <code>Observable&lt;number&gt;</code> as a parameter and return <code>Observable&lt;Hero&gt;</code>. But it doesn't work.</p>

<p>Here is my <code>HeroViewerComponent</code> in <code>hero-viewer.component.ts</code>:</p>

<pre><code>import { Component, OnInit, OnDestroy } from ""@angular/core"";
import { ActivatedRoute } from ""@angular/router"";
import { Observable } from ""rxjs/Observable"";
import { Observer } from ""rxjs/Observer"";
import { Subscription } from ""rxjs/Subscription"";

import { HeroService } from ""./hero.service"";
import { Hero } from ""./hero"";

@Component({
    providers: [HeroService]
})
export class HeroViewerComponent implements OnInit, OnDestroy {
    private routeParamsSubscription:Subscription;

    // to the service
    private routeParamsObservable:Observable&lt;number&gt;;

    // the subscriber of the route ID param
    private routeParamsObserver:Observer&lt;number&gt;;

    // from the service
    private heroSubscription:Subscription;

    // the current hero
    hero:Hero;

    constructor(private route:ActivatedRoute, private heroService:HeroService) {}

    ngOnInit() {
        this.routeParamsObservable = new Observable&lt;number&gt;((observer:Observer&lt;number&gt;) =&gt; this.routeParamsObserver = observer);

        this.heroSubscription = this.heroService
            .getHeroSubscription(this.routeParamsObservable)
            .subscribe(
                hero =&gt; this.hero = hero,
                error =&gt; console.warn(error)
            );

        this.routeParamsSubscription = this.route
            .params
            .subscribe(
                params =&gt; this.routeParamsObserver.next( +params[""id""] ),
                error =&gt; console.warn(error)
            );
    }

    ngOnDestroy() {
        this.routeParamsSubscription.unsubscribe();
        this.heroSubscription.unsubscribe();
        this.routeParamsObserver.complete();
    }
}
</code></pre>

<p>Here is my <code>HeroService</code> in <code>hero.service.ts</code>:</p>

<pre><code>import { Injectable } from ""@angular/core"";
import { Http, Response } from ""@angular/http"";
import { Observable } from ""rxjs/Observable"";
import { Observer } from ""rxjs/Observer"";
import ""rxjs/add/operator/merge"";
import ""rxjs/add/operator/map"";
import ""rxjs/add/observable/throw"";
import ""rxjs/add/operator/catch"";

import { Hero } from ""./hero"";

@Injectable()
export class HeroService {
    constructor(private http:Http) {}

    getHeroSubscription(heroIdObservable:Observable&lt;number&gt;):Observable&lt;Hero&gt; {
        let heroObserver:Observer&lt;Hero&gt;;
        let heroObservable = new Observable&lt;Hero&gt;((observer:Observer&lt;Hero&gt;) =&gt; {
            heroObserver = observer;
        });

        let heroIdSubscription = heroIdObservable.subscribe(
            heroId =&gt; {
                const tmp = this.http
                    .get(""api/heroes/"" + heroId)
                    .map((response:Response) =&gt; response.json().data)
                    .catch((response:any) =&gt; {
                        if (response instanceof Response) {
                            return Observable.throw(response.json().error);
                        }
                        return Observable.throw(response);
                    });
                heroObservable.merge(tmp);
            },
            error =&gt; console.warn(error),
            () =&gt; {
                heroIdSubscription.unsubscribe();
                heroObserver.complete();
            }
        );

        return heroObservable;
    }
}
</code></pre>

<p>And here is my <code>Hero</code> in <code>hero.ts</code>:</p>

<pre><code>export class Hero {public id: number;}
</code></pre>

<p>Where is my mistake?</p>
","2112300","","2112300","","2016-07-21 12:05:59","2016-07-21 13:16:55","Two-way binding between an angular 2 component and service using Observable","<typescript><angular><rxjs5>","1","2","","","","CC BY-SA 3.0"
"38530015","1","38535952","","2016-07-22 15:17:00","","1","68","<p>I have a class with a list of users from a server.<br>
Other classes can manipulate the list on the server e.g. call add or delete operation.<br>
My Core-Class has a reference to the other classes which are manipulating the list on the server.</p>

<p>I would like to:</p>

<ul>
<li>Make a init call in Core-Class to get the list on the beginning</li>
<li>The Core-Class will be notified by plugins each time the list was      manipulated on the server, so the Core-Class get the list from the server again.</li>
<li>Notify other classes that the list was reloaded and forward the new list.</li>
</ul>

<p>My structure</p>

<pre><code>Core {

     users: [];

     plugin1: Plugin;
     plugin2: Plugin;

     //Get a new list of users from the server
     loadUsers() {
      userService.loadUsers.then(function (res) {
        this.users = res;
      })
     }

    }

    Plugin {

    //sends a request to the server to create a special user, 
    //depending on plugin implementation
    createUser();
    }
</code></pre>

<p>I'm only just starting of using rx. I understand the factory methods, hot vs cold observable and other basic stuff. But i can not imagine how to do it with rx in the right way.</p>

<p>Thanks.</p>
","5931608","","","","","2016-07-22 22:10:57","Notification between classes using Observable","<system.reactive><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"38534453","2","","38503485","2016-07-22 20:03:02","","2","","<p>You will need more than one <code>Observable</code>. One to contain the count and one to signal when messages have been read. The former will use the <code>wsGetMessage</code> stream while the latter will have to be connected to an Observable that fires whenever the notification panel is opened.</p>

<pre><code>const panelOpened: Observable&lt;any&gt; = //..Need a signalling mechanism for when the messages get read

const unreadCount: Observable&lt;number&gt; = messagesRead.switchMap(() =&gt; 
   this.notificationsService
         .wsGetMessages()
         //Just count all of the messages as they come in.
         .scan((unread, _) =&gt; unread + 1, 0)
         //Make sure it always gets reset to zero
         .startWith(0));

//Subscribe to updates on count changes.
unreadCount.subscribe(count =&gt; this.unreadMessageCount = count);
</code></pre>
","2521865","","","","","2016-07-22 20:03:02","","","","1","","","","CC BY-SA 3.0"
"38535952","2","","38530015","2016-07-22 22:10:57","","1","","<p>My idea of reactive implementation would be:</p>

<p>In your UserService add the following:</p>

<pre><code>var loadSubject = new Subject();
var usersObservable = loadSubject.flatMap(
  Observable.fromPromise(&lt;your http call that returns promise&gt;)).share()

function loadUsers(){
  loadSubject.next(true);
}
</code></pre>

<p>Then each plugin that made changes will simply call:</p>

<pre><code>userService.loadUsers();
</code></pre>

<p>Your Core, plugins, and other classes that would like to get updated will simply do:</p>

<pre><code>loadService.usersObservable.subscribe(function(usersFreshValue){
  this.users = usersFreshValue;
})
</code></pre>

<p>Note that I used the '.share()' to avoid duplication of the data.</p>

<p>Possible improvements:</p>

<ol>
<li><p>Instead of the loadUsers method, have each plugin call userService.loadSubject.next(true);</p></li>
<li><p>Use backpressure/buffering operators to avoid too frequent calls. For example debounce (CAUTION! when used incorrectly, might lead to starvation) or bufferWithTime + filter (to ensure you don't trigger on empty buffers)</p></li>
<li><p>Use behavioral/replay observables so that new subscribers will quickly get the latest value.</p></li>
</ol>
","242098","","","","","2016-07-22 22:10:57","","","","2","","","","CC BY-SA 3.0"
"38544633","1","38544678","","2016-07-23 17:29:06","","1","203","<p>I have a Angular Component like this: </p>

<p>It creates a normal ReplaySubject. (see <code>constructor</code>).
Then some other component get the <code>subject</code> via the method <code>getSubject()</code> and subscribes to it. Another Component sets a new value via <code>setValue</code>. This value should be received by the Subscribers. However, this does not happen. It receives nothing, even no error.</p>

<pre><code>@Injectable()
export class BreadcrumbService {

    subject: ReplaySubject&lt;string&gt;;

    constructor() {
        this.subject = new ReplaySubject&lt;string&gt;();
        console.log('Step 1: Subject created');
    }

    getSubject(): ReplaySubject&lt;string&gt; {
        console.log('Step 2: Return subject for subscribing');
        return this.subject;
    }

    setValue(title: string) {
        console.log('Step 3: Invoke a new value which should be received in the Subscriber of step 2.');
        this.subject.next(title);
    }
}
</code></pre>

<p>If I place the subscription inside <code>setValue()</code> it works as expected.</p>

<p>Here is my Component which should receive the subscription:</p>

<pre><code>export class BreadcrumbComponent implements OnInit {

    constructor(
        private breadcrumbsService: BreadcrumbService
    ) {}

    ngOnInit() {
        this.breadcrumbsService.getSubject()
            .subscribe(
                success =&gt; {
                    console.log(success); // is never called
                },
                error =&gt; {
                    console.log(error); // is never called
                }
            );
    }
}
</code></pre>

<p>How can my subscriber receive this value? </p>
","5798225","","","","","2016-07-23 17:37:33","RxJS, Angular: Cannot receive result of subscription in other methods","<angular><rxjs><observable><rxjs5>","2","1","","","","CC BY-SA 3.0"
"38544678","2","","38544633","2016-07-23 17:33:30","","0","","<p>I haven't seen a mistake but
I assume you provide <code>BreadcrumbService</code> more than once.<br>
Angular2 maintains a single instance per provider. If you provide more than once there will be multiple instances. I assume that the instance that calls <code>setValue</code> does it on a different instance than the <code>BreadcrumbComponent</code> got.</p>

<p>If you want a shared instance provide it at a common parent (for example the root componeent).</p>
","217408","","","","","2016-07-23 17:33:30","","","","1","","","","CC BY-SA 3.0"
"38547415","1","38547449","","2016-07-23 23:51:00","","2","213","<p>I'm creating a class for my app that keeps an internal <a href=""http://reactivex.io/rxjs/class/es6/BehaviorSubject.js~BehaviorSubject.html"" rel=""nofollow""><code>BehaviorSubject</code></a>. Is there a way I can expose a corresponding '<code>BehaviorObservable</code>', which pipes through the values of the subject, but only has the 'read-only' stuff of the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""nofollow""><code>Observable</code></a> interface? The <code>.next()</code>, <code>.error()</code> and <code>.complete()</code> methods should only be available internally.</p>

<p>It's not just a matter (I believe) of using <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-subscribe"" rel=""nofollow""><code>Observable.create()</code></a> to pipe the subject's values through. Users of my API should <code>.subscribe()</code> to the exposed observable, and then immediately get a callback for the stored current value.</p>

<p>I may be able to hack something together, but I'm sure I'm just missing something that RxJS can already do.</p>
","681588","","3743222","","2016-11-18 05:09:21","2016-11-18 05:09:21","RxJS 5: Can I create a `BehaviorObservable`?","<javascript><rxjs><observable><rxjs5><behaviorsubject>","1","0","","","","CC BY-SA 3.0"
"38547449","2","","38547415","2016-07-23 23:57:15","","1","","<p>Are you by any chance looking for the <code>.asObservable()</code> method - which existed in Rxjs v4. Don't know if that is still the case in Rxjs v5 though.</p>

<p>According to <a href=""http://www.ceus-now.com/how-to-transform-a-subject-into-an-observable-in-rxjs-5/"" rel=""nofollow noreferrer"">this</a>, the method should have been included in release 5.0.0-beta.2. Also I quote here their work-around if the functionality is not there :</p>

<blockquote>
  <p>You can get the same functionality by creating an observable with the private subject's subscribe function:</p>

<pre><code>&gt; const subj = new rx.Subject();
&gt; const exposed = new rx.Observable(fn =&gt; subj.subscribe(fn));
</code></pre>
</blockquote>

<p>For more details about subjects' semantics, you can have a look <a href=""https://stackoverflow.com/questions/34849873/what-are-the-semantics-of-different-rxjs-subjects/34860777#34860777"">here</a>.</p>
","3743222","","-1","","2017-05-23 12:30:24","2016-07-23 23:57:15","","","","1","","","","CC BY-SA 3.0"
"38551916","1","38552278","","2016-07-24 12:16:15","","2","1622","<p>Is there any way how to compose functions with RxJS without dot notation.</p>

<p>Use case: My stream of event may be processed by configurable functions and I want to configure them just by adding to the array.</p>

<pre><code>const result$ = source$.map(function1).map(function2).map(function3)
</code></pre>

<p>I'd like to have <code>farray = [function1, function2, function3]</code> and use it as follows:</p>

<pre><code>const result$ = source$.compose(farray)
</code></pre>

<p>The reason is that it should be able to change the <code>farray</code> during execution (or during init).</p>

<p>I found <a href=""https://github.com/cognitect-labs/transducers-js"" rel=""nofollow"">transducers-js</a> but not sure how it's <code>map</code> and <code>filter</code> and other play with Rx counterparts.</p>

<p>Thanks for any tip.</p>
","4461438","","","","","2016-07-25 19:26:22","Compose functions/operators with RxJS","<javascript><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38552278","2","","38551916","2016-07-24 12:56:15","","3","","<p>You can just use Rambda.compose with map. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const functions = [x =&gt; x * 2, x =&gt; x + 1]

Rx.Observable
  .range(0, 10)
  .map(R.compose(...functions))
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.js""&gt;&lt;/script&gt;
&lt;script src=""//cdnjs.cloudflare.com/ajax/libs/ramda/0.21.0/ramda.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Or You can create your own operator:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const functions = [x =&gt; x * 2, x =&gt; x + 1];

Rx.Observable.prototype.mapCompose = function (functions) {
  return this.map(R.compose(...functions));
};

Rx.Observable
  .range(0, 10)
  .mapCompose(functions)
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.js""&gt;&lt;/script&gt;
&lt;script src=""//cdnjs.cloudflare.com/ajax/libs/ramda/0.21.0/ramda.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Ofc, Rambda compose can be switched for any other compose implementation.</p>

<p>Edit:
Composing Rx operators is a little bit more complicated. It is hard to imagine how it would look like, not to mention implementing it. But you can always compose (or apply) some functions that take observable and return observable. Here is example implementation. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.prototype.apply = function (functions) {
  functions = [].concat(functions);
  
  return functions.reduce(function (observable, func) {
    return func(observable);
  }, this);
};

var functions = [obs =&gt; obs.map(x =&gt; x*2), obs =&gt; obs.filter(x =&gt; x % 3 === 0)];

Rx.Observable
  .range(0, 15)
  .apply(functions)
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","6356166","","6356166","","2016-07-25 19:26:22","2016-07-25 19:26:22","","","","2","","","","CC BY-SA 3.0"
"38555971","1","38599520","","2016-07-24 19:34:04","","2","6448","<p>Iâm doing a check for existing login at start of app which I want only once.  How do we cancel that subscription after the first time?  I tried take(1) but that doesn't seem to work.  </p>

<pre><code>this.auth.getUserData().take(1).subscribe(data =&gt; { // the take(1) doesn't work
  console.log('Firebase responded with success.');
  this.rootPage = TabsPage;
 }, err =&gt; {
  console.log('Firebase responded with error.', err);
  this.rootPage = LoginEmailPage;
 }
);
</code></pre>
","791842","","","","","2016-07-28 05:20:32","Cancel observable after first time - Angular2, TypeScript, rxjs/Observable","<typescript><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"38558619","1","","","2016-07-25 01:43:46","","0","614","<p>New to angular and confused with the <code>flatMap</code> function.</p>

<pre><code>export interface IProduct {
    productId: number;
    productName: string;
    versionUrl: string;
    versionObj: any;
}
</code></pre>

<h2>product.service.ts:</h2>

<p>First HTTP request returns array of <code>IProduct</code> objects.
Make HTTP request for each product using the <code>versionUrl</code> from the product object and map the resulting object to <code>product.versionObj</code>.</p>

<p><code>product.versionObj</code> ==> should be mapped to the result of each product's HTTP request.</p>

<pre><code>getAllProductsWithAddlInfo(): Observable&lt;IProduct[]&gt; {
      return this._http.get('products.json')
             .flatMap((response: Response) =&gt; response.json())
             .flatMap((product: IProduct) =&gt; this._http.get(product.versionUrl), 
                     (product: IProduct, resp) =&gt; resp.json())   
</code></pre>

<h2>product-list.component.ts:</h2>

<pre><code>products: IProduct[];

/* 
I would like to get an array of products with the additional info object 
mapped to versionObj from the http call for each product 
*/

ngOnInit(): void {
     this._productService.getAllProductsWithAddlInfo()
        .subscribe(
            products =&gt; this.products = products,
            error =&gt; this.errorMessage = &lt;any&gt;error);

    console.log(this.products);
}
</code></pre>
","6626556","","1850609","","2016-07-26 00:52:25","2016-07-26 00:52:25","Angular 2 chain http requests with iterable array and merge resutls","<typescript><angular><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"38575886","1","","","2016-07-25 19:23:56","","1","351","<p>I'm using RxJS 5 (beta10) in a <a href=""https://github.com/akauppi/svg.rx.js"" rel=""nofollow noreferrer"">project</a>. Most of my events originate from a mouse or touch drag, and I would only ever need to hear the last one.</p>

<p>i.e. How do I do a lossy stream in RxJS5?</p>

<p>Running the demos in certain tablets clearly show a ""drag"" that happens when the update of the graphics takes longer than the event ignition from the browser (which is not continuous, even itself - browsers seem to optimize on the interval they actually tell things changed).</p>

<p>With a lossy data stream I'd be able to make the user experience always keep up with the finger.</p>

<hr>

<p><strong>Edit:</strong></p>

<p><a href=""https://stackoverflow.com/questions/35343183/rxjs-control-observable-invocation#answer-35347136"">This answer</a> seems to sum up the current state of RxJS5 backpressure pretty well.</p>
","14455","","-1","","2017-05-23 11:44:23","2016-07-30 22:11:07","How to skip too frequent mouse events in RxJS 5 (beta)?","<rxjs5><backpressure>","2","2","","","","CC BY-SA 3.0"
"38589383","1","38597106","","2016-07-26 12:03:12","","15","11261","<p>In <code>redux-observable</code> is it possible to use <a href=""https://github.com/matthew-andrews/isomorphic-fetch"" rel=""noreferrer"">isomporphic-fetch</a> instead of <a href=""https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/doc/operators/ajax.md"" rel=""noreferrer"">Rx.DOM.ajax</a>?</p>
","1075289","","1770633","","2016-10-12 06:59:15","2019-08-13 07:39:42","Use fetch instead of ajax with redux-observable","<ajax><redux><rxjs5><isomorphic-fetch-api><redux-observable>","2","0","3","","","CC BY-SA 3.0"
"38590346","1","38597548","","2016-07-26 12:48:34","","19","5172","<p>On <a href=""https://github.com/ReactiveX/RxJS#goals"">RxJS - Goals</a> I read that their goal is better debuggability: </p>

<blockquote>
  <p>Goals</p>
  
  <p>Provide more debuggable call stacks than preceding versions of RxJS</p>
</blockquote>

<p>I have just started to use <code>redux-observable</code> which is quite easier for me to understand comparing it to <code>redux-saga</code> as I am already used to the reactive style with <code>lodash</code> and <code>ramda</code> (ok, fp style maybe ;). I was surprised that it's not possible to debug it yet. Is it true? If so, then I gotta switch to <code>redux-saga</code>s maybe or stick with <code>redux-thunk</code>.</p>

<p><strong>Edit based on Jay Phelps's answer</strong></p>

<p>By debugging I meant: ""How to set a breakpoint on e.g. <code>observable.map(...)</code> in a browser?"" With <code>lodash</code> I can set a breakpoint in the browser and it stops right there on the <code>_.map(...)</code>. How to do it with <code>redux-observable</code> (or <code>rxjs</code>)? I don't want to depend on drawing of marble diagrams and <code>console.log()</code>.</p>
","1075289","","1075289","","2016-07-26 20:32:02","2017-01-10 09:48:09","How to debug rxjs5?","<debugging><rxjs5><redux-saga><redux-observable>","2","1","5","","","CC BY-SA 3.0"
"38595386","1","","","2016-07-26 16:35:12","","2","1615","<p>Dou you have a working example for me ? Which use-case can/should apply this pattern? The information here: <a href=""http://reactivex.io/documentation/operators/and-then-when.html#collapseRxJS"" rel=""nofollow"">http://reactivex.io/documentation/operators/and-then-when.html#collapseRxJS</a> is very short.</p>
","","user2227400","","","","2017-02-02 10:33:54","RxJS and-thenDo-when example","<operators><rxjs5>","1","1","","","","CC BY-SA 3.0"
"38597106","2","","38589383","2016-07-26 18:13:48","","51","","<p>(Note: <code>RX.DOM.ajax</code> is from RxJS <strong>v4</strong>, and doesn't work with <code>redux-observable</code> which requires <a href=""https://github.com/ReactiveX/rxjs/tree/master/src"" rel=""noreferrer"">RxJS <strong>v5</strong></a>. The equivalent in v5 is <a href=""http://reactivex.io/rxjs/file/es6/observable/dom/AjaxObservable.js.html"" rel=""noreferrer""><code>Rx.Observable.ajax</code></a> or <code>import { ajax } from 'rxjs/observable/ajax';</code>)</p>

<p>It is indeed possible to use <code>fetch()</code> as well as any other AJAX API; though some adapt easier than others!</p>

<p>The <code>fetch()</code> API returns a <code>Promise</code>, which RxJS v5 has <em>built-in support for</em>. Most operators that expect an observable can consume Promises as-is (like <code>mergeMap</code>, <code>switchMap</code>, etc). But often you'll want to apply Rx operators to the Promise before passing it along to the rest of your Epic, so you'll often want to wrap the Promise inside an Observable.</p>

<p><strong>You can wrap a Promise into an Observable with <code>Observable.from(promise)</code></strong></p>

<p>Here's an example where I fetch for a user, request the JSON response, then wrap the promise in an observable:</p>

<pre class=""lang-js prettyprint-override""><code>const api = {
  fetchUser: id =&gt; {
    const request = fetch(`https://jsonplaceholder.typicode.com/users/${id}`)
      .then(response =&gt; response.json());
    return Observable.from(request);
  }
};
</code></pre>

<p>You can then consume that in your Epic and apply any operators you want:</p>

<pre><code>const fetchUserEpic = action$ =&gt;
  action$.ofType(FETCH_USER)
    .mergeMap(action =&gt;
      api.fetchUser(action.payload) // This returns our Observable wrapping the Promise
        .map(payload =&gt; ({ type: FETCH_USER_FULFILLED, payload }))
    );
</code></pre>

<p>Here's a JSBin with this working example: <a href=""https://jsbin.com/fuwaguk/edit?js,output"" rel=""noreferrer"">https://jsbin.com/fuwaguk/edit?js,output</a></p>

<hr>

<p>If you have control over the API code, ideally you would use <code>Observable.ajax</code> (or any other Observable-based AJAX utils) because Promises cannot be cancelled. (as of this writing)</p>
","1770633","","1770633","","2017-11-21 01:30:13","2017-11-21 01:30:13","","","","1","","","","CC BY-SA 3.0"
"38597548","2","","38590346","2016-07-26 18:39:15","","16","","<p>It certainly is possible to debug RxJS code. I think it's probably safe to say hardly anyone would use it if that wasn't the case--Angular2 is heavily built on it too.</p>

<p>The most common ways people use are the same ways they debug other JavaScript, breakpoints (e.g. debugger) and console.log()'s</p>

<p>There are more advanced techniques some users use like drawing dependency graphs or marble diagrams. <a href=""http://staltz.com/how-to-debug-rxjs-code.html"">AndrÃ© Staltz wrote about this</a> recently, so that might be a helpful resource.</p>

<p>Ultimately, any kind of async programming is going to be harder to debug. This is not unique to redux-observable/RxJS; a quick search will reveal plenty of debugging concerns for redux-saga too.</p>

<p>It turns out that redux-thunk is the best solution for a vast majority of applications built because a majority of them do not have complex side effect concerns that justify something like redux-observable or redux-saga. Though if you are already proficient in RxJS, there's nothing <em>wrong</em> with using redux-observable.</p>

<p>redux-saga as a project has existed longer than redux-observable so that's certainly one major selling point. You'll find more documentation, examples, and likely are have a better community to get support from.</p>

<p>The counter being that the operators and APIs you learn in redux-saga aren't nearly as transferable as learning RxJS, which is used all over the place. redux-observable is super super <strong>super</strong> simple internally, it's really just giving you a natural way for you to use RxJS. So if you know RxJS (or want to), it's an extremely natural fit.</p>

<p>My advice at the moment for most people is that if you have to ask which one you should use, you probably should choose redux-saga.</p>

<p>(disclaimer: I am one of the maintainers of redux-observable and RxJS v5)</p>
","1770633","","1770633","","2016-07-27 20:59:01","2016-07-27 20:59:01","","","","5","","","","CC BY-SA 3.0"
"38599520","2","","38555971","2016-07-26 20:43:21","","2","","<p>Have you tried <code>first()</code> instead of <code>take(1)</code></p>

<p>Depending on your imports at the module level, you may want to add an import for the <strong>first</strong> operator</p>

<pre><code>import 'rxjs/add/operator/first'
</code></pre>

<p>While this does not actually cancel the subscription, it completes the observation which is which I believe is what was meant.</p>

<p>EDIT: adding the explicit way of cancelling the subscription as originally requested by the OP</p>

<p>The result of .subscribe(...) will return a handler to the subscription. You can use that handle to explicitly cancel the subscription and the code would look like this:</p>

<pre><code>let subscription = this.auth.getUserData().take(1).subscribe(data =&gt; { // the take(1) doesn't work
  console.log('Firebase responded with success.');
  this.rootPage = TabsPage;
  subscription.unsubscribe();
 }, err =&gt; {
  console.log('Firebase responded with error.', err);
  this.rootPage = LoginEmailPage;
 }
);
</code></pre>

<p>While it feels wrong to explicitly cancel the subscription in this case, a common pattern is to create the subscription within <code>ngOnInit()</code> or based on post init events, and cancel pending subscriptions within the <code>ngOnDestroy()</code>.</p>
","84376","","84376","","2016-07-28 05:20:32","2016-07-28 05:20:32","","","","3","","","","CC BY-SA 3.0"
"38611336","1","38613494","","2016-07-27 11:12:02","","0","89","<p>There are two streams, which never completes:</p>

<pre><code>--a---b-c-d---e--f----&gt;

-----1-------2------3--&gt;
</code></pre>

<p>I want to get events from the first stream which happened after the last event from the second stream. </p>

<p>At the beginning it looks like this:</p>

<pre><code>--a-&gt;
 (?)
----&gt;
 (=)
--a-&gt;
</code></pre>

<p>After the second stream emits first event it looks like this:</p>

<pre><code>--a---b-c-d-&gt;
    (?)
-----1------&gt;
    (=)
------b-c-d-&gt;
</code></pre>

<p>After a new event in the second stream:</p>

<pre><code>--a---b-c-d---e--f-&gt;
        (?)
-----1-------2-----&gt;
        (=)
--------------e--f-&gt;
</code></pre>

<p>And so on... Which set of operators needed to do this?</p>
","4802333","","4802333","","2016-07-27 11:28:54","2016-07-27 22:27:11","How to get events from one stream which happened after the last event from other stream","<javascript><angular><reactive-programming><rxjs><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"38613494","2","","38611336","2016-07-27 12:50:20","","2","","<p>You can use <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/combinelatest.md"" rel=""nofollow"">CombineLatest</a> to return the events as you would like, for example:</p>

<pre><code>/* Have staggering intervals */
var source1 = Rx.Observable.interval(1000)
    .map(function(i) {

        return {
            data: (i + 1),

            time: new Date()
        };
    });

var source2 = Rx.Observable.interval(3000).startWith(-1)
    .map(function(i) {

        return {
            data: (i + 1),
            time: new Date()
        };
    });

// Combine latest of source1 and source2 whenever either gives a value with a selector
var source = Rx.Observable.combineLatest(
    source1,
    source2,
    function(s1, s2) {

        if (s1.time &gt; s2.time) {
            return s1.data + ', ' + s2.data;
        }

        return undefined;
    }
).filter(x =&gt; x !== undefined).take(10);

var subscription = source.subscribe(
    function(x) {
        console.log('Next: %s', x);
    },
    function(err) {
        console.log('Error: %s', err);
    },
    function() {
        console.log('Completed');
    });
</code></pre>
","386188","","","","","2016-07-27 12:50:20","","","","0","","","","CC BY-SA 3.0"
"38619779","1","","","2016-07-27 17:39:58","","1","466","<p>I must iterate over array, find correspondent objects in other array an merge the result in a object.</p>

<p>Assume I have three arrays</p>

<pre><code>var users = [
    { name: ""A"", type: 2, level: 1 },
    { name: ""B"", type: 1, level: 2 }
]
var types = [
    { description: ""Type 1"", id: 1 },
    { description: ""Type 2"", id: 2 }
]
var levels = [
    { description: ""Level 1"", id: 1 },
    { description: ""Level 2"", id: 1 }
]
</code></pre>

<p>I want to have following result:</p>

<pre><code>var users = [
    { name: ""A"", type: 2, level: 1, levelDescription: ""Level 1"", typeDescription: ""Type 2"" },
    { name: ""B"", type: 1, level: 2, levelDescription: ""Level 2"", typeDescription: ""Type 1"" }
]
</code></pre>

<p>I know I can achieve it like that</p>

<pre><code>var usersObservable = RX.Observable.fromArray(users);
var typesObservable = Rx.Observable.fromArray(types);
var levelsOBservable = Rx.Observable.fromArray(levels);

var uiUsers= [];// not really needed because I will use the same users array again.

usersObservable.map(function(user) {
      typesObservable.filter(function(type) {
        return type.id == user.type;
    }).subscribeOnNext(function(userType) {
        user.typeDescription = userType.description;
    });
    return user;
}).map(function(user) {
       levelsOBservable.filter(function(level) {
        return level.id == user.levelId;
    }).subscribeOnNext(function(level) {
        user.levelDescription = level.description;
    });
    return user;
})
.subscribeOnNext(function(user) {
    uiUsers.push(user);
})
</code></pre>

<p>I would like to have a solution without nested Observables.<br>
Thanks.</p>
","5931608","","","","","2016-09-08 20:13:13","How to iterate over multiple arrays without nested observables","<system.reactive><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"38658582","1","38665100","","2016-07-29 12:14:35","","3","2304","<p>I'm in the process of learning RxJS and i constantly try many operators and combinations that i find interesting.</p>

<p>I'm learning form here: <a href=""http://reactivex.io/documentation/operators.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators.html</a> and <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md"" rel=""nofollow noreferrer"">here</a>.</p>

<p>I have an Angular2 rc4 CLI project - so i'm using Typescript. RxJS is : 5.0.0-beta.6</p>

<p><strong>The problem:</strong> </p>

<p><strong><em>I found that some operators are not present on the Observable.</em></strong></p>

<p>For example: I want to create an observable that returns one by one key value pairs of an object:
You can see how the implementation looks like, as i've taken it <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/pairs.md"" rel=""nofollow noreferrer"">from here</a>.</p>

<pre><code>// Using Standard JavaScript
var obj = {
  foo: 42,
  bar: 56,
  baz: 78
};

var source = Rx.Observable.pairs(obj);

var subscription = source.subscribe(
  function (x) {
    console.log('Next: %s', x);
  },
  function (err) {
    console.log('Error: %s', err);
  },
  function () {
    console.log('Completed');
  });

// =&gt; Next: ['foo', 42]
// =&gt; Next: ['bar', 56]
// =&gt; Next: ['baz', 78]
// =&gt; Completed
</code></pre>

<p>But here is what my editor looks like:</p>

<p><a href=""https://i.stack.imgur.com/RjEVX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RjEVX.png"" alt=""enter image description here""></a></p>

<p>no Intelisense for Observable.pairs()..</p>

<p><a href=""https://i.stack.imgur.com/9DDZ0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9DDZ0.png"" alt=""enter image description here""></a></p>

<p>Based on <a href=""https://manuel-rauber.com/2016/01/04/where-are-my-observable-operators/"" rel=""nofollow noreferrer"">this post</a> i've aded the 2 imports:</p>

<pre><code>import {Observable} from ""rxjs/Rx"";
import 'rxjs/Rx'; // import all operators and stuff. it's not good practice i know, but only for this example
</code></pre>

<p>And tryed to install more typings for rxjs than angular cli provides, but is not working:</p>

<pre><code>typings install --save --ambient npm:rx/ts/rx.all.d.ts // Unable to resolve ""npm:rx/ts/rx.all.d.ts"" from ""rx""
or
typings install rxjs // Unable to find ""rxjs"" (""npm"") in the registry.
</code></pre>

<p>And aslo tryed to use:</p>

<pre><code>import * as Rx form 'rxjs/Rx'
myObjProperties$ = Rx.Observable.pairs(myObj) // still doesn't work, same error.
</code></pre>

<p>And aslo, I can't explain why printing the Observable object to the console doesn't work.. I get a <code>string-function</code> which is useless. No prototype stuff.</p>

<pre><code>console.log('TheAllmightyObservable : ', Observable) // i get:

// TheAllmightyObservable :  function Observable(subscribe) {
        // this._isScalar = false;
        // if (subscribe) {
            // this._subscribe = subscribe;
        // }
    // }
</code></pre>

<p>I have the <strong>same problem with many other operators</strong>: ofObjectChanges, ofArrayChanges, ofWithSkeduler, pairs - some of them not that important - but it bugs me when i found one RxJs operator that is very useful, and i can't use it in angular2 CLI project.</p>

<p><strong>Questions:</strong></p>

<ol>
<li><p>what angular2 has to do with RxJS ? (i'm missing the general picture i guess..) - is there a separate list of angular2-rxjs operators or RxJS is fully separated package, and can be used like Jquery for example? I mean no wired interference between the 2 - that i can't predict. (digest cycle related maybe?!)</p></li>
<li><p>where can i find a good list of all the RxJS operators available on angular2 - assuming that exists.</p></li>
<li><p>is this only a Typescript - typings problem? If so, how to install them in order to have all the operators which are available on the docs? If no typings are available, how to <strong>temporarily</strong> get rid of this <code>""no property/method found on x""</code> problem?</p></li>
</ol>

<p>Thank you so much for taking the time to read and help me by finding a solution to this:)</p>
","5904566","","","","","2016-07-29 18:12:09","some RxJS operators are missing from angular2 CLI project? What to do?","<typescript><angular><rxjs><strong-typing><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"38662155","1","","","2016-07-29 15:13:02","","40","11986","<p>Is there a short and simple way to pass an RxJS <a href=""http://reactivex.io/rxjs/class/es6/Subject.js~Subject.html"" rel=""noreferrer""><code>Subject</code></a> or <a href=""http://reactivex.io/rxjs/class/es6/BehaviorSubject.js~BehaviorSubject.html"" rel=""noreferrer""><code>BehaviorSubject</code></a> to an an Angular 2 directive for two-way binding? The long way to do it would be as follows:</p>

<pre><code>@Component({
    template: `
        &lt;input type=""text"" [ngModel]=""subject | async"" (ngModelChange)=""subject.next($event)"" /&gt;
    `
})
</code></pre>

<p>I'd like to be able to do something like this:</p>

<pre><code>@Component({
    template: `
        &lt;input type=""text"" [(ngModel)]=""subject"" /&gt;
    `
})
</code></pre>

<p>I believe the <code>async</code> pipe is only one-way, so that's not enough. Does Angular 2 provide a short and simple way to do this? Angular 2 uses RxJS too, so I expected there to be some inherent compatibility.</p>

<p>Could I perhaps create a new <code>ngModel</code>-like directive to make this possible?</p>
","681588","","681588","","2016-07-29 15:21:32","2021-07-13 16:18:09","How to two-way bind my own RxJS Subject to an [(ngModel)]?","<angular><rxjs><angular-ngmodel><rxjs5>","6","7","10","","","CC BY-SA 3.0"
"38665100","2","","38658582","2016-07-29 18:12:09","","5","","<p>Root issue: You are using one version of RxJS but looking at the documentation for another. </p>

<p>RxJS 5 (beta) used with Angular 2: <a href=""https://github.com/ReactiveX/rxjs"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs</a>
RxJS 4 (stable): <a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS</a></p>

<p>Those operators do not exist on the new version which is why you can't see them.</p>

<p>To your questions:</p>

<p>1) RxJS doesn't have anything to do with Angular2, you can use RxJS without Angular2. RxJS is just a library for creating event streams, it operate orthogonally to what ever you use to <em>generate</em> events.</p>

<p>2) If you are using RxJS 4 then you can use the <a href=""https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api"" rel=""noreferrer"">docs</a> which are pretty good. RxJS 5 is still a work in progress but there are docs that are generated by the build process <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""noreferrer"">here</a>.</p>

<p>3) It is not a typings issue in this case.</p>
","2521865","","","","","2016-07-29 18:12:09","","","","0","","","","CC BY-SA 3.0"
"38689309","1","","","2016-07-31 23:39:53","","0","26","<p>I'm mostly a newbie to JavaScript and RxJs so my question may not even make sense but I'm trying to understand if Observables in RxJavaScript ought to be used in conjunction with an async library or does it handle it internally?</p>
","852982","","","","","2016-08-03 16:44:29","Does Observables in RxJavaScript imply asynchronous execution","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"38712801","1","","","2016-08-02 06:01:49","","1","473","<p>I'm getting started with an Angular2 app.  My very simple Angular2 app is very slow to load.  I noticed a lot of different RXJS files are initially loaded.  Are all of these RXJS files needed?  Is there a way to limit what RXJS files get loaded?  My Angular 2 app is getting all of the related RXJS files from node_modules.  What's the best way to optimize RXJS?</p>

<p>Here is my app.component file:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES } from '@angular/router';

@Component
	({
		moduleId: module.id,
		selector: 'my-app',
		templateUrl: './app.component.html',
		directives: [ROUTER_DIRECTIVES]
	})

export class AppComponent
{
}</code></pre>
</div>
</div>
</p>

<p>here is my system.config.js:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/**
 * System configuration for Angular 2 samples
 * Adjust as necessary for your application needs.
 */
(function (global)
{
	// map tells the System loader where to look for things
	var map =
		{
			'app': '', // 'dist',
			'@angular': '/lib/@angular',
			'angular2-in-memory-web-api': '/lib/angular2-in-memory-web-api',
			'gitana': '/lib/gitana/gitana.min.js',
			'rxjs': '/lib/rxjs'
		};

	// packages tells the System loader how to load when no filename and/or no extension
	var packages =
		{
			'app': { main: 'app/main.js', defaultExtension: 'js' },
			'angular2-in-memory-web-api': { main: 'index.js', defaultExtension: 'js' },
			'rxjs': { defaultExtension: 'js' }
		};

	var ngPackageNames =
		[
			'common',
			'compiler',
			'core',
			'forms',
			'http',
			'platform-browser',
			'platform-browser-dynamic',
			'router',
			'router-deprecated',
			'upgrade',
		];

	// Individual files (~300 requests):
	function packIndex(pkgName)
	{
		packages[ '@angular/' + pkgName ] = { main: 'index.js', defaultExtension: 'js' };
	}

	// Bundled (~40 requests):
	function packUmd(pkgName)
	{
		packages[ '@angular/' + pkgName ] = { main: '/bundles/' + pkgName + '.umd.js', defaultExtension: 'js' };
	}

	// Most environments should use UMD; some (Karma) need the individual index files
	var setPackageConfig = System.packageWithIndex ? packIndex : packUmd;

	// Add package entries for angular packages
	ngPackageNames.forEach(setPackageConfig);

	var config =
		{
			map: map,
			packages: packages
		};

	System.config(config);
})(this);</code></pre>
</div>
</div>
</p>
","418549","","418549","","2016-08-02 13:43:48","2016-08-02 13:43:48","how to specify the RXJS files needed for an Angular2 app","<angular><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"38713552","1","38714099","","2016-08-02 06:51:07","","0","118","<p>How do I wait for one stream (say, <code>StreamA</code>) to return non-null value and then invoke <code>StreamB</code> subscribe function. I'm not particularly interested in <code>StreamA</code>'s value. In turn, I am trying to get <code>StreamB</code>'s value which might have been updated before the StreamA returned non-null value, and might not have any new events. </p>

<p>I tried, <em>pausable</em>, by looking at this: <a href=""https://stackoverflow.com/questions/28315026/rxjs-how-can-i-do-an-if-with-observables"">RxJS: How can I do an &quot;if&quot; with Observables?</a>, but unfortunately could not get it to work. This is because, there are no exported class <code>pausable</code>, rxjs v 5.0.0-beta.6.</p>

<p>This is how far, I've come up with, as per the answer.</p>

<p>export class AuthService {
      userModel: FirebaseListObservable = this.af.database.list(<code>/users</code>);
      constructor(private af: AngularFire) {</p>

<pre><code>    var user = this.currentAuthor();
    var userStream = user;

    this.af.auth.flatMap((d) =&gt; { console.log(d);return this.userModel.publishReplay(1); });

    this.userModel
      .subscribe((data) =&gt; {
        var flag = false;
        data.forEach((item) =&gt; {
          if (item.$key &amp;&amp; item.$key === user.uid) {
            flag = true;
            return;
          }
        });

        if (flag) {
          console.log('hello');
        } else {
          this.userModel.push({
              firstName: user.auth.displayName.substr(0, user.auth.displayName.lastIndexOf(' ')),
              lastName: user.auth.displayName.substr(user.auth.displayName.lastIndexOf(' '), user.auth.displayName.length),
              displayPic: user.auth.photoURL,
              provider: user.provider,
              uid: user.uid
            }
          );
        }
      })
  }
  public currentAuthor():FirebaseAuthState  {
    return this.af.auth.getAuth();
  }
</code></pre>

<p>Hope, I can make myself clear. Even I am getting confused now. :p.</p>

<p>I am new to rxjs and reactive programming. And, any help will be appreciated.</p>

<p>And, btw, thanks for stopping by. :)</p>
","2149883","","-1","","2017-05-23 11:46:44","2016-11-18 05:09:32","Wait for a stream before invoking another stream","<javascript><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38714099","2","","38713552","2016-08-02 07:20:14","","1","","<p>I suppose by <code>plausible</code> you mean <code>pausable</code>? I am not sure what exactly you are trying to achieve here (control flow?). However, if you want streamB value after streamA produces a value, then you can use <code>flatMap</code>.</p>

<p><code>streamA.flatMapLatest(function (_){return streamB})</code></p>

<p>That should give you, anytime <code>streamA</code> emits, the values emitted after that time by <code>streamB</code>.</p>

<p>If you want values including the last one B emitted prior to that time, you can use <code>streamBB = streamB.publishReplay(1)</code> and </p>

<p><code>streamA.flatMapLatest(function (_){return streamBB})</code></p>

<p>Haven't tested it, so keep me updated if that works.</p>
","3743222","","","","","2016-08-02 07:20:14","","","","3","","","","CC BY-SA 3.0"
"38720547","1","38749158","","2016-08-02 12:33:28","","0","181","<pre><code>---abcde-----f-------gh-----i----&gt;  //Events
</code></pre>

<p>I have a ""work queue"" that I want to observe/subscribe to. This is an array of command objects to process. New items of work typically arrive in bursts and they need to be processed serially (in the order received, one at a time, until fully processed). </p>

<p>I'm using RxJS 5.0.0-beta.6. (version imposed by other libraries)</p>

<p>Here is a working example that illustrates the behavior I want, but uses RxJS v4. </p>

<p>The main code in question is this...</p>

<pre><code>var events$ = Rx.Observable.fromEvent(produceEvent, 'click')
  .timestamp()
  .tap(({timestamp}) =&gt; updatePanelAppend(pending, timestamp));

var inProgress$ = events$;

var done$ = inProgress$
  .flatMapWithMaxConcurrent(1, ({timestamp}) =&gt; 
                            Rx.Observable.fromPromise(() =&gt; {
                              updatePanelAppend(inProgress, timestamp);
                              removeFromPanel(pending, timestamp);
                              return expensiveComputation(getRandomInt(1, 5) * 1000, timestamp)
                           }));

done$.subscribeOnNext((timestamp) =&gt; {
  updatePanelAppend(done, timestamp);
  removeFromPanel(inProgress, timestamp);
});
</code></pre>

<p><a href=""http://jsbin.com/meyife/edit?js,output"" rel=""nofollow"">http://jsbin.com/meyife/edit?js,output</a></p>

<p>Given the current beta state of the API and incomplete/changing documentation, I can't figure out how to do this in RxJS 5.</p>

<p><strong>Update</strong>: This <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""nofollow"">migration guide</a> for moving from v4 to v5 shows many function that were removed, but does not direct how to do things the new way. Examples of removed operations: .tap, .controlled, .flatMapWithMaxConcurrent (renamed).</p>
","244707","","244707","","2016-08-03 04:23:57","2016-08-03 16:32:46","Converting RxJS v4 code to v5, processing a queue with a ""pull""","<javascript><rxjs><observable><rxjs5><backpressure>","1","1","","","","CC BY-SA 3.0"
"38735678","1","","","2016-08-03 06:08:43","","1","644","<p>I want to force an rxjs subject to have only one subscriber at a time.
and I want to count the number of subscriptions to enforce the condition</p>

<pre><code> import { Subject } from 'rxjs/Subject';


/**
 * FormDialogActionModel
 */
export class FormDialogActionModel {
    public $customAction: Subject&lt;CustomAction&gt; = new Subject&lt;CustomAction&gt;();

    private positiveActionSubscribers: number = 0;
    private customActionSubscribers: number = 0;
    private $positiveAction: Subject&lt;Object&gt; = new Subject&lt;Object&gt;();    
    private internalToken = 'FORM-DIALOG-SERVICE-GET-POSITIVE-ACTION-WITHOUT-TRIGGERING-GET-RESTRICTIONS';

    /**
     * This get method was created to force the number of subscribers to 1
     */
    public get $$positiveAction(): Subject&lt;Object&gt;  {
        this.positiveActionSubscribers ++;
        if(this.positiveActionSubscribers &gt; 1){
            throw new Error('Somebody already subscribed to a positive action. You cannot subscribe to it again until the subscribes unsubscribes');            
        }

        return this.$positiveAction;    
    }

    public unSubscribePositiveAction(){
        this.positiveActionSubscribers --;
    }

    public getPositiveAction(token){
        if(token != this.internalToken){
            throw new Error('The get mothod getPositiveAction was created only for form-dialog.service');
        }

        return this.$positiveAction;
    }
}

export interface CustomAction {
    data: Object;
    customActionIdentifier: string;
}
</code></pre>

<p>Is there a way to cache the subscribe event and increse the counter
 and unsubscribe to decrese it? I want the other clases to not know
 what's happening behind and this one to be forced to have only one
 subscriber on time</p>
","3497559","","4558029","","2016-08-03 06:10:59","2016-08-04 05:52:09","Subject<any> catch the subscribe and unsubscribe methods","<rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"38749158","2","","38720547","2016-08-03 16:32:46","","2","","<ul>
<li><p><a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/mergeMap.ts"" rel=""nofollow""><code>flatMap</code>/<code>mergeMap</code></a> - Now takes a concurrency parameter</p></li>
<li><p><code>tap</code> -> <code>do</code></p></li>
<li><p><code>subscribeOnNext</code> no longer exists, so just use <code>subscribe</code> with a single parameter.</p></li>
<li><p><code>fromPromise</code> overload does not exist on RxJS 5 so use <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/DeferObservable.ts"" rel=""nofollow""><code>defer</code></a> instead.</p></li>
</ul>

<p>See the updated jsbin <a href=""http://jsbin.com/bojuxazara/edit?html,js,output"" rel=""nofollow"">here</a></p>
","2521865","","","","","2016-08-03 16:32:46","","","","1","","","","CC BY-SA 3.0"
"38784566","1","","","2016-08-05 08:24:06","","59","53993","<p>Previously in <strong>rxjs4</strong> there was a method in the BehaviorSubject called:
<code>getValue()</code> (<a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md#rxbehaviorsubjectprototypegetvalue"" rel=""noreferrer"">doc here</a>).</p>
<p>This method does not exist anymore in <strong>rxjs5</strong>.</p>
<p>So the only solution that I found to get the value of a BehaviorSubject was:</p>
<pre><code>let value;
myBehaviorSubject.take(1).subscribe( (e) =&gt; value = e );
</code></pre>
<p>This code runs synchronously (I do not exactly understand why, but it does ...) and gets the value. It works, but it's not as clean as it could be if <code>getValue()</code> was present:</p>
<pre><code>let value = myBehaviorSubject.getValue();
</code></pre>
<p>Why <code>getValue()</code> was removed in <strong>rxjs5</strong> and what's the cleanest solution to this problem?</p>
","1619369","","74089","","2021-04-29 16:03:57","2021-09-01 17:36:33","Simple way to get the current value of a BehaviorSubject with rxjs5","<javascript><reactive-programming><rxjs><rxjs5><behaviorsubject>","2","6","4","","","CC BY-SA 4.0"
"38803825","1","","","2016-08-06 11:34:49","","0","44","<p>I'm trying to do the initialization settings, but it seems that I am doing something wrong</p>

<p><strong>main.service.provider.ts</strong></p>

<pre><code>import {Injectable} from ""@angular/core"";
import {Http, Response} from '@angular/http';
import {Observable}     from 'rxjs/Observable';
import ""../lib/lib"";
@Injectable()
export class MainServiceProvider {
  private _settings: any;
  private _error: boolean;

  constructor(private http: Http) {
    this._error = false;
//try load settings here
    this._getsettings().subscribe(
      resp =&gt; {
        console.log(resp);
        this._settings = resp
      },
      error =&gt; {
        console.error(error);
        this._error = true;
      }
    );
  }


  //main request to server function
  public getData(citieslist: Array&lt;string&gt;): Observable&lt;Object&gt; {
    if ((typeof  citieslist === 'object') &amp;&amp; (citieslist.length &gt; 0)) {
      let adressarray: Array&lt;any&gt; = [];
      for (let city of citieslist) {
        let url = this._settings.url + this._settings.searchparam + city;
        adressarray.push(this.http.get(url).map((res: Response) =&gt; this._extractData(res)).catch(this._handleError))
      }
      return Observable.forkJoin(adressarray)
    }
    else
      console.error('no valid data in function parameter');
  }
  //data handler
  private _extractData(res: Response) {

    let body = res.json();
    return body || {};
  }
  //error handler function
  private _handleError(error: any) {

    let errMessage = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : 'server error';
    console.error(errMessage);
    return Observable.throw(errMessage);
  }
  //settings getter
  public _getsettings(): Observable&lt;Object&gt; {
    return this.http.get('/data/settings.json').map((res: Response) =&gt; this._extractData(res)).catch(this._handleError);
  }
}
</code></pre>

<p>In app.component i subscribing on  GetData function in ngOnInit
As result: when i start app, GetData execute first and not seen settings in main.service.provider</p>
","6590105","","","","","2016-08-06 11:34:49","How correctly load settings to my angular2 app","<typescript><angular><rxjs5>","0","5","","","","CC BY-SA 3.0"
"38812797","1","","","2016-08-07 09:34:20","","0","132","<p>Trying to create a drag n drop implementation from an Rxjs course example, but its not working correctly. Some time the box is dragged back to original position some times it just get stuck. Here is the plunkr
<a href=""https://plnkr.co/edit/9Nqx5qiLVwsOV7zU6Diw?p=preview"" rel=""nofollow"">https://plnkr.co/edit/9Nqx5qiLVwsOV7zU6Diw?p=preview</a></p>

<p>the js code:</p>

<pre><code>var $drag = $('#drag');
var $document = $(document);
var $dropAreas = $('.drop-area');

var beginDrag$ = Rx.Observable.fromEvent($drag, 'mousedown');
var endDrag$ = Rx.Observable.fromEvent($document, 'mouseup');
var mouseMove$ = Rx.Observable.fromEvent($document, 'mousemove');

var currentOverArea$ = Rx.Observable.merge(
  Rx.Observable.fromEvent($dropAreas, 'mouseover').map(e =&gt; $(e.target)),
  Rx.Observable.fromEvent($dropAreas, 'mouseout').map(e =&gt; null)
);

var drops$ = beginDrag$
  .do(e =&gt; {
    e.preventDefault();
    $drag.addClass('dragging');
  })
  .mergeMap(startEvent =&gt; {
    return mouseMove$
      .takeUntil(endDrag$)
      .do(moveEvent =&gt; moveDrag(startEvent, moveEvent))
      .last()
      .withLatestFrom(currentOverArea$, (_, $area) =&gt; $area);
  })
  .do(() =&gt; {
    $drag.removeClass('dragging')
      .animate({top: 0, left: 0}, 250);
  })
  .subscribe( $dropArea =&gt; {
    $dropAreas.removeClass('dropped');

    if($dropArea) $dropArea.addClass('dropped');
  });

  function moveDrag(startEvent, moveEvent) {
    $drag.css(
      {left: moveEvent.clientX - startEvent.offsetX,
       top: moveEvent.clientY - startEvent.offsetY}
    );
  }
</code></pre>

<p>If I remove the withLatestFrom operator, then dragging of div always work fine, but without this I cannot get the drop feature implemented.</p>
","277696","","","","","2017-01-19 17:28:00","Drag and Drop implemented using Rxjs not working","<javascript><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38835934","1","38836957","","2016-08-08 18:17:15","","4","1163","<p>This is what I am doing now, and I wonder if there is a better way</p>

<pre><code>this.dataService.subscribe(
    data =&gt; this.data = data,
    error =&gt; alert('Something went wrong'),
    () =&gt; this.doSomethingOnCompletion());
</code></pre>

<p>If I'm not catching data, however, I might just alter the first of the three functions:</p>

<pre><code>() =&gt; null,
</code></pre>

<p>The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md"" rel=""nofollow"">documentation for rxjs 4.x</a> doesn't answer this question well enough for me. <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/subscription.md"" rel=""nofollow"">Version 5.x</a> explains even less.</p>

<p>So, what is the verdict? Is the following wrong when I need to do nothing more than trigger something to happen?</p>

<pre><code>this.dataService.subscribe(
    () =&gt; null,
    error =&gt; alert('Boom.'),
    () =&gt; this.doSomethingOnCompletion());
</code></pre>

<p>If I didn't need to do something on completion, I'd just leave that part out. What if I only wanted to check for errors and nothing else? </p>
","5899766","","","","","2016-08-08 19:20:20","I need help understanding RxJx subscribe syntax","<typescript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"38836957","2","","38835934","2016-08-08 19:20:20","","5","","<p>RxJS 4 if you only need <code>errors</code> then you can use the <code>subscribeOnError</code> method which handles only the errors. </p>

<p>You can use the subscribe method as well, but you just need to pass a null value for the handlers you don't want, you don't have to pass your own noop.</p>

<pre><code>this.dataService.subscribe(
    null,
    error =&gt; alert('Something went wrong'));
</code></pre>

<p>RxJS 5 you can pass a so-called <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observer.ts"" rel=""noreferrer""><code>PartialObserver</code></a>:</p>

<pre><code>this.dataService.subscribe({
  error: error =&gt; alert('Boom.'), 
  complete: () =&gt; this.doSomethingOnCompletion()
})
</code></pre>
","2521865","","","","","2016-08-08 19:20:20","","","","2","","","","CC BY-SA 3.0"
"38853380","1","38863802","","2016-08-09 14:21:06","","6","5985","<p>I have a subscribe like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>this.test.subscribe(params =&gt; { 
  ...some code
});</code></pre>
</div>
</div>
</p>

<p>If I pass a callback function instead of arrow function, the context is missing.</p>

<p>I want to bind the context to the subscribe function but I never see that.
is it possible to do without make something like</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>that = this</code></pre>
</div>
</div>
</p>
","6467396","","","","","2016-08-10 03:35:53","How to set context to rxjs subscribe callback function?","<rxjs><rxjs5><angular2-observables>","1","2","3","","","CC BY-SA 3.0"
"38859420","1","","","2016-08-09 19:59:36","","2","645","<p>Several tutorials on RxJS 5 talk about a <code>catch</code> operator but I can't see any info in the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""nofollow"">reference documentation</a>. Why not? Is it supported?</p>
","736070","","","","","2017-01-09 10:12:05","Why doesn't the RxJS 5 reference documentation describe a catch operator?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"38863802","2","","38853380","2016-08-10 03:35:53","","14","","<p>I will attempt an answer but I'm still not quite sure what you mean.</p>

<p>When you write:</p>

<pre><code>const v = 42;
observable.subscribe(x =&gt; {
  // here you have access to `v`
});
</code></pre>

<p>But when you write:</p>

<pre><code>{
  const v = 42;
  observable.subscribe(f);
}

function f(x) {
  // here you do not have access to `v`
}
</code></pre>

<p>And that's how it should be. If you want <code>f</code> to see variables that are not in its declaration scope, then you must make them arguments and pass them appropriately. For instance:</p>

<pre><code>{
  const v = 42;
  observable.subscribe(x =&gt; f(x, v));
}

function f(x, v) {
  // here you **do** have access to `v`
}
</code></pre>

<p>Or if you can define the callback in the context of the variable you want to capture:</p>

<pre><code>{
  const v = 42;
  observable.subscribe(x =&gt; f(x));
  function f(x) {
    // here you **do** have access to `v` because it is in scope
  }
}
</code></pre>

<p>Does this answer your question? It has nothing to do with RxJS though, those are pure JavaScript (and programming languages) concepts.</p>
","553003","","","","","2016-08-10 03:35:53","","","","0","","","","CC BY-SA 3.0"
"38876124","1","38876340","","2016-08-10 14:22:51","","2","507","<p>Using Rxjs 5.0, I have an object like this</p>

<pre><code>var data = [
    {name: 'abc', title: 'zzz', data: '', id: ''},
    {name: 'abc1', title: 'zzz1', data: '', id: ''},
    {name: 'abc2', title: 'zzz2', data: '', id: ''},
    {name: 'abc3', title: 'zzz3', data: '', id: ''}
]
</code></pre>

<p>I want to simple map it, to retain just name and tile. So did something like this</p>

<pre><code>Rx.Observable.from(data)
    .map(item =&gt; return {name: item.name, title: item.title};)
    .subscribe(items =&gt; console.log('Final OBJ:' + JSON.stringify(items)));
</code></pre>

<p>On console I am getting items on multiple line i.e. subscribe is running 4 times. I want to run subscribe only once with one complete object containing data with only name and title fields.</p>

<p>Expected output on console is:</p>

<pre><code>Final OBJ: [{name: 'abc', title: zzz},{name: 'abc1', title: zzz1},{name: 'abc2', title: zzz2},{name: 'abc3', title: zzz3}]
</code></pre>
","277696","","965051","","2016-08-10 14:26:12","2016-08-10 16:06:24","combining array objects into single object","<javascript><rxjs5>","2","3","","","","CC BY-SA 3.0"
"38876340","2","","38876124","2016-08-10 14:32:07","","2","","<p>You can simply have:</p>

<pre><code>Rx.Observable.from(data)
  .reduce((arr, item, idx, source) =&gt; {
    arr.push({
      name: item.name,
      title: item.title
    });
    return arr;
  }, [])
  .subscribe(items =&gt; console.log(JSON.stringify(items)));
</code></pre>

<p><a href=""http://jsbin.com/modazibovo/edit?html,js,console"" rel=""nofollow"">JS Bin example</a></p>

<p><strong>Edit:</strong> It seems that <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/combineAll.ts"" rel=""nofollow"">combineAll</a> should do the trick.</p>

<pre><code>Rx.Observable.from(data)
  .map(item =&gt; {
    return Rx.Observable.of({
      name: item.name,
      title: item.title
    });
  })
  .combineAll()
  .subscribe(items =&gt; console.log(JSON.stringify(items)));
</code></pre>

<p><a href=""http://jsbin.com/kiyuqagifi/edit?html,js,console"" rel=""nofollow"">JS Bin Example</a></p>
","4512046","","4512046","","2016-08-10 16:06:24","2016-08-10 16:06:24","","","","0","","","","CC BY-SA 3.0"
"38877973","1","38912333","","2016-08-10 15:39:42","","0","353","<p>I have a js object like this</p>

<pre><code>var routes = [
    {lat: 12.44, lng: 74.50},
    {lat: 12.54, lng: 74.60},
    {lat: 12.64, lng: 74.70},
    ...
];
</code></pre>

<p>I want to calculate distance between 2 points from the routes array to create a new array with lat,lng and distance from previous point. Using recursive function I can do that in sequential order, so until the http request is not resolved I do not call the next points. here is the recursive code</p>

<pre><code>var finalData = [];
function getData(points, i) {
    if(points.length &gt;= i+1) {
        var p1 = points[i];
        var p2 = points[i+1];
        var url = 'http://to/web/app/origin=' + p1.lat + ',' + p1.lng + '&amp;destination=' + p2.lat + ',' + p2.lng;
        http.get(url, function(res) {
            var data = '';
            res.on('data', function(chunk) {
                data += chunk;
            });
            res.on('end', function() {
                var d = JSON.parse(data);
                finalData.push({
                    lat: p2.lat,
                    lng: p2.lng,
                    distance: d.dis
                });
                getData(points, i+1);
            });
        });
    }
}
getData(routes, 0);
</code></pre>

<p>Being new to Reactive Programming, not able to think and find out how can I achieve the same using Rxjs library? I mean some small declarative code.</p>
","1477260","","1033581","","2019-01-09 11:21:39","2019-01-09 11:21:39","How to resolve http requests in sequence using Rxjs","<node.js><reactive-programming><rxjs5>","2","0","","","","CC BY-SA 4.0"
"38879409","1","","","2016-08-10 16:57:09","","4","9314","<p>Using Rxjs v5, trying to run http.get requests in sequential order but getting error <code>TypeError: promise.then is not a function</code>
js code:</p>

<pre><code>    var http = require('http');
    Rx.Observable
        .from(data)
        .pairwise()
        .concatMap(a =&gt; {
            var url = 'http://to/some/api?origins=' + a[0].lat + ',' + a[0].lng + '&amp;destinations=' + a[1].lat + ',' + a[1].lng;
            return Rx.Observable.fromPromise(http.get(url));        
        })    
        .subscribe(item =&gt; {
            console.log(item);
        });
</code></pre>
","277696","","","","","2016-08-12 05:03:06","TypeError: promise.then is not a function","<javascript><node.js><rxjs5>","1","5","","","","CC BY-SA 3.0"
"38883203","1","","","2016-08-10 20:45:01","","3","610","<p>The <a href=""https://angular.io/docs/ts/latest/api/router/index/CanActivate-interface.html"" rel=""nofollow""><code>CanActivate</code> class</a> permits an <code>Observable&lt;boolean&gt;</code> return type. </p>

<p>The only use cases that make sense to me are: </p>

<ol>
<li><code>CanActivate</code> could 'asynchronously' block a route being displayed until <code>observer.next(true|false)</code> is called.</li>
<li>I could display a route that <code>CanActivate</code> allows then push a <code>observer.next(false)</code> from another part of my app and have that route disappear.</li>
</ol>

<p>However, point one works but not point two. Therefore I can't find a reason why <code>CanActivate</code> should allow a return type of <code>Observable&lt;boolean&gt;</code> other than convenience - which in turn complicates the API. It would be cleaner if <code>CanActivate</code> only permitted a <code>boolean</code> return type and <code>Promise</code>.</p>

<p>Please note that I am new to Angular, RxJS and everything Node based so I might be missing the obvious. I spent a while trying to extract the functionality from <code>CanActivate</code> that the <code>Observer&lt;boolean&gt;</code> return type implies.</p>
","736070","","5765795","","2017-09-22 08:02:57","2019-02-21 08:29:05","Why does Angular 2's CanActivate return an Observable<boolean> instead of a Promise?","<javascript><angular><rxjs><rxjs5>","3","3","0","","","CC BY-SA 3.0"
"38895243","1","","","2016-08-11 11:35:11","","1","704","<p>Does ""async"" pipe work with ""rxjs 5"" Subject? If not what will be the way?
I tried <code>myObservable = new Observable(fn =&gt; ngrxStore.select('myreducer').subscribe(fn));</code> 
as clarified <a href=""https://stackoverflow.com/questions/35094705/how-to-transform-a-subject-into-an-observable-in-rxjs-5"">here</a>
and used <code>myObservable | async</code> in template, but it didn't work.</p>

<p>To add a little more clarity, Atom IDE doesn't allow asObservable() as it finds <code>ngrxStore.select('myreducer')</code> to return an <code>Observable</code>, which doesn't seem to be the case (and I am not expecting also) when I print the object in the console which say's it is a <code>Subject</code></p>
","2371715","","-1","","2017-05-23 11:46:44","2016-08-11 11:47:37","async pipe with rxjs 5 Subject","<angular><rxjs5>","0","3","","","","CC BY-SA 3.0"
"38912333","2","","38877973","2016-08-12 07:30:21","","1","","<p>Extending the answer by @paulpdaniels I was able to fix my code. Putting it here if someone interested.</p>

<pre><code>Rx.Observable.from(data)
    .pairwise()
    .concatMap(points =&gt; {
        const p1 = points[0];
        const p2 = points[1];
        var url = `http://to/web/app?origins=${p1.lat},${p1.lng}` + 
                         `&amp;destinations=${p2.lat},${p2.lng}`;
        return GetDataStream(url);
    },
    //Process the response along with the original array of responses 
    (points, dis) =&gt; {          
        return {lat: points[1].lat, lng: points[1].lng, distance: dis};
    })
    .toArray()
    .subscribe(x =&gt; console.log(x));
</code></pre>

<p>and her is the custom observable</p>

<pre><code>const GetDataStream = function(url) {
    return Rx.Observable.create(observer =&gt; {
        http.get(url, res =&gt; {
            var _data = ''
            res.on('data', chunk =&gt; {
                _data += chunk;
            });
            res.on('end', () =&gt; {
                var d = JSON.parse(_data);
                var distance = d.rows[0].elements[0].distance.value;
                observer.next(distance);
                observer.complete();
            });
        });
    });
}
</code></pre>
","1477260","","","","","2016-08-12 07:30:21","","","","0","","","","CC BY-SA 3.0"
"38915650","1","38915884","","2016-08-12 10:23:40","","1","50","<p>Consider the data object like this</p>

<pre><code>var data = [
    {name: 'abc', dis: 0},
    {name: 'bcd', dis: 30},
    {name: 'cde', dis: 70},
    {name: 'def', dis: 22},
    {name: 'efg', dis: 40},
    {name: 'fgh', dis: 29},
    {name: 'ghi', dis: 41},
    {name: 'hij', dis: 33}
];
</code></pre>

<p>I want to filter out object only when the accumulated distance is greater than or equal to 100. So required output would be</p>

<pre><code>var finalData = [
    {name: 'abc', dis: 0},  //start point
    {name: 'cde', dis: 100}, // 0 + 30 + 70
    {name: 'ghi', dis: 132}, //22 + 40 + 29 + 41
    {name: 'hij', dis: 33}  // 33 as points ended
];
</code></pre>

<p>Offcourse I can easily do it via for-loop and push like this</p>

<pre><code>var finalData = [];
var sum = 0;
for(var i=0;i&lt;data.length;i++) {
    sum += data[i].dis;
    if(i == 0 || sum &gt;= 100) {
        finalData.push({name: data[i].name, dis: sum});
        sum = 0;
    }

}
</code></pre>

<p>but want do learn it in Rxjs style.</p>
","1477260","","2521865","","2016-08-12 19:34:34","2016-08-12 19:34:34","Filtering elements based on accumulated sum of a field","<javascript><functional-programming><rxjs5>","1","2","","","","CC BY-SA 3.0"
"38915884","2","","38915650","2016-08-12 10:34:52","","1","","<p>I'm not sure whether specific RxJS functionalities could be of any help in that case. Did you mean Functional Programming?</p>

<p>You can use the <code>.reduce()</code> method with an accumulator and additional tests for the first and last elements.</p>

<p>As far as I can tell, your original code was only missing the test on the last element.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var data = [
  {name: 'abc', dis: 0},
  {name: 'bcd', dis: 30},
  {name: 'cde', dis: 70},
  {name: 'def', dis: 22},
  {name: 'efg', dis: 40},
  {name: 'fgh', dis: 29},
  {name: 'ghi', dis: 41},
  {name: 'hij', dis: 33}
];

var sum = 0;

var finalData = data.reduce(function(prv, cur, i) {
  if((sum += cur.dis) &gt;= 100 || !i || i == data.length - 1) {
    cur.dis = sum;
    sum = 0;
    prv.push(cur);
  }
  return prv;
}, []);

console.log(finalData);</code></pre>
</div>
</div>
</p>

<p>If you want to avoid using a variable defined outside the scope of the <code>.reduce()</code> method, you can either use the optional <code>thisArg</code> parameter or an object instead of a simple array as the initial value.</p>

<p>I tend to prefer the second option which allows to explicitly initialize the accumulator from the beginning:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var data = [
  {name: 'abc', dis: 0},
  {name: 'bcd', dis: 30},
  {name: 'cde', dis: 70},
  {name: 'def', dis: 22},
  {name: 'efg', dis: 40},
  {name: 'fgh', dis: 29},
  {name: 'ghi', dis: 41},
  {name: 'hij', dis: 33}
];

var finalData = data.reduce(function(prv, cur, i) {
  if((prv.sum += cur.dis) &gt;= 100 || !i || i == data.length - 1) {
    cur.dis = prv.sum;
    prv.sum = 0;
    prv.res.push(cur);
  }
  return prv;
}, {sum: 0, res: []}).res;

console.log(finalData);</code></pre>
</div>
</div>
</p>
","2004841","","2004841","","2016-08-12 11:21:01","2016-08-12 11:21:01","","","","1","","","","CC BY-SA 3.0"
"38926445","1","38939516","","2016-08-12 21:04:45","","0","337","<p>For example, I have an observable that emits a 10-second timer every 5 seconds. I can use scan to create an observable that emits an array of all the inner observables emitted so far:</p>

<pre><code>tick = 5000
tock = 1000
timers = Observable.interval(tick).scan( (acc, next) =&gt; {
    let timer = Observable.interval(tock).take(10);
    return acc.concat([timer]);
}, []);
</code></pre>

<p>But what if I want to emit it to emit an array of all ""live"" timers (i.e. those that haven't called <code>complete</code> yet)?</p>

<p>Here's a crappy ascii marble diagram of what I'm thinking of:</p>

<pre><code>-A--B-----
  \  \
   \  \
    \  x
     x
 |  |    |
[A][A,B] []
</code></pre>

<p>Is there a way to do this using the standard operators, or is this just not an idiomatic thing to try to do with rxjs?</p>
","262271","","","","","2016-08-14 05:43:32","Collecting the currently incomplete observables in a higher-order rxjs observable","<javascript><rxjs><rxjs5><reactivex>","1","0","","","","CC BY-SA 3.0"
"38939516","2","","38926445","2016-08-14 05:43:32","","1","","<p>You should be able to use the ""active"" method described in this answer to achieve what you want:</p>

<p><a href=""https://stackoverflow.com/questions/35817174/rx-a-zip-like-operator-that-continues-after-one-of-the-streams-ended/35906684#35906684"">Rx: a zip-like operator that continues after one of the streams ended?</a></p>
","1855065","","-1","","2017-05-23 12:33:02","2016-08-14 05:43:32","","","","0","","","","CC BY-SA 3.0"
"38940123","1","46354052","","2016-08-14 07:34:21","","0","1104","<p><strong>Context:</strong> I've got many <code>ConnectableObservable</code>s, almost all of which have a replay count of 1 or more. There are many observers of the observables subscribing and unsubscribing at any given time.</p>

<p><strong>What I want:</strong> In many cases, when an observer subscribes to one of these observables, I don't care about the possible pre-existing emitted data that I'd receive because of the observable's data replay mechanism. The only data that the recently-subscribed observer is interested in, is data that is emitted after the moment of subscription.</p>

<pre><code>const observable = Rx.Observable
    .interval(100)
    .take(4)
    .publishReplay(3);

observable.connect();
</code></pre>

<p><strong>Problem:</strong> As far as I can tell, when an observer subscribes to the observable, it has no way of knowing whether or not the data it observes was emitted before or after the moment of subscription.</p>

<pre><code>observable.subscribe(x =&gt; console.log('observed', x));

setTimeout(() =&gt; 
    observable.subscribe(y =&gt; console.log('delayed observed', y)), 
    400
);
</code></pre>

<p>The code above will output:</p>

<pre><code>// =&gt; observed 0
// =&gt; observed 1
// =&gt; observed 2
// =&gt; delayed observed 0 **don't care**
// =&gt; delayed observed 1 **don't care**
// =&gt; delayed observed 2 **don't care**
// =&gt; observed 3
// =&gt; delayed observed 3
</code></pre>

<p>In this hypothetical situation, the delayed observer is only interested in data emitted after the moment of subscription; in this case, <code>3</code>.</p>

<p>I've scoured the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""nofollow"">RxJS 5 reference docs</a> and can't seem to find a silver-bullet operator to accomplish what I'm after. Any ideas?</p>
","901706","","","","","2017-09-21 22:25:35","RxJS: How do I subscribe to Observable data that is emitted only after the moment of subscription?","<reactive-programming><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"38940430","1","38940496","","2016-08-14 08:20:47","","7","1835","<p>I have been using this pattern:</p>

<pre><code>func myObservable() Observable&lt;boolean&gt; {
    ...
}

func myFunc() {
    myObservable().subscribe((cond: boolean) =&gt; {
        if (cond) {
            // How do I unsubscribe here?
        }
    });
}
</code></pre>

<p>However I can't see any way to unsubscribe thereby maybe creating a memory leak.</p>

<p>The reason I ask is because <a href=""https://angular.io/docs/ts/latest/api/http/index/Http-class.html"">Angular 2's HTTP client</a> uses the same pattern - although I believe it auto-unsubscribes somehow and I would like to do the same.</p>
","736070","","","","","2016-08-14 08:32:22","How to unsubscribe from an RxJS 5 observable?","<javascript><angularjs><angular><typescript><rxjs5>","1","1","","","","CC BY-SA 3.0"
"38940496","2","","38940430","2016-08-14 08:32:22","","12","","<p>You should do something like this:</p>

<pre><code>func myFunc() {
   var subscription = myObservable().subscribe((cond: boolean) =&gt; {
       if (cond) {
          // How do I unsubscribe here?
           subscription.unsubscribe()
       }
   });
}
</code></pre>
","4054332","","","","","2016-08-14 08:32:22","","","","2","","","","CC BY-SA 3.0"
"38948284","1","38949310","","2016-08-15 01:48:26","","3","51","<p>I'm coding in <code>Typescript 1.9</code> and using <code>RxJS 5</code>. I'm trying to build an observable that will emit just one value: <code>true</code> if any of the inner <code>Observable&lt;number&gt;</code>'s emissions belong to a fixed array of numbers. <code>false</code> otherwise.  This is my code:</p>
<pre><code>let lookFor = [2,7]; // Values to look for are known
Observable.from([1,2,3,4,5]) //inner observable emits these dynamic values
    .first( //find first value to meet the requirement below
        (d:number) =&gt; lookFor.find(id=&gt;id===d)!==undefined,
        ()=&gt;true //projection function. What to emit when a match is found
    )
    .subscribe(
        res =&gt; console.log('Result: ',res),
        err =&gt; console.error(err),
        ()  =&gt; console.log('Complete')
    );
</code></pre>
<p>The code above works great. It will ouput:</p>
<blockquote>
<p>Result: true (because inner observable emits 2, which is found in <code>lookFor</code></p>
<p>Complete</p>
</blockquote>
<p>If I start with <code>Observable.from([8,9])</code> I would like to get <code>Result: false</code> since there is no overlap with <code>lookFor</code>, but instead the error handler is triggered:</p>
<blockquote>
<p>Object {name:&quot;Empty Error&quot;, stack:&quot;&quot;}</p>
</blockquote>
<p>What's the right approach to get my observable to emit <code>true</code> as soon as a match is found, but to emit <code>false</code> if there is still no match at the end of the stream?</p>
","3977061","","-1","","2020-06-20 09:12:55","2016-08-15 04:26:02","RxJS 5 Observable: does any result belong to a known set","<typescript><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38949310","2","","38948284","2016-08-15 04:26:02","","1","","<p>There is an additional parameter that lets you specify the default value to use if no match is found:</p>

<pre><code>...
.first( //find first value to meet the requirement below
    (d:number) =&gt; lookFor.find(id=&gt;id===d)!==undefined,
    ()=&gt;true, //projection function. What to emit when a match is found
    false //default value to emit if no match is found
)
...
</code></pre>
","6680611","","","","","2016-08-15 04:26:02","","","","0","","","","CC BY-SA 3.0"
"38951176","1","","","2016-08-15 07:44:53","","0","366","<p>I want to filter data based on a selection value of select box.</p>

<pre class=""lang-html prettyprint-override""><code>&lt;select id=""testDD""&gt;
    &lt;option value=""local""&gt;Local&lt;/option&gt;
    &lt;option value=""international""&gt;Internationl&lt;/option&gt;
&lt;/select&gt;
&lt;div id=""list""&gt;&lt;!-- List Items to be generated from #testDD value --&gt;&lt;/div&gt;
</code></pre>

<p>I have data object like this</p>

<pre class=""lang-js prettyprint-override""><code>var data = [
    {type: 'local', name: 'abc1', location: 'xyz1'},
    {type: 'local', name: 'abc2', location: 'xyz2'},
    {type: 'international', name: 'abc3', location: 'xyz3'},
    {type: 'local', name: 'abc4', location: 'xyz4'},
    {type: 'local', name: 'abc5', location: 'xyz5'},
    {type: 'international', name: 'abc6', location: 'xyz6'},
    {type: 'international', name: 'abc7', location: 'xyz7'}
]
</code></pre>

<p>Whats the ideal way to filter out data based on selection event changed?</p>
","277696","","106909","","2017-01-20 20:22:50","2019-09-20 21:46:18","Filter data from value of dropdown","<rxjs5>","2","1","0","","","CC BY-SA 3.0"
"38951651","1","","","2016-08-15 08:21:17","","0","151","<p>I am using rxjs based on typescript files as you can see as follow:<br>
<a href=""https://i.stack.imgur.com/6aO4r.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6aO4r.png"" alt=""enter image description here""></a></p>

<p>and included in my app.ts file:</p>

<pre><code>import * as Rx from ""rx/Rx"";

var main = () =&gt; {
  $("".ui.dropdown"").dropdown();
  $("".left-half"").backstretch([""../images/lotus.jpg""]);


  var source = Rx.Observable.range(0, 3);

  var subscription = source.subscribe(
    x =&gt; {
      console.log('Next: ' + x);
    },
    err =&gt; {
      console.log('Error: ' + err);
    },
    () =&gt; {
      console.log('Completed');
    });

};

$(document)
  .ready(() =&gt; {
    main();
  });
</code></pre>

<p>but what confuse me is, visual studio does not recognize the range method as marked as red(as you can see on pic):
<a href=""https://i.stack.imgur.com/GuSfY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GuSfY.png"" alt=""enter image description here""></a></p>

<p>But it works like expected:
<a href=""https://i.stack.imgur.com/kVMTd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kVMTd.png"" alt=""enter image description here""></a></p>

<p>What is wrong with visual studio 2015?</p>

<p>I am using typescript version:</p>

<p><a href=""https://i.stack.imgur.com/Xl7FG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Xl7FG.png"" alt=""enter image description here""></a></p>
","1743843","","1743843","","2016-08-15 08:40:30","2016-08-15 08:40:30","Why intellisense does not show the range method","<typescript><visual-studio-2015><rxjs5>","0","3","","","","CC BY-SA 3.0"
"38952794","1","39009288","","2016-08-15 09:45:43","","5","1634","<p>Based on selecting different items in a dropdown, I am generating html of items with check boxes. How can I preserve the state of checkbox i.e. check/uncheck whenever value in dropdown is changing. See the plunkr here <a href=""https://plnkr.co/edit/PUG3g7dfTbQjPyIgGLzh?p=preview"" rel=""noreferrer"">https://plnkr.co/edit/PUG3g7dfTbQjPyIgGLzh?p=preview</a></p>

<p>Steps:</p>

<pre><code>- uncheck 'abc2'
- change dd value to 'international'
- again change the dd value to 'local'
- here 'abc2' must be unchecked...
</code></pre>

<p>here is my code:</p>

<pre><code>var data = [
    {type: 'local', name: 'abc1', location: 'xyz1', checked: true},
    {type: 'local', name: 'abc2', location: 'xyz2', checked: true},
    {type: 'international', name: 'abc3', location: 'xyz3', checked: true},
    {type: 'local', name: 'abc4', location: 'xyz4', checked: true},
    {type: 'local', name: 'abc5', location: 'xyz5', checked: true},
    {type: 'international', name: 'abc6', location: 'xyz6', checked: true},
    {type: 'international', name: 'abc7', location: 'xyz7', checked: true}
];

var $container = $('#container');
var $splitDD = $('#testDD');
var splitDD$ = Rx.Observable.fromEvent($splitDD, 'change')
    .startWith($splitDD.val())
    .map(function(e) { $container.html(''); return e.target ? e.target.value : e;})
    .switchMap(function(v) {return data;})
    .filter(function(v) {
      return v.type == $splitDD.val()
    })
    .map(getHtml)
    .subscribe(function(html) {
            $container.append(html);
    });


function getHtml(v) {
    var checked = v.checked ? 'checked=""checked""' : '';
    var html = '&lt;label&gt;&lt;input class=""point"" name=""' + v.name + '"" type=""checkbox"" ' + checked + '&gt;' +
        '&lt;span&gt;' + v.name + ' &lt;/span&gt;' +
        '&lt;/label&gt;';
    return html;
}
</code></pre>
","277696","","","","","2016-08-18 11:30:06","Preserving state of checkboxes generated by Rxjs","<rxjs5>","2","0","","","","CC BY-SA 3.0"
"38954008","1","38954610","","2016-08-15 11:12:44","","2","1152","<p>I am writing an angular 2 validator function. I would like to return a <strong>plain object</strong> instead of an <strong>observable</strong>.</p>

<p>Here is my current implementation:</p>

<pre><code>import {AbstractControl} from ""@angular/common"";
import {UserAccountService} from ""../../useraccount/useraccount.service"";

export function validateEmailAvailable(userAccountService: UserAccountService) {
  return (control: AbstractControl)=&gt; { //This returned lambda should itself return a plain object
    return userAccountService.checkAvailability(control.value)
      .map(res=&gt; {
        if (res.json() === true) {
          return null;
        }
        else {
          return {unavailable: true};
        }
      });
  };
}
</code></pre>

<p>Can someone please explain how to properly use the RxJs operators in order to return either <code>null</code> or <code>{unavailable: true}</code> from the above but not an observable?</p>
","536299","","3743222","","2016-11-18 05:09:43","2017-02-19 06:43:00","RxJS clarification needed: how to return a plain object instead of an Observable","<javascript><angular><rxjs><observable><rxjs5>","3","0","","","","CC BY-SA 3.0"
"38954610","2","","38954008","2016-08-15 11:54:30","","3","","<p>I would bet that this is not possible. This is the same as asking to ask an async function to return its value synchronously. Or returning a value in the present computed from values in the future. It is inherently contradictory. Promise 'operators' will always also return a promise, if you think about it. </p>
","3743222","","","","","2016-08-15 11:54:30","","","","0","","","","CC BY-SA 3.0"
"38954855","1","","","2016-08-15 12:12:51","","0","252","<p>I using rxjs as follow in typescript:</p>

<pre><code>import {Observable} from ""./rx/Rx""

var main = () =&gt; {

  $("".ui.dropdown"").dropdown();
  $("".left-half"").backstretch([""../images/lotus.jpg""]);

  var source = Observable.range(0, 3);


  var subscription = source.subscribe(
    x =&gt; {
      console.log(""Next: ${x}"");
    },
    err =&gt; {
      console.log(""Error: ${err}"");
    },
    () =&gt; {
      console.log(""Completed"");
    });

};

$(document)
  .ready(() =&gt; {
    main();
  });
</code></pre>

<p>and the files structure</p>

<p><a href=""https://i.stack.imgur.com/h04pM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/h04pM.png"" alt=""enter image description here""></a></p>

<p>the problem is, typescript compile it to multi files instead only one file.
<a href=""https://i.stack.imgur.com/Aa24I.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Aa24I.png"" alt=""enter image description here""></a></p>

<p>Everythings works fine, but all scripts from rxjs will be load as show:<br>
<a href=""https://i.stack.imgur.com/Tk90a.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Tk90a.png"" alt=""enter image description here""></a></p>

<p>To load the page, it takes <strong>25.42s</strong> and that is horrible. I am using only <code>Observable</code> object and all libraries will be loaded.  </p>

<p>How can I prevent long loading?</p>

<p><strong>Update</strong>
For backend I am using ASP.NET Core and the tsconfig file looks as follow:</p>

<pre><code>{
  ""compilerOptions"": {
    ""module"": ""amd"",
    ""noImplicitAny"": false,
    ""noEmitOnError"": true,
    ""removeComments"": false,
    ""sourceMap"": true,
    ""target"": ""es6"",
    ""outDir"": ""../wwwroot/js""
  },
  ""exclude"": [
    ""node_modules"",
    ""wwwroot""
  ]
}
</code></pre>

<p>And require.js is used(layout template):</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=""utf-8"" /&gt;
  &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" /&gt;
  &lt;title&gt;@ViewData[""Title""] - IndustryCloud&lt;/title&gt;

  &lt;environment names=""Development""&gt;
    &lt;link href=""~/lib/sui/semantic.css"" rel=""stylesheet"" /&gt;
    &lt;link rel=""stylesheet"" href=""~/css/site.css"" /&gt;
  &lt;/environment&gt;

  &lt;environment names=""Staging,Production""&gt;
    &lt;link href=""~/lib/sui/semantic.min.css"" rel=""stylesheet"" /&gt;
    &lt;link rel=""stylesheet"" href=""~/css/site.css"" /&gt;
  &lt;/environment&gt;

&lt;/head&gt;
&lt;body&gt;

  @RenderBody()

  &lt;environment names=""Development""&gt;
    &lt;script src=""~/lib/jquery/jquery.js""&gt;&lt;/script&gt;
    &lt;script src=""~/lib/jquery-backstretch/jquery.backstretch.js""&gt;&lt;/script&gt;
    &lt;script src=""~/lib/sui/semantic.js""&gt;&lt;/script&gt;
    &lt;script src=""~/lib/require/require.js"" data-main=""../js/signin.js""&gt;&lt;/script&gt;
  &lt;/environment&gt;

  &lt;environment names=""Staging,Production""&gt;

  &lt;/environment&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
","1743843","","1743843","","2016-08-15 12:54:36","2016-08-15 23:39:24","Avoid to load all javascripts files","<javascript><typescript><asp.net-core><rxjs5>","1","4","1","","","CC BY-SA 3.0"
"38955112","1","","","2016-08-15 12:28:59","","1","952","<p>I use a function call inside an angular2 template. The function itself performs a http network request using http.get(), and returns an Observable  of any[] that is actually a css style object:</p>

<pre><code>@Component({
    selector: ""test-component"",
    template: `&lt;div *ngFor=""let item of items"" [ngStyle]=""lookupStyle(item)""; }} &lt;/div&gt;"",
})
@Injectable()
export class TestComponent {

    @Input()
    items: Array&lt;any&gt;; 

    lookupStyle(params: any): Observable&lt;any&gt; {
        return this.http.get(/* ... */).map(/* ... */);
    }

    constructor(private http: Http) {}
}
</code></pre>

<p>But the above code <strong>will trigger an infinite loop</strong>! The function <code>lookupStyle</code> is evaluated every time angular2 change detection takes place. Since <code>http.get()</code> will trigger a change-detection run, the function <code>lookupStyle</code> is re-evaluated after the http request complete - there is your infinite loop.</p>

<p>Is there a solution or a better way in which i could tell angular to evaluate the function <code>lookupStyle</code> only once? Now, I know I could probable come up with some <code>.zip/.combineLatest</code> magic on my viewmodel, but this seems overkill and would prodouce a lot of additional code - thats why I am looking for a better way.</p>
","777928","","","","","2016-08-15 17:47:12","How to call a function from a template exactly once?","<ajax><angular><typescript><rxjs5><angular2-changedetection>","1","7","","","","CC BY-SA 3.0"
"38961842","1","38962686","","2016-08-15 19:37:51","","0","933","<p>I have an Angular 2 service that executes a few steps to authenticate and log in an app user. Any time I try to call next() on my Observer I get an error that it is undefined. The only place I can successfully call next() on it is inside contructor when the Observable is instantiated. </p>

<p>If I call authenticateUser() I get an error that this.isLoggedIn is undefined.</p>

<p><strong>AuthService.ts</strong></p>

<pre><code>public isLoggedIn$: Observable&lt;boolean&gt;;
private isLoggedIn: Observer&lt;boolean&gt;;

constructor(...) {

    this.isLoggedIn$ = new Observable&lt;boolean&gt;(
        (observer: Observer&lt;boolean&gt;) =&gt; {
            this.isLoggedIn = observer;

            // this works fine
            this.doLogin();

        }).share()

}

private doLogin = ():void =&gt; {

    let context:AuthContextModel = this.authContextService.getAuthContext();

    if (context) {

        let isAuthenticated = this.isAuthenticated(context);

        if (isAuthenticated) {

            this.doCreateCurrentUserContext(context)
                .then((result) =&gt; {return this.doNotifyLoggedInStatus(result);});
        }
    }
};


private doNotifyLoggedInStatus = (result:boolean):Promise&lt;boolean&gt; =&gt; {

    this.isLoggedIn.next(result);

    return new Promise((resolve, reject) =&gt; {
        return resolve(true);
    });
};


public authenticateUser = (user: string, pass: string):Promise&lt;boolean&gt; =&gt; {
    return this.doFetchToken(user, pass)
        .then((fetchTokenData) =&gt; {return this.doStoreToken(fetchTokenData);})
        .then((authContext) =&gt; {return this.doCreateCurrentUserContext(authContext);})
        .then((result) =&gt; {return this.doNotifyLoggedInStatus(result);});

};
</code></pre>
","202820","","","","","2016-08-15 20:58:28","RxJS Observable & Observer issues","<angular><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"38962686","2","","38961842","2016-08-15 20:39:34","","3","","<p>If you want to call <code>.next()</code> on an Observer outside of the instantiation of the Observable, you should use a Subject rather than separate Observables and Observers. Subjects act as both. You can subscribe to them separately from where you pass events to it. </p>

<p>There are different kinds of Subjects, but for your situation, I would recommended a BehaviorSubject. Whenever you subscribe to it, not only will it catch future events, it will return the <em>last</em> event fired before the subscription happened. This is useful for an authentication component because you won't have to write separate code for a successful log in and actually checking if a user is authenticated after it has already happened (or a later sign out). It's really simple too. </p>

<pre><code>import { BehaviorSubject } from 'rxjs/Rx'; 

//...
  public isLoggedIn: BehaviorSubject&lt;boolean&gt; = BehaviorSubject.create();

  constructor(...) { }

  private doLogin():void {

    //... Do the log in
    this.isLoggedIn.next(true);

  };
</code></pre>

<p>All you need to do wherever you want to check for log in status is grab the BehaviorSubject and subscribe to it. It doesn't matter whether or not the subscription happens before or after doLogin() was called. </p>

<p>If you intend to preserve the login state on refresh, all you'd need to do in the constructor is check for authentication and call the <code>.next(true)</code> on the BehaviorSubject as usual. </p>

<p>See also: </p>

<p><a href=""http://reactivex.io/documentation/subject.html"" rel=""nofollow"">ReactiveX Subject docs</a></p>

<p><a href=""http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#BehaviorSubject"" rel=""nofollow"">Intro to Rx BehaviorSubjects</a></p>
","5386466","","5386466","","2016-08-15 20:58:28","2016-08-15 20:58:28","","","","11","","","","CC BY-SA 3.0"
"38968947","1","38969539","","2016-08-16 07:29:08","","0","592","<p>I need to transform and aggregate the elements in an observable array. the sequence is open and will likely never complete (network based).</p>

<p>I am currently using the following code:</p>

<pre><code>const numbers = [1,2,3];
const numbers$ = new Rx.Subject();

const output = numbers$
  .flatMap(n =&gt; n)
  .map(n =&gt; n*n)
  .scan((acc, x) =&gt; acc.concat([x]), [])
  .subscribe(n =&gt; { console.log(n); });

numbers$.next(numbers);

setTimeout(() =&gt; {
  numbers$.next([5,6,7])
}, 1000);
</code></pre>

<p>Currently, multiple arrays are emitted and the last emitted value currently is <code>[1, 4, 9, 25, 36, 49]</code>. However, I only want those values to be squared that are <strong>within the same input array</strong>. </p>

<p>I.e. I need the output observable to emit exactly two arrays: <code>[1,4,9]</code> and <code>[25, 36, 49]</code>.</p>

<p>How to do this?</p>
","777928","","","","","2016-08-17 01:34:59","How to have .scan() only aggregate the most recent emitted array in an uncompleted sequence","<javascript><arrays><reactive-programming><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"38969539","2","","38968947","2016-08-16 08:01:49","","1","","<p>This should be what you are looking for:</p>

<pre><code>const output = numbers$
    .map((a) =&gt; a.map(n =&gt; n * n))
    .subscribe(n =&gt; { console.log(n); });
</code></pre>

<p><strong>Edit:</strong> If you don't want to use <code>Array.map</code>, you can use RxJS, instead.</p>

<p>You could replace <code>Array.map</code> with an observable that squares the values and reduces them back to an array. This could be extended to include <code>distinct</code> or other RxJS operators (as per your comment):</p>

<pre><code>const output = numbers$
    .mergeMap(
        (a) =&gt; Rx.Observable.from(a)
            .map((n) =&gt; n * n)
            .reduce((acc, n) =&gt; { acc.push(n); return acc; }, [])
    )
    .subscribe(n =&gt; { console.log(n); });
</code></pre>

<p>The solution that you solution posted:</p>

<pre><code>const output = numbers$
    .flatMap(n =&gt; n)
    .map(n =&gt; n*n)
    .buffer(numbers$.delay(1))
    .subscribe(n =&gt; { console.log(n); });
</code></pre>

<p>is timing-based and the only reason the arrays are not being merged is because the interval between the first <code>next</code> call and the second exceeds one millisecond.</p>
","6680611","","6680611","","2016-08-17 01:34:59","2016-08-17 01:34:59","","","","2","","","","CC BY-SA 3.0"
"38974357","1","","","2016-08-16 11:58:50","","3","6390","<p>I am writing some application to read the selected files by the user and convert them to base64. I want to get notification when all the files are read in memory. For this purpose I am using <code>Observable</code> where handle the <code>onload</code> event of <code>FileReader</code> and send a complete notification. I am using <code>forkJoin</code> to run the operation in parallel.</p>

<p>Please see below the code where I am creating <code>Observable</code> and subscribing to it. </p>

<pre><code>onChange($event: any) {
  console.log('No of files selected: ' + $event.target.files.length);
  var observableBatch : any = [];

  var rawFiles = $event.target.files;
  for (var i = rawFiles.length - 1; i &gt;= 0; i--) {

      var reader = new FileReader(); 
      var file = rawFiles[i];
      var myobservable = Observable.create((observer: any) =&gt; {
        reader.onload = function (e: any) {
          var data = e.target;
          var imageSrc = data.result;
          console.log('File loaded succesfully.' );
          observer.next(""File loaded"");
          observer.complete();
        };
       });

      observableBatch.push(myobservable);
      reader.readAsArrayBuffer(file);

  }

  Observable.forkJoin(observableBatch)
  .subscribe(
      (m) =&gt; {
        console.log(m);
      },
      (e) =&gt; {
        console.log(e);
      },
      () =&gt; {
        console.log(""All file(s) loading completed!!!"");
      }
    ); 
}
</code></pre>

<p>Complete sample code is available in <a href=""http://plnkr.co/edit/bSNj5Fhy441mpuN7rioS"" rel=""nofollow noreferrer"">plunkr</a></p>

<p>When I select a single file, <code>onload</code> function is executed and I get the following console logs </p>

<p><a href=""https://i.stack.imgur.com/iL55K.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iL55K.png"" alt=""enter image description here""></a></p>

<p>However, when I select multiple files, <code>onload</code> gets executed only once and the batch operation is not completed. Please see the following console logs</p>

<p><a href=""https://i.stack.imgur.com/ly9Wf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ly9Wf.png"" alt=""enter image description here""></a></p>

<p>Can somebody help me to understand where I am making the mistake?</p>
","5780013","","107625","","2017-11-09 10:24:51","2017-11-09 13:24:29","Reading files in parallel with observables","<angular><typescript><rxjs5>","3","0","","","","CC BY-SA 3.0"
"38989389","1","38989775","","2016-08-17 06:21:09","","1","523","<p>In Angular2, I have a lot of <code>Observable&lt;any[]&gt;</code> (Observable that emits arrays) that offspring in <code>http.get()</code> or are feed via websocket operations and hence <strong>do not .complete()</strong> but emit multiple values over time.</p>

<p>Very often I need to transform the elements within the array with RxJS operators (I don't want to use Array.prototype.* transforms!) and assemble the individual elements back to an array, that is emitted as single entity.</p>

<p>But I don't know how to assemble the elements back to an array.</p>

<p>Example:</p>

<pre><code>const n$ = new Subject();

const output = n$
    // create an observable emitting the individual elements
    // of the array
    .mergeMap(n =&gt; n)

    // some kind of transform on the elements
    .distinct((n1, n2) =&gt; n1 == n2)
    .map(n =&gt; n*n)

    // how to assemble back to an array here???
    // not working:
    // .buffer(n$)
    // also not working (subject does not complete!)
    // .toArray()

output.subscribe(v =&gt; console.log(v))

n$.next([1,1,1,2,3]);
n$.next([4,5,5,6]);

// Wanted output:
// [1, 4, 9]
// [16, 25, 36]
</code></pre>
","777928","","","","","2016-08-17 06:54:52","Serialize Array into elements, transform using RxJS, and assemble elements back to array","<javascript><arrays><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"38989775","2","","38989389","2016-08-17 06:43:04","","2","","<p>If you have multiple values and want a single value (the array), <s><code>reduce</code></s><code>toArray</code> should be what you're after:</p>

<pre><code>Rx.Observable.from([0, 1, 1, 2, 3])
    .distinct()
    .map((n) =&gt; n * n)
    // .reduce((acc, n) =&gt; { acc.push(n); return acc; }, [])
    .toArray()
    .subscribe((a) =&gt; { console.log(a); })
</code></pre>

<p>If you have an <code>Observable&lt;any[]&gt;</code>, just put it into in a <code>mergeMap</code>:</p>

<pre><code>const output = n$
    .mergeMap((a) =&gt; Rx.Observable.from(a)
        .distinct()
        .map((n) =&gt; n * n)
        // .reduce((acc, n) =&gt; { acc.push(n); return acc; }, [])
        .toArray()
    )
    .subscribe(a =&gt; { console.log(a); });
</code></pre>
","6680611","","6680611","","2016-08-17 06:54:52","2016-08-17 06:54:52","","","","3","","","","CC BY-SA 3.0"
"39009288","2","","38952794","2016-08-18 02:56:28","","0","","<p>Here's what seemed to work for me:</p>

<pre><code>var splitDD$ = Rx.Observable.fromEvent($splitDD, 'change')
    .startWith($splitDD.val())
    .map(function(e) { return e.target ? e.target.value : e;})
    // See below what this is about
    .switchMap(function(v) { return getData$(data); })
    // In functional world, you only cause effects to the world in subscribe
    // It's not 100% true because we change data above, but it's close
    .subscribe(function(items) {
        var html = items.map(getHtml);
        $container.html(html);

    });

function getData$(itemsArray) {
    // We can use Rx.Observable.of() and get the entire array, and do some
    //  and do some optimxations based on that (for example, toArray won't be needed)
    //  but I'm avoidng changing the symantics of the question 
    //  just in case if they have a reaosn in the real case
      return Rx.Observable.from(itemsArray)
        // Update checkboxes before filtering because
        //  the checkbox you are about to update is one you are about to hide
        .map(function(v) {
          var existing = $container.find(""[name='"" + v.name + ""']"");
          if(existing.length) {
            v.checked = !!existing.prop(""checked"");
          }
          return v;
        })
        .filter(function(v) {return v.type == $splitDD.val();})
        // `toArray` needs an observable that completes
        // That's why we separate this from the event, which might emit forever
        //    as the event might fire any time.
        .toArray();  
}

function getHtml(v) {
    var checked = v.checked ? 'checked=""checked""' : '';
    var html = '&lt;label&gt;&lt;input class=""point"" name=""' + v.name + '"" type=""checkbox"" ' + checked + '&gt;' +
        '&lt;span&gt;' + v.name + ' &lt;/span&gt;' +
        '&lt;/label&gt;';
    return html;
}
</code></pre>

<p><a href=""https://plnkr.co/edit/So2dHZscGSBndMFBtezN?p=preview"" rel=""nofollow"">Plunker</a></p>

<p>Another obvious change, and much easier, is to set another event handler, like:</p>

<pre><code>var containerCHK$ = Rx.Observable.fromEvent($container, 'change')
  .subscribe(function(e) {
      var input = e.target;
      var dataPart = data.filter(function(v) {
        return v.name == input.name;
      });

      if(dataPart.length) {
        dataPart[0].checked = !! input.checked;
      }
  });
</code></pre>

<p><a href=""https://plnkr.co/edit/mFbYHOmc2rmeppB3nQ9k?p=preview"" rel=""nofollow"">Plunker</a></p>
","146656","","","","","2016-08-18 02:56:28","","","","1","","","","CC BY-SA 3.0"
"39010291","1","","","2016-08-18 04:58:21","","3","550","<p>I don't understand what does it mean by scheduler in rxjs documentation, so I'm trying to understand by scenario its useful in, so I can understand scheduler</p>
","5710014","","","","","2018-10-15 14:57:26","Rxjs: What scenario do you want to use scheduler","<javascript><scheduler><reactive-programming><rxjs><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"39029762","1","39029848","","2016-08-19 01:24:11","","0","1493","<p>I have some functions that accept an RxJS subject (backed to a socket) that I want to test. I'd like to mock the subject in a very request reply fashion. Since I'm unsure of a clean Rx way to do this, I'm tempted to use an EventEmitter to form my fake socket.</p>

<p>Generally, I want to:</p>

<ul>
<li>check that the message received on my ""socket"" matches expectations</li>
<li>respond to that message on the same subject: <code>observer.next(resp)</code></li>
</ul>

<p>I do need to be able to use data from the message to form the response as well.</p>

<hr>

<p>The code being tested is</p>

<pre><code>export function acquireKernelInfo(sock) {
  // set up our JSON payload
  const message = createMessage('kernel_info_request');

  const obs = shell
    .childOf(message)
    .ofMessageType('kernel_info_reply')
    .first()
    .pluck('content', 'language_info')
    .map(setLanguageInfo)
    .publishReplay(1)
    .refCount();

  sock.next(message);
  return obs;
}
</code></pre>
","700228","","700228","","2016-08-19 01:35:59","2016-08-19 01:35:59","How to Mock and test using an RxJS subject?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"39029848","2","","39029762","2016-08-19 01:35:28","","0","","<p>You could manually create two subjects and ""glue them together"" as one Subject with <code>Subject.create</code>:</p>

<pre class=""lang-js prettyprint-override""><code>const sent = new Rx.Subject();
const received = new Rx.Subject();

const mockWebSocketSubject = Subject.create(sent, received)

const s1 = sent.subscribe(
  (msg) =&gt; sentMsgs.push({ next: msg }),
  (err) =&gt; sentMsgs.push({ error: err }),
  () =&gt; sendMsgs.push({ complete: true })
);

const s2 = recieved.subscribe(
  (msg) =&gt; sentMsgs.push({ next: msg }),
  (err) =&gt; sentMsgs.push({ error: err }),
  () =&gt; sendMsgs.push({ complete: true })
);


// to send a message
// (presumably whatever system you're injecting this into is doing the sending)
sent.next('weee');

// to mock a received message
received.next('blarg');

s1.unsubscribe();
s2.unsubscribe();
</code></pre>

<p>That said, it's really a matter of what you're testing, how it's structured, and what the API is.</p>

<p>Ideally you'd be able to run your whole test synchronously. If you can't for some Rx-related reason, you should look into the <code>TestScheduler</code>, which has facilities to run tests in virtualized time.</p>
","135786","","","","","2016-08-19 01:35:28","","","","0","","","","CC BY-SA 3.0"
"39039577","1","","","2016-08-19 12:53:47","","3","359","<p>I am trying to find the cleanest solution and operators in order to chain observables.</p>

<p>My requirements are as follows:</p>

<ol>
<li>Retrieve a <code>userAccountToken</code> from route params</li>
<li>Use that <code>userAcccountToken</code> in order to do a http call to the backend</li>
<li>Again use the <code>userAcccountToken</code> in order to do another http call to the backend</li>
<li>Finally navigate to a route (i.e. <code>/dashboard</code>) if all has gone well above.</li>
</ol>

<p>My angular 2 component is as follows:</p>

<pre><code>import {Component, OnInit} from '@angular/core';
import {UserAccountService} from '../useraccount.service';
import {ActivatedRoute, Router} from '@angular/router';
import {SessionService} from '../../session/session.service';


@Component({
  templateUrl: 'useraccount-activation.component.html'
})
export class UserAccountActivationComponent implements OnInit {

  constructor(private userAccountService: UserAccountService,
              private sessionService: SessionService,
              private router: Router,
              private route: ActivatedRoute) {
  }

  ngOnInit() {
    this.route.params.map(params =&gt; params['userAccountToken'])//1.
      .switchMap(userAccountToken =&gt; this.userAccountService.activateAccount(userAccountToken))//2.
      .switchMap(() =&gt; this.sessionService.signinByUserAccountToken('???'))//3.
      .subscribe(() =&gt; this.router.navigate(['/dashboard']));//4.
  }
}
</code></pre>

<p>The issue is that I need the <code>userAccountToken</code> in two places and yet I need to subscribe to both http calls so that they are executed.</p>

<p>I could perform another <code>this.route.params.map(...)</code> between 2. and 3. but that seems repeating myself. </p>

<p>I could introduce state in the component with a <code>userAccountToken</code> instance variable but then my functions would be creating side-effects.</p>

<p>What could be a clean solution to this problem?</p>

<p><strong>edit</strong>: The following code:</p>

<pre><code>  ngOnInit() {
    this.route.params.map(params =&gt; params['userAccountToken'])
      .mergeMap(userAccountToken =&gt; Observable.concatAll(
        this.userAccountService.activateAccount(userAccountToken),
        this.sessionService.signinByUserAccountToken(userAccountToken)
      ))
      .subscribe(() =&gt; this.router.navigate(['/dashboard']));
  }
</code></pre>

<p>yields the following error:</p>

<pre><code>__WEBPACK_IMPORTED_MODULE_4_rxjs_Observable__.Observable.concatAll is not a function
</code></pre>

<p>even though I have imported <code>import 'rxjs/add/operator/concatAll';</code></p>

<p><strong>edit 2</strong>: The reason I get the above error is that I use <code>concatAll</code> on <code>Observable</code> and not on a instance/object of type <code>Observable</code>...</p>
","536299","","536299","","2016-08-19 16:17:55","2016-08-19 20:42:28","Issue with chaining a number of RxJS Observable operators","<angular><rxjs><observable><rxjs5>","1","0","0","","","CC BY-SA 3.0"
"39049586","1","39065711","","2016-08-20 01:16:58","","5","3161","<p>I'm guessing this should be somewhat easy to achieve but I've having trouble (conceptually, I guess) figuring out how to tackle it.</p>

<p>What I have is an API that returns an array of JSON objects. I need to step through these objects, and, for each object, make another AJAX call. The issue is the system that handles each AJAX call can only handle two active calls at a time (as it's quite a CPU-intensive task that hooks out into a desktop application).</p>

<p>I was wondering how I could achieve this using RxJS (either using version 5 or 4)?</p>

<p>EDIT: In addition, is it possible to have a chain of steps running concurrently. i.e.</p>

<p><code>
Downloading File: 1
Processing File: 1
Converting File: 1
Uploading File: 1
Downloading File: 2
Processing File: 2
Converting File: 2
Uploading File: 2
Downloading File: 3
Processing File: 3
Converting File: 3
Uploading File: 3
</code></p>

<p>I've tried doing something like:</p>

<pre><code>Rx.Observable.fromPromise(start())
    .concatMap(arr =&gt; Rx.Observable.from(arr))
    .concatMap(x =&gt; downloadFile(x))
    .concatMap((entry) =&gt; processFile(entry))
    .concatMap((entry) =&gt; convertFile(entry))
    .concatMap((entry) =&gt; UploadFile(entry))
    .subscribe(
        data =&gt; console.log('data', new Date().getTime(), data),
        error =&gt; logger.warn('err', error),
        complete =&gt; logger.info('complete')
    );
</code></pre>

<p>However that doesn't seem to work. The downloadFile, for example doesn't wait for processFile, convertFile and uploadFile to all complete, rather, the next one will run again as soon as the previous one completes.</p>
","394491","","3743222","","2016-11-18 05:15:16","2018-09-27 03:15:13","Batching using RxJS?","<javascript><rxjs><rxjs5>","4","2","1","","","CC BY-SA 3.0"
"39059991","1","39061945","","2016-08-21 00:59:42","","2","1206","<p>When I run a new JSBIN project with the following specifications:</p>

<p><strong>- Utilizing Tabs: JavaScript, Console</strong></p>

<p><strong>- Adding Library: RxJS 5.0.0</strong></p>

<p>And then run the following code block in the JavaScript area:</p>

<pre><code>var observable = Rx.Observable.create(observer =&gt; {
  setInterval(() =&gt; {
    observer.onNext('This is the output of my async operation');
  }, 2000);
});

observable.subscribe(response =&gt; console.log(response));
</code></pre>

<p>The preceding code should render the following output in the console area:</p>

<pre><code>""This is the output of my async operation""
</code></pre>

<p>Two seconds later, the console area should gain render:</p>

<pre><code>""This is the output of my async operation""
</code></pre>

<p>However, I receive the following error:</p>

<pre><code>""error""
-----------------------------
""ReferenceError: Rx is not defined
    at yivicazake.js:3:4
    at https://static.jsbin.com/js/prod/runner-3.39.12.min.js:1:13926
    at https://static.jsbin.com/js/prod/runner-3.39.12.min.js:1:10855
</code></pre>

<p>This is my first time pulling in RxJS as a library using JSBIN and I'm hoping someone has had experience with this particular error.</p>
","4897352","","","","","2016-08-21 14:48:59","JSBIN Project with RX.Js 5.0.0 Pulling 'Not Defined' Error","<javascript><rxjs5><jsbin>","2","0","2","","","CC BY-SA 3.0"
"39061945","2","","39059991","2016-08-21 07:39:58","","2","","<p>I am not sure which exact version of Rxjs beta u r using, I have created a jsbin here its working fine for me
<a href=""http://jsbin.com/henimevepa/edit?html,js,console,output"" rel=""nofollow"">http://jsbin.com/henimevepa/edit?html,js,console,output</a></p>

<p>Few things here</p>

<pre><code>- instead of '.onNext' in version 5 its just '.next'
- You need to subscribe to observer to run it.
</code></pre>
","1477260","","","","","2016-08-21 07:39:58","","","","5","","","","CC BY-SA 3.0"
"39065711","2","","39049586","2016-08-21 15:12:08","","4","","<p>Here are 2 approaches, if you want the sequence of requests exactly like this</p>

<pre><code>Downloading File: 1
Processing File: 1
Converting File: 1
Uploading File: 1
Downloading File: 2
Processing File: 2
...
</code></pre>

<p>You need to resolve all promises inside single concatMap method, like this</p>

<pre><code>Rx.Observable.fromPromise(getJSONOfAjaxRequests())
  .flatMap(function(x) { return x;})
  .concatMap(function(item) {
    return downloadFile(item)
      .then(processFile)
      .then(convertFile);
  })
  .subscribe(function(data) {
    console.log(data);
  });
</code></pre>

<p>see the working plunkr here: <a href=""https://plnkr.co/edit/iugdlC2PpW3NeNF2yLzS?p=preview"" rel=""nofollow"">https://plnkr.co/edit/iugdlC2PpW3NeNF2yLzS?p=preview</a>
This way, the new ajax call will be sent only when the previous is finished.</p>

<p>Another approach is that allow the files to send requests in parallel but the operations 'downloading,processing,converting,uploading' will be in sequence. For this you can get it working by</p>

<pre><code>Rx.Observable.fromPromise(getJSONOfAjaxRequests())
  .flatMap(function(x) { return x;})
  .merge(2)  // in case maximum concurrency required is 2
  .concatMap(function(item) {
    return downloadFile(item);
  })
  .concatMap(function(item) {
    return processFile(item);
  })
  .concatMap(function(item) {
    return convertFile(item)
  })
  .subscribe(function(data) {
    //console.log(data);
  });
</code></pre>

<p>see plunkr here: <a href=""https://plnkr.co/edit/mkDj6Q7lt72jZKQk8r0p?p=preview"" rel=""nofollow"">https://plnkr.co/edit/mkDj6Q7lt72jZKQk8r0p?p=preview</a></p>
","1477260","","1477260","","2016-08-22 08:42:25","2016-08-22 08:42:25","","","","3","","","","CC BY-SA 3.0"
"39066604","1","39066768","","2016-08-21 16:53:21","","32","28453","<p>After the release of Angular 2 RC.5 there was introduced router resolve. <a href=""https://angular.io/docs/ts/latest/guide/router.html#!#resolve-guard"" rel=""nofollow noreferrer"">Here</a> demonstrated example with Promise, how to do the same if I make a request to the server with Observable?</p>
<p>search.service.ts</p>
<pre class=""lang-ts prettyprint-override""><code>searchFields(id: number) {
  return this.http.get(`http://url.to.api/${id}`).map(res =&gt; res.json());
}
</code></pre>
<p>search-resolve.service.ts</p>
<pre class=""lang-ts prettyprint-override""><code>import { Injectable } from '@angular/core';
import { Router, Resolve, ActivatedRouteSnapshot } from '@angular/router';
import { Observable } from 'rxjs/Observable';

import { SearchService } from '../shared';

@Injectable()
export class SearchResolveService implements Resolve&lt;any&gt; {

  constructor(
    private searchService: SearchService ,
    private router: Router
  ) {}

  resolve(route: ActivatedRouteSnapshot): Observable&lt;any&gt; | Promise&lt;any&gt; | any {
    let id = +route.params['id'];
    return this.searchService.searchFields(id).subscribe(fields =&gt; {
      console.log('fields', fields);
      if (fields) {
        return fields;
      } else { // id not found
        this.router.navigate(['/']);
        return false;
      }
    });
  }
}
</code></pre>
<p>search.component.ts</p>
<pre class=""lang-ts prettyprint-override""><code>ngOnInit() {
  this.route.data.forEach((data) =&gt; {
    console.log('data', data);
  });
}
</code></pre>
<p>Get <code>Object {fields: Subscriber}</code> instead of real data.</p>
","2247766","","74089","","2021-03-04 14:38:24","2021-03-04 14:38:24","Angular 2 router resolve with Observable","<angular><angular2-routing><rxjs5>","1","2","13","","","CC BY-SA 4.0"
"39066768","2","","39066604","2016-08-21 17:09:54","","52","","<p>Don't call <code>subscribe()</code> in your service and instead let the route subscribe.</p>

<p>Change</p>

<pre><code>return this.searchService.searchFields().subscribe(fields =&gt; {
</code></pre>

<p>to</p>

<pre><code>import 'rxjs/add/operator/first' // in imports

return this.searchService.searchFields().map(fields =&gt; {
  ...
}).first();
</code></pre>

<p>This way an <code>Observable</code> is returned instead of a <code>Subscription</code> (which is returned by <code>subscribe()</code>).</p>

<p>Currently the router waits for the observable to close. You can ensure it gets closed after the first value is emitted, by using the <code>first()</code> operator.</p>
","217408","","664747","","2017-03-06 21:12:43","2017-03-06 21:12:43","","","","21","","","","CC BY-SA 3.0"
"39084119","1","","","2016-08-22 16:07:45","","0","249","<p>i am trying to create an observable from sendMail, currently my test for that looks like that:</p>

<pre><code>/// &lt;reference path=""../../typings/index.d.ts"" /&gt;
import * as chai from ""chai"";
let assert = chai.assert;
const Rx = require('rxjs');
var nodemailer = require('nodemailer');

describe(""emailPlugin"", function() {
   it.only('should emit one value from a callback', function () {
       let mailOptions = {
          from: '""Fred Foo ð¥"" &lt;MY@gmail.com&gt;', // sender address
          to: 'YOUR@gmail.com', // list of receivers; comma seperated
          subject: 'Hello â', // Subject line
          text: 'Hello world ð´', // plaintext body
          html: '&lt;b&gt;Hello world ð´&lt;/b&gt;' // html body
      };
      let transporter = nodemailer.createTransport('smtps://MY%40gmail.com:MY@smtp.gmail.com');

      let boundCallback = Rx.Observable.bindNodeCallback(transporter.sendMail);
      boundCallback(mailOptions, function(error, info){
          if(error){
              return error;
          }
          return info.response;
      }).subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
  });   
});
</code></pre>

<p>the result is an error: </p>

<p><code>[TypeError: Cannot convert undefined or null to object]</code></p>

<p>can someone help me out here?</p>
","4021204","","","","","2016-12-13 10:40:25","creating an observable from transporter.sendMail","<node.js><observable><nodemailer><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39108549","1","39109705","","2016-08-23 18:42:38","","9","6664","<p>I'm writing a timer stream using Date.now() and I'm having a problem understanding a detail.</p>

<p>When I write the stream using a switchMap, it works fine, and the <code>getTestStartTime$()</code> is called after the start$ starts emitting events.</p>

<pre><code>let start$ = Observable.fromEvent(document.querySelector('#start'), 'click');
let stop$ = Observable.fromEvent(document.querySelector('#stop'), 'click');

let getTestStartTime$ = () =&gt; Observable.of(Date.now())
    .delay(sampleTime)
    .repeat()
    .takeWhile(val =&gt; true);

let time$ = start$
    .switchMap(event =&gt; getTestStartTime$())
    .map(startTime =&gt; Date.now() - startTime)
    .map(diff =&gt; diff / 1000)
    .takeUntil(stop$)
    .repeat();
</code></pre>

<p>But when replacing switchMap with switchMapTo it seems the function is called before the start$ is firing. I can see this because Date.now() is called too early (it has the same time as the time of pageload).</p>

<pre><code>let time$ = start$
    .switchMapTo(getTestStartTime$()) // this calls getTestStartTime$ too early
    .map(startTime =&gt; Date.now() - startTime)
    .map(diff =&gt; diff / 1000)
    .takeUntil(stop$)
    .repeat();
</code></pre>

<p>Thanks.</p>
","3368477","","","","","2016-08-23 19:58:38","switchMapTo creates observable before subscription","<rxjs><rxjs5>","1","1","5","","","CC BY-SA 3.0"
"39109705","2","","39108549","2016-08-23 19:58:38","","41","","<p>It is calling early because you are <strong>calling</strong> the function when you are building the stream. </p>

<p><code>switchMap</code> takes a <em>function</em> which gets invoked when a new value comes from up stream. The result of that function is subscribed to as a new stream.</p>

<p><code>switchMapTo</code> takes an <em><code>Observable</code></em> which is subscribed to for every value that comes from up stream. You are creating the <code>Observable</code> by invoking <code>getTestStartTime$()</code>.</p>

<p>Use <code>switchMap</code> when the output depends on the value coming from upstream, and use <code>switchMapTo</code> when the actual upstream value is irrelevant and is only used as a signal for subscription.</p>
","2521865","","","","","2016-08-23 19:58:38","","","","3","","","","CC BY-SA 3.0"
"39111254","1","39116054","","2016-08-23 21:52:07","","1","1525","<p>As suggested I installed using</p>

<pre><code>npm install @reactivex/rxjs@5.0.0-beta.11
</code></pre>

<p>I can import almost everything this way:</p>

<pre><code>import { Observable, Subscriber } from '@reactivex/rxjs';
</code></pre>

<p>but not WebSocketSubject. I've tried:</p>

<pre><code>import { WebSocketSubject } from '@reactivex/rxjs';
import { WebSocketSubject } from '@reactivex/rxjs/observable/dom';
</code></pre>

<p>... and many other variations.</p>
","199855","","199855","","2016-08-24 04:54:22","2016-08-24 14:03:57","How do I import WebSocketSubject in TypeScript?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39115006","1","","","2016-08-24 05:22:50","","5","4319","<p>For instance, I'm currently calling unsubscribe from an Observable that is returned from Angular 2's HTTP.</p>

<p>But I have some custom logic surrounding it.</p>

<p>Is it possible to add custom teardown logic to an already existing Observable, like the one returned from Angular 2's HTTP?</p>

<p>Something along the lines of Observable.prototype.whenUnsubscribed(customTeardownLogic) maybe?</p>
","5154063","","","","","2021-11-30 20:23:44","Is it possible to add Teardown logic to an already existing Observable?","<rxjs5>","4","0","1","","","CC BY-SA 3.0"
"39116054","2","","39111254","2016-08-24 06:37:55","","4","","<p><code>dom</code> is not a file, but a folder, so there will nothing to import :)
Try this one:</p>

<p><code>import { WebSocketSubject } from '@reactivex/rxjs/src/observable/dom/WebSocketSubject';</code></p>

<p>The import will give you the TypeScript source file, but I would recommend installing <code>rxjs@5.0.0-beta.11</code> rather than <code>@reactivex/rxjs</code> so you can do this:</p>

<p><code>import { WebSocketSubject } from 'rxjs/observable/dom/WebSocketSubject';</code> </p>

<p>The above import will give you the <code>.js</code> file, not the <code>.ts</code> file. Autocompletion and all the good TypeScript stuff will still work, because the package has the <code>.d.ts</code> files!</p>

<p><em>One more tip:</em> If you having problems finding the correct import path:</p>

<ol>
<li>Go to <code>node_modules/[&lt;organization_name&gt;/]&lt;package_name&gt;</code> (the organization name is optional, they all start with <code>@</code>).</li>
<li>This is your starting point for all imports, from there you can append any folder/file path to the <code>[&lt;organization_name&gt;/]&lt;package_name&gt;</code> and the import <em>should</em> work.</li>
</ol>

<p><strong>But</strong> if you only point to the import statement to <code>[&lt;organization_name&gt;/]&lt;package_name&gt;</code> Typescript will pick up the real path to the import file from the <code>main</code> property of the <code>package.json</code>. Which in the case of <code>@reactivex/rxjs</code> points to <code>index.js</code> and that file again will do a <code>require('./dist/cjs/Rx')</code>. So when you do <code>@reactivex/rxjs</code> the path gets resolved to <code>node_modules/@reactivex/rxjs/dist/cjs/Rx.js</code>.</p>

<p>Hope this explaination wasn't to confusing, but the path resolution sometimes can be :-x</p>
","298969","","298969","","2016-08-24 14:03:57","2016-08-24 14:03:57","","","","5","","","","CC BY-SA 3.0"
"39121167","1","39129945","","2016-08-24 10:45:56","","0","277","<p>I am surprised about the behavior of the following code (see <a href=""https://plnkr.co/edit/OVc26DmXpvXqSOJsQAoh?p=preview"" rel=""nofollow"">https://plnkr.co/edit/OVc26DmXpvXqSOJsQAoh?p=preview</a>):</p>

<pre><code>  let empty = Observable.empty();
  let source = Observable.range(1, 5)
    .map(i =&gt;
      Observable.timer(i * 2000, 1000).map(x =&gt; ""source "" + i + "": "" + x).take(10))
    .reduce((s1, s2) =&gt; s1.takeUntil(s2).concat(s2), empty)
    .mergeAll();

   var subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    },
    function (err) {
        console.log('Error: ' + err);   
    },
    function () {
        console.log('Completed');   
    });
</code></pre>

<p>yields</p>

<pre><code>Next: source 1: 0
Next: source 1: 1
</code></pre>

<p>--- a long pause here ---</p>

<pre><code>Next: source 5: 0
Next: source 5: 1
Next: source 5: 2
Next: source 5: 3
Next: source 5: 4
Next: source 5: 5
Next: source 5: 6
Next: source 5: 7
Next: source 5: 8
Next: source 5: 9
Completed
</code></pre>

<p>but I had hoped to see <strong>all</strong> sequences show up inbetween. What went wrong?</p>

<h1>Edit:</h1>

<p>Note that using <code>share()</code>not always cures it. This code fails:</p>

<pre><code>   let originalSequence = Observable.timer(0, 1000).take(10).share();

   let empty = Observable.empty();
     let source = Observable.range(1, 5)
      .map(i =&gt;
      originalSequence.delay(i * 2000).map(x =&gt; ""source "" + i + "": "" + x))
    .reduce((s1, s2) =&gt; s1.takeUntil(s2).concat(s2), empty)
    .mergeAll(); 
</code></pre>

<p>and this code works as I expect and I do not understand why</p>

<pre><code> let empty = Observable.empty();
     let source = Observable.range(1, 5)
      .map(i =&gt;
      Observable.timer(i * 2000, 1000).map(x =&gt; ""source "" + i + "": "" + x).take(10).share())
    .reduce((s1, s2) =&gt; s1.takeUntil(s2).concat(s2), empty)
    .mergeAll();
</code></pre>

<h1>Edit 2:</h1>

<p>The C# version also has a behavior I would not expect, but at the same time behaves <strong>differently</strong>:</p>

<pre><code>using System;
using System.Linq;
using System.Reactive.Linq;
using System.Threading;

namespace RxScanProblem
{
    class Program
    {
        static void Main(string[] args)
        {
            var originalSequence = Observable.Timer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1)).Take(10).Select(i =&gt; (long)i).Publish();

            var empty = Observable.Empty&lt;string&gt;();
            var source = Observable.Range(1, 5)
             .Select(i =&gt; originalSequence.Delay(TimeSpan.FromSeconds(2 * i)).Select(x =&gt; ""source "" + i + "": "" + x))
             .Aggregate(empty, (s1, s2) =&gt; s1.TakeUntil(s2).Concat(s2))
             .SelectMany(x =&gt; x);

            source.Subscribe(
                s =&gt; Console.WriteLine(""Next: "" + s),
                ex =&gt; Console.WriteLine(""Error: "" + ex.Message),
                () =&gt; Console.WriteLine(""Completed""));

            originalSequence.Connect();

            // Dirty, I know
            Thread.Sleep(20000);
        }
    }
}
</code></pre>

<p>yields (with some delay)</p>

<pre><code>Next: source 1: 0
Next: source 1: 1
Next: source 1: 2
</code></pre>

<h1>Edit 3</h1>

<p>Also <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switch"" rel=""nofollow"">switch()</a> does not behave as i would expect!</p>

<pre><code>   let empty = Observable.empty();
     let source = Observable.range(1, 5)
      .map(i =&gt; Observable.timer(i * 2000, 1000).map(x =&gt; ""source "" + i + "": "" + x).take(10))
      .switch();
</code></pre>

<p>yields</p>

<pre><code>Next: source 5: 0
Next: source 5: 1
Next: source 5: 2
Next: source 5: 3
Next: source 5: 4
Next: source 5: 5
Next: source 5: 6
Next: source 5: 7
Next: source 5: 8
Next: source 5: 9
</code></pre>

<p>Same (!) behavior for C#</p>

<pre><code>   var originalSequence = Observable.Timer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1)).Take(10).Select(i =&gt; (long)i).Publish();

    var empty = Observable.Empty&lt;string&gt;();
    var source = Observable.Range(1, 5)
     .Select(i =&gt; originalSequence.Delay(TimeSpan.FromSeconds(2 * i)).Select(x =&gt; ""source "" + i + "": "" + x))
     .Switch();
</code></pre>
","1528210","","1528210","","2016-08-24 16:00:29","2016-08-24 18:07:54","Unexpected behavior of Rx.Observable.reduce takeUntil concat","<system.reactive><rxjs5>","2","4","","","","CC BY-SA 3.0"
"39124384","1","","","2016-08-24 13:14:22","","1","83","<p>I have a synchronous operation that is run somewhere down a chain of RxJS observables subscription.</p>

<p>This synchronous operation sets data on local storage (synchronous) that is required further down the chain in order to perform a http call (asynchronous/observable).</p>

<p>Here is a summary of the sequence:</p>

<ol>
<li>Async operation returning an observable called</li>
<li>Sync operation setting data on local storage</li>
<li>Async operation using local storage date and returning an observable</li>
<li>Final subscription</li>
</ol>

<p>By the time <strong>3.</strong> is called, it seems data is not available on local storage - supposed to have been set by <strong>2.</strong></p>

<p>The above is just a simplification of the issue.</p>

<p>Here is the full code (in typescript):</p>

<p>This is called by a form (located in a component):</p>

<pre><code>  resetPassword() {
    this.submitted = true;
    if (this.passwordResetForm.valid) {
      this.route.params.map(params =&gt; params['userAccountToken'])
        .switchMap(userAccountToken =&gt; {
          return Observable.concat(
            this.userAccountService.resetPassword(Object.assign(this.passwordResetForm.value.passwordReset, {token: userAccountToken})),
            this.sessionService.signinByUserAccountToken(userAccountToken)
          );
        })
        //Will require the UserAccountResolve below which will itself fail because 'x-auth-token' is not yet available on local storage
        .subscribe(() =&gt; this.router.navigate(['/dashboard']));
    }
  }
</code></pre>

<p>from UserAccountService:</p>

<pre><code>  resetPassword(passwordResetForm) {
    return this.http.put(this.urls.USER_ACCOUNT.RESET_PASSWORD, passwordResetForm);
  }
</code></pre>

<p>from SessionService:</p>

<pre><code>  signinByUserAccountToken(userAccountToken: string) {
    return this.http.post(format(this.urls.AUTHENTICATION.SIGNIN_BY_USER_ACCOUNT_TOKEN, {userAccountToken}), null)
      .do(response =&gt; this.setPersonalInfo(response.headers.get('x-auth-token')));
  }

  private setPersonalInfo(sessionToken) {
    localStorage.setItem('authenticated', 'true');
    localStorage.setItem('sessionToken', sessionToken);
    this.authenticated$.next(true);
  }
</code></pre>

<p>UserAccountResolve:</p>

<pre><code>import {Injectable} from '@angular/core';
import {Resolve, ActivatedRouteSnapshot} from '@angular/router';
import {UserAccount} from '../shared/models/useraccount.model';
import {AuthenticatedHttpClient} from '../shared/services/authenticated-http-client.service';
import {URLS} from '../urls/URLS';

@Injectable()
export class UserAccountResolve implements Resolve&lt;UserAccount&gt; {

  private urls;

  constructor(private authenticatedHttpClient: AuthenticatedHttpClient) {
    this.urls = URLS;
  }

  resolve(route: ActivatedRouteSnapshot) {
    //Will fail
    return this.authenticatedHttpClient.get(this.urls.USER_ACCOUNT.USER_ACCOUNT)
      .map(response =&gt; response.json());
  }

}
</code></pre>

<p>AuthenticatedHttpClient:</p>

<pre><code>@Injectable()
export class AuthenticatedHttpClient {

  static createAuthorizationHeader(headers: Headers) {
    //Is not available on local storage when required
    headers.append('x-auth-token', localStorage.getItem('sessionToken'));
  }

  constructor(private http: Http) {
  }


  get(url) {
    let headers = new Headers();
    AuthenticatedHttpClient.createAuthorizationHeader(headers);
    return this.http.get(url, {
      headers: headers
    });
  }
  ...
</code></pre>

<p>Can someone please help?</p>
","536299","","","","","2017-07-28 14:01:49","Issue with synchronous operation somewhere down a chain RxJS observables subscription","<rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39129945","2","","39121167","2016-08-24 17:50:26","","2","","<p>Lets look at what your code does.</p>

<pre><code>  let source = Observable.range(1, 5)
    .map(i =&gt;
      Observable.timer(i * 2000, 1000).map(x =&gt; ""source "" + i + "": "" + x).take(10))
    .reduce((s1, s2) =&gt; s1.takeUntil(s2).concat(s2), empty)
    .mergeAll();
</code></pre>

<p>First map will transform <code>{1,2,3,4,5}</code> into</p>

<pre><code>s1 = Observable.timer(1 * 2000, 1000).map(x =&gt; ""source 1: "" + x).take(10));
s2 = Observable.timer(2 * 2000, 1000).map(x =&gt; ""source 2: "" + x).take(10));
s3 = Observable.timer(3 * 2000, 1000).map(x =&gt; ""source 3: "" + x).take(10));
s4 = Observable.timer(4 * 2000, 1000).map(x =&gt; ""source 4: "" + x).take(10));
s5 = Observable.timer(5 * 2000, 1000).map(x =&gt; ""source 5: "" + x).take(10));
</code></pre>

<p>next, <code>reduce</code> will glue them together like this:</p>

<pre><code>s1.takeUntil(s2).concat(s2)
   .takeUntil(s3).concat(s3)
   .takeUntil(s4).concat(s4)
   .takeUntil(s5).concat(s5)
</code></pre>

<p>now lets write a small marble to show what all these streams will yield:</p>

<pre><code>s1               --0123456789
s2               ----0123456789
s3               ------0123456789
s4               --------0123456789
s5               ----------0123456789
s1.takeUntil(s2) --01|
  .concat(s2)    --01----0123456789
  takeUntil(s3)  --01--|
  .concat(s3)    --01--------0123456789
  takeUntil(s4)  --01----|
  .concat(s4)    --01------------0123456789
  takeUntil(s5)  --01------|
  .concat(s5)    --01----------------0123456789
</code></pre>

<p>Now, if you use <code>share()</code>, you effectively publish the source. Publish means you multicast to all subscribers at the same time. This works well if there are 2 subscribers, even if one arrives later than the other, the source will continue mid-stream for the second subscriber. Things change when the first subscriber disconnect before the second one arrive. To preserve resources, <code>share()</code> will disconnect the source, and resubscribe to it later. Given you started with cold observables, this means they will start again at the beginning, with the long wait.</p>

<p>Since you use <code>.takeUntil(s2).concat(s2)</code>, you will actually unsubscribe from <code>s2</code> right before you subscribe to <code>s2</code> again. After all <code>concat</code> wont connect until it receives <code>completed</code> from <code>takeUntil</code> and <code>takeUntil</code> wont emit <code>completed</code> until <code>s2</code> has yielded. If <code>s2</code> yields, takeUntil will instantly unsubscribe from it before forwarding <code>completed</code> down stream. This means that s2 will have no subscribers for a split second, and the source will be reset.</p>

<p>What you probably expected was that <code>s2</code> would stay connected the entire time, and would keep running in the background. This would work if you had used a hot observable resulting from an active source instead of a cold observable made hot trough <code>share()</code>.</p>

<p>I will not go into detail on <code>switch()</code> since i believe you already understood the problem there: It will disconnect the previous source when the next one arrives, not when the next one yields.</p>

<p>What you can do, is write your own 'switchOnYield'</p>

<pre><code>source.publish(src =&gt; src
  .flatMap(inner1 =&gt; 
    inner1.takeUntil(src.flatMap(inner2 =&gt; inner2.take(1)))
  ))
</code></pre>

<p>What this does is merge all sources from source together, but add <code>takeUntil</code> on them with all latter sources. If any of the later sources yields, the first bunch will be unsubscribed. This works because the first time <code>src</code> yields, <code>.flatMap(inner1</code> will run. The second time it yields, <code>src.flatMap(inner2</code> will merge any item from the later source into the <code>takeUntil</code> operator.</p>

<p><a href=""http://jsbin.com/naveva/3/edit?js,console,output"" rel=""nofollow"">demo here</a></p>
","402027","","","","","2016-08-24 17:50:26","","","","3","","","","CC BY-SA 3.0"
"39137704","1","39137887","","2016-08-25 06:00:05","","2","6791","<p>I thought to have a simple problem, but i am having a hard time finding confirmation if my solution is ""correct""</p>

<p>I have a child component <code>SearchComponent</code> with a <code>formControl</code></p>

<pre class=""lang-js prettyprint-override""><code>@Component({
    selector : ""my-search"",
    inputs : [""placeholder""],
    template : `
      &lt;div class=""searchForm""&gt;
        &lt;input type=""text"" [placeholder]=""placeholder"" [formControl]=""search""/&gt;
      &lt;/div&gt;
    `
})
export class SearchComponent {

    search = new FormControl();
    public searchValues : Observable&lt;string&gt;;


    constructor() {
        this.searchValues  = this.search.valueChanges
            .debounceTime(400) 
            .distinctUntilChanged(); 
    }

}
</code></pre>

<p>I am using this in the parent component's template</p>

<pre><code>&lt;div class=""col-md-2 sidebar""&gt;
    &lt;my-search [placeholder]=""'search'""&gt;&lt;/my-search&gt;
&lt;/div&gt;
</code></pre>

<p>I now want to subscribe to the <code>searchValues</code> Observable from within the parent. The best i came up with is:</p>

<pre class=""lang-js prettyprint-override""><code>export class MyListComponent implements AfterContentInit {

    @ViewChild(SearchComponent) searchComponent: SearchComponent;

    constructor(private myService: MyService ) {

    }

    ngAfterContentInit() {
        this.searchComponent.searchValues.subscribe(s=&gt;this.search(s))
    }

    private search(s: string) {
        this.foos = this.myService.find(s); 
    }

    foos: Observable&lt;[Foo]&gt;; // used on a ngFor | async

}
</code></pre>

<p>Is this recommended approach? Is there no better way to define the contract between the components (like can be done with <code>@Input</code> and <code>@Output</code>)?</p>
","4869457","","","","","2016-08-25 06:42:58","Subscribe to child component's Observable (valueChanges)","<angular><observable><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"39137887","2","","39137704","2016-08-25 06:12:09","","2","","<p>You could easily use @Output for this.
In the search component you could add one like: </p>

<pre><code>@Output() searchEvent: EventEmitter = new EventEmitter();
</code></pre>

<p>Then subscribe to the text changes and (re)emit them:</p>

<pre><code>this.search.valueChanges
        .debounceTime(400) 
        .distinctUntilChanged()
        .subscribe((event) =&gt; this.searchEvent.emit(event));
</code></pre>

<p>After that you have the Output that you can use in any parent component. Without any need for a component reference (ViewChild).</p>

<p><strong>Edit</strong> </p>

<p>One way to use this would be to have a Subject in the parent component that you push changes to <code>updateStream = new Subject()</code> and the event handler <code>(searchEvent) = ""updateStream.next($event)""</code>.</p>

<p>Then you can create the Observable like:</p>

<pre><code>foo = updateStream.flatMap((s) =&gt; myService.find(s))
</code></pre>
","225780","","225780","","2016-08-25 06:42:58","2016-08-25 06:42:58","","","","3","","","","CC BY-SA 3.0"
"39167415","1","39190202","","2016-08-26 13:23:17","","8","10870","<p>Hi I'm relatively new to Angular2, Karma and Jasmine. Currently I'm using Angular 2 RC4 Jasmine 2.4.x 
I have an Angular 2 service which periodically calls an http service like this:</p>

<pre class=""lang-typescript prettyprint-override""><code>getDataFromDb() { return Observable.timer(0, 2000).flatMap(() =&gt; {
        return this.http.get(this.backendUrl)
            .map(this.extractData)
            .catch(this.handleError);
    });
}
</code></pre>

<p>Now I want to test the functionality. For testing purposes I have just tested the ""http.get"" on a separate function without the Observable.timer by doing:</p>

<pre class=""lang-typescript prettyprint-override""><code>const mockHttpProvider = {
    deps: [MockBackend, BaseRequestOptions],
    useFactory: (backend: MockBackend, defaultOptions: BaseRequestOptions) =&gt; {
        return new Http(backend, defaultOptions);
    }
}

describe('data.service test suite', () =&gt; {
    var dataFromDbExpected: any;

    beforeEachProviders(() =&gt; {
        return [
            DataService,
            MockBackend,
            BaseRequestOptions,
            provide(Http, mockHttpProvider),
        ];
    });

    it('http call to obtain data',
        inject(
            [DataService, MockBackend],
            fakeAsync((service: DataService, backend: MockBackend) =&gt; {
                backend.connections.subscribe((connection: MockConnection) =&gt; {
                    dataFromDbExpected =  'myData';
                    let mockResponseBody: any = 'myData';
                    let response = new ResponseOptions({ body: mockResponseBody });
                    connection.mockRespond(new Response(response));

                });
                const parsedData$ = service.getDataFromDb()
                    .subscribe(response =&gt; {
                        console.log(response);
                        expect(response).toEqual(dataFromDbExpected);
                    });
            })));
});
</code></pre>

<p>I obviously want to test the whole function with the Observable.timer. I think one might want to use the TestScheduler from the rxjs framework, but how can I tell to only repeat the timer function for x times? I couln't find any documentation using it in the typescript context.</p>

<p>Edit: I'm using rxjs 5 beta 6</p>

<p>Edit: Added working example for Angular 2.0.0 final release:</p>

<pre class=""lang-typescript prettyprint-override""><code>describe('when getData', () =&gt; {
    let backend: MockBackend;
    let service: MyService;
    let fakeData: MyData[];
    let response: Response;
    let scheduler: TestScheduler;

    beforeEach(inject([Http, XHRBackend], (http: Http, be: MockBackend) =&gt; {
        backend = be;
        service = new MyService(http);
        fakeData = [{myfake: 'data'}];
        let options = new ResponseOptions({ status: 200, body: fakeData });
        response = new Response(options);

        scheduler = new TestScheduler((a, b) =&gt; expect(a).toEqual(b));
        const originalTimer = Observable.timer;
        spyOn(Observable, 'timer').and.callFake(function (initialDelay, dueTime) {
            return originalTimer.call(this, initialDelay, dueTime, scheduler);
        });
    }));
    it('Should do myTest', async(inject([], () =&gt; {
        backend.connections.subscribe((c: MockConnection) =&gt; c.mockRespond(response));
        scheduler.schedule(() =&gt; {
            service.getMyData().subscribe(
                myData =&gt; {
                    expect(myData.length).toBe(3,
                        'should have expected ...');
                });
        }, 2000, null);
        scheduler.flush();
    })));
});
</code></pre>
","6761501","","327301","","2019-11-26 14:05:56","2019-11-26 14:06:22","Unit Test RxJS Observable.timer using typescript, karma and jasmine","<unit-testing><angular><rxjs5>","4","0","2","","","CC BY-SA 4.0"
"39169042","1","","","2016-08-26 14:46:50","","19","7693","<p>In JsBin, I got error ""Rx.Observable.just is not a function"" in Firefox &amp; Chrome. JsBin example : <a href=""http://jsbin.com/vunuta/edit?html,js,console"" rel=""noreferrer"">http://jsbin.com/vunuta/edit?html,js,console</a></p>

<p>HTML :</p>

<pre><code>script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.7/dist/global/Rx.umd.js""&gt;
</code></pre>

<p>Typescript :</p>

<pre><code>Rx.Observable.from ([1,2,3]).subscribe(x =&gt; console.log(x)); // Work
Rx.Observable.just (99).subscribe(x =&gt; console.log(x)); // Fail
Rx.Observable.return (99).subscribe(x =&gt; console.log(x)); // Fail
</code></pre>

<p>Tx</p>
","22280","","","","","2019-05-05 11:35:57","Rx.Observable.just is not a function in JSBIN & RxJS 5","<rxjs5><jsbin>","2","1","1","","","CC BY-SA 3.0"
"39181404","1","39181621","","2016-08-27 12:57:06","","1","308","<p>I am using Angular2 and I want to track changes in array,but there is only RxJs5,and seems it hasn`t such functionality.</p>
","5434523","","","","","2016-08-27 13:23:25","Is there an equivalent to RxJs<=4#ofArrayChanges in RxJs5","<javascript><angular><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"39181621","2","","39181404","2016-08-27 13:23:25","","1","","<p>There is no equivalent. The <code>Object.observe</code> proposal has been <a href=""https://esdiscuss.org/topic/an-update-on-object-observe"" rel=""nofollow"">withdrawn from ES7</a>, so there is little point in having <code>ofArrayChanges</code> or <code>ofObjectChanges</code> in RxJS 5.</p>
","6680611","","","","","2016-08-27 13:23:25","","","","1","","","","CC BY-SA 3.0"
"39184789","1","39185021","","2016-08-27 19:11:33","","37","7060","<p>I am reading the official documentation of RxJS and then I realized they both are doing exactly the same thing.</p>
<p>To me they both seem exactly similar.</p>
<p>Please point out the difference between them if there is any at all.</p>
","6309913","","74089","","2020-12-02 13:15:25","2020-12-02 13:15:25","Difference between audit and debounce in RxJS?","<rxjs><rxjs5><reactivex>","2","1","7","","","CC BY-SA 4.0"
"39185021","2","","39184789","2016-08-27 19:36:45","","69","","<p>I'm going to describe the difference between them in terms of their <code>Time</code> versions as that's how I understand them best. </p>

<p>Both <code>auditTime</code> and <code>debounceTime</code> will initially start a timer when an event comes in. Both will wait the given amount of time before they emit an event. The difference is that <code>debounceTime</code> resets the timer whenever a new event comes in while <code>auditTime</code> does not. <code>auditTime</code> will emit the most recent event after the given number of milliseconds whether or not it is still receiving events. <code>debounceTime</code> will wait for a gap in the events. You said you read the documentation but just to double check I have found <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"">this</a> document particularly helpful.</p>
","6733371","","","","","2016-08-27 19:36:45","","","","2","","","","CC BY-SA 3.0"
"39189111","1","","","2016-08-28 07:50:00","","3","2260","<p>I have extended <code>Http</code> class to set default headers and handle errors for all the requests inside an angular2 app, and I would like to use <code>retryWhen()</code> to retry the requests on certain errors.</p>

<p>On which errors should <code>retryWhen</code> retry the request and on which errors should it stop?</p>

<pre><code>@Injectable()
export class WpHttp extends Http {

  constructor(backend: ConnectionBackend,
            defaultOptions: RequestOptions,
            private wpService: WpService) {
    super(backend, defaultOptions);
  }

   get(endpoint: string, args?: QueryArgs): Observable&lt;Response&gt; {

    return super.get(this.getUrl(endpoint, args), this.getOptions())

        /** retry the request after 1 second */
        .retryWhen(error =&gt; error.delay(1000))

        /** timeout 3s
        .timeout(3000 , new Error('delay exceeded'))

        .catch((err) =&gt; {
            if (err.status === 400 || err.status === 422) {
                return Observable.throw(err);
            } 
            else {
                /** Stream errors in WpService */
                this.wpService.errors.next(err);
            }
        })
        .finally(() =&gt; {

        });
   }
}
</code></pre>

<p>And should it be used for <code>post</code>, <code>put</code>, <code>update</code>, <code>delete</code> requests?</p>
","1015648","","","","","2016-08-28 07:50:00","Using `retryWhen` in http requests","<http><angular><rxjs><rxjs5>","0","4","1","","","CC BY-SA 3.0"
"39190202","2","","39167415","2016-08-28 10:11:41","","9","","<p>You need to inject the TestScheduler into the timer method inside a beforeEach part:</p>

<pre class=""lang-typescript prettyprint-override""><code>beforeEach(function() {
  this.scheduler = new TestScheduler();
  this.scheduler.maxFrames = 5000; // Define the max timespan of the scheduler
  const originalTimer = Observable.timer;
  spyOn(Observable, 'timer').and.callFake(function(initialDelay, dueTime) {  
    return originalTimer.call(this, initialDelay, dueTime, this.scheduler);
  });
});
</code></pre>

<p>After that you have full control of the time with <code>scheduleAbsolute</code>:</p>

<pre class=""lang-typescript prettyprint-override""><code>this.scheduler.schedule(() =&gt; {
  // should have been called once
  // You can put your test code here
}, 1999, null);

this.scheduler.schedule(() =&gt; {
  // should have been called twice
  // You can put your test code here
}, 2000, null);

this.scheduler.schedule(() =&gt; {
  // should have been called three times
  // You can put your test code here
}, 4000, null);

this.scheduler.flush();
</code></pre>

<p>You need <code>scheduler.flush()</code> to start the TestScheduler.</p>

<p>edit: so if you want to only test it X times, use the schedule functions as often (and with the right absolute times in milliseconds) as you wish.</p>

<p>edit2: I added the missing scheduler start</p>

<p>edit3: I changed it so should be working with RxJs5</p>

<p>edit4: Add <code>maxFrames</code> setting since the default is 750ms and will prevent testing longer-running sequences.</p>
","1138386","","327301","","2019-11-26 14:06:22","2019-11-26 14:06:22","","","","8","","","","CC BY-SA 4.0"
"39203156","1","39218348","","2016-08-29 09:45:33","","2","652","<pre class=""lang-js prettyprint-override""><code>@Component({
    template: ` &lt;div&gt;
                    &lt;a *ngIf=""!sending"" (click)=""send()""&gt;Send&lt;/a&gt;
                    &lt;span *ngIf=""sending"" &gt;{{seconds}} s&lt;/span&gt;
                &lt;/div&gt;`,
    selector: 'password-reset-form'
})
export class PasswordResetFormComponent implements OnInit {

    sending:boolean = false;
    seconds:number = 60;
    counterObservable = new Subject();


    constructor(public authService:AuthService, public router:Router, public formBuilder:FormBuilder) {

    }

    ngOnInit() {

        this.counterObservable.subscribe(()=&gt; {
            this.seconds --;
        }, null, ()=&gt; {
            this.seconds = 60;
            this.sending = false;
        });
    }

    send() {

        this.sending = true; 
        this.counterObservable.next(Observable.interval(1000).take(60));
    }
}
</code></pre>

<p>Hey,I try to using ng2 and RxJS to make a timer,when I click the send button,it would display a 60s timer,but I spent a lot of time and still don't know how to use RxJS to do it.
I would appreciate very much if somebody can help me. </p>
","6176355","","217408","","2016-08-29 09:50:51","2016-08-30 03:29:12","RxJS -- How to make a timer trigger by click a button when using RxJS?","<angular><rxjs><rxjs5>","2","0","0","","","CC BY-SA 3.0"
"39209560","1","39212429","","2016-08-29 15:10:22","","2","291","<p>I'm trying to bundle calls to a server to a maximum of maxEntries, but don't want to wait longer than maxWait ms. This used to be available as <code>windowWithTimeOrCount()</code> in RxJS 4, but was removed from RxJS 5.</p>

<p>Everything is working great, except that the last element of a window is lost. And speaking of 'lost' - that is how I feel now. Any RxJS Guru out there who could tell me what I'm doing wrong?</p>

<pre class=""lang-js prettyprint-override""><code> private chunk(queue: Observable&lt;CacheEntry&gt;, maxEntries: number, maxWait: number): Observable&lt;Observable&lt;CacheEntry&gt;&gt; {

    // We have an incoming stream of CacheEntries to be retrieved. We want to bundle these in units of max maxEntries
    // but wait no longer than max maxWait ms. We return an Observable, that emits Observables of CacheEntries that
    // complete after maxEntries / maxWait (whatever comes first).
    const toggleSubject = new Subject&lt;void&gt;();

    return queue

    // Start emitting a new Observable every time toggleSubject emits.
    // (bufferWhen() wouldn't work as we have to count the elements as they come and buffer only gives us the
    // complete collection)
      .windowWhen(() =&gt; toggleSubject)

      // map() is called once for every window (maxEntries/maxWait)
      // the inner do() is called for every element in the window, allowing us to set up the timeout callback and to
      // count all elements, then emitting on toggleSubject, triggering a new Observable.
      // (We have to map() here - instead of an outer do() -  because otherwise the original obs would be streamed
      // and the hooked up version with the inner do() would never be called.)
      .map((obs) =&gt; {
        // counts the number of cacheEntries already in this stream
        let count = 0;
        // flag to kill the timeout callback
        let done = false;
        // we have to return an Observable
        return obs.do(() =&gt; {
            count++;
            if (count === 1) {
              // we start counting when the first element is streamed.
              IntervalObservable.create(maxWait).first().subscribe(() =&gt; {
                if (!done) {
                  //trigger due to maxWait
                  toggleSubject.next(null);
                }
              });
            }
            if (count &gt; (maxEntries)) {
              done = true;
              // trigger due due to maxEntries(' + maxEntries + ')');
              toggleSubject.next(null);
            }
          }
        );
      });
  }
</code></pre>

<p>The element that triggers <code>toggleSubject.next(null)</code> due to <code>if (count &gt; (maxEntries))</code> is lost (not in any window).</p>

<p>EDIT: maxTime starts ticking the moment the first element of a new Observable is pushed. <code>if (count === 1 )</code>. This is a) the reason I'm working from inside of the windowed Observables in <code>map()</code> and b) important because that is the required behavior.</p>

<p>Example: maxElements: 100, maxWait: 100. 101 Elements are pushed at t=99. Expected behavior: At t=99 an Observable with 100 Elements is pushed. 1 Element is left over. Counter + Timer reset. At t=199 the counter for the second 'chunk' expires and pushes an Observable with 1 element.</p>

<p>(In this example Brandons (see answer) code would - if I read it correctly - push an Observable at t=99 with 100 elements and <strong>one ms later</strong>, at t=100, an Observable with one element.)</p>
","462897","","462897","","2016-08-30 05:20:13","2016-08-30 13:46:58","RxJS - using windowWhen() for maxWait and maxElements windows","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"39212429","2","","39209560","2016-08-29 18:03:53","","2","","<p>Yeah you don't want to use <code>map</code> for side effects like this.  As you noticed, you end up dropping items.</p>

<p>Here's a generic method that I think will do what you want.</p>

<p>Note: RXJS 5 currently has an <a href=""https://github.com/ReactiveX/rxjs/issues/1905"" rel=""nofollow"">issue</a> with the type definition for this overload of publish.  I've added some typecasts that should allow it to compile in TypeScript.</p>

<pre><code>chunk&lt;T&gt;(queue: Observable&lt;T&gt;, maxEntries: number, maxWait: number): Observable&lt;Observable&lt;T&gt;&gt; {
    // use publish() so that we can subscribe multiple times to the same stream of data.
    return queue.publish(entries =&gt; {
        // observable which will trigger after maxWait
        const timer = IntervalObservable.create(maxWait);
        // observable which will trigger after maxEntries
        const limit = entries.take(maxEntries).last();
        // observable which will trigger on either condition
        const endOfWindow = limit.takeUntil(timer);

        // use endOfWindow to close each window.
        return entries.windowWhen(() =&gt; endOfWindow) as Observable&lt;T&gt;;
    }) as Observable&lt;Observable&lt;T&gt;&gt;;
}
</code></pre>

<p>Edit:</p>

<p>If you don't want the timer to start until after the first item arrives in each window, then you can do it like so:</p>

<pre><code>chunk&lt;T&gt;(queue: Observable&lt;T&gt;, maxEntries: number, maxWait: number): Observable&lt;Observable&lt;T&gt;&gt; {
    // use publish() so that we can subscribe multiple times to the same stream of data.
    return queue.publish(entries =&gt; {
        // observable which will trigger after maxWait after the first
        // item in this window arrives:
        const timer = entries.take(1).delay(maxWait);
        // observable which will trigger after maxEntries
        const limit = entries.take(maxEntries).last();
        // observable which will trigger on either condition
        const endOfWindow = limit.takeUntil(timer);

        // use endOfWindow to close each window.
        return entries.windowWhen(() =&gt; endOfWindow) as Observable&lt;T&gt;;
    }) as Observable&lt;Observable&lt;T&gt;&gt;;
}
</code></pre>
","674326","","674326","","2016-08-30 13:46:58","2016-08-30 13:46:58","","","","10","","","","CC BY-SA 3.0"
"39218348","2","","39203156","2016-08-30 03:29:12","","1","","<pre><code>send() {

    this.sending = true;
    let subscription = Observable.interval(1000).take(60).subscribe(()=&gt; {
        this.seconds --;
    }, null, ()=&gt; {
        this.seconds = 60;
        this.sending = false;
        subscription.unsubscribe();
    });
}
</code></pre>

<p>I solved it,like this.</p>
","6176355","","","","","2016-08-30 03:29:12","","","","0","","","","CC BY-SA 3.0"
"39230526","1","39242014","","2016-08-30 14:39:25","","2","542","<p>I have an issue with the following validator function:</p>

<pre><code>export function validateEmailKnownFactory(userAccountService: UserAccountService): {[key: string]: any} {
  return (control: AbstractControl) =&gt; {
    return control
      .valueChanges
      .debounceTime(1000)
      .switchMap(value =&gt; userAccountService.checkAvailability(value))
      .map(res =&gt; {
        if (res.json() === false) {
          return null;
        }
        //Control flow does get through here
        return {emailKnownValidator: {unknown: true}};
      });
  };
}
</code></pre>

<p>It is not setting the error object (i.e. <code>{emailKnownValidator: {unknown: true}}</code>) on the form control but the control flow does get through the right place.</p>

<p>Now if I replace the above function with the following:</p>

<pre><code>export function validateEmailKnownFactory(userAccountService: UserAccountService): {[key: string]: any} {
  return (control: AbstractControl) =&gt; {
    return userAccountService.checkAvailability(control.value)
      .map(res =&gt; {
        if (res.json() === false) {
          return null;
        }
        return {emailKnownValidator: {unknown: true}};
      });
  };
}
</code></pre>

<p>the error object is set fine on the form control and the application behaves as expected.</p>

<p>Notice the difference: I get the <code>Observable</code> from <code>control.valueChanges</code> and I call <code>debounceTime</code> on it whereas the other function just call <code>checkAvailability</code> directly.</p>

<p>For completeness' sake here is the <code>checkAvailability</code> method:</p>

<pre><code>  checkAvailability(email: string) {
    let body = 'email=' + email;
    return this.http.get(this.urls.USER_ACCOUNT.EMAIL_AVAILABLE + body);
  }
</code></pre>
","536299","","","","","2016-08-31 06:15:05","Issue with validator function not setting error object on form control","<angular><rxjs><angular2-forms><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"39231343","1","39266413","","2016-08-30 15:17:44","","4","2093","<p><a href=""http://jsbin.com/potiqa/edit?html,js,console"" rel=""nofollow"">JSBIN Sample</a></p>

<p>I have a changeable set of child components (POJO object) that each have its own state stream. Each time a user triggers addChild/removeChild/clearChildren, a new set of children state streams is emitted with #switchMap. So far so good! (And so amazed by RxJS!)</p>

<p>With <code>Rx.Observable.from(arrayOfStateStreams).combineAll()</code> I get a good result as long as the <code>arrayOfStateStreams</code> isn't an empty array.</p>

<p>Since this is a partial state that is combined(Latest) on a higher level, I need to get an empty array emitted or the global state tree will contain old state data that is no longer true!</p>

<p>I can emit some reserved token like <code>['EMPTY-ARRAY-PLACEHOLDER-TOKEN']</code>, but that's just weird.
A better way would be to always append one last stream into the array so the last index can be considered trash. Still confusing code and state though.
Using <code>[null]</code> is not OK, since we could have a child state of <code>'null'</code>.</p>

<p>Anyone who can solve this in a good way? Can't this be supported since there should be no other representation of an empty array after #combineAll?</p>
","2083576","","415661","","2016-08-30 15:39:29","2021-11-28 05:20:06","combineAll does not emit on empty array","<rxjs><rxjs5><reactive-extensions-js>","4","2","1","","","CC BY-SA 3.0"
"39242014","2","","39230526","2016-08-31 06:15:05","","2","","<p>Asynchronous validator functions in Angular 2 can return either a <code>Promise</code> or an <code>Observable</code>. If an <code>Observable</code> is returned, it must complete - as Angular <a href=""https://github.com/angular/angular/blob/2.0.0-rc.5/modules/%40angular/forms/src/validators.ts#L124-L134"" rel=""nofollow"">converts the <code>Observable</code> to a <code>Promise</code></a>. That is, the <code>Observable</code> is used so that the validation can be asynchronous - not so that the validator can supply a stream of results.</p>

<p>The <code>Observable</code> composed from <code>valueChanges</code> in your first validator does not complete - as <code>valueChanges</code> keeps pumping out changes. That means the <code>Promise</code> doesn't resolve and there is no validation result that can be applied to the control. (Note that Angular will be calling your validation function for each change in the control's value and each call will see an <code>Observable</code> composed and subscribed to, so <code>checkAvailability</code> is going to be called for every change. The <code>debounceTime</code> operator is not going to effect the behaviour you seem to want.)</p>

<p>The <code>Observable</code> returned by the <code>checkAvailability</code> function does complete, so your second validator function works.</p>
","6680611","","","","","2016-08-31 06:15:05","","","","4","","","","CC BY-SA 3.0"
"39242024","1","","","2016-08-31 06:15:31","","1","203","<p>UI -Angular JS screen has to be a non blocking page, so we are using RxJS oberverable but not sure what we need to have in backend services to subscribe and publish the request from/to UI (whether we should go with Spring Reactor or RxJava)</p>
","3863943","","","","","2016-08-31 06:15:31","Compatible for RxJs is Spring reactor or RxJava","<angularjs><spring><spring-boot><rxjs><rxjs5>","0","0","","","","CC BY-SA 3.0"
"39252833","1","39259179","","2016-08-31 14:50:06","","1","404","<p>How to make something similar to the code below? </p>

<pre><code>.map( async request =&gt; await asyncRequest( request ) )  
</code></pre>

<p>Event click collect data and create a request object.
Then call .next( request ). How do I get [object Promise], and json?</p>

<pre><code>let a = Rx.Observable.create( observer =&gt; {
  Rx.Observable.fromEvent(document, 'click')
  .do( () =&gt; observer.next(  ) )
  .subscribe( result =&gt; console.log(`[a] complete`), error =&gt; console.log(`a error: ${error}`));
} );


function asyncRequest( request ) {
  return Rx.Observable.create( observer =&gt; {
    new Promise( ( resolve, reject ) =&gt; {
      setTimeout( ( ) =&gt; resolve( 'response' ), 1000 );
    } )
  } )
}

a
  .map( request =&gt; asyncRequest( request ) )
  .do( json =&gt; console.log(json) ) // to get json
  .subscribe( result =&gt; console.log(`complete: ${result}`) )
</code></pre>
","6315433","","","","","2016-08-31 21:19:39","How to make an async pipe in rxjs@5?","<javascript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"39258188","1","39984059","","2016-08-31 20:08:39","","0","564","<p>I'm new to RxJS and trying this (seemingly) simple task, but I just can't figure it out.</p>

<p>I want:<br/>
1.  Read an image from file<br/>
2.  Convert that image to several smaller images<br/>
3.  Save all images to file<br/></p>

<p>I've converted fs.readFile and fs.writeFile to observables.</p>

<pre><code>const readFile$ = Rx.Observable.bindNodeCallback(fs.readFile);
const writeFile$ = Rx.Observable.bindNodeCallback(fs.writeFile);
</code></pre>

<p>I made a pictures array pipeline.</p>

<pre><code>var pictureSizes = [
  {width: 100, size: 'thumbnail', suffix: '_t'},
  {width: 300, size: 'small', suffix: '_s'},
  {width: 600, size: 'medium', suffix: '_m'},
  {width: 1000, size: 'large', suffix: '_l'}
];
</code></pre>

<p>And I made a resizeImage$ function using graphics magic</p>

<pre><code>function resizeImage$(picture, data) {
  return Rx.Observable.create(observer =&gt; {
      gm(data)
        .resize(picture.width)
        .toBuffer('jpg', function(err, buffer) {
          if (err) {
            console.log(err);
            observer.error(err);
          } else {
            observer.next(buffer);
            observer.complete();
          }
        });
  })
}
</code></pre>

<p>I think (hope) the above is ok.  I can't figure out how to chain my operators.</p>

<pre><code>  readFile$('./largeimage.jpg')
    .mergeMap(data =&gt; pictureSizes.map(picture =&gt; resizeImage$(picture, data)))
    .flatMap(picture =&gt; writeFile$('./testImages/resized.jpg', picture))
    .subscribe(
    (x) =&gt; console.log('Next', x),
    (e) =&gt; console.log('Error', e),
    (c) =&gt; console.log('Complete',c )
  )
</code></pre>

<p>This above corrupted data to a jpeg file.  (And rewrites that file because I can't figure out how to get pictureSizes.suffix into the outputted file name.</p>

<p>Anything helps!  Thank you.</p>

<p><strong>UPDATE</strong></p>

<p>I got it to work, but I know this bizarre multiple subscription is a horrid anti pattern.  The main subscription completes before the image is resized.  I have a feeling this is a hot/cold issue, but I have no idea how to fix it.  Here's my now working code..</p>

<pre><code>const pictureSizes = [
  {width: 100, size: 'thumbnail', suffix: '_t'},
  {width: 300, size: 'small', suffix: '_s'},
  {width: 600, size: 'medium', suffix: '_m'},
  {width: 1000, size: 'large', suffix: '_l'}
];

const image = 'truck.jpg';

function resizeImage$(binary, pictureSize) {
  return new Rx.Observable(observer =&gt; {
      gm(binary)
        .resize(pictureSize.width)
        .toBuffer('jpg', function(err, buffer) {
          console.log('BUFFER');
          if (err) {
            console.log(err);
            observer.error(err);
          } else {
            observer.next({binary: buffer, pictureSize: pictureSize});
            observer.complete('done');
          }
        });
  }).subscribe(
    (resizedImage) =&gt; {
      console.log(resizedImage);
      const binary = resizedImage.binary;
      const pictureSize = resizedImage.pictureSize;
      const fileName = image.split('.')[0];
      const fileExtension = image.split('.')[1];
      fs.writeFile(`./testImages/${fileName}${pictureSize.suffix}.${fileExtension}`, binary);
    })
}
  var readFile$ = new  Rx.Observable.bindNodeCallback(fs.readFile);
  readFile$(`./${image}`)
  .zip(Rx.Observable.of(pictureSizes), (binary, sizes) =&gt;
        Rx.Observable.of({ binary: binary, sizes: sizes }))
  .mergeMap(x =&gt; x.value.sizes.map(pictureSize =&gt; 
       resizeImage$(x.value.binary, pictureSize)))
  .subscribe()
</code></pre>
","5220820","","5220820","","2016-09-01 20:55:02","2016-10-11 18:50:53","Resizing Pictures with RxJS and Node","<node.js><rxjs><graphicsmagick><rxjs5>","2","2","","","","CC BY-SA 3.0"
"39259179","2","","39252833","2016-08-31 21:19:39","","2","","<p>You should use <code>flatMap</code> instead of <code>map</code></p>

<pre><code>let a = 
  Rx.Observable.fromEvent(document, 'click')
    //Console loggin is a side effect, so make it the do instead of 
    //wrapping the Observable
    .do(_ =&gt; console.log(`[a] complete`), 
        error =&gt; console.log(`a error: ${error}`));


function asyncRequest( request ) {
  //This will actually handle the result of the Promise
  return Rx.Observable.defer(() =&gt; 
    new Promise( ( resolve, reject ) =&gt; {
      setTimeout( ( ) =&gt; resolve( 'response' ), 1000 );
    })
  );
}

a
  //Kicks off an async request each time an event comes in
  //and then flattens the response into the stream.
  .flatMap(asyncRequest)
  .do( json =&gt; console.log(json) ) // to get json
  .subscribe( result =&gt; console.log(`complete: ${result}`) )
</code></pre>
","2521865","","","","","2016-08-31 21:19:39","","","","0","","","","CC BY-SA 3.0"
"39262208","1","39262580","","2016-09-01 03:22:12","","4","414","<p>Let's say I have the following asynchronous callback-based ""infinite"" sequence, which I cancel after some time:</p>

<pre><code>'use strict';

const timers = require('timers');

let cancelled = false;

function asyncOperation(callback) {
  const delayMsec = Math.floor(Math.random() * 10000) + 1;
  console.log(`Taking ${delayMsec}msec to process...`);
  timers.setTimeout(callback, delayMsec, null, delayMsec);
}

function cancellableSequence(callback) {
  asyncOperation((error, processTime) =&gt; {
    console.log('Did stuff');
    if (!cancelled) {
      process.nextTick(() =&gt; { cancellableSequence(callback); });
    } else {
      callback(null, processTime);
    }
  });
}

cancellableSequence((error, lastProcessTime) =&gt; {
  console.log('Cancelled');
});

timers.setTimeout(() =&gt; { cancelled = true; }, 0);
</code></pre>

<p>The <code>asyncOperation</code> will execute and call back at least once, and the cancellation message will not display immediately, but rather after <code>asyncOperation</code> is complete.  The number of calls to <code>asyncOperation</code> depends on the internal <code>delayMsec</code> value and the delay argument passed to <code>setTimeout()</code> at the end (an attempt to show that these are variable).</p>

<p>I'm starting to learn RxJS5, and thought it might be possible to convert this into an Observable sequence (""oooh, an Observable subscription can be unsubscribe()d - that looks neat!"").</p>

<p>However, my attempts at turning <code>cancellableSequence</code> into an ES6 generator (how else to make infinite?) yielding <code>Observable.bindNodeCallback(asyncOperation)()</code> resulted in immediate yields, which in my case is undesired behavior.</p>

<p>I cannot use <code>Observable.delay()</code> or <code>Observable.timer()</code>, as I do not have a known, consistent interval.  (The Math.random(...) in <code>asyncOperation</code> was an attempt to indicate that I as the caller do not control the timing, and the callback happens ""some unknown time later."")</p>

<p>My failed attempt:</p>

<pre><code>'use strict';

const timers = require('timers');
const Rx = require('rxjs/Rx');

function asyncOperation(callback) {
  const delayMsec = Math.floor(Math.random() * 10000) + 1;
  console.log(`Taking ${delayMsec}msec to process...`);
  timers.setTimeout(callback, delayMsec, null, delayMsec);
}

const operationAsObservable = Rx.Observable.bindNodeCallback(asyncOperation);
function* generator() {
  while (true) {
    console.log('Yielding...');
    yield operationAsObservable();
  }
}

Rx.Observable.from(generator()).take(2).mergeMap(x =&gt; x).subscribe(
  x =&gt; console.log(`Process took: ${x}msec`),
  e =&gt; console.log(`Error: ${e}`),
  c =&gt; console.log('Complete')
)
</code></pre>

<p>Which results is the output:</p>

<pre><code>Yielding...
Taking 2698msec to process...
Yielding...
Taking 2240msec to process...
Process took: 2240msec
Process took: 2698msec
Complete
</code></pre>

<p>The yields occur right away.  The <code>Process took: xxx</code> output occurs when you'd expect (after 2240 and 2698ms, respectively).</p>

<p>(In all fairness, the reason I care about the delay in between yields is that <code>asyncOperation()</code> here is in reality a rate-limiting token bucket library which controls the rate of asynchronous callbacks - an implementation which I'd like to retain.)</p>

<p>As an aside, I attempted to replace <code>take(2)</code> with a delayed cancellation, but that never occurred:</p>

<pre><code>const subscription = Rx.Observable.from(generator()).mergeMap(x =&gt; x).subscribe(
  x =&gt; console.log(`Process took: ${x}msec`),
  e =&gt; console.log(`Error: ${e}`),
  c =&gt; console.log('Complete')
)

console.log('Never gets here?');
timers.setTimeout(() =&gt; {
  console.log('Cancelling...');
  subscription.unsubscribe();
}, 0);
</code></pre>

<p>Can what I'm attempting be accomplished with a cancellable subscription via RxJS?  (I can see other approaches, such as <code>process.exec('node', ...)</code> to run <code>asyncOperation()</code> as a separate process, giving me the ability to <code>process.kill(..)</code>, etc., but let's not go there...).</p>

<p>Is my initial callback-based implementation the suggested way to implement a cancellable sequence?</p>

<p>UPDATED SOLUTION:</p>

<p>See my reply comment to @user3743222's answer below.  Here's what I ended up with (replace ES6 generator with <code>Observable.expand()</code>):</p>

<pre><code>'use strict';

const timers = require('timers');
const Rx = require('rxjs/Rx');

function asyncOperation(callback) {
  const delayMsec = Math.floor(Math.random() * 10000) + 1;
  console.log(`Taking ${delayMsec}msec to process...`);
  timers.setTimeout(callback, delayMsec, null, delayMsec);
}

const operationAsObservable = Rx.Observable.bindNodeCallback(asyncOperation);

const subscription = Rx.Observable
  .defer(operationAsObservable)
  .expand(x =&gt; operationAsObservable())
  .subscribe(
    x =&gt; console.log(`Process took: ${x}msec`),
    e =&gt; console.log(`Error: ${e}`),
    c =&gt; console.log('Complete')
  );

subscription.add(() =&gt; {
  console.log('Cancelled');
});

timers.setTimeout(() =&gt; {
  console.log('Cancelling...');
  subscription.unsubscribe();
}, 0);
</code></pre>

<p>UPDATED SOLUTION 2:</p>

<p>Here's what I came up with for the alternate RxJS4 <code>repeatWhen()</code> approach:</p>

<pre><code>'use strict';

const timers = require('timers');
const Rx = require('rx');

function asyncOperation(callback) {
  const delayMsec = Math.floor(Math.random() * 1000) + 1;
  console.log(`Taking ${delayMsec}msec to process...`);
  timers.setTimeout(callback, delayMsec, null, delayMsec);
}

const operationAsObservable = Rx.Observable.fromNodeCallback(asyncOperation);

const subscription = Rx.Observable
  .defer(operationAsObservable)
  .repeatWhen(x =&gt; x.takeWhile(y =&gt; true))
  .subscribe(
    x =&gt; console.log(`Process took: ${x}msec`),
    e =&gt; console.log(`Error: ${e}`),
    c =&gt; console.log('Complete')
  );

timers.setTimeout(() =&gt; {
  console.log('Cancelling...');
  subscription.dispose();
}, 10000);
</code></pre>
","4947310","","4947310","","2016-09-01 18:47:36","2016-09-01 18:47:36","Convert infinite async callback sequence to Observable sequence?","<javascript><rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"39262580","2","","39262208","2016-09-01 04:09:50","","1","","<p>You seem to be repeating an action every time it finishes. That looks like a good use case for <code>expand</code> or <code>repeatWhen</code>.</p>

<p>Typically, that would be something like :</p>

<pre><code>Rx.Observable.just(false).expand(_ =&gt; {  
  return cancelled ? Rx.Observable.empty() : Rx.Observable.fromCallback(asyncAction)
})
</code></pre>

<p>You put <code>cancelled</code> to true at any point of time and when the current action finishes, it stops the loop. Haven't tested it so I would be interested to know if that worked in the end.</p>

<p>You can have a look at similar questions about polling:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/35856397/how-to-build-an-rx-poller-that-waits-some-interval-after-the-previous-ajax-promi"">How to build an rx poller that waits some interval AFTER the previous ajax promise resolves?</a></li>
</ul>

<p>Documentation:</p>

<ul>
<li><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/fromcallback.md"" rel=""nofollow noreferrer"">[fromCallback]</a></li>
<li><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/expand.md"" rel=""nofollow noreferrer"">[expand]</a></li>
</ul>

<p>Documentation links are for Rxjs 4 but there should not be much changes vs v5</p>
","3743222","","-1","","2017-05-23 10:29:08","2016-09-01 04:16:10","","","","5","","","","CC BY-SA 3.0"
"39266413","2","","39231343","2016-09-01 08:27:16","","3","","<p><em>Credits go to <a href=""https://github.com/ReactiveX/rxjs/issues/1910#issuecomment-243617202"" rel=""nofollow noreferrer"">github user trxcllnt who provided the following answer</a>:</em></p>
<blockquote>
<p>combineAll won't emit unless the combined Observables emit at least
one value, but you could check to ensure the collection you're
combining is empty or not, and either combine or emit an empty Array:</p>
<pre class=""lang-js prettyprint-override""><code> var arrayOfStreamsStream = Rx.Observable
    .of(
        [], [
            Rx.Observable.of('blah-1'), // component state.
            Rx.Observable.of('blah-2'),
            Rx.Observable.of('blah-3')
        ], [], [
            Rx.Observable.of('foo-1'),
            Rx.Observable.of('qux-2')
        ]
    )
    .switchMap(function onMap(coll) {
        return coll.length === 0 ?
            Observable.of(coll) :
            Observable.combineLatest(...coll);
    })
    .subscribe(function onSubscribe(data) {
        console.log('onSubscribe START')
        console.dir(data)
        console.log('onSubscribe END')
    }) 
</code></pre>
</blockquote>
","2083576","","542251","","2021-10-15 15:25:27","2021-10-15 15:25:27","","","","0","","","","CC BY-SA 4.0"
"39279816","1","39281316","","2016-09-01 19:50:30","","1","952","<p>I try to implement drag and drop in RxJS. I have a DOM node with id <code>draggable</code> that can be dragged around. By using the standard procedure drag and drop works as expected.</p>

<p>But I tried to enhance drag and drop and this is where things get complicated. I attempt to change the background color of the element once dragging starts and change it back once it's dropped. </p>

<p>In my approach I'm using <code>switchMap</code> to map the results of the mouse move event into my observable which is triggered by the mouse down event. But since I use the mouse up event to complete the <code>switchMap</code>ed observable (<code>mm$</code> in the example below) I have no chance to get notified about the completion event of the inner observable except when I'm subscribing to it within the <code>switchMap</code> operator.</p>

<p>I know that subscribing within an operator is far from good practice and might lead to memory leaks. But what else can I do? How can this be done better?</p>

<p>Fiddle: <a href=""https://jsfiddle.net/djwfyxs5/"" rel=""nofollow"">https://jsfiddle.net/djwfyxs5/</a></p>

<pre class=""lang-js prettyprint-override""><code>const target = document.getElementById('draggable');
const mouseup$ = Observable.fromEvent(document, 'mouseup');
const mousedown$ = Observable.fromEvent(target, 'mousedown');
const mousemove$ = Observable.fromEvent(document, 'mousemove');

const move$ = mousedown$
  .switchMap(md =&gt; {
    md.target.style.backgroundColor = 'yellow';
    const {offsetX: startX, offsetY: startY} = md;
    const mm$ = mousemove$
      .map(mm =&gt; {
        mm.preventDefault();
        return {
          left: mm.clientX - startX,
          top: mm.clientY - startY
        };
      })
      .takeUntil(mouseup$);

    // Can the next line be avoided? 
    mm$.subscribe(null, null, () =&gt; {
      md.target.style.backgroundColor = 'purple';
    });

    return mm$;
  });

move$.subscribe((pos) =&gt; {
    target.style.top = pos.top + 'px';
    target.style.left = pos.left + 'px';
});
</code></pre>
","434227","","","","","2016-09-08 17:43:47","RxJS: Advanced Drag and Drop - Prevent subscription in operator","<drag-and-drop><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"39281316","2","","39279816","2016-09-01 21:42:13","","2","","<p>I answered a similar question here: <a href=""https://stackoverflow.com/questions/35950593/rxjs-drag-and-drop-example-add-mousedragstart/35964479#35964479"">RxJs: Drag and Drop example : add mousedragstart</a></p>

<p>It should be reasonably straightforward to adapt the answer to your purpose, as the streams still contain the events which expose the elements for which they were raised.</p>
","1855065","","-1","","2017-05-23 12:22:53","2016-09-01 21:42:13","","","","1","","","","CC BY-SA 3.0"
"39283782","1","39283993","","2016-09-02 03:15:23","","3","113","<p>I have two independent Observables that I'd like to couple in such a manner that every time the first emits a value, it causes the second to emit a value.</p>

<p>In this scenario, the first Observable is an infinite sequence based on an async Node.js-style method with variable callback timing (no usage of <code>delay</code> or <code>timer</code> allowed).  The second Observable is a finite sequence of independent values.</p>

<p>Perhaps a diagram can express what I'm looking for:</p>

<pre><code>I: ---A--D-----Q-G---B-&gt; (I is infinite)
F: -3512-|-&gt;             (F is finite)
O: ---3--5-----1-2-|-&gt;   (O is finite)
</code></pre>

<p>The output sequence (O) is finite with the values from (F), based on the timing of (I).</p>

<p>Here's (I):</p>

<pre><code>// I'm stuck with this, it cannot change...
function asyncOperation(callback) {
  const delayMsec = Math.floor(Math.random() * 1000);
  timers.setTimeout(callback, delayMsec, null, delayMsec);
}

const callbackObservable = Rx.Observable.bindNodeCallback(asyncOperation);

const infiniteCallbackSequence = Rx.Observable
  .defer(callbackObservable)
  .expand(x =&gt; callbackObservable());
</code></pre>

<p>And for simplicity, here's (F):</p>

<pre><code>const finiteSequence = Rx.Observable.from([3, 5, 1, 2]);
</code></pre>

<p>(This build upon a previous Question of mine <a href=""https://stackoverflow.com/questions/39262208/convert-infinite-async-callback-sequence-to-observable-sequence"">here</a>.)</p>

<p>I don't understand things well enough to make <code>combine*</code>, <code>merge*</code>, or <code>*map</code> work to generate what I want -- assuming they can.  It seems like I want <code>take(1)</code> on (I) each time (O) emits.</p>

<p>How do I get the behavior described?</p>
","4947310","","-1","","2017-05-23 12:32:52","2016-09-02 03:44:01","Chain Observable emissions?","<javascript><rxjs><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"39283993","2","","39283782","2016-09-02 03:44:01","","1","","<p>Would <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/zip.md"" rel=""nofollow""><code>Observable.zip</code></a> work for your usecase?</p>

<pre><code>const Rx = require('rxjs');
const timers = require('timers');

const finite = Rx.Observable.from([3, 5, 1, 2]);

// I'm stuck with this, it cannot change...
function asyncOperation(callback) {
  const delayMsec = Math.floor(Math.random() * 1000);
  timers.setTimeout(callback, delayMsec, null, delayMsec);
}

const callbackObservable = Rx.Observable.bindNodeCallback(asyncOperation);

const infiniteCallbackSequence = Rx
  .Observable
  .defer(callbackObservable)
  .expand(x =&gt; callbackObservable());

const combined = Rx.Observable.zip(
  finite,
  infiniteCallbackSequence
).forEach(v =&gt; console.log(v));
</code></pre>

<p>running on node 6:</p>

<pre><code>â $ node test.js
[ 3, 816 ]
[ 5, 297 ]
[ 1, 95 ]
[ 2, 677 ]
â $
</code></pre>
","1718488","","","","","2016-09-02 03:44:01","","","","0","","","","CC BY-SA 3.0"
"39290306","1","","","2016-09-02 10:34:53","","4","4688","<p>In rxjs5 doc, it mentions 'To reduce polymorphism and get better performance out of operators, some operators have been split into more than one operator'. What does it actually mean and how to use the mergeMapTo operator? </p>
","3906979","","","","","2016-09-02 13:52:38","What is the difference between mergeMap and mergeMapTo?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"39296948","1","39299549","","2016-09-02 16:24:02","","3","15748","<p>I have a component that asks my service for an Observable object (that is, the underlying http.get returns one single object).</p>
<p>The object (an observable) is used in conjunction with an async pipe in my template.
Unfortunately, I get an error:</p>
<blockquote>
<p>Cannot read property 'lastname' of null</p>
</blockquote>
<p>I have been breaking my head on this one. A similar type of code works correctly on a list of objects (in conjunction with *ngFor).</p>
<pre class=""lang-html prettyprint-override""><code>&lt;li&gt;{{(person | async)?.lastname}}&lt;/li&gt;
</code></pre>
<p>Method in my service:</p>
<pre class=""lang-js prettyprint-override""><code>getPerson(id: string): Observable&lt;Person&gt; {        
   let url = this.personsUrl + &quot;/&quot; + id;
   return this.http.get(url, {headers: new Headers({'Accept':'application/json'})})
              .map(r =&gt; r.json())
              .catch(this.handleError); //error handler
}
</code></pre>
<p>In my component:</p>
<pre class=""lang-js prettyprint-override""><code>//... imports omitted

@Component({
  moduleId: module.id,
  selector: 'app-details-person',
  templateUrl: 'details-person.component.html',
  styleUrls: ['details-person.component.css'],
})
export class DetailsPersonComponent implements OnInit, OnDestroy 
{
   person: Observable&lt;Person&gt;;
   sub: Subscription;

   constructor(private personService: PersonService, private route: ActivatedRoute) {
   }

  ngOnInit() {
     this.sub = this.route.params.subscribe(params =&gt; {
                 let persId = params['id'];
                 this.person = this.personService.getPerson(persId);
                });
  }

  ngOnDestroy(): void {
     this.sub.unsubscribe();
  }
}

</code></pre>
<p>Apparently the observable is/returns a null object value in the pipe.
I have checked if I am really getting a nonempty Observable from my service and I can confirm that there exists an (underlying) object returned from my service.</p>
<p>Of course, I could subscribe to the observable in my component after having retrieved the Observable from the service, but I would really like to use the async construct.</p>
<p>Btw, another question: Is there already a pattern on how to handle errors that occur in the async pipe? (A downside of using async pipes.... errors are delayed until rendering time of the view.</p>
","2120188","","390161","","2021-07-15 08:30:12","2021-07-15 08:30:12","Observable with Async Pipe in template is not working for single value","<angular><rxjs><rxjs5>","4","2","1","","","CC BY-SA 4.0"
"39299549","2","","39296948","2016-09-02 19:31:45","","4","","<p>The first time your view renders, <code>person</code> is not defined, since that component property only gets created asynchronously, when the route params subscription fires.  You need to initially create an empty observable.  Instead of</p>

<pre><code>person:Observable&lt;Person&gt;;
</code></pre>

<p>try</p>

<pre><code>person = Observable.of&lt;Person&gt;(Person());  // or however you create an empty person object
    // the empty object probably needs a lastname field set to '' or null
</code></pre>

<hr>

<p>I normally handle errors in a service by </p>

<ol>
<li>return an empty observable</li>
<li>report the error to some app-wide (singleton) service.  Some (singleton) component then displays those errors (if appropriate) somewhere on the page.</li>
</ol>
","215945","","","","","2016-09-02 19:31:45","","","","3","","","","CC BY-SA 3.0"
"39319673","1","39322747","","2016-09-04 17:34:21","","4","2183","<p>I am using angular2fire. I am querying and trying to get all the tours from a city. </p>

<pre><code>getAllTours(cityId) {
    return this.af.database.list(`/cities/${cityId}/tours`)
        .map((tours): any =&gt; {
            tours.map((tour: any) =&gt; {
                tour.tour  = this.af.database.object(`/tours/${tour.$key}/tours`)
            });
            return tours;
        })
}
</code></pre>

<p>If i console.log the tour object, i get a array of ""FirebaseObjectObservable"". </p>

<p>I have to loop through all the FirebaseObjectObservable, to get the actual data. </p>

<p>I was wondering if i could forkJoin all the observables and get the output as an array with a single subscribe function. </p>

<p>Is this a right approach. </p>

<p>I know i can do an async pipe on all the observers array, but i would like to get the data inside the controller and then do some processing before its shown in the view, so async pipe is really not the best solution for me.  </p>
","1019460","","209103","","2016-09-04 22:07:55","2016-09-06 03:22:36","Fork join two firebase observables","<angular><firebase><firebase-realtime-database><observable><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"39322747","2","","39319673","2016-09-05 00:59:35","","8","","<p>Yes, <code>forkJoin</code> could be used to get the data for the inner observables:</p>

<pre><code>getAllTours (cityId) {
    return this.af.database
        .list(`/cities/${cityId}/tours`)
        .mergeMap((tours) =&gt; {

            // The array of tours is going to be mapped to an observable,
            // so mergeMap is used.

            return Observable.forkJoin(

                // Map the tours to the array of observables that are to
                // be joined. Note that forkJoin requires the observables
                // to complete, so first is used.

                tours.map((tour) =&gt; this.af.database
                    .object(`/tours/${tour.$key}/tours`)
                    .first()
                ),

                // Use forkJoin's results selector to match up the result
                // values with the tours.

                (...values) =&gt; {
                    tours.forEach((tour, index) =&gt; { tour.tour = values[index]; });
                    return tours;
                }
            );
        });
}
</code></pre>

<p>Whether or not using <code>forkJoin</code> is the right approach will depend upon your requirements.</p>

<p>With the above code, the observable returned by <code>getAllTours</code> will not emit a value until all of the inner observables have completed - that is, until each of the city's tours have been looked up. That could affect <em>perceived</em> performance - if there is information in <code>/cities/${cityId}/tours</code> that could be shown before the information in <code>/tours/${tour.$key}/tours</code> is looked up, you won't be able to show it. Similarly, you won't be able to show the city's tours as the results arrive.</p>

<p>Using <code>forkJoin</code> makes dealing with the implementation simpler, but it might make the UI feel slower. (However, piecemeal updates to the UI might be something that you do not want.)</p>

<p>Note that if you do need to do some processing on each of the city's tours before it is shown in the view, you might be able to perform said processing on the observables in the code in your question. For example, using your <code>getAllTours</code> function:</p>

<pre><code>observable = getAllTours(someCityId);
observable.map((tours) =&gt; {

    tours.forEach((tour) =&gt; {

        // With your function, tour.tour is an observable, so map
        // could be used to process the values.

        tour.tour = tour.tour.map((value) =&gt; {

            // Do some processing here with the value.
        })

        // And, if you are not interested in dynamic updates, you could
        // call first.

        .first();
    });
    return tours;
});
</code></pre>

<p>You could then use the <code>async</code> pipe in the template and it would receive your processed tours.</p>
","6680611","","6680611","","2016-09-06 03:22:36","2016-09-06 03:22:36","","","","5","","","","CC BY-SA 3.0"
"39334090","1","39335364","","2016-09-05 15:55:28","","1","62","<pre><code>Observable.interval(1000)
  .flatMap(() =&gt; this.http.get('abc'))
  .subscribe(
      // x =&gt; console.log('Next: ' + x) // Don't terminite without this.
  );
</code></pre>

<p>This http request gives an error due to 404. But the stream keeps polling.</p>

<p>However, as soon as I uncomment the commented line in <code>subscribe</code>, it terminates on the first error.</p>

<p>See example here</p>

<p><a href=""http://plnkr.co/edit/bQyBvboFJCPyZUEFjraX?p=preview"" rel=""nofollow"">http://plnkr.co/edit/bQyBvboFJCPyZUEFjraX?p=preview</a></p>

<p>Why is that?</p>

<h3>Update</h3>

<p>Seems a bug, reported <a href=""https://github.com/ReactiveX/rxjs/issues/1921#issuecomment-246131406"" rel=""nofollow"">here</a></p>
","691867","","691867","","2016-09-11 00:15:31","2016-09-11 00:15:31","Why doesn't my observable terminate at error?","<angular><rxjs><observable><rxjs5><reactivex>","1","0","","","","CC BY-SA 3.0"
"39335364","2","","39334090","2016-09-05 17:34:16","","1","","<p>I'm not 100% sure I'm correct but by checking the source I think it happens like this:</p>

<ol>
<li><p>Calling <code>.subscribe()</code> without any argument leads to a <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts#L90"" rel=""nofollow"">call to <code>toSubscribe()</code> in Observable.ts#L90</a>.</p></li>
<li><p>This call returns an empty instance of <code>Subscriber</code> class <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/util/toSubscriber.ts#L21"" rel=""nofollow"">in toSubscriber.ts#L21 <code>return new Subscriber()</code></a></p></li>
<li><p>Calling <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L62"" rel=""nofollow"">Subscribe() without any parameters</a> creates an <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observer.ts"" rel=""nofollow""><code>empty</code> Observer</a> which does literally nothing.</p></li>
<li><p>I think this is where the problem happens. When you subscribe to the Observable resulting from <code>flatMap</code> (btw, it's been <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#operators-renamed-or-removed"" rel=""nofollow"">renamed to <code>mergeMap</code></a>) it's supposed to unsubscribe from the Observable <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/mergeMap.ts#L120"" rel=""nofollow"">on error in mergeMap.ts#L12</a> but this never happens because the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observer.ts#L34"" rel=""nofollow""><code>empty</code> Observer does nothing on Observer.ts#L34</a>.</p></li>
</ol>

<p>So the Observable keeps emitting values because the Observer never unsubscribes. I'm not sure this is what really happens but if it does I don't know whether it's a bug or a feature.</p>
","310726","","","","","2016-09-05 17:34:16","","","","0","","","","CC BY-SA 3.0"
"39356336","1","39358649","","2016-09-06 19:18:19","","3","3410","<p>I am new to ReactiveExtensions and I do not get to work s.th. that I think should be a very common usecase. I want to receive a new value only after a specific period of time has passed without a new next value. In the bottom example this period of time is 1 second. The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md"" rel=""nofollow noreferrer"">debounce-operator</a> seems to do exactly what I want. I do not get it to work though. </p>

<pre><code>const observable$ = new Rx.Observable(observer =&gt; {

 observer.next('start');

 setTimeout(() =&gt; {
  observer.next(1);
 }, 100);
 setTimeout(() =&gt; {
  observer.next(2);
 }, 200);
 setTimeout(() =&gt; {
  observer.next(3);
 }, 300);
 setTimeout(() =&gt; {
  observer.next(4);
 }, 400);

 setTimeout(() =&gt; {
  observer.next('end');
 }, 1500);
});

let sub = observable$
      .debounce(1000) //debounce(1000, null) does not work either
      .take(100)
      .subscribe(data =&gt; {
          console.log(data);
         }, 
         err =&gt; console.log(err.message), 
         complete =&gt; console.log('Observable completed')
       )
</code></pre>

<p>What I want to get is a console-output of only:</p>

<pre><code>""start""
""end""
</code></pre>

<p>In my IDE (Webstorm) the above code does not even compile although the documentation states that the second argument is optional. On <a href=""http://jsbin.com/vubafod/edit?js,console"" rel=""nofollow noreferrer"">jsbin.com</a> i get the following error: ""this.durationSelector.call is not a function"" (I admit, I dont know yet how to apply schedulers in rxjs). In the documentation they use only a number, too. Most examples of debounce i found on google use only a number, i.e. this <a href=""https://stackoverflow.com/questions/30840247/what-does-rxjs-observable-debounce-do"">example on Stackoverflow</a>. Why doesn't this work in my case?</p>

<p>Thanks for your help!</p>

<p>PS: I use rxjs 5.0.0-beta.6.</p>

<p>EDIT: With the help of the answers here I did find the actual soltion I wanted:</p>

<pre><code>const observable$ = new Rx.Observable(observer =&gt; {

observer.next('start');

 setTimeout(() =&gt; {
  observer.next(1);
 }, 1100); //&lt;-- If you change 1100 to i.e. 900 you just get ""end"" in the output, because there is no 1s periode during which no new value arrives. 
 setTimeout(() =&gt; {
  observer.next(2);
 }, 1200);
 setTimeout(() =&gt; {
  observer.next(3);
 }, 1300);
 setTimeout(() =&gt; {
  observer.next(4);
 }, 1400);
 setTimeout(() =&gt; {
  observer.next(5);
 }, 1500);

 setTimeout(() =&gt; {
  observer.next('end');
 }, 1501);


});

let sub = observable$
      .debounceTime(1000)
      .take(10)
      .subscribe(data =&gt; {
         console.log(data);
       }, 
       err =&gt; console.log(err.message), 
       complete =&gt; console.log('Observable completed')
);
</code></pre>
","5580311","","-1","","2017-05-23 12:00:56","2016-09-07 14:11:52","RxJs: New value only after a period of time has passed","<javascript><rxjs><rxjs5><reactive-extensions-js>","2","0","1","","","CC BY-SA 3.0"
"39358649","2","","39356336","2016-09-06 22:16:18","","2","","<p>You can do something like this</p>

<pre><code>const observable$ = new Rx.Observable(observer =&gt; {

    observer.next('start');

    setTimeout(() =&gt; {
        observer.next(1);
    }, 100);
    setTimeout(() =&gt; {
        observer.next(2);
    }, 200);
    setTimeout(() =&gt; {
        observer.next(3);
    }, 300);
    setTimeout(() =&gt; {
        observer.next(4);
    }, 400);

    setTimeout(() =&gt; {
        observer.next('end');
    }, 1500);


});

let sub = observable$
    .map(function(x, i) {
        return {
            val: x,
            index: i
        };
    })
    .debounce(function(obj) {
        let interval = obj.index === 0 ? 0 : 1500;
        return Rx.Observable.timer(interval);
    })
    .take(100)
    .subscribe(data =&gt; {
            console.log(data.val);
        },
        err =&gt; console.log(err.message),
        complete =&gt; console.log('Observable completed')
    )
</code></pre>

<p>The key here is to use <code>map</code> function to get the index of the element and then decide the waiting interval.</p>
","386188","","","","","2016-09-06 22:16:18","","","","1","","","","CC BY-SA 3.0"
"39373619","1","","","2016-09-07 15:13:48","","1","594","<p>I have a List object, like this</p>

<pre><code>class List {
    private urls: string[] = [];

    public getNames(): Observable&lt;string[]&gt; {
       // fetch all `this.urls` and extract the names
    }

    public addUrl(url: string) {
       this.urls.push(url);
    }

    public hash(): string {
       // generate a hash out of `this.urls`
    }
}
</code></pre>

<p>It basically has some urls, and can provide names found on these urls</p>

<p>Now i need a component that displays these names:</p>

<pre><code>@Component({
    selector: 'lister',
    template: '&lt;p *ngFor=""let name of names|async""&gt;{{ name }}&lt;/p&gt;'
})
class Lister implements OnChanges {

     @Input() list: List;

     private names: Observable&lt;string[]&gt;;

     ngOnChanges() {
         this.names = this.list.getNames();
     }
}
</code></pre>

<p>So far so good, it works if i use it like this</p>

<pre><code> &lt;lister [list]=""somelist""&gt;&lt;/lister&gt;
</code></pre>

<p>but it doesnt refresh when <code>somelist.addUrl(...)</code> is called, due to the fact that it does not really change anything.</p>

<p>A workaround is to introduce something that changes, like this:</p>

<pre><code>class Lister implements OnChanges {
    // ...
    @Input() hash: string;
}
</code></pre>

<p>and use the Lister accordingly:</p>

<pre><code> &lt;lister [list]=""somelist"" [hash]=""somelist.hash()""&gt;&lt;/lister&gt;
</code></pre>

<p>but this seem to make it unneccessary complex for the caller.</p>

<p>I'd rather would somehome make the Lister itself ""listen"" to it's lists changes.</p>

<p>Is there a way to achieve this?</p>
","214531","","","","","2016-09-08 13:30:11","Extend a components change detection in Angular2","<angular><rxjs5><angular2-changedetection>","1","0","","","","CC BY-SA 3.0"
"39389537","1","39398046","","2016-09-08 11:18:20","","0","28","<p>I wonder why when subscribed to this Observable after a delay of 3200s, the observer will take the first values (from 0 to 2) which he normally would miss and just start from the value 3 :</p>

<pre><code>const interval$ = Rx.Observable.interval(1000);


setTimeout(() =&gt; {
    interval$.subscribe({
        next : item =&gt; console.log(""one.next : "" + item),
        error : error =&gt; console.log(""one.error : "" + error),
        complete : () =&gt; console.log(""one.complete"")
    });
}, 3200);
</code></pre>
","1705922","","","","","2016-09-08 18:39:07","Why the observer can see values generated by the Observable before it was subscribed to it","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"39398046","2","","39389537","2016-09-08 18:39:07","","1","","<p>Observables are cold by default. This means that they are lazy and just become active when an Observer subscribes to them.</p>

<p>What you want is a hot observable. You can make a cold observable hot by calling <code>publish()</code> on it and call the <code>connect()</code> method on the hot observable. It then starts to emit values regardless of any observers. Also it shares the values between the observers as it can be seen in <a href=""https://jsfiddle.net/khkhz6o3/"" rel=""nofollow"">this fiddle</a>.</p>

<p>See also <a href=""https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339"" rel=""nofollow"">this medium post by Ben Lesh</a> that explains the differences between hot and cold observables.</p>

<p>Full code:</p>

<pre class=""lang-js prettyprint-override""><code>const interval$ = Rx.Observable.interval(100);
const hotInterval$ = interval$.publish();
hotInterval$.connect();

setTimeout(() =&gt; {
    hotInterval$
    .take(5) // stop after five values for debugging purposes
    .subscribe({
        next : item =&gt; console.log(""one.next : "" + item),
        error : error =&gt; console.log(""one.error : "" + error),
        complete : () =&gt; console.log(""one.complete"")
    })
}, 320);

setTimeout(() =&gt; {
    hotInterval$
    .take(5) // stop after five values for debugging purposes
    .subscribe({
        next : item =&gt; console.log(""two.next : "" + item),
        error : error =&gt; console.log(""two.error : "" + error),
        complete : () =&gt; console.log(""two.complete"")
    })
}, 450);
</code></pre>
","434227","","","","","2016-09-08 18:39:07","","","","0","","","","CC BY-SA 3.0"
"39463391","1","","","2016-09-13 06:20:48","","2","249","<p>What i'm trying to do is to get numbers of keyboard events if time between these events were less than provided.
Maybe that's not correct approach so that's why I'm still in the same place. </p>

<p>So first I made simple stream with filter to catch every events that interest me. Next I made second stream and grouped events into pairs where i can measure time stamps. It seems that it's working pretty good but only with even numbers of events - so after this period of time i need to check if something is in a buffer and if it's there i should add it to my string.</p>

<p>Code :</p>

<pre><code>const timeToWait : number = 500;
const keyDigitsUp$ = Observable.fromEvent(document, ""keyup"")
  .filter((event:any) =&gt; {return ((event.keyCode&gt;=48 &amp;&amp; event.keyCode &lt;=57) ||
(event.keyCode&gt;=96 &amp;&amp; event.keyCode &lt;=106))});

let bufferedEvents = Observable.from(keyDigitsUp$).bufferCount(2);
let numbers : string = """";

bufferedEvents.subscribe((eventArray) =&gt; {
    if (eventArray[1].timeStamp - eventArray[0].timeStamp &lt;= timeToWait)
    {
        numbers+=eventArray[0].key + eventArray[1].key;
    }
    else
    {
        numbers="""";
    }
});
</code></pre>

<p>Is there any way to make this concept works ? Or maybe there is much better approach which i'm missing. I also made other concepts but they were producing similar results. I can of course make it work in non-reactive way and subscribe to main stream - save last event if exist and than compare it with next and so on, but since i'm trying to learn reactive programming i would like to make it as much reactive as i can.</p>
","1719156","","1719156","","2016-09-15 05:26:50","2016-10-21 21:47:41","RxJS - how to emit buffer manually / view elements in buffer","<javascript><reactive-programming><rxjs5>","1","2","","","","CC BY-SA 3.0"
"39464562","2","","35980457","2016-09-13 07:36:40","","2","","<p>For future readers - 
<code>.timestamp()</code> has been re-implemented in RxJS 5.0 (in beta.4 (2016-03-29)).</p>

<p>Changelog at: <a href=""https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md"" rel=""nofollow"">https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md</a></p>
","6750051","","","","","2016-09-13 07:36:40","","","","0","","","","CC BY-SA 3.0"
"39465733","1","39466239","","2016-09-13 08:44:06","","2","2259","<p>When an HTTP request fails, I'd like to retry twice 1 second apart. If it fails again the third time, I'd like to forward that error to the Observers. I'm having trouble with that last part.</p>

<p>HTTP request from <strong>DataService.get()</strong></p>

<pre><code>return this.http.get(url,options)
    .retryWhen(errors =&gt; errors.delay(1000).take(2))
    .catch((res)=&gt;this.handleError(res));
</code></pre>

<p><strong>Subscription</strong></p>

<pre><code>this.dataSvc.get('/path').subscribe(
    res =&gt; console.log(res),
    err =&gt; console.error(err),
    () =&gt; console.log('Complete')
);
</code></pre>

<p>My server is setup to always return an error (status <code>400 Bad request</code>).  </p>

<ul>
<li><p>I'd like the application to make a 2nd request, make a 3rd request, then throw the error to be caught by <code>this.handleError()</code></p></li>
<li><p>What actually happens: application  makes a 2nd request, makes a 3rd, then Observable completes without error (""<em>Complete</em>"" printed to console)</p></li>
</ul>

<p><code>Angular 2 rc.6</code>, <code>RxJS 5 beta 11</code>, <code>Typescript 2.0.2</code></p>
","3977061","","3977061","","2016-09-13 09:27:08","2016-09-13 09:31:23","RxJS 5 with Angular 2: Retry failed Observable but then forward error","<angular><typescript><observable><rxjs5>","1","2","","","","CC BY-SA 3.0"
"39466239","2","","39465733","2016-09-13 09:10:50","","5","","<p>I used <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/scan.md"" rel=""noreferrer"">the <code>scan</code> operator</a>:</p>

<pre><code>return this.http.get(url,options)
    .retryWhen(errors =&gt; errors.delay(1000).scan((acc,source,index)=&gt;{
        if(index) throw source;
    }))
    .catch((res)=&gt;this.handleError(res));
</code></pre>

<p>The parameters of <code>scan()</code>:</p>

<ul>
<li><code>acc</code>: an accumulator (think <code>Array.reduce()</code>). If you modify and return it, the new value will be provided as the <code>acc</code> parameter in the next execution</li>
<li><code>source</code>: the value (or exception) emitted by the previous operation (<code>delay()</code>, which itself forwards it from <code>errors</code>)</li>
<li><code>index</code>: Index of the currently emitted value (zero-based)</li>
</ul>

<p>This makes 3 HTTP requests (Don't know why; I would have expected 2). On the 3rd failure, it throws <code>source</code> -- the error emitted -- to be caught by <code>handleError()</code></p>
","3977061","","3977061","","2016-09-13 09:31:23","2016-09-13 09:31:23","","","","1","","","","CC BY-SA 3.0"
"39472569","1","39479639","","2016-09-13 14:30:28","","0","99","<p>I'm trying to create an observable facebook jsdk, so I have a method, with <code>.create()</code>d observable that looks for example like this</p>

<pre><code>getLoginStatus$() {
  return Observable.create((observer: Observer&lt;FBResponseObject&gt;) =&gt; {
    try {
      // this._fb is window.FB
      this._fb.getLoginStatus((resp: FBResponseObject) =&gt; {
        if (resp.error) {
          observer.error(resp.error);
        } else {
          observer.next(resp);
          observer.complete();
        }
      }, force);

    } catch (error) {
      observer.error(error);
    }

    return function () {};
  });
}
</code></pre>

<p>the problem is, that since facebook sdk is being loaded asynchronously, it might still not be available at the time I subscribe to this method. So I have a <code>Subject</code> called <code>fbSdkReady$</code> I <code>next()</code> to <code>true</code> once it becomes available. Now the question is how to connect these, so when I subscribe to <code>getLoginStatus$</code> it first waits for <code>fbSdkReady$</code> to become ready and only then creates the observable.</p>

<p>I tried using <code>delayWhen(() =&gt; fbSdkReady$.filter(r =&gt; !!r)</code>, which works fine for waiting for <code>fbSdkReady$</code> to be ready, but the <code>Observable.create</code> is called immeditealy nevertheless and thus errors outs because <code>FB</code> is still not ready.</p>

<p>What can I do to defer creation of that observable?</p>
","301596","","","","","2016-09-13 22:00:37","rxjs5: defer creation of an observable until another observable emits certain value","<facebook-javascript-sdk><frp><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39479639","2","","39472569","2016-09-13 22:00:37","","1","","<p>You already have a <code>fbSdkReady$</code>. However if I understand you correctly it will only emit once the sdk is loaded once. This is a problem because if you subscribe to it later, you will have missed the load event and wont know if you need to wait longer or if it was already yielded. You should make the stream repeat the ready value once it is available. You can do this by calling <code>fbSdkReady$.cache(1)</code>, but since it is backed by a subject you could also replace it with a <code>new Rx.replaySubject(1)</code>.</p>

<p>Now we got that out of the way, you can just use the <code>fbSdkReady$</code> as the base for <code>getLoginStatus$()</code>.</p>

<pre><code>fbSdkReady$.switchMap(() =&gt; getLoginStatus$())
</code></pre>

<p>Notice I used <code>switchMap</code> because it clearly communicates there will only be once instance of <code>getLoginStatus$()</code> active at any time. But since your source only emit once, you can also use <code>mergeMap</code> or <code>flatMap</code>.</p>

<p>Ps. I do hope you also call <code>complete()</code> on the subject and not just <code>next()</code>. It is good practice to signal Observables that you are done with them.</p>
","402027","","","","","2016-09-13 22:00:37","","","","2","","","","CC BY-SA 3.0"
"39480348","1","39480800","","2016-09-13 23:19:17","","4","6370","<p>I've composed my Observable (from an HTTP request) to retry on failure. However, I would like to <em>not</em> retry if the server responded with <code>429 Too many requests</code> error.</p>

<p>The current implementation retries twice, 1 second apart, no matter what.</p>

<pre><code>return this.http.get(url,options)
    .retryWhen(errors =&gt; {
        return errors.delay(1000).take(2);
    })
    .catch((res)=&gt;this.handleError(res));
</code></pre>

<p><code>errors</code> is an Observable. How can I get the underlying <code>Response</code> object that caused the error? With it I can access the server's status code and only retry if it's not 429:</p>

<pre><code>return this.http.get(url,options)
    .retryWhen(errors =&gt; {
        if($code == 429) throw errors;
        else return errors.delay(1000).take(2);
    })
.catch((res)=&gt;this.handleError(res));
</code></pre>

<p>How can I get status code within <code>retryWhen</code>? </p>

<p><a href=""http://plnkr.co/edit/iz9N8LzYIghwqqrstNEN?p=preview"" rel=""nofollow""><strong>Live demo on Plunker</strong></a></p>

<p><code>Angular 2 rc.6</code>, <code>RxJS 5 Beta 11</code>, <code>Typescript 2.0.2</code></p>
","3977061","","3977061","","2016-09-14 00:13:12","2017-07-12 19:35:33","Angular 2 RxJS Observable: Retry except on 429 status","<angular><typescript><observable><rxjs5>","1","6","","","","CC BY-SA 3.0"
"39480800","2","","39480348","2016-09-14 00:26:06","","12","","<p>You can compose the handling of 429 errors into the <code>errors</code> observable that's passed to <code>retryWhen</code>. The errors that are emitted from the <code>errors</code> observable will contain a <code>status</code> property if they are errors that were received from the server.</p>

<p>If you don't want to retry when 429 errors occur and instead wish to throw an error you could do something like this:</p>

<pre><code>return this.http.get(url,options)
    .retryWhen((errors) =&gt; {
        return errors
            .mergeMap((error) =&gt; (error.status === 429) ? Observable.throw(error) : Observable.of(error))
            .delay(1000)
            .take(2);
    })
    .catch((res) =&gt; this.handleError(res));
</code></pre>

<p>If, instead, you wanted the HTTP observable to complete without emitting either an error or a response, you could simply filter 429 errors.</p>
","6680611","","2150711","","2017-07-12 19:35:33","2017-07-12 19:35:33","","","","2","","","","CC BY-SA 3.0"
"39490545","1","39531782","","2016-09-14 12:31:46","","3","2157","<p>I'm new to ReactiveX/RxJs and I'm wondering if my use-case is feasible smoothly with RxJs, preferably with a combination of built-in operators. Here's what I want to achieve:</p>

<p>I have an Angular2 application that communicates with a REST API. Different parts of the application need to access the same information at different times. To avoid hammering the servers by firing the same request over and over, I'd like to add client-side caching. The caching should happen in a service layer, where the network calls are actually made. This service layer then just hands out <code>Observable</code>s. The caching must be transparent to the rest of the application: it should only be aware of <code>Observable</code>s, not the caching.</p>

<p>So initially, a particular piece of information from the REST API should be retrieved only once per, let's say, 60 seconds, even if there's a dozen components requesting this information from the service within those 60 seconds. Each subscriber must be given the (single) last value from the Observable upon subscription.</p>

<p>Currently, I managed to achieve exactly that with an approach like this:</p>

<pre><code>public getInformation(): Observable&lt;Information&gt; {
  if (!this.information) {
    this.information = this.restService.get('/information/')
      .cache(1, 60000);
  }
  return this.information;
}
</code></pre>

<p>In this example, <code>restService.get(...)</code> performs the actual network call and returns an <code>Observable</code>, much like Angular's http Service.</p>

<p>The problem with this approach is refreshing the cache: While it makes sure the network call is executed exactly once, and that the cached value will no longer be pushed to new subscribers after 60 seconds, it doesn't re-execute the initial request after the cache expires. So subscriptions that occur after the 60sec cache will not be given any value from the <code>Observable</code>.</p>

<p>Would it be possible to re-execute the initial request if a new subscription happens after the cache timed out, and to re-cache the new value for 60sec again?</p>

<p>As a bonus: it would be even cooler if existing subscriptions (e.g. those who initiated the first network call) would get the refreshed value whose fetching had been initiated by the newer subscription, so that once the information is refreshed, it is immediately passed through the whole Observable-aware application.</p>
","737587","","","","","2016-09-17 12:08:41","Time-based cache for REST client using RxJs 5 in Angular2","<caching><angular><rxjs><rxjs5><reactivex>","2","0","1","","","CC BY-SA 3.0"
"39490738","1","39506519","","2016-09-14 12:42:33","","3","276","<p>After updating to Angular2 RC7 I get the folloing JavaScript error when running in the browser:</p>

<blockquote>
  <p>OuterSubscriber is not defined</p>
</blockquote>

<p>This only happens when I create a bundle using <code>rollup.js</code>. If I run the application with the JavaScript not bundled it works fine.</p>

<p>The error must somehow be related with <code>rxjs</code> since <code>OuterSubscriber</code> is part of it. I checked the bundle and could not find <code>OuterSubscriber</code> there. I suppose <code>rollup.js</code> thinks that it is not necessary and therefore does not include it.</p>

<p>Environment:</p>

<ul>
<li><code>angular, v2.0.0-rc.7</code></li>
<li><code>rxjs, v5.0.0-beta.12</code></li>
<li><code>systemjs, v0.19.27</code></li>
<li><code>gulp-rollup, v2.4.0</code></li>
<li><code>rollup-stream, v1.13.0</code></li>
</ul>

<p>In the <code>system.js</code> config I map the <code>umd</code> modules (e.g. <code>core.umd.js</code>) for <code>angular</code>. For <code>rxjs</code> I use a classical mapping as in this <a href=""https://gist.github.com/robwormald/29f3dcda1a06b955d83fccb2a94586eb"" rel=""nofollow"">example</a>.</p>

<p>Does anyone have an idea what I'm doing wrong here?</p>
","1474439","","1474439","","2016-09-15 05:58:40","2016-09-15 12:56:22","""OuterSubscriber is not defined"" when bundeling with rollup.js","<javascript><angular><rxjs5><rollupjs>","2","1","1","","","CC BY-SA 3.0"
"39506519","2","","39490738","2016-09-15 08:35:49","","0","","<p>Rollup 0.34.0 works with 2.0.0-rc.7 and verified Rollup 0.34.0 works with 2.0.0 also but I was able to replicate the issue with 0.35.0</p>
","2752996","","","","","2016-09-15 08:35:49","","","","1","","","","CC BY-SA 3.0"
"39512662","1","","","2016-09-15 13:43:03","","0","32","<p>I cannot figure out how can I solve the following problem.</p>

<p>There is an object type:</p>

<pre><code>Box { 
    Fruit[n]: {
      Kinds[n]: {  
        id: string;
        name: string;
      }
    }
}
</code></pre>

<p>I got the box of fuits from an API call as an Observable (Angular2) [Fruit[]] then I want to populate its ""navigation property"" with another API call what gives back an observable as well like:</p>

<pre><code>  Box.foreach(fruits =&gt;
       fruits.foreach(f =&gt; 
           f.kinds.foreach(k =&gt; 
                k.name = kindservice.getKindName(k.id) // &lt;- observer
    )))
</code></pre>

<p>How can I do it with RxJs?</p>

<p>I tried many ways, there are many mapper but I could not figure out yet.
I used the Observable.from(..) as well but there was no luck.</p>

<p>Thank you</p>
","1693057","","","","","2016-11-01 10:56:23","Population with embeded queries RxJs","<javascript><angular><rxjs><rxjs5><reactive-extensions-js>","1","0","","","","CC BY-SA 3.0"
"39531782","2","","39490545","2016-09-16 12:40:01","","2","","<p>I figured out a solution to achieve exactly what I was looking for. It might go against ReactiveX nomenclature and best practices, but technically, it does exactly what I want it to. That being said, if someone still finds a way to achieve the same with just built-in operators, I'll be happy to accept a better answer.</p>

<p>So basically since I need a way to re-trigger the network call upon subscription (no polling, no timer), I looked at how the <code>ReplaySubject</code> is implemented and even used it as my base class. I then created a callback-based class <code>RefreshingReplaySubject</code> (naming improvements welcome!). Here it is:</p>

<pre><code>export class RefreshingReplaySubject&lt;T&gt; extends ReplaySubject&lt;T&gt; {

  private providerCallback: () =&gt; Observable&lt;T&gt;;
  private lastProviderTrigger: number;
  private windowTime;

  constructor(providerCallback: () =&gt; Observable&lt;T&gt;, windowTime?: number) {
    // Cache exactly 1 item forever in the ReplaySubject
    super(1);
    this.windowTime = windowTime || 60000;
    this.lastProviderTrigger = 0;
    this.providerCallback = providerCallback;
  }

  protected _subscribe(subscriber: Subscriber&lt;T&gt;): Subscription {
    // Hook into the subscribe method to trigger refreshing
    this._triggerProviderIfRequired();
    return super._subscribe(subscriber);
  }

  protected _triggerProviderIfRequired() {
    let now = this._getNow();
    if ((now - this.lastProviderTrigger) &gt; this.windowTime) {
      // Data considered stale, provider triggering required...
      this.lastProviderTrigger = now;
      this.providerCallback().first().subscribe((t: T) =&gt; this.next(t));
    }
  }
}
</code></pre>

<p>And here is the resulting usage:</p>

<pre><code>public getInformation(): Observable&lt;Information&gt; {
  if (!this.information) {
    this.information = new RefreshingReplaySubject(
      () =&gt; this.restService.get('/information/'),
      60000
    );
  }
  return this.information;
}
</code></pre>
","737587","","","","","2016-09-16 12:40:01","","","","0","","","","CC BY-SA 3.0"
"39550466","1","","","2016-09-17 18:44:08","","2","804","<pre><code>import {Observable} from '@reactivex/rxjs'

// This is a fake API polling, this data is in reality coming from
// the server
const fakePoll$ = Observable.from([
  {
    status: 'initialized',
    data: {...},
  },
  {
    status: 'progress',
    data: {...},
  },
  {
    status: 'progress',
    data: {...},
  },
  {
    status: 'progress',
    data: {...},
  },
  {
    status: 'completed',
    data: {...},
  },
  ...
  {
    status: 'completed',
    data: {...},
  },
])

fakePoll$
  .takeWhile(x =&gt; x.status != 'completed')
  .subscribe(x =&gt; console.log(x))
</code></pre>

<p>This snippet returns all the progress and initialized statuses:</p>

<pre><code>initialized
progress
progress
progress
</code></pre>

<p>But I need to get the first completed also like a takeWhile but inclusive.</p>
","1227953","","1227953","","2016-09-18 09:22:01","2017-05-30 09:48:04","Rxjs: Poll data until predicate is met","<javascript><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"39552331","1","39556717","","2016-09-17 22:32:32","","1","1844","<p>I am trying to set my <code>$currentUser</code> after an API call, but I keep getting the error: </p>

<pre><code>[default] 
Type 'Observable&lt;{}&gt;' is not assignable to type 'Observable&lt;User&gt;'.
  Type '{}' is not assignable to type 'User'.
    Property 'username' is missing in type '{}'.
</code></pre>

<p>My component that's throwing the error looks like this:</p>

<pre><code>import {Component, state} from '@angular/core';
import { Observable } from ""rxjs"";

import { User } from '../../../../models/user';
import { Store } from '@ngrx/store';
import { AppState } from '../../../../reducers';
import {UserService} from ""../../../../services/user.service"";

@Component({
  selector: 'user-center',
  templateUrl: 'user-center.component.html',
  styleUrls: ['user-center.component.scss']
})
export class UserCenter {
  $currentUser: Observable&lt;User&gt;;
  userService: UserService;
  constructor(
    userService: UserService,
    public store: Store&lt;AppState&gt;
  ) {
    this.userService = userService;
    this.$currentUser = this.store.select('user');
  }

  ngOnInit() {
    this.userService.initialise();
  }
}
</code></pre>

<p>My Effect looks like this::</p>

<pre><code>import { Injectable } from '@angular/core';
import { Effect, StateUpdates, toPayload } from '@ngrx/effects';
import { Observable } from 'rxjs/Observable';

import { AppState } from '../reducers';
import { UserService } from '../services/user.service';
import { UserActions } from ""../actions/UserActions"";

@Injectable()
export class UserEffects {
  constructor(
    private updates$: StateUpdates&lt;AppState&gt;,
    private userService: UserService,
    private userActions: UserActions,
  ) {}


  @Effect() CurrentUser$ = this.updates$
    .whenAction('INIT_USER')
    .switchMap(() =&gt; this.userService.getUser()
      .map(user =&gt; this.userActions.setCurrentUser(user))
      .catch(() =&gt; Observable.of({ type: 'GET_USER_FAILED' })
      ));
}
</code></pre>
","2370927","","13762264","","2021-06-05 18:36:02","2021-06-05 18:36:02","Getting the error Type 'Observable<{}>' is not assignable to type 'Observable<User>'. when trying to use @ngrx/store's store.select()","<angular><typescript><rxjs><ngrx><rxjs5>","1","2","","","","CC BY-SA 3.0"
"39556717","2","","39552331","2016-09-18 10:36:34","","3","","<p>You should change your constructor and set dependency to Store as <code>public store: Store&lt;User&gt;</code>. Or do you really need it to be as <code>Store&lt;AppState&gt;</code>? The type should be set automatically using generics <a href=""https://github.com/ngrx/core/blob/master/src/operator/select.ts"" rel=""nofollow""><code>src/operator/select.ts</code></a>:</p>

<pre><code>constructor(
    userService: UserService,
    public store: Store&lt;User&gt;
) {
    this.userService = userService;
    this.$currentUser = this.store.select('user');
}
</code></pre>

<p>Alternatively, the error is thrown because you define <code>$currentUser</code> as:</p>

<pre><code>$currentUser: Observable&lt;User&gt;;
</code></pre>

<p>so you can use <a href=""https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#416-type-assertions"" rel=""nofollow"">type assertion in TypeScript</a> when assigning the data to <code>this.$currentUser</code>:</p>

<pre><code>this.$currentUser = &lt;Observable&lt;User&gt;&gt;this.store.select('user');
</code></pre>
","310726","","310726","","2016-09-18 10:43:43","2016-09-18 10:43:43","","","","0","","","","CC BY-SA 3.0"
"39566268","1","","","2016-09-19 06:00:34","","2","1464","<p>I have data classes</p>

<pre><code>class Processor {
    frequency: number;
    error: booelan;
}

class Computer {
    name: string;
    processor: Processor[];
}
</code></pre>

<p>I faetch it from backend using json:</p>

<pre><code>{
    ""name"": ""Alfa Beta"",
    ""processors"": [
        {
            ""url"": ""ASD3-455R-FRTT-ASEW""
        },
        {
            ""url"": ""AQW2-DFFFR-367K-MMKE""
        }
    ]
}
</code></pre>

<p>and single processor</p>

<pre><code>{
    ""url"": ""ASD3-455R-FRTT-ASEW"",
    ""frequency"": 2200,
    working: true
}
</code></pre>

<p>I need to return stream of <code>Computer</code> as I'd like to ask for processors status each minute. For single returned instance of <code>Computer</code> I need to send 3 http requests with dependencies on each other. Of course I'll use service class for this. The only trouble for me is how to create this stream, ie. <code>this.http.get(this.mainUrl)</code>?</p>

<p>I've found <a href=""https://jaxenter.com/reactive-programming-http-and-angular-2-124560.html"" rel=""nofollow"">Reactive programming, HTTP and Angular 2</a> and chapter <em>Executing a request with the result of a previous one</em> but it didn't help.</p>
","905865","","310726","","2016-11-14 08:26:31","2016-11-14 08:26:31","Angular 2 + rxjs - how return stream of objects fetched with several subsequent http requests","<angular><rxjs><angular2-services><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39571944","1","39572228","","2016-09-19 11:20:01","","2","1989","<p><strong>Below are my component file and service file.</strong> What I want to do is that the after verification() service method on its success callback i.e., inside subscribe I want call another service method i.e., signup(). But, its not working showing me following error:</p>

<p><a href=""https://i.stack.imgur.com/ORmkB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ORmkB.png"" alt=""enter image description here""></a></p>

<p>Previously in <strong>angular1</strong> if i do this it would work but not here:</p>

<pre><code>sampleService.meth1().success(function(){
            //statement1...
            sampleService.meth1().success(function(data){
            //statement2...
        }).error(function(){})
    }).error(function(){});
})
</code></pre>

<p><strong>Signup.component.ts</strong>    </p>

<pre><code>import { Component, Input } from '@angular/core';
    import { Router } from '@angular/router';
    import {User} from '../shared/model/user';
    import {SignupService} from './signup.service';
    import 'rxjs/add/operator/map';
    import 'rxjs/add/operator/catch';
    import 'rxjs/add/operator/debounceTime';
    import 'rxjs/add/operator/distinctUntilChanged';
    import 'rxjs/add/operator/switchMap';
    import 'rxjs/add/operator/toPromise';

    @Component({
        moduleId: module.id,
        selector: 'ym-signup',
        templateUrl: 'signup.component.html',
        styleUrls: ['signup.component.css'],
        providers: [SignupService]
    })

    export class SignupComponent {

        @Input()
        user = {};

        constructor(private router:Router, private signupService:SignupService) {
        }

        signup(selectedUser:User) {
            this.signupService.verification(selectedUser)
                .subscribe(data =&gt; {
                        swal({
                            title: 'Verify token sent on your Email.',
                            input: 'password',
                            inputAttributes: {
                                'maxlength': 10,
                                'autocapitalize': 'off',
                                'autocorrect': 'off'
                            }
                        }).then(function (password) {

                            this.signupService.signup(password)
                                .subscribe(data =&gt; {

                                        localStorage.setItem('user', JSON.stringify(data));
                                        this.router.navigate(['dashboard']);
                                    },
                                    error =&gt; alert(error));
                        })
                    },
                    error =&gt; alert(error));
        }


        goBack() {
            this.router.navigate(['login']);
        }
    }
</code></pre>

<p><strong>Signup.service.ts</strong></p>

<pre><code>import {User} from '../shared/model/user';
import { Headers, Http } from '@angular/http';

import 'rxjs/add/operator/toPromise';
import {Injectable} from '@angular/core';
import {Response} from ""angular2/http"";
import { Observable }     from 'rxjs/Observable';


@Injectable()
export class SignupService {

    private postUrl:string = '/api/users/signup';
    private verify:string = '/api/users/verify';
    constructor(private http:Http) {
    }

    verification(user:User):Observable&lt;JSON&gt; {
        let headers = new Headers({
            'Content-Type': 'application/json'
        });

        return this.http
            .post(this.verify, JSON.stringify(user), {headers: headers})
            .map(this.extractData)
            .catch(this.handleError);
    }

    signup(token:string):Observable&lt;any&gt; {
        let headers = new Headers({
            'Content-Type': 'application/json'
        });

        return this.http
            .post(this.postUrl, JSON.stringify({verificationToken:token}), {headers: headers})
            .map(this.extractData)
            .catch(this.handleError);
    }

    private extractData(res: Response) {
        let body = res.json();
        return body || { };
    }

    private handleError(error: any) {
        let errMsg = (error.message) ? error.message :
            error.status ? `${error.status} - ${error.statusText}` : 'Server error';
        console.error(errMsg);
        return Observable.throw(errMsg);
    }

}
</code></pre>
","4300454","","310726","","2016-11-14 08:19:34","2018-08-21 20:43:08","How to make nested Service calls in Angular2 using observables?","<angular><typescript><rxjs><observable><rxjs5>","3","1","1","","","CC BY-SA 3.0"
"39572228","2","","39571944","2016-09-19 11:35:58","","3","","<p>Judging by the error <code>Cannot read property 'signup' of undefined</code> it looks like you're calling <code>signup()</code> on a non-existing object. </p>

<p>And it's correct, you're creating the closure as <code>.then(function (password) { ... })</code> which doesn't capture the surrounding context <code>this</code> and therefore is called with <code>this = window</code> which is not what you want obviously.</p>

<p>See: <a href=""https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html"" rel=""nofollow noreferrer"">https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html</a></p>

<p>So you can easily fix it with an arrow function:</p>

<pre><code>.then(password =&gt; {
    this.signupService.signup(password)
        .subscribe(data =&gt; {
             localStorage.setItem('user', JSON.stringify(data));
             this.router.navigate(['dashboard']);
        }, error =&gt; alert(error));
})
</code></pre>
","310726","","310726","","2018-08-21 20:43:08","2018-08-21 20:43:08","","","","2","","","","CC BY-SA 4.0"
"39608427","1","","","2016-09-21 05:47:45","","1","99","<p><strong>Solved and Closed</strong></p>

<p>The code snippet is from <a href=""http://reactivex.io/rxjs/manual/tutorial.html#state-stores"" rel=""nofollow"">rx.js doc</a></p>

<pre><code>var increaseButton = document.querySelector('#increase');
var increase = Rx.Observable.fromEvent(increaseButton, 'click')
  .map(() =&gt; state =&gt; Object.assign({}, state, {count: state.count + 1}));

// We create an object with our initial state. Whenever a new state change function
// is received we call it and pass the state. The new state is returned and
// ready to be changed again on the next click
var state = increase.scan((state, changeFn) =&gt; changeFn(state), {count: 0});
</code></pre>

<p>I get confused here that why <code>changeFn</code> is the right one that returned by <code>map</code> operator?</p>
","2326199","","2326199","","2016-09-21 06:11:27","2016-09-21 06:11:27","Rx.js 5 : why the scan use the function returned by map","<javascript><rxjs5>","0","1","","","","CC BY-SA 3.0"
"39631189","1","39642621","","2016-09-22 05:51:50","","0","136","<p>Here's the demo:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var availableNews$ = Rx.Observable.fromPromise(fetch('https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty').then(res =&gt; res.json()));
var pager$ = new Rx.Subject();
var fetchedNews$ = Rx.Observable.combineLatest(availableNews$, pager$, (news, pager) =&gt; news.slice((pager.current - 1) * pager.items_per_page, pager.items_per_page))
    .flatMap(id =&gt; id)
    .map(id =&gt; Rx.Observable.fromPromise(fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json?print=pretty`).then(res =&gt; res.json()))
    .concatMap(res =&gt; res));
pager$.subscribe(v =&gt; {
  console.log(v);
  document.querySelector('#pager').textContent = JSON.stringify(v);
});
fetchedNews$.subscribe(x =&gt; { 
  console.log(x);
  document.querySelector('#news').textContent = JSON.stringify(x);;
})
pager$.next({current: 1, items_per_page: 10})</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs/dist/global/Rx.js""&gt;&lt;/script&gt;
pager: &lt;p id=""pager""&gt;&lt;/p&gt;
news: &lt;p id=""news""&gt;&lt;/p&gt;
&lt;p&gt;the news return obserable instance instead of &lt;em&gt;array of fetched news&lt;/em&gt; which is desired&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p>I do these things in code:</p>

<p>1, fetch top news feeds (availableNews$)</p>

<p>2, use pager to limit which feeds should be fetch (pager$)</p>

<p>3, fetch news which should be a array (fetchedNews$)</p>

<p>But I stunk at step 3, the results returned is the stream of each promiseObserable, not result of each promise concated as a array.</p>

<p>Thanks for help ^_^</p>

<p>--Edited--</p>

<p>I ask this question as <a href=""https://github.com/ReactiveX/rxjs/issues/1982#issuecomment-249835663"" rel=""nofollow"">issue</a> for the rxjs on github, and get a better solution. Here's the code:</p>

<pre><code>const { Observable } = Rx;
const { ajax: { getJSON }} = Observable;

var availableNews$ = getJSON('https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty');
var pager$ = new Rx.Subject();
var fetchedNews$ = Observable
  .combineLatest(availableNews$, pager$, (news, {current, items_per_page}) =&gt; {
    return news.slice((current - 1) * items_per_page, items_per_page);
  })
  .switchMap((ids) =&gt; Observable.forkJoin(ids.map((id) =&gt; {
    return getJSON(`https://hacker-news.firebaseio.com/v0/item/${id}.json?print=pretty`);
  })));

pager$.subscribe(v =&gt; {
  document.querySelector('#pager').textContent = JSON.stringify(v);
});

fetchedNews$.subscribe(stories =&gt; {
   document.querySelector('#news').textContent = JSON.stringify(stories);  
});

pager$.next({current: 1, items_per_page: 10})
</code></pre>
","2326199","","2326199","","2016-09-28 01:49:41","2016-09-28 01:49:41","Rx.js: get all results as array from promise lists","<javascript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39635879","1","39641283","","2016-09-22 09:55:15","","3","804","<p>Imagine that we have an HTML page that fires AJAX requests. We want to make sure that AJAX requests are executed in order. The next AJAX request won't be fired until the previous one completes or errors.</p>

<p>I have tried to model this via a task queue using RxJS <code>concatMap</code>. Each AJAX request is modeled as an <code>Observable</code>. Everything is working great if AJAX request completes successfully, however if it errors, then the next task in the queue is not executed.</p>

<p>Here is an example, that uses <code>setTimeout()</code> to simulate long running async tasks:
</p>

<pre><code>  function identity(observable) {
    return observable;
  }

  function createTaskQueue() {
    var subject= new Rx.Subject();

    subject
    .concatMap(identity)
    .onErrorResumeNext(Rx.Observable.of('error'))
    .subscribe(function(data) {
      console.log('onNext', data);
    }, 
    function(error) {
      console.log('onError', error);
    });

    return {
      addTask: function(task) {
        subject.next(task);
      }
    }
  }

  function createTask(data, delay) {
    return Rx.Observable.create(function(obs) {
      setTimeout(function() {
        obs.next(data);
        obs.complete();
      }, delay);
    });
  }

  function createErrorTask(data, delay) {
    return Rx.Observable.create(function(obs) {
      setTimeout(function() {
        obs.error('Error: ' + data);
        obs.complete();
      }, delay);
    });
  }

  var taskQueue = createTaskQueue();

  taskQueue.addTask(createTask(11, 500))
  taskQueue.addTask(createTask(22, 200));
  taskQueue.addTask(createErrorTask(33, 1000));
  taskQueue.addTask(createTask(44, 300));
  taskQueue.addTask(createErrorTask(55, 300));
  taskQueue.addTask(createTask(66, 300));
</code></pre>

<p>Here is an executable example: <a href=""https://jsfiddle.net/artur_ciocanu/s6ftxwnf/"" rel=""nofollow"">https://jsfiddle.net/artur_ciocanu/s6ftxwnf/</a>.</p>

<p>When I run this code the following is printed to the console:
<code>
onNext 11
onNext 22
onNext error
</code></p>

<p>Which is expected, but I wonder why the other tasks like 44, 55, etc are not executed.</p>

<p>I am pretty sure I am doing something stupid with <code>onErrorResumeNext()</code> or may be the whole approach is totally wrong.</p>

<p>Any help is very much appreciated.</p>
","5339525","","3743222","","2016-09-25 23:51:59","2016-09-25 23:51:59","RxJS 5 task queue, continue if a task fails","<javascript><ajax><rxjs><rxjs5><reactive-extensions-js>","2","0","1","","","CC BY-SA 3.0"
"39641283","2","","39635879","2016-09-22 14:03:51","","2","","<p>If you read the documentation of <code>onErrorResumeNext</code>,</p>

<blockquote>
  <p>Continues an observable sequence that is terminated normally or by an
  exception with the next observable sequence or Promise.</p>
</blockquote>

<p>What that means is that when your source observable will encounter an error, it will switch to whatever you passed to <code>onErrorResumeNext</code>. What happens here is that <code>Rx.of(...)</code> terminates immediately after emitting its value. Hence the behavior you observe.</p>

<p>So in short, you don't want <code>onErrorResumeNext</code> here.</p>

<p>You could instead <code>.catch(...)</code> the stream which could emit an error. So, something like :</p>

<pre><code>subject
    .concatMap(obs =&gt; obs.catch(Rx.Observable.of('error')))
    .subscribe(...)
</code></pre>
","3743222","","","","","2016-09-22 14:03:51","","","","1","","","","CC BY-SA 3.0"
"39642621","2","","39631189","2016-09-22 15:04:33","","1","","<p>You have a combination of two or three errors.</p>

<p>First, the lambda in your <code>combineLatest()</code> does not operate on the array of news ids, but on a single item containing the array. The <code>flatmap()</code> is therefore unnecessary, as is the <code>concatMap()</code>.</p>

<p>Second, you don't need to create <code>Observable</code> from <code>fetch()</code>, as</p>

<p>third, the <code>combineLatest()</code> you have does not give a Promise that is fullfilled when the news are loaded, but when the availableNews and pager are loaded. So you have to make a third <code>Observable</code> with <code>combineLatest()</code>, but from the Array of <code>fetch()</code> Promises. You then subscribe to that in your second <code>subscribe()</code>, like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var availableNews$ = Rx.Observable.fromPromise(fetch('https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty').then(res =&gt; res.json()));
var pager$ = new Rx.Subject();
var fetchedNews$ = Rx.Observable.combineLatest(availableNews$, pager$, (news, pager) =&gt;
  Rx.Observable.combineLatest.apply(this, news.slice((pager.current - 1) * pager.items_per_page, pager.items_per_page)
    .map(id =&gt; fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json?print=pretty`).then(res =&gt; res.json()))));

pager$.subscribe(v =&gt; {
  document.querySelector('#pager').textContent = JSON.stringify(v);
});

fetchedNews$.subscribe(x =&gt; { 
  x.subscribe(a =&gt; {
    document.querySelector('#news').textContent = JSON.stringify(a);
  });
})
pager$.next({current: 1, items_per_page: 10})</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs/dist/global/Rx.js""&gt;&lt;/script&gt;
pager: &lt;p id=""pager""&gt;&lt;/p&gt;
news: &lt;p id=""news""&gt;&lt;/p&gt;
&lt;p&gt;the news return obserable instance instead of &lt;em&gt;array of fetched news&lt;/em&gt; which is desired&lt;/p&gt;</code></pre>
</div>
</div>
</p>
","5242576","","5242576","","2016-09-24 19:00:12","2016-09-24 19:00:12","","","","3","","","","CC BY-SA 3.0"
"39644318","1","39646882","","2016-09-22 16:29:13","","0","660","<p>IÂ´d like to create a <strong>JS Lib</strong> using <strong>RxJs (5.0.0-Beta.6)</strong> and <strong>TypeScript (1.8.10)</strong>.</p>

<p>My simple TypeScript file is compiling. I have this files:</p>

<p><strong>MyLib.ts:</strong></p>

<pre><code>/// &lt;reference path=""../../typings/globals/es6-shim/index.d.ts"" /&gt;
import * as Rx from 'rxjs/Rx';
Rx.Observable.of('foo', 'bar');
</code></pre>

<p><strong>tsconfig.json:</strong></p>

<pre><code>{
    ""compilerOptions"": {
         ""module"": ""commonjs""
        ,""target"": ""es5""
        ,""sourceMap"": true
    },
    ""files"": [
         ""src/MyLib.ts""
    ]
}
</code></pre>

<p>IÂ´m using <strong>gulp-typescript</strong> to generate JS file and it generate this file:</p>

<p><strong>MyLib.js:</strong></p>

<pre><code>""use strict"";
var Rx=require(""rxjs/Rx"");
Rx.Observable.of(""foo"",""bar"");
</code></pre>

<p>Now I need to have this file in an HTML. RxJs needs dependencies so I have copied these ones:</p>

<ul>
<li><p>RxJs 5.0.0 Beta 6 >> node_modules/rxjs/bundles/Rx.min.js</p></li>
<li><p>SystemJS 0.19.38 >> node_modules/systemjs/dist/system.js</p></li>
<li><p>RequireJS 2.3.2 >> node_modules/requirejs/require.js</p></li>
</ul>

<p><strong>This is my HTML:</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
&lt;head&gt;

    &lt;meta charset=""UTF-8""&gt;
    &lt;title&gt;MyLib Test&lt;/title&gt;

    &lt;script src=""vendor/require.js""&gt;&lt;/script&gt;
    &lt;script src=""vendor/system.js""&gt;&lt;/script&gt;
    &lt;script src=""vendor/Rx.min.js""&gt;&lt;/script&gt;
    &lt;script src=""MyLib.js""&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p><strong>My problem:</strong></p>

<p>IÂ´m getting this error in Chrome Console:</p>

<p><em>Uncaught Error: Module name ""rxjs/Rx"" has not been loaded yet for context: _. Use require([])</em></p>

<p>I haven't been able to load this simple JS: <strong>MyLib.js</strong> made with RxJs and TypeScript.</p>

<p>What is my problem and how can I fix it?</p>
","334963","","5837405","","2016-09-22 18:00:13","2016-09-22 18:55:33","RxJs with TypeScript: How generate Production files for Web?","<javascript><typescript><rxjs><typescript1.8><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39646882","2","","39644318","2016-09-22 18:55:33","","1","","<p>You have forgot to configure your module loader (and for some reason included two of them (require and systemjs)). </p>

<p>You should leave only one and your html with systemjs will look somewhat similar to:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
&lt;head&gt;
    &lt;meta charset=""UTF-8""&gt;
    &lt;title&gt;MyLib Test&lt;/title&gt;
    &lt;script src=""vendor/system.js""&gt;&lt;/script&gt;
    &lt;script&gt;
        System.config({
            paths: {
                ""rxjs"": 'vendor/rx/dist/rx.min'
            }    
        });

        System.defaultJSExtensions = true;

        //This will bootstrap your app
        System.import('myLib').catch(function(e)
        {
            console.error(e);
        });;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Hope this helps.</p>
","1035889","","","","","2016-09-22 18:55:33","","","","0","","","","CC BY-SA 3.0"
"39657373","1","","","2016-09-23 09:32:35","","6","872","<p>I'm using observables in Angular 2 final with Angular-cli.</p>

<ul>
<li>Angular 2.0.0 final</li>
<li>angular-cli: 1.0.0-beta.15 </li>
<li>node: 6.3.0 </li>
<li>Mac os: el capitan</li>
</ul>

<p>Dependencies in package.json:</p>

<pre><code>""dependencies"": {
    ""@angular/common"": ""2.0.0"",
    ""@angular/compiler"": ""2.0.0"",
    ""@angular/core"": ""2.0.0"",
    ""@angular/forms"": ""2.0.0"",
    ""@angular/http"": ""2.0.0"",
    ""@angular/platform-browser"": ""2.0.0"",
    ""@angular/platform-browser-dynamic"": ""2.0.0"",
    ""@angular/router"": ""3.0.0"",
    ""bootstrap-sass"": ""^3.3.7"",
    ""chart.js"": ""^2.2.2"",
    ""core-js"": ""^2.4.1"",
    ""d3"": ""^4.2.3"",
    ""d3-tip"": ""^0.7.1"",
    ""ionicons"": ""^3.0.0"",
    ""moment"": ""^2.15.1"",
    ""rxjs"": ""5.0.0-beta.12"",
    ""ts-helpers"": ""^1.1.1"",
    ""zone.js"": ""^0.6.23""
  }
</code></pre>

<p>My app works fine in every browser except in Safari 9.1.2 â it throws this error message to console:</p>

<pre><code>Failed to load resource: the server responded with a status of 404 (Not Found) http://localhost:4200/Observable.js.map
</code></pre>

<p>I've tried to import Rxjs in angular_cli.json:</p>

<pre><code>""scripts"": [
        ""../node_modules/rxjs/Rx.js""
      ],
</code></pre>

<p>Also, I've tried to import rxjs to app.module.ts and to working component like this:</p>

<pre><code>import {Observable} from 'rxjs/Rx';
</code></pre>

<p>But keep getting the same error.</p>

<p>Am I doing something wrong?
It's very strange that only Safari encounters this error.</p>
","6020338","","","","","2018-02-12 13:31:29","Failed to load resource: Observable.js.map in Safari 9.1.2","<angular><angular-cli><rxjs5><angular2-observables>","1","2","","","","CC BY-SA 3.0"
"39658207","1","","","2016-09-23 10:11:58","","2","550","<p>I'm trying to implement error handling for http requests. I've copied code from angular doc: <a href=""https://angular.io/docs/ts/latest/guide/server-communication.html"" rel=""nofollow"">https://angular.io/docs/ts/latest/guide/server-communication.html</a></p>

<p>Here is my file:</p>

<pre><code>import {Injectable} from ""@angular/core"";
import {Http, Response} from ""@angular/http"";
import '/js/admin/rxjs-operators';
import {Observable} from ""rxjs"";
@Injectable()
export class ApiService {
    private apiUrl: string = 'http://www.system.local/api/';

    constructor(private http: Http) {
    }

    post(url: string, params): Observable&lt;any&gt; {
        let requestUrl: string = this.apiUrl + url;
        return this.http.post(requestUrl, params)
            .map(response =&gt; response.json())
            .catch(this.handleError);
    }

    private handleError(error: any) {
        // In a real world app, we might use a remote logging infrastructure
        // We'd also dig deeper into the error to get a better message
        let errMsg = (error.message) ? error.message :
            error.status ? `${error.status} - ${error.statusText}` : 'Server error';
        console.error(errMsg); // log to console instead
        return Observable.throw(errMsg);
    }

    private parseParams(obj: Object, prefix?: string): string {
        var str = [];
        for (var p in obj) {
            if (obj.hasOwnProperty(p)) {
                var k = prefix ? prefix + ""["" + p + ""]"" : p, v = obj[p];
                str.push(typeof v == ""object"" ?
                    this.parseParams(v, k) :
                encodeURIComponent(k) + ""="" + encodeURIComponent(v));
            }
        }
        return str.length ? ""?"" + str.join(""&amp;"") : '';
    }
}
</code></pre>

<p>And rxjs-operators:</p>

<pre><code>// import 'rxjs/Rx'; // adds ALL RxJS statics &amp; operators to Observable
// See node_module/rxjs/Rxjs.js
// Import just the rxjs statics and operators we need for THIS app.
// Statics
import 'rxjs/add/observable/throw';
// Operators
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/toPromise';
</code></pre>

<p>When I refresh page I get instant error: </p>

<pre><code>zone.js:1274 GET http://www.system.local/node_modules/rxjs/ 404 (Not Found)
login:15 Error: (SystemJS) XHR error (404 Not Found) loading http://www.system.local/node_modules/rxjs(â¦)
</code></pre>

<p>When I comment out <code>// return Observable.throw(errMsg);</code> everything works but Observable is not passed further.
What can it be?
I'm using <code>rxjs@5.0.0-beta.12</code></p>
","979911","","","","","2016-09-23 10:11:58","Breaks with Observable.throw()","<angular><rxjs5>","0","0","","","","CC BY-SA 3.0"
"39664290","1","39664344","","2016-09-23 15:19:28","","13","16107","<p>How to tell the version of the installed RxJS from the code? For example:</p>

<pre><code>var Rx = require('rxjs/Rx');
console.log(Rx.rev);   // undefined
console.log(Rx.version);  // undefined
</code></pre>

<p>Second question: How to tell if it's rxjs5 ?</p>
","4374258","","","","","2018-12-16 10:21:56","How to tell the version number of RxJS","<javascript><node.js><rxjs><rxjs5>","3","3","4","","","CC BY-SA 3.0"
"39664344","2","","39664290","2016-09-23 15:21:54","","4","","<p>You could do something like:</p>

<pre><code>const package = require('rxjs/package.json');
const is5 = /^5\./.test(package.version);

console.log(package.version);
console.log(is5);
</code></pre>
","2615209","","","","","2016-09-23 15:21:54","","","","2","","","","CC BY-SA 3.0"
"39682861","1","","","2016-09-25 02:35:20","","0","450","<p>I'm trying to create wrapper module for fileupload feature.
Below code looks to work fine for my scenario, recently i came across rxjs, and would like to know how i can convert below approach to Observable. What will be the advantage over promise.</p>

<p><a href=""http://mono.software/2014/07/07/Creating-NodeJS-modules-with-both-promise-and-callback-API-support-using-Q/"" rel=""nofollow"">http://mono.software/2014/07/07/Creating-NodeJS-modules-with-both-promise-and-callback-API-support-using-Q/</a></p>

<p>```</p>

<pre><code>// dual-module.js
var Q = require('q');

module.exports = {
  getFullName: function (firstName, lastName, callback) {
    var deferred = Q.defer();

    if (firstName &amp;&amp; lastName) {
        var fullName = firstName + "" "" + lastName;
        deferred.resolve(fullName);
    }
    else {
        deferred.reject(""First and last name must be passed."");
    }

    deferred.promise.nodeify(callback);
    return deferred.promise;
 }
}
</code></pre>

<p>```</p>

<pre><code>var DualModule = require('dual-module');

DualModule.getFullName(""John"", ""Doe"")
.then(function (result) {
    // result returns ""John Doe""
})
.fail(function (error) {
    // error returns error message if either first or last name are null or undefined
});


var DualModule = require('dual-module');

DualModule.getFullName(""John"", ""Doe"", function (error, result) {
    // error returns error message if either first or last name are null or undefined   
    // result returns ""John Doe""
});
</code></pre>
","538776","","","","","2016-09-26 07:35:05","Rxjs alternative for promise approach","<node.js><promise><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39690582","1","","","2016-09-25 18:52:17","","1","482","<p>I've just started using the <a href=""https://github.com/jeffbski/redux-logic"" rel=""nofollow"">https://github.com/jeffbski/redux-logic</a> library and its going well except for an issue that I haven't been able to resolve.  I'm not sure what's causing it, but it started when I installed this library and also the required RXJs library (5.0.0-beta.12), and updated WebPack (1.13.2) and Babel (core 6.14) to handle the ES2016 features.  </p>

<p>The babel-runtime is in dependencies, babel-plugin-transform-runtime is in devDependencies. I've checked multiple times.  I dont see any index.js file though, but I'm not sure there is on</p>

<p>I've tried clearing the NPM cache, removing and reinstalling node_modules, changing parameters on the webpack CommonsChunkPlugin, .bablerc, etc for 2 days and the exception is still thrown in the browser.  Even odder, the application seems to be working, but I cant have this browser exception.</p>

<p>I'd love to post the actual output from WebPack, but after 20+ tries, SO is still complaining that my post appears to contain code that is not properly formatted as code.  So here it is as a Gist:</p>

<p><a href=""https://gist.github.com/MrRoyce/4e9b0ca0747541893848b19206cea2f8"" rel=""nofollow"">https://gist.github.com/MrRoyce/4e9b0ca0747541893848b19206cea2f8</a></p>

<p>Here is .babelrc</p>

<pre><code>{
  ""presets"": [
    ""es2015"",
    ""es2016"",
    ""react""
  ],
  ""plugins"": [
    [""transform-runtime"", {
      ""polyfill"": false,
      ""regenerator"": true
    }],
    ""syntax-async-functions"",
    ""transform-class-properties"",
    ""transform-regenerator"",
    ""transform-object-rest-spread""
  ]
}
</code></pre>

<p>Any help is appreciated</p>
","2516625","","","","","2016-09-25 18:52:17","Getting WebPack multi vendor error - Cannot resolve module 'babel-runtime'","<webpack><babeljs><rxjs5>","0","2","1","","","CC BY-SA 3.0"
"39717525","1","","","2016-09-27 06:30:12","","1","664","<p>Hi I am using this rxjs libraray .I am getting this error 
Rx.Observable.bindCallback is not a function</p>

<p>here is my code
<a href=""http://jsbin.com/tuxucotake/edit?html,js,console,output"" rel=""nofollow"">http://jsbin.com/tuxucotake/edit?html,js,console,output</a></p>

<p>I am reading doc from here 
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""nofollow"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html</a></p>

<pre><code>var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
var result = getJSONAsObservable('http://mysafeinfo.com/api/data?list=englishmonarchs&amp;format=json');
result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
</code></pre>
","3701974","","217408","","2016-09-27 06:33:01","2020-02-17 14:13:59","why bindCallback is not a function?","<javascript><rxjs><rxjs5>","2","7","","","","CC BY-SA 3.0"
"39732822","1","41621644","","2016-09-27 19:28:27","","-1","406","<p>I am facing a <strong>RxJS</strong> issue. </p>

<p>My app is currently designed as follows: I have two different clients: <code>ClientA</code> &amp; <code>ClientB</code> that subscribe to two different Observables: <code>ObservableA</code> &amp; <code>ObservableB</code>. </p>

<p>Note that the app also mutates a variable called <code>aVariable</code>.</p>

<p>Here is the flow:</p>

<ol>
<li><code>ClientA</code> subscribes to <code>ObservableA</code>.</li>
<li><code>ClientB</code> subscribes to <code>ObservableB</code>.</li>
<li><code>ObservableB</code> subscription read <code>false</code> from <code>aVariable</code> and completes.</li>
<li><code>ObservableA</code> subscription sets <code>aVariable</code> to <code>true</code> and completes (later than <code>ObservableB</code>).</li>
</ol>

<p>Whereas what is really intended was for <code>ObservableA</code>'s subscription to complete before <code>ObservableB</code>'s so that <code>ClientB</code> would read <code>true</code> from <code>aVariable</code>... Or to put it another way, somehow ensure that <code>ObservableB</code>'s subscription waits till the other subscription has completed.</p>

<p>I am not sure what RxJS construct to use in order to achieve what I want (I currently use plain Observables). I believe I need more than plain Observables here...</p>

<p>Can someone please help?</p>

<p>P.S. <em>Note that <code>aVariable</code> is held in a <strong>ngrx store</strong> but I don't think that is relevant to this issue...</em></p>

<p>P.P.S. <em>The above is a simplification of my real app.</em></p>
","536299","","536299","","2016-09-29 15:00:01","2017-01-12 19:43:39","Choosing the right RxJS construct in order to ensure one subscription completes before another one","<rxjs><observable><rxjs5><ngrx>","1","8","","","","CC BY-SA 3.0"
"39761826","1","39762099","","2016-09-29 05:07:26","","22","16910","<p>I am using <a href=""https://github.com/ngrx/effects"" rel=""noreferrer"">ngrx/effects</a>.</p>

<p>How can I dispatch an empty action?</p>

<p>This is how I am doing now:</p>

<pre><code> @Effect() foo$ = this.actions$
    .ofType(Actions.FOO)
    .withLatestFrom(this.store, (action, state) =&gt; ({ action, state }))
    .map(({ action, state }) =&gt; {
      if (state.foo.isCool) {
        return { type: Actions.BAR };
      } else {
        return { type: 'NOT_EXIST' };
      }
    });
</code></pre>

<p>Since I have to return an action, I am using <code>return { type: 'NOT_EXIST' };</code>.</p>

<p>Is there a better way to do this? </p>
","2000548","","2000548","","2016-09-29 18:11:20","2021-06-16 05:37:36","How to dispatch an empty action?","<angular><typescript><rxjs5><ngrx>","7","0","2","","","CC BY-SA 3.0"
"39761995","1","","","2016-09-29 05:21:45","","3","260","<p>I am a absolute beginner to <code>Rxjs</code> - But I came to know that, It works better for `async' operations.</p>

<p>In my web page, there is a <code>iframe</code> loading the content ( it has some loop in it )</p>

<p>once all done, I would like to trigger a event to say that, ""hey all contents are loaded in iframe"" - how to do this using <code>rxjs</code>?</p>

<p>i see that some example like this: </p>

<pre><code>function initialize() {
    // Do something on initialization
}

Rx.DOM.ready().subscribe(initialize);
</code></pre>

<p>But actually what is the correct way to write the function and wait until the iframe contents loads?</p>

<p>Thanks in advance.</p>
","2024080","","","","","2016-09-29 10:18:32","`RxJs` - how to wait untill `Iframe` contents loaded and trigger an function?","<iframe><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39762099","2","","39761826","2016-09-29 05:30:02","","16","","<p>I've used similar unknown actions, but usually in the context of unit tests for reducers.</p>

<p>If you are uneasy about doing the same in an effect, you could conditionally emit an action using <code>mergeMap</code>, <code>Observable.of()</code> and <code>Observable.empty()</code> instead:</p>

<pre><code>@Effect() foo$ = this.actions$
  .ofType(ChatActions.FOO)
  .withLatestFrom(this.store, (action, state) =&gt; ({ action, state }))
  .mergeMap(({ action, state }) =&gt; {
    if (state.foo.isCool) {
      return Observable.of({ type: Actions.BAR });
    } else {
      return Observable.empty();
    }
  });
</code></pre>
","6680611","","","","","2016-09-29 05:30:02","","","","0","","","","CC BY-SA 3.0"
"39775577","1","40928266","","2016-09-29 16:31:00","","3","1554","<p>I have an angular 2.0.0 (same issue in 2.2.0) project. The current dev build generates > 100 http requests.</p>

<p>This is due to it loading non-bundled versions of rxjs..</p>

<p>When I have the following :</p>

<pre><code>    map: {
        // our app is within the app folder
        app: 'app',
        // angular bundles
        // snip
        'rxjs': 'npm:rxjs',
        'angular-in-memory-web-api': 'npm:angular-in-memory-web-api',
    },
</code></pre>

<p>The app works but we have 1000+ http requsts , so I try to load rxjs from the bundle, todo this I remove <code>rxjs': 'npm:rxjs'</code> and I add the following</p>

<p>Note, for both the npm: loads from unpkg</p>

<pre><code>    paths: {
        // paths serve as alias
        'npm:': 'https://unpkg.com/',
        'rxjs/*': 'https://unpkg.com/@reactivex/rxjs/dist/global/Rx.js'
    },
</code></pre>

<p>The ReactiveX git page suggests that this package should work or is it missing something else??</p>

<p>I get the following error with the second config </p>

<pre><code>Uncaught (in promise): TypeError: Cannot read property 'call' of undefined
</code></pre>
","4477334","","4477334","","2016-12-02 09:09:13","2016-12-02 16:36:08","rxjs bundle from unpkg","<angularjs><bundle><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"39777220","1","39777221","","2016-09-29 18:10:41","","1","2638","<p>I am using ngrx. I got error</p>

<blockquote>
  <p>Cannot read property 'type' of undefined</p>
</blockquote>

<p>This is part of my codes:</p>

<pre><code>@Effect() foo$ = this.actions$
    .ofType(Actions.FOO)
    .withLatestFrom(this.store, (action, state) =&gt; ({ action, state }))
    .map(({ action, state }) =&gt; {
      if (state.foo.isCool) {
        return { type: Actions.BAR };
      }
    });
</code></pre>
","2000548","","","","","2016-10-02 20:29:01","Cannot read property 'type' of undefined (ngrx)","<angular><typescript><rxjs5><ngrx>","1","0","1","","","CC BY-SA 3.0"
"39777221","2","","39777220","2016-09-29 18:10:41","","5","","<p>This issue is little tricky since it is not easy to locate the issue based on the error.</p>

<p>In this situation, when <code>state.foo.isCool</code> is <code>false</code>, no action is returned.</p>

<p>So changing to something like this will solve the issue:</p>

<pre><code>@Effect() foo$ = this.actions$
    .ofType(Actions.FOO)
    .withLatestFrom(this.store, (action, state) =&gt; ({ action, state }))
    .map(({ action, state }) =&gt; {
      if (state.foo.isCool) {
        return { type: Actions.BAR };
      }

      return { type: Actions.SOMETHING_ELSE };
    });
</code></pre>
","2000548","","2000548","","2016-10-02 20:29:01","2016-10-02 20:29:01","","","","6","","","","CC BY-SA 3.0"
"39780986","1","","","2016-09-29 22:29:19","","1","3381","<p>This seems to work and I am curious to know if this is safe. Take the following scenario...</p>

<p>In a shared service class I have:</p>

<pre><code>this.subject = new Rx.Subject();
</code></pre>

<p>Lets say this observable has multiple subscribers.</p>

<p>The subject looks like so <code>subject.observers = [Subscriber 1, Subscriber 2...Subscriber n]</code></p>

<p>If I wanted the <code>Subject</code> to stop notifying all subscribers, I know I can do <code>subject.unsubscribe()</code> and that will set <code>subject.observers = null</code>, but this then does not allow any future subscribers to attach to the <code>this.subject</code> instance.</p>

<p>Okay heres the question... </p>

<p>Instead of using <code>subject.unsubscribe()</code>, can I just clear out the observers array like so <code>subject.observers.length = 0</code> with out causing any issues? </p>

<p>This then clears out all of the subscribers it was watching but still allows me to attach other subscribers in the future.</p>

<p>I can iterate through the <code>subject.observers</code> array and unsubscribe that way, but if I just clear out the observers array with out causing any memory leaks, I'd prefer the way.</p>
","1211936","","","","","2016-09-29 22:29:19","Is it safe to clear observers from the Subject object in rxjs in this scenario?","<rxjs><observable><rxjs5>","0","5","","","","CC BY-SA 3.0"
"39790770","1","39791929","","2016-09-30 11:43:59","","0","1805","<p>I keep getting the error that unsubscribe is not a function. I'm using rxjs@5.0.0-beta.12.</p>

<p>These are my import statements:</p>

<pre><code>import { TimerObservable } from 'rxjs/observable/TimerObservable';
import 'rxjs/add/operator/take';
</code></pre>

<p>This is the TimerObservable in question:</p>

<pre><code>countdown = TimerObservable.create(0, 1000).take(6);
</code></pre>

<p>This kicks off the timer:</p>

<pre><code>startCountdownTimer(): void {
    this.countdown.subscribe(
        i =&gt; this.timeRemaining = (5 - i).toString(),
        null,
        () =&gt; this.toDelete = -1)
}
</code></pre>

<p>This, well, this doesn't work:</p>

<pre><code>cancelCountdownTimer(): void {
    this.countdown.unsubscribe();
}
</code></pre>
","5899766","","","","","2016-09-30 12:49:17","How to unsubscribe from my nifty TimerObservable in rxjs","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39791929","2","","39790770","2016-09-30 12:49:17","","0","","<p>Callers of <code>subscribe</code> receive a <a href=""http://reactivex.io/rxjs/manual/overview.html#subscription"" rel=""nofollow"">subscription</a>:</p>

<pre><code>startCountdownTimer(): void {
    this.subscription = this.countdown.subscribe(
        i =&gt; this.timeRemaining = (5 - i).toString(),
        null,
        () =&gt; this.toDelete = -1);
}
</code></pre>

<p>which has an <code>unsubscribe</code> method:</p>

<pre><code>cancelCountdownTimer(): void {
    this.subscription.unsubscribe();
}
</code></pre>
","6680611","","","","","2016-09-30 12:49:17","","","","3","","","","CC BY-SA 3.0"
"39792544","1","","","2016-09-30 13:19:19","","1","335","<p>I have an Angular2 ForkJoin that can contain multiple HTTP requests.  When the ForkJoin errors, I'd like to be able to determine the sub domain/domain of the URL of the request in the ForkJoin that caused the error.  If the error is a 401 Unauthorized, then I need to try and re-establish a new connection.  I need the sub domain/domain of the failed request so I can look up the credentials in order to re-establish a token then attempt the ForkJoin request again.  My ForkJoin could be making multiple requests to different domains.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>			return Observable.create(observer =&gt; 
			{
				//JOIN ALL REQUESTS TOGETHER INTO A BATCH TO BE FORKED....
				let observableBatch = [];	

				//ADD OBSERVABLE FOR SINGLE GET REQUEST				
				if (requestModel.Get)
				{
					observableBatch.push(this.HttpGet(requestModel.Get));
				}	

				//ADD OBSERVABLE FOR AN ARRAY OF GET REQUESTS				
				if (requestModel.GetList)
				{
					for (let item in requestModel.GetList) 
					{
						observableBatch.push(this.HttpGet(requestModel.GetList[ item ]));
					}
				}	
								
				//ADD OBSERVABLE FOR SINGLE POST REQUEST	
				if (requestModel.Post)
				{
					observableBatch.push(this.HttpPost(requestModel.Post));
				}				
								
				//ADD OBSERVABLE FOR AN ARRAY OF POST REQUESTS
				if (requestModel.PostList)
				{
					for (let item in requestModel.PostList) 
					{
						observableBatch.push(this.HttpPost(requestModel.PostList[ item ]));
					}					
				}	
				
				/*
				FORK JOIN RETURNS AN ARRAY OF RESULT SETS (1 FOR EACH REQUEST IN FORK JOIN)
				THIS OBSERVABLE, IF SUCCESSFUL, RETURNS THE FOLLOWING:
				[1..N] - THE RAW JSON FROM CMS SERVICE
				*/
				let forkJoinSubscription = Observable.forkJoin(observableBatch)
					.subscribe (
						//SUCCESS, WE HAVE JSON RESPONSE(S)
						data =&gt;
						{						
							console.log('FORK JOIN SUCCESS !!!', data);							
						},
					
						//ERROR
						err =&gt;
						{
							console.log('FORK JOIN ERROR...', err);
						},

						//COMPLETE
						() =&gt;
						{
							if (forkJoinSubscription)
							{ 
								forkJoinSubscription.unsubscribe();
							}							
							//console.log('FORK JOIN COMPELETED');
						}
				);			
			});</code></pre>
</div>
</div>
</p>

<p>Is it possible to determine the subdomain/domain of the URL in the batch of URLS in ForkJoin when an error happens?</p>
","418549","","","","","2016-09-30 13:19:19","Angular2 - Get URL of error in Observable ForkJoin","<angular><rxjs5><fork-join><angular2-observables>","0","0","","","","CC BY-SA 3.0"
"39796271","1","39809547","","2016-09-30 16:40:22","","1","127","<p>I have the following code (httpObservable completes on first emission) which polls service with fixed ""dead time"":</p>

<pre><code>return serviceObservable.expand(() =&gt; Observable.timer(period).concatMap(() =&gt; serviceObservable));
</code></pre>

<p>How can I make the timer ""resettable"" by using <code>Subject</code> which emits every time the timer should be resetted?</p>
","3865778","","","","","2016-10-01 17:29:39","RxJs 5 periodic polling with out of order refreshing","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39797698","1","39816349","","2016-09-30 18:18:32","","4","5346","<p>I've read the <a href=""http://reactivex.io/documentation/operators/repeat.html"" rel=""nofollow"">Rx.js repeat</a> Documentation in an effort to find out how I can continue calling an api based upon the response that I receive from the <code>API</code>. I'm calling an <code>API</code> that can only send back <code>2k</code> records at a time. The API will send back a value for me to send it so that I can continue receiving the records until they return a done value.</p>

<p>So the flow goes as follows:</p>

<ol>
<li>Make a <code>GET</code> request a query parameter <code>reqMode=''</code>:</li>
<li>retrieve response with the last array containing <code>reqMode</code> with a <code>value</code> or <code>done</code>.</li>
<li>If I receive a <code>value</code> then I need to make the same request but send the <code>reqMode</code> parameter with the value.</li>
<li>If i receive <code>done</code> then I'll stop and return all of the records since the first call. </li>
</ol>

<p>I get the first set of values when <code>subscribing normally</code>, but this would be my attempt after reading the docs, but it doesn't make sense:</p>

<pre><code>getRecords(){
    let url = this.url + 'reqMode=';
    return this.http.get(url)
            .doWhile() //What would I do here
}
</code></pre>

<p>When trying to do <code>.doWhile</code> with a Observable that is type <code>Observable&lt;response&gt;</code>. I'm looking for any alternative using Observables for what I need to do.</p>
","804928","","310726","","2016-10-02 12:33:03","2016-10-02 12:33:03","Observable Continue calling API and changing parameters based on condition","<angular><typescript><rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"39805688","1","40240260","","2016-10-01 10:47:41","","1","142","<p>I'm trying to group my observable values into groups using windowCount, and for each value of each group send request.<br>Then, concatenate those groups so that next group's requests would not start before current group's request are not completed.<br>The problem is some values get skipped.<br><br>Here's my code.<br>(I'm not making actual ajax calls here, but Observable.timer should work for an example).</p>

<pre><code>Observable.interval(300)
     .take(12)
     .windowCount(3)
     .concatMap(obs =&gt; {
         return obs.mergeMap(
             v =&gt; Observable.timer(Math.random() * 1500).mapTo(v)
         );
     })
     .do(v =&gt; console.log(v))
     .finally(() =&gt; console.log('fin'))
     .subscribe();
</code></pre>

<p>I tried to replace windowCount by creating the groups manually. And it works perfectly. No values are skipped.</p>

<pre><code>Observable.interval(900)
    .take(4)
    .map(i =&gt; Observable.interval(300).take(3).map(j =&gt; j + i * 3))
    .concatMap(obs =&gt; {
        return obs.mergeMap(
            v =&gt; Observable.timer(Math.random() * 1500).mapTo(v)
        );
    })
    .do(v =&gt; console.log(v))
    .finally(() =&gt; console.log('fin'))
    .subscribe();
</code></pre>

<p>I was under impression that windowCount should group the emitted values the same way.<br>But, apparently it does something else.<br></p>

<p>I would be really thankful for any explanation of its behavior. <br><br>Thanks!</p>
","6908212","","162698","","2016-10-01 14:07:26","2016-11-01 11:41:20","windowCount dropping values","<reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39809547","2","","39796271","2016-10-01 17:29:39","","1","","<pre><code>return serviceObservable
    .expand(() =&gt; Observable
        .timer(period)
        .race(subject.take(1))
        .concatMap(() =&gt; serviceObservable));
</code></pre>
","3865778","","","","","2016-10-01 17:29:39","","","","0","","","","CC BY-SA 3.0"
"39812690","1","39813514","","2016-10-02 00:12:38","","3","2576","<p>I have an observable -- <code>loading$</code> -- that outputs <em>true</em> when I want to show a loading overlay in the UI, and <em>false</em> when it's time to remove that overlay. The visibility is controlled with a CSS class.</p>

<p>When the Observable emits <em>true</em>, I want to add the CSS class to the <code>&lt;body&gt;</code>, and remove it on <em>false</em>.</p>

<p><strong>html</strong></p>

<pre><code>&lt;body class=""""&gt;
    &lt;my-app&gt;Angular app goes here&lt;/my-app&gt;
&lt;/body&gt;
</code></pre>

<p>As you can see, the <code>&lt;body&gt;</code> is outside of my <code>Angular 2</code> app, so I cannot use property binding to change the class. This is what I currently do:</p>

<p><strong>AppComponent.ts</strong></p>

<pre><code>loading$.subscribe(loading =&gt;{
    if(loading) document.querySelector('body').classList.add('loading');
    else document.querySelector('body').classList.remove('loading');
});
</code></pre>

<p>This works well. The <code>loading</code> class is added/removed when the <code>loading$</code> observable emits <em>true</em>/<em>false</em>.  The problem is that I'd like to run my app in a web worker which means no access to the DOM. Plus, Angular recommends against manipulating the DOM directly.</p>

<p>How can I use <code>Angular</code> APIs to change <code>&lt;body&gt;</code>?</p>

<p><code>Angular 2</code>, <code>typescript 2</code>, <code>rxjs 5 beta 12</code></p>

<p>PS: <a href=""https://stackoverflow.com/questions/36157605/modify-dom-elements-outside-root-component"">This question</a> looks promising, but the key link is dead. I've also seen a couple of suggestions that worked with Beta releases but are now obsolete (<a href=""http://stackoverflow.duapp.com/questions/34432980/angular-2-x-selecting-dom-element?noredirect=1"" rel=""nofollow noreferrer"">example</a>)</p>
","3977061","","-1","","2017-05-23 12:02:08","2016-12-01 23:47:09","Angular 2: change DOM elements outside the root AppComponent","<dom><angular><typescript><rxjs5>","3","4","1","","","CC BY-SA 3.0"
"39813514","2","","39812690","2016-10-02 03:15:45","","1","","<p>Try to do like this:</p>

<pre><code>&lt;my-app&gt;
  &lt;div class=""your-class-for-loading""&gt;&lt;/div&gt;
&lt;/my-app&gt;
</code></pre>

<p>When <code>my-app</code> is ready, div will be automatically removed.</p>
","1716560","","","","","2016-10-02 03:15:45","","","","1","","","","CC BY-SA 3.0"
"39816349","2","","39797698","2016-10-02 11:06:13","","9","","<p>I don't think <code>repeat()</code> is a good operator for this. If I understand you correctly you want to repeat the HTTP request based on the response of the previous request. Operator <code>repeat()</code> is good if you wanted to repeat <strong>the same</strong> request multiple times.</p>

<p>I'd use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concatMap"" rel=""noreferrer""><code>concatMap()</code></a> and recursively call itself until the <code>reqMode</code> is eqaul to <code>""done""</code>:</p>

<p>See live demo: <a href=""http://plnkr.co/edit/w0DdepslTaKrLSB3aIkA"" rel=""noreferrer"">http://plnkr.co/edit/w0DdepslTaKrLSB3aIkA</a></p>

<pre><code>import {Observable, Subject} from 'rxjs';

const result = new Subject();
const closeBuffer = new Subject();
const buffer = result.buffer(closeBuffer.asObservable());

function sendHttpRequest(reqMode) {
  return Observable.of('{""reqMode"":' + reqMode + '}')
    .map(response =&gt; JSON.parse(response))
    .concatMap(data =&gt; {
      console.log('HTTP Response:', data);
      // Add data to the buffer of results
      result.next(data);

      if (data.reqMode == 'done') {
        // Return an empty value wrapped as an Observable so concatMap can work
        // with it and emit onNext when it completes (which is immediately
        // thanks to the `.of()` operator).
        return Observable.of(null);
      } else {
        // Simulate that the next call returns 'done'
        return sendHttpRequest('""done""');

        // Uncomment this for real usage
        //return sendHttpRequest(data.reqMode);
      }
    });
}

// Subscribe to the buffer where I'll receive the value.
buffer.subscribe(val =&gt; console.log('Next: ', val));

// Simulate HTTP request with reqMode = 42
sendHttpRequest(42).subscribe(() =&gt; {
  console.log('done');
  // Emit values from the buffer.
  closeBuffer.next(null);
  closeBuffer.complete();
});
</code></pre>

<p>I use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-of"" rel=""noreferrer""><code>of()</code></a> operator to simulate a request and to return a value wrapped as an Observable. I also use <code>Subject</code> to hold all responses that are buffered using <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-buffer"" rel=""noreferrer""><code>buffer()</code></a> operator. The I subscribe to the buffer to get the final array of responses (If you wrap this code into a function you'll most likely return the <code>buffer</code> where you can subscribe later).</p>

<p>The response is following:</p>

<pre><code>HTTP Response: Object {reqMode: 42}
HTTP Response: Object {reqMode: ""done""}
Next:  [Object, Object]
</code></pre>

<p>See similar question: <a href=""https://stackoverflow.com/questions/39566268/angular-2-rxjs-how-return-stream-of-objects-fetched-with-several-subsequent/39578646#39578646"">Angular 2 + rxjs - how return stream of objects fetched with several subsequent http requests</a></p>
","310726","","-1","","2017-05-23 10:30:59","2016-10-02 11:39:48","","","","5","","","","CC BY-SA 3.0"
"39819194","1","39821353","","2016-10-02 16:36:08","","1","1579","<p>I wonder how to implement this properly with RxJs (4/5)?</p>

<pre><code>-a-- -b----c----d-----------------------------------------------------------e------f---------------------
-5-sec after-""a""--&gt; [abcd]---new 5 sec timer will start when ""e"" emited-----5 sec-after-""e""-&gt;[ef]-
</code></pre>

<p>I think this:</p>

<pre><code>.buffer(source$.throttleTime(5000).debounceTime(5000))
</code></pre>

<p>do the job in rxjs 5</p>
","733596","","733596","","2016-10-03 10:06:56","2020-06-26 16:26:03","RxJS: (Time) Buffer that starts after next emittion","<rxjs><rxjs5>","4","0","","","","CC BY-SA 3.0"
"39821353","2","","39819194","2016-10-02 20:25:14","","1","","<p>Your best shot is to use buffer. The buffer has a closing condition, and you'd like a closing condition 5 seconds after a new item was introduced. So, lets suppose you have a source stream, your desired stream will be:</p>

<pre><code>source.buffer(source.throttle(5100).debounce(5000));
</code></pre>

<p>This is rxjs 4. I think rxjs has a slightly different buffer operators but the idea is the same.</p>

<p>Explanation:
The throttle ensures that for 5100 mSecs you will get only the first ""tick"". The debounce will propagate this ""tick"" after 5000 mSecs because there were no other ""ticks"" since. Note that I chose 5100 mSecs since the timing is not always perfect and if you use 5000 mSecs for both, the debounce might be repeatedly delayed and you'll get starvation. Anyways, your buffer will not loose data, just might group it in chunks bigger than 5000 mSecs.</p>

<p>Rxjs 5 has a bufferToggle operator which might look a better option, yet, the fact that you both open and close the buffer might become risky and make you loose data due to timing issues.</p>
","242098","","","","","2016-10-02 20:25:14","","","","2","","","","CC BY-SA 3.0"
"39844027","1","","","2016-10-04 04:09:32","","0","2521","<p>Getting error in Chrome Console: EXCEPTION: Error: Uncaught (in promise): TypeError: Cannot read property 'applicationName' of null.</p>

<p><strong>Model:</strong> 
    export class BasicInfoModel {</p>

<pre><code>    applicationName: string;
    localDirectoryPath: string; 
}
</code></pre>

<p>Controller emitting data to parent component, parent component there it is saved to services.</p>

<p><strong>Controller:</strong></p>

<pre><code>import { Component, Output, OnInit, EventEmitter} from '@angular/core';
import { FormGroup, FormControl, REACTIVE_FORM_DIRECTIVES, Validators,               
FormBuilder, FormArray}from ""@angular/forms"";
import { Observable } from ""rxjs/Rx"";
import { BasicInfoModel } from '../basicinfomodel';
import { BasicInfoService} from '../app.dev.basicinfo.service';

@Component({
   selector: 'basic-info',
   templateUrl: './basicInfo.html',
   styleUrls: ['../../ComponentStyles.css'],
   directives: [REACTIVE_FORM_DIRECTIVES]
})

export class BASIC_INFOComponent implements OnInit {

observableBasic: BasicInfoModel;
basicInfoForm: FormGroup;

@Output() basicInfoUpdate = new EventEmitter&lt;JSON&gt;();
@Output() basicInfoFormValid = new EventEmitter&lt;Boolean&gt;();

constructor(private formBuilder: FormBuilder, private BasicInfoService:      
BasicInfoService) {  }

onSubmit() {
    debugger;
    this.observableBasic;
    this.basicInfoUpdate.emit(this.basicInfoForm.value);
}

ngOnInit() {

    this.basicInfoForm = new FormGroup({
        'applicationName': new FormControl('', Validators.required),
        'localDirectoryPath': new FormControl('', Validators.required)
    });

    this.basicInfoForm.valueChanges.subscribe(data =&gt; console.log('form   
    changes', data));
    this.BasicInfoService.currentBasicInfo
        .subscribe(
        (basic: BasicInfoModel) =&gt; {
            this.observableBasic = basic;
        });

    (&lt;FormGroup&gt;this.basicInfoForm).setValue(this.observableBasic, { onlySelf: true });
}

}
</code></pre>

<p><strong>What i want to achieve:</strong></p>

<ol>
<li>When i build my code, i want my formGroup should be populated with null values.</li>
<li>when i filled the data and saved it to behaviourSubject in my services, latter when i revisit the page my formGroup should be in sync with data services.</li>
</ol>
","6194909","","","","","2016-10-04 04:11:39","Populate FormGroup with null value and","<javascript><angular><rxjs5><angular-material2>","1","0","","","","CC BY-SA 3.0"
"39850723","1","","","2016-10-04 11:08:37","","3","806","<p>In the angular2-meteor tutorial <a href=""https://www.angular-meteor.com/tutorials/socially/angular2/3-way-data-binding"" rel=""nofollow"">step3</a>, we use a zone method.
Code:</p>

<pre><code>import { Component } from '@angular/core';
import { Observable } from 'rxjs/Observable';

import { Parties } from '../../both/collections/parties.collection';

...some lines skipped...
  template
})
export class AppComponent {
  parties: Observable&lt;any[]&gt;;

  constructor() {
    this.parties = Parties.find({}).zone();
  }
}
</code></pre>

<p>What exactly does Parties.find({}).zone() do?</p>
","6899048","","","","","2016-10-04 13:29:35","Angular2-Meteor zone() method","<meteor><angular><rxjs><angular-meteor><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"39856187","1","39857792","","2016-10-04 15:23:56","","1","443","<p>I am on Ionic2/RC0 and I am implementing a user service for my application.</p>

<pre><code>@Injectable()
export class UserService {
    UserWhatever: ReplaySubject&lt;User&gt; = new ReplaySubject&lt;User&gt;();



    constructor(private _util: UtilService,
        private _app: AppService,
        private _http: Http) {
        console.log(""I am UserService. Just got created"")

        this.UserWhatever.subscribe(
            (data) =&gt; {
                console.log(""User service got a USER"");
            }
        )


    }

    login(element) {
        return this.getToken(element).flatMap(
            (data) =&gt; {
                return Observable.forkJoin([Observable.of(data),
                this.readUser(data)
                ]);
            }
        ).map(data =&gt; {
            localStorage[""jwt""] = data[0];
            this._util.sendToast(""logged"");
            console.log(""Http call received a USER"")
            let guser: User = data[1];
            console.log(""Called next "")
            this.UserWhatever.next(guser)
        });
    }
</code></pre>

<p>As soon as I got the full response from the login() observable inside my HomeComponent I send the user to the DashboardComponent</p>

<pre><code>export class LoginComponent implements OnInit {

    subs() {
        this._user.UserWhatever.subscribe(
            (data) =&gt; {
                console.log(""Login Component got a Replayed USER"");
            })
    }


    login() {
        this.isDisabled = true;
        this._user.login(this.loginForm)
            .subscribe(
            data =&gt; {
                this.subs()   
                this.nav.push(DashboardPageComponent);
            }    
    }
</code></pre>

<p>Where I subscribe to the ReplaySubject from my userService. Here its where the problems appear.It does not replay the subject by the time of its subscription. It all works fine if I happen to call next() again on the ReplaySubject.</p>

<pre><code>export class DashboardPageComponent implements OnInit, OnDestroy, AfterViewInit {
    public user: User;


    constructor(private _app: AppService,
        private _device: DeviceService,
        private _user: UserService,
        private _store: Store&lt;any&gt;,
        private _nav: NavController) {
        console.log(""Dashboard component"")
    }

    ngOnInit() {

        this._user.UserWhatever.subscribe(
            (data) =&gt; {
                this.user = data;
                console.log(""Dashboard finally received a User"")
                console.log(data)
            }
        )
    }
</code></pre>

<p>Its all working as a regular Rxjs.Subject() but I need the replay feature. I am on rxjs.beta-12</p>

<h3>Updated Logs</h3>

<pre><code>I am UserService. Just got created
Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.
Native: tried calling StatusBar.styleDefault, but Cordova is not available. Make sure to include cordova.js or run in a device/simulator
Http call received a USER
Called next 
User service got a USER
Login Component got a Replayed USER
I am UserService. Just got created
Dashboard component
</code></pre>
","3074508","","3074508","","2016-10-04 19:03:58","2016-10-05 20:02:30","RxJs ReplaySubject does not replay on Ionic2","<angular><ionic2><rxjs5>","1","10","","","","CC BY-SA 3.0"
"39857792","2","","39856187","2016-10-04 16:51:23","","1","","<p>Based on your code (which is essentially correct) and testing, your problem is that the <code>UserService</code> is getting recreated for each component that needs it.  You need to make it a ""singleton service"", which just means a single instance will get shared with all components that need it.</p>

<p>I am not familiar with Ionic.  Here's <a href=""https://forum.ionicframework.com/t/how-to-create-a-singleton-service/40113/6"" rel=""nofollow"">one thread</a> you can try.  If it doesn't help, I suggest you open a second SO question asking how to make your UserService a singleton in Ionic.</p>

<p>Apparently changing your <code>DashboardPageComponent</code>'s constructor to declare the <code>_user</code> property to be public instead of private will allow Ionic to inject the same instance instead of making a new one.  <a href=""https://forum.ionicframework.com/t/rc0-typescript-private-vs-public-keyword/64863"" rel=""nofollow"">https://forum.ionicframework.com/t/rc0-typescript-private-vs-public-keyword/64863</a></p>
","674326","","674326","","2016-10-05 20:02:30","2016-10-05 20:02:30","","","","4","","","","CC BY-SA 3.0"
"39901168","1","41024204","","2016-10-06 16:25:54","","0","750","<p>I am developing an application on Ionic2/rc0. I got a ReplaySubject on a singlenton service that keeps the current user consistent across the whole app. It all works fine, I can subscribe to it and get a User object as easy as</p>

<pre><code>    this._user.Current.subscribe(user=&gt;{ console.log(user)});
</code></pre>

<p>The User object looks like this</p>

<pre><code>User {
    confirmed:true
    devices:[""57f65werwe343bn8843f7h"",""7yr3243h5429hf2hjd""]
    friends:[""t245y53h65346htyh"",""356ytrer75dfhg43we56df""]
    email:""francescoaferraro@gmail.com""
    id:""57f6525e926bbc7615fc5c5c""
    notification:false            
    password=""$2a$04$.Fk/8eMj18ZrkfurbbdP4uT3yOs7Lb9db74GkNfgtABVY.ez2Q0I.""
    picture:""https://api.cescoferraro.xyz/kitty""
    role:""master""
    username:""cesco""
}
</code></pre>

<p>As you can see my backend is using MongoDB with One-to-Many Relationships with Document References as described <a href=""https://docs.mongodb.com/manual/tutorial/model-referenced-one-to-many-relationships-between-documents/"" rel=""nofollow"">here</a>. </p>

<p>I have created a devices tab where I want to display all data about those user devices, but I need to call this._devices.info for each one of current.devices and concat the result back to TrueDevices</p>

<pre><code>@Component({
    template: `  
            &lt;ion-header&gt;
                &lt;ion-navbar&gt;
                    &lt;ion-title&gt;Tabs&lt;/ion-title&gt;
                &lt;/ion-navbar&gt;
            &lt;/ion-header&gt;
            &lt;ion-content&gt;
                &lt;h2&gt;Device:list&lt;/h2&gt;

                &lt;h2 *ngFor=""let item of devices | async""&gt;{{item}}&lt;/h2&gt;

                &lt;button ion-button (click)=""readDevice()""&gt;Read Random Device&lt;/button&gt;
            &lt;/ion-content&gt;
`
})
export class DeviceComponent {
    devices: Observable&lt;string[]&gt;;
    TrueDevices: Observable&lt;Device[]&gt;;

    constructor(public _user: UserService, public _device: DeviceService) {

        this._user.Current.subscribe(user=&gt;{ this.devices = Observable.of(user.devices)});

        // Get current User
        // call this._devices.info for each one of current.devices
        // concat the result back to TrueDevices
        this._user.Current
            .subscribe((result) =&gt; { console.log(result) });

    }

    readDevice(){
        console.log(this.devices);
        this._device.info(this.devices.value[0]).subscribe(data=&gt;console.log(data))
    }
}
</code></pre>

<p>I will need to repeat the same procedure to the friends tab and so on. I am pretty sure there are a couple operators that would do the magic, but I am fairly new to rxjs and not familiar with all of them. Whats the right approach?</p>
","3074508","","","","","2016-12-08 02:58:01","Rxjs workflow for MongoDB Document References","<mongodb><angular><ionic2><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39903941","1","","","2016-10-06 19:11:11","","0","132","<p>I have a stream of data from car auctions.  Each car auction has n-number of lanes.  I want to log the auction of each vehicle.</p>
<p>The stream looks something like this...</p>
<p>--{lane: 1, action: bid} --- { lane: 2, action: start} --- { lane:1, action: bid} --- {lane: 2, action: bid} --- {lane:1, action: sold} ---</p>
<p>I have the following to buffer each auction lane and close the buffer on sale...</p>
<pre><code>const bufferOpen$= auctionWebSocketStream$
    .filter(stream =&gt; stream.tag === 'CURITEM');

const bufferClose$ = () =&gt; auctionWebSocketStream$.filter(stream =&gt; stream.tag === 'SOLD');

auctionWebSocketStream$
  .bufferToggle(bufferOpen$, bufferClose$)
  .subscribe(x =&gt; console.log(x));
</code></pre>
<p>The above works fine so long as there is one auction and one lane.  With multiple lanes, there's bid/sale information about multiple lanes.</p>
<p>How would I aggregate the stream by lanes into the buffer?  Similar solutions always had known aggregation parameters.  But I need to split the stream anytime there's a new lane.</p>
<p>Help is greatly appreciated.</p>
<h1>UPDATE</h1>
<p>I made a JSBin to show off my frustration and cluelessness.  It gives an example input stream and explains the desired output.</p>
<p><a href=""http://jsbin.com/tuxitev/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/tuxitev/edit?js,console</a></p>
<p>(For bonus points, it only shows empty arrays under Babel.  Not sure why Typescript is required)</p>
","5220820","","-1","","2020-06-20 09:12:55","2016-10-07 16:49:15","How to dynamically route RxJS streams","<rxjs><rxjs5>","1","7","","","","CC BY-SA 3.0"
"39914803","1","39980318","","2016-10-07 10:13:29","","0","563","<p>I'm trying to get the specific <strong><em>Item</em></strong>, for example, <code>{ key: ""321"" }</code>, from <code>ngrx/store</code> based on route parameter. I got it working like this:</p>

<pre><code>this.route.params
  .map((params: any) =&gt; params.key)

  .mergeMap((key: string) =&gt; {

    return this.store.select(state =&gt; state.items)

      .mergeMap((items: Observable&lt;any[]&gt;) =&gt; items)

      // .do(item =&gt; console.log(item, key))

      .filter((item: any) =&gt; item.key === key);
  })
  .take(1)
  .subscribe(console.log);
</code></pre>

<p>where <code>state.items</code> is an array of objects, like: <code>[ {key: ""1""}, {key: ""2""}, ...]</code> that fills over time.</p>

<p>I'm wondering is there a better/different way to do this? </p>

<p>Also, why do I get same item multiple (<code>state.items.length</code>) times before <code>.take(1)</code>?</p>
","1876949","","","","","2016-10-11 14:59:09","Flatten an Observable","<angular><rxjs5><ngrx>","1","2","","","","CC BY-SA 3.0"
"39919530","1","39924589","","2016-10-07 14:22:16","","1","590","<p>I am trying to use the ""take"" operator in my code (learning rxjs) but it is not sending the top 5 like I want.  my simple code is below, anyone have any idea how to help?</p>

<pre><code>countries: Observable&lt;Country[]&gt;;

private searchTerms = new Subject&lt;string&gt;();

this.countries = this.searchTerms.debounceTime(300).distinctUntilChanged().switchMap(  
            searchTerm =&gt; searchTerm ? this.countrySearchService.search(searchTerm) : observable.of&lt;Country[]&gt;([])) 
            .take(5);
</code></pre>
","6937746","","","","","2016-10-07 19:32:36","rxjs and angular 2 and the use of the ""take"" operator","<angular><rxjs5>","1","2","","","","CC BY-SA 3.0"
"39924589","2","","39919530","2016-10-07 19:32:36","","0","","<p>After reading your comment, I understand you need the first 5 countries. Now note that your observable emits arrays of countries and not countries. The reason you use Observable.of instead of Observable.from. So, the right syntax should be:</p>

<pre><code>this.countries = this.searchTerms.debounceTime(300).distinctUntilChanged().switchMap(  
        searchTerm =&gt; searchTerm ? this.countrySearchService.search(searchTerm) : observable.from&lt;Country[]&gt;([])) 
        .take(5);
</code></pre>

<p>If you want a sample that demonstrate various use cases, have a look at <a href=""http://jsbin.com/jusuzep/edit?js,console"" rel=""nofollow"">this jsbin</a>.</p>
","242098","","","","","2016-10-07 19:32:36","","","","0","","","","CC BY-SA 3.0"
"39928183","1","","","2016-10-08 02:47:47","","6","6004","<p>I am using Angular 2 HTTP library which returns an observable.
I want to implement retry on certain error status/code.</p>

<p>I have an issue, if the error is not 429, <code>Observable.of(error)</code> is getting executed in error case to retry, but when all your 2 retry fails the execution of flow goes to success block instead of catch block.</p>

<p>How to make execution of flow to catch block in all retry fails?</p>

<pre><code>    return this.http.get(url,options)
           .retryWhen((errors) =&gt; {
                      return errors
                            .mergeMap((error) =&gt; (error.status === 429) ? Observable.throw(error) : Observable.of(error))
                            .take(2);
                     })
                       .toPromise()
                       .then((res:Response) =&gt; console.log('In Success Block'))
                       .catch((res) =&gt; this.handleError(res));
</code></pre>

<p>will it resolve my problem</p>

<pre><code>        return this.http
  .post(url, JSON.stringify(body), requestOptions).retryWhen((errors) =&gt; {
    return errors
      .mergeMap((error) =&gt; (error.status === 404) ? Observable.throw(error) : Observable.of(error))
      .take(2);
  }).map((res:Response) =&gt;{
    if (res.status === 200)
      return res;
    else
      return Observable.throw(res);
  })
  .toPromise();
</code></pre>
","6939915","","4720935","","2017-10-31 16:01:03","2018-01-22 09:19:10","Angular 2 RxJS Observable: RetryWhen filter retry on error Status","<angular><typescript><observable><rxjs5><angular2-http>","1","1","3","","","CC BY-SA 3.0"
"39934677","1","","","2016-10-08 16:26:18","","1","1235","<p>I'm looking for some guidance on the correct way to setup a WebSocket connection with RxJS 5. I am connecting to a WebSocket that uses JSON-RPC 2.0. I want to be able to execute a function which sends a request to the WS and returns an Observable of the associated response from the server.</p>

<p>I set up my initial WebSocketSubject like so:</p>

<p><code>const ws = Rx.Observable.webSocket(""&lt;URL&gt;"")</code></p>

<p>From this observable, I have been able to send requests using <code>ws.next(myRequest)</code>, and I have been able to see responses coming back through the ws` observable.</p>

<p>I have struggled with creating functions that will filter the ws responses to the correct response and then complete. These seem to complete the source subject, stopping all future ws requests. </p>

<p>My intended output is something like:</p>

<pre><code>function makeRequest(msg) {
    // 1. send the message
    // 2. return an Observable of the response from the message, and complete
}
</code></pre>

<p>I tried the following:</p>

<pre><code>function makeRequest(msg) {
    const id = msg.id;
    ws.next(msg);
    return ws
        .filter(f =&gt; f.id === id)
        .take(1);
}
</code></pre>

<p>When I do that however, only the first request will work. Subsequent requests won't work, I believe because I am completing with <code>take(1)</code>?</p>

<p>Any thoughts on the appropriate architecture for this type of situation?</p>
","5880623","","","","","2016-10-09 03:28:03","RxJS5 WebSocketSubject - how to filter and complete messages?","<websocket><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"39947383","1","39947504","","2016-10-09 19:01:41","","4","928","<p>By default <strong>RxJs Subject</strong> is ""<strong><em>Hot</em></strong>"", but is it possible to create ""<strong><em>Cold</em></strong>"" Subject to get all the values propagated from it from the beginning?</p>

<p>i.e.:</p>

<pre><code>let s = new Subject();
s.next(1);
s.next(2);
s.subscribe(n =&gt; console.log(n)); //to get here 1 2 3
s.next(3);
</code></pre>
","274500","","","","","2016-10-09 19:14:34","How could I create Cold Subject in RxJS?","<rxjs5>","2","0","","","","CC BY-SA 3.0"
"39947504","2","","39947383","2016-10-09 19:14:34","","3","","<p>You can use a ReplaySubject to do this. The one thing to keep in mind is that a ReplaySubject expects a number during creation to know how many values it should buffer. You cannot buffer all the elements.</p>

<pre><code>const subject = new Rx.ReplaySubject(10);

subject.next(""1"");
subject.next(""2"");
subject.next(""3"");
subject.next(""4"");
subject.next(""5"");

subject.subscribe(
  (val) =&gt; console.log(val)
);    

subject.next(""6"");

// Logs out 
// 1
// 2
// 3
// 4
// 5
// 6
</code></pre>

<p>jsbin: <a href=""http://jsbin.com/rocofa/edit?js,console"" rel=""nofollow"">http://jsbin.com/rocofa/edit?js,console</a></p>
","1018598","","","","","2016-10-09 19:14:34","","","","1","","","","CC BY-SA 3.0"
"39949655","1","","","2016-10-09 23:43:21","","1","1790","<p>I do know that RxJs <code>observables</code> are async collections that yield over time when the <code>Observable</code> is being subscribed.</p>

<p>Now I would like to use RxJs operators as Linq operators. My question is how can I use the RxJs operators on <code>Array</code> instead of <code>Observables</code>.</p>

<p>For example I would like to know how many instances matches of an <code>Array</code> collection matches a specific filter:</p>

<pre><code>let countMatchingMembers = (collection: Array&lt;any&gt;): number =&gt; {
    // I want to use on collection instead of Rx.Observable
    const matchingMembersObservable = Rx.Observable.from(collection) 
      .filter(p =&gt; {
        return p.value !== null &amp;&amp; typeof p.value !== ""undefined"";
      });

    return matchingMembersObservable.count() &gt; 0;
}
</code></pre>
","2315511","","","","","2016-10-10 12:27:36","Use RxJs operators on Array","<arrays><linq><rxjs><rxjs5>","2","4","","","","CC BY-SA 3.0"
"39950381","1","39951716","","2016-10-10 02:00:19","","1","364","<p>I'm trying to teach myself some reactive functional programming. This <a href=""https://slack-redir.net/link?url=https%3A%2F%2Fegghead.io%2Flessons%2Frxjs-what-is-rxjs"" rel=""nofollow"">video</a> from Ben Lesh is showing an example of an observable. My prior reading indicated that an observable is lazy, i.e., it only evaluates after being subscribed to. Strangely enough, this code doesn't require subscription to print to the console.</p>

<pre><code>var Rx = require('rxjs/Rx')

var source = Rx.Observable.from([1,2,3,4,5]);

var newSource = source.filter(x =&gt; x % 2 === 1)
                .map(x =&gt; x + '!')
                .forEach(x =&gt; console.log(x));
</code></pre>

<p>From the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-forEach"" rel=""nofollow"">RxJS docs</a>:</p>

<p>It seems as though the Observable must be actively resolving the promises emitted by .forEach, I am <em>so</em> confused by this.</p>

<p>Further confusion stems from this code:</p>

<pre><code>var Rx = require('rxjs/Rx')

var source = Rx.Observable.from([1,2,3,4,5]);

var newSource = source.filter(x =&gt; x % 2 === 1)
      .map(x =&gt; x + '!')
      .do(x =&gt; console.log(x));
</code></pre>

<p>Which does not evaluate until running <code>newSource.subscribe();</code>, please help me out to explain the difference behind the two operators here. </p>
","6946822","","","","","2016-10-10 05:23:21","forEach operator being evaluated without subscription","<javascript><functional-programming><rxjs><frp><rxjs5>","1","0","","","","CC BY-SA 3.0"
"39951716","2","","39950381","2016-10-10 05:23:21","","2","","<p>Observables are lazy by default. If you perform an operator on an observable, under the hood, rxjs will create a new observable for you that is linked to the previous one. Know that observables are immutable. </p>

<p>However, ForEach is a special kind of operator. It does not return a new Observable but it will subscribe onto the observable under the hood and perform a function on every element emitted by that observable. If you check the source code of the forEach implementation, which is on the Observable class itself you will see the following (just a snippet).</p>

<pre><code>const subscription = this.subscribe((value) =&gt; {
    if (subscription) {
      // if there is a subscription, then we can surmise
      // the next handling is asynchronous. Any errors thrown
      // need to be rejected explicitly and unsubscribe must be
      // called manually
      try {
        next(value);
      } catch (err) {
        reject(err);
        subscription.unsubscribe();
      }
</code></pre>

<p>Here we can see the observable is being subscribed to and the value is 'next'-ed. This next function is the function you pass to the forEach call.</p>
","1018598","","","","","2016-10-10 05:23:21","","","","2","","","","CC BY-SA 3.0"
"39980318","2","","39914803","2016-10-11 14:59:09","","1","","<p>The code is pretty good already but the inner mergeMap isn't necessary. The filter should actually be a map if I understand correctly. You are getting an array of items in the store.select statement and in your filter you are handling one item at a time. This shouldn't work since it's the array you're working on. Using a map we can get the item array as input and return the item that is actually the one we are looking for.</p>

<pre><code>this.route.params
  .map((params: any) =&gt; params.key)
  .mergeMap((key: string) =&gt; {
      return this.store.select(state =&gt; state.items)

         // no need for this mergeMap
         //.mergeMap((items: Observable&lt;any[]&gt;) =&gt; items)

         // map will actually get an array of items as input here
         // we want to get the element from the array matching 
         // the key from the route param and return the first element
         // =&gt; [0] since there should be only one
         .map((item: any[]) =&gt; items.filter((item) =&gt; item.key === key)[0];
})
.take(1)
.subscribe(console.log);
</code></pre>

<p>Jsbin with mocked working example: <a href=""http://jsbin.com/sihina/7/edit?js,console"" rel=""nofollow"">http://jsbin.com/sihina/7/edit?js,console</a></p>
","1018598","","","","","2016-10-11 14:59:09","","","","2","","","","CC BY-SA 3.0"
"39984059","2","","39258188","2016-10-11 18:21:10","","0","","<p>Based on your example I think you can further simplify your answer:</p>

<pre><code>var pictureSizes = [
  {width: 100, size: 'thumbnail', suffix: '_t'},
  {width: 300, size: 'small', suffix: '_s'},
  {width: 600, size: 'medium', suffix: '_m'},
  {width: 1000, size: 'large', suffix: '_l'}
];

const scaler$ = Rx.Observable.bindNodeCallback((binary, size, callback) =&gt; {
  gm(binary)
   .resize(size.width)
   .toBuffer('jpg', callback);
});

const readFile$ = Rx.Observable.bindNodeCallback(fs.readFile);
const writeFile$ = Rx.Observable.bindNodeCallback(fs.writeFile);

function scaleImage$(sizes) {
  const scales = Rx.Observable.from(sizes);

  return source =&gt; 
    source.flatMap(binary =&gt; 
      scales.flatMap(
        size =&gt; scaler$(binary, size),
        (pictureSize, binary) =&gt; ({pictureSize, binary})
      )
    );
}

function resize(imagePath, sizes) {
  return readFile$(imagePath)
    .let(scaleImage$(sizes))
    .flatMap(result =&gt; {
      const {pictureSize, binary} = result;
      const [name, ext] = image.split('.');
      return writeFile$(`./resized/${name}${pictureSize.suffix}.${ext}`, binary);
    });
}
</code></pre>

<p>Use:</p>

<pre><code>resize(imagePath, pictureSizes)
  .subscribe();
</code></pre>
","2521865","","2521865","","2016-10-11 18:50:53","2016-10-11 18:50:53","","","","3","","","","CC BY-SA 3.0"
"39991935","1","39992839","","2016-10-12 06:34:50","","1","612","<p>I am currently updating the dependencies of my project which uses the Angular2 npm packages and therefore RxJs as well. I am updating to the 2.0.2 stable release of angular which depends on Rx5 beta.12.
For my web application i only deploy the Rx.min.js bundle and load it with a script tag in my index.html file. That approach worked perfectly before with the Rx umd bundle, but causes errors meanwhile, since it appears to me that the contributors of RxJs dropped the different bundle versions for the sake of one common bundle file. i.e. Rx.js instead of Rx.umd.js and so on.</p>

<p>I am using SystemJs module loader and if i do no additional steps these errors will occur with any symbol of the RxJs Framework:</p>

<pre><code>GET http://localhost:8080/rxjs/Subject.js 404 (Not Found)
</code></pre>

<p>I recognized that Rx is now globally defined (window.Rx) and contains all the necessary stuff. So i tried to define those symbols in SystemJs manually by doing smth like this:</p>

<pre><code>function defineGlobalModule( parentModuleName, simpleName, moduleValue ) {
  var fqModuleName = parentModuleName + simpleName;
  System.amdDefine( fqModuleName, [""require"", ""exports""], function (require, exports) {
       ""use strict"";
       exports[ simpleName ] = moduleValue;
  }); 

  if( typeof moduleValue === ""object"" )
     for( var key in moduleValue )
       defineGlobalModule( fqModuleName + ""/"", key, moduleValue[ key ] )
}

defineGlobalModule( """", ""rxjs"", global.Rx );
</code></pre>

<p>That made the 'rxjs/Subject' style imports work again. But now i get lots of errors like this:</p>

<pre><code>GET http://localhost:8080/rxjs/operator/toPromise.js 404 (Not Found)
GET http://localhost:8080/rxjs/observable/fromPromise.js 404 (Not Found)
</code></pre>

<p>These files are imported by the angular forms.umd.js bundle for example.</p>

<p>What is the state of the art for Angular2 2.0.x when it comes to importing the Rx.js <strong>bundle</strong> without deploying the node_module itself. I need the bundled version! I was using the umd version of the Rx.js bundle before which seems not to exist anymore.</p>
","1173210","","310726","","2016-10-12 07:32:18","2016-12-02 16:38:37","Angular2 2.0.x and Rx 5 beta.12 bundle","<angular><rxjs><systemjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"39992839","2","","39991935","2016-10-12 07:28:26","","1","","<p>I did maybe exactly what you're looking for with <code>Angular2</code> and <code>rxjs@5.0.0-beta.12</code> which is now distributed as <code>globals</code> and the <code>umd</code> package is probably not supported any more (just as you said):</p>

<p>See live demo: <a href=""https://plnkr.co/edit/z4gg2XBoQDgYXev0Csuq"" rel=""nofollow"">https://plnkr.co/edit/z4gg2XBoQDgYXev0Csuq</a></p>

<p>Basically, I just updated my SystemJS config:</p>

<pre><code>paths: {
  'rxjs*': 'https://unpkg.com/@reactivex/rxjs@5.0.0-beta.12/dist/global/Rx.js'
},
</code></pre>

<p>Then I removed <code>rxjs</code> from <code>map</code> list. Now it loads a single <code>Rx.js</code> file.</p>
","310726","","310726","","2016-10-12 07:35:34","2016-10-12 07:35:34","","","","1","","","","CC BY-SA 3.0"
"39994096","1","40015615","","2016-10-12 08:37:29","","5","5393","<p>I'm using an <code>IntervalObservable</code> to make continuous calls to the server side of my application. I can subscribe and unsubscribe to to the Oberservable and everything works fine with one exception:</p>

<p>The first call to the server is delayed, but I want it to be instant. The behaviour of the <code>IntervalObservable</code> is in principle correct, but does not match my requirements.</p>

<pre><code>@Injectable()
export class LoggerService {
  constructor(private http: Http) { }
  private apiURL = 'assets/file.json'; 

  getList() {
       return IntervalObservable.create(1000).flatMap(() 
       =&gt; this.http.get(this.apiURL))
      .map(this.extractData)
      .catch(this.handleError);
  }
  private extractData(res: Response) {
    var fooot = new Foo();
    fooot.fillFromJSON(JSON.stringify(res.json()));
    return fooot;
  }

  private handleError(error: any) {
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : 'Server error';
    console.error(errMsg);
    return IntervalObservable.throw(errMsg);
  }
}
</code></pre>

<p>So how can I call the server instant on the first call and afterwards with the defined delay?</p>
","1632341","","310726","","2016-10-12 09:08:38","2017-10-06 10:14:30","Start first call of IntervalObservable instant","<angular><typescript><rxjs><rxjs5>","4","0","1","","","CC BY-SA 3.0"
"40002662","1","40002867","","2016-10-12 15:34:25","","2","1511","<p>I am using an application state service based on <code>BehaviorSubject</code>s in Rx which exposes <code>Observables</code> for components to work with. In one of my components I want to show some nested data if its present.  </p>

<p>This is what I was trying</p>

<pre><code>&lt;div&gt;&gt;{{  sharedState.loadedAccountDetails.accountId | async }}&lt;/div&gt;
</code></pre>

<p>Which yields me an error about not being able to get account Id of undefined which makes sense to me but I thought perhaps the async pipe would help me out here. </p>

<p>In my component shared state is just an <code>Observable</code> I don' think there is much to show. </p>

<p>Ultimately, I want to show this data when its present and display nothing when its not there. How can I achieve this?</p>
","112665","","310726","","2016-10-12 15:53:01","2016-10-12 15:53:01","Display nested data from observable in Angular 2 view","<angular><rxjs><angular2-template><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40002867","2","","40002662","2016-10-12 15:45:05","","4","","<p>You need to use the <code>async</code> pipe directly on the Observable, not values emitted from Observable. In your template use this instead:</p>

<pre><code>&lt;div&gt;{{ (sharedState | async)?.loadedAccountDetails.accountId }}&lt;/div&gt;
</code></pre>

<p>With the following component:</p>

<pre><code>import { Component } from '@angular/core';
import { Observable, Subject } from 'rxjs';

@Component({
  selector: 'my-app',
  template: `
    I'm Loaded!
    &lt;div&gt;{{ (sharedState | async)?.loadedAccountDetails.accountId }}&lt;/div&gt;
  `
})
export class AppComponent {

  sharedState: Observable = null;
  private subject = new Subject();

  constructor() {
    this.sharedState = this.subject.asObservable();
    setTimeout(_ =&gt; {
       this.subject.next({
         loadedAccountDetails: {
           accountId: 42
         }
       });
    }, 1000);
  }

}
</code></pre>

<p>This demo shows number <code>42</code> one second after the component has been created.</p>

<p>See live demo: <a href=""http://plnkr.co/edit/fGtNVOZWndYU22U4sRow"" rel=""nofollow"">http://plnkr.co/edit/fGtNVOZWndYU22U4sRow</a></p>
","310726","","","","","2016-10-12 15:45:05","","","","3","","","","CC BY-SA 3.0"
"40013024","1","40014686","","2016-10-13 05:35:32","","0","1486","<p>When I extend <code>Http</code> class to add a timeout setter using rxjs, the <code>timeout</code> operator doesn't work when I import it like this <code>import 'rxjs/add/operator/timeout'</code></p>

<p>It only works when I load the entire rxjs library</p>

<p><a href=""https://plnkr.co/edit/kQTFLWjZ8lEtlN3Oe1wu?p=preview"" rel=""nofollow"">live plnkr</a></p>

<pre class=""lang-js prettyprint-override""><code>import {Component, NgModule} from '@angular/core'
import {BrowserModule} from '@angular/platform-browser'
import {Observable} from 'rxjs/Observable'
import 'rxjs/add/operator/timeout'
import {HttpModule, RequestOptions, XHRBackend} from ""@angular/http"";

import {WpHttp} from ""../wpHttp"";

@Component({
  selector: 'my-app',
  template: `
    &lt;div&gt;
      &lt;h2&gt;Hello {{name}}&lt;/h2&gt;
    &lt;/div&gt;
  `,
})
export class App {
  name:string;
  constructor(private wpHttp: WpHttp) {
    //this.name = 'Angular2'
  }

  ngOnInit(){
    this.wpHttp.get(""../test.json"").subscribe((res)=&gt;{
      this.name = res.title;
    });
  }
}

@NgModule({
  imports: [ BrowserModule, HttpModule ],
  declarations: [ App ],
  providers: [
    {
      provide: WpHttp,
      useFactory: (backend: XHRBackend, defaultOptions: RequestOptions) =&gt;
        new WpHttp(backend, defaultOptions),
      deps: [XHRBackend, RequestOptions]

    }
  ],
  bootstrap: [ App ]
})
export class AppModule {}
</code></pre>

<p>Extended Http</p>

<pre class=""lang-js prettyprint-override""><code>import {Injectable} from '@angular/core';
import {Http, RequestOptions, RequestOptionsArgs, ConnectionBackend} from '@angular/http';

import {Observable} from 'rxjs/Observable';


@Injectable()
export class WpHttp extends Http {

  constructor(backend: ConnectionBackend,
              defaultOptions: RequestOptions) {
    super(backend, defaultOptions);
  }


  get(url): Observable&lt;any&gt; {

    console.log(""started"")
    return super.get(url)

      .timeout(""500"", new Error('delay exceeded'))
      .catch((err) =&gt; {
        return Observable.throw(err);
      })
      .finally(() =&gt; {
        console.log(""finished"")
      });
  }


}
</code></pre>
","1015648","","217408","","2016-10-13 05:44:19","2017-11-17 10:01:10","Angular2 Timeout operator doesn't work on extended Http","<angular><rxjs><rxjs5>","1","10","1","","","CC BY-SA 3.0"
"40014686","2","","40013024","2016-10-13 07:21:15","","2","","<p>It is fixed by adding all the used operators</p>

<pre><code>import 'rxjs/add/operator/timeout';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/finally';
import 'rxjs/add/operator/map';
import 'rxjs/add/observable/throw';
import {Observable} from 'rxjs/Observable';
</code></pre>
","1015648","","1015648","","2017-11-17 10:01:10","2017-11-17 10:01:10","","","","0","","","","CC BY-SA 3.0"
"40015615","2","","39994096","2016-10-13 08:11:33","","9","","<p>Two things, </p>

<ol>
<li>You can use the factory methods instead of the derived types, i.e. <code>Observable.interval(3000)</code> instead of <code>IntervalObservable.create</code></li>
<li><p>You can use <code>timer</code> to do it with a single operator instead:</p>

<pre><code>return Observable.timer(0, 1000)
  .flatMapTo(this.http.get(this.apiURL))
  .map(this.extractData)
  .catch(this.handleError);
</code></pre></li>
</ol>
","2521865","","","","","2016-10-13 08:11:33","","","","1","","","","CC BY-SA 3.0"
"40020557","1","40023742","","2016-10-13 12:06:25","","2","1207","<p>I want to extend the rxjs5 <code>Observable</code> class with a <strong>static</strong> function. I can to this in plain JavaScript:</p>

<pre><code>var myStaticFn = function() { /* ... */Â };
Observable.myStaticFn = myStaticFn;
</code></pre>

<p>this works, but in TypeScript I can't aaccess <code>Observable.myStaticFn</code> as the property <code>myStaticFn</code> is not known on the class <code>Observable</code>.</p>

<p>How do I declare/augment the rxjs5 Module <code>Observable</code> class, so that I can access my function in a type-safe manner?</p>

<p><em>Note: As a starting point, the following shows an example how to extend a <strong>non-static</strong> function to the Observable (for example to create a custom rxjs Operator), and this completely works but is not what I want!</em></p>

<pre><code>function myOperator(this: Observable&lt;any&gt;): Observable&lt;any&gt; = function(){ /*...*/ };
Observable.prototype.myOperator = myOperator;

declare module ""rxjs/Observable"" {
    interface Observable&lt;T&gt; {
        myOperator: typeof myOperator;
    }
}
</code></pre>

<p>The above works, because the <code>declare</code> syntax of TypeScript allows me to treat the <code>Observable</code> as an interface, and interfaces can be augmented/merged. But there is no way in TypeScript to declare a <strong>static</strong> function on an interface.</p>

<p>It is also not feasible to derive from the <code>Observable</code> class, say <code>ExtendedObservable</code> because every user of my code would have to use the <code>ExtendedObservable</code> type instead of the <code>Observable</code> type throughout the project, and the concept additionally fails if I want to put different static methods on the Observable, depending on the imported modules.</p>
","777928","","","","","2016-10-13 14:30:06","Extend a class from an external library with a static function in a typesafe manner in TypeScript","<javascript><typescript><static><rxjs><rxjs5>","3","1","1","","","CC BY-SA 3.0"
"40023742","2","","40020557","2016-10-13 14:24:31","","8","","<p>I found it out myself looking <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/add/observable/from.ts"" rel=""noreferrer"">at the implementation of the static <code>.from()</code> extension in the RxJS source</a>:</p>

<pre><code>import { myStaticFn as myStaticFnStatic } from ""./myStaticFn"";

declare module ""rxjs/Observable"" {
    namespace Observable {
        let myStaticFn: myStaticFnStatic;
    }
}
</code></pre>

<p>Note how I import <code>myStaticFn</code> but scope it locally to the name <code>myStaticFnStatic</code> - this is required else you get a compiler error.</p>
","777928","","","","","2016-10-13 14:24:31","","","","1","","","","CC BY-SA 3.0"
"40026502","1","40028455","","2016-10-13 16:34:30","","1","1575","<p>I can't explain to myself this </p>

<pre><code>const something = new Rx.BehaviorSubject([1,2,4,4])
.distinct()
.do((s) =&gt; console.log(s))
.map(list =&gt; list.length)
.filter(length =&gt; length &gt;=2)
.subscribe(total =&gt; console.log('total:', total));
</code></pre>

<p>this is what I get as output</p>

<pre><code>[1, 2, 4, 4]
""total:""
 4
</code></pre>

<p>I get confused because reviewing the docs on distinct I thought it would work for numbers.  My use case is a data table widget sends me events and this array tracks which row they clicked and I want to detect once a double click occurred.</p>

<p>updated code</p>

<pre><code>const something = new Rx.BehaviorSubject([]);
</code></pre>

<p>something.next([1]);
console.log(something.getValue());
something.next(something.getValue().concat(2));
something.next(something.getValue().concat(3));
something.next(something.getValue().concat(4));
something.next(something.getValue().concat(4));</p>

<p>something
.distinct()
.subscribe(val => console.log('value:', val));</p>

<p>output</p>

<pre><code>""value:""
[1, 2, 3, 4, 4]
</code></pre>
","112665","","112665","","2016-10-13 18:21:21","2016-10-13 18:32:43","Rxjs distinct and arrays of numbers","<rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"40028455","2","","40026502","2016-10-13 18:32:43","","2","","<p>You're sending a value that happens to be an array. You would see the operation of distinct if you did</p>

<pre><code>const something = new Rx.BehaviorSubject([]);
something .distinct() .subscribe(val =&gt; console.log('value:', val));
something.next(1); // --&gt; value: 1
something.next(2); // --&gt; value: 2
something.next(1); // no output (because of distinct)
something.next(3); // --&gt; value: 3
</code></pre>
","1207583","","","","","2016-10-13 18:32:43","","","","5","","","","CC BY-SA 3.0"
"40046558","1","40052330","","2016-10-14 15:14:09","","1","1518","<p>I'm building an Angular2 app, so I'm getting used to Observables and Reactive Extensions as a whole. I'm using TypeScript and rxjs.</p>

<p>Now I've got an observable, or a stream if you will, of an array of some objects. Let's say Person-objects. Now I've got two other streams of Person-objects and want to combine these so I get a stream which is always up to date:</p>

<pre><code>var people$ = getPeople();                  // Observable&lt;Person[]&gt;
var personAdded$ = eventHub.personAdded;    // Observable&lt;Person&gt;;
var personRemoved$ = eventHub.personRemoved // Observable&lt;Person&gt;;

var allwaysUpToDatePeople$ = people$.doSomeMagic(personAdded$, personRemoved$, ...);
</code></pre>

<p>If the people-stream emits an array of, let's say, 5 people, and after that the personAdded-stream emits a person, the allPeople-stream wil emit an array of 6. 
If the personRemoved-stream emits a person, the allPeople-stream should emit an array of Person-objects without the one just emitted by the personRemoved-stream.</p>

<p>Is there a way built into rxjs to get this behaviour?</p>
","709455","","","","","2019-09-06 18:44:48","Combine multiple Observables with different actions/operations","<angular><rxjs><rxjs5><reactive-extensions-js><angular2-observables>","2","0","","","","CC BY-SA 3.0"
"40052330","2","","40046558","2016-10-14 21:33:26","","2","","<p>My suggestion is that you wrap the idea of an <code>action</code> into a stream which can then be merged and applied directly to the <code>Array</code>.</p>

<p>The first step is to define some functions that describe your actions:</p>

<pre><code>function add(people, person) {
  return people.concat([people]);
}

function remove(people, person) {
  const index = people.indexOf(person);
  return index &lt; 0 ? people : people.splice(index, 1);
}
</code></pre>

<p>Note: we avoid mutating the Array in place because it can have unforeseen side effects. Purity demands that we create a copy of the array instead.</p>

<p>Now we can use these functions and lift them into the stream to create an <code>Observable</code> that emits functions:</p>

<pre><code>const added$ = eventHub.personAdded.map(person =&gt; people =&gt; add(people, person));
const removed$ = eventHub.personRemoved.map(person =&gt; people =&gt; remove(people, person));
</code></pre>

<p>Now we get events in the form of: <code>people =&gt; people</code> where the input and output will be an array of people (in this example simplified to just an array of strings).</p>

<p>Now how would we wire this up? Well we really only care about adding or removing these events <em>after</em> we have an array to apply them to:</p>

<pre><code>const currentPeople = 

  // Resets this stream if a new set of people comes in
  people$.switchMap(peopleArray =&gt; 

    // Merge the actions together 
    Rx.Observable.merge(added$, removed$)

      // Pass in the starting Array and apply each action as it comes in
      .scan((current, op) =&gt; op(current), peopleArray)

      // Always emit the starting array first
      .startWith(people)
  )
  // This just makes sure that every new subscription doesn't restart the stream
  // and every subscriber always gets the latest value
  .shareReplay(1);
</code></pre>

<p>There are several optimizations of this technique depending on your needs (i.e. avoiding the function currying, or using a binary search), but I find the above relatively elegant for the generic case.</p>
","2521865","","3587715","","2019-09-06 18:44:48","2019-09-06 18:44:48","","","","1","","","","CC BY-SA 4.0"
"40052529","1","40052986","","2016-10-14 21:51:15","","3","3900","<p>I know observables in RxJS 5 (and elsewhere) are lazily executed. In other words, they aren't executed until there is a subscriber. However, I'm trying to prefetch some data. Is there a way to trigger the observable before subscribing to it?</p>

<pre><code>let obs = Rx.Observable.create(observer =&gt; {
  console.log('Observer executed');
  // This would actually be fetching data from a server:
  observer.next(42);
});

// Something like obs.warmup() happens here
console.log('Observer is ideally called before this point.');

// Some time later this is called, and hopefully the data is already retrieved.
obs.subscribe(value =&gt; {
  console.log('Got ' + value);
});
</code></pre>
","40736","","","","","2016-10-14 22:41:59","In RxJS 5, is there a way to trigger an Observable before subscribing to it?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"40052986","2","","40052529","2016-10-14 22:41:59","","8","","<p>You would like to make a cold observable hot. (<a href=""https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339#.sbyzhoqun"" rel=""noreferrer"">what are hot and cold observables</a>)</p>

<p>So if you already have a cold observable you can use the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/publish.md"" rel=""noreferrer"">publish</a> operator alongside with <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/connect.md"" rel=""noreferrer"">connect</a>.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let obs = Rx.Observable.create(observer =&gt; {
  console.log('Observer executed');
  // This would actually be fetching data from a server:
  observer.next(42);
}).publish(); // create a ConnectableObservable

obs.connect(); // Run the observer

// Something like obs.warmup() happens here
console.log('Observer is ideally called before this point.');

// Some time later this is called, and hopefully the data is already retrieved.
obs.subscribe(value =&gt; {
  console.log('Got ' + value);
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.0-rc.1/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>But usually there is a much simpler way. I assume you have an external source of events, which you want to convert to an observable. The correct way is to use a <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md"" rel=""noreferrer"">Subject</a>.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let obs = new Rx.Subject();

console.log('Observer executed');
obs.next(42); // subscribers would receive this... 
// it could be something like `service.on(""event"", e =&gt; obs.next(e));`

// Something like obs.warmup() happens here
console.log('Observer is ideally called before this point.');

// Some time later this is called, and hopefully the data is already retrieved.
obs.subscribe(value =&gt; {
  console.log('Got ' + value);
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.0-rc.1/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","5108418","","","","","2016-10-14 22:41:59","","","","1","","","","CC BY-SA 3.0"
"40063504","1","40063711","","2016-10-15 19:47:56","","0","1118","<p>I am writing an ng2 app and use an application state service based on behavior subjects that expose observables. For the majority of the use cases I want to use observable A to look up a nested object.  I found an odd case where Observable A won't have this data but its in Observable B. Observable A &amp; B are both available from my application state service. </p>

<p>Right now in my component it looks like this</p>

<pre><code>  sharedState: Observable&lt;any&gt;;

  constructor(private appStateService: AppStateService) {
    this.sharedState = appStateService.shared$;
  }
</code></pre>

<p>Then in my view : </p>

<pre><code>&lt;div&gt;{{ (sharedState | async)?.loadedAccountDetails?.accountId }}&lt;/div&gt;
</code></pre>

<p>As one example. What I imagine I need to do now in the component is:</p>

<ol>
<li>Subscribe to Observable A and check if it has my loadedAccountDetails and account Id etc</li>
<li>If A doesn't have this value then go with B </li>
</ol>

<p>What I was hoping to do in the component as well was only expose/have one instance variable that is an Observable so that I can keep my view/html the same.</p>

<p>Even if you are unfamiliar with Angular 2 I can work on that but need help understanding how to almost implement an if statement with observables.   </p>
","112665","","","","","2016-10-15 21:09:20","Choose one observable based on condition","<angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"40063711","2","","40063504","2016-10-15 20:09:13","","1","","<p>Try this:</p>

<pre><code>Observable
  // When any of the inner observables emit, supply latest from all
  .combineLatest(observableA, observableB)
  // Emit either result
  .map(([resultA, resultB]) =&gt; resultA || resultB)
  // Test it
  .subscribe(console.info)
</code></pre>

<p>Just make sure <code>observableA/B</code> doesn't emit anything if it doesn't find what you're looking for (use <code>.filter(Boolean)</code>, for example).</p>
","1876949","","1876949","","2016-10-15 20:32:11","2016-10-15 20:32:11","","","","9","","","","CC BY-SA 3.0"
"40074707","1","40074872","","2016-10-16 19:47:01","","8","1154","<p>I am using ngrx/effects.</p>

<p>After updating <strong>rxjs</strong> from <strong>5.0.0-beta.12</strong> to <strong>5.0.0-rc.1</strong>, my IDE WebStorm gives me the error below (red underline). And when I run my app, the same error also shows in the terminal.</p>

<blockquote>
  <p>Supplied parameters do not match any signature of call target.</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/SsxGk.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/SsxGk.png"" alt=""enter image description here""></a></p>

<pre><code>  @Effect() updateProfile$ = this.actions$
    .ofType(ProfileActions.PROFILE_UPDATE_PROFILE)
    .map&lt;string&gt;(toPayload)
    .switchMap(name =&gt; this.profileService.updateProfile(name)
      .map(name =&gt; ({ type: ProfileActions.PROFILE_UPDATE_PROFILE_SUCCESS, payload: name }))
      .catch(error =&gt; Observable.of({ type: ProfileActions.PROFILE_UPDATE_PROFILE_FAIL, payload: error }))
    );
</code></pre>

<p>.</p>

<pre><code>  updateProfile(name: string): Observable&lt;string&gt; {
    return Observable.of(name);
  }
</code></pre>

<ul>
<li><p>This error happens whenever I use <code>map&lt;string&gt;(toPayload)</code>. I tried to change to <code>.map&lt;any&gt;(action =&gt; action.payload)</code>, but still same error.</p></li>
<li><p>The effects without <code>map&lt;string&gt;(toPayload)</code> won't give the
error.</p></li>
</ul>

<p>Although it gives me the error, the app still runs well.</p>

<p>How to solve this issue?</p>
","2000548","","2000548","","2016-10-16 19:52:17","2016-10-16 20:04:33","ngrx: Supplied parameters do not match any signature of call target","<angular><typescript><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"40074872","2","","40074707","2016-10-16 20:04:33","","11","","<p>In rxjs 5.0.0-rc.1 the generic type parameters for all operators were changed to accept the type of the source observable first.</p>

<p>You will need to change the <code>map</code> operator call accordingly:</p>

<pre><code>actions$
  .ofType(ProfileActions.PROFILE_UPDATE_PROFILE)
  .map&lt;Action, string&gt;(toPayload)
</code></pre>
","397476","","","","","2016-10-16 20:04:33","","","","1","","","","CC BY-SA 3.0"
"40076953","1","40082814","","2016-10-17 00:25:48","","3","4902","<p>I would like to query an API every x seconds when subscribing to an autorefresher Observable, making sure that the last request has completed before sending another one.</p>

<pre><code>let autoRefresher = new Observable().exhaustMap(() =&gt; Observable.defer(() =&gt; {
    return someService.returningAPromise();
}).timeout(refreshIntervalInMs).repeat());
</code></pre>

<p>Is there a better way to do this? How could I update the refresh interval without creating a new observable each time?</p>
","2182142","","310726","","2016-10-17 09:29:30","2020-09-23 12:35:13","Rxjs: Repeat an Ajax Call Every X Seconds, but Wait for the Last One to Complete","<ecmascript-6><rxjs><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"40078602","1","","","2016-10-17 04:40:33","","0","323","<p>I am learning the Angular 2.</p>

<p>I am following exactly the tutorial Tour of Heroes (<a href=""https://angular.io/docs/ts/latest/tutorial/"" rel=""nofollow"">https://angular.io/docs/ts/latest/tutorial/</a>), I have everything work just fine.</p>

<p>Just one thing, it looks like the VS 2015 (with update 3) doesn't recognize extension functions from the Rxjs, can you advise how to fix it?</p>

<p><a href=""https://i.stack.imgur.com/FMA9g.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/FMA9g.png"" alt=""enter image description here""></a></p>

<p>I have all imported as in the tutorial</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Observable class extensions
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';

// Observable operators
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';</code></pre>
</div>
</div>
</p>

<p>a note while checking the file rxjs/add/operator/debounce.d.ts
the observable founder is not found, in fact the folder is there
<a href=""https://i.stack.imgur.com/sIT3E.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/sIT3E.png"" alt=""enter image description here""></a></p>
","523872","","","","","2017-04-20 01:48:09","Angular 2 - Rxjs Intelligent with VS 2015 update 3","<visual-studio><angular><rxjs5>","1","2","","","","CC BY-SA 3.0"
"40082814","2","","40076953","2016-10-17 09:29:01","","7","","<p>I'd do it like this:</p>

<pre><code>import {Observable} from 'rxjs';

function doRequest() {
  if (Math.random() &lt; 0.25) {
    return Observable.of('HTTP Response').delay(3000);
  } else {
    return Observable.of('HTTP Response');
  }
}

let autoRefresher = Observable.timer(0, 1000)
  .exhaustMap(doRequest)
  .subscribe(response =&gt; {
    console.log(response);
  });
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/7HAib10r6Vdl1x2U2wFS"" rel=""noreferrer"">http://plnkr.co/edit/7HAib10r6Vdl1x2U2wFS</a></p>

<p>This randomly makes 3s delay. Operator <code>timer()</code> periodically emits a value. Then <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-exhaustMap"" rel=""noreferrer"">exhaustMap()</a> subscribes to the preceding Observable and ignores all Observables emitted until the current one completes. So <code>timer()</code> is emitting values but these are ignored by <code>exhaust()</code>.</p>

<p>Btw, note that I'm using TypeScript.</p>
","310726","","310726","","2016-10-17 11:08:00","2016-10-17 11:08:00","","","","2","","","","CC BY-SA 3.0"
"40094019","1","40096012","","2016-10-17 19:17:03","","0","49","<p>I am fetching weather form Yahoo and I want to only grab a few fields out of the response. I thought this might work but it doesn't how can I achieve getting the response JSON and then do some more work to only return an object with a few fields? </p>

<pre><code>  constructor(private http: Http) { }

  getWeather(): Observable&lt;any&gt; {
    return this.http
        .get(this.url)
        .map((resp:Response) =&gt; resp.json())
        .switchMap((json) =&gt; this.tranformJson(json))
        .catch(this.handleError);
  }

  private tranformJson(json) {
    let result = {};
    const r = json.query.results.channel;
    const current = r.item.condition.temp;
    const f = r.item.forecast[0];
    const { high, low, text} = f;
    result['high'] = high;
    result['low'] = low;
    result['text'] = text;
    result['currentTemp'] = current;
    return result;
  }
</code></pre>
","112665","","","","","2016-10-17 21:32:01","How can I do further processing in this rxjs pipeline?","<angular><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"40096012","2","","40094019","2016-10-17 21:32:01","","1","","<p>How about:</p>

<pre><code>  getWeather(): Observable&lt;any&gt; {
    return this.http
        .get(this.url)
        .map((resp:Response) =&gt; resp.json())
        //You are only using the channel field so pluck it out
        .pluck('query','results','channel')
        // Use map instead of switchMap
        .map(this.transform)
        .catch(this.handleError);
  }

  private static transform({item: {forecast, condition}}) {
    const [{high, low, text}] = forecast;
    return {
      currentTemp: condition.temp,
      high,
      low,
      text
    };
  }
</code></pre>
","2521865","","","","","2016-10-17 21:32:01","","","","2","","","","CC BY-SA 3.0"
"40106953","1","40108454","","2016-10-18 11:25:13","","7","4525","<p>I am trying to <code>throttle</code> ngrx store action updates events with the following code </p>

<pre><code>import 'rxjs/add/operator/throttle'
import { Dispatcher, Store } from '@ngrx/store';
...
static get parameters() {
  return [[Dispatcher]];
}
constructor(actions$) {
...

this.actions$
  .filter(action =&gt; action.type === this.Actions[`LOAD_USERS_REQUEST`])
  .throttle(1000 /* ms */)
  .subscribe(() =&gt;
    ...
  );
</code></pre>

<p>this throws me an error</p>

<blockquote>
  <p>at ThrottleSubscriber.tryDurationSelector (throttle.js:80) TypeError:
  this.durationSelector is not a function</p>
</blockquote>

<p>When I replace <code>.throttle(1000)</code> with <code>.throttle(() =&gt; 1000)</code> it throws a different error that clearly shows throttle expects a function, just not the one that I provide. But I wonder why because the documentation states throttle expects a number value.</p>

<p><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/throttle.md"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/throttle.md</a></p>
","1436151","","310726","","2016-10-18 12:54:59","2016-10-18 12:54:59","rxjs throttle this.durationSelector is not a function","<angular><typescript><rxjs><rxjs5><ngrx>","1","3","2","","","CC BY-SA 3.0"
"40107860","1","40508888","","2016-10-18 12:08:17","","3","199","<p>With the help of <a href=""https://stackoverflow.com/questions/39994096/start-first-call-of-intervalobservable-instant"">Observable.timer(0, 1000)</a> I am making continuous requests to my server in a defined time pattern. After I processed the content of the response it is possible under special conditions and <strong>depending on the previous response</strong> that I need to drop the response and therefore do not pass it to the subscriber of the service:</p>

<pre><code>@Injectable()
export class LoggerService {
  constructor(private http: Http) { }
  private apiURL = 'assets/file.json'; 

  getList() {
    return Observable.timer(0, 1000)
      .concatMap(() =&gt; this.http.get(this.apiURL))
      .map(this.extractData)
      .catch(this.handleError););
  }
  private extractData(res: Response) {
    var fooot = new Foo();
    fooot.fillFromJSON(JSON.stringify(res.json()));
    if(fooot.getProperty()){
    //DROP IT
    }
    return fooot;
  }

  private handleError(error: any) {
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : 'Server error';
    console.error(errMsg);
    return Observable.throw(errMsg);
  }
}
</code></pre>

<p>The <code>getList()</code> method is then called from <code>ngOnInit</code> of a component.
At the moment there are two possible solutions I can think of, buy maybe there is a better/clearer approach to solve this problem:</p>

<ol>
<li><p>If I have to drop the response I create a special object which is recognized by the subscriber of <code>getList()</code> and then specifically handled. But this solution would be very ugly because the dropped response leaves my service and I need to extra write code outside of the service to handle this case.</p></li>
<li><p>I throw an exception when I have to drop the response. Then the exception is caught, recognized (to differ it from other cases) and then dropped without any notice/output. Afterwards the observable is restarted. The advantage of this approach is that the observable which should be dropped to not leave the service, but I do not like the usage of exceptions in this case for the control flow.</p></li>
</ol>

<p>I tried both solutions and they are working, but I hope there are some better approaches.</p>
","1632341","","-1","","2017-05-23 12:32:30","2016-11-09 14:06:45","How to drop the response of an Observable","<angular><typescript><rxjs5>","2","0","","","","CC BY-SA 3.0"
"40108454","2","","40106953","2016-10-18 12:36:16","","19","","<p>Documentation page you're referring on <a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS</a> is related to RxJS 4. Since you're using Angular2, you're using RxJS 5.</p>

<p>Operator <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-throttle"" rel=""noreferrer""><code>throttle()</code></a> expects as argument an Observable or Promise.</p>

<p>Operator <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-throttleTime"" rel=""noreferrer""><code>throttleTime()</code></a> takes as argument time in miliseconds.</p>

<p>So you should use <code>throttleTime(1000)</code>. </p>

<p>Note that using <code>.throttle(() =&gt; 1000)</code> is very different. You pass an anonymous function that returns <code>1000</code> instead of <code>1000</code> number directly. That's why it throws a different error.</p>
","310726","","310726","","2016-10-18 12:54:30","2016-10-18 12:54:30","","","","2","","","","CC BY-SA 3.0"
"40130139","1","40130796","","2016-10-19 11:27:09","","3","1349","<p>This scenario works fine when the RESTful API returns a JSON array - but the web method I'm calling returns a single JSON object - and so the code has been converted to map a single object from <code>&lt;IRegistration[]&gt; to &lt;IRegistration&gt;</code> all the way up the stack. </p>

<p>This fails and the Chrome console returns an error showing the app could not find either of the mapped fields in the HTML</p>

<p>The HTML</p>

<pre><code>{{myobject.productId}}
{{myobject.productName}}
</code></pre>

<p>The JSON</p>

<pre><code>{
  ""productId"": 1,
  ""productName"": ""My Field Value""
}
</code></pre>

<p>The Interface</p>

<pre><code>export interface IRegistration {
    productId: number;
    productName: string;
}
</code></pre>

<p>The observable</p>

<pre><code>getRegistration(): Observable&lt;IRegistration&gt; {
    return this._http.get(this._svcURL)
        .map((response: Response) =&gt; &lt;IRegistration&gt;response.json())
        .do(data =&gt; console.log('ALL: ' + JSON.stringify(data)))
        .catch(this.handleError);
}
</code></pre>

<p>The client component</p>

<pre><code>myobject: IRegistration;

ngOnInit(): void {
    this._registrationService.getRegistration().subscribe(
        reg =&gt; this.myobject= reg,
        error =&gt; this.errorMessage = &lt;any&gt;error
    );
}
</code></pre>

<p>The error </p>

<pre><code> EXCEPTION: TypeError: Cannot read property 'productId' of undefined in [
{{myobject.productId}}
{{myobject.productName}}

 in SearchComponent@0:0]
</code></pre>

<p>The debugging I've done points to the response.json() in the observable failing to map correctly to the IRegistration - I can't seem to find the correct syntax?</p>
","251770","","310726","","2016-10-19 11:58:29","2016-10-19 11:58:29","Response.json() bind to single object using interface - RxJs/Observable fails","<angular><typescript><rxjs><angular2-template><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"40130796","2","","40130139","2016-10-19 11:57:20","","2","","<p>The code looks fine, I think the problem is that you don't initialize the <code>myobject: IRegistration;</code> before using it.</p>

<p>The <a href=""https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html"" rel=""nofollow"">doc for lifecycle hook <code>ngOnInit()</code></a> says:</p>

<blockquote>
  <p>Initialize the directive/component after Angular first displays the data-bound properties and sets the directive/component's input properties.</p>
</blockquote>

<p>The data is displayed before the HTTP call returns any result so <code>myobject</code> is undefined when Angular is trying to render it.</p>

<p>You can use <code>?</code> to ignore undefined properties such as <code>{{ myobject?.productId }}</code> or initialize the property first <code>myobject: IRegistration = &lt;IRegistration&gt;{};</code>.</p>
","310726","","","","","2016-10-19 11:57:20","","","","1","","","","CC BY-SA 3.0"
"40138072","1","","","2016-10-19 17:37:21","","0","337","<p>Can someone please guide me in the right direction for using socket.io with RxJS?
I've been experimenting with my own implementation, but was wondering if there is a preferred standard. </p>

<p>I've seen RxJS5's WebSocketSubject, is there something similar that works with socket.io?</p>

<p>Thanks in advance</p>
","2275792","","2275792","","2016-10-19 17:52:04","2016-10-19 19:42:33","RxJS5 WebSocketSubject and socket.io","<websocket><socket.io><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40141024","1","40663296","","2016-10-19 20:33:45","","0","488","<p>I am trying to resubscribe to socket events when socket.io disconnects->reconnects using RxJS. </p>

<p>Below is a slimed down simplified version of what I have so far. I am wrapping socket.io with an Observable, which is wrapped by another Observable that filters all socket events. I want to use retryWhen after the socket reconnects and not sure how to accomplish this... </p>

<p>Can anyone point me in the right direction please?</p>

<pre><code>function socket() {
    return Observable.create(subscriber =&gt; {
        let socket = io('my_socket_path');
        let _onevent = socket.onevent;

        socket.onevent = (packet) =&gt; {
            subscriber.next(packet);
            _onevent.call(socket, packet);
        };

        socket.on('disconnect', (data) =&gt; {
            subscriber.error(data);
        });

        return () =&gt; {
            socket.close();
        };
    }).share();
}
function getSocketEvent(event) {
    const socket = socket();
    return Observable.create(subscriber =&gt; {
        const eventSubscription = socket
            .filter(packet =&gt; packet.data[0] === event)
            .subscribe(packet =&gt; {
                subscriber.next(packet);
            });

        return () =&gt; {
            eventSubscription.unsubscribe();
        };
    }).share()
      .retryWhen(
       //Not sure how to trigger re-subscription here when socket reconnects
    ));
}
getSocketEvent('myGreatEvent').subscribe(data =&gt; {
    console.log(data);
});
</code></pre>

<p>Thank-you</p>

<p><strong>Update:</strong></p>

<p>I noticed that the retryWhen() is called when I just pass the subscriber in the subscription of the socket like this:</p>

<pre><code>...
 const eventSubscription = socket
        .filter(packet =&gt; packet.data[0] === event)
        .subscribe(subscriber); //now triggers retryWhen()...
...
</code></pre>

<p>Even with this new discovery, I am not sure why just passing subscriber triggers the retryWhen, and how to resubscribe when socket comes back online.</p>
","2275792","","2275792","","2016-10-20 14:09:25","2016-11-17 19:21:05","RxJS socket.io reconnection with retryWhen()","<sockets><websocket><socket.io><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40149894","1","40150290","","2016-10-20 09:00:32","","3","1673","<p>I have a method for handle our errors from http requests and it looks like this</p>

<pre><code>public handleError(err: any, caught: Observable&lt;any&gt;): Observable&lt;any&gt; {

  //irrelevant code removed
  this.logger.debug(err);//example of problem 
  return caught;
}
</code></pre>

<p>It is invoked like this (example method, but shows the error)</p>

<pre><code>  public makeHttpCall() {
    this.http.get(""http://api.exmaple.com/getsomedata"")
      .map(r=&gt; r.json())
      .catch(this.handleError);
  }
</code></pre>

<p>The problem with the above code is that when calling <code>this.logger.debug(err)</code> in the <code>handleError</code> method <code>this</code> no longer refers to the class the http call was made from but references the CatchSubscriber.</p>

<p>See here:
<a href=""https://i.stack.imgur.com/9yCzI.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/9yCzI.png"" alt=""example of this""></a></p>

<p>So i change <code>.catch(this.handleError);</code> to <code>.catch(this.handlError.bind(this))</code>;</p>

<p>This works, now when i call <code>this.logger.debug</code> <code>this</code> refers to the correct object. The problem is, the http request gets called over and over and over, 
see here:</p>

<p><a href=""https://i.stack.imgur.com/3pxPj.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/3pxPj.png"" alt=""enter image description here""></a></p>

<p>This only happens after applying <code>.bind(this)</code></p>

<p>I can't figure out why this is happening</p>

<p>*********EDIT*********</p>

<p>Change from <code>.catch(handleError)</code> to <code>.catch((a,b)=&gt;handleError(a,b))</code> fixes the reference of <code>this</code> but the http request just gets spammed over and over, but only when the request fails. If the request succeeds it only happens once.</p>
","1421778","","1421778","","2016-10-20 09:33:02","2016-10-20 09:33:02","Angular 2 & RxJs catch function callback binding to 'this' causes http request to be repeated over and over","<angular><typescript><rxjs><rxjs5><angular2-http>","1","1","","","","CC BY-SA 3.0"
"40150290","2","","40149894","2016-10-20 09:18:57","","3","","<p>When you pass a function with <code>.catch(this.handleError);</code> it loses its context <code>this</code>. See <a href=""https://stackoverflow.com/questions/16382165/why-do-i-lose-the-context-of-this-in-javascript"">Why do I lose the context of this in Javascript?</a></p>

<p>Most easily you can fix this by wrapping the function call into a closure.</p>

<pre><code>.catch((err, caught) =&gt; this.handleError(err, caught));
</code></pre>
","310726","","-1","","2017-05-23 11:54:34","2016-10-20 09:18:57","","","","6","","","","CC BY-SA 3.0"
"40159886","1","40164700","","2016-10-20 16:34:23","","3","1091","<p>I have a subject that is responsible for subscriptions to certain observable:</p>

<pre><code>var timer$ = Rx.Observable.timer(1000, 2000);
</code></pre>

<p>When the subject is linked to the subject like that</p>

<pre><code>var timerSubject = new Rx.Subject;
timer$.subscribe(timerSubject);

var subscription1 = timerSubject.subscribe(n =&gt; console.log(n));
var subscription2 = timerSubject.subscribe(n =&gt; console.log(n));

setTimeout(() =&gt; timerSubject.unsubscribe(), 4000);
</code></pre>

<p>everything is fine, <code>timerSubject.unsubscribe()</code> can be called once and the subscriptions shouldn't be unsubscribed one by one.</p>

<p>When the subject is created with <code>Subject.create</code> like that (a <a href=""http://plnkr.co/edit/sQ3inBq4xDXpCvlMXrPV?p=info"" rel=""nofollow"">plunk</a>)</p>

<pre><code>var timerSubject = Rx.Subject.create(null, timer$);

var subscription1 = timerSubject.subscribe(n =&gt; console.log(n));
var subscription2 = timerSubject.subscribe(n =&gt; console.log(n));

setTimeout(() =&gt; timerSubject.unsubscribe(), 4000);
</code></pre>

<p><code>timerSubject.unsubscribe()</code> does nothing, while I would expect to behave it the same as in the first snippet.</p>

<p>If <code>Subject.create</code> creates a subject that can't even unsubscribe, what's the purpose of <code>Subject.create</code> then?</p>

<p>Why does this happen? Is this a bug?</p>

<p>How can the subject should be created to reach the desired behaviour?</p>

<p>It is reproducible with RxJS 5 RC1.</p>
","3731501","","3731501","","2016-10-20 22:12:05","2016-10-20 22:12:05","Subjects created with Subject.create can't unsubscribe","<rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40164700","2","","40159886","2016-10-20 21:15:42","","3","","<p>I checked the <a href=""http://reactivex.io/rxjs/file/es6/Subject.js.html#lineNumber19"" rel=""nofollow"">source code for <code>Subject.create()</code></a> and it's not the same as <a href=""http://reactivex.io/rxjs/file/es6/Subject.js.html#lineNumber111"" rel=""nofollow"">calling <code>new Subject()</code></a>.</p>

<ul>
<li><p><code>Subject.create()</code> returns an instance of <code>AnonymousSubject</code>.</p></li>
<li><p><code>new Subject()</code> returns an instance of <code>Subject</code>.</p></li>
</ul>

<p>So it seems the problem why <code>unsubscribe()</code> on <code>AnonymousSubject</code> doesn't work is because it in fact never subscribes. It just keeps a reference to the <code>source</code> Observable and when subscribing an Observer it connects directly <code>source</code> with the Observer and doesn't keep track of created subscribtions.</p>

<p>In your case when you call <code>timerSubject.subscribe()</code> it subscribes directly to <code>timer$</code> and <code>AnonymousSubject</code> acts only as mediator.</p>

<p>I don't know whether this is by design or it's a bug. However, the first option is more likely I think.</p>
","310726","","310726","","2016-10-20 21:21:20","2016-10-20 21:21:20","","","","2","","","","CC BY-SA 3.0"
"40164752","1","40169872","","2016-10-20 21:19:48","","20","12036","<p>This is mainly an RxJs best practice/approach question, since my POC code works but I'm brand new to RxJs.</p>

<p>The question boils down to <code>.subscribe()</code> vs <code>.publish().connect()</code>, since they both appear to do the same thing.</p>

<p>In my angular2 app, I have a button that calls a function to log the user out, which calls a function in my service that performs some server side actions and returns me a URL to redirect the user to.  In order to initiate the request I call <code>.subscribe()</code> to cause the observable to start producing values.  I was reading an article on ""Cold vs Hot Observables"" and it another approach would be to call <code>.publish().connect()</code> instead of <code>.subscribe()</code>. Is there any benefit to either approach. </p>

<pre><code>&lt;a (click)=""logout()""&gt;Logout&lt;/a&gt;
</code></pre>

<p>The logout function looks like this:</p>

<p><strong>logout.component.ts</strong></p>

<pre><code>logout() { this.authService.logout(); }
</code></pre>

<p>And the service (actual logout) looks like this:</p>

<p><strong>auth.service.ts</strong>    </p>

<pre><code>logout() : Observable&lt;boolean&gt;  {
        this.http.get(this.location.prepareExternalUrl('api/v1/authentication/logout'))
            .map(this.extractData)
            .catch(this.handleError)
            .do((x: string) =&gt; { window.location.href = x; })
            .subscribe();    // Option A - 

        return Observable.of(true);

    }
</code></pre>

<p><strong>auth.service.alternative.ts</strong>    </p>

<pre><code>logout() : Observable&lt;boolean&gt;  {
        this.http.get(this.location.prepareExternalUrl('api/v1/authentication/logout'))
            .map(this.extractData)
            .catch(this.handleError)
            .do((x: string) =&gt; { window.location.href = x; })
            .publish()  // Option B - Make connectable observable
            .connect(); // Option B - Cause the connectable observable to subscribe and produce my value       

        return Observable.of(true);
    }
</code></pre>
","7038065","","310726","","2016-10-21 16:41:39","2016-10-21 16:41:39","RxJS - .subscribe() vs .publish().connect()","<angular><rxjs><rxjs5>","2","0","8","","","CC BY-SA 3.0"
"40168627","1","40182700","","2016-10-21 04:49:53","","4","2280","<p>I am using observable in Angular2. As I know so far, each Observable instance come with an observer(1:1), and when we emit something with observer.next(value) we can get that value with observable.subscribe((value) => {}).</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var observable = Observable.create(observer =&gt; {
  observer.next(value);
}
.map(value=&gt;{})
.catch(...)
observable.subscribe(value =&gt; {
  console.log(value);
})</code></pre>
</div>
</div>
</p>

<p>How can I emit value without knowing the corresponding observer, because I want to emit value outside create function. One possible solution is save observer into some global variable but I think an observable should be enough. Any suggestion for this ??</p>
","3370320","","310726","","2016-10-21 17:52:55","2016-10-21 19:37:15","Observable instance emit without an observer (or subscriber ?)","<javascript><angular><rxjs><observable><rxjs5>","1","7","2","","","CC BY-SA 3.0"
"40169872","2","","40164752","2016-10-21 06:35:37","","27","","<p>The difference between <code>subscribe()</code> and <code>.publish().connect()</code> is in when they subscribe to its source Observable. Consider the following Observable:</p>

<pre><code>let source = Observable.from([1, 2, 3])
</code></pre>

<p>This Observable emits all values to an Observer right when it subscribes. So if I have two Observers then they receive all values in order:</p>

<pre><code>source.subscribe(val =&gt; console.log('obs1', val));
source.subscribe(val =&gt; console.log('obs2', val));
</code></pre>

<p>This will print to console:</p>

<pre><code>obs1 1
obs1 2
obs1 3
obs2 1
obs2 2
obs2 3
</code></pre>

<p>On the other hand calling <code>.publish()</code> returns a <a href=""http://reactivex.io/rxjs/class/es6/observable/ConnectableObservable.js~ConnectableObservable.html"" rel=""noreferrer""><code>ConnectableObservable</code></a>. This Observable doesn't subscribe to it's source (<code>source</code> in our example) in its constructor and only keeps its reference. Then you can subscribe multiple Observers to it and nothing happens. Finally, you call <code>connect()</code> and the <code>ConnectableObservable</code> subscribes to the <code>source</code> which starts emitting values. This time there're already two Observers subscribes so it emits values to both of them one by one:</p>

<pre><code>let connectable = source.publish();
connectable.subscribe(val =&gt; console.log('obs1', val));
connectable.subscribe(val =&gt; console.log('obs2', val));
connectable.connect();
</code></pre>

<p>Which prints to console:</p>

<pre><code>obs1 1
obs2 1
obs1 2
obs2 2
obs1 3
obs2 3
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/ySWocRr99m1WXwsOGfjS?p=preview"" rel=""noreferrer"">http://plnkr.co/edit/ySWocRr99m1WXwsOGfjS?p=preview</a></p>
","310726","","","","","2016-10-21 06:35:37","","","","6","","","","CC BY-SA 3.0"
"40170157","1","40186121","","2016-10-21 06:53:38","","6","8059","<p>I have a service which uses <code>@angular/http</code> to load data from an API.
I want to create a projection of the retrieved data for my <code>Components</code> using this data.</p>

<p>Therefore I wrote the following code:</p>

<pre><code>getById(id: string) {
  return this.http
    .get(`https://my-api.io/${id}`)
    .map(response =&gt; response.json())
    .map(contracts =&gt;
      contracts.map(contract =&gt;        # &lt;- Nested map
        new Contract(
          contract['id'],
          contract['description']
        )
      )
    );
}
</code></pre>

<p>In the <strong>6th</strong> line I have a nested <code>map</code>-Statement reducing the readability of my code.</p>

<p><strong>Question</strong></p>

<p>Can I do better? Is there an operator in RxJS which I can use instead of creating this kind of nesting?</p>

<p>Thanks in advance!</p>
","1648207","","310726","","2016-10-21 16:41:24","2016-10-21 22:09:32","RxJS Refactor nested map statement","<angular><refactoring><rxjs><code-cleanup><rxjs5>","3","4","1","","","CC BY-SA 3.0"
"40182700","2","","40168627","2016-10-21 17:52:14","","7","","<p>You're mixing multiple things together. Observables are not in 1:1 relation with Observers (more precisely it's 1:N). If you want to be able to manually emit values you need a <a href=""http://reactivex.io/documentation/subject.html"" rel=""noreferrer""><code>Subject</code></a> which acts as an Observable and an Observer at the same time. Practically this means you can call its <code>next()</code> method and it'll propage the value to all its subscribers (Observers).</p>

<p>For example consider the following code in TypeScript:</p>

<pre><code>import {Subject} from 'rxjs';

let source = new Subject();

source.subscribe(val =&gt; console.log('Observer 1:', val));
source.subscribe(val =&gt; console.log('Observer 2:', val));

source.next(42);
source.next('test');
</code></pre>

<p>This will print to console:</p>

<pre><code>Observer 1: 42
Observer 2: 42
Observer 1: test
Observer 2: test
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/gWMFMnPlLJVDC1pQi8pH?p=preview"" rel=""noreferrer"">http://plnkr.co/edit/gWMFMnPlLJVDC1pQi8pH?p=preview</a></p>

<p>Read more:</p>

<ul>
<li><a href=""http://reactivex.io/intro.html"" rel=""noreferrer"">http://reactivex.io/intro.html</a></li>
<li><a href=""https://github.com/Reactive-Extensions/RxJS#resources"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS#resources</a></li>
<li><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md</a></li>
</ul>

<p>Be aware that <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-create"" rel=""noreferrer""><code>Observable.create()</code></a> is a very different animal. It takes as a parameter a function that is <strong>called every time a new Observer subscribes</strong>. That's why it take the newly subscribed Observer as an argument. In this function you can for example call <code>next()</code> method on the Observer to send it some default value that all subscribes need to receive.</p>

<p>So you probably want to use <code>Subject</code> instead of <code>Observable.create()</code>.</p>
","310726","","310726","","2016-10-21 19:37:15","2016-10-21 19:37:15","","","","2","","","","CC BY-SA 3.0"
"40184509","1","40204023","","2016-10-21 19:53:54","","3","7280","<p>Here's my code:</p>

<pre><code>this._http.post(this._url_get + extension, '', { headers: headers })
    .map(res =&gt; res['_body'])
    .retryWhen(errors =&gt; {return responseErrorProcess(errors)})
</code></pre>

<p>now I need to catch exceptions and pass them to my <code>responseErrorProcess()</code> which returns <code>true</code> if it needs to retry</p>

<p>I could not figure out how to retrieve the exceptions from <code>errors</code>, this is how it looks:</p>

<pre><code>Subject_isScalar: falseclosed: falsehasError: falseisStopped: falseobservers: Array[0]thrownError: null__proto__: Observable`
</code></pre>

<p>It doesn't seem to contain errors about the exceptions that occurs, plus I couldn't figure out what should I return in order to actually retry or not. </p>
","5078433","","310726","","2016-10-22 18:39:47","2016-10-23 16:52:56","How to use retryWhen with a function that returns a Boolean?","<angular><rxjs><rxjs5><angular2-observables>","2","0","1","","","CC BY-SA 3.0"
"40184625","1","40184986","","2016-10-21 20:02:28","","1","1010","<p>I cant find a way to implement a live charts with ng2-charts.</p>

<p>I get an error when I do : </p>

<pre><code>&lt;div *ngIf=""(lineChartData$ | async)!=null""&gt;
    ....
    &lt;canvas baseChart width=""100"" height=""200""
      [datasets]=""lineChartData$ | async"" &lt;&lt;-ERROR: ""Cannot read property 'data' of undefined""
       ....
    &lt;/canvas&gt;
&lt;/div&gt;
</code></pre>

<p>I think that even if I would make it work some how, it would be the worst way to do it.</p>

<hr>

<p>Please recommend on any other liberies that has a build-in live charts if there is no solution to this error.</p>

<hr>

<p><strong>EDIT:</strong> </p>

<p><strong>app.component.html:</strong></p>

<pre><code>&lt;div *ngIf=""(lineChartData$ | async)!=null""&gt;
  &lt;div class=""row""&gt;
    &lt;div class=""col-md-6""&gt;
      &lt;div style=""display: block;""&gt;
        &lt;canvas baseChart width=""100"" height=""200""
                [datasets]=""lineChartData$ | async""   &lt;&lt;&lt;-- ERROR
                [labels]=""lineChartLabels""
                [options]=""lineChartOptions""
                [colors]=""lineChartColors""
                [legend]=""lineChartLegend""
                [chartType]=""lineChartType""
                (chartHover)=""chartHovered($event)""
                (chartClick)=""chartClicked($event)""&gt;&lt;/canvas&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""col-md-6"" style=""margin-bottom: 10px""&gt;
      &lt;table class=""table table-responsive table-condensed""&gt;
        &lt;tr&gt;
          &lt;th *ngFor=""let label of lineChartLabels""&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr *ngFor=""let d of lineChartData""&gt;
          &lt;td *ngFor=""let label of lineChartLabels; let j=index""&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p><strong>app.component.ts:</strong></p>

<pre><code>import {Component, OnInit} from '@angular/core';
import {Observable} from ""rxjs"";
import {Store} from ""@ngrx/store"";
import {AppState} from ""../../redux/design/app-state"";
import {AngularFire, AuthProviders, FirebaseObjectObservable} from ""angularfire2"";
import 'rxjs/add/operator/withLatestFrom';
import {AuthActions} from ""../../redux/actions/auth.actions"";
import {UserService} from ""../../services/user.service"";

@Component({
  selector: 'app-root',
  templateUrl: 'app.component.html'
})
export class AppComponent implements OnInit
{
  private lineChartData$:Observable&lt;Array&lt;any&gt;&gt;;
  constructor(private authActions: AuthActions,
              private af: AngularFire,
              private userService:UserService,
              private store:Store&lt;AppState&gt;){}
  public ngOnInit(): void {
    this.lineChartData$=Observable.interval(500)
      .map(index=&gt;[{data: [65, 59, index, 81, 56, 55, 40], label: 'Series A'},
          {data: [28, 48, 40, 19, 86, 27, 90], label: 'Series B'},
          {data: [18, 48, 77, 9, 100, 27, 40], label: 'Series C'}
        ]);
  }
// lineChart
  public lineChartLabels:Array&lt;any&gt; = ['January', 'February', 'March', 'April', 'May', 'June', 'July'];
  public lineChartOptions:any = {
    animation: false,
    responsive: true,
    maintainAspectRatio: false
  };
  public lineChartColors:Array&lt;any&gt; = [
    { // grey
      backgroundColor: 'rgba(148,159,177,0.2)',
      borderColor: 'rgba(148,159,177,1)',
      pointBackgroundColor: 'rgba(148,159,177,1)',
      pointBorderColor: '#fff',
      pointHoverBackgroundColor: '#fff',
      pointHoverBorderColor: 'rgba(148,159,177,0.8)'
    },
    { // dark grey
      backgroundColor: 'rgba(77,83,96,0.2)',
      borderColor: 'rgba(77,83,96,1)',
      pointBackgroundColor: 'rgba(77,83,96,1)',
      pointBorderColor: '#fff',
      pointHoverBackgroundColor: '#fff',
      pointHoverBorderColor: 'rgba(77,83,96,1)'
    },
    { // grey
      backgroundColor: 'rgba(148,159,177,0.2)',
      borderColor: 'rgba(148,159,177,1)',
      pointBackgroundColor: 'rgba(148,159,177,1)',
      pointBorderColor: '#fff',
      pointHoverBackgroundColor: '#fff',
      pointHoverBorderColor: 'rgba(148,159,177,0.8)'
    }
  ];
  public lineChartLegend:boolean = true;
  public lineChartType:string = 'line';


  // events
  public chartClicked(e:any):void {
    console.log(e);
  }

  public chartHovered(e:any):void {
    console.log(e);
  }
}
</code></pre>
","806963","","310726","","2016-10-21 20:51:16","2016-10-21 20:51:16","Is there a way to use rxjs with ng2-charts?","<javascript><angular><rxjs><rxjs5><ng2-charts>","1","3","","","","CC BY-SA 3.0"
"40184986","2","","40184625","2016-10-21 20:30:56","","1","","<p>I don't know much about <code>ng2-charts</code> but the error suggests the problem is somewhere else. </p>

<p>The doc on <code>ngOnInit</code> says:</p>

<blockquote>
  <p>Initialize the directive/component after Angular first displays the data-bound properties and sets the directive/component's input properties.</p>
</blockquote>

<p>So this lifecycle event is called after the view is initialized. Your <code>lineChartData$</code> is defined as:</p>

<pre><code>private lineChartData$:Observable&lt;Array&lt;any&gt;&gt;;
</code></pre>

<p>... and it's not initialized until <code>ngOnInit()</code> call. So the view tries to bind <code>lineChartData$</code> which is still <code>undefined</code> at that time. Thus the error message thrown probably from <code>ng2-charts</code> internals.</p>
","310726","","","","","2016-10-21 20:30:56","","","","2","","","","CC BY-SA 3.0"
"40185113","1","40185588","","2016-10-21 20:40:18","","0","230","<p>I'm new to RxJS and having a mental block.  My solution works, but I know it's a hack.  What's the proper way to do the following?</p>

<pre><code>// Desired Console Log: {x: 'abcd', y: 'efgh'}

const x = Rx.Observable.of('abcd').delay(1000);
const y = Rx.Observable.of('efgh').delay(1000);

Rx.Observable.concat(x,y)
.scan((acc, cur) =&gt; {
  if (cur.includes('a')) {
    acc.x = cur;
  }
   if (cur.includes('e')) {
    acc.y = cur;
  }
  return acc
}, {x: false, y: false})
.filter(x =&gt; x.y === 'efgh')
.subscribe(x =&gt; console.log(x))

// {x: 'abcd', y:'efgh'}
</code></pre>
","5220820","","983912","","2016-10-21 20:57:39","2016-10-23 15:55:45","Combine Inner Concat Observables","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40185588","2","","40185113","2016-10-21 21:18:24","","0","","<pre><code>Rx.Observable.concat(x,y)
  .zipIterable(['x','y'], (v1, v2) =&gt; {
    let result = {};
    result[v2] = v1;
    return result;
  })
  .toArray()
  .map(objects =&gt; Object.assign({}, ...objects))
  .subscribe(console.log.bind(console, '&gt;&gt; '));
</code></pre>

<p>Provided that the order is kept, i.e. the first element is x and the second y</p>
","242098","","310726","","2016-10-23 15:55:45","2016-10-23 15:55:45","","","","3","","","","CC BY-SA 3.0"
"40186121","2","","40170157","2016-10-21 22:09:32","","3","","<p>I propose to use <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/selectmany.md"" rel=""nofollow"">flatMap/selectMany</a> to flatten your nested array into a new stream of each single array element. In a next step you can then use <code>RxJS.map()</code> to do the actual mapping. Finally collect all mapped array elements with <code>RxJS.toArray()</code>into a new observable that provides a single array event:</p>

<pre><code>const stream = $http('http://jsonplaceholder.typicode.com/posts')
 .map(res =&gt; res.data)
 .flatMap(posts =&gt; posts)
 .map(post =&gt; Object.assign({}, post, { status: false }))
 .toArray();
</code></pre>

<p>See sample here: <a href=""http://jsbin.com/vigizihiwu/1/edit?js,console"" rel=""nofollow"">http://jsbin.com/vigizihiwu/1/edit?js,console</a></p>

<p>But I would also consider: is doing such limbo really necessary? If you only have one subscriber at all, map the received array there:</p>

<pre><code>const stream = $http('http://jsonplaceholder.typicode.com/posts')
 .map(res =&gt; res.data);

stream.subscribe(res =&gt; {
  const posts = res.map(post =&gt; Object.assign({}, post, { status: false }));
  console.log(posts);
});
</code></pre>
","385507","","","","","2016-10-21 22:09:32","","","","1","","","","CC BY-SA 3.0"
"40198748","1","","","2016-10-23 01:41:46","","4","3761","<p>Using RxJS <code>5.0.0-rc.1</code>, I'm trying to communicate my <code>Observer</code> and <code>Observable</code> in a way similar to <a href=""http://www.2ality.com/2015/03/es6-generators.html"" rel=""nofollow"">how generators/iterators work</a> by exchanging data using <code>yield</code> and <code>.next()</code>. The intention is to <strong>get a hold of what a call to <code>.subscribe</code> returns</strong> and modify/update following values in my observable stream depending on that.</p>

<p>I'm not entirely sure if this is, at all, possible. Though, I found out that you <em>can</em> catch exceptions thrown on <code>.subscribe</code> callbacks. The following snippets prints out <code>""Boom!""</code>:</p>

<pre><code>var source = Observable.create((observer) =&gt; {
  try {
    observer.next(42);
  } catch (e) {
    // This will catch the Error
    // thrown on the subscriber
    console.log(e.message);
  }
  observer.complete();
});

source.subscribe(() =&gt; {
  throw new Error('Boom!');
});
</code></pre>

<p>So, what if instead of throwing, the subscriber returns a value? Is there a way for the <code>Observable</code> to retrieve it? Perhaps I'm approaching this the wrong way. If so, what's the ""reactive"" way of doing things in this scenario?</p>

<p>Many thanks.</p>

<hr>

<p><strong>EDIT</strong></p>

<p>One possible way I came up with is by providing a callback function on every item in the stream. Something like:</p>

<pre><code>var source = Observable.create((observer) =&gt; {
  // This will print ""{ success: true }""
  observer.next({ value: 42, reply: console.log });
  observer.complete();
});

source.subscribe(({ value, reply }) =&gt; {
  console.log('Got', value);
  return reply({ success: true });
});
</code></pre>

<p>Any other thoughts?</p>

<hr>

<p><strong>EDIT 2</strong></p>

<p>Since my original question brought some confusion on what I was trying to achieve, I'll describe my real world scenario. I'm writing the API of a module for managing messages through queues (much like a simplified, in memory, AMQP-RPC mechanism) and I though RxJS would be a good fit.</p>

<p>It works like you would expect: a <code>Publisher</code> pushes messages to a queue, which get delivered to a <code>Consumer</code>. In term, the <code>Consumer</code> can reply to the <code>Publisher</code>, which can listen to that response if it's interested.</p>

<p>In an ideal scenario, the API would look something like this:</p>

<pre><code>Consumer().consume('some.pattern')
  .subscribe(function(msg) {
    // Do something with `msg`
    console.log(msg.foo);
    return { ok: true };
  });

Publisher().publish('some.pattern', { foo: 42 })
// (optional) `.subscribe()` to get reply from Consumer
</code></pre>

<p>That example would print <code>42</code>.</p>

<p>The logic for replying to the <code>Publisher</code> lies within the <code>Consumer</code> function. But the actual response comes <em>from the <code>.subscribe()</code></em> callback. Which leads me to my original question: how should I go about fetching that returned value from the creator of the stream?</p>

<p>Think of <code>Consumer#consume()</code> as:</p>

<pre><code>/**
 * Returns an async handler that gets invoked every time
 * a new message matching the pattern of this consumer
 * arrives.
 */
function waitOnMessage(observer) {
  return function(msg) {
    observer.next(msg);
    // Conceptually, I'd like the returned
    // object from `.subscribe()` to be available
    // in this scope, somehow.
    // That would allow me to go like: 
    // `sendToQueue(pubQueue, response);`
  }
}

return Observable.create((observer) =&gt; {
  queue.consume(waitOnMessage(observer));
});
</code></pre>

<p>Does it make any more sense?</p>
","4470169","","4470169","","2016-10-24 13:43:07","2016-10-24 18:12:28","Get return value from subcribe on Observable","<javascript><reactive-programming><rxjs><observer-pattern><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40204023","2","","40184509","2016-10-23 14:27:20","","8","","<p><code>retryWhen</code> should return an Observable. The retry occurs once that observable emits:</p>

<pre><code>.retryWhen(errors =&gt; 
    //switchMap to retrieve the source error
    errors.switchMap(sourceErr =&gt; 
        //send source to processor
        responseErrorsProcess(sourceErr) ? 
        //if result is TRUE, emit (will cause retry). Else, pass on the error
        Observable.of(true): Observable.throw(sourceErr)
    )
)
</code></pre>

<p>If you want to complete instead of error when your processor returns <code>false</code>, replace <code>Observable.throw()</code> with <code>Observable.empty()</code></p>
","3977061","","3977061","","2016-10-23 16:52:56","2016-10-23 16:52:56","","","","0","","","","CC BY-SA 3.0"
"40218425","1","","","2016-10-24 12:27:07","","3","434","<p>I am learning RxJS 5 (release candidate). I am using the ASCII <a href=""http://reactivex.io/rxjs/manual/overview.html#marble-diagrams"" rel=""nofollow"">marble diagrams</a> in unit tests.</p>

<p>For a failing test, is there a built in function to show the <code>actual</code> ASCII marbles string instead of the deep equal failure result? It seems like if I have to understand and write an <code>expected</code> ASCII marble string that it would be useful for a failing test to show the actual ASCII marble string. It would assist in troubleshooting.</p>

<p>I am hoping that there is a built in function that is effectively the reverse of <a href=""https://github.com/ReactiveX/rxjs/blob/master/spec/schedulers/TestScheduler-spec.ts"" rel=""nofollow""><code>parseMarbles()</code></a>. I have not found anything yet when searching through the documentation and source code.</p>

<p>Below is an example taken from <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md#anatomy-of-a-test"" rel=""nofollow"">Writing marble tests - anatomy of a test</a> that I modified to get a failing test. It gives the following output:</p>

<pre><code>AssertionError: expected [ Array(5) ] to deeply equal [ Array(4) ]Error
</code></pre>

<p>I would rather see something like: </p>

<pre><code>AssertionError: expected ""'---(be)----c-f-----|'"" 
                to equal ""'---(be)----c-------|'""
</code></pre>

<p><a href=""http://jsbin.com/hipepew/edit?js,output"" rel=""nofollow"">http://jsbin.com/hipepew/edit?js,output</a></p>

<pre><code>mocha.setup('bdd');
const expect = chai.expect; 

describe('RXJS 5 Marbles', () =&gt; {
  it(""basic anatomy of a failing test"", () =&gt; {

    const rxTestScheduler: TestScheduler = new Rx.TestScheduler(function (actual, expected) {
      expect(actual).to.deep.equal(expected);
    });
    const e1 = rxTestScheduler.createHotObservable&lt;string&gt;('----a--^--b-------c--|');
    const e2 = rxTestScheduler.createHotObservable&lt;string&gt;('---d-^--e---------f-----|');
    const expectedFail = '---(be)----c-------|';//missing f at frame 130
    rxTestScheduler.expectObservable(e1.merge(e2)).toBe(expectedFail);
    rxTestScheduler.flush();

  });
});

mocha.run();
</code></pre>
","371899","","","","","2017-04-09 19:51:29","RxJs 5 ascii marbles output for failing test","<unit-testing><typescript><rxjs5>","0","0","1","","","CC BY-SA 3.0"
"40219593","1","40219888","","2016-10-24 13:21:37","","5","7485","<p>I am new to Angular2 and Observable, I want to check if a Observable <code>getRoles</code> which is of type <code>Observable&lt;string[]&gt;</code> contains a string.</p>

<pre><code>public hasRole(name: string): boolean {
    // getRoles is of type Observable&lt;string[]&gt;
    let getRoles = this.tokenService.getTokenInformation().map(element =&gt; element.roles);

    if (/* check if name is inside of getRoles */) {
        return true;
    }
    return false;
}
</code></pre>
","1262566","","310726","","2016-10-24 14:07:22","2016-10-24 14:07:22","How to check if a RxJS Observable contains a string in Angular2?","<angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40219888","2","","40219593","2016-10-24 13:36:11","","3","","<p>Observables are asynchronous so you can't use <code>let getRoles = ...map(...)</code>. The <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map"" rel=""nofollow""><code>map()</code></a> method is not executed on an array but on an Observable which is always asynchronous.</p>

<p>So proper way to do it could be (I didn't test this code):</p>

<pre><code>public hasRole(name: string): Observable {
    return this.tokenService.getTokenInformation()
        .map(element =&gt; element.roles)
        .first(roles =&gt; roles.indexOf(name) !== -1);
}
</code></pre>

<p>Operator <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-first"" rel=""nofollow""><code>first()</code></a> emits an error when no matching element was found when the source completed (when we iterated all roles).</p>

<p>Then use this method like:</p>

<pre><code>hasRole('my-role').subscribe(
    role =&gt; console.log(""has role""),
    error =&gt; console.log(""doesn't have role""),
)
</code></pre>

<p>Edit:</p>

<p>This converts everything to only <code>true</code> or <code>false</code> values. See doc for <code>first()</code> operator what are these argument. Then I used <code>map()</code> to force convert everything into boolean.</p>

<pre><code>public hasRole(name: string): Observable {
    return this.tokenService.getTokenInformation()
        .map(element =&gt; element.roles)
        .first(roles =&gt; roles.indexOf(name) !== -1, undefined, false)
        .map(val =&gt; !!val);
}
</code></pre>

<p>See live simplified demo: <a href=""http://plnkr.co/edit/MtYfGLgqgHACPswFTVJ5"" rel=""nofollow"">http://plnkr.co/edit/MtYfGLgqgHACPswFTVJ5</a></p>
","310726","","310726","","2016-10-24 14:03:19","2016-10-24 14:03:19","","","","5","","","","CC BY-SA 3.0"
"40226376","1","40233391","","2016-10-24 19:49:56","","1","507","<p>Iâm trying to build a dashboard for charts using angular 2 and chart.js (via ngcharts). Iâd like to have an array of charts that each update via an http request on a custom interval. </p>

<p>Right now I have three separate chart calls that push data to an array. Iâm having trouble when it comes to the next iteration - if I push to the array again, Iâll end up with 3 more charts. Iâd like the subscribers in the array to update with new data when the interval emits it. </p>

<p>Iâm a little confused as to how to correctly structure the component/service/http relationship for my use case.  I feel that Iâm close but Iâm definitely missing something. How can I get the interval/subscriber relationship to map to the view and update the existing charts on an interval? 
Any help would be great!</p>

<p>Right now:</p>

<p><strong>Service:</strong></p>

<p>Iâm implementing the interval here:</p>

<pre><code>getSingleChartObsinterval(id: number, interval: number) : Observable&lt;Graph&gt; {

return Observable.interval(interval).flatMap(() =&gt; this.getSingleChartobs(id));        
}


getSingleChartobs(id: number) : Observable&lt;Graph&gt; {

    return this.jsonp.get(âapi locationâ)
            .map(response =&gt; this.extractJsonData(response, id) as Graph)
}
</code></pre>

<p>extractJsonData is just taking the response and manipulating it to work with the chart JS. It returns a Graph object that has properties that are easy to work with. I donât have control of the API so I canât reconfigure the response to include more than one graph.</p>

<p><strong>The component:</strong> </p>

<pre><code>import { Component } from '@angular/core';
import { ChartsModule } from 'ng2-charts/ng2-charts';
import { ChartService } from './chart.service';
import { Graph } from './graph';
import { OnInit } from '@angular/core';
import { Observable } from 'rxjs/Rx';


@Component({
  selector: 'ab-chart',
  styles: [`
    .chart {
      display: block;
    }
  `],
  templateUrl: 'app/chart.component.html'
})
export class ChartComponent implements OnInit {

    ngOnInit(): void {
      console.log(""Chart component init"");

      this.getSingleChart(3, 5000);
      this.getSingleChart(5, 4000);
      this.getSingleChart(6, 5000);
    }

    graph: Graph;
    graphs: Graph[] = [];


    constructor(
        private chartService: ChartService
    ) {}


  getSingleChart(id: number, interval: number): void {
     this.chartService.getSingleChartObsinterval(id, interval)
      .subscribe(x =&gt; 
       this.graphs.push(x)
      );
}
}
</code></pre>

<p><strong>The view:</strong></p>

<pre><code>&lt;div *ngFor=""let graph of graphs"" class=""chart-container""&gt;
    &lt;base-chart
        class=""chart""
        [datasets]=""graph.datasets""
        [labels]=""graph.labels""
        [options]=""graph.options""
        [chartType]=""graph.type""&gt;
      &lt;/base-chart&gt;
  &lt;/div&gt;
</code></pre>
","1832509","","310726","","2016-10-25 07:15:52","2016-10-25 07:15:52","How to update an array of observables using interval?","<javascript><angular><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"40228188","1","40230617","","2016-10-24 21:58:17","","2","102","<pre><code>var state = [];
var operation1 = function() {
    return Rx.Observable.fromPromise(new Promise((resolve, reject) =&gt; {
        state.push(1, 2);
        setTimeout(resolve, 300, state);
    }));
};
var operation2 = function() {
    return Rx.Observable.fromPromise(new Promise((resolve, reject) =&gt; {
        state = state.map(x =&gt; x * 2);
        setTimeout(resolve, 200, state);
    }));
};
var operation3 = function() {
    return Rx.Observable.fromPromise(new Promise((resolve, reject) =&gt; {
        state = state.reduce( (prev, next) =&gt; prev + next );
        setTimeout(resolve, 100, state);
    }));
};
var operations = [operation1, operation2, operation3];
</code></pre>

<p>Given the code above, I am trying to combine <code>operations</code> into one <code>Observable</code> that emits the state of each operation. So the <code>Observable</code> needs to do either one of the following:</p>

<ul>
<li>emits 3 times: <code>[1, 2], [2, 4], 6</code></li>
<li>emits 1 time: <code>[[1, 2], [2, 4], 6]</code></li>
</ul>
","1999083","","1999083","","2016-10-25 00:25:52","2016-10-25 02:52:54","Combine a list of ordered operations into one Observable","<javascript><promise><rxjs><observable><rxjs5>","2","2","","","","CC BY-SA 3.0"
"40230617","2","","40228188","2016-10-25 02:52:54","","3","","<p>You could try (<a href=""http://jsfiddle.net/9vsu1mgm/"" rel=""nofollow"">jsbin</a>)</p>

<pre><code>var state = [];
var operation1 = Rx.Observable.defer(function() {
    return Rx.Observable.fromPromise(new Promise((resolve, reject) =&gt; {
        state.push(1, 2);
        setTimeout(resolve, 300, state);
    }));
});
var operation2 = Rx.Observable.defer(function() {
    return Rx.Observable.fromPromise(new Promise((resolve, reject) =&gt; {
        state = state.map(x =&gt; x * 2);
        setTimeout(resolve, 200, state);
    }));
});
var operation3 = Rx.Observable.defer(function() {
    return Rx.Observable.fromPromise(new Promise((resolve, reject) =&gt; {
        state = state.reduce( (prev, next) =&gt; prev + next );
        setTimeout(resolve, 100, state);
    }));
});
var operations = Rx.Observable.from([operation1, operation2, operation3]).merge(1);
operations.subscribe(function(x){console.log(x)})
</code></pre>

<p>Please check if that does the trick, I will elaborate later on how this works.</p>
","3743222","","","","","2016-10-25 02:52:54","","","","1","","","","CC BY-SA 3.0"
"40233391","2","","40226376","2016-10-25 07:02:03","","1","","<p>Since each graph has its own <code>id</code> (I assume its unique) so I'd just change <code>getSingleChart()</code> method to update <code>graphs</code> object at specific key. Note I changed the <code>graphs</code> property from an array to an object:</p>

<pre><code>graphs: {[key: number]: Graph} = {};

getSingleChart(id: number, interval: number): void {
  this.chartService.getSingleChartObsinterval(id, interval)
    .subscribe(x =&gt; this.graphs[id] = x);
}

get graphIds() {
    return Object.keys(this.graphs);
}
</code></pre>

<p>Then in the template you need to iterate the array of keys (you can iterate the <code>graphs</code> object:</p>

<pre><code>&lt;div *ngFor=""let id of graphIds"" class=""chart-container""&gt;
    &lt;base-chart
        class=""chart""
        [datasets]=""graphs[id].datasets""
        [labels]=""graphs[id].labels""
        [options]=""graphs[id].options""
        [chartType]=""graphs[id].type""&gt;
    &lt;/base-chart&gt;
&lt;/div&gt;
</code></pre>
","310726","","","","","2016-10-25 07:02:03","","","","1","","","","CC BY-SA 3.0"
"40235777","1","40237813","","2016-10-25 09:05:59","","1","633","<p>I am building an angular2 front end for my full stack application. I am working on user login and I have this function which is called when the login form is submitted:</p>

<pre><code>onSubmit(email, password) {
    this.userService.login(this.user.email, this.user.password).subscribe((result) =&gt; {
        console.log('reps' + result)
        if (result) {
            this.router.navigate(['']);
        }
    });
}
</code></pre>

<p>The login function in my userService is as follows:</p>

<pre><code>login(_email, _password) {
    let headers = new Headers({ 'Content-Type': 'application/json' });
    let options = new RequestOptions({ headers: headers });

    let data = { email: _email, password: _password };
    console.log(data);
    return this.http.post('/api/login', data, options)
        .map(this.extractData)
        .map((res) =&gt; {
            console.log('res' + JSON.stringify(res))
            if (res.token) {
                localStorage.setItem('auth_token', res.token);
                this.loggedIn = true;
            }
            return true;
        }).catch(this.handleError);
}
</code></pre>

<p>and finally, the handleError function:</p>

<pre><code>private handleError(error: Response | any) {
    // In a real world app, we might use a remote logging infrastructure
    console.log('isinError Handler' + error);
    let errMsg: string;
    if (error instanceof Response) {
        const err = error || JSON.stringify(error);
        console.log('err' + err); // Prints out ""Response with status: 401 Unauthorized for URL: http://localhost:3000/api/login""
        errMsg = `${error.status} - ${error.statusText || ''} ${err}`;
    } else {
        errMsg = error.message ? error.message : error.toString();
    }
    console.error('msg' + errMsg); // Prints out ""401 - Unauthorized Response with status: 401 Unauthorized for URL: http://localhost:3000/api/login""
    return errMsg;
}
</code></pre>

<p>When I submit the wrong password, I get the error:</p>

<blockquote>
  <p>401 - Unauthorized Response with status: 401 Unauthorized for URL: <a href=""http://localhost:3000/api/login"" rel=""nofollow"">http://localhost:3000/api/login</a></p>
</blockquote>

<p>printed from the <code>errMsg</code> variable in my error handler. This is great, however, back in my component, I then get <code>resp4</code>,<code>resp0</code>,<code>resp1</code>... printed out. i.e. the errMsg char by char. How can I get this to return in one full string?</p>
","4620733","","310726","","2016-10-25 10:06:17","2016-10-25 10:39:57","Angular2 Observable in http service returning errors char by char","<angular><typescript><rxjs><rxjs5><angular2-http>","2","0","","","","CC BY-SA 3.0"
"40237813","2","","40235777","2016-10-25 10:39:57","","0","","<p>Yo are prob not returning JSON. You are prob responding with a String and it is expecting JSON.</p>

<p>do something like this in your response code ..</p>

<pre><code>let json = JSON.parse(str);
res.send(json); // responding with parsed JSON
</code></pre>
","1205871","","","","","2016-10-25 10:39:57","","","","0","","","","CC BY-SA 3.0"
"40240260","2","","39805688","2016-10-25 12:41:14","","0","","<p>The missing values are a result of using a hot observable (<code>Observable.interval(300)</code>) that continues to output values that you are not storing for use.</p>

<p>Following is a slightly simplified version of your code that also logs the times that numbers are emitted. I replaced <code>Math.random()</code> with <code>1</code> so that the output is deterministic. I have also loaded the code in jsbin for you to try out:</p>

<p><a href=""https://jsbin.com/burocu/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/burocu/edit?js,console</a></p>

<pre><code>Observable.interval(300)
    .do(x =&gt; console.log(x + "") hot observable at: "" + (x * 300 + 300)))
    .take(12)
    .windowCount(3)
    .do(observe3 =&gt; {observe3.toArray()
      .subscribe(x =&gt; console.log(x + "" do window count at: "" + (x[2] * 300 + 300)));})
    .concatMap(obs =&gt; {
        return obs.mergeMap(
            v =&gt; Observable.timer(1 * 1500).mapTo(v)
        )
        .do(v =&gt; console.log(v + "" merge map at: "" + (v * 300 + 300 + 1500)));
    })
    .finally(() =&gt; console.log('fin windowCount'))
    .subscribe();
</code></pre>

<p>It results in the output below. Notice that the hot observables march on while the other operators are still being processed.</p>

<p>This is what is giving you the impression that values are being dropped. You can see that <code>windowCount(3)</code> is doing <strong>what</strong> you thought but not <strong>when</strong> you thought.</p>

<pre><code>""0) hot observable at: 300""
""1) hot observable at: 600""
""2) hot observable at: 900""
""0,1,2 do window count at: 900""
""3) hot observable at: 1200""
""4) hot observable at: 1500""
""5) hot observable at: 1800""
""3,4,5 do window count at: 1800""
""0 merge map at: 1800""
""6) hot observable at: 2100""
""1 merge map at: 2100""
""7) hot observable at: 2400""
""2 merge map at: 2400""
""8) hot observable at: 2700""
""6,7,8 do window count at: 2700""
""9) hot observable at: 3000""
""10) hot observable at: 3300""
""11) hot observable at: 3600""
""9,10,11 do window count at: 3600""
"" do window count at: NaN""
""8 merge map at: 4200""
""fin windowCount""
</code></pre>

<p><strong>Edit</strong>: further explanation...</p>

<p>After <code>windowCount(3)</code> there is a call to <code>concatMap</code>. <code>concatMap</code> is a combination of <code>map</code> and <code>concatAll</code>. </p>

<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concatAll"" rel=""nofollow noreferrer""><code>concatAll</code></a>:</p>

<blockquote>
  <p>Joins every Observable emitted by the source (a higher-order
  Observable), in a serial fashion. It subscribes to each inner
  Observable <em>only after the previous inner Observable has completed</em> (emphasis added), and
  merges all of their values into the returned observable.</p>
</blockquote>

<p>So, looking at the output above we see that the first <code>windowCount(3)</code> values [0,1,2] are emitted between 1800 and 2400. </p>

<p>Notice that the second <code>windowCount(3)</code> values [3,4,5] are emitted at 1800. <code>concatAll</code> is not ready to subscribe when [3,4,5] is emitted because the <strong>previous inner Observable has not completed</strong> yet. So these values are effectively dropped.</p>

<p>Next, notice that the previous inner Observable [0,1,2] completes at 2400. <code>concatAll</code> subscribes at 2400.</p>

<p>The next value to appear is the value 8 at 2700 (300ms after the subscription started at 2400). The value 8 is then output by <code>mergeMap</code> at 4200 because of the interval delay of 300 from the subscription start point of 2400 and then a timer delay of 1500 (i.e 2400 + 300 + 1500 = 4200).</p>

<p>After this point the sequence is completed so no further values are emitted.</p>

<p>Please add a comment if more clarification is needed.</p>
","371899","","371899","","2016-11-01 11:41:20","2016-11-01 11:41:20","","","","0","","","","CC BY-SA 3.0"
"40256541","1","40256977","","2016-10-26 07:48:04","","9","17647","<p>I have followed the tutorial for angular 2 and have a search functionality that renders a list of heroes asynchronously.</p>

<pre><code>&lt;div *ngFor=""let hero of heroes | async""&gt;
    {{hero.name}}
&lt;/div&gt;
</code></pre>

<p>In the component I have observable heroes:</p>

<pre><code>heroes: Observable&lt;Hero[]&gt;;
</code></pre>

<p>Now I have implemented similar functionality in my application by I don't see anything and I don't see any errors either. I opened the debugger in Chrome and tried to check the value of heroes, but it's just some Observable wrapper of course. </p>

<p>Is there any way to see the current/last or some value in the debugger or maybe there is some other technique to debug such issues?</p>
","1671558","","310726","","2017-06-27 15:46:09","2021-03-17 10:55:11","How to debug Observable values in Angular2 / Typescript?","<angular><typescript><rxjs><observable><rxjs5>","7","1","4","","","CC BY-SA 3.0"
"40256914","1","40257051","","2016-10-26 08:07:58","","0","704","<p>All over the tutorial for Angular2 I see that exceptions are being caught right where the call is, e.g.:</p>

<pre><code>getHeroes(): Promise&lt;Hero[]&gt; {
    return this.http.get(this.heroesUrl)
               .toPromise()
               .then(response =&gt; response.json().data as Hero[])
               .catch(this.handleError);
  }
</code></pre>

<p>While this might be good for the tutorial, this does not sound sustainable for me. I would like to have some global handler that will e.g. overlay/popup some message to a user and log the error to console + override it when I need some special handling (e.g. if I read the json error and find that I can handle it in a more user-friendly way than just a popup for one of the components), without the need to override it everywhere like the example from Angular2 suggests. </p>

<p>Is it possible to achieve?</p>

<p>P.S. A C# analogue would be some global.asax <code>Application_Error</code> + <code>TaskScheduler.UnobservedTaskException</code> error handling for example.</p>
","1671558","","310726","","2016-10-26 08:17:44","2016-10-26 08:30:23","How to handle exception uniformly / globally for Angular2 / Typescript observables?","<angular><typescript><rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"40256977","2","","40256541","2016-10-26 08:12:19","","10","","<p>There're several article on this topic but most easily use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-do"" rel=""noreferrer""><code>do()</code></a> operator to see what's going on in your operator chains.</p>

<p>Read more:</p>

<ul>
<li><p><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/testing.md#debugging-your-rx-application"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/testing.md#debugging-your-rx-application</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/38590346/how-to-debug-rxjs5"">How to debug rxjs5?</a></p></li>
<li><p><a href=""http://staltz.com/how-to-debug-rxjs-code.html"" rel=""noreferrer"">http://staltz.com/how-to-debug-rxjs-code.html</a></p></li>
<li><p><a href=""https://react.rocks/example/rxvision"" rel=""noreferrer"">https://react.rocks/example/rxvision</a></p></li>
<li><p><a href=""http://jaredforsyth.com/2015/03/06/visualizing-reactive-streams-hot-and-cold/"" rel=""noreferrer"">http://jaredforsyth.com/2015/03/06/visualizing-reactive-streams-hot-and-cold/</a></p></li>
</ul>
","310726","","-1","","2017-05-23 12:17:43","2016-11-07 11:55:39","","","","2","","","","CC BY-SA 3.0"
"40257051","2","","40256914","2016-10-26 08:16:25","","3","","<p>There's no way you can make all Observables do some globally predefined behavior.</p>

<p>Since you probably want to handle mostly request from <code>http</code> in some uniform way you can replace the default <code>http</code> service with your own that extends methods such as <code>get()</code> or <code>post()</code> and always append <code>catch()</code> or <code>retryWhen()</code> operators. See:</p>

<ul>
<li><p><a href=""https://stackoverflow.com/questions/38438020/extend-http-class-and-access-custom-properties-angular2-typescript"">Extend http class and access custom properties (Angular2 typescript)</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/39675806/how-to-extend-angular-2-http-class-in-angular-2-final"">How to extend angular 2 http class in Angular 2 final</a></p></li>
</ul>
","310726","","-1","","2017-05-23 12:17:36","2016-10-26 08:16:25","","","","0","","","","CC BY-SA 3.0"
"40257964","1","40263173","","2016-10-26 09:01:16","","5","4745","<p>I'm trying to apply fade-in, fade-out animation on a line of text. I want to keep it doing on regular interval (something like text flashing). I am using Observable for state triggering. </p>

<p>This is my animations array:</p>

<pre><code>animations: [
    trigger('showhide', [
        state('invisible', style({opacity: '0', visibility: 'hidden'})),
        state('visible', style({opacity: '1', visibility: 'visible'})),
        transition('invisible &lt;=&gt; visible', animate('2s linear'))
    ])
]
</code></pre>

<p>Variables I'm using:</p>

<pre><code>heading = 'invisible';
index: number = 0;
headingarray = [
    ""Heading 1"",
    ""Heading 2"",
    ""Heading 3""
]
</code></pre>

<p>Observable:</p>

<pre><code>Observable.interval(2000)
        .subscribe(x =&gt; {
            console.log(x);
            this.heading = (this.heading == 'visible') ? 'invisible' : 'visible';
            this.index = (x / 2) % 3
        })
</code></pre>

<p>And here's HTML:</p>

<pre><code>&lt;h2 [@showhide]=""heading""&gt;
    {{headingarray[index]}}
&lt;/h2&gt;
</code></pre>

<p>It is working partially. If I put initial value of <em>heading</em> as 'invisible' only fade-in effect is working &amp; vice versa. </p>

<p>It seems to be problem with interval handling. (I'd like to know if this can be done without Observable)</p>

<p>I've tried using both Angular 2 core animation as well as normal CSS animation. Both are giving me same effect.</p>
","6892876","","310726","","2016-10-26 14:19:50","2016-10-26 14:19:50","Continuous flashing/blinking of text line","<angular><rxjs><rxjs5><angular2-animation>","1","2","0","","","CC BY-SA 3.0"
"40263173","2","","40257964","2016-10-26 13:08:17","","3","","<p>The only problem was timing. You want to change the text every second tick because the animation needs to replay both in-out cycle which takes always 4s. </p>

<p>See your updated demo: <a href=""http://plnkr.co/edit/1lMLXmjIgDLnmd8L0qI5?p=preview"" rel=""nofollow"">http://plnkr.co/edit/1lMLXmjIgDLnmd8L0qI5?p=preview</a></p>

<pre><code>.subscribe(x =&gt; {
    console.log(x);
    this.heading = (this.heading == 'visible') ? 'invisible' : 'visible';
    if (x % 2 == 0) {
        this.index = (x / 2) % 3;
    }
})
</code></pre>
","310726","","","","","2016-10-26 13:08:17","","","","0","","","","CC BY-SA 3.0"
"40271050","1","","","2016-10-26 19:53:09","","3","2486","<p>There is an incomplete observable which can have or not have a replay of n values. I would like to get the last value from it - or just the next one if there is none yet.</p>

<p>This works for first available value with <code>first()</code> and <code>take(1)</code> (<a href=""http://plnkr.co/edit/UEKVS23Hl7hvhGFaPezV?p=preview"" rel=""nofollow"">example</a>):</p>

<pre><code>possiblyReplayedIncomplteObservable.first().toPromise().then(val =&gt; ...);
</code></pre>

<p>But for the last value both <code>last()</code> and <code>takeLast(1)</code> wait for observable completion - not the desirable behaviour here.</p>

<p>How can this be solved? Is there a specific operator for that?</p>
","3731501","","3731501","","2016-10-26 21:37:27","2016-10-27 00:18:23","Get last value from incomplete observable","<rxjs><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"40278971","1","40383825","","2016-10-27 07:43:40","","9","484","<p>In <code>rxjs5</code>, I have an AsyncSubject and want to subscribe to it multiple times, but only ONE subscriber should ever receive the <code>next()</code> event. All others (if they are not yet unsubscribed) should immediately get the <code>complete()</code> event without <code>next()</code>.</p>

<p>Example:</p>

<pre><code>let fired = false;
let as = new AsyncSubject();

const setFired = () =&gt; {
    if (fired == true) throw new Error(""Multiple subscriptions executed"");
    fired = true;
}

let subscription1 = as.subscribe(setFired);
let subscription2 = as.subscribe(setFired);

// note that subscription1/2 could be unsubscribed from in the future
// and still only a single subscriber should be triggered

setTimeout(() =&gt; {
    as.next(undefined);
    as.complete();
}, 500);
</code></pre>
","777928","","777928","","2016-11-09 06:44:50","2016-11-09 06:44:50","How to subscribe exactly once to an element from AsyncSubject (consumer pattern)","<javascript><typescript><ecmascript-6><producer-consumer><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"40286294","1","","","2016-10-27 13:47:10","","1","146","<p>In rxjs5, I'm trying to implement a <code>Throttler</code> class.</p>

<pre><code>import Rx from 'rxjs/rx';

export default class Throttler {
  constructor(interval) {
    this.timeouts = [];
    this.incomingActions = new Rx.Subject();
    this.incomingActions
      .concatMap(action =&gt; Rx.Observable.just(action).delay(interval / 2))
      .subscribe(action =&gt; action());
  }

  clear() {
    // How do I do this?
  }

  do(action) {
    this.incomingActions.next(action);
  }
}
</code></pre>

<p>The following invariants must hold:</p>

<ul>
<li><p>every action passed to <code>do</code> gets added to an action queue</p></li>
<li><p>the action queue gets processed in order and at a fixed interval as determined by the constructor parameter</p></li>
<li><p>the action queue can be cleared using <code>clear()</code>.</p></li>
</ul>

<p>My current implementation, as seen above, handles the fixed interval, but I don't know how to clear the queue. It also has the problem that all actions are delayed by <code>interval / 2</code>ms even when the queue is empty.</p>

<p>P.S. The way I describe the invariants maps very easily to an implementation with setInterval and an array as a queue, but I'm wondering how I would do this with Rx.</p>
","","user3099140","","","","2016-10-29 07:42:05","Lossless rate-limiting in RxJS with queue clearing","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40295717","1","40312328","","2016-10-27 23:25:03","","2","822","<p>I keep reading rxjs documentation but getting lost in all the operators..</p>

<p>this is what i got so far</p>

<pre><code>  let obs = Observable.from([1, 3, 5])   
</code></pre>

<p>so what i need this to do is <code>take()</code> some set amount from the array.  use the results in a post request, when that comes out successful then i need to restart the process.  I want to collect all the results, and keep progress as the process is going (for a progress bar)</p>

<p>I don't need the code for all of that.  what i really need to know is how to use rxjs to split this array up.. send part of it, and restart the process until theres nothing left to send.</p>

<p><strong>FINAL SOLUTION</strong></p>

<pre><code>  var _this = this

  function productsRequest(arr) {
    return _this.chainableRequest('post', `reports/${clientId}/${retailerId}/`, loadedProductsReport, {
        'identifiers': arr,
        'realTime': true
      })    
  }

  let arrayCount = Math.ceil(identifiers.length/10)
  let obs = Observable.from(identifiers)            
    .bufferCount(10)
    .concatMap(arr =&gt; {
      arrayCount--
      return arrayCount &gt; 0 ? productsRequest(arr) : Observable.empty()
    })


  let subscriber = obs.subscribe(
    value =&gt; console.log(value)
  )
</code></pre>

<p>chainable request method in parent</p>

<pre><code>  chainableRequest(method: string, endpoint: string, action: Function, data = {}, callback?: Function){
let body = (&lt;any&gt;Object).assign({}, {
  headers: this.headers
}, data)


return this._http[method.toLowerCase()](`${this.baseUri}/${endpoint}`, body, body)
          .map((res: Response) =&gt; res.json())
  }
</code></pre>
","1015571","","1015571","","2016-10-31 19:27:38","2016-10-31 19:27:38","Angular 2 / RXJS - need some help batching requests","<angular><rxjs><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"40303012","1","40311692","","2016-10-28 10:19:51","","27","33540","<p>I have the following code:</p>

<pre><code>//Loop: For each user ID/Role ID, get the data
userMeta.forEach((businessRole) =&gt; {
  Observable.forkJoin(
    af.database.object('/roles/'+businessRole.$value),
    af.database.object('/users/'+businessRole.$key)
  ).subscribe(
    data =&gt; {
      console.log(""Data received"");
      data[1].role = data[0];
      this.users.push(data[1]);
    },
    err =&gt; console.error(err)
  );
</code></pre>

<p>I am trying to subscribe to a result of 2 observables using <code>forkJoin</code>. </p>

<p>For some reasons, the ""Data received"" message is not shown.</p>

<p>My <code>userMeta</code> variables looks fine at console.log:</p>

<p><a href=""https://i.stack.imgur.com/NJO71.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/NJO71.png"" alt=""enter image description here""></a></p>

<p>What's wrong?</p>

<p>Update: the following code does not return anything either</p>

<pre><code>let source = Observable.forkJoin(
        af.database.object('/roles/'+businessRole.$value),
        af.database.object('/users/'+businessRole.$key)
    );
    let subscription = source.subscribe(
      function (x) {
    console.log(""GOT: "" + x);
  },
  function (err) {
    console.log('Error: %s', err);
  },
  function () {
    console.log('Completed');
  });
</code></pre>

<p>What I actually trying to do is improve the performance of the following code:</p>

<pre><code>//Subscription 3: role ID to role Name
        af.database.object('/roles/'+businessRole.$value)
        .subscribe((roleData) =&gt; {
        //Subscription 4: Get user info
        af.database.object('/users/'+businessRole.$key).subscribe(user =&gt; {
</code></pre>
","3669981","","310726","","2018-07-21 07:39:12","2020-09-29 18:26:59","Observable.forkJoin() doesn't execute","<angular><rxjs><observable><rxjs5><angularfire2>","5","3","5","","","CC BY-SA 4.0"
"40311692","2","","40303012","2016-10-28 19:05:24","","29","","<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin"" rel=""noreferrer""><code>forkJoin()</code></a> requires all source Observables to emit at least once and to complete.</p>

<p>This following demo completes as expected:</p>

<pre><code>const source = forkJoin(
  from([1,2,3]),
  from([9,8,7,6])
).subscribe(
  x =&gt; console.log('GOT:', x),
  err =&gt; console.log('Error:', err),
  () =&gt; console.log('Completed')
);
</code></pre>

<p>Live demo: <a href=""https://stackblitz.com/edit/rxjs-urhkni"" rel=""noreferrer"">https://stackblitz.com/edit/rxjs-urhkni</a></p>

<pre><code>GOT: 3,6
Completed
</code></pre>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-17 09:40:28","2019-01-17 09:40:28","","","","6","","","","CC BY-SA 4.0"
"40311907","1","40312744","","2016-10-28 19:21:27","","0","2520","<p>I have the following code:</p>

<pre><code>//Subscription 3: role ID to role Name
        af.database.object('/roles/'+businessRole.$value)
        .subscribe((roleData) =&gt; {
        //Subscription 4: Get user info
        af.database.object('/users/'+businessRole.$key).subscribe(user =&gt; {
</code></pre>

<p>Which contains a subscription inside a subscription. </p>

<p>The problem here is that the app waiting for the first one before running the second one. I want to execute both of them in one time, and get the result of each. How I can do that?</p>

<p>I've been using <code>Promise.All()</code> before but:</p>

<ol>
<li>I would love to know how I can do that with rxjs</li>
<li>I couldn't find a way to get the result of each observable using <code>Promise.All()</code></li>
</ol>

<p>Thanks</p>
","3669981","","310726","","2016-10-29 08:17:13","2016-10-29 08:17:13","Angular 2 - Run 2 subscription in the same time","<angular><rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"40312328","2","","40295717","2016-10-28 19:52:52","","2","","<p>This largely depends on what you're trying to achieve.</p>

<p>If you want to recursively call an Observable based on some previous Observable and you don't know how many times you're going to call it then use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-expand"" rel=""nofollow""><code>expand()</code></a> operator.</p>

<p>For example this demo recursively creates 5 requests based on the response from the previous call (<code>count</code> property):</p>

<pre><code>import { Observable } from 'rxjs/Observable';

function mockPostRequest(count) {
    return Observable.of(`{""count"":${count},""data"":""response""}`)
        .map(val =&gt; JSON.parse(val));
}

Observable.of({count: 0})
    .expand(response =&gt; {
        console.log('Response:', response.count);
        return response.count &lt; 5 ? mockPostRequest(response.count + 1) : Observable.empty();
    })
    .subscribe(undefined, undefined, val =&gt; console.log('Completed'));
</code></pre>

<p>Prints to console:</p>

<pre><code>Response: 0
Response: 1
Response: 2
Response: 3
Response: 4
Response: 5
Completed
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/lKNdR8oeOuB2mrnR3ahQ?p=preview"" rel=""nofollow"">http://plnkr.co/edit/lKNdR8oeOuB2mrnR3ahQ?p=preview</a></p>

<p>Or if you just want to call a bunch of HTTP request in order one after another (<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concatMap"" rel=""nofollow""><code>concatMap()</code></a> operator) or call all of them at once and consume them as they arrive (<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow""><code>mergeMap()</code></a> operator):</p>

<pre><code>Observable.from([
    'https://httpbin.org/get?1',
    'https://httpbin.org/get?2',
    'https://httpbin.org/get?3',
  ])
  .concatMap(url =&gt; Observable.of(url))
  .subscribe(response =&gt; console.log(response));
</code></pre>

<p>Prints to console:</p>

<pre><code>https://httpbin.org/get?1
https://httpbin.org/get?2
https://httpbin.org/get?3
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/JwZ3rtkiSNB1cwX5gCA5?p=preview"" rel=""nofollow"">http://plnkr.co/edit/JwZ3rtkiSNB1cwX5gCA5?p=preview</a></p>
","310726","","","","","2016-10-28 19:52:52","","","","6","","","","CC BY-SA 3.0"
"40312744","2","","40311907","2016-10-28 20:25:21","","2","","<p>This creates two Observables that complete after 1000ms and 900ms. When you run this demo you'll see that the first one completes just a moment after the first one to prove that these we're executed in parallel.</p>

<pre><code>let obs1 = Observable.of('HTTP Response 1').delay(1000);
let obs2 = Observable.of('HTTP Response 2').delay(900);

console.log('Start');

obs1.merge(obs2)
    .subscribe(val =&gt; console.log(val), undefined, () =&gt; console.log('Completed'));
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/hzmpclxDkIhnfTYcWXd5?p=preview"" rel=""nofollow noreferrer"">http://plnkr.co/edit/hzmpclxDkIhnfTYcWXd5?p=preview</a></p>

<p>This prints to console:</p>

<pre><code>Start
HTTP Response 2
HTTP Response 1
Completed
</code></pre>

<p>If you need <code>forkJoin()</code>, then see my previous answer <a href=""https://stackoverflow.com/questions/40303012/observable-forkjoin-doesnt-executes"">Observable.forkJoin() doesn&#39;t executes</a> :).</p>
","310726","","-1","","2017-05-23 12:25:42","2016-10-29 07:27:55","","","","5","","","","CC BY-SA 3.0"
"40335859","1","","","2016-10-31 02:33:48","","1","1088","<p>I am learning Angular2 and RxJS and I'm following someone else's application. In his application, he has two modules. The first is the <code>asObservable.ts</code> file:</p>

<p><strong>asObservable.ts</strong></p>

<pre><code>export function asObservable(subject: Subject) {
    return new Observable(fn =&gt; subject.subscribe(fn));
}
</code></pre>

<p>The second is a file that creates a new <code>BehaviorSubject</code> RxJS object and sends it to the <code>asObservable.ts</code> module</p>

<p><strong>todo-store.service.ts</strong></p>

<pre><code>import {asObservable} from ""./asObservable"";
import {List} from ""immutable"";
import {Todo} from ""./todo"";
// Todo is a customized class

@Injectable()
export class TodoStore {

    private _todos: BehaviorSubject&lt;List&lt;Todo&gt;&gt; = new BehaviorSubject(List([]));

    get todos() {
        return asObservable(this._todos);
    }

    loadInitialData() {
        this.todoBackendService.getAllTodos()
            .subscribe(
                res =&gt; {
                    let todos = (&lt;Object[]&gt;res.json()).map((todo: any) =&gt;
                        new Todo({id:todo.id, description:todo.description, completed: todo.completed}));
                    this._todos.next(List(todos));
                },
                err =&gt; console.log(""Error retrieving Todos"")
            )
    }
    //unnecessary code omitted
 }
</code></pre>

<p>I would like to eliminate the <code>asObservable.ts</code> file and perform the subscribe function in a single function but I can't figure out how it would be done, something like:</p>

<pre><code>get todos() {
    return new Observable(Subject.subscribe(this._todos));
}
</code></pre>

<p>This obviously doesn't work. Could someone give me some pointers on the proper way to do this and a brief explanation of what I am doing wrong?</p>
","3235705","","310726","","2016-10-31 16:59:50","2016-10-31 16:59:50","Rewrite code to have BehaviorSubject subscribe with Observable","<angular><typescript><rxjs><observable><rxjs5>","1","5","","","","CC BY-SA 3.0"
"40341771","1","","","2016-10-31 12:02:01","","2","897","<p>When I subscirbe to form and wait for value changes that break if I resonse is error from my service...</p>

<p>Here is code:</p>

<pre><code>constructor(private fb: FormBuilder, private bankService: BankService) {
        this.page = 1;

        this.filter = this.fb.group({
            text: ['', []],
            bankC: ['', []]
        });

        this.filter.valueChanges
            // wait for a pause in typing of 200ms then emit the last value
            .debounceTime(200)
            // only accept values that don't repeat themselves
            .distinctUntilChanged()
            // map that to an observable HTTP request, using the TickerLoad
            // service and switch to that
            // observable. That means unsubscribing from any previous HTTP request
            // (cancelling it), and subscribing to the newly returned on here.
            .switchMap((val: any) =&gt; {
                return bankService.getCountry(val.bankC)
            })
            .subscribe((res) =&gt; {
                console.log(res);
            },
             (err) =&gt; {
                 console.log(err);
             });
            // send an empty array to tickers whenever clear emits by
            // merging in a the stream of clear events mapped to an
            // empty array.
    }
</code></pre>

<p><strong>Edit</strong></p>

<p>I found what couse problem, it is inside http intreceptor:</p>

<pre><code>intercept(observable: Observable&lt;Response&gt;): Observable&lt;Response&gt; {
        return observable.catch((err, source) =&gt; {
            if (err.status == 401) {
                this._router.navigate(['']);
                return Observable.throw(err);
                //&amp;&amp; !_.endsWith(err.url, 'api/auth/login')
            } else {
               return Observable.throw(err);
            }
        });

    }
</code></pre>

<p>It is this part: <code>return Observable.throw(err);</code></p>

<p>How can I return error without braking subscription.</p>
","2158982","","310726","","2016-10-31 12:37:29","2016-10-31 12:37:29","Error response break valueChanges [Angular2]","<angular><rxjs><observable><rxjs5>","1","7","","","","CC BY-SA 3.0"
"40343835","1","40346998","","2016-10-31 14:06:13","","3","524","<p>I have the following objects:</p>

<pre><code>class Question {
    idQuestion: string;
    question: string;
    typeQuestion: string;
}

class Answer {
    idAnswer: string;
    idQuestion: string;
    answer: string;
}

class Option {
    idOption: string;
    idQuestion: string;
    option;
}
</code></pre>

<p>And I want to populate the following object:</p>

<pre><code>class QuestionOptionsAnswer {
    question: Question;
    answer: Answer;
    options: Option[];
}
</code></pre>

<p>For now, I have a service for each kind of object, so we can illustrate it in the following way:</p>

<pre><code>questionService.getQuestions();
answerService.getAnswers();
optionService.getOptions();
</code></pre>

<p>To populate a <code>questionoptionsanswer</code> object I have doing nested requests:</p>

<pre><code>questionService.getQuestions()
    .subscribe(
        answerService.getAnswers()
           .subscribe(
               optionService.getOptions()
                  .subscribe();
           )
    )
</code></pre>

<p>I can populate correctly the <code>questionoptionsanswer</code> object, but is is slow, so I think I am making a bad approach. The idea behind having a <code>questionoptionsanswer</code> is for rendering in a easy way the <code>html</code> with angular2 directives.</p>

<p>I read about <code>flatMap</code>, <code>switchMap</code>, <code>forkJoin</code> but I am not quite sure in how to use them.</p>

<p>Which could be a good approach to load this data?</p>

<p><code>questionoptionsanswer</code> will have a question object, an answer associated with it, and its possible options depending on the <code>typeQuestion</code> i.e: select, radio, multiple, etc.</p>
","1596786","","310726","","2016-10-31 17:07:08","2016-10-31 17:07:08","Performing advanced http requests in rxjs","<angular><typescript><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"40346998","2","","40343835","2016-10-31 17:06:52","","2","","<p>So you need to call the first request and wait for its response and then call the two other requests (for options and the answer) at the same time.</p>

<p>Since I want to know when both responses are ready I'll use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin"" rel=""nofollow""><code>Observable.forkJoin()</code></a> operator that emits a single array with all values of source Observables when they completed and then add data to the <code>qoa</code> variable that I'll just pass to the Observer when it subscribes. </p>

<p>Operators such <code>concat()</code> or <code>concatMap()</code> are good to make multiple HTTP calls in order but not very useful when you need to create multiple Observable to construct one large response you want to emit (<code>QuestionOptionsAnswer</code> in your case). </p>

<p>I also used <code>Observable.of(...)</code> to simulate HTTP requests. I don't know what's your usecase so you'll maybe don't use <code>Observable.create()</code> and use <code>Subject</code> instead:</p>

<pre><code>function getQOA() {
    return Observable.create(observer =&gt; {

        Observable.of({ question_id: '1' }).subscribe(response =&gt; {
            var qoa = new QuestionOptionsAnswer();
            let question = new Question();
            question.idQuestion = response.question_id;

            qoa.question = question;

            let obs1 = Observable.of({ answer_id: '1', answer: 'bla' });
            let obs2 = Observable.of([{ option_id: '1', option: 'ble' }]);

            Observable.forkJoin(obs1, obs2).subscribe(responses =&gt; {
                let [answerResponse, optionsResponse] = responses;

                let answer = new Answer();
                answer.idAnswer = answerResponse.answer_id;
                answer.answer = answerResponse.answer;
                qoa.answer = answer;

                qoa.options = optionsResponse.map(o =&gt; {
                    let option = new Option();
                    option.idOption = o.option_id;
                    option.option = o.option;
                    return option;
                });

                observer.next(qoa);
            });
        });
    });
}

getQOA().subscribe(qoa =&gt; console.log(qoa));
</code></pre>

<p>Prints to console:</p>

<pre><code>QuestionOptionsAnswer {
  question: Question { idQuestion: '1' },
  answer: Answer { idAnswer: '1', answer: 'bla' },
  options: [ Option { idOption: '1', option: 'ble' } ] }
</code></pre>
","310726","","","","","2016-10-31 17:06:52","","","","0","","","","CC BY-SA 3.0"
"40358948","1","","","2016-11-01 11:14:56","","2","684","<p>I am working on an AngularFire2 application and want to implement basic authentication. The authentication itself works so far but, additionally I want to create a user object upon registration, so that each user has a profile in the database. The main issue here is that almost all methods on the AngularFire2 service return promises. On the other hand the db service works with observables and the combination of <code>firebase.Promise</code> and observables somehow doesn't work as expected.</p>

<p>So for instance, this does't work:</p>

<pre><code>Observable.fromPromise(() =&gt; this.auth$.createUser(credentials))
</code></pre>

<p>This results in an error saying <code>Argument of type 'Promise&lt;FirebaseAuthState&gt;' is not assignable to parameter of type 'Promise&lt;{}&gt;'</code>.</p>

<p>The same applies for the <code>set</code> method on a <code>db.object</code>. I don't know how to fix this issue.</p>

<p>My idea was to work with the promises but at some point I have to cast from an observable to a promise then. This is what I have:</p>

<p><strong>auth.service.ts</strong></p>

<pre><code>register(credentials: ICredentials): firebase.Promise&lt;FirebaseAuthState&gt; {
  return this.auth$.createUser(credentials)
    .then((response: FirebaseAuthState) =&gt; this.userService.createUserEntity(response))
    .then(() =&gt; this.postSignIn())
    .catch((error: Error) =&gt; this.onError(error));
}
</code></pre>

<p><strong>user.service.ts</strong></p>

<pre><code>createUserEntity(response: FirebaseAuthState): Promise&lt;boolean&gt; {
  this.user = this.db.object(`/users/${response.uid}`);

  return this.user
    .take(1)
    .filter((snapshot: Snapshot) =&gt; !snapshot.$exists())
    .mergeMap(() =&gt; this.createUser(response))
    .toPromise();
}

private createUser(response: FirebaseAuthState): Observable&lt;any&gt; {
  const { email, displayName, photoURL, providerId } = response.auth;

  return Observable.of(new User(email, displayName, photoURL, providerId))
    .mergeMap((user) =&gt; this.saveUserEntity(user));
}

private saveUserEntity(user): Promise&lt;any&gt; {
  return new Promise((resolve, reject) =&gt; {
    this.user.set(user).then(() =&gt; {
      console.log('RESOLVE');
      resolve();
    });
  });
}
</code></pre>

<p>As you can see in the <code>saveUserEntity</code>, I even tried to work around by creating a promise myself and resolving it. But somehow this never resolves in the source promise chain in <code>register()</code>. The <code>console.log</code> in <code>saveUserEntity</code> is called but it never goes up again, and the promise chain doesn't continue to work. Again, <code>fromPromise</code> somehow has the same behavior. However, I can replace the body of <code>saveUserEntity</code> with <code>Promise.resolve(1)</code> and everything works. Somehow the <code>this.user.set</code> messes things up.</p>

<p>Any ideas?</p>
","2533225","","","","","2016-11-01 11:32:00","AngularFire2 methods which return a promise do not work with fromPromise","<javascript><angular><firebase><rxjs5><angularfire2>","1","0","","","","CC BY-SA 3.0"
"40361623","1","40362172","","2016-11-01 14:01:59","","2","2616","<p><code>Subject.subscribe</code> method when called outputs the following error: </p>

<pre><code>TypeError: Cannot read property '_subscribe' of undefined
at BidirectionalSubject._subscribe (Rx.js:10239)
at BidirectionalSubject._subscribe (Rx.js:10239)
at BidirectionalSubject.Observable.subscribe (Rx.js:9924)
at AppComponent.doIt (app.component.ts:32)
at ChangeDetector_AppComponent_0.handleEventInternal (eval at ChangeDetectorJITGenerator.generate (angular2.dev.js:1), &lt;anonymous&gt;:29:29)
at ChangeDetector_AppComponent_0.AbstractChangeDetector.handleEvent (angular2.dev.js:8788)
at AppView.dispatchEvent (angular2.dev.js:9396)
at AppView.dispatchRenderEvent (angular2.dev.js:9391)
at DefaultRenderView.dispatchRenderEvent (angular2.dev.js:7819)
at eventDispatcher (angular2.dev.js:9781)
</code></pre>

<h2>See Plunkr <a href=""https://plnkr.co/edit/UYJJuFeR1ZrWAPaxsA8D"" rel=""nofollow noreferrer"">here</a>.</h2>

<hr>

<p>This is a part of a bigger problem I am facing. <strong>In my actual code, the <code>subscribe</code> method does not throw but it simply does not add an <code>observer</code> to the <code>subject</code>, and hence on all <code>subject.next</code> invocations no one receives the emitted data.</strong></p>

<p>I think the problems are related. In my actual code I am using version <code>5.0.0-beta.12</code> of rxjs. In the plukr though, the <code>rx</code> dependency seems to be coming from angular itself.</p>
","1958893","","5765795","","2017-09-20 09:22:26","2017-09-20 09:22:26","RxJs Subject.subscribe method not working as expected","<angular><typescript><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"40362172","2","","40361623","2016-11-01 14:30:57","","4","","<p><strong>Be aware of using <code>Subject.create()</code>.</strong> </p>

<p>This is not the same as <code>new Subject()</code> and absolutely most of the time you want to use just <code>new Subject()</code> instead of <code>Subject.create()</code>. With <code>Subject.create()</code> you're creating an instance of <code>AnonymousSubject</code> which never subscribes itself and therefore the <code>flatMap()</code> operator throws an error when trying to subscribe <code>AnonymousSubject</code> to another <code>AnonymousSubject</code>.</p>

<p>See my answer to a similar question: <a href=""https://stackoverflow.com/questions/40159886/subjects-created-with-subject-create-cant-unsubscribe/40164700#40164700"">Subjects created with Subject.create can&#39;t unsubscribe</a>.</p>

<p>I just changed <code>Subject.create()</code> to <code>new Subject()</code> and it's probably working.</p>

<p>See your updated demo: <a href=""https://plnkr.co/edit/6M1lPLZA16vwQsVAjNzc?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/6M1lPLZA16vwQsVAjNzc?p=preview</a></p>

<p>Although, I don't know what's that demo supposed to do so I can't tell whether it's working correctly.</p>
","310726","","-1","","2017-05-23 12:25:42","2016-11-01 14:30:57","","","","2","","","","CC BY-SA 3.0"
"40366396","1","","","2016-11-01 18:32:51","","4","257","<p>I am trying to use <code>@ngrx/store</code> to keep track of the values in a form. One of the inputs can only have digits. When I enter data, the Redux state is correctly storing only digits, but the updated value is not being reflected in the input field, it still shows the un-sanitized value.</p>

<p>EDITED: This problem isn't specific to ngrx/store. Populating the value of the input field from any observable causes this issue. Tried storing the data in a Behavior Subject from an @Injectable class and exposing publicly <code>.asObservable()</code> but ran into the same issue.</p>

<p>e.g.) </p>

<p>Input value of ""123abc""</p>

<p>Redux stores ""123"" (Correct)</p>

<p>Input field still shows ""123abc"" (Incorrect, doesn't match Redux state)</p>

<p>EDITED: If we use sample input of <code>123abc</code> and then type in the digit <code>4</code>, we visually see the input value update to <code>1234</code>, same as the Redux store.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class InputComponent {
  private value: Observable&lt;string&gt;;

  constructor(private store: Store&lt;IAppState&gt;) {
    this.value = store
      .map(appState =&gt; appState.form.value)
      .distinctUntilChanged();
  }

  public onChange(value: string): void {
    const sanitizedValue: string =
      value.replace(/\D/g, '');

    this.store.dispatch(updateValue(sanitizedValue));
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div&gt;
  &lt;input
    autofocus
    type=""tel""
    [ngModel]=""(value | async)""
    id=""form-value""
    (ngModelChange)=""onChange($event)""
  /&gt;
  &lt;label for=""form-value""&gt;Form Value&lt;/label&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","3734026","","3734026","","2016-11-09 13:39:25","2016-11-09 13:39:25","Setting value of <input/> in Angular 2 via observable","<javascript><angular><rxjs5>","0","0","1","","","CC BY-SA 3.0"
"40376594","1","","","2016-11-02 09:37:09","","2","839","<p>I'm new to rxjs.
I wanted to know whether below code is correct or any correction needed?</p>

<pre><code>var rxjs_1 = require('rxjs');    
rxjs_1.Observable.defer(function() {

            })

            .cache(1);
</code></pre>

<p>By above code I'm facing issue with cache (it is throwing the error : rxjs_1.Observable.defer(...).cache is not a function).</p>

<p>I checked in node_modules for the installed rxjs and in Observable.js file there is no method called cache.</p>

<p>could you please tell me how to call cache on Observable in rxjs.</p>
","2313833","","","","","2016-11-02 11:59:26","How to call cache method on Observables in rxjs","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"40378344","1","40976344","","2016-11-02 11:02:39","","1","611","<p>I have a UI like this:</p>

<p><a href=""https://i.stack.imgur.com/iFsjC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iFsjC.png"" alt=""enter image description here""></a></p>

<p>Where I can</p>

<ul>
<li>Enter something in search box</li>
<li>Drag users from table to chart</li>
</ul>

<p>The logic required is:</p>

<ul>
<li>Initially chart shows some subset of all users (e.g., first 10)</li>
<li>When users are dragged on chart they are added to the users that already there</li>
<li>When filter is applied all users are removed from chart and then it is repopulated with some subset of matching users</li>
</ul>

<p>I am trying to implement such logic with RxJs.
I have <code>filteredUsers$</code> and <code>addedUsers$</code> stream that produce users matching filter and dragged users correspondingly.</p>

<p>I need to combine them in such way:</p>

<pre><code>        Observable
            .&lt;OPERATOR&gt;(filteredUsers$, addedUsers$)
            .subscribe(([filteredUsers, addedUsers]) =&gt; {
                // When filteredUsers$ fires:
                //   filteredUsers is value from stream
                //   addedUsers == null

                // When addedUsers$ fires:
                //   filteredUsers is latest available value
                //   addedUsers is value from stream

                redrawChart(/* combining users */)
            });
</code></pre>

<p>Any ideas how I can achieve this?</p>

<p>Time sequence:</p>

<pre><code>Filtered: -  a  -  -  -  -  a  -  -&gt;
Added   : -  -  b  -  b  -  -  -  -&gt;
Result  : -  a  ab -  ab -  a  -  -&gt;
</code></pre>
","1010664","","1010664","","2016-11-07 11:41:35","2016-12-07 10:14:22","RxJs. Combining latest and once","<rxjs><rxjs5>","3","2","","","","CC BY-SA 3.0"
"40383825","2","","40278971","2016-11-02 15:30:16","","0","","<p>The simples way is to wrap your AsyncSubject in another object that handles the logic of calling 1 subscriber only. Assuming you want to invoke the 1st subscriber only, the code below should be a good starting point</p>

<pre><code>let as = new AsyncSubject();

const createSingleSubscriberAsyncSubject = as =&gt; {
    // define empty array for subscribers
    let subscribers = [];

    const subscribe = callback =&gt; {
        if (typeof callback !== 'function') throw new Error('callback provided is not a function');

        subscribers.push(callback);

        // return a function to unsubscribe
        const unsubscribe = () =&gt; { subscribers = subscribers.filter(cb =&gt; cb !== callback); };
        return unsubscribe;
    };

    // the main subscriber that will listen to the original AS
    const mainSubscriber = (...args) =&gt; {
        // you can change this logic to invoke the last subscriber
        if (subscribers[0]) {
            subscribers[0](...args);
        }
    };

    as.subscribe(mainSubscriber);

    return {
        subscribe,
        // expose original AS methods as needed
        next: as.next.bind(as),
        complete: as.complete.bind(as),
    };
};

// use

const singleSub = createSingleSubscriberAsyncSubject(as);

// add 3 subscribers
const unsub1 = singleSub.subscribe(() =&gt; console.log('subscriber 1'));
const unsub2 = singleSub.subscribe(() =&gt; console.log('subscriber 2'));
const unsub3 = singleSub.subscribe(() =&gt; console.log('subscriber 3'));

// remove first subscriber
unsub1();

setTimeout(() =&gt; {
    as.next(undefined);
    as.complete();
    // only 'subscriber 2' is printed
}, 500);
</code></pre>
","3716153","","","","","2016-11-02 15:30:16","","","","6","","","","CC BY-SA 3.0"
"40388785","1","40397535","","2016-11-02 20:04:03","","3","792","<p>Silly question that has me stumped.  I want to give a different debounceTime based on data in the stream.  I have:</p>

<pre><code>const fakeData = [{number: 1}, {number: 2}, {number: 3}];
const stream$ = Rx.Observable.from(fakeData);
const delayedStream$ = stream$.concatMap(x =&gt; Rx.Observable.of(x).delay(300));

delayedStream$
  .concatMap(x =&gt; x.number &gt;=2 
      ? Rx.Observable.of(x).debounceTime(500)
      : Rx.Observable.of(x).debounceTime(1000)
   )
  .subscribe(x =&gt; console.log(x));
// expected output: 3
// actual output:  1 ... 2 ... 3 |
</code></pre>

<p><a href=""http://jsbin.com/dafaxoraca/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/dafaxoraca/edit?js,console</a></p>

<p>The above code simply returns x without a debounce.  But if I replace debounceTime with delay, the delay works as expected.  I'm obviously missing something fundamental between the two operators.  I've gone through the docs and am not getting it.</p>

<p>Thanks for your help!</p>
","5220820","","","","","2020-01-06 14:54:36","Alter debounceTime on stream data","<rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"40397535","2","","40388785","2016-11-03 09:09:47","","3","","<p>I can't test this with your actual use-case but you're not using <code>debounceTime</code> correctly.</p>

<p>Operator <code>debounceTime</code> applies debounce only on this Observable stream and its data. Since you're chaining <code>concatMap</code> and the returned Observable with <code>debounceTime</code>, the concat will always wait until the Observable completes. So this always returns all three values.</p>

<p>You can use <code>debounce()</code> that expects to get an Observable that lets you use delay by emitting values instead of hardcoded time.</p>

<pre><code>const fakeData = [{number: 1}, {number: 2}, {number: 3}];
const stream$ = Rx.Observable.from(fakeData);
const delayedStream$ = stream$.concatMap(x =&gt; Rx.Observable.of(x).delay(300));

delayedStream$
    .debounce(val =&gt; Rx.Observable.of(true).delay(val &gt;= 2 ? 500 : 1000))
    .subscribe(x =&gt; console.log(x.number));
</code></pre>

<p>See live demo: <a href=""http://jsbin.com/tifajodogi/1/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/tifajodogi/1/edit?js,console</a></p>

<p>This emits just: <code>3</code></p>

<hr>

<p>Update: Since RxJS 5.5+ the same technique can be restructured like so:</p>

<pre><code>const fakeData = [{number: 1}, {number: 2}, {number: 3}];
const stream$ = from(fakeData);
const delayedStream$ = stream$.pipe(concatMap(x =&gt; of(x).pipe(delay(300))));

delayedStream$.pipe(
  debounce(val =&gt; of(true).pipe(delay(val &gt;= 2 ? 500 : 1000)))
  subscribe(x =&gt; console.log(x.number))
);
</code></pre>
","310726","","310726","","2020-01-06 14:54:36","2020-01-06 14:54:36","","","","1","","","","CC BY-SA 4.0"
"40397738","1","40399513","","2016-11-03 09:19:54","","0","606","<p>I'm trying to respond to a merged observable of touch and mousedown events to toggle a menu open/close. The problem is that the code to handle the toggle is running twice. I've confirmed this by logging the event to the console, and it's the same event that is logged:</p>

<pre><code>export const toggleMenu = (openButton, closeButton) =&gt; {
  return Observable.merge(
    Observable.fromEvent(openButton, 'mousedown'),
    Observable.fromEvent(closeButton, 'mousedown'))
      .subscribe((event) =&gt; {
        console.log(event);
        if (elementIsVisible(nav)) {
          hideElement(nav);
        } else {
          showElement(nav);
        }
      });
};
</code></pre>

<p>So this ends up opening then immediately closing the menu.</p>
","931036","","","","","2016-11-03 10:46:13","RxJS 5 fromEvent observable subscribe called twice","<javascript><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"40399513","2","","40397738","2016-11-03 10:46:13","","0","","<p>Ok, this was my mistake. The actual posted code is fine, but I was instantiating the class that called this function twice, so there were two subscriptions.</p>
","931036","","","","","2016-11-03 10:46:13","","","","0","","","","CC BY-SA 3.0"
"40400979","1","40860884","","2016-11-03 12:02:04","","1","517","<p>Basically I have two subscriptions that fire events now and then.</p>

<p>First one is pretty straightforward, it loads and displays some data:</p>

<pre><code>observableOne$.switchMap(event =&gt; {
  return loadData(event);
}).subscribe(data =&gt; {
  displayData(data);
});
</code></pre>

<p>Second one transform displayed data, and the transformation should be done only once:</p>

<pre><code>observableTwo$.subscribe(event =&gt; {
  transformDisplayedData(event);
});
</code></pre>

<p>The problem I am facing is that if second event is fired right after first, then transformation is lost. And I can't reapply, it is one time action.</p>

<p>Is there a way to postpone transformation if <code>observableOne$</code> fired recently?</p>

<p>Time sequence will look like so:</p>

<pre><code>One      : -a----------a-----&gt;
Two      : -----b------b-----&gt;
Display  : ---a----------a---&gt; // lag is due to async data loading
Transform: -----b--------b---&gt;
</code></pre>

<p><strong>EDIT</strong></p>

<p>I have created a <a href=""https://fiddle.jshell.net/WiseBird/mc8h52r7/2/"" rel=""nofollow noreferrer"">fiddle</a> with demonstration. The actual time sequence can be written like this:</p>

<pre><code>PageClick      : -x----------x-----&gt;
HighlightClick : -----x------x-----&gt;
DataRender     : ---x----------x---&gt;
DataHighlight  : -----x------x-----&gt;
</code></pre>

<p>When PageClick and HighlightClick come together data is highlighted and a second later rendered. But I want to postpone highlighting, hence desired time sequence: </p>

<pre><code>PageClick      : -x----------x-----&gt;
HighlightClick : -----x------x-----&gt;
DataRender     : ---x----------x---&gt;
DataHighlight  : -----x--------x---&gt;
</code></pre>
","1010664","","1010664","","2016-11-23 10:38:18","2016-11-29 08:19:59","RxJs. How to wait for other observable if it fired recently","<rxjs><rxjs5>","1","10","","","","CC BY-SA 3.0"
"40407540","1","40522372","","2016-11-03 17:14:16","","0","75","<p>I'm pretty new to Reactive Programming but already in love. However it is still hard to switch my brain to it. I'm trying to follow all recommendations as ""Avoid using subjects"" and ""Avoid impure functions"" and of course ""Avoid imperative code.""</p>

<p>What I'm finding hard to achieve is simple cross modules communications where one module can register ""action""/observable and the other could subscribe and react to it. A simple message bus will probably work but this will enforce the usage of Subjects and imperative code style which I'm trying to avoid.</p>

<p>So here is a simple starting point I'm playing with:</p>

<pre><code>    // some sandbox
class Api {
  constructor() {
    this.actions = {};
  }

  registerAction(actionName, action) {
    // I guess this part will have to be changed
    this.actions[actionName] = action.publishReplay(10).refCount();
    //this.actions[actionName].connect();
  }

  getAction(actionName) {
    return this.actions[actionName];
  }
}

const api = new Api();

// -------------------------------------------------------------------
// module 1
let myAction = Rx.Observable.create((obs) =&gt; {
  console.log(""EXECUTING"");
  obs.next(""42 "" + Date.now());
  obs.complete();
});

api.registerAction(""myAction"", myAction);

let myTrigger = Rx.Observable.interval(1000).take(2);

let executedAction = myTrigger
.flatMap(x =&gt; api.getAction(""myAction""))
.subscribe(
  (x) =&gt; { console.log(`executed action: ${x}`); },
  (e) =&gt; {}, 
  () =&gt; { console.log(""completed"");});

// -------------------------------------------------------------------
// module 2
api.getAction(""myAction"")
  .subscribe(
  (x) =&gt; { console.log(`SECOND executed action: ${x}`); },
  (e) =&gt; {}, 
  () =&gt; { console.log(""SECOND completed"");});
</code></pre>

<p>So currently at the moment the second module subscribes it ""triggers"" the ""myAction"" Observable. And in a real life scenario that could be an ajax call. Is there any way to make all subscribers delay/wait until ""myAction"" is called properly from module1? And again - its easy to do it using subjects but I'm trying to do it following recommended practices.</p>
","1875216","","","","","2016-11-10 07:48:14","RxJS/ReactiveX Proper modules communication","<rxjs><rxjs5><reactivex><reactive-extensions-js>","2","2","","","","CC BY-SA 3.0"
"40437428","1","40443667","","2016-11-05 11:01:05","","2","9253","<p>Below is my component code where I am trying to use RxJS ""throttle"" operator.</p>

<pre><code>import { Component , OnInit , OnChanges , DoCheck  } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/throttle';

@Component({
    selector:'rx1',
    template: `
    &lt;h2&gt; Rx1 Component &lt;/h2&gt;
    &lt;button name=""btn"" valur=""click""&gt; 
})

export class Rx1Component implements OnInit {   

    ngOnInit() {
        var button = document.getElementsByTagName('button');

        Observable.fromEvent(button, 'click')
            .throttle(1000) 
            .subscribe(() =&gt; console.log('clicked....'));
    }
}
</code></pre>

<p>The intention of this simple sample is to print ""clicked...."" only when there is a min gap of 1 sec between clicks.</p>

<p>But when I compile this code , it display below error and it points to "".throttle(1000)"" line.</p>

<blockquote>
  <p>Argument of type 'number' is not assignable to parameter of type '(value: {}) => SubscribableOrPromise'.</p>
</blockquote>

<p>What is the mistake I am doing.</p>
","2693545","","310726","","2016-11-05 19:15:15","2016-11-05 22:02:12","How to use RxJS ""throttle"" operator in Angular 2","<angular><rxjs><rxjs5>","1","5","1","","","CC BY-SA 3.0"
"40443667","2","","40437428","2016-11-05 22:02:12","","5","","<p>As others have suggested <code>throttle()</code> takes as an argument an Observable not the duration. However, what you describe suits more for a <code>debounceTime()</code> operator.</p>

<p>One thing worth mentioning is that since you're using Angular2 you're <strong>always using RxJS 5</strong> and not the old RxJS 4. I guess you've found <code>throttle</code> here <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/throttle.md"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/throttle.md</a> or <a href=""http://reactivex.io/documentation/operators/debounce.html"" rel=""noreferrer"">http://reactivex.io/documentation/operators/debounce.html</a> but these both describe RxJS 4.</p>

<p>The correct doc for RxJS 5 is <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-throttle"" rel=""noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-throttle</a> and as you can see there're <code>throttle()</code> and <code>throttleTime()</code>.</p>
","310726","","","","","2016-11-05 22:02:12","","","","0","","","","CC BY-SA 3.0"
"40445418","1","40448489","","2016-11-06 02:27:31","","10","3531","<p>I'm a stuck in nested observable hell and could do with a hand.</p>

<p>I have the following block of code</p>

<pre><code>return this.findUser(term).map( users =&gt; {
  return users.map( user =&gt; this.getLastLogin(user.user_id).map( last_login =&gt; {
    user.last_login = last_login;
    return user;
  }));
});
</code></pre>

<p><code>findUser</code> returns <code>Observable&lt;User[]&gt;</code> and <code>getLastLogin</code> returns <code>Observable&lt;number&gt;</code>.</p>

<p>I'm basically hoping to fetch a list of users and then update this with the information from another value.</p>

<p>Right now the code above is returning <code>&lt;Observable&lt;Observable&lt;User&gt;[]&gt;</code>.</p>

<p>I thought I could replace the initial <code>map</code> with <code>flatMap</code> but this turns the object into <code>&lt;Observable&lt;Observable&lt;User&gt;&gt;</code>.</p>

<p>The RxJS documentation is a little hard to decipher so I'm not sure what combination of <code>switch</code>, <code>forkJoin</code> or <code>flatMap</code> will get me to what I need.</p>

<p>I'm hoping to return <code>Observable&lt;User[]&gt;</code>. Could anyone point me in the right direction?</p>
","3750194","","310726","","2016-11-06 11:00:28","2016-11-06 19:13:13","Flattening nested Observables","<javascript><angular><rxjs><observable><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"40448489","2","","40445418","2016-11-06 10:53:33","","9","","<p>Actually, you don't need <code>forkJoin()</code> nor <code>switch()</code> to do this.</p>

<p>In general, you want to update each user in the array of users by another async call.</p>

<p>I'd do it like this:</p>

<pre><code>var source = findUser('term')
    .mergeAll()
    .mergeMap(user =&gt; getLastLogin(user.user_id)
        .map(last_login =&gt; {
            user.last_login = last_login;
            return user;
        })
    )
    .toArray();

source.subscribe(val =&gt; console.log(val));
</code></pre>

<p>Operator <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeAll"" rel=""noreferrer""><code>mergeAll()</code></a> converts a higher-order Observable into single observables. In this case it takes the array of all users and re-emits them one by one. Then <code>mergeMap()</code> emits users updated with the <code>last_login</code> date. At the end I used <code>toArray()</code> to transform single users into one large array that is them emitted as whole (you can remove this operator if you want to emit single users instead).</p>

<p>Note that when you used <code>return users.map(...)</code> you were using <code>Array.map()</code> that returns an array and not <code>map()</code> from RxJS that returns an Observable. I think working with single objects is usually easier that with arrays of objects. </p>

<p>See live demo: <a href=""https://jsbin.com/naqudun/edit?js,console"" rel=""noreferrer"">https://jsbin.com/naqudun/edit?js,console</a></p>

<p>This prints to console:</p>

<pre><code>[ { name: 'foo',
    user_id: 42,
    last_login: 2016-11-06T10:28:29.314Z },
  { name: 'bar',
    user_id: 21,
    last_login: 2016-11-06T10:28:29.316Z } ]
</code></pre>
","310726","","310726","","2016-11-06 19:13:13","2016-11-06 19:13:13","","","","5","","","","CC BY-SA 3.0"
"40455579","1","40460900","","2016-11-06 23:06:12","","2","269","<p>I've successfully migrated a larger Excel calculation to JS using RxJS. Any input data is represented as an Observable and subsequent calculations are implemented with <code>.map</code> and <code>.combineLatest</code> when any Excel formula uses more than one input. </p>

<p>This works great except for one problem. Here is a simplified example:
<a href=""https://i.stack.imgur.com/yt9hG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yt9hG.png"" alt=""Excel screenshot""></a></p>

<p>Three inputs (<code>a$=1</code>, <code>b$=2</code>, <code>c$=3</code>) are used in two different calculations (<code>$ab = $a+$b = 3</code> in the first, <code>$bc = $b+$c = 5</code> in the second) as intermediate steps to calculate the final result <code>$abbc = $ab + $bc = 8</code>. </p>

<p>When $b is now updated/emitting a new input value (e.g. <code>4</code>), $abbc is calculated twice - first when $ab is updated (resulting in the wrong result <code>$abbc=10</code>) and again when $bc is updated, resulting in the correct result <code>12</code>.</p>

<p>While the final result is correct, the intermediate calculation is both wrong and redundant. Is there any way to only execute the last calculation in case <code>$b</code> gets updated - while still also updating the calculation when <code>a$</code> or <code>c$</code> is updated (which would rule out the zip operator). I understand that this example can obviously be simplified to leave out the intermediate steps and calculated <code>$abbc</code> directly from <code>$a</code>, <code>$b</code> and <code>$c</code> - but in the real live example this is not possible/feasible.</p>

<p>Here's the running example in JSbin: <a href=""https://jsbin.com/pipiyodixa/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/pipiyodixa/edit?js,console</a></p>
","1867581","","310726","","2016-11-07 08:54:11","2016-11-08 22:48:02","Other operator in calculation chain than combineLatest to avoid redundant calculations","<javascript><rxjs><rxjs5><ngrx>","2","4","0","","","CC BY-SA 3.0"
"40457343","1","40457448","","2016-11-07 03:23:23","","1","199","<p>I am looking in to sample which has this filter:</p>

<pre><code>Observable.fromEvent(this.getNativeElement(this.btn), 'click')
      .filter(event =&gt; event.shiftKey)
      .map(event =&gt; 'Beast Mode Activated!!!')
      .subscribe(message =&gt; this.message = message);
</code></pre>

<p>This one referencing <code>""rxjs"": ""5.0.0-beta.5""</code></p>

<p>In my project I am getting an error:</p>

<p><code>[ts] Property 'shiftKey' does not exist on type '{}'. any</code></p>

<p>I am referencing <code>""rxjs"": ""5.0.0-beta.12""</code></p>

<p>I've got same error in both cases.</p>

<p>that is what I've got in imports:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
</code></pre>
","2926340","","2926340","","2016-11-07 03:36:04","2016-11-07 03:43:04","Rxjs filter shiftKey","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40457448","2","","40457343","2016-11-07 03:36:48","","2","","<p>Because there's no type information on <code>event</code></p>

<pre><code>.filter(event =&gt; event.shiftKey)
</code></pre>

<p>it is just treated as <code>{}</code> type. You can ""cast"" it or specify a type</p>

<pre><code>.filter((event: any) =&gt;
.filter((event: ExpectedEventType) =&gt;
.filter(event =&gt; (&lt;any&gt;event).shiftKey)
</code></pre>

<p>Any of these should work. With the <code>ExpectedEventType</code>, it should be replace with the actual type of event. This is only if you care for strong typing. If that's not a concern, using <code>any</code> should be fine.</p>
","2587435","","2587435","","2016-11-07 03:43:04","2016-11-07 03:43:04","","","","5","","","","CC BY-SA 3.0"
"40457929","1","","","2016-11-07 04:37:34","","0","307","<p>I have such code taken from the rxjs sample:</p>

<pre><code> Observable.fromEvent(this.getNativeElement(this.right), 'click')
      .map(event =&gt; 10)
      .startWith({x: 400, y: 400})
      .scan((acc, curr) =&gt; Object.assign({}, acc, {x: acc.x + curr}))
      .subscribe(position =&gt; this.position = position);
</code></pre>

<p>Typescript giving such error:</p>

<pre><code>[ts] Argument of type '{ x: number; y: number; }' is not assignable to parameter of type 'number | Scheduler'.
       Object literal may only specify known properties, and 'x' does not exist in type 'number | Scheduler'.
</code></pre>

<p>How to fix that?</p>
","2926340","","","","","2016-11-07 07:06:57","rxjs typescript error Argument of type","<typescript><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"40460900","2","","40455579","2016-11-07 08:38:59","","2","","<p>The problem here is that RxJS's behavior is correct by its design.</p>

<p>It really should first update <code>b</code> => <code>ab</code> => <code>abbc</code> and then <code>bc</code> => <code>abbc</code>. It processed values in streams.</p>

<p>What you want is to process values in ""layers"".<code>a</code>, <code>b</code>, <code>c</code>, then <code>ac</code> , <code>bc</code> and after that calculate final value <code>abbc</code>.</p>

<p>The only way I can think of is to make use of JavaScript execution context and a trick with <code>setTimeout(() =&gt; {}, 0)</code>. This way you don't schedule any timeout (in fact the real <a href=""https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout#Reasons_for_delays_longer_than_specified"" rel=""nofollow noreferrer"">timeout might be <code>&gt; 0</code></a>) and just run the closure in another execution context after JavaScript finishes executing the current one. </p>

<p>The bad thing is that to avoid re-emitting values multiple times you need to cache even more (because of <code>merge()</code>):</p>

<pre><code>var b2$ = b$.cache(1);

var ab$ = a$
  .combineLatest(b2$, (a, b) =&gt; a + b)
  .do(x =&gt; console.log('$a + $b = ' + x))
  .cache(1);

var bc$ = b2$
  .combineLatest(c$, (b, c) =&gt; b + c)
  .do(x =&gt; console.log('$b + $c = ' + x))
  .cache(1);

var abbc$ = new Rx.Observable.merge(ab$, bc$)
  .auditTime(0)
  .withLatestFrom(ab$, bc$, (_, ab, bc) =&gt; ab + bc)
  .do(x =&gt; console.log('$ab + $bc = ' + x));

console.log(""Initial subscription:"")
abbc$.subscribe();

b$.next(4);
</code></pre>

<p>The <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-auditTime"" rel=""nofollow noreferrer""><code>auditTime()</code></a> operator is the most important thing here. It triggers <code>withLatestFrom()</code> to update it's value while when it's triggered for first time by <code>ab$</code> or <code>bc$</code> it ignores all consecutive emits until the end of this closure execution (that's the <code>setTimeout()</code> trick).</p>

<p>See live demo: <a href=""https://jsbin.com/zoferid/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/zoferid/edit?js,console</a></p>

<p>Also, if you add <code>a$.next(5);</code> the final calculation is executed just once (which might be both good or bad :)).</p>

<p>I don't know if this solves your problem because as I said RxJS works this way. I haven't tested it on any more complicated example so maybe this is not the way you can use at the end.</p>

<p>Note that <code>cache()</code> operator was removed in RC.1 and there's no replacement for now: <a href=""https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md</a></p>
","310726","","310726","","2016-11-07 14:29:47","2016-11-07 14:29:47","","","","1","","","","CC BY-SA 3.0"
"40464108","1","40464581","","2016-11-07 11:29:26","","3","1372","<p>I'm handling a mouseover event using <code>Observable.fromEvent()</code>, with various chained operators. How would I go about unit testing this?</p>

<pre><code>export const bindMouseover = (link) =&gt; Observable.fromEvent(link, 'mouseover')
    .filter(event =&gt; Nav.hasSubNav(event.target))
    .map(event =&gt; Nav.getSubNav(event.target))
    .filter(target =&gt; !Nav.elementIsVisible(target))
    .subscribe((target) =&gt; {
      Nav.hideElements(subNavs);
      Nav.showElement(target);
    });
</code></pre>
","931036","","","","","2016-11-07 12:00:38","How to test RxJS events","<javascript><rxjs><rxjs5><rxjs-dom>","1","0","","","","CC BY-SA 3.0"
"40464581","2","","40464108","2016-11-07 11:54:39","","0","","<p>There's a chapter on testing RxJS chains in the RxJS 4 documentation but the principles applies to RxJS 5 as well: <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/testing.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/testing.md</a></p>

<p>If you want to unit test RxJS custom operators or operator chains there's official documentation: <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md</a> (However, this document doesn't tell you where you can import features listed there in your own code).</p>

<p>Also, have a look at how RxJS is tested itself. For example <a href=""https://github.com/ReactiveX/rxjs/blob/master/spec/operators/map-spec.ts"" rel=""nofollow noreferrer"">testing <code>map()</code> operator</a> (btw, these are <code>mocha</code> tests). Note how Hot and Cold Observables are made with this short notation <code>cold('--1--2--3--|')</code> and then compared with the expected <code>'--x--y--z--|'</code> using <a href=""https://github.com/ReactiveX/rxjs/blob/260d335f497a2de223b164ea9705699e7f306d7d/src/testing/TestScheduler.ts#L75"" rel=""nofollow noreferrer""><code>expectObservable</code> that comes from TestScheduler</a>.</p>

<p>If you wanted to use also the short notation with <code>cold(...)</code>, <code>hot(...)</code> and others you'd need to grab the source code, compile it with <code>npm run build_test</code> and then use the same options for <code>mocha</code> as the original. <a href=""https://github.com/ReactiveX/rxjs/blob/master/package.json#L91"" rel=""nofollow noreferrer"">See <code>package.json</code></a> and the default options for <a href=""https://github.com/ReactiveX/rxjs/blob/master/spec/support/default.opts"" rel=""nofollow noreferrer""><code>mocha</code> in <code>default.opts</code></a>. I'm not aware of any easier solution right now.</p>

<p>The short notation just makes things easier and more readable but you don't need it in fact. You can use the regular test Observables (<code>TestScheduler</code>, <code>ColdObservable</code> and <code>HotObservable</code>) already since they're part of the standard <code>rxjs</code> package. <a href=""https://github.com/ReactiveX/rxjs/tree/master/src/testing"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/tree/master/src/testing</a> (<code>node_modules/rxjs/testing</code>)</p>

<p>Also see: <a href=""https://stackoverflow.com/questions/40256541/how-to-debug-observable-values-in-angualr2-typescript/40256977#40256977"">How to debug Observable values in Angualr2 / Typescript?</a></p>
","310726","","-1","","2017-05-23 12:13:33","2016-11-07 12:00:38","","","","1","","","","CC BY-SA 3.0"
"40464943","1","40465158","","2016-11-07 12:13:37","","0","2448","<p>i will start by adding the code, result i get and in the end what i would like to obtain and if it is possible.</p>

<p>The result which i'm getting  is Array[object, object, ...] where object is Array </p>

<pre><code>export class SomeService {
           ....
           .... 
     public someFunction(): MyObject[]{
         Observable
            .forkJoin(this.userItemsA(userId), this.userItemsB(userId), etc)
             .filter(each =&gt; {
                      for (let array of each) {
                            let x: any = &lt;any&gt; array;
                               return x.length &gt; 0;
                            }
                        })
             .map(result =&gt; {
                   return result;
              })
            .subscribe(result =&gt; {
                  /// what i would like to do for example assuming only 1st array has items
                  /// do something here with result[0] 
                  /// return MyObject[] from result[0]
        });
    ....
    }
}
</code></pre>

<blockquote>
  <p>Filter structure</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/u6qqa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/u6qqa.png"" alt=""filter structure""></a></p>

<p>I'm in my early learning stage of angular2 and reactive programming, what i would like is to filter so that the map result will be only the arrays that have at least 1 item.</p>

<p>Thank you</p>
","6608606","","310726","","2016-11-07 13:01:12","2016-11-07 13:01:12","Angular2 filter array of objects","<angular><typescript><rxjs><reactive-programming><rxjs5>","2","2","","","","CC BY-SA 3.0"
"40465158","2","","40464943","2016-11-07 12:25:46","","1","","<p>Instead of <code>.filter</code> use <code>.map</code></p>

<pre><code>.map(each =&gt; {
    return each.filter(array =&gt; array.length &gt; 0)
}
</code></pre>
","310726","","","","","2016-11-07 12:25:46","","","","0","","","","CC BY-SA 3.0"
"40468311","1","40468462","","2016-11-07 15:03:03","","6","4186","<p>I wish to create a function that returns an <code>Observable&lt;any&gt;</code> but before returning another asyncronous task must complete (an <code>Observable&lt;string&gt;</code>), in order for a value to be passed to the returned <code>Observable</code>.</p>

<pre><code> @Injectable()
 export class MyComponent
 {

      GetAuthToken = function() : Observable&lt;string&gt;
      {
           return this._storageService.GetAsString('authToken');
      }

      GetData = function(authToken) : Observable&lt;any&gt;
      {

           let headers = new Headers();
           headers.append('authToken', authToken);
           var getUsers = this._http.get('/api/endpoint', { headers: headers })
                 .map((resonse: Response) =&gt; resonse.json()));

           return getUsers;        
      }


      DoIt = function() : Observable&lt;any&gt;
      {
          this.GetAuthToken ().Subsribe(t=&gt; {
              return GetData(t); 
          })
      }          


 }
</code></pre>

<p>So instead of passing the authToken parameter into the GetData function, I wish to execute the GetAuthToken function within the GetData function, wait for its completion, and then still return the http observable.</p>

<p>Executing the DoIt function would return the subscriber, not the GetData Observable</p>
","522330","","310726","","2016-11-07 15:33:06","2017-10-11 15:05:21","Angular 2 rxjs nested Observables","<javascript><angular><rxjs><rxjs5>","2","5","","","","CC BY-SA 3.0"
"40468462","2","","40468311","2016-11-07 15:10:40","","10","","<p>Try using <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html?#instance-method-concatMap"" rel=""noreferrer""><code>concatMap()</code></a>:</p>

<pre><code>DoIt() : Observable&lt;any&gt;
{
    return this.GetAuthToken()
        .concatMap(token =&gt; this.GetData(token)); 
}   
</code></pre>
","310726","","522330","","2016-11-07 15:13:21","2016-11-07 15:13:21","","","","2","","","","CC BY-SA 3.0"
"40480855","1","","","2016-11-08 07:04:17","","7","8056","<p>How do I use <code>Observable.bindCallback()</code> with a callback that returns 2 args, <code>callback(results, status)</code>? The example is with <code>google.maps.places</code> API below: </p>

<pre><code>  const service = new google.maps.places.PlacesService(map);
  // service.nearbySearch(request, callback);


  function callback(results, status) {
    if (status === google.maps.places.PlacesServiceStatus.OK) {
      for (var i = 0; i &lt; results.length; i++) {
        createMarker(results[i]);
      }
    }
  }
</code></pre>

<p>I want to do something like this:</p>

<pre><code>const handleError = err=&gt;console.error(error);

const nearbyAsObservable = Observable.bindCallback(service.nearbySearch)
nearbyAsObservable(request)
   .subscribe( 
     (results,status)=&gt;{
       if (status!=""OK"") handleError(results);
       callback
     }
     , handleError
   )
</code></pre>

<p>but I am unsure about the following:</p>

<p>1) is the best practice to ""throw"" an error from the <code>next</code> handler and catch it in the <code>error</code> handler, or just call the method <code>handleError()</code>?</p>

<p>2) I am getting <code>Cannot read property 'nearbySearch' of undefined(â¦)</code> error. But when I call <code>const nearbyAsObservable = Observable.bindCallback( service.nearbySearch.bind(service) )</code> I get a TS error:</p>

<pre><code>// const nearbyAsObservable = Observable.bindCallback(service.nearbySearch.bind(service) )
// nearbyAsObservable(request)
[ts] Supplied parameters do not match any signature of call target.
const nearbyAsObservable: () =&gt; Observable&lt;{}&gt;
</code></pre>

<p><strong>update</strong> it looks like this hack will fix the TS error</p>

<pre><code>const nearbyAsObservable : any = Observable.bindCallback(service.nearbySearch.bind(service) )
nearbyAsObservable(request)
   .subscribe( 
     (results,status)=&gt;{
       if (status!=""OK"") handleError(results);
       callback
     }
     , handleError
   )
</code></pre>

<p>but the <code>next</code> handler complains if I give it a <code>(result, status)=&gt;void</code></p>

<p>3) how do I transform the Observable return from <code>Observable&lt;[result, status]&gt;</code> to <code>Observable&lt;PlaceResult[]&gt;</code>?</p>
","264410","","264410","","2016-11-08 08:20:56","2016-11-08 08:55:53","How do you use Observable.bindCallback()","<angular><typescript><rxjs><rxjs5>","1","5","2","","","CC BY-SA 3.0"
"40488881","1","40488963","","2016-11-08 14:02:05","","17","3028","<p>I am a bit confused. What is the difference between these libraries?
<br/>
<br/>
<a href=""https://github.com/ReactiveX/rxjs"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs</a><br/>
<a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS</a><br/>
<br/>
What is the differance between <a href=""https://www.npmjs.com/package/rx"" rel=""noreferrer"">rx</a>, <a href=""https://www.npmjs.com/package/@reactivex/rxjs"" rel=""noreferrer"">@reactivex/rxjs</a> <a href=""https://www.npmjs.com/package/rxjs"" rel=""noreferrer"">rxjs</a> on npm.<br/>
<br/>
If you search npm there are multiple libraries for rxjs which one is the official?<br/>
<br/>
<a href=""https://www.npmjs.com/search?q=rx"" rel=""noreferrer"">https://www.npmjs.com/search?q=rx</a></p>
","655440","","310726","","2016-11-08 14:09:49","2018-03-05 10:31:46","What is the difference between Reactive-Extensions/RxJS and ReactiveX/rxjs","<javascript><typescript><ecmascript-6><rxjs><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"40488963","2","","40488881","2016-11-08 14:05:43","","16","","<p>RxJS 4 is hosted on: <a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""noreferrer"">https://github.com/Reactive-Extensions/RxJS</a></p>

<p>RxJS 5 (<a href=""https://github.com/ReactiveX/rxjs"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs</a>) replaces RxJS 4 and is relatively compatible with RxJS 4. <a href=""https://github.com/ReactiveX/rxjs#rxjs-5-release-candidate"" rel=""noreferrer"">README.md on gtihub says</a>:</p>

<blockquote>
  <p>Reactive Extensions Library for JavaScript. This is a rewrite of Reactive-Extensions/RxJS and is intended to supersede it once this is ready.</p>
</blockquote>

<p>RxJS 5 is completely written in TypeScript and compiled to both as ES6 and ES5 (as a bundle in UMD format).</p>

<p>There's also RxJS 6 currently in development.</p>

<p>Also, RxJS 4 is now called <code>rx</code> and npm while RxJS 5 is <code>rxjs</code> now. The scoped one <code>@reactivex/rxjs</code> is probably just an older npm package (they both come from the same repo).</p>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md</a></p>
","310726","","310726","","2018-03-05 10:31:46","2018-03-05 10:31:46","","","","1","","","","CC BY-SA 3.0"
"40491285","1","40494225","","2016-11-08 15:57:15","","2","187","<p>I need to query a device multiple times. Every query needs to be asynchronous and the device doesn't support simultaneous queries at a time. 
Moreover, once it is queried, it can not be queried again immediately after. It needs at least a 1 second pause to work properly.</p>

<p>My two queries, performed by <code>saveClock()</code> and <code>saveConfig()</code>, return a Promise and both resolve by returning undefined as expected.</p>

<p>In the following code why removing <code>take()</code> prevents <code>toArray()</code> from being called? <br>
What's happening here, is there a better way to achieve the same behavior?</p>

<pre><code>export const saveEpic = (action$, store) =&gt;
  action$.ofType(SAVE)
    .map(action =&gt; {
      // access store and create object data
      // ...
      return data;
    })
    .mergeMap(data =&gt;
      Rx.Observable.from([
        Rx.Observable.of(data).mergeMap(data =&gt; saveClock(data.id, data.clock)),
        Rx.Observable.timer(1000),
        Rx.Observable.of(data).mergeMap(data =&gt; saveConfig(data.id, data.config)),
        Rx.Observable.of(data.id)
     ])
    )
    .concatAll()
    .take(4)
    .toArray()
    // [undefined, 0, undefined, ""id""]
    .map(x =&gt; { type: COMPLETED, id: x[3] });
</code></pre>
","1141063","","1141063","","2016-11-08 16:17:38","2016-11-08 19:55:21","Why complete is not invoked after performing a concatenation?","<javascript><rxjs><rxjs5><reactivex><redux-observable>","1","1","1","","","CC BY-SA 3.0"
"40493391","1","40493854","","2016-11-08 17:50:19","","1","824","<p>I'm trying to return an observable that will return data as follows. </p>

<pre><code>getRootGroupNodes(): Observable&lt;Group[]&gt; {


    return Observable.create(function(observer) {

        var groups = [
            { groupName: ""Group1"" },
            { groupName: ""Group2"" }
        ]
        observer.next(groups);

        observer.complete();

    });
}
</code></pre>

<p>When I try to consume it </p>

<pre><code>   this._loadGroupsSubscription = this._apiGroupService.getRootGroupNodes()
        .retry(3)
        .subscribe(
        groups =&gt; {
            // do somethign with groups
        },
        err =&gt; { this._log.logMessage(""failed to retrieve groups""); },
        () =&gt; {

            this._loadGroupsSubscription.unsubscribe();
        }
        );
</code></pre>

<p>I get <code>this._loadGroupsSubscription</code> is <code>null</code>. Hence an exception is thrown trying to call unsubscribe on undefined. Any ideas what I'm doing wrong ? This should be basic..</p>
","2022345","","310726","","2016-11-08 19:03:31","2016-11-08 19:03:31","Observable is null when unsubscribe is called","<angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40493854","2","","40493391","2016-11-08 18:19:22","","2","","<p>It's true the variable isn't assigned inside the callback. I think there're two ways to handle this:</p>

<ol>
<li><p>Wrap unsubscription with <code>setTimeout()</code>:</p>

<pre><code>setTimeout(() =&gt; _loadGroupsSubscription.unsubscribe());
</code></pre></li>
<li><p>Add <code>.delay(0)</code> operator, which is basically the same trick:</p>

<pre><code>var _loadGroupsSubscription = getRootGroupNodes()
  .retry(3)
  .delay(0)
  .subscribe(
    groups =&gt; {
      console.log(groups);
    },
    err =&gt; { this._log.logMessage(""failed to retrieve groups""); },
    () =&gt; {
      _loadGroupsSubscription.unsubscribe();
    }
);
</code></pre></li>
</ol>

<p>See live demo: <a href=""https://jsbin.com/sunicoq/2/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/sunicoq/2/edit?js,console</a></p>

<p>See a slightly similar question with explanation how this works: <a href=""https://stackoverflow.com/questions/40455579/other-operator-in-calculation-chain-than-combinelatest-to-avoid-redundant-calcul/40460900#40460900"">Other operator in calculation chain than combineLatest to avoid redundant calculations</a></p>
","310726","","-1","","2017-05-23 11:54:15","2016-11-08 18:19:22","","","","0","","","","CC BY-SA 3.0"
"40494225","2","","40491285","2016-11-08 18:42:52","","2","","<p>There are a couple things I see:</p>

<p>Your final <code>.map()</code> is missing parenthesis, which in its current form is a syntax error but a subtle change could make it accidentally a <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label"" rel=""nofollow noreferrer"">labeled statement</a> instead of returning an object. Because in its current form it's a syntax error, I imagine this is just a bug in this post, not in your code (which wouldn't even run), but double check!</p>

<pre class=""lang-js prettyprint-override""><code>// before
.map(x =&gt; { type: COMPLETED, id: x[3] });

// after
.map(x =&gt; ({ type: COMPLETED, id: x[3] }));
</code></pre>

<p>With that fixed, the example does run with a simple redux-observable test case: <a href=""http://jsbin.com/hunale/edit?js,output"" rel=""nofollow noreferrer"">http://jsbin.com/hunale/edit?js,output</a> So if there's nothing notable I did differently than you, problem <em>appears</em> to be in code not provided. Feel free to add additional insight or even better, reproduce it in a JSBin/git repo for us.</p>

<hr>

<p>One thing you didn't mention but is very very noteworthy is that in redux-observable, your epics will typically be long-lived ""process managers"". This epic will actually only process one of these saves, then complete(), which is probably not what you actually want? Can the user only save something one time per application boot? Seems unlikely.</p>

<p>Instead, you'll want to keep the top-level stream your epic returns alive and listening for future actions by encapsulating this logic inside the <code>mergeMap</code>. The <code>take(4)</code> and passing the <code>data.id</code> then become extraneous:</p>

<pre class=""lang-js prettyprint-override""><code>const saveEpic = (action$, store) =&gt;
  action$.ofType(SAVE)
    .mergeMap(data =&gt;
      Rx.Observable.from([
        Rx.Observable.of(data).mergeMap(data =&gt; saveClock(data.id, data.clock)),
        Rx.Observable.timer(1000),
        Rx.Observable.of(data).mergeMap(data =&gt; saveConfig(data.id, data.config))
      ])
      .concatAll()
      .toArray()
      .map(() =&gt; ({ type: COMPLETED, id: data.id }))
    );
</code></pre>

<p>This separation of streams is described by Ben Lesh in his recent AngularConnect talks, in the context of errors but it's still applicable: <a href=""https://youtu.be/3LKMwkuK0ZE?t=20m"" rel=""nofollow noreferrer"">https://youtu.be/3LKMwkuK0ZE?t=20m</a> (don't worry, this isn't Angular specific!)</p>

<p>Next, I wanted to share some unsolicited refactoring advice that may make your life easier, but certainly this is opinionated so feel free to ignore:</p>

<p>I would refactor to more accurately reflect the order of events visually, and reduce the complexity:</p>

<pre class=""lang-js prettyprint-override""><code>const saveEpic = (action$, store) =&gt;
  action$.ofType(SAVE)
    .mergeMap(data =&gt;
      Rx.Observable.from(saveClock(data.id, data.clock))
        .delay(1000)
        .mergeMap(() =&gt; saveConfig(data.id, data.config))
        .map(() =&gt; ({ type: COMPLETED, id: data.id }))
    );
</code></pre>

<p>Here we're consuming the Promise returned by <code>saveClock</code>, delaying it's output for 1000ms, the mergeMapping the result to a call to <code>saveConfig()</code> which also returns a Promise that will be consumed. Then finally mapping the result of that to our <code>COMPLETE</code> action.</p>

<p>Finally, keep in mind that if your Epic <em>does</em> stay alive and is long lived, there's nothing in this epic as-is to stop it from receiving multiple SAVE requests while other ones are still in-flight or have not yet exhausted the required 1000ms delay between requests. i.e. if that 1000ms space between <em>any</em> request is indeed required, your epic itself does not entirely prevent your UI code from breaking that. In that case, you may want to consider adding a more complex buffered <a href=""http://reactivex.io/documentation/operators/backpressure.html"" rel=""nofollow noreferrer"">backpressure</a> mechanism, for example using the <code>.zip()</code> operator with a <code>BehaviorSubject</code>.</p>

<p><a href=""http://jsbin.com/waqipol/edit?js,output"" rel=""nofollow noreferrer"">http://jsbin.com/waqipol/edit?js,output</a></p>

<pre class=""lang-js prettyprint-override""><code>const saveEpic = (action$, store) =&gt; {
  // used to control how many we want to take,
  // the rest will be buffered by .zip()
  const requestCount$ = new Rx.BehaviorSubject(1)
    .mergeMap(count =&gt; new Array(count));

  return action$.ofType(SAVE)
    .zip(requestCount$, action =&gt; action)
    .mergeMap(data =&gt;
      Rx.Observable.from(saveClock(data.id, data.clock))
        .delay(1000)
        .mergeMap(() =&gt; saveConfig(data.id, data.config))
        .map(() =&gt; ({ type: COMPLETED, id: data.id }))
        // we're ready to take the next one, when available
        .do(() =&gt; requestCount$.next(1))
    );
};
</code></pre>

<p>This makes it so that requests to save that come in while we're still processing an existing one is buffered, and we only take one of them at a time. Keep in mind though that this is an unbounded buffer--meaning that the queue of pending actions can potentially grow infinitely quicker than the buffer is flushed. This is unavoidable unless you adopted a strategy for lossy backpressure, like dropping requests that overlap, etc.</p>

<p>If you have other epics which have overlapping requirements to not sending requests more than once a second, you would need to create some sort of single supervisor that makes this guarantee for all the epics.</p>

<p>This may all seem very complex, but perhaps ironically this is <em>much</em> easier to do in RxJS than with traditional imperative code. The hardest part is actually knowing the patterns.</p>
","1770633","","1770633","","2016-11-08 19:55:21","2016-11-08 19:55:21","","","","2","","","","CC BY-SA 3.0"
"40500241","1","","","2016-11-09 04:36:47","","2","1108","<p>This is my first project/application using Angular 2. And I am currently stuck in the login problem of the application. So, in my web app:</p>

<p><strong>Expectations:</strong></p>

<ol>
<li><p>I load a login component for the first time. In this case, the navbar shows a ""Sign In"" button.</p></li>
<li><p>After correct login, I can go to a dashboard component. In the dashboard component, I can see a sidebar on the left side, and my navbar is updated to show the ""Sign Out"" button.</p></li>
<li><p>When I click ""Sign Out"", it should sign me out gracefully.</p></li>
</ol>

<p>For a clearer picture, I've uploaded <a href=""http://imgur.com/a/ZDrhQ"" rel=""nofollow noreferrer"">an album</a> showing how the login and dashboard should look like, and the actual happening after login.</p>

<p><strong>Reality:</strong></p>

<ol>
<li>I use <code>localStorage</code> from Angular 2 to store the current user in key <code>currentUser</code> and detect whether user is logged in. As long as it deoesn't value in the <code>currentUser</code> key, the login component works fine. Otherwise, it shows an empty dashboard with no title in it.</li>
<li>After the login, the sidebar and updated navbar is jumbled up with the login screen, while the dashboard is not showing up.</li>
</ol>

<p>I've made <a href=""https://github.com/baskoroi/back-temp"" rel=""nofollow noreferrer"">a temporary Git repo</a> to show you my code for now. </p>

<p>If you notice, the Angular frontend is connected to a Node.js backend. The Node.js backend works just fine.</p>

<p>I think the main problem points are in my usage of Observables (to tell every subscribing component that user is logged in), the authentication guard on the routes, and maybe the authentication service itself. </p>

<p>To meet the expectations above, I've tried to use Observables and emit the values to the subscribing components. However, the 'reality' points I've mentioned above happened, and I haven't known a way yet to fix it again.</p>

<p>So, can you help show me where the problem is, and what I can do to fix it? I would appreciate your input, thank you.</p>
","1894879","","","","","2016-11-09 07:09:33","Node / Angular 2: Update navbar and show sidebar after user login","<node.js><angular><typescript><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"40508888","2","","40107860","2016-11-09 14:05:38","","1","","<p>I ended up using <code>distinctUntilChanged</code> to archive my goal:</p>

<pre><code>getList() {
    return Observable.timer(0, 1000)
      .concatMap(() =&gt; this.http.get(this.apiURL)
      .distinctUntilChanged(null, x =&gt; x.json().info[1].value)
      .map(this.extractData)
      .catch(this.handleError);
  }
</code></pre>

<p>Therefore if the current and last response share the same specific value, the newest response is dropped. I guess my question was not clear enough and I did not mention that the decision to drop a response depends on the previous one.</p>

<p>A <strong>downside</strong> of this approach is that the response have to be parsed twice, but I guess that cannot be avoided. It would be nice to know if the json approch is faster than a complete string compare of the result (body).</p>

<p>If the decision to drop a response only depends on the current response, I would recommend to use a <a href=""http://reactivex.io/documentation/operators/filter.html#collapseRxJS"" rel=""nofollow noreferrer"">filter</a>.</p>
","1632341","","","","","2016-11-09 14:05:38","","","","0","","","","CC BY-SA 3.0"
"40512084","1","40515607","","2016-11-09 16:49:21","","1","4961","<p>Below is my Angular 2 component code</p>

<pre><code>import { Component , OnInit } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/distinct';

@Component({
             selector:'js',
             template: `
                       &lt;input type=""text"" id=""txt"" value=""""&gt;                           `
          })


  export class Js1Component implements OnInit{  

      ngOnInit(){   

         var data = Observable.fromEvent(document.getElementById('txt'),'keypress')
        .distinct()
        .subscribe({
            next: (e) =&gt; { console.log(e);}
        });

   }
}
</code></pre>

<p>Since I am using ""distinct"" operator , when user types ""Hello"" in textbox , I 
was expecting that only character h , e , l and o will be printed in the console,that is only one ""l"" will be printed.
But instead all the character are printed( h e l l o).</p>

<p>Any idea how the distinct operator needs to be used.</p>
","2693545","","","","","2016-11-10 05:02:02","How to use ""distinct"" RxJS operator in Angular 2?","<angular><rxjs5>","1","1","","","","CC BY-SA 3.0"
"40515607","2","","40512084","2016-11-09 20:37:45","","3","","<p>As stated by @estus in the comment, <code>e</code> is an object in your example and not a string. Hence it's different every time (even if the object's keys were all the same, the reference is different).</p>

<p>You can <code>map</code> the event you receive into the pressed key with function <code>event =&gt; event.key</code>.</p>

<pre><code>Observable.fromEvent(this.input.nativeElement, 'keypress')
  .map(event =&gt; event.key)
  .distinct()
  .subscribe(e =&gt; console.log(e)); // logs key pressed
</code></pre>

<p>Depending on the use case, you might need the whole event, and not just the letter pressed afterwards. In that case, using the map operator is a bad idea since you lose all other information.</p>

<p>If this is the case, you can supply a function to <code>.distinct</code> operator. By default this is an identity mapping <code>x =&gt; x</code>, but you can make it <code>event =&gt; event.key</code>. It will then consider items in the stream different if their <code>.key</code> properties are different.</p>

<pre><code>Observable.fromEvent(this.input.nativeElement, 'keypress')
  .distinct(event =&gt; event.key)
  .subscribe(e =&gt; console.log(e)); // logs whole event (distinct keys)
</code></pre>

<p>On the side note, notice how I don't use native DOM API (like <code>getElementById</code>). You should use <code>@ViewChild</code> decorator instead for grabbing elements from the template. <a href=""http://plnkr.co/edit/f8dGyHdx1SUcpJNOcnjo?p=preview"" rel=""nofollow noreferrer"">The full <strong>Plunker</strong> is here.</a></p>
","2131286","","5706293","","2016-11-10 05:02:02","2016-11-10 05:02:02","","","","0","","","","CC BY-SA 3.0"
"40522372","2","","40407540","2016-11-10 07:48:14","","0","","<p>So here is a much simpler solution than the one I thought. With simply using 2 observables. Similar effect could be achieved with schedulers and subscribeOn.</p>

<pre><code>    // some sandbox
class Action {
  constructor(name, observable) {
    this.name = name;
    this.observable = observable;
    this.replay = new Rx.ReplaySubject(10);
  }
}

function actionFactory(action, param) {

  return Rx.Observable.create(obs =&gt; {
    action.observable
    .subscribe(x =&gt; {
        obs.next(x);
        action.replay.next(x);
    }, (e) =&gt; {}, () =&gt; obs.complete);
  }); 
}

class Api {
  constructor() {
    this.actions = {};
  }

  registerAction(actionName, action) {
    let generatedAction = new Action(actionName, action);

    this.actions[actionName] = generatedAction;

    return actionFactory.bind(null, generatedAction);
  }

  getAction(actionName) {
    return this.actions[actionName].replay;
  }
}

const api = new Api();

// -------------------------------------------------------------------
// module 1
let myAction = Rx.Observable.create((obs) =&gt; {
  obs.next(""42 "" + Date.now());
  obs.complete();
});

let myRegisteredAction$ = api.registerAction(""myAction"", myAction);

let myTrigger = Rx.Observable.interval(1000).take(1).delay(1000);

let executedAction = myTrigger
.map(x =&gt; { return { someValue: x} })
.concatMap(x =&gt; myRegisteredAction$(x))
.subscribe(
  (x) =&gt; { console.log(`MAIN: ${x}`); },
  (e) =&gt; { console.log(""error"", e)}, 
  () =&gt; { console.log(""MAIN: completed"");});


// -------------------------------------------------------------------
// module 2
 var sub = api.getAction(""myAction"")
  .subscribe(
  (x) =&gt; { console.log(`SECOND: ${x}`); },
  (e) =&gt; {console.log(""error : "" + e)}, 
  () =&gt; { console.log(""SECOND: completed"");});
</code></pre>
","1875216","","","","","2016-11-10 07:48:14","","","","0","","","","CC BY-SA 3.0"
"40528481","1","","","2016-11-10 13:10:56","","1","251","<p>I'm using Observables of rxjs to communicate with a device which is accessible over HTTP. The HTTP-calls are started before the device is completely online, so therefore some calls can fail at the beginning. At some point the device is online, an update is started and the progress is polled periodically. At the end of the update the device has to restart and will afterwards provide the progress on a different url.</p>

<p>Now I want to map this behaviour with rxjs:</p>

<pre><code>successfulCall: boolean = false;  

testGet() {
    return Observable.timer(0, 1000)
      .concatMap(() =&gt; this.http.get(this.url))
      .map(response =&gt; {
        let result: string = String.fromCharCode.apply(null, new Uint16Array(response.arrayBuffer()));
        this.successfulCall = true;
        return result;
      })
      .timeout(2000)
      .retryWhen(errors =&gt; {

        if (this.successfulCall) {
          return Observable.throw(""offline"");
        }
        else {
          return errors.delay(2000);
        }

      })
      .onErrorResumeNext(this.observableTwo);
</code></pre>

<p>My idea is to use <code>retryWhen</code> as a switch, which then can chose the other observable. But the second observable is never started, only the first one is called. Dependent on the device status (online or offline) I either receive timeouts or valid answers and the calls continue. I also know that an exception in the normal control flow is not a very pretty idea. </p>

<p>I made a little flowchart to visualize my idea, because I could imagine that my description of the problem could be to complicated.</p>

<p><em>wasSuccessful have to be initialized with false and the processing of the observable results is not shown</em></p>

<p><a href=""https://i.stack.imgur.com/ICcWU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ICcWU.png"" alt=""Flowchart of Observable""></a></p>

<p>Also other (maybe prettier/better)  approaches are perfectly okay, I just want to solve the problem and do not have to insist on my approch.</p>
","1632341","","","","","2017-02-02 11:05:09","On error swap to another observable after atleast one successful response","<typescript><rxjs><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"40529599","1","40531179","","2016-11-10 14:08:04","","5","2046","<p>I'm about to mock a http call wrapped into observable. My initial idea was to simply use <code>Observable.of</code> similar to <code>Promise.resolve</code>, but it does not seem to work as I expected:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.of('of1').subscribe(e =&gt; console.log(e));

console.log('of2');

Rx.Observable.from(Promise.resolve('from1')).subscribe(e =&gt; console.log(e));

console.log('from2');</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.6/dist/global/Rx.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>It seems that <code>Observable.of</code> runs synchronously while <code>Rx.Observable.from(Promise.resolve('from1'))</code> runs asynchronously (that is what I want). As long as I want to test the spinner is displayed, the synchronous call is not an option for me.</p>

<p>There is some kind of solution when I e.g. delay it or set a timer:</p>

<pre><code>Rx.Observable.of('of1').delay(0).subscribe...
</code></pre>

<p>but this also does not look good to me.</p>

<p>How can I turn <code>Observable.of</code> to run asynchronously? Converting it from Promise seems like an overkill.</p>
","1990451","","","","","2019-10-10 06:39:45","Observable.of turn async","<javascript><asynchronous><observable><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"40531179","2","","40529599","2016-11-10 15:25:18","","5","","<p>If you want an observable of to behave differently you can pass it a scheduler. You could use the async scheduler to make the observable emit values as soon as the call stack is clear. 
Code wise this would look like this:</p>

<pre><code>Rx.Observable.of(1, 2, 3, Rx.Scheduler.async).subscribe(
    (val) =&gt; console.log(val)
);

console.log('first');
</code></pre>

<p>This will log out:</p>

<pre><code>//first
//1
//2
//3
</code></pre>

<p>Working jsbin example here: <a href=""http://jsbin.com/cunatiweqe/6/edit?js,console"" rel=""noreferrer"">http://jsbin.com/cunatiweqe/6/edit?js,console</a></p>
","1018598","","","","","2016-11-10 15:25:18","","","","0","","","","CC BY-SA 3.0"
"40533450","1","40535017","","2016-11-10 17:15:54","","2","820","<p>I'm using RXJS and I'm looking to dynamically filter the data, but I'm having problems:</p>

<pre><code>let numberSource: ReplaySubject&lt;Number&gt; = new ReplaySubject&lt;Number&gt;();
let numberFilter: BehaviorSubject&lt;Number&gt; = new BehaviorSubject&lt;Number&gt;(5);

let filteredData = numberSource.filter(n =&gt; n &lt; numberFilter.value);
numberFilter.subscribe(newFilter =&gt; {
  filteredData = numberSource.filter(n =&gt; n &lt; newFilter);
  filteredData.subscribe(console.log);  // &lt;- I think this is wrong
});

console.log(""A"");
filteredData.subscribe(console.log);

numberSource.next(1);
numberSource.next(10);
numberSource.next(100);

console.log(""B"");
numberFilter.next(50);
</code></pre>

<p>What I am doing is subscribing to numberSource, that is the data I am interested in displaying. I am also subscribing to numberFilter, because I want any changes to that to replay the subject, but I think I have done that wrong.</p>

<p>I am expecting to see:</p>

<pre><code>A
1
B
1
10
</code></pre>

<p>I am seeing:</p>

<pre><code>A
1
1
B
1
10
</code></pre>

<p>Can anyone help?</p>
","141985","","310726","","2016-11-10 18:56:18","2016-11-10 18:56:18","Dynamically filtering rxjs stream","<typescript><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"40535017","2","","40533450","2016-11-10 18:55:48","","1","","<p>I think I understand what you're trying to do. You want to stack all value emitted by <code>numberSource</code> to be able to reemit and filter them when <code>numberFilter</code> changes. </p>

<p>The major problem in your implementation is that <code>numberFilter</code> is a <code>BehaviorSubject</code> which emits its default value (<code>5</code> in this case) every time you subscribe to it which happens right on the line <code>numberFilter.subscribe(newFilter =&gt; ...</code>. This callback subscribes to <code>filteredData</code> and then again right after <code>console.log(""A"");</code>. So you haven't even started emitting data to <code>numberSource</code> and you've already subscribed twice. That's why it gives you <code>1</code> two times.</p>

<p>Easy solution is to use classic <code>Subject</code> and remember to <code>unsubscribe()</code> the previous subscription to <code>filteredData</code>:</p>

<pre><code>let numberSource: ReplaySubject&lt;Number&gt; = new ReplaySubject&lt;Number&gt;();
let numberFilter: Subject&lt;Number&gt; = new Subject&lt;Number&gt;();

var subscription;
numberFilter.subscribe(newFilter =&gt; {
  if (subscription) {
    subscription.unsubscribe();
  }

  subscription = numberSource.filter(n =&gt; n &lt; newFilter)
    .subscribe(console.log);
});

numberFilter.next(5);

console.log(""A"");

numberSource.next(1);
numberSource.next(10);
numberSource.next(100);

console.log(""B"");
numberFilter.next(50);
</code></pre>

<p>See live demo: <a href=""http://plnkr.co/edit/vOaD8tcWlLRdfzU14Ufw"" rel=""nofollow noreferrer"">http://plnkr.co/edit/vOaD8tcWlLRdfzU14Ufw</a></p>

<p>Now it gives you the output you wanted.</p>
","310726","","","","","2016-11-10 18:55:48","","","","3","","","","CC BY-SA 3.0"
"40536152","1","40536435","","2016-11-10 20:08:05","","2","632","<p>I'm trying to use AngularFire2. I am querying and everything works fine below.</p>

<p>I want to combine all/most of the observables into one:</p>

<pre><code>getTournamentWithRounds(key):Observable&lt;Tournament&gt; {

    return this.af.database
        .object(`/tournaments/${key}`)
        .map(tourney =&gt; {

            let t = Tournament.fromJson(tourney);

            this.af.database.list('players', {
                query: {
                    orderByChild: 'tournament_key',
                    equalTo: key
                }
            })
            .map(Player.fromJsonList)
            .subscribe(ps =&gt; { t.players = ps; });

            this.af.database.list('rounds', {
                query: {
                    orderByChild: 'tournament_key',
                    equalTo: key
                }
            })
            .map(Round.fromJsonList)
            .subscribe(rs =&gt; { t.rounds= rs; })

            return t;
        })
  }
</code></pre>

<p>I was wondering if I could join all the observables and get the output with a single subscribe function.</p>

<p>I would like to know when all the initial data has been loaded and perform additional computation in the controller before outputting it to the view.</p>

<p>Also, how could this be extended to include the matches for each round?</p>

<p>My extension to the above code would be:</p>

<pre><code>...

this.af.database.list('rounds', {
    query: {
        orderByChild: 'tournament_key',
        equalTo: key
    }
})
.map(rounds =&gt; {
    return rounds.map((round) =&gt; {

        let r = Round.fromJson(round);

        this.af.database.list('matches', {
            query: {
                orderByChild: 'round_key',
                equalTo: round.$key
            }
        })
        .map(Match.fromJsonList)
        .subscribe(matches =&gt; { r.matches = matches; })

        return r;
    })
})
.subscribe(rs =&gt; { t.rounds= rs; })

...
</code></pre>
","1541771","","6680611","","2016-11-12 01:07:37","2016-11-12 01:53:36","Flatten/Chain multiple nested firebase Observables","<firebase><firebase-realtime-database><observable><rxjs5><angularfire2>","1","2","2","","","CC BY-SA 3.0"
"40536435","2","","40536152","2016-11-10 20:27:53","","5","","<p>You could use the <code>combineLatest</code> operator to combine the players and rounds with the tournament:</p>

<pre><code>getTournamentWithRounds(key): Observable&lt;Tournament&gt; {

  return this.af.database
    .object(`/tournaments/${key}`)
    .combineLatest(
      this.af.database.list('players', {
        query: {
          orderByChild:'tournament_key',
          equalTo: key
        }
      }),
      this.af.database.list('rounds', {
        query: {
          orderByChild:'tournament_key',
          equalTo: key
        }
      })
    )
    .map(([tourney, players, rounds]) =&gt; {

      let t = Tournament.fromJson(tourney);
      t.players = Player.fromJsonList(players);
      t.rounds = Round.fromJsonList(rounds);
      return t;
    });
}
</code></pre>

<p>Whenever any of the observables emits, the latest values will be re-combined and a new <code>Tournament</code> will be emitted.</p>

<p>Extending this to include each round's matches is a little more complicated, as each round's key is needed for the matches query.</p>

<p>The emitted rounds can be mapped to an array of list observables for the matches and <code>forkJoin</code> can be used to join the observables, with the <code>forkJoin</code> selector function being used to combine the matches with the rounds. <code>switchMap</code> is then used to emit the rounds.</p>

<pre><code>getTournamentWithRounds(key): Observable&lt;Tournament&gt; {

  return this.af.database
    .object(`/tournaments/${key}`)
    .combineLatest(
      this.af.database.list('players', {
        query: {
          orderByChild:'tournament_key',
          equalTo: key
        }
      }),
      this.af.database.list('rounds', {
        query: {
          orderByChild:'tournament_key',
          equalTo: key
        }
      })
      .switchMap(rounds =&gt; {
        Observable.forkJoin(
          rounds.map(round =&gt; this.af.database.list('matches', {
            query: {
              orderByChild: 'round_key',
              equalTo: round.$key
            }
          }).first()),
          (...lists) =&gt; rounds.map((round, index) =&gt; {
            let r = Round.fromJson(round);
            r.matches = Match.fromJsonList(lists[index]);
            return r;
          })
        )
      })
    )
    .map(([tourney, players, rounds]) =&gt; {

      let t = Tournament.fromJson(tourney);
      t.players = Player.fromJsonList(players);
      t.rounds = rounds;
      return t;
    });
}
</code></pre>
","6680611","","6680611","","2016-11-12 01:53:36","2016-11-12 01:53:36","","","","0","","","","CC BY-SA 3.0"
"40548610","1","40549117","","2016-11-11 13:01:59","","1","614","<p>I have the following code:</p>

<pre><code>this.itemsService.getItems()
    .subscribe(i =&gt; this.items = i);
</code></pre>

<p>But, the user can select a type of item, so I have an event emitter for this:</p>

<pre><code>this.typeofitems.selectedType.subscribe(type =&gt; this.type = type);
</code></pre>

<p>and it is working well.</p>

<p>Now I want to filter the list of items <code>this.items</code> with the <code>filter function</code>. The problem is, I don't know when the loading of items is completed, altough if I put a log in the subscription:</p>

<pre><code>this.itemsService.getItems()
    .subscribe(i =&gt; {this.items = i; console.log(""completed"");});
</code></pre>

<p>it indicates me that's completed. So I tried:</p>

<pre><code>this.itemsService.getItems()
    .subscribe(i =&gt; {
        this.items = i;
        this.typeofitems.selectedType.subscribe(type =&gt; {
            this.type = type;
            this.filterByType();
        });
    });

filterByType() {
    this.itemsfilteredByType = this.items.filter(i =&gt; i.type === this.type)
}
</code></pre>

<p>But it is not working. So I think I can not subscribe inside a subscriptor.
How can I achieve it?</p>
","1596786","","1596786","","2016-11-11 13:42:21","2016-11-11 13:42:21","Subscribe to event emitter when array is loaded","<angular><typescript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"40549117","2","","40548610","2016-11-11 13:33:18","","2","","<p>Note that you're using <code>=</code> instead of <code>==</code> in the <code>filter()</code> callback so make sure this wasn't the problem.</p>

<p>Anyway, you can use operator <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""nofollow noreferrer""><code>combineLatest()</code></a> that emits a value every time any of it's sources emit a value (while at least one value from each source has to be emitted):</p>

<pre><code>function getItems() {
  return Observable.of([{type: 1, val: 345}, {type: 2, val: 107}, {type: 1, val: 926}, {type: 2, val: 456} ]);
}

let typeOfItems = new Subject();

Observable.combineLatest(getItems(), typeOfItems)
  .subscribe(vals =&gt; {
    let [items, typeOfItem] = vals;

    let results = items.filter(i =&gt; i.type == typeOfItem);
    console.log(results);
  });

typeOfItems.next(2);
</code></pre>

<p>This filters items by <code>type == 2</code> and prints to console:</p>

<pre><code>[[object Object] {
  type: 2,
  val: 107
}, [object Object] {
  type: 2,
  val: 456
}]
</code></pre>

<p>It works thanks to <code>combineLatest()</code> which first receives all items and then I tell it to filter them by <code>type == 2</code> using <code>typeOfItems.next(2);</code> which triggers call to the callback for <code>combineLatest()</code> that uses <code>Array.filter()</code> to actually filter and print filtered items (note this is  <code>Array.fitler()</code> and not <code>Observable.filter()</code>).</p>

<p>See live demo: <a href=""https://jsbin.com/nenosiy/5/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/nenosiy/5/edit?js,console</a></p>

<p>Btw, of course you can <code>subscribe()</code> inside another <code>subscribe()</code> callback. Just remember you have to manually unsubscribe previous subscribtions.</p>

<p>See a very similar question: <a href=""https://stackoverflow.com/questions/40533450/dynamically-filtering-rxjs-stream/40535017#40535017"">Dynamically filtering rxjs stream</a></p>
","310726","","-1","","2017-05-23 12:09:45","2016-11-11 13:33:18","","","","2","","","","CC BY-SA 3.0"
"40555690","1","","","2016-11-11 20:27:47","","0","507","<p>I'm 
just playing around with Rxjs</p>

<p>what's wrong with this code</p>

<p>I've got an error</p>

<p>my goal is to set the 'My message'</p>

<p>only when the button is clicked twice.</p>

<h2>Property 'length' does not exist on type 'MouseEvent'.</h2>

<p>//JS</p>

<pre><code>import { Component, OnInit, ElementRef, ViewChild } from '@angular/core';
import {Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent  implements OnInit {
  message = 'Hello Rxjs';
  @ViewChild('btn') btn: ElementRef;
  ngOnInit(){
    let clicks = Observable.fromEvent&lt;MouseEvent&gt;(this.getNativeElement(this.btn), 'click')
    .filter(ev =&gt; ev.length &gt;= 2)
    .map(e =&gt; 'My Message')
    .subscribe(msg =&gt; this.message = msg);
  }
  getNativeElement(element){
    return element.nativeElement;
  }
}
</code></pre>

<p>//html</p>

<pre><code>&lt;h1&gt;
  &lt;button #btn&gt;Click&lt;/button&gt;
  {{message}}
&lt;/h1&gt;
</code></pre>

<p>UPDATE1</p>

<p>I'm following this course 
courses.ultimateangular.com
and the problem 
happens with the other snippet :(</p>

<p>UPDATE2
following the hint of @martin
this seems to work</p>

<pre><code>let clicks = Observable.fromEvent&lt;MouseEvent&gt;(this.getNativeElement(this.btn), 'click')
    .bufferCount(2, 1)
    .map(e =&gt; 'ah Pippo')
    .subscribe(msg =&gt; this.message = msg);
</code></pre>
","356380","","356380","","2016-11-12 09:06:03","2016-11-12 09:06:03","Angular2 rxjs filter double click Property 'length' does not exist on type 'MouseEvent'","<angular><typescript><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"40557715","1","40558000","","2016-11-11 23:20:38","","4","487","<p>I'm trying to make what I think is a <a href=""https://twitter.com/headinthebox/status/632607554263117828"" rel=""nofollow noreferrer"">pausable buffer</a></p>

<p>I had someone share their code for this, but I cannot figure out how to turn it into a custom operation (without typescript / just ES6.</p>

<pre><code>const attach = Rx.Observable.timer(0 * 1000, 8 * 1000).mapTo('@');
const detach = Rx.Observable.timer(4 * 1000, 8 * 1000).mapTo('#');

const input = Rx.Observable.interval(1* 1000);
const pauser = attach.mapTo(true).merge(detach.mapTo(false));

input
  .publish(_input =&gt; _input
    .combineLatest(pauser, (v, b) =&gt; b)
    .filter(e =&gt; e)
    .publish(_switch =&gt; _input.bufferWhen(() =&gt; _switch.take(1)))
  )
  .flatMap(e =&gt; Rx.Observable.from(e))
  .concatMap(e =&gt; Rx.Observable.empty().delay(150).startWith(e))
</code></pre>

<p>Can someone help me create that so that I can just do <code>input.pausableBuffer(pauser)</code> (and maybe define a startsWith).</p>
","7148238","","","","","2019-09-05 06:39:55","How can I create a pausableBuffer w/ rxjs 5","<rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"40558000","2","","40557715","2016-11-11 23:50:51","","4","","<p>You can add it to the prototype like this:</p>

<pre><code>var pausableBuffer = function(pauser) {
  return this.publish(_input =&gt; _input
    .combineLatest(pauser, (v, b) =&gt; b)
    .filter(e =&gt; e)
    .publish(_switch =&gt; _input.bufferWhen(() =&gt; _switch.take(1)))
  )
  .flatMap(e =&gt; Rx.Observable.from(e));
}

Rx.Observable.prototype.pausableBuffer = pausableBuffer;
</code></pre>

<p>One thing to remember is that this will start in the paused state. To start it in the active state instead, add <code>.startWith(true)</code> to <code>pauser</code>.</p>

<pre><code>var pausableBuffer = function(pauser) {
  return this.publish(_input =&gt; _input
    .combineLatest(pauser.startWith(true), (v, b) =&gt; b)
    .filter(e =&gt; e)
    .publish(_switch =&gt; _input.bufferWhen(() =&gt; _switch.take(1)))
  )
  .flatMap(e =&gt; Rx.Observable.from(e));
}

Rx.Observable.prototype.pausableBuffer = pausableBuffer;
</code></pre>

<p>Update 2019: RxJs 6 style:</p>

<pre><code>var pausableBuffer = function(pauser) {
  return (source) =&gt; source.pipe(publish(_input =&gt; 
  combineLatest(_input, pauser.pipe(startWith(true))).pipe(
    map(([inp, pa]) =&gt; pa),
    filter(pa =&gt; pa),
    publish(_switch =&gt; _input.pipe(bufferWhen(() =&gt; _switch.pipe(take(1)))))
  )),
    mergeMap(e =&gt; from(e))
  );
}
</code></pre>

<p><a href=""https://jsbin.com/vuhuyuwoce/edit?js,console,output"" rel=""nofollow noreferrer"">Demo</a></p>
","402027","","402027","","2019-09-05 06:39:55","2019-09-05 06:39:55","","","","5","","","","CC BY-SA 4.0"
"40559747","1","40560899","","2016-11-12 05:01:33","","11","14441","<p>I have these two objects, and I want to stop listening to their events. I am totally new to observables and RxJS and just trying to work with the <a href=""https://github.com/SBoudrias/Inquirer.js"" rel=""noreferrer"">Inquirer</a> library.</p>

<p>Here is the RxJS API for reference:
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html</a></p>

<p>How can I unsubscribe from these types of observables?</p>

<p><strong>ConnectableObservable:</strong></p>

<pre><code>   ConnectableObservable {
     source: EventPatternObservable { _add: [Function], _del: [Function], _fn: undefined },
     _connection: ConnectDisposable { _p: [Circular], _s: [Object] },
     _source: AnonymousObservable { source: [Object], __subscribe: [Function: subscribe] },
     _subject: 
      Subject {
        isDisposed: false,
        isStopped: false,
        observers: [Object],
        hasError: false } },
  _count: 1,
  _connectableSubscription: 
   ConnectDisposable {
     _p: 
      ConnectableObservable {
        source: [Object],
        _connection: [Circular],
        _source: [Object],
        _subject: [Object] },
     _s: AutoDetachObserver { isStopped: false, observer: [Object], m: [Object] } } }
</code></pre>

<p><strong>FilterObservable:</strong></p>

<pre><code>FilterObservable {
  source: 
   RefCountObservable {
     source: 
      ConnectableObservable {
        source: [Object],
        _connection: [Object],
        _source: [Object],
        _subject: [Object] },
     _count: 1,
     _connectableSubscription: ConnectDisposable { _p: [Object], _s: [Object] } },
  predicate: [Function] }
</code></pre>

<p>I need to unsubscribe from these objects:</p>

<pre><code>'use strict';
var rx = require('rx');

function normalizeKeypressEvents(value, key) {
  return {value: value, key: key || {}};
}

module.exports = function (rl) {

  var keypress = rx.Observable.fromEvent(rl.input, 'keypress', normalizeKeypressEvents)
    .filter(function (e) {
      // Ignore `enter` key. On the readline, we only care about the `line` event.
      return e.key.name !== 'enter' &amp;&amp; e.key.name !== 'return';
    });

  return {
    line: rx.Observable.fromEvent(rl, 'line'),

    keypress: keypress,

    normalizedLeftKey: keypress.filter(function (e) {
      return e.key.name === 'left';
    }).share(),

    normalizedRightKey: keypress.filter(function (e) {
      return e.key.name === 'right';
    }).share(),

    normalizedUpKey: keypress.filter(function (e) {
      return e.key.name === 'up' || e.key.name === 'k' || (e.key.name === 'p' &amp;&amp; e.key.ctrl);
    }).share(),

    normalizedDownKey: keypress.filter(function (e) {
      return e.key.name === 'down' || e.key.name === 'j' || (e.key.name === 'n' &amp;&amp; e.key.ctrl);
    }).share(),

    numberKey: keypress.filter(function (e) {
      return e.value &amp;&amp; '123456789'.indexOf(e.value) &gt;= 0;
    }).map(function (e) {
      return Number(e.value);
    }).share(),

    spaceKey: keypress.filter(function (e) {
      return e.key &amp;&amp; e.key.name === 'space';
    }).share(),

    aKey: keypress.filter(function (e) {
      return e.key &amp;&amp; e.key.name === 'a';
    }).share(),

    iKey: keypress.filter(function (e) {
      return e.key &amp;&amp; e.key.name === 'i';
    }).share()
  };
};
</code></pre>

<p>My current best guess is that no explicit call to subscribe is happening like this:</p>

<pre><code>var source = Rx.Observable.fromEvent(input, 'click');

var subscription = source.subscribe(
  function (x) {
    console.log('Next: Clicked!');
  },
  function (err) {
    console.log('Error: %s', err);
  },
  function () {
    console.log('Completed');
  });
</code></pre>

<p>but instead, there are these calls:</p>

<pre><code>events.normalizedUpKey.takeUntil(validation.success).forEach(this.onUpKey.bind(this));
events.normalizedDownKey.takeUntil(validation.success).forEach(this.onDownKey.bind(this));
</code></pre>

<p>so my best guess is that I need a way to nullify/cancel the takeUntil call.</p>
","1223975","","1223975","","2016-11-12 08:58:00","2018-03-28 04:10:59","Unsubscribe from RxJS Observables","<javascript><node.js><rxjs><reactive-programming><rxjs5>","3","0","2","","","CC BY-SA 3.0"
"40560899","2","","40559747","2016-11-12 08:12:50","","22","","<p>If you want to unsubscribe you need to have the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subscription.ts"" rel=""noreferrer""><code>Subscription</code></a> object. That's the object returned from every <code>Observable.subscribe()</code> call. For example:</p>

<pre><code>let subscriber = Observable.subscribe(...);
...
subscriber.unsubscribe();
</code></pre>

<p>For more info see: <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/subscription.md"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/subscription.md</a></p>
","310726","","","","","2016-11-12 08:12:50","","","","4","","","","CC BY-SA 3.0"
"40563065","1","40564340","","2016-11-12 12:59:09","","94","44901","
<p>I wonder, if there is any difference in performance between using <code>.take(1)</code> and <code>.unsubscribe</code> when <code>unsubscribe</code> is used right after the subscription:</p>
<pre class=""lang-js prettyprint-override""><code>var observable = Rx.Observable.interval(100);
</code></pre>
<p>First:</p>
<pre class=""lang-js prettyprint-override""><code>var subscription = observable.subscribe(function(value) {
   console.log(value);
}).unsubscribe();
</code></pre>
<p>Second:</p>
<pre class=""lang-js prettyprint-override""><code>var subscription = observable.take(1).subscribe(function(value) {
    console.log(value);
});
</code></pre>
<p>Any ideas of it makes any different regard the performance?</p>
","3669981","","13762264","","2021-08-16 23:12:48","2021-08-16 23:12:48","Difference between .unsubscribe to .take(1)","<rxjs><observable><rxjs5>","2","1","18","","","CC BY-SA 4.0"
"40564340","2","","40563065","2016-11-12 15:24:19","","148","","<p>Each serves a different purpose so it's hard to compare them.</p>

<p>In general if you take this source:</p>

<pre><code>const source = range(1,3);
</code></pre>

<p>... and consume it with <code>subscribe()</code> followed immediately by <code>unsubscribe()</code>:</p>

<pre><code>source.subscribe(
  console.log,
  undefined, 
  () =&gt; console.log('complete')
).unsubscribe();
</code></pre>

<p>... then all values from <code>source</code> are going to be emitted even though we called <code>unsubscribe()</code> right after subscribing. This is because the code is still strictly sequential (synchronous) and the <code>source</code> is a cold Observable.</p>

<pre><code>1
2
3
complete
</code></pre>

<p>Btw, try adding <code>delay(0)</code> operator to make <code>source.pipe(delay(0)).subscribe(...).unsubscribe()</code>. This makes emitting values asynchronous using an actual <code>setTimeout()</code> call and for this reason <code>unsubscribe()</code> is called before any <code>next</code> handlers and is discarded immediately.</p>

<p>In other words <code>unsubscribe()</code> let's you stop receiving values anytime. Even when the source hasn't emitted any value (we never receive any complete notification).</p>

<p>Using <code>take()</code> operator limits the chain to only emit a specific number of values.</p>

<pre><code>source.pipe(
  take(1),
)
.subscribe(
  console.log,
  undefined,
  () =&gt; console.log('complete')
);
</code></pre>

<p>This just emits a single value and completes:</p>

<pre><code>1
complete
</code></pre>

<p>Even if you add <code>.unsubscribe()</code> the result would be the same.</p>

<p>See live demo: <a href=""https://stackblitz.com/edit/rxjs-tbu5kb"" rel=""noreferrer"">https://stackblitz.com/edit/rxjs-tbu5kb</a></p>

<p>So <code>take()</code> is an operator while <code>unsubscribe()</code> is a method on a <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subscription.ts"" rel=""noreferrer""><code>Subscription</code></a> object. These two things are often interchangeable but they never fully substitute each other. </p>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-13 10:38:48","2019-01-13 10:38:48","","","","5","","","","CC BY-SA 4.0"
"40579452","1","40579477","","2016-11-13 22:20:08","","22","25528","<p>I'm using this great repo for my angular 2 test project (TypeScript) - <a href=""https://github.com/qdouble/angular-webpack2-starter"" rel=""noreferrer"">https://github.com/qdouble/angular-webpack2-starter</a>. And I need to use <strong>Observable.of(..)</strong>. When I try to import it:</p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import { of } from 'rxjs/observable/of';
</code></pre>

<p>I get:</p>

<blockquote>
  <blockquote>
    <p>Property 'of' does not exist on type 'typeof Observable'.</p>
  </blockquote>
</blockquote>

<p>I also tried it the following way:</p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import { of } from 'rxjs/add/observable/of'; // notice 'add'
</code></pre>

<p>I got:</p>

<blockquote>
  <blockquote>
    <p>node_modules/rxjs/add/observable/of""' has no exported member 'of'.</p>
  </blockquote>
</blockquote>

<p>So, how can one import this Of() static method for Observable???</p>
","2896495","","","","","2018-06-14 22:14:57","import .of() for Observable in typescript","<angular><typescript><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"40579477","2","","40579452","2016-11-13 22:23:30","","23","","<p><strike>You do not have to import <code>{of}</code> from <code>'rxjs/add/observable/of'</code>. You can directly use</strike></p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import ""rxjs/add/observable/of"";
</code></pre>

<p><strike>Or you can import <code>Observable</code> from ""rxjs/Rx"" which bundle all the operators.</strike> <em>Bad practice</em></p>

<pre><code>import { Observable } from ""rxjs/Rx"";
</code></pre>

<h2>Update 2018-01-26: RxJS v5.5+ pipeable operators</h2>

<p>From <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md</a></p>

<blockquote>
  <p>Starting in version 5.5 we have shipped ""pipeable operators"", which can be accessed in rxjs/operators (notice the pluralized ""operators""). These are meant to be a better approach for pulling in just the operators you need than the ""patch"" operators found in rxjs/add/operator/*.</p>
</blockquote>

<p>Now that ""patching"" imports are going to be deprecated, it would be better to use strict imports.</p>

<pre><code>import { of as observableOf } from 'rxjs/observable/of'
</code></pre>

<p>and use it like that</p>

<pre><code>const myObs$: Observable&lt;number&gt; = observableOf(1, 2, 3)
</code></pre>
","2459831","","2459831","","2018-02-17 10:06:33","2018-02-17 10:06:33","","","","3","","","","CC BY-SA 3.0"
"40582054","1","65675901","","2016-11-14 04:51:48","","5","2219","<p>I've found myself with a mixed object of values and observables. Something like:</p>

<pre><code>const mixedObject = {
  field1: ""Hello"",
  field2: Rx.Observable.of('World'),
  field3: Rx.Observable.interval(1000),
};
</code></pre>

<p>What would be the best way of doing something like a <code>combineLatest</code> on this object to get a stream of plain objects. </p>

<p>For example, I'd like to do something like:</p>

<pre><code>Rx.Observable.combineLatest(mixedObject).subscribe(plainObject =&gt; {
  console.log(plainObject.field1, plainObject.field2, plainObject.field3);
  // Outputs: 
  // &gt; Hello World 0
  // &gt; Hello World 1
  // &gt; Hello World 2
});
</code></pre>
","586181","","","","","2021-07-07 18:24:57","RxJS combineLatest on object of Observables?","<rxjs5>","2","0","","","","CC BY-SA 3.0"
"40585849","1","","","2016-11-14 09:50:36","","0","2838","<p>i have a problem with a nested forkjoin, when i try to subscribe pull, it's getting back my data, but i can see that getitem3 is still running. How to wait till all functions are finished before subscribe </p>

<p>see example</p>

<pre><code>pull(id) {
  return Observable.forkJoin(
    this.getitem1(id),
    this.getitem2(id),
    this.getitem3(id)
  );
}



getitem3(id) {
  let url = 'https://host3/get/' + id;
  let observableBatch = [];

  return this.http.get(url).map(res =&gt; res.json()).map(data =&gt; {
    data.posts.data.forEach((item) =&gt; {
      observableBatch.push(this.getImageUrl(item.id));
    })
    return Observable.forkJoin(observableBatch);
  })
}


getitem2(id) {
  let url = 'https://host2/get/' + id;
  let observableBatch = [];

  return this.http.get(url).map(res =&gt; res.json()).map(data =&gt; {
   data.posts.data.forEach((item) =&gt; {
     observableBatch.push(this.getImageUrl(item.id));
   });
   return Observable.forkJoin(observableBatch);

  });
}

 getitem1(id) {
  let url = 'https://host1/get/' + id;
  let observableBatch = [];

  return this.http.get(url).map(res =&gt; res.json()).map(data =&gt; {
    data.posts.data.forEach((item) =&gt; {
      observableBatch.push(this.getImageUrl(item.id));
    });
    return Observable.forkJoin(observableBatch);
  });
}

getImageUrl(id) {
  let url = 'https://localhost/image/' + id;
  return this.http.get(url).map(res =&gt; res.json()).map(data =&gt; {
    console.log('done');
  });
}
</code></pre>
","3526195","","1449157","","2016-11-14 10:28:54","2016-11-14 10:30:22","How to wait till nested forkjoin is finished?","<angular><rxjs><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"40587792","1","","","2016-11-14 11:34:55","","9","11807","<p>I'm trying to implement a ""save on type"" feature for a form using <a href=""https://github.com/ReactiveX/rxjs"" rel=""noreferrer"">RxJS v5 beta</a>.</p>

<p>The data should be posted to the backend as the user types into the text fields. I'm creating a <code>Rx.Subject</code> to fire new events (<code>next()</code>) for new user input and post it with HTTP requests.</p>

<p>I've used this question as a starting point: <a href=""https://stackoverflow.com/questions/37173877/rxjs-wait-until-promise-resolved"">RxJS wait until promise resolved</a></p>

<p>However, with the solution from this post, simultaneous request to the backend are sent. </p>

<p>My goal is to only send one request and defer following requests until a running request has completed. After completion of the request the last of the pending events should be emitted (like it is the case in <code>debounceTime</code>)</p>

<p>The <code>example</code> function in the following snippet uses the approach from the linked SO question. This sends requests for all the input values.</p>

<p>The <code>workaround</code> function function uses a promise stored outside of the ""stream"" to block and wait for a previous request. This works and only sends a request for the last input value. But that seems to not follow the concept of RxJs and feels hacky.</p>

<p>Is there a way to achieve this with RxJS?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function fakeRequest(value) {
  console.log('start request:', value)
  return new Promise((resolve) =&gt; { 
    setTimeout(() =&gt; resolve(value), 1000);
 });
}

function example() {
  let subject = new Rx.Subject();
  
  subject
    .debounceTime(500)
    .switchMap(input =&gt; fakeRequest(input))
    .subscribe(data =&gt; console.log(data))

  subject.next('example value 1');
  subject.next('example value 2');
  subject.next('example value 3');
  subject.next('example value 4');
}


function workaround() {
  let subject = new Rx.Subject();

  let p = Promise.resolve();
  subject
    .debounceTime(500)  
    .switchMap(input =&gt; p.then(() =&gt; input))
    .do(input =&gt; p = fakeRequest(input))
    .subscribe(data =&gt; console.log(data))

  subject.next('workaround value 1');
  subject.next('workaround value 2');
  subject.next('workaround value 3');
  subject.next('workaround value 4');
}

example();
// workaround();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.0-rc.2/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","181108","","-1","","2017-05-23 12:30:23","2021-10-07 14:56:12","Wait for a promise to resolve with RxJs","<javascript><rxjs><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"40587900","1","40589585","","2016-11-14 11:41:26","","3","452","<p>I have a code where for each of the ids I am making an ajax request and processing them as results come in. Here is a simple replica of my actual code and <a href=""https://jsfiddle.net/ibrahimislam/nfmnxe62/5/"" rel=""nofollow noreferrer"">jsfiddle</a>:</p>

<pre><code>var ids = [1,2,3,4,5,6];
var ids$ = (id) =&gt; {
    return Observable.of(id);
};
var loadIds$ = (id) =&gt; {
    if(id == 4) return xhr('/echo/jsoneee/', {id: id});
    return xhr('/echo/json/', {id: id});
};

Observable.from(ids)
.concatMap(id =&gt; Observable.forkJoin(ids$(id), loadIds$(id)))
.catch((err, caught) =&gt; {
  //get the id for which loadIds failed
  //send the id to subscribe() and continue the subscription
  return Observable.empty();
})
.subscribe(result =&gt; console.log(result))
</code></pre>

<p>But now I need to modify the code so that if an error occurs I will have to get the <code>id</code> for which the ajax request failed and then just continue the subscription like nothing happened. I have not been able to do this yet. Help is really appreciated.</p>
","1565402","","310726","","2016-11-14 13:13:36","2016-11-14 13:13:36","Continue the subscription after error","<javascript><ajax><rxjs><reactive-programming><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"40589585","2","","40587900","2016-11-14 13:11:45","","3","","<p>I think you can simplify this significantly by emitting correct values right in <code>Observable.create(...)</code>:</p>

<pre><code>function xhr(url, json) {
    return Observable.create(function (observer) {
        $.ajax({
            url: url,
            data: JSON.stringify(json),
            success: function (response) {
                observer.next([json.id, json]);
            },
            error: function (jqXHR, status, error) {
                observer.next([json.id]); // &lt;== Notice this
            },
            complete: function () {
                observer.complete();
            }
        });
    });
}

var ids = [1,2,3,4,5,6];
var ids$ = (id) =&gt; {
    return Observable.of(id);
};
var loadIds$ = (id) =&gt; {
    if(id == 4) return xhr('/echo/jsoneee/', {id: id});
    return xhr('/echo/json/', {id: id});
};

Observable.from(ids)
    .concatMap(id =&gt; loadIds$(id))
    .subscribe(result =&gt; console.log(result));
</code></pre>

<p>This way you can avoid <code>forkJoin()</code> completely. Also be aware that <code>catch()</code> operator automatically unsubscribes from its source. This operator is intended to continue with another Observable so it's now very useful in cases such as yours.</p>

<p>You could of course use:</p>

<pre><code>.catch((error, caught) =&gt; {
    return caught;
})
</code></pre>

<p>This however causes resubscription and thus reemission of all values from the beginning which is usually undesired.</p>

<p>There's also <code>onErrorResumeNext()</code> operator that simply ignores the errors but that's probably not what you want.</p>

<p>See demo: <a href=""https://jsfiddle.net/4f1zmeyd/1/"" rel=""nofollow noreferrer"">https://jsfiddle.net/4f1zmeyd/1/</a></p>

<p>A slightly similar question: <a href=""https://stackoverflow.com/questions/39953419/get-new-ticket-then-retry-first-request/39955002#39955002"">get new ticket then retry first request</a></p>
","310726","","-1","","2017-05-23 11:46:15","2016-11-14 13:11:45","","","","4","","","","CC BY-SA 3.0"
"40605395","1","40605459","","2016-11-15 08:43:21","","1","1243","<p>I would like to create a method getSelectedUser that return an Observable only if a private field is there (not undefined).</p>

<pre><code>private user : User

init() {
   // user = loadingUser...
}

getSelectedUser(): Observable&lt;User&gt; {
    // return ???
}
</code></pre>

<p>The goal is that other component can subscribe this observable and receive the user once it is loaded.</p>

<p>Does someone have an idea how I can achieve this?</p>
","2046572","","","","","2016-11-15 08:48:07","RxJs return Observable if variable not undefined","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40605459","2","","40605395","2016-11-15 08:48:07","","1","","<p>Then define user to be an observable:</p>

<pre><code>private user: Subject&lt;User&gt; = new ReplaySubject&lt;User&gt;(1); // ensure that new registered component gets the last loaded user.

getSelectedUser(): Observable&lt;User&gt; {
   return user.asObservable();
}
</code></pre>

<p>then update the user when it is ready:</p>

<pre><code>private someUserLoadingFunction(){
   ... retrieve user logic -&gt; currentUser...
   this.user.next(currentUser);
}
</code></pre>
","242098","","","","","2016-11-15 08:48:07","","","","5","","","","CC BY-SA 3.0"
"40611203","1","40619428","","2016-11-15 13:35:02","","6","3742","<p>I'm still a noob when it comes to RxJS but here's a JSBin of what I am trying to do.</p>

<p><a href=""https://jsbin.com/wusalibiyu/1/edit?js,console"" rel=""noreferrer"">https://jsbin.com/wusalibiyu/1/edit?js,console</a></p>

<p>I have an observable 'a' (in my case it's the current active connection) which emits a new object whenever the connection reconnects. It's an observable itself because it can re-emit a new value.</p>

<p>I now want an observable that completes whenever an action is executed on the current connection. That action notifies it is done when the observable for it completes. This is b.</p>

<p>The problem is that when the inner observable completes, the outer does not complete. How to make the outer observable complete ... . Is there a different operator I should be using in RxJS5?</p>
","48417","","","","","2016-11-15 20:48:41","switchMap does not seem to complete when the inner observable completes","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40619428","2","","40611203","2016-11-15 20:48:41","","9","","<p>If I understand your requirement correctly, you can ""lift"" the inner stream out using a <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-materialize"" rel=""noreferrer""><code>materialize</code></a>/<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-dematerialize"" rel=""noreferrer""><code>dematerialize</code></a> pair (note I refactored as well as part of my never ending war to get people to stop using <code>Observable#create</code>).</p>

<p><a href=""https://jsbin.com/puxenajama/1/edit?js,console"" rel=""noreferrer"">JsBin</a> (excerpt below)</p>

<pre><code>function b(a) {
  // Emit and complete after 100 millis
  return Rx.Observable.timer(100)

    // Ignore any values emitted
    .ignoreElements()

    // Emit the value on start
    .startWith(a)
    .do(() =&gt; console.log('creating observable'))
    .finally(() =&gt; console.log('b done'));
}

var a$ = Rx.Observable.from(['a', 'b'])
  .finally(() =&gt; console.log('a done'));

var result$ = a$.switchMap(function(a) {
  console.log('switching map for a to b', a);

  // This ""materializes"" the stream, essentially it maps complete -&gt; next
  return b(a).materialize();
})
// This does the opposite, and converts complete events back, 
// but since we are now in the outer stream
// this results in the outer stream completing as well.
.dematerialize()
.share();


result$.subscribe(function(value) {
  console.log('value', value);
}, function(e) {
  console.error('e', e);
}, function() {
  console.log('completed!');
})

result$.toPromise().then(function(data) {
  console.log('this should trigger!?', data);
}, function(e) {
  console.error('boom', e.toString());
});
</code></pre>
","2521865","","","","","2016-11-15 20:48:41","","","","1","","","","CC BY-SA 3.0"
"40631095","1","","","2016-11-16 11:34:21","","0","476","<p>I have a piece of flow that in an imperative language could look like:</p>

<pre><code>if (something1()) {
  try {
    return loadDataFrom1();
  } catch (err) { }
}

if (something2()) {
  try {
    return loadDataFrom2();
  } catch (err) { }
}

if (something3()) {
  try {
    return loadDataFrom3();
  } catch (err) { }
}

return someSafeDefault();
</code></pre>

<p>The conditions are not mutually exclusive. It may happen that both <code>something1()</code> and <code>something2()</code> are true, in which case <code>loadDataFrom2()</code> should occur when <code>loadDataFrom1()</code> fails.</p>

<p>Now I need to implement this using rxjs 5, with the conditions as well as the operations dealing with Observables.</p>

<p>I can easily achieve the callback hell equivalent by creating Observables and subscribing all over the place, but it's bad for many obvious reasons.</p>

<p>What is a good, idiomatic way to do it?</p>
","277683","","277683","","2016-11-16 11:50:44","2016-11-16 13:33:04","Idiomatic if-else chain with rx/rxjs","<rxjs><rxjs5>","1","4","","","","CC BY-SA 3.0"
"40636035","1","40822369","","2016-11-16 15:32:50","","0","486","<p>I have a table on a page and two subscriptions:</p>

<ol>
<li>First one reloads table data. It has a delay because it calls an api.</li>
<li>Second highlights data. Does not affect table data.</li>
</ol>

<p>When subscriptions fire one by one everything is OK, but when they fire at the same time data is highlighted and soon after is reloaded so highlighting is gone.</p>

<p>You can see it <a href=""https://fiddle.jshell.net/WiseBird/mc8h52r7/2/"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Is there are way to postpone highlighting if reloading is in action?</p>

<p>Probably I can accomplish this by introducing <code>loading</code> variable but I am looking for reactiveX solution.</p>

<p>Thanks in advance.</p>
","1010664","","","","","2016-11-28 18:06:25","Postpone observable when other one fired in RxJs","<rxjs5><reactivex>","1","0","","","","CC BY-SA 3.0"
"40651842","1","40655239","","2016-11-17 10:01:52","","1","903","<p>I need a way to pipe values from an observable to two functions that each accept a value and each in turn returns an observable (emiting only a single value, then completing). I was hoping <code>.combineLatest()</code> would allow me to pass a projection function, but it doesn't.</p>

<p>Sample code (not working):</p>

<pre><code>const ac = [1, 2, 3]; // only as example, I have complex types in my array not numbers

Observable.from(ac)
    .combineLatest(
        // processFn should get a number as argument and return Observable&lt;number&gt;
        // does not work because .combineLatest does not accept two functions as arguments :(
        n =&gt; processFn1(n),
        n =&gt; processFn2(n)
    )
    .map(([result1, result2] =&gt; {
        // result1, result2 should be flat numbers here, not Observables
    })
);
</code></pre>

<p>Any idea on how to do that?</p>
","777928","","777928","","2016-11-17 12:22:19","2016-11-17 12:44:06","RxJS5: .combineLatest() with projection function?","<javascript><typescript><rxjs><rxjs5><reactivex>","1","0","","","","CC BY-SA 3.0"
"40655239","2","","40651842","2016-11-17 12:44:06","","2","","<p>Your idea to use the combineLatest operator is correct but it's in the wrong place. If you need to flat out observables you should be using mergeMap. This is a JSBIN that does what you expect: <a href=""http://jsbin.com/rutovot/4/edit?html,js,console"" rel=""nofollow noreferrer"">http://jsbin.com/rutovot/4/edit?html,js,console</a></p>

<p>The code looks like this:</p>

<pre><code>const ac = [1, 2, 3];

Rx.Observable.from(ac)
  // use mergeMap, it takes a function that accepts a value and
  // returns an observable. MergeMap will listen to this observable
  // under the hood and next the result of this observable down the
  // the chain
  .mergeMap(val =&gt; {
    // Here we return an observable that combines the result of the
    // call to both the functions
    return Rx.Observable.combineLatest(fake(val), fake2(val));
  })
  .subscribe(val =&gt; console.log(val));
</code></pre>
","1018598","","","","","2016-11-17 12:44:06","","","","1","","","","CC BY-SA 3.0"
"40663296","2","","40141024","2016-11-17 19:21:05","","1","","<p>Being a newbie, I found my issue and answering my own question in case it helps someone...</p>

<p>Turns out it was simple, I needed to pass down all handlers in the subscribe. </p>

<pre><code>.subscribe(
   (packet) =&gt; subscriber.next(packet),
   (error) =&gt; subscriber.error(error),
   () =&gt; console.log('completed')
);
</code></pre>
","2275792","","","","","2016-11-17 19:21:05","","","","0","","","","CC BY-SA 3.0"
"40664127","1","40664207","","2016-11-17 20:09:14","","0","41","<p>Quick question: Will <code>.do()</code> fire off when there is an error? The docs say, ""Perform a side effect for every emission on the source Observable, but return an Observable that is identical to the source."" Is an error considered an emission, too?</p>

<pre><code>return this.authHttp.get(url)
      .delay(5000)
      .map(this.extractData)
      .do(() =&gt; console.log(""I'm doing something""))
      .share()
      .catch(error =&gt; {
        if (isDev) this.toastr.error(""The panels could not be retrieved from the API."");
        return this.handleEerror(error);
      });
</code></pre>
","5899766","","819742","","2016-11-17 20:10:21","2016-11-17 20:14:58","Is Error Considered an Emission from an Observable in RxJs?","<javascript><rxjs><rxjs5><reactivex>","2","1","","","","CC BY-SA 3.0"
"40664207","2","","40664127","2016-11-17 20:14:58","","2","","<p>The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/do.md#rxobservableprototypedoobserver--onnext-onerror-oncompleted"" rel=""nofollow noreferrer""><code>.do()</code> method</a> can take an optional <code>onError</code> callback for handling errors:</p>

<pre><code>observable
  .do(
    value =&gt; console.log(""I'm doing something""),
    err   =&gt; console.error('I got an error', err.stack)
  )
</code></pre>

<p>...otherwise it will just pass through the pipeline.</p>
","119549","","","","","2016-11-17 20:14:58","","","","1","","","","CC BY-SA 3.0"
"40675631","1","","","2016-11-18 11:11:19","","1","1273","<p>I am new to RX-JS , and would like to log data for debugging purpose.
In the end what i need is to log every observable defined in piece of code and all events / emits of data happening out of those observables.</p>

<p>For RX-JS If i override <strong>lift</strong> , it becomes possible to inject behaviors into all observers in an operator chain ,
<strong>But how can i log RX-Observables those are not applied to any operator yet ?</strong>.</p>

<p>And is it proper way to log all observables to override <strong>lift</strong> and subscribe to each observables for logging data ,
Because <strong>do</strong> operator did not work.</p>

<p>This is how i am trying </p>

<pre><code>const _lift = Rx.Observable.prototype.lift;
var idCounter = 0;
Rx.Observable.prototype.lift = function (operator) {
    var sourceObs = this ;
    sourceObs.id = ++idCounter;
    var resultantObservable = _lift.call(sourceObs, operator);
    resultantObservable.id = ++idCounter;
    // In this Method i log data 
    LogObserver(operator , sourceObs , resultantObservable);
    return resultantObservable;
};
</code></pre>

<p>Above code works for</p>

<pre><code>var timer = Rx.Observable.interval(1000).take(4);
</code></pre>

<p>But does not work for </p>

<pre><code>var sequence = Rx.Observable.range(1, 10);
</code></pre>

<p>Thanks in advance.</p>

<p>Best Regards</p>
","7103462","","7103462","","2016-11-18 12:03:45","2016-11-18 15:13:24","RX-JS 5 - Using ""lift"" to log Observable data for debugging","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40677789","1","40677919","","2016-11-18 13:00:03","","0","437","<p>I am using RxJS observables in my Angular 2 application.I am trying to get a list of employee and if the employee id ends with 'MA' i dont want them to be added to the list. Following is my code:</p>

<pre><code>    getEmployees(): any {
    return this.employeeService.get(""http://localhost:9080/employees"")
                .map((employees: any) =&gt; employees.map((employee: any) =&gt; {
                    let empcode: string = employee.empcode;
                    if (empcode.lastIndexOf(""MA"") == -1) {
                        return { empText: empcode+ ' - ' + employee.empName, data: employee};
                    }
                        return { empText: '', data : null};
                }));
}
</code></pre>

<p>I am not able to filter the records and it is returning me all the values.I have two return statements so it is returning all the value but if I remove one of them I get the following error:</p>

<p>no best common type exists among return expressions</p>

<p>The json returned by the web service is in the following format:</p>

<pre><code>{
employeeCode: ""EMPCT"", 
employeeName: ""Tom"", 
role: ""HR""
}
</code></pre>

<p>So could you let me know what is the best way to filter records returned by the web service in this case.</p>
","2600457","","2600457","","2016-11-18 13:38:45","2016-11-18 13:56:52","How to filter data using RxJS observables based on a pattern","<angular><typescript><rxjs5>","2","0","","","","CC BY-SA 3.0"
"40677919","2","","40677789","2016-11-18 13:07:12","","1","","<p>Why not use the <code>filter</code> function?</p>

<pre><code>getEmployees(): any {
  return this.employeeService.get(""http://localhost:9080/employees"")
              .map((employees: any) =&gt; items.filter((employee: any) =&gt; {
                  let empcode: string = employee.empcode;
                  return ((ifscode.lastIndexOf(""MA"") == -1); 
              }));
}
</code></pre>

<p>not sure where the ifscode comes from. Anyways, you should use filter. If you need further transformation, you can chain a <code>.map()</code> operation.</p>
","242098","","","","","2016-11-18 13:07:12","","","","4","","","","CC BY-SA 3.0"
"40681663","1","","","2016-11-18 16:17:16","","0","92","<p>Is there any function in RX-JS that serve same as we have .spy in Bacon.js.
<a href=""https://github.com/baconjs/bacon.js/#bacon-spy"" rel=""nofollow noreferrer"">https://github.com/baconjs/bacon.js/#bacon-spy</a></p>

<p>I need that to create Debugging tool for RX-JS.</p>

<p>Best Regards</p>
","7103462","","","","","2016-11-22 11:22:30","RX-JS - do we have in RX-JS method like .spy in bacon","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40707379","1","40722965","","2016-11-20 17:54:42","","143","125281","<p>According to <a href=""http://paqmind.com/posts/rxjs-error-and-completed-events-demystified/"" rel=""noreferrer"">this artcle</a>, <code>onComplete</code> and <code>onError</code> function of the <code>subscribe</code> are mutually exclusive.  </p>

<p>Meaning either <code>onError</code> or <code>onComplete</code> events will fire up in my <code>subscribe</code>.<br>
I have a logic block which needs to be executed whether I receive an error, or I finish my steam of information successfully.  </p>

<p>I looked up for something like <a href=""https://docs.python.org/3/tutorial/errors.html"" rel=""noreferrer""><code>finally</code> in python</a>, but all I found is <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/finally.md"" rel=""noreferrer""><code>finally</code></a> which needs to be attached to the observable I create.   </p>

<p>But I want to to do that logic only when I subscribe, and after the stream has ended, whether successfully or with an error.</p>

<p>Any ideas?</p>
","1467394","","310726","","2016-11-22 15:41:41","2021-05-25 06:20:13","Observable Finally on Subscribe","<javascript><rxjs><rxjs5>","3","0","20","","","CC BY-SA 3.0"
"40708264","1","","","2016-11-20 19:12:54","","1","352","<p>I'm new to Redux and Redux-Observable.  I'm having success in getting information from a rest API with GET and GET(ID), but I cannot get the Delete and Post to work.  Sample code below that is issuing a GET request:</p>

<pre><code>[EPIC File]
import { debounceTime, Observable } from 'rxjs';
import { ajax } from 'rxjs/observable/dom/ajax';
import ActionTypes from '../actions/ActionTypes';
import { receiveFeedBack, receiveDeleteFeedBackId,
receiveFeedBackId } from '../actions/FeedBackActions';


export const fetchFeedBack = (action$) =&gt;      ... Working
export const fetchFeedBackId  = (action$) =&gt;   ... Working

//Not Working
export const deleteFeedBackById = (action$) =&gt;
  action$.ofType(ActionTypes.DELETE_FEEDBACK_REQUEST)
  .debounceTime(500)
  .switchMap(action =&gt;
    ajax.delete(`${ActionTypes
      .FEEDBACK__URL}/posts/${action.payload.feedbackId}?key=${ActionTypes
      .FEEDBACK__API_KEY}`)
      .map(receiveDeleteFeedBackId.bind(action))
      .takeUntil(action$.ofType(ActionTypes.DELETE_FEEDBACK_CANCELED))
      .catch(error =&gt; Observable.of({
        type: ActionTypes.DELETE_FEEDBACK_ERROR,
        payload: error
      }))
);
</code></pre>

<p>What am I doing wrong?</p>
","7186340","","","","","2016-11-20 19:12:54","Proper Use of Redux-Ovservable ajax http methods: put, delete, post","<rxjs5><redux-observable>","0","5","","","","CC BY-SA 3.0"
"40722965","2","","40707379","2016-11-21 14:50:53","","173","","<p>The current ""pipable"" variant of this operator is called <code>finalize()</code> (since RxJS 6). The older and now deprecated ""patch"" operator was called <code>finally()</code> (until RxJS 5.5).</p>

<p>I think <code>finalize()</code> operator is actually correct. You say:</p>

<blockquote>
  <p>do that logic only when I subscribe, and after the stream has ended</p>
</blockquote>

<p>which is not a problem I think. You can have a single <code>source</code> and use <code>finalize()</code> before subscribing to it if you want. This way you're not required to <em>always</em> use <code>finalize()</code>:</p>

<pre><code>let source = new Observable(observer =&gt; {
  observer.next(1);
  observer.error('error message');
  observer.next(3);
  observer.complete();
}).pipe(
  publish(),
);

source.pipe(
  finalize(() =&gt; console.log('Finally callback')),
).subscribe(
  value =&gt; console.log('#1 Next:', value),
  error =&gt; console.log('#1 Error:', error),
  () =&gt; console.log('#1 Complete')
);

source.subscribe(
  value =&gt; console.log('#2 Next:', value),
  error =&gt; console.log('#2 Error:', error),
  () =&gt; console.log('#2 Complete')
);

source.connect();
</code></pre>

<p>This prints to console:</p>

<pre><code>#1 Next: 1
#2 Next: 1
#1 Error: error message
Finally callback
#2 Error: error message
</code></pre>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-03-12 16:13:56","2019-03-12 16:13:56","","","","5","","","","CC BY-SA 4.0"
"40733188","1","40739646","","2016-11-22 03:12:55","","1","89","<p>I want to do something like:</p>

<pre><code>Rx.Observable.of(userToken)
    .flatMap(verifyToken)
    .flatMap(getUserInformation)
    .flatMap(createUser)
    .flatMap(signNewToken)
    .subcribe({
        next: result =&gt; useResult(result),
        error: error =&gt; handleError(error)
    })
</code></pre>

<p>What I'm trying to avoid is a callback mess. In my code, functions like <code>verifyToken</code> are Observables, and I want to chain them. Is this pattern on the right track? Because right now as soon as one of them internally does <code>observer.error(new Error('problem'))</code>, the chain crashes and my error handler is not called. How can I improve this?</p>
","371760","","310726","","2016-11-22 13:05:07","2016-11-22 13:05:07","RxJS de-nesting callbacks","<javascript><node.js><ecmascript-6><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40735851","1","40750144","","2016-11-22 07:16:00","","2","743","<p>I have an array of observables which was created in a loop. And then merged all these observables using <code>merge</code>, and subscribed to the merged observable. I could not find a way to retrieve context of observable where it was created (in loop). Here is code</p>

<pre><code>let observable = Rx.Observable.bindNodeCallback(request);
let streams = _(['a', 'b', 'c', 'd'])
 .someMoreLodashStuff()
 .map(val =&gt; {
   // HERE SOMEHOW I WANT TO BIND CONTEXT (e.g. loop val),
   // SO THAT SUBSCRIBER CAN KNOW THE EXACT LOOP STATE
   // WHEN RECEIVING RESULT
   return observable(mutate(val))
 })
 .value();

Rx.Observable
.merge(...streams)
.subscribe(
  (res) =&gt; {
   // HERE I WANT TO GET CONTEXT (e.g. val)
  }, (err) =&gt; {
   // HERE I WANT TO GET CONTEXT (e.g. val)
  },
  () =&gt; {
    //on complete stuff
  });
</code></pre>

<p><strong>Update (as asked by @martin)</strong></p>

<p>Since @martin asked about purpose of this binding and what problem I am trying to solve, so I will describe the real problem.</p>

<p><strong>Pupose and real problem</strong></p>

<p>I am trying to crawl list of websites (passed as query params), fetch their titles and render them in an html and return the html back to user. This is part of my <a href=""https://github.com/hhsadiq/async-lab"" rel=""nofollow noreferrer"">open source repo</a>, where solved this exact problem using node.js callbacks, async.js waterfall and promises. Now solving it using rxjs. Its just a way to learn different async techniques. This is <a href=""https://github.com/hhsadiq/async-lab/blob/master/server/titles/streams/titles.service.js"" rel=""nofollow noreferrer"">file from github repo</a> where using rxjs to solve this problem</p>
","3131443","","3131443","","2016-11-22 13:23:44","2016-11-22 20:03:30","Rxjs bind context of place where observable was created","<javascript><rxjs><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"40739646","2","","40733188","2016-11-22 10:39:33","","1","","<p>I think the error does propagate to your subscriptions. This should simulate your situation:</p>

<pre><code>const Rx = require('rxjs/Rx');
const Observable = Rx.Observable;

let userToken = Observable.of(42);
let verifyToken = Observable.range(1,3);
let getUserInformation = Observable.of('whatever');
let createUser = Observable.create(observer =&gt; {
    observer.error(new Error('problem'));
});

Observable.of(userToken)
    .flatMap(val =&gt; verifyToken)
    .flatMap(val =&gt; getUserInformation)
    .flatMap(val =&gt; createUser)
    .subscribe({
        next: result =&gt; console.log(""Next:"", result),
        error: error =&gt; console.log(""Error subscriber:"", error.message)
    });
</code></pre>

<p>The output in console is as expected:</p>

<pre><code>Error subscriber: problem
</code></pre>
","310726","","","","","2016-11-22 10:39:33","","","","1","","","","CC BY-SA 3.0"
"40746992","1","","","2016-11-22 16:30:15","","0","772","<p>I did create my own Observable service that return current tracks of a player.</p>

<p>I'm subscribing to this service on my Angular component this way:</p>

<pre><code>this.playerSubscription = this.player
      .player(playlist)
      .subscribe(
        playerInfo =&gt; this.playerInfo = playerInfo,
        error =&gt; this.router.navigate(['login'], { queryParams: { error: 'expired_token' }})
      );
</code></pre>

<p>As you can see, when I have an error, I redirect the user to the login page.</p>

<p>The problem is when I do login after a previous error, the subscription returns to me the <strong>lastest error sequence and I gonna redirected again to the login page.</strong></p>

<p>On my service, I'm using the BehaviorSubject and doing <code>subject.next(message)</code> to valid sequences, and <code>subject.error(error)</code> to send an error sequence.</p>

<p>How can I forget about the last error after resubscribing
 to my observable?</p>

<p>Thank you!</p>

<p><strong>UPDATE 1:</strong></p>

<p>I did some new tests here and it only works when I create a new subject every time I subscribe, like bellow:</p>

<pre><code>player(playlist: IPlaylist, fromBegin: boolean): Observable&lt;IPlayerInfo&gt; {

    this._player = new BehaviorSubject&lt;IPlayerInfo&gt;({ status: PlayerStatuses.LOADING });

    ... more code here ...

    return this._player.asObservable();
  }
</code></pre>

<p>Nevermind if it's a <code>Subject</code> or a <code>BehaviorSubject</code>.</p>

<p>Is this a good practice?</p>
","4978097","","4978097","","2016-12-08 02:53:14","2016-12-08 02:53:14","Angular 2 Observable Error Handling","<angular><rxjs><observable><rxjs5>","1","2","","","","CC BY-SA 3.0"
"40750144","2","","40735851","2016-11-22 19:31:26","","2","","<p>If you want to retain a reference to the input state you could use the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/selectmany.md"" rel=""nofollow noreferrer""><code>flatMap</code></a> overload which takes a <code>resultSelector</code> function to create a tuple containing the merged input + output state:</p>

<pre><code>// given a function which can return the body of the page requested
function doRequest(url) : Observable&lt;string&gt;

const urls = Rx.Observable.from([a,b,c])
  .flatMap(
    a =&gt; doRequest(url),
    (a,res) =&gt; ({ url: a, body: res})
  )
  .subscribe(resTuple =&gt; console.log(`url ${resTuple.url} returned ${resTuple.body}`)
</code></pre>
","106909","","106909","","2016-11-22 20:03:30","2016-11-22 20:03:30","","","","4","","","","CC BY-SA 3.0"
"40751826","1","","","2016-11-22 21:19:34","","11","6401","<p>I've always known to import my <code>Observable</code> operators separately to limit the load times. However I've noticed something today that I hope someone could please explain to me.</p>

<p>I am using IntelliJ/WebStorm with Webpack.</p>

<p>Let's say on a page in my <code>ngOnInit</code> I have an http call:</p>

<pre><code> ngOnInit() {  
        this.http.get('https//:google.com').map(e =&gt; e);
 }
</code></pre>

<p>If I don't import the map operator the compiler will complain, so I import it like this:</p>

<pre><code>import 'rxjs/add/operator/map';
</code></pre>

<p>All is good in the world. Until I need to use an Observable. So, I'll add one.</p>

<pre><code> ngOnInit() {
        let test = Observable.create(subscriber =&gt; {
            return null;
        });

        this.http.get('https//:google.com').map(e =&gt; e);
 }
</code></pre>

<p>Now the compiler understandably complains that it cannot find Observable, so I get IntelliJ/WebStorm to import it for me and adds this at the top of my file:</p>

<pre><code>import {Observable} from 'rxjs';
</code></pre>

<p>All is good again. But, this new import seems to make the map import irrelevant. What I mean is that, if I remove the map import and just leave the Observable one in, all compiles fine...</p>

<p>However, if I specify to import Observable like this:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
</code></pre>

<p>Then I must re-add the import for the map operator...</p>

<p>Am I importing all of RxJS when I import my Observable like this?</p>

<pre><code>import {Observable} from 'rxjs';
</code></pre>

<p>If so, how can I tell IntelliJ to not do that and import class only?</p>
","2275792","","783119","","2016-11-22 22:28:18","2017-10-25 03:23:39","Angular and RxJS imports","<angular><intellij-idea><webstorm><rxjs5>","3","3","3","","","CC BY-SA 3.0"
"40780363","1","","","2016-11-24 07:30:59","","8","2805","<p>I have the following <code>systemjs.config.js</code> (based on some example I found on the internet):</p>

<pre><code>(function (global) {
    System.config({
        paths: {
            // paths serve as alias
            'js:': 'js/',
        },
        // map tells the System loader where to look for things
        map: {
            // our app is within the app folder
            app: 'app',
            // angular bundles
            '@angular/core': 'js:angular2/core.umd.js',
            '@angular/common': 'js:angular2/common.umd.js',
            '@angular/compiler': 'js:angular2/compiler.umd.js',
            '@angular/platform-browser': 'js:angular2/platform-browser.umd.js',
            '@angular/platform-browser-dynamic': 'js:angular2/platform-browser-dynamic.umd.js',
            '@angular/http': 'js:angular2/http.umd.js',
            '@angular/router': 'js:angular2/router.umd.js',
            '@angular/forms': 'js:angular2/forms.umd.js',
            '@angular/upgrade': 'js:angular2/upgrade.umd.js',
            // other libraries
            'rxjs': 'js:rxjs',
            'angular-in-memory-web-api': 'js:in-memory-web-api.umd.js'
        },
        // packages tells the System loader how to load when no filename and/or no extension
        packages: {
            app: {
                main: './main.js',
                defaultExtension: 'js'
            },
            rxjs: {
                defaultExtension: 'js'
            }
        }
    });
})(this);
</code></pre>

<p>When I start my Angular2 application many individual rxjs files are loaded which takes a long time. I have a bundled version of RxJs in <code>js/rxjs/bundles/Rx.js</code>, so I tried to modify <code>systemjs.config.js</code> like this:</p>

<pre><code>(function (global) {
    System.config({
        paths: {
            // paths serve as alias
            'js:': 'js/',
        },
        // map tells the System loader where to look for things
        map: {
            // our app is within the app folder
            app: 'app',
            // angular bundles
            '@angular/core': 'js:angular2/core.umd.js',
            '@angular/common': 'js:angular2/common.umd.js',
            '@angular/compiler': 'js:angular2/compiler.umd.js',
            '@angular/platform-browser': 'js:angular2/platform-browser.umd.js',
            '@angular/platform-browser-dynamic': 'js:angular2/platform-browser-dynamic.umd.js',
            '@angular/http': 'js:angular2/http.umd.js',
            '@angular/router': 'js:angular2/router.umd.js',
            '@angular/forms': 'js:angular2/forms.umd.js',
            '@angular/upgrade': 'js:angular2/upgrade.umd.js',
            // other libraries
            'rxjs': 'js:rxjs/bundles/Rx.js',
            'angular-in-memory-web-api': 'js:in-memory-web-api.umd.js'
        },
        // packages tells the System loader how to load when no filename and/or no extension
        packages: {
            app: {
                main: './main.js',
                defaultExtension: 'js'
            }
        }
    });
})(this);
</code></pre>

<p>When I try to start my application now, I get the following error in the browser:</p>

<pre><code>Error: (SystemJS) Syntax error
    SyntaxError: Syntax error
       at Anonymous function (eval code:2:1)
    Evaluating http://localhost:37191/js/rxjs/bundles/Rx.js/Subject
    Evaluating http://localhost:37191/app/main.js
    Error loading http://localhost:37191/app/main.js
</code></pre>

<p>My <code>main.ts</code> looks like this:</p>

<pre><code>import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app.module';
const platform = platformBrowserDynamic();
platform.bootstrapModule(AppModule);
</code></pre>

<p>And my <code>app.module.ts</code> looks like this:</p>

<pre><code>import 'rxjs';

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppRoutingModule } from './app-routing.module';

import { AppComponent } from './app.component';
import { DeviceGroupsViewComponent } from './device-groups-view.component';

import { DeviceGroupService } from './devicegroup.service';
import { SourceTypeService } from './sourcetype.service';

@NgModule({
    imports: [
        BrowserModule,
        FormsModule,
        HttpModule,
        AppRoutingModule
    ],
    declarations: [
        AppComponent,
        DeviceGroupsViewComponent
    ],
    providers: [
        DeviceGroupService,
        SourceTypeService
    ],
    bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>

<p>What do I have to change to make my app work with the bundled Rx.js?</p>
","487356","","310726","","2016-11-24 13:55:20","2016-11-24 13:55:20","SystemJS loads many files for rxjs","<angular><typescript><rxjs><systemjs><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"40781903","1","","","2016-11-24 09:02:44","","6","3978","<p>I'm using this but interval operator wants to be on observable object its not exist on range, is there a way to have observable that emit for example emit 60 integer with interval of 1 second, i have been doing this</p>

<pre><code> this.clock = Observable.range(1,60);
 this.clock = this.clock.interval(1000).map(function(value){
     console.log(value)
     return value;
 })
</code></pre>

<p>Its saying interval is not a function</p>

<p>also tried this:</p>

<pre><code> this.clock = Observable.range(1,60).interval(1000).map(function(value){
     console.log(value)
     return value;
 })
</code></pre>
","5710014","","","","","2016-11-24 10:21:23","How to emit integers from certain range with some interval of time using rxjs","<javascript><angular><rxjs><reactive-programming><rxjs5>","3","2","3","","","CC BY-SA 3.0"
"40786658","1","40786793","","2016-11-24 12:38:39","","1","167","<p>I am looking for a way to combine multiple Observables into a flat tuple of scalar values - similar to <code>.combineLatest()</code> - but with the exception that it should emit a new value tuple even when no value has been emitted on one of the source observables - yieldung ""undefined"" in the tuple for those observables that did not yet emit.</p>

<p>Example:</p>

<pre><code>const s1 = new Subject&lt;string&gt;();
const s2 = new Subject&lt;string&gt;();

Observable.combineWithUndefined(s1, s2).subscribe( ([t1, t2]) =&gt; {
    console.log(t1.toString() + "" "" + t2.toString());
});

s1.next(""Hello"");
s2.next(""John"");

// expected output:
// Hello undefined
// Hello John
</code></pre>
","777928","","","","","2016-11-24 12:46:43","RxJS5 operator similiar to .combineLatest but fire whenever a single observable emits","<javascript><typescript><rxjs><rxjs5><angular2-observables>","1","0","1","","","CC BY-SA 3.0"
"40786793","2","","40786658","2016-11-24 12:46:43","","2","","<p>Make the two subjects <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-startWith"" rel=""nofollow noreferrer"">startWith</a> the undefined value, so when one of then emits the first value, the combineLatest will emit as well and combine that with the start value of the other subject.</p>
","645252","","","","","2016-11-24 12:46:43","","","","0","","","","CC BY-SA 3.0"
"40792748","1","41193702","","2016-11-24 18:29:49","","0","113","<p>How do I determine, if the Observable is ""empty""?
Better, that it has <strong>never</strong> received anything.</p>

<p>My code looks like this:
<code>spots: Observable&lt;Spot[]&gt;;</code></p>

<p>And I've tried several things I found on Google like:</p>

<pre><code>spots.isEmpty();
spots.length;
spots.length();
spots().length;
spots.first();
</code></pre>

<p>But none of them works like I want..
I need this functionality, to fill a list in Ionic2 with <code>No items found</code> until the first item is loaded.</p>
","1904790","","","","","2016-12-16 23:10:40","How do I determine, if Observable has never received anything?","<meteor><ionic2><rxjs5>","2","2","","","","CC BY-SA 3.0"
"40815665","1","40815680","","2016-11-26 06:31:41","","2","549","<p>How to get how many times this observable ran </p>

<pre><code>   this.clock = Observable.interval(1000).map(function(value){
     if(value == 0){
       return  value * 100 / 60;
     }
     return value * 100 / 60;
    }).take(61);
</code></pre>

<p>I want to get that this Observable ran 1 or 2 or 3.. times and display each time with interpolation in template</p>

<p>if I'm doing this, it would return percentage variable to be NaN</p>

<pre><code>this.clock.subscribe(function(x){
              console.log(x);
              console.log(""percentage "" + this.percentage);
              this.percentage = this.percentage + 1;
    })
</code></pre>
","5710014","","5710014","","2016-11-26 06:55:27","2016-11-26 07:33:29","How to get number of ticks from rxjs Observable","<javascript><angular><rxjs><reactive-programming><rxjs5>","1","2","","","","CC BY-SA 3.0"
"40815680","2","","40815665","2016-11-26 06:33:50","","2","","<p>Then you can create a variable which will responsible for storing count of how many time observable ran. Then apply <code>async</code> over that value to display value returned by observable.</p>

<pre><code>{{ clockCount | async }}
</code></pre>

<p><strong>Code</strong></p>

<pre><code>clockCount: any;
count: number = 0;
ngOnInit(){
    this.clock = Observable.interval(1000).map((value) =&gt; {
       if(value == 0){
         return  value * 100 / 60;
       }
       return value * 100 / 60;
    }).take(61);
    this.clockCount = this.clock.do(() =&gt; this.count = ++this.count);
}
</code></pre>
","2435473","","2435473","","2016-11-26 07:33:29","2016-11-26 07:33:29","","","","8","","","","CC BY-SA 3.0"
"40822369","2","","40636035","2016-11-26 19:38:40","","1","","<p>Keep in mind that in rxjs everything is a stream, which you can use to your advantage, I've modified you fiddle a bit so that everything is a stream now:</p>

<pre><code>  var pageClicks = Rx.Observable.fromEvent(document.getElementById('page'),  'click');
  var highlightClicks = Rx.Observable.fromEvent(document.getElementById('highlight'), 'click');
  var bothClicks = Rx.Observable.fromEvent(document.getElementById('both'), 'click');

  var page = 0;
  var nextPage$ = Rx.Observable.of(page)
    .map(function() {
      page = (page + 1) % 2;
      return page
    })
    .switchMap(loadData)
    .do(renderData);

  var doBoth$ = nextPage$
    .do(highlight);

  // initial rendering of data
  doBoth$.subscribe();

  pageClicks
    .switchMapTo(nextPage$)
    .subscribe();

  highlightClicks
    .do(highlight)
    .subscribe();

  bothClicks
    .switchMapTo(doBoth$)
    .subscribe();
</code></pre>

<p>Here is the link to the updated fiddle: <a href=""https://fiddle.jshell.net/r2L7k0mc/3/"" rel=""nofollow noreferrer"">https://fiddle.jshell.net/r2L7k0mc/3/</a></p>

<hr>

<p>Based on your comments I have updated your fiddle with the following code:</p>

<pre><code>  var page$ = events.page$.share();
  var loadData$ = page$
    .startWith(0)
    .switchMap(page =&gt; loadData(page).takeUntil(page$))
    .do(renderData);
  loadData$.subscribe();

  var loading$ = Rx.Observable.merge(
    page$.mapTo(true),
    loadData$.mapTo(false)
  )
    .startWith(false)
    .publishReplay(1);
  loading$.connect();

  events.highlight$
    .switchMap(function() {
        return loading$
        .filter(function(isLoading) { return !isLoading; })
        .take(1);
    })
    .do(highlight)
    .subscribe();
</code></pre>

<p>See: <a href=""https://fiddle.jshell.net/mc8h52r7/5/"" rel=""nofollow noreferrer"">https://fiddle.jshell.net/mc8h52r7/5/</a></p>

<p>However I would strongly suggest to rethink the architecture, since this is a very ugly set of streams, that could surely be optimized with a different architecture.</p>
","1518765","","1518765","","2016-11-28 18:06:25","2016-11-28 18:06:25","","","","5","","","","CC BY-SA 3.0"
"40825126","1","40827320","","2016-11-27 02:10:01","","3","1040","<p>I'd like to handle the response of each subscribe independently in a concat observable. I'm using Rxjs 5 in angular2.</p>

<pre><code>let source1 = //some Http service
let source2 = //some Http service
let source3 = //some Http service  

Observable.concat(source1,source2,source3)
      .subscribe(data=&gt; console.log(data));
</code></pre>

<p>The above concat observable works fine, as long as the data returned from each source is of the same type and I have to handle the returned data in the same way for all 3 sources.</p>

<p>But what if the sources where generating a promise from a different service and each source's data returned in the subscription was different and needed to be handled uniquely. Is this possible? The following is a pseudo code of what I'm asking for.</p>

<pre><code>let source1 = //some Http service1 returns a string
let source2 = //some Http service2 returns a number
let source3 = //some Http service3 returns a boolean  

//The following is pseudo code
Observable.concat(source1,source2,source3)
      .subscribe(data_source1=&gt; console.log(data_source1))
      .subscribe(data_source2=&gt; console.log(data_source2 +3))
      .subscribe(data_source3=&gt; console.log(data_source3 === true));
</code></pre>

<p>p.s. Clearly all the responses need to be handled sequentially not in parallel.</p>
","2333145","","310726","","2016-11-27 09:09:30","2016-11-27 10:19:06","concat: how to handle each subscribe with a specific next function as independent","<javascript><asynchronous><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40827193","1","40839071","","2016-11-27 08:47:00","","1","1728","<p>I have an array of numbers like this: [1, 2, 3], and HTTP service that has function to load data object by number like this:</p>

<pre><code>function get(id: number): Observable&lt;object&gt;
</code></pre>

<p>How to map my original array of numbers to array of objects preserving order of elements?</p>
","2000124","","310726","","2016-11-27 09:20:35","2016-11-28 07:24:03","Angular 2 & RxJS: map an array using Rx Observable","<angular><typescript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"40827320","2","","40825126","2016-11-27 09:07:09","","1","","<p>You could use <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/forkjoin.md"" rel=""nofollow noreferrer""><code>forkJoin()</code></a> that emits after all Observables complete.</p>

<p>However, you say you want to handle responses sequentially so I guess you want to start requests one after another. </p>

<p>This is still solvable with <code>concat</code> and then merging all responses into a single array with <code>toArray()</code>.</p>

<pre><code>const Observable = Rx.Observable;

let source1 = Observable.of(42).do(() =&gt; console.log('source1')).delay(500);
let source2 = Observable.of(true).do(() =&gt; console.log('source2')).delay(500);
let source3 = Observable.of(""Hello, World!"").do(() =&gt; console.log('source3')).delay(500);

Observable.concat(source1, source2, source3)
    .toArray()
    .subscribe(data =&gt; console.log(data));
</code></pre>

<p>This prints to console:</p>

<pre><code>""source1""
""source2""
""source3""
[42, true, ""Hello, World!""]
</code></pre>

<p>There're multiple <code>do()</code> operators to show that the Observables are started with delay.</p>

<p>See live demo: <a href=""https://jsbin.com/kikuceh/1/edit"" rel=""nofollow noreferrer"">https://jsbin.com/kikuceh/1/edit</a></p>
","310726","","310726","","2016-11-27 10:19:06","2016-11-27 10:19:06","","","","0","","","","CC BY-SA 3.0"
"40838308","1","40838856","","2016-11-28 06:28:53","","8","5717","<p>I am using Rx to keep an animation clock. Every animation frame, it maps an interval tick to the new values for that tick.</p>

<p>Suppose I want to pause the animation. The most natural way would be to somehow suspend the clock rx and then resume it at a later time. </p>

<p>Unsubscribe then resubscribe isn't a natural fit, because this animation clock is a cold observable. I don't want to restart the animation when they resume. If I go for a workaround method, I will have to generate a new resume rx, vastly complicating all of the exposed APIs.</p>

<p>Backpressure methods don't seem promising:</p>

<p><code>pause</code> doesn't work, because I want to resume where I left off, not jump forward. In other words I don't want to drop ticks while it's off.</p>

<p><code>pausableBuffered</code> doesn't work, because on resume, it will drain all of the accumulated ticks as fast as it can. </p>

<p>Using some sort of a virtual time scheduler to completely stop time and then resume normal time might be possible(?)</p>

<p>I am on RxJS 5.0rc4, but I wouldn't know how to do this on RxJS 4, either. Any advice for either version would be appreciated.</p>
","86432","","","","","2021-11-05 03:57:37","RxJS (5.0rc4): Pause and resume an interval timer","<rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"40838856","2","","40838308","2016-11-28 07:09:51","","9","","<p>Use <code>switchMap</code> on a <code>pauser</code> stream to choose between the original source and <code>Observable.never</code>. If you don't want the timer to jump ahead, then manage it yourself (using the <code>x</code> variable in the below).</p>
<pre class=""lang-js prettyprint-override""><code>function pausableInterval(ms, pauser) {
    let x = 0;
    const source = IntervalObservable.create(ms);
 
    return pauser.switchMap(
        paused =&gt; paused ? 
        Observable.never() : 
        source.map(() =&gt; x++)
    );
}
</code></pre>
<p>The <code>pauser</code> stream should emit booleans.</p>
<p>Not tested.</p>
","","user663031","7477881","user663031","2021-08-30 02:28:24","2021-08-30 02:28:24","","","","2","","","","CC BY-SA 4.0"
"40839071","2","","40827193","2016-11-28 07:24:03","","0","","<p>Thanks to @martin I found this solution:</p>

<pre><code>const myPromise = val =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(`Promise Resolved: ${val}`), 
                                                          Math.round(Math.random() * 1000 + 1000)))
const queue = Rx.Observable.of([1,2,3,4,5]);
const result = queue
  .mergeMap(q =&gt; Rx.Observable.forkJoin(...q.map(myPromise)));
const subscribeTwo = result.subscribe(val =&gt; console.log(val));
</code></pre>
","2000124","","","","","2016-11-28 07:24:03","","","","0","","","","CC BY-SA 3.0"
"40843003","1","40847072","","2016-11-28 11:16:29","","5","618","<p>I am working on a node project that needs to submit thousands of images for processing. Before these images are uploaded to the processing server they need to be resized so I have something along the lines of this:</p>

<pre><code>imageList
    .map(image =&gt; loadAndResizeImage)
    .merge(3)
    .map(image =&gt; uploadImage)
    .merge(3)
    .subscribe();
</code></pre>

<p>Image resizing typically takes a few tenths of a second, uploading and processing takes around 4 seconds.</p>

<p>How can I prevent thousands of resized images building up in memory as I wait for the upload queue to clear? I probably want to have 5 images resized and waiting to go so that as soon as an image upload finishes the next resized image is pulled from the queue and uploaded and a new image is resized and added to the 'buffer'.</p>

<p>An illustration of the issue can be found here:</p>

<p><a href=""https://jsbin.com/webaleduka/4/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/webaleduka/4/edit?js,console</a></p>

<p>Here there is a load step (taking 200ms) and a process step (taking 4 seconds). Each process is limited to a concurrency of 2.
We can see that with 25 initial items we get to 20 images in memory.</p>

<p>I did look at the buffer options but neither seemed to do what I wanted to do.</p>

<p>At the moment I have just combined the load, resize and upload into one deferred observable that I merge with a max concurrency. I would like to have the images waiting for upload though and I am sure that it must be possible.</p>

<p>I am using RXjs 4 but I imagine the principals will be the same for 5.</p>

<p>Many Thanks.</p>
","151770","","151770","","2016-11-28 14:04:37","2016-11-28 14:48:04","Understanding back-pressure in rxjs - only cache 5 images waiting for upload","<javascript><node.js><rxjs><reactive-programming><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"40844267","1","","","2016-11-28 12:23:53","","2","677","<p>I would like to accomplish something in RxJS that I would express in English like this:</p>

<blockquote>
  <p>Wait for an event to be raised from a stream, perform some function, then wait for five seconds of silence from this stream, then perform another function.</p>
</blockquote>

<p>I have had several attempts at this. The stream I want to subscribe to looks like this:</p>

<pre><code>this.documentClick$ = Observable.fromEvent(document.querySelector('body'), 'mousemove')
    .merge(Observable.fromEvent(document.querySelector('body'), 'click'));
</code></pre>

<p>The current two contenders do the job, but each has its faults:</p>

<pre><code>this.documentClick$
    .subscribe( () =&gt; {
        this.toolbarsVisible = 'visible';
    });

this.documentClick$
    .debounceTime(5000)
    .subscribe( () =&gt; {
        this.toolbarsVisible = 'hidden';
    });
</code></pre>

<p>and</p>

<pre><code>this.documentClick$
    .do( () =&gt; {
        this.toolbarsVisible = 'visible';
    })
    .debounceTime(3000)
    .subscribe( () =&gt; {
        this.toolbarsVisible = 'hidden';
    });
</code></pre>

<p>What would be the ""most correct"" way of doing this? I thought using a Subject would be best, but I couldn't get <code>Observable.fromEvent()</code> into the Subject. </p>

<p>(I guess the question I really want to ask is: how do I create a Subject from an Observable?) </p>
","343159","","","","","2016-11-28 13:23:17","debounceTime() and waiting for events","<javascript><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40847072","2","","40843003","2016-11-28 14:48:04","","0","","<p>I think that I have managed to solve this by using the <code>controlled()</code> rxjs operator:</p>

<pre><code>var queuedImages = 0;

var imageSource = Rx.Observable.range(1, 25)
  .map(index =&gt; ""image_"" + index)
  .controlled();

imageSource
  .map(image =&gt; loadImage(image))
  .merge(2)
  .do((image) =&gt; {
    queuedImages++;
    console.log(`Images waiting for processing: ${queuedImages}`);
  })
  .map(image =&gt; processImage(image))
  .merge(2)
  .do( () =&gt; {
    queuedImages--;
    console.log(`Images waiting for processing: ${queuedImages}`);

    if(queuedImages &lt; 4){
      console.log(`requesting more image loads`);
      imageSource.request(4-queuedImages);
    }
  })
  .subscribe( 
    (item) =&gt; {}, null, 
    () =&gt; console.log(`All Complete`) );

imageSource.request(4);
</code></pre>

<p>Initially 4 images are requested. These are loaded from disc and then processed. As each image is loaded and then processed the number of images in memory are kept track of using the <code>queuedImages</code> variable. When this number drops below 4 more images are requested.</p>

<p>A jsbin of this can be seen here:</p>

<p><a href=""https://jsbin.com/webaleduka/11/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/webaleduka/11/edit?js,console</a></p>

<p>This method means that there are never more than 6 or so images in the cache and ensures that there are always enough images in the cache waiting to be uploaded.</p>
","151770","","","","","2016-11-28 14:48:04","","","","0","","","","CC BY-SA 3.0"
"40848030","1","40852322","","2016-11-28 15:33:23","","3","1996","<p>in RxJS I'd like to take some special action once an Observer subscribes to an Observable and when he unsubscribes. I can of course overwrite the <code>subscribe()</code> and <code>unsubscribe()</code> methods, but that seems crud.
Isn't there a way during creation of the observable to supply callbacks that get called whenever someone subscribes/unsubscribes?
BR,
Daniel</p>
","1092599","","310726","","2016-11-28 19:28:45","2016-11-28 19:48:45","Action on subscribe() and unsubscribe()","<javascript><rxjs><observable><rxjs5><subject>","1","0","1","","","CC BY-SA 3.0"
"40852322","2","","40848030","2016-11-28 19:48:45","","4","","<p>This is what <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/observable.md#disposing-observable-executions"" rel=""nofollow noreferrer""><code>Observable.create</code></a> is for. You can create your own observable with specified attach/detach handlers, and can even wrap existing observables with just 2 additional lines of code.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const obs = Rx.Observable.create(observer =&gt; {
  console.log('attach');
  // If you want to wrap another observable, call this:
  // const subs = other.subscribe(observer);
  return () =&gt; {
    // subs.unsubscribe();
    console.log('detach');
  };
});

console.log('subscribe subscription1');
const subscribtion1 = obs.subscribe(() =&gt; {});
console.log('subscribe subscription2');
const subscribtion2 = obs.subscribe(() =&gt; {});
setTimeout(() =&gt; {
  console.log('subscribtion1.dispose()');
  subscribtion1.unsubscribe();
}, 500);
setTimeout(() =&gt; {
  console.log('subscribtion2.dispose()');
  subscribtion2.unsubscribe();
}, 1000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.0-rc.4/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","5108418","","","","","2016-11-28 19:48:45","","","","1","","","","CC BY-SA 3.0"
"40860884","2","","40400979","2016-11-29 08:19:59","","0","","<p>If someone interested it can be done via introducing intermediate stream, through which events <code>start loading</code> and <code>end loading</code> are passing. For more details refer to this <a href=""https://stackoverflow.com/questions/40636035/postpone-observable-when-other-one-fired-in-rxjs/40822369#40822369"">question</a></p>
","1010664","","-1","","2017-05-23 12:00:05","2016-11-29 08:19:59","","","","0","","","","CC BY-SA 3.0"
"40861494","1","40885304","","2016-11-29 08:56:43","","49","28606","<p>What is the best practice to unsubscribe within a Angular2 service from a http subscription?</p>

<p>Currently I do this but I'm not sure if this will be the best way.</p>

<pre><code>import { Injectable } from ""@angular/core"";
import { Http } from ""@angular/http"";

import { Subject } from ""rxjs/Subject"";
import { ISubscription } from ""rxjs/Subscription"";

@Injectable()
export class SearchService {
    private _searchSource = new Subject&lt;any&gt;();

    public search$ = this._searchSource.asObservable();

    constructor(private _http: Http) {}

    public search(value: string) {
        let sub: ISubscription = this._http.get(""/api/search?value="" + value)
            .map(response =&gt; &lt;any&gt;response.json())
            .do(data =&gt; this._searchSource.next(data))
            .finally(() =&gt; sub.unsubscribe()).subscribe();
    }

}
</code></pre>
","4340667","","","","","2021-02-26 04:21:47","Angular2: Unsubscribe from http observable in Service","<angular><rxjs5><unsubscribe>","4","4","13","","","CC BY-SA 3.0"
"40869778","1","40884536","","2016-11-29 15:36:53","","2","339","<p>I have a subscription which has asynchronous step - api call. While api call is in progress I want to show loading animation. It can be easily <a href=""https://jsfiddle.net/WiseBird/jdq52cxd/"" rel=""nofollow noreferrer"">done</a> when stream created with access to the UI:</p>

<pre><code>Rx.Observable
    .combineLatest(page$, sorting$)
    .switchMap(function(args) {
        var page = args[0];
        var sorting = args[1];

        $('.overlay').show();

        return loadData(page, sorting);
    })
    .subscribe(function(data) {
        renderData(data);
        $('.overlay').hide();
    });
</code></pre>

<p>But when I move stream management code to the <a href=""https://jsfiddle.net/WiseBird/jdq52cxd/1/"" rel=""nofollow noreferrer"">service</a> (e.g. for code reuse) the ability to track asynchronous operation is lost and I can't show loading animation.</p>

<p>Any ideas how it can be done? Return two stream from the service?</p>

<p>Thanks in advance.</p>
","1010664","","","","","2017-05-17 08:17:57","Tracking asynchronous operation in RxJs","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"40881903","1","","","2016-11-30 06:42:49","","2","132","<p>Hy all,
whats the best way to chaining RXJS5 results, like promises?</p>

<pre><code>interface MyObj{
  name : string
  url: string
  html: any // async
}

// promise chaining, pretty simple
getMyObjWithPromise()
  .then(myObj=&gt;{

   // promise, we get back html from myObj.url async
   return getMyObjHtmlWithPromise(myObj)
  })
  .then(myObj=&gt;{

   // done, here we have myObj with html
  })
</code></pre>

<p>Similar with RXJS5? 
We need share myObj across the streams, and modify obj props asynchronously...</p>
","7229191","","","","","2016-11-30 10:33:29","RXJS5 chaining like Promises","<javascript><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40884536","2","","40869778","2016-11-30 09:25:39","","2","","<p>Why not create a stream which contains multiple 'events' - <code>started</code> and <code>finished</code>, something like this:</p>

<pre><code>function loadDataWithStartEvent($page, sorting$) {
  return Rx.Observable
    .combineLatest(page$, sorting$)
    .flatMap(args =&gt; {
      var page = args[0];
      var sorting = args[1];

      return Rx.Observable.just({ event : 'started' })
        .concat(
          // given that loadData returns an Observable&lt;data&gt; which only emits data one time
          loadData(pageSortingTuple.page, pageSortingTuple.sorting))
            .map(data =&gt; ({ event: 'finished', data: data}))
        );
    });    
}
</code></pre>

<p>Now you subscribe as follows:</p>

<pre><code>loadDataWithStartEvent(page$, sorting$)
  .doOnNext(evt =&gt; {
    if(evt.type == 'started') {
      $('overlay').show();
    } else {
      $('overlay').hide();
    }
  })
  .filter(evt =&gt; evt.type === 'finished')
  .map(evt =&gt; evt.data);
  .subscribe(data =&gt; renderData(data));
</code></pre>
","106909","","","","","2016-11-30 09:25:39","","","","0","","","","CC BY-SA 3.0"
"40885304","2","","40861494","2016-11-30 10:00:40","","127","","<p>A Service in Angular is a singleton. This means that the service will exist for the entire lifespan of your application.</p>

<p>The reason that you need to unsubscribe from an observable, is to avoid memory leaks. When do you get memory leaks? If something has been garbage collected while it was still subscribed to an observable, event listener, socket, ...</p>

<p>Since an Angular service never get's destroyed, unless your entire application get's destroyed, there is no real reason to unsubscribe from it. The observable will either complete or error or keep going as long as your application does. </p>

<p>Conclusion: Unsubscribing in a service is kind of pointless, since there is no chance of memory leaks.</p>
","1018598","","","","","2016-11-30 10:00:40","","","","7","","","","CC BY-SA 3.0"
"40896824","1","40897280","","2016-11-30 19:41:55","","2","1651","<p>If I had an object <em>car</em>:</p>

<pre><code>{
    make: ""Chevy"",
    model: ""Sonic""
    type: {
        id: 1,
        name: ""Tiny""
    }
}
</code></pre>

<p>And I wanted to manipulate the object to add a typeId property:</p>

<pre><code>{
    make: ""Chevy"",
    model: ""Sonic""
    type: {
        id: 1,
        name: ""Tiny""
    },
    typeId: 1
}
</code></pre>

<p>Which rxjs operator would you use, assuming you had an array of these objects? This is what I'm trying to avoid:</p>

<pre><code>someArray.map(item =&gt; ({
    make: item.make,
    model: item.model,
    type: item.type,
    typeId: item.type.id
}));
</code></pre>
","5899766","","","","","2016-11-30 20:10:44","Add a property with .map() in rxjs","<javascript><arrays><object><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"40897280","2","","40896824","2016-11-30 20:10:44","","3","","<p>To add a property in each object in the array, you could use <code>forEach</code> as you don't have to map the array</p>

<pre><code>someArray.forEach(o =&gt; o.typeId = o.type.id)
</code></pre>
","965051","","","","","2016-11-30 20:10:44","","","","0","","","","CC BY-SA 3.0"
"40928266","2","","39775577","2016-12-02 09:00:43","","0","","<p>This issue is discussed in detail <a href=""https://github.com/angular/angular/issues/9359"" rel=""nofollow noreferrer"">here</a> and the solution is to use your own loader such as (code credit <a href=""https://gist.github.com/nros/311962c6e0ffb67b4e6aada67e1821f0"" rel=""nofollow noreferrer"">nros</a></p>

<p>Apparently, it's going to be fixed in a future release I suspect this is being held back as rxjs is still in beta.</p>

<p><strong>rxjsLoader.js</strong></p>

<pre><code>// see: https://github.com/angular/angular/issues/9359
// in case all parts of RxJS are loaded with a single file (eg: Rx.js), Angular 2 may have
// difficulties using/requiring the various parts.
// this custom loader translates requests to these parts to the already loaded Rx entity.
//
// eg: Angular:
//      require('rxjs/observable/from')  --&gt;  Rx.Observable
//      require('rxjs/operator/concatMap')  --&gt;  Rx.Observable.prototype
//      require('rxjs/util/EmptyError')  --&gt;  Rx
//
// Angular will access 'rxjs/observable/from' as rxjs_observable_from.from
// so, the last part of the included module (eg: 'from') denotes the property name to access
// the required value.
SystemJS.amdDefine(SystemJS.baseURL + ""rxjsLoader.js"", [""rxjs""], function (Rx) {
    'use strict';

    // custom loader for RX.js to instantiate the correct value
    // see: https://github.com/ModuleLoader/es-module-loader/blob/v0.17.0/docs/loader-extensions.md
    return {
        fetch: function fetch(loadData) {
            return """"; // no fetch - ""Rx"" is already loaded!
        },

        translate: function translate(loadData) {
            return """";
        },

        instantiate: function instantiate(loadData) {

            // loadData.name contains the full URL
            var propertyName = loadData.name.replace(/^.*\/rxjs-parts\/(.*)$/i, ""$1"").replace(/\.js$/i, """");

            // if property name is not empty, evaluate and use it
            if (propertyName.length &gt; 0 &amp;&amp; !(/^\s*$/.test(propertyName))) {
                var parts = propertyName.split(""/""),
                    targetObject = Rx
                ;

                // Angular 2 expects the return value to be an object
                // and the last part of the name to be the property of that object

                for (var i=0; i &lt; parts.length-1; i++) {
                     var partName = parts[i],
                         upperCaseName = partName.charAt(0).toUpperCase() + partName.slice(1)
                     ;

                     // handle special case for ""operator/*""
                     if (partName === ""operator"") {
                         return Rx.Observable.prototype;

                     } else if (targetObject[partName] !== undefined) {
                         targetObject = targetObject[partName];

                     } else if (targetObject[upperCaseName] !== undefined) {
                         targetObject = targetObject[upperCaseName];

                     } else {
                         // skip name and try with next part name. eg: ""utils""
                         continue;
                     }
                }

                return targetObject;

            } else {
                // return the Rx as default
                return Rx;
            }
        }
    };
});
</code></pre>

<p><strong>systemjs-config-using-custom-rx-loader.js</strong></p>

<pre><code>SystemJS.config({

    baseURL: '/',

    map: {
        ""rxjs"": ""Rx.js""
    },
    paths: {
        ""Rx.js/*"": ""rxjs-parts/*""
    },
    packages: {
       ""rxjs-parts"": {
            meta: {
                ""*"": {
                    loader: ""rxjsLoader.js""
                }
            }
        }
    }
});
</code></pre>
","4477334","","4477334","","2016-12-02 16:36:08","2016-12-02 16:36:08","","","","0","","","","CC BY-SA 3.0"
"40936467","1","","","2016-12-02 16:09:45","","1","673","<p>i my angular 2 service i have this method : </p>

<pre><code>  notify(userID: string) {
   return Observable.interval(5000)
      .map(() =&gt; this.baseUrl + '/notification/GetUnseen?userId=' + userID)
      .switchMap(url =&gt; {
         this.datatService.set(url);
         return this.datatService.get();
    })
     .flatMap(response =&gt; response.json().slice())
     .distinct(function (x) { return x.id });
   }
</code></pre>

<p>How can i use the distinct operator with key selector in this cas ?
When i try to do it i have this error : Property 'id' does not exist on type '{}'.</p>

<p>UPDATE : </p>

<p>The final result i get with this method is : </p>

<pre><code>  {
  id:""f3055770-6e66-4936-8e9a-732b53121549""
  message:""Empty Notification for test ......""
  navigationLink:""/api/home""
  seen:false
  sendedOn:""2016-12-02T15:19:44.856Z""
  userId:null
  }
</code></pre>

<p>I would like to filter the result, so if i already have the notification i dont want to get in again</p>
","2125067","","2125067","","2016-12-02 16:50:44","2016-12-02 16:50:44","Rxjs Distinct operator with key selector in Angular 2 http?","<angular><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"40953055","1","40955606","","2016-12-03 22:12:38","","0","290","<p>I have a design document: 'accounts',and the view: 'accounts-view'</p>

<p>the view's content is:</p>

<pre><code>function (doc) {
  emit( doc._id, doc);
}
</code></pre>

<p>And my code in express is:</p>

<pre><code>db.view('accounts', 'accounts-view', function(err, body) {
    if (err) throw error;
    res.json(body.rows);
});
</code></pre>

<p>Result is:</p>

<pre><code>[
  {
    ""id"": ""8767d3474a0e80dd0ab7d0b0580065af"",
    ""key"": ""8767d3474a0e80dd0ab7d0b0580065af"",
    ""value"": {
      ""_id"": ""8767d3474a0e80dd0ab7d0b0580065af"",
      ""_rev"": ""1-37eb3e76e4715e9a4fc8930470cc4ca3"",
      ""type"": ""accounts"",
      ""lastname"": ""Kitchen"",
      ""firstname"": ""Peter""
    }
  },
  {
    ""id"": ""8767d3474a0e80dd0ab7d0b058006e3c"",
    ""key"": ""8767d3474a0e80dd0ab7d0b058006e3c"",
    ""value"": {
      ""_id"": ""8767d3474a0e80dd0ab7d0b058006e3c"",
      ""_rev"": ""1-bcab94bb253c83b4951a787c253896f5"",
      ""type"": ""accounts"",
      ""lastname"": ""Kolner"",
      ""firstname"": ""John""
    }
  }
]
</code></pre>

<p>How i can get just something like this: ( just printing all is inside value for every row)</p>

<pre><code>[
  {
     ""_id"": ""8767d3474a0e80dd0ab7d0b0580065af"",
      ""_rev"": ""1-37eb3e76e4715e9a4fc8930470cc4ca3"",
      ""type"": ""accounts"",
      ""lastname"": ""Kitchen"",
      ""firstname"": ""Peter""

  },
  {

      ""_id"": ""8767d3474a0e80dd0ab7d0b058006e3c"",
      ""_rev"": ""1-bcab94bb253c83b4951a787c253896f5"",
      ""type"": ""accounts"",
      ""lastname"": ""Kolner"",
      ""firstname"": ""John""

  }
]
</code></pre>

<p>UPDATE:</p>

<p>I've follow Domonique's suggestions ; and now I have a new view, that emit just the id (so i can save space on disk and retrive de doc with the parameter ""include_docs=true"" on the view):</p>

<pre><code>function(doc) {
  if (doc.type &amp;&amp; doc.type=='accounts') {
    emit( doc._id);
  }
}
</code></pre>

<p>and a new list:</p>

<pre><code>function(head, req) {
  provides('json', function() {
    var results = [];
    while (row = getRow()) {
      //results.push(row.value);
      results.push(row.doc);
    }
    send(JSON.stringify(results));
  });
}
</code></pre>

<p>Finally i get the records with:</p>

<pre><code>http://127.0.0.1:5984/crm/_design/crmapp/_list/accounts-list/accounts-view?include_docs=true
</code></pre>

<p>and the result is:</p>

<pre><code>[
  {
    ""_id"": ""8767d3474a0e80dd0ab7d0b0580065af"",
    ""_rev"": ""1-37eb3e76e4715e9a4fc8930470cc4ca3"",
    ""type"": ""accounts"",
    ""lastname"": ""Kitchen"",
    ""firstname"": ""Peter""
  },
  {
    ""_id"": ""8767d3474a0e80dd0ab7d0b058006e3c"",
    ""_rev"": ""1-bcab94bb253c83b4951a787c253896f5"",
    ""type"": ""accounts"",
    ""lastname"": ""Kolner"",
    ""firstname"": ""John""
  },
  {
    ""_id"": ""8767d3474a0e80dd0ab7d0b058008e9a"",
    ""_rev"": ""1-86078f00be82b97499a0f52488cefbbf"",
    ""lastname"": ""Tower"",
    ""firstname"": ""George"",
    ""type"": ""accounts""
  }
]
</code></pre>

<p>my app node express updated:</p>

<pre><code>db.viewWithList('crmapp', 'accounts-view','accounts-list', {""include_docs"":""true""} , function(err, body) {
    if (err) throw err;
    res.json(body);
});
</code></pre>

<p>with this list , I don't need more reduce it on express project, it's ok ?
How to udate my list or view to get by id ? it'not working just adding id on the url ; like this:</p>

<pre><code>http://127.0.0.1:5984/crm/_design/crmapp/_list/accounts-list/accounts-view?include_docs=true&amp;_id=8767d3474a0e80dd0ab7d0b058006e3c
</code></pre>

<p>I get all the records and not the only one by id</p>
","4543343","","4543343","","2016-12-04 10:49:22","2016-12-04 10:49:22","couchdb ; how get documents directly in first level of json, and not grouped inside value - viewWithList","<json><couchdb><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40955606","2","","40953055","2016-12-04 05:08:41","","1","","<p>To answer your question here, you should simply <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"" rel=""nofollow noreferrer"">map</a> the array and only include the <code>value</code> portion:</p>

<pre><code>db.view('accounts', 'accounts-view', function(err, body) {
  if (err) throw error;
  res.json(body.rows.map(function (row) {
    return row.value;
  }));
});
</code></pre>

<p>Since it's apparent you are new to CouchDB, I'll also give you some advice regarding views. First, the view you've created is actually just a duplicate of the system view <code>_all_docs</code>, so you should just use that instead rather than creating your own view. (especially since you've effectively created a duplicate on disk)</p>

<p>However, it is probably pretty likely that as you get further along in your application, you'll be using real views that partition documents differently depending on the query. As such, you should <em>not</em> emit your entire document (ie: <code>doc</code>) in your view function. By doing this, you are effectively duplicating that document on disk, since it will be represented in your database, as well as the view index.</p>

<p>The recommended starting point is to simply leave out the 2nd argument of your emit.</p>

<pre><code>function (doc) {
  emit(doc._id);
}
</code></pre>

<p>When you query the view, you can simply add <code>include_docs=true</code> to the URL and your view will look something like this:</p>

<pre><code>[
  {
    ""id"": ""8767d3474a0e80dd0ab7d0b0580065af"",
    ""key"": ""8767d3474a0e80dd0ab7d0b0580065af"",
    ""value"": null,
    ""doc"": {
      ""_id"": ""8767d3474a0e80dd0ab7d0b0580065af"",
      ""_rev"": ""1-37eb3e76e4715e9a4fc8930470cc4ca3"",
      ""type"": ""accounts"",
      ""lastname"": ""Kitchen"",
      ""firstname"": ""Peter""
    }
  }
  // ...
]
</code></pre>

<p>Then, you can retrieve the <code>doc</code> instead of <code>value</code> to achieve the same result much more efficiently.</p>
","188702","","","","","2016-12-04 05:08:41","","","","5","","","","CC BY-SA 3.0"
"40957330","1","40957978","","2016-12-04 09:47:19","","2","66","<p>I need to access the ""original"" value of stream.</p>

<p><strong>My use case:</strong></p>

<ol>
<li>Iterating list of URLs.</li>
<li>Request each URL.</li>
<li>handle the response, and at this point, I also need the URL from the first ""iteration"".</li>
</ol>

<p><strong>Sample code:</strong></p>

<pre class=""lang-js prettyprint-override""><code>const Rx = require('rxjs');
const request = require('request');

// my request method in Rx version
const req = Rx.Observable.bindNodeCallback(request);
const list = [/*list of URLs*/];

Rx.Observable.from(list)
    .flatMap(req) // eq to: .flatMap(url =&gt; req(url))
    .map(response =&gt; {
        // here I need the response object
        // and the URL I used to request it (the ""original"" value).
    });
</code></pre>

<p>Any ideas? :)</p>
","1318223","","","","","2016-12-04 11:11:51","Keep tracking ""original"" item in RxJs","<javascript><functional-programming><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"40957978","2","","40957330","2016-12-04 11:11:51","","2","","<p>FlatMap has an overload which takes the input and every produced value for you to map:</p>

<pre><code>.flatMap(
  url =&gt; doRequest(url),
  (url, res) =&gt; ({ url, res }) 
)
</code></pre>
","106909","","","","","2016-12-04 11:11:51","","","","0","","","","CC BY-SA 3.0"
"40958210","1","40958520","","2016-12-04 11:39:24","","2","134","<p>I am working on angular 2 project. I have to make <code>n</code> number of <code>http Requests</code>. But i need to wait to get the data from previous request to make next request.</p>

<p>How can I achieve this with <code>Observables</code>.</p>

<p>I am doing:</p>

<pre><code>_.forEach(data, (path) =&gt; {
        this.userService.getTreeNodes(path.id)
          .subscribe(
            data =&gt; {
              //do something
            }
          );
      });
</code></pre>

<p>So right now, three simulatneous requests are going.</p>
","3219157","","3219157","","2016-12-04 11:53:27","2016-12-05 18:43:34","Make synchronus http requests with Observables","<javascript><angular><rxjs><rxjs5>","2","4","1","","","CC BY-SA 3.0"
"40958520","2","","40958210","2016-12-04 12:16:52","","1","","<p><strong>flatMap</strong> - Operator is the keyword, which will help you to solve your problem.</p>

<p>flatMap is how we handle dependencies between observables. My sample is contrived, but I am returning a value from the first observable that is needed by the second observable to calculate a sum.</p>

<p>Like I said this example is contrived, but if we compare this to promises, flatMap is how we would create the equivalent of promise chains. The code can be seen below.</p>

<pre><code>let first = Observable.of(10);
first.flatMap((operand1) =&gt; {
  return Observable.of(operand1 + 10);
})
.subscribe(res =&gt; this.flatMappedStreams = {msg: '10 + 10 = ' + res});
</code></pre>

<p>Source from <a href=""http://www.syntaxsuccess.com/viewarticle/combining-multiple-rxjs-streams-in-angular-2.0"" rel=""nofollow noreferrer"">http://www.syntaxsuccess.com/viewarticle/combining-multiple-rxjs-streams-in-angular-2.0</a></p>
","6081820","","","","","2016-12-04 12:16:52","","","","1","","","","CC BY-SA 3.0"
"40966026","1","40969729","","2016-12-05 01:56:34","","3","707","<p>New to rxjs and angular2. How do I abort an http call and return an observable so I don't get an error on the subscription end? of course if I just return an object here, we get <code>.searchAlbum(...).subscribe is not a function</code></p>

<pre><code>public searchAlbum (term:string, queryObject?:any) {

    if( this.abortSearches){
      queryObject.body = null;
      return //what to return here? used to be deferred.resolve(queryObject);
    }

    ...

    return this.http.request( new Request( options ) )
        .map(res =&gt; this.extractData(res, queryObject) )
        .catch(this.handleError);
}
</code></pre>
","654434","","310726","","2016-12-05 08:10:39","2016-12-05 10:35:02","how to abort and ""resolve"" a subscription immediately in rxjs?","<angular><rxjs><observable><abort><rxjs5>","1","1","","","","CC BY-SA 3.0"
"40969729","2","","40966026","2016-12-05 08:08:59","","2","","<p>As far as I understand your situation you want to return an Observable even though the <code>this.abortSearches</code> is <code>true</code> and therefore you don't want to make any actual HTTP request. However, you have some other functionality tied to this method so you want it to always return an Observable.</p>

<p>You can return <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-empty"" rel=""nofollow noreferrer""><code>Observable.empty()</code></a> which is an Observable that emits no values an just signals complete.</p>
","310726","","310726","","2016-12-05 10:35:02","2016-12-05 10:35:02","","","","0","","","","CC BY-SA 3.0"
"40970751","1","40973357","","2016-12-05 09:16:32","","1","1246","<p>I have obeservables of these objects :     </p>

<pre><code>  {
        id : ""f3055770-6e66-4936-8e9a-732b53121549""
        message:""Empty Notification for test ......""
        navigationLink:""/fusion/home""
        seen:false 
        sendedOn:""2016-12-02T15:19:44.856Z""
        userId :null
      }
</code></pre>

<p>I would like to not receive duplicated object (based on ids) and i use this method to achieve it </p>

<pre><code> notify(userID: string) {
    return Observable.interval(5000)
        .map(() =&gt; this.baseUrl + '/notification/GetUnseen?userId=' + userID)
        .switchMap(url =&gt; {
            return Observable.from(this.datatService.get(url));
        })
        .flatMap(response =&gt; Observable.from(response.json().slice()))

}
</code></pre>

<p>When i add distinct(x => x.id) as last operator i have only one object instead of Four any help ?</p>

<p><strong>UPDATE :</strong></p>

<p>I call this method in the oninit() life cycle of my component, so that the method execute every 5 second to get notification, i use distict this way : </p>

<pre><code> notify(userID: string) {
    return Observable.interval(5000)
        .map(() =&gt; this.baseUrl + '/notification/GetUnseen?userId=' + userID)
        .switchMap(url =&gt; {
            return Observable.from(this.datatService.get(url));
        })
        .flatMap(response =&gt; Observable.from(response.json().slice()))
        .distinct(x =&gt; x.id);
}
</code></pre>

<p><strong>UPDATE 2</strong></p>

<p>Serveur raw response : </p>

<pre><code>""[{""userId"":null,""sendedOn"":""2016-12-02T15:19:44.856Z"",""message"":""Empty Notification for test ......"",""navigationLink"":""/fusion/home"",""seen"":false,""id"":""f3055770-6e66-4936-8e9a-732b53121549""},{""userId"":null,""sendedOn"":""2016-12-02T15:19:45.146Z"",""message"":""Empty Notification for test ......"",""navigationLink"":""/fusion/home"",""seen"":false,""id"":""ce172122-11d9-4054-a3e4-594c8c910a7d""},{""userId"":null,""sendedOn"":""2016-12-02T15:19:45.146Z"",""message"":""Empty Notification for test ......"",""navigationLink"":""/fusion/home"",""seen"":false,""id"":""66e32c45-f544-4ce6-901c-e5ac64904954""},{""userId"":null,""sendedOn"":""2016-12-02T15:19:45.147Z"",""message"":""Empty Notification for test ......"",""navigationLink"":""/fusion/home"",""seen"":false,""id"":""4c2322cb-526c-490e-8a86-f1e9ced1c34f""}]""
</code></pre>
","2125067","","2125067","","2016-12-05 10:26:47","2016-12-05 12:42:33","Angular 2 Rxjs : Apply distinct on objects","<angular><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"40971495","1","40971925","","2016-12-05 09:55:57","","2","1911","<p>Is there an operator in RxJS that works like <code>filter()</code> but accepts a predicate that allows returning an Observable? So when the Observable returned by the predicate emits an event <code>filter()</code> decides whether event from the original source should be discarded or not.</p>
","617900","","","","","2019-06-17 04:20:41","Return Observable from RxJS filter() predicate","<filter><rxjs><reactive-programming><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"40971805","1","40972050","","2016-12-05 10:13:03","","0","138","<p>In this bit of code:</p>

<pre><code>Rx.Observable.range(0,8)
    .doOnCompleted(() =&gt; console.log(""range complete""))
    .take(1)
    .subscribe(
        item =&gt; console.log(`Item completed: ${item}`),
        error =&gt; console.log(`Error: ${error}`),
        () =&gt; console.log(`all complete`)
    );
</code></pre>

<p><a href=""https://jsbin.com/jacoyedesa/edit?js,console"" rel=""nofollow noreferrer"">JSBin</a></p>

<p>I get the output:</p>

<pre><code>""Item completed: 0""
""all complete""
</code></pre>

<p>with no <code>range complete</code></p>

<p>Why is this? Surely the <code>range()</code> observable will still complete? It seems strange that this doesn't fire at all.</p>
","151770","","310726","","2016-12-05 10:34:25","2016-12-05 10:34:25","Rxjs doOnCompleted() not firing before a take()","<javascript><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40971925","2","","40971495","2016-12-05 10:21:05","","1","","<p>If I understand you correctly I'd do it like the following:</p>

<pre><code>const Observable = Rx.Observable;
const Subject = Rx.Subject;

let subject = new Subject();

source = Observable.from([1,2,3,4])
  .flatMap(val =&gt; subject
    .withLatestFrom(Observable.of(val), (_, val) =&gt; val)
    .filter(val =&gt; val % 2 == 0)
  );

source.subscribe(val =&gt; console.log(val));

subject.next(null);
setTimeout(() =&gt; {
  subject.next(null);
}, 1000);
</code></pre>

<p>I wrapped each value with another Observable and <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-withLatestFrom"" rel=""nofollow noreferrer""><code>withLatestFrom</code></a> operator that emits only when its source emits. In my case the source is <code>subject</code> so I have full control over it. Then there's <code>filter()</code> that can filter whatever you want.</p>

<p>Although, I wonder if there's any easier solution...</p>

<p>This prints only two values and after 1s another two because I called <code>subject.next(null);</code> inside the <code>setTimeout</code> callback:</p>

<pre><code>2
4
2
4
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/gasumiz/10/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/gasumiz/10/edit?js,console</a></p>
","310726","","","","","2016-12-05 10:21:05","","","","1","","","","CC BY-SA 3.0"
"40972050","2","","40971805","2016-12-05 10:28:06","","1","","<p>This is correct. Observable <code>Observable.range(0,8)</code> starts counting from <code>0</code>, that's why you got <code>""Item completed: 0""</code>.</p>

<p>Then <code>take(1)</code> operator passes only one value and sends complete signal which causes unsubscription. I think this is where it happens: <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L119"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L119</a> and <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L143"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L143</a></p>

<p>That's why <code>range()</code> never emits all its values. Also <code>RangeObservable</code> is considered as ""Cold"" Observable so it won't emit values until there's at least one subscriber.</p>
","310726","","","","","2016-12-05 10:28:06","","","","0","","","","CC BY-SA 3.0"
"40973357","2","","40970751","2016-12-05 11:35:06","","1","","<p>I found the solution for the distinct ! </p>

<p>In fact, the function passed to disctinct can take 2 parameters (precedentValue, actualValue) so you can resolve this issue like this : </p>

<pre><code>....
....
.distinct(function (x, y) { return x.id === y.id; });
</code></pre>

<p>It return a boolean on each iteration (is x.id = y.id ? => true or false...).</p>

<p>**UPDATE **</p>

<p>My mistake is that i was looking for the rxjs 4.0 documentation, and my project is on rxjs 5 .</p>
","2125067","","2125067","","2016-12-05 12:42:33","2016-12-05 12:42:33","","","","0","","","","CC BY-SA 3.0"
"40976344","2","","40378344","2016-12-05 14:17:38","","2","","<p>If you want the final stream to be populated only when addUsers$ fires with latest from could be a solution:</p>

<p><a href=""https://i.stack.imgur.com/HXziv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HXziv.png"" alt=""enter image description here""></a></p>

<p>So, in your case addUsers$ could be the first stream. 
You can try out the following code:</p>

<pre><code> let firstObservable$ = Observable.from([1, 2, 3, 4])
    .zip(Observable.interval(50), (a, b) =&gt; {
      return a;
    });

  let secondObservable$ = Observable.from([5, 6])
    .zip(
      Observable.interval(70), (a, b) =&gt; {
        return a;
      });

  firstObservable$
    .withLatestFrom(secondObservable$, (f, s) =&gt; ({ a: f, b: s }))
    .subscribe(x =&gt; {
      console.log('result: ', x);
    });
</code></pre>

<p>The first observable emits every 50 ms a value from the array.
The second observable every 75 ms. </p>

<p>The values printed are {a: 2, b: 5} {a: 3, b: 6} {a: 4, b: 6}</p>

<p><em>Because 1 was emitted before 5 we lose the pair (1,5)!</em></p>

<p>I am not clear but missing a pair from addUsers$ if the other stream has not emitted may be non-desired behavior for you.
You could overcome that if you start the second stream with an initial value and then filter out any results you don't want.</p>
","3757195","","","","","2016-12-05 14:17:38","","","","0","","","","CC BY-SA 3.0"
"40984053","1","40984359","","2016-12-05 21:54:24","","0","1574","<p>Please, how can I fix this code ?</p>

<pre><code>Observable.fromEvent(this.getNativeElement(this.term), 'keyup')
    .debounceTime(500)
    .map(ev =&gt; ev.key)
    .scan((acc, one) =&gt; acc + one)
    .subscribe(term =&gt; console.log(term));
</code></pre>

<p>I get the error Property 'key' does not exist on type '{}' </p>

<p>UPDATE</p>

<p>As in the comment of @jb-nizet ( thx so much :) )
I worked it out with</p>

<pre><code>Observable.fromEvent&lt;KeyboardEvent&gt;(this.getNativeElement(this.term), 'keyup')
</code></pre>
","356380","","356380","","2016-12-05 22:17:46","2016-12-05 22:17:46","Angular2 Observable fromEvent keyup map Property 'key' does not exist on type '{}'","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"40984359","2","","40984053","2016-12-05 22:17:29","","1","","<p>Use </p>

<pre><code>map(ev =&gt; ev['key']) 
</code></pre>

<p>Or tell TypeScript that your initial Observable is an <code>Observable&lt;KeyboardEvent&gt;</code></p>

<pre><code>const obs: Observable&lt;KeyboardEvent&gt; = Observable.fromEvent(this.getNativeElement(this.term), 'keyup');
obs.debounceTime()...
</code></pre>
","571407","","","","","2016-12-05 22:17:29","","","","0","","","","CC BY-SA 3.0"
"40992711","1","41146245","","2016-12-06 10:09:06","","1","148","<p>Here a quite complex sample:</p>

<p>Main:</p>

<pre><code>this.runInstructionAndGetResult().subscribe({
      next: val =&gt; console.log(`NEXT VALUE: ${val}`),
      error: val =&gt; console.log(`ERROR VALUE: ${val}`),
      complete: val =&gt; console.log(`COMPLETE`)
    });
</code></pre>

<p>Observables:</p>

<pre><code>public runInstructionAndGetResult(): Observable&lt;string&gt; {
    return this.runAnInstruction()
        .flatMap((data) =&gt; {
            console.info(""flatMap of runAnInstruction:"", data);
            return this.getInstructionExecutionStatusInPolling()
                .filter(data =&gt; data != ""Polling"")
                .take(1)
                .flatMap((data) =&gt; {
                    console.info(""flatMap of getInstructionExecutionStatusInPolling:"", data);
                    return this.getInstructionResult();
                }).map((data) =&gt; {
                    console.info(""Map of getInstructionResult:"", data);
                    return data;
                });
        });
  }

  public runAnInstruction(): Observable&lt;string&gt; {
    return Observable.of(""StartRun"");
  }

  public getInstructionResult(): Observable&lt;string&gt; {
    return Observable.of(""FinalResult"");
  }

  public getInstructionExecutionStatusInPolling(): Observable&lt;string&gt; {
    return Observable.interval(1000)
        .concatMap(data =&gt; {
            return this.getInstructionExecutionStatus();
        });
  }

  public getInstructionExecutionStatus(): Observable&lt;string&gt; {
    return Observable.of(""Polling"", ""Terminate"");
  }
</code></pre>

<p>Here plunk:
<a href=""https://plnkr.co/edit/c1cahMtVARQnLgnHWlEe?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/c1cahMtVARQnLgnHWlEe?p=preview</a></p>

<p>Main problem is that i just would like to be notify about ""evolution"" of inner stream outside.</p>

<p><strong>Right now we have ""next"" event on main only when all inner flatMap are completed.</strong> </p>

<p><strong>How to get notify?</strong> How can i emit explicit values to main stream for example during polling?</p>

<p>Thanks.</p>
","4556732","","310726","","2016-12-06 12:52:49","2016-12-14 15:26:19","Notify from inner flatMap","<rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"40997977","1","","","2016-12-06 14:41:21","","1","797","<p>I want to manually subscribe to an event emitted by a directive, which, by design, should be available to multiple components of my application. At the moment the structure looks like this:</p>

<pre><code>AppComponent
  Draggable.Directive (uses an attribute of a DOM element to control the behaviour)

  (and then, via routing)
  Parent1 Component
     Child1 Component
     Child2 Component
</code></pre>

<p><strong>app.module</strong> looks like this:</p>

<pre><code>@NgModule({
  imports:      [ BrowserModule, HttpModule, JsonpModule, RouterModule.forRoot(appRoutes) ],
  declarations: [ AppComponent, FooComponent, BarComponent, ParentComponent, DraggableDirective ],
  bootstrap:    [ AppComponent ]
})
</code></pre>

<p>Later in the development, another Parent component will be listening to draggable directive and implement its own logic. </p>

<p>None of the children component knows (or should care) about Draggable Directive doing anything to it. The parent component should. So, in <strong>parent component</strong>:</p>

<pre><code>import { Component, OnInit, ViewChild } from '@angular/core';
import { DraggableDirective } from './draggable.directive';
import { FooComponent } from './foo.component';
import { BarComponent } from './bar.component';

@Component({
  selector: 'parent-view',
  templateUrl: './parent.component.html',
  providers: [DraggableDirective],
  moduleId: module.id
})

export class ParentComponent implements OnInit {
  @ViewChild('foo') fooC:FooComponent;
  @ViewChild('bar') barC:BarComponent;

  constructor(private draggable:DraggableDirective){
    draggable.droppedOn.subscribe(event =&gt; {
      console.log('listening', event);
    })
  }

  ngOnInit(): void {
   // updated
   // child view components
   this.fooC.fooInit();
  }
</code></pre>

<p>And here is the <strong>directive</strong>, using Subject and not EventEmitter, as recommended elsewhere:</p>

<pre><code>import { Directive, ElementRef, Renderer, HostListener, AfterViewInit } from '@angular/core';
import {Subject} from 'rxjs/Rx';

@Directive({
    selector: '[draggable], [data-draggable]'
})

export class DraggableDirective implements AfterViewInit {

    public droppedOn = new Subject();

    //... at some point this method is envoked
    couldDrop():void {

        if ( this.dElem ) {
            let _attr = this.dElem.dataset.indexed;
            console.log('emitting', _attr);
            this.droppedOn.next(_attr);

        }

    }
}
</code></pre>

<p>I get console logging ""emitting"" with the correct values. I never get ""listening"" from the parent component in the console. What am I doing wrong here?</p>
","542191","","310726","","2016-12-07 10:32:15","2016-12-07 10:32:15","Angular2: rxjs Subject in Angular2 child-parent component interaction","<angular><typescript><rxjs><rxjs5><subject-observer>","1","0","","","","CC BY-SA 3.0"
"41000043","1","41000769","","2016-12-06 16:19:54","","2","943","<p>I have an RXJS subject which, when I emit to it (with next), makes an HTTP call and timesout after 5 secs. I've turned the backend off so that it ALWAYS timesout. The timeout causes the subscribes error func to be called. Perfect.</p>

<p>However, when I emit to the subject a second time, i see that the subject has 0 observers. The timeout error undesirably removes all current observers to the RXJS subject. However, I do not want this behaviour. I want all observers to remain subscribed.</p>

<p>How do I fix this?</p>

<p>The important line of code is ...</p>

<pre><code>console.log(this.getDocumentsSubject.observers.length);
</code></pre>

<p>Which returns 1 when called the 1st time.</p>

<p>BUT Which problematically returns 0 when called the 2nd time, after a timeout.</p>

<p>Full code below.</p>

<pre><code>// RXJS SUBJECT AND ASSOCIATED OBSERVABLE

private getDocumentsSubject = new Subject&lt;ElasticFilteredQuery&gt;();
public getDocuments$ = this.getDocumentsSubject.asObservable().flatMap((elasticFilteredQuery: ElasticFilteredQuery) =&gt; {

let query = elasticFilteredQuery.toString();

// noinspection UnnecessaryLocalVariableJS
let restStream = this.http.post(BASE_URL + '_search', query, this.options)
  .do(() =&gt; {
    console.log('firing post');
  })
  .timeout(Config.http.timeout, new Error('timeout'))
  .map((response: any) =&gt; {

    return {
      documents: response.json().hits.hits.map((hit: any) =&gt; {
        return this.createDocumentResult(hit);
      }),
      numDocuments: response.json().hits.total,
      elasticFilteredQuery
    };
  });

return restStream;
}).publish().refCount();



// EMIT TO RXJS SUBJECT - this is being called at the correct times

public getDocuments(elasticFilteredQuery: ElasticFilteredQuery) {
  this.getDocumentsSubject.next(elasticFilteredQuery);
  console.log('watch number of observables', this.getDocumentsSubject.observers.length); // Outputs 1 initially but 0 after a timeout
}


// SUBSCRIPTION

this.esQueryService.getDocuments$.subscribe((response: any) =&gt; {
    console.log('XXXXX NEXT');
    ...
  }, (err: any) =&gt; {
    console.log('XXXXX error');
    ...
  }, () =&gt; {
    console.log('XXXXX completed');
  }
);
</code></pre>
","1205871","","","","","2016-12-06 17:38:49","Remain subscribed to an RXJS subject on HTTP timeout","<angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41000769","2","","41000043","2016-12-06 16:56:58","","2","","<p>This answer is solely based on the assumption, that you want to use <code>getDocuments$</code> as a perpetual stream, that emits new data, whenever a a new query <em>comes in</em>. (If this is not the case, then the answer might not help you)</p>

<p>However this will not work like this, because whenever an Error is emitted on a stream, the Stream is essentially <em>dead</em>. (also see <a href=""https://stackoverflow.com/questions/40716115/infinite-loop-when-catching-error-from-behaviorsubject-subscribed-by-async-pipe/40823122#40823122"">this</a> answer)</p>

<p>This is a basic issue in your rxjs-architecture: Errors are supposed to be thrown on one-time-processes (like a rest-call), however data-streams (like <code>documents$</code>) are usually there to ensure that any eventual errors have already been handled, and whatever is emitted (<code>next'ed</code>) on the perpetual stream is reliable &amp; valid data.</p>

<p>So my suggestion would be to use a <code>.catch()</code> to handle the error gracefully, and simple skip the emission of the documents of this call.</p>

<hr>

<p>Slightly off-topic and maybe not relevant:</p>

<p>In any case it is a very unusual case to have a hard timeout for a rest-call, if you want to save server-power, then I'd suggest handling this on the server-side. Another very common case is, that you might only want to accept responses until the next query is triggered to prevent <em>older, slower</em> queries from showing after a new one was rendered, if this is the case, then you could use a simple <code>.takeUntil(this.getDocumentSubject)</code>:</p>

<pre><code>this.http.post(BASE_URL + '_search', query, this.options)
  .takeUntil(this.getDocumentSubject)
  .do(...
</code></pre>

<p>As an alternative you could use <code>switchMap</code> instead of the <code>flatMap</code></p>
","1518765","","-1","","2017-05-23 10:31:06","2016-12-06 17:02:01","","","","6","","","","CC BY-SA 3.0"
"41001115","1","41001892","","2016-12-06 17:13:56","","1","1251","<p>Using <code>RxJS 5</code>, is this possible?  </p>

<pre><code>var source = new Rx.Subject();

source.map((data) =&gt; {console.log('map1'); return data;})
    .subscribe((data) =&gt; {
        console.log('subscribe1', data);
        if(someCondition) {
            source.stop(); //????????
        }
    });

source.map((data) =&gt; {console.log('map2'); return data;})
    .subscribe((data) =&gt; {
        console.log('subscribe2', data);
    });
</code></pre>

<p>So, when I call <code>source.next(""Hello World"");</code> only the first subscriber will be notified. Of course this will fail in <code>source.stop()</code> because the <code>stop</code> function does not exist but it is just to elaborate my question. </p>

<p>Exist a way to do this, like <code>event.stopPropagation</code> do?</p>
","418638","","","","","2016-12-06 18:00:54","Is it possible to stop a Rx.Subject from emitting within a subscriber like event.stopPropagation?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41001892","2","","41001115","2016-12-06 18:00:54","","2","","<p>It depends on what do you expect by stopping propagation. You can call <code>source.complete()</code> which will stop the Subject and it will never emit anything any more.</p>

<p>See demo: <a href=""https://jsbin.com/geyucuc/3/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/geyucuc/3/edit?js,console</a></p>

<p>However, if you want to be able to work on ""per item basis"" you can't the structure you have right now because each value from <code>source</code> is emitted to both its subscribers by the Subject.</p>

<p>You don't have chain where the value goes like <code>source</code> => <code>subscribe1</code> => <code>subscribe2</code>.</p>

<p>Right now you have <code>source</code> => <code>subscribe1</code> and then <code>source</code> => <code>subscribe2</code>.</p>

<p>So you can make it a chain like this for example:</p>

<pre><code>var source = new Rx.Subject();

source
    .map(item =&gt; { // wrap this
        return { value: item, stopped: false };
    })
    // your logic
    .map((data) =&gt; {
        console.log('map1', data.value);
        // do whatever here
        if (data.value == 2) {
          data.stopped = true;
        }
        return data;
    })
    .filter(item =&gt; !item.stopped) // this is your stopPropagation()
    .map((data) =&gt; {
        // do whatever here
        console.log('map2', data.value);
        return data;
    })
    .subscribe((data) =&gt; {
        // do nothing here, just construct the chain.
    });

source.next(1);
source.next(2);
</code></pre>

<p>Which prints the following:</p>

<pre><code>map1 1
map2 1
map1 2
</code></pre>
","310726","","","","","2016-12-06 18:00:54","","","","4","","","","CC BY-SA 3.0"
"41004901","1","41028095","","2016-12-06 21:05:51","","0","617","<p>My goal is to concat the characters
typed in a input like this</p>

<pre><code>&lt;input #term (keyup)=""search()""&gt;
</code></pre>

<p>so I tried with</p>

<pre><code>const obs$: Observable&lt;KeyboardEvent&gt; = Observable.fromEvent(this.getNativeElement(this.term), 'keyup');
    obs$
    .debounceTime(500)
    .map(ev =&gt; ev.key)
    .distinctUntilChanged()
    .scan((acc, one) =&gt; acc + one)
    .do(x =&gt; console.log(x))
    .subscribe(term =&gt; this.search(term));
</code></pre>

<p>and it's all good until you don't use backspace
just an example to catch the point</p>

<pre><code>a
app.component.ts:49 av
app.component.ts:49 avf
app.component.ts:49 avfd
app.component.ts:49 avfdBackspace
app.component.ts:49 avfdBackspaced
app.component.ts:49 avfdBackspaceds
app.component.ts:49 avfdBackspacedsw
app.component.ts:49 avfdBackspacedswControl
</code></pre>

<p>so what I can use without to get the right input ?</p>

<p>UPDATE</p>

<p>I could do like</p>

<pre><code>term$ = new Subject&lt;string&gt;();
(input)=term$.next($event.target.value)
</code></pre>

<p>but I'd like to do it with fromEvent</p>

<p>UPDATE2 (see the reply of @meligy)</p>

<pre><code>Observable.fromEvent&lt;HTMLInputElement&gt;(this.getNativeElement(this.term), 'keyup')
    .debounceTime(500)
    .map(ev =&gt; ev.target.value)
    .distinctUntilChanged()
    .do(termDebug =&gt; console.log(termDebug))
    .switchMap(term =&gt; this.service.search(term))
    .subscribe(result =&gt; this.items = result);
</code></pre>
","356380","","356380","","2016-12-07 22:41:56","2016-12-07 22:41:56","Angular2 Rxjs keyup how to concat characters","<angular><rxjs5>","1","3","","","","CC BY-SA 3.0"
"41005674","1","41014380","","2016-12-06 21:57:12","","4","6034","<p>I'm trying to use <code>retryWhen</code> in HTTP calls.</p>

<p>It works perfectly when try to use like this:</p>

<pre><code>return this.http.get(`${environment.apiUrl}/track/${this.user.instance._id}/${this.currentPlayer.playlist.id}/next?s=${this.playerCounter}`, options)
      .timeout(500, new TimeoutError(`Timeout trying to get next track. [instanceId=${this.user.instance._id}]`))
      .retryWhen(attempts =&gt; {
        return Observable.range(1, 3).zip(attempts, i =&gt; i).flatMap(i =&gt; 3 === i ? Observable.throw(attempts) : Observable.timer(i * 1000));
      })
</code></pre>

<p>It makes a maximum of 3 tries if get a Timeout error.</p>

<p>But, always have a buuut, I want to make this more abstract to use on various use cases and for this, I have to check the type of the error.</p>

<p><strong>Only TechnicalErros will be retried.</strong></p>

<p>So I tried this without success.</p>

<pre><code>.retryWhen(attempts =&gt; {
    return attempts.flatMap(error =&gt; {
      if(error instanceof TechnicalError) {
        return Observable.range(1, 3).zip(attempts, i =&gt; i).flatMap(i =&gt; 3 === i ? Observable.throw(attempts) : Observable.timer(i * 1000));
      } else {
        Observable.throw(error);
      }
    });
  })
</code></pre>

<p>It stops at first try and does not execute the <code>Observable.timer()</code>, neither the <code>Observable.throw()</code>.</p>

<p>I have almost sure that the problem is about the first <code>flatMap</code>, I already tried to use <code>mergeMap</code>, without success.</p>

<p>Thanks in advance!</p>
","4978097","","310726","","2016-12-07 09:59:01","2017-10-30 11:11:06","Angular 2 Http RetryWhen","<angular><rxjs><observable><rxjs5><angular-http>","2","0","1","","","CC BY-SA 3.0"
"41006606","1","41013653","","2016-12-06 23:07:39","","1","258","<p>Trying to build something up but getting stuck and missing whatever the error is here. I want to track button clicks but get the value from the <code>#zip</code> input so thats why I chose <code>mapTo</code>. When I remove <code>mapTo</code> I can track clicks and change my statement  in the subscribe function to update the result div text with the contents of the <code>#zip</code> input (exactly as I am doing in <code>mapTo</code>) which confuses me because I think that shows the syntax is ok.</p>

<pre><code>   Rx.Observable.fromEvent(document.getElementById('btn'),'click')
     .mapTo($('#zip').val())
      .subscribe(function(zipCode){
         $('#result').text(zipCode);
      });
</code></pre>

<p><a href=""http://jsbin.com/wegaceyefe/edit?html,js,console,output"" rel=""nofollow noreferrer"">jsbin</a></p>
","112665","","310726","","2016-12-07 09:25:35","2016-12-07 09:25:35","What is wrong with my mapTo Statement","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41011049","1","","","2016-12-07 06:45:22","","2","281","<p>I have an observable that's expensive to create, so I've <code>shared</code> it. In certain cases, though, all of the subscribers unsubscribe and then immediately (or after a short delay) a new subscriber subscribes.</p>

<p>The actual observable is too complex to replicate here, but for the sake of argument:</p>

<pre><code>const heavyObservable = Rx.Observable.create((observer) =&gt; {
    console.log('I am expensive, avoid hitting this code');

    return Rx.Observable
            .interval(500) // these updates are cheap though!
            .subscribe(observer)
                .add(() =&gt; {
                    console.log('Cache has been destroyed, will have to be rebuild on next call');
                });
});
</code></pre>

<p>I don't want to hit the expensive code involved in creating this observable. I'd like to delay disconnection until after <em>n</em> ms. Is there a way to do this?</p>

<pre><code>const sharedObservable = heavyObservable
    .publish()
    // ideally I'm looking for a way to get refCount to wait for new 
    // subscribers for n ms before unsubscribing when refcount === 0
    .refCount(); 

// calling subscribe here invokes heavyObservable which can take a bit of time
const subscription1 = sharedObservable.subscribe();
// log: I am expensive, avoid hitting this code

// second call is ""free"" - the underlying observable is reused
const subscription2 = sharedObservable.subscribe();

subscription1.unsubscribe();
subscription2.unsubscribe();

// calling subscribe again here invokes heavyObservable over again
const subscription3 = sharedObservable.subscribe();
// log: I am expensive, avoid hitting this code
</code></pre>
","1330257","","1330257","","2016-12-09 07:43:26","2016-12-09 07:50:44","rxjs5: Delay unsubscription of a shared observable","<typescript><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41013653","2","","41006606","2016-12-07 09:24:35","","2","","<p>If I understand what you want to do, you're trying to update <code>$('#result')</code> with current value of <code>$('#zip')</code> at the time the event occurs.</p>

<p>Operator <code>mapTo()</code> takes a single value as argument. This value is then used instead of every value coming from its source. In effect this means that <code>.mapTo($('#zip').val())</code> is initialized <strong>just once</strong> when you're creating the chain of Observables (even before you subscribe to it).</p>

<p>If you want it to be always the actual value you'll need some operator that takes a callback as a parameter. For example just <code>map()</code>:</p>

<pre><code>Rx.Observable.fromEvent(document.getElementById('btn'), 'click')
  .map(function(val) {
    return $('#zip').val();
  })
  .subscribe(function(zipCode){
    $('#result').text(zipCode);
  });
</code></pre>

<p>Your updated demo: <a href=""http://jsbin.com/qepalo/1/edit?html,js,console,output"" rel=""nofollow noreferrer"">http://jsbin.com/qepalo/1/edit?html,js,console,output</a></p>
","310726","","","","","2016-12-07 09:24:35","","","","1","","","","CC BY-SA 3.0"
"41014380","2","","41005674","2016-12-07 09:57:49","","8","","<p>In RxJS 5 <code>flatMap()</code> is just alias to <code>mergeMap()</code> :).</p>

<p>The problem is in the way you use the callback for <code>retryWhen()</code> operator. It's called just once and then every time an error signal arrives it's pushed to the Observable returned from this callback.</p>

<p>In your second example you're returning Observable from <code>attempts.flatMap</code> and then subscribing to it again that callback with <code>.zip(attempts, i =&gt; i)</code>. But this <code>zip</code> operator is never called because it's called after the value has been already consumed by <code>attempts.flatMap</code>. Also this is why the <code>Observable.range(1, 3)</code> starts always from the beginning.</p>

<p>I know this looks confusing. Just be aware thet:</p>

<ul>
<li>the callback for <code>retryWhen()</code> is called just once.</li>
<li>the callback for <code>attempts.flatMap()</code> is called every time an error arrives.</li>
</ul>

<p>So you just need to restructure your code, for example like the following:</p>

<pre><code>var source = Observable.create(obs =&gt; {
        obs.next(1);
        obs.next(2);
        obs.error(new TechnicalError('error from source'));
    })
    .retryWhen(attempts =&gt; {
        console.log('retryWhen callback');
        let count = 0;

        return attempts.flatMap(error =&gt; {
            if (error instanceof TechnicalError) {
                console.log(error);
                return ++count &gt;= 3 ? Observable.throw(error) : Observable.timer(count * 1000);
            } else {
                return Observable.throw(error);
            }
        });
    })
    .subscribe(
        val =&gt; console.log(val),
        err =&gt; console.log('subscribe error', err),
        _ =&gt; console.log('complete')
    );
</code></pre>

<p>This prints to console:</p>

<pre><code>1
2
retryWhen callback
TechnicalError { msg: 'error from source' }
1
2
TechnicalError { msg: 'error from source' }
1
2
TechnicalError { msg: 'error from source' }
subscribe error TechnicalError { msg: 'error from source' }
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/hobeda/3/edit?js,console"" rel=""noreferrer"">https://jsbin.com/hobeda/3/edit?js,console</a></p>
","310726","","","","","2016-12-07 09:57:49","","","","1","","","","CC BY-SA 3.0"
"41015512","1","41015801","","2016-12-07 10:51:55","","4","718","<p><strong>Update</strong></p>

<p>After the solution was found I wrote a small helper <a href=""https://github.com/smnbbrv/ng2-rx-collector"" rel=""nofollow noreferrer"">ng2-rx-collector</a> based on the accepted answer to make it even easier to use. Hope it helps somebody facing the same problems again and again.</p>

<p><strong>Original question</strong></p>

<p>Assume we have a component with two subscriptions on hot observables. We subscribe to them in <code>ngOnInit</code> and unsubscribe in <code>ngOnDestroy</code> in order to avoid the memory leaks / unexpected behavior:</p>

<pre><code>public ngOnInit() {
  this.s1 = o1.subscribe(console.debug.bind(console));
  this.s2 = o2.subscribe(console.debug.bind(console));
}

public ngOnDestroy() {
  this.s1.unsubscribe();
  this.s2.unsubscribe();
}
</code></pre>

<p>I love Rx, but I literally want to kill myself every time I need to follow this:</p>

<ol>
<li>Create a private subscription property for each subscription</li>
<li>Assign this property to a subscription (this looks really ugly because the real logic goes to the right side)</li>
<li>Unsubscribe from each subscription on destroy</li>
</ol>

<p>Is there any way to improve this?</p>

<p>E.g. in RxSwift they have a <code>DisposeBag</code> in order to improve the process, translated to typescript would be:</p>

<pre><code>private let bag = DisposeBag();

...

o1.subscribe(...).addDisposableTo(bag);
</code></pre>

<p>And then only destroying it only once. Problem is that I cannot find any similar <code>Subscription</code> function.</p>

<p>Any ideas / hints would be warmly welcomed.</p>
","1990451","","1990451","","2016-12-07 20:01:54","2016-12-07 20:01:54","Angular & RX: improved subscription collection","<angular><typescript><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"41015801","2","","41015512","2016-12-07 11:05:15","","5","","<p>You can do this:</p>

<pre><code>private teardown$ = new Subject&lt;void&gt;();

public ngOnInit() {
    o1.takeUntil(this.teardown$).subscribe(console.debug.bind(console));
    o2.takeUntil(this.teardown$).subscribe(console.debug.bind(console));
}

public ngOnDestroy() {
   this.teardown$.next();
}
</code></pre>
","1374517","","","","","2016-12-07 11:05:15","","","","3","","","","CC BY-SA 3.0"
"41022235","1","41031425","","2016-12-07 16:13:29","","2","1254","<p>I am trying to get a better understanding of cleaning up after I create a custom Observable.  In order to avoid memory leaks you are suppose to clean up with a disposable function.  In this case I used a Rx method of timer rather than <code>setInterval</code> and I believe that when I call <code>observer.onCompleted()</code> that internally cleans up the timer and my disposable is useless.  Is my understanding of this process correct?    </p>

<pre><code>function countInterval(interval, times) {
  return Rx.Observable.create(function (observer) {  
    var timerId = Rx.Observable.timer(0, interval)
      .subscribe(count =&gt; {
        if (count&gt;=times) {
          console.log('')
          observer.onNext(true);
          // I believe this already cleans up internal
          // references to setTimeout but I am not sure
          observer.onCompleted();
        }
      });

    // creating a disposable
    return () =&gt; {
      console.log('dispose')
      timerId.dispose();
    }
  });
</code></pre>

<p>}</p>

<p>feel free to play with this example here:
<a href=""https://jsbin.com/vojiduzopo/edit?js,console,output"" rel=""nofollow noreferrer"">https://jsbin.com/vojiduzopo/edit?js,console,output</a>
There is also a version where I use <code>setInterval</code> with a call to 'clearInterval' as a disposable.  </p>
","3790927","","","","","2016-12-08 03:52:57","RxJS: how do you know what needs to be cleaned up when using Observable.create","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41024204","2","","39901168","2016-12-07 17:57:22","","1","","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>this._user.Current
  .switchMap(user =&gt; Observable.from(user.devices)) // after this line, you have an Observable&lt;string&gt;
  .mergeMap(device =&gt; this._device.info(device)) // each device will be mapped to another observable(or stream), and all the streams will be merged together
  .toArray() // wait for all the streams to complete and reduce all the results into an array.
  .subscribe(array =&gt; console.log(array));</code></pre>
</div>
</div>
</p>

<p>or go to the gitter room:
<a href=""https://gitter.im/Reactive-Extensions/RxJS"" rel=""nofollow noreferrer"">https://gitter.im/Reactive-Extensions/RxJS</a></p>
","3454273","","3454273","","2016-12-08 02:58:01","2016-12-08 02:58:01","","","","0","","","","CC BY-SA 3.0"
"41025242","1","41025494","","2016-12-07 18:57:51","","0","759","<p>I`m trying to test the catch function of a rxjs observer but catch never run.</p>

<p>test.js</p>

<pre><code>it.only('On fail restore password', () =&gt; {
    sandbox = sinon.stub(Observable.ajax, 'post').returns(new Error());
    store.dispatch(restorePasswordVi('prueba'));
    expect(store.getActions()).toInclude({ success: false, type: SET_RESTORE_PASSWORD_SUCCESS });
  });
</code></pre>

<p>Epic please see <a href=""https://redux-observable.js.org/"" rel=""nofollow noreferrer"">https://redux-observable.js.org/</a></p>

<pre><code>export function restorePasswordViEpic(action$: Observable&lt;Action&gt;, store: Store) {
  return action$
    .ofType(RESTORE_PASSWORD_VI)
    .switchMap(({ user }) =&gt; {
      store.dispatch(blockLoading(true));
      return Observable
       .ajax
       .post(`${config.host}/auth/restore-password`, { user })
         .map(() =&gt; setRestorePasswordSuccess(true))
         .catch(() =&gt; {
           return Observable.of(setMessage('Se ha producido un error por favor intente de nuevo.'));
         });
    });
}
</code></pre>
","3626118","","","","","2016-12-07 19:13:26","Stub catch on redux-observable epic","<rxjs><sinon><rxjs5><redux-observable><rxjs-dom>","1","0","","","","CC BY-SA 3.0"
"41025494","2","","41025242","2016-12-07 19:13:26","","3","","<p>Your stubbing of <code>Observable.ajax.post</code> needs to return an <code>Observable</code> that throws the error.</p>

<pre><code>.returns(Observable.throw(new Error()));
</code></pre>

<p>All together:</p>

<pre><code>it.only('On fail restore password', () =&gt; {
  sandbox = sinon.stub(Observable.ajax, 'post').returns(Observable.throw(new Error()));
  store.dispatch(restorePasswordVi('prueba'));
  expect(store.getActions()).toInclude({ success: false, type: SET_RESTORE_PASSWORD_SUCCESS });
});
</code></pre>

<p>Since your existing stub returns just an Error object itself (not an observable that throws an error) it should have caused an uncaught error to be thrown, something like:</p>

<pre><code>Uncaught TypeError: Observable.ajax.post(...).map is not a function
</code></pre>

<p>If you don't see any error like that when you run your test, you may have something swallowing errors silently somewhere, so something to look out for.</p>
","1770633","","","","","2016-12-07 19:13:26","","","","2","","","","CC BY-SA 3.0"
"41028095","2","","41004901","2016-12-07 21:55:51","","1","","<p>You still have access to <code>target</code> when using <code>fromEvent()</code>. You can just type <code>ev.target.value</code>.</p>
","146656","","","","","2016-12-07 21:55:51","","","","3","","","","CC BY-SA 3.0"
"41031425","2","","41022235","2016-12-08 03:46:18","","3","","<p>Here's how it works.</p>

<ol>
<li>You pass a function to <code>Observable.create</code>. That function is called whenever the observable that you are creating is subscribed to.</li>
<li>Your function receives a <code>Subscriber</code> that exposes <code>next</code>, <code>error</code>, and <code>complete</code>. Your job is to call those three functions in the proper order, building up what looks like a sequence of values, from the point of view of the downstream observer.</li>
<li>In order to do the proper calls on the <code>Subscriber</code> you received, you might acquire resources, such as subscriptions on more basic observables that you're working with. We'll call these upstream observables. (Remember: subscriptions require resources, specifically memory). Subscriptions that you make in the body of your create function are called inner subscriptions. </li>
<li>Your create function returns a function that will become your dispose method. It will be called when the observable that you created is disposed, either by its <code>complete()</code> method being called, its erroring out, or the subscriber manually calls dispose.</li>
</ol>

<p>Your understanding of this process is not correct. When you signal completion to your downstream observer, then things downstream of you will clean up, and then your dispose method will be called so that you can clean yourself up. You do have some cleanup, because the inner subscription that you made on a timer will not be cleaned up just because the downstreams are disposed. That timer is still ticking until you dispose it yourself. It doesn't know about anything downstream of it, because you are the one who's connecting it to downstream observers. Your code at the bottom that disposes the timer sub is necessary to avoid a leak.</p>
","86432","","86432","","2016-12-08 03:52:57","2016-12-08 03:52:57","","","","4","","","","CC BY-SA 3.0"
"41032177","1","41042560","","2016-12-08 05:10:09","","1","1030","<p>I have the following function that validates that rangeFrom is not superior to rangeTo and that the rangeFrom does not already exist in the list of ranges.</p>

<p>How can rewrite this using RxJS?</p>

<pre><code>const isTagAlreadyExist = (tags, currentTag) =&gt; _(tags)
    .filter(x =&gt; x.id !== currentTag.id)
    .some(x =&gt; _.inRange(currentTag.rangeTo, x.rangeFrom, x.rangeTo))
    .value();

const validateRangeFrom = (tags, currentTag) =&gt; {
    const errors = {};

    if (isNumeric(currentTag.rangeFrom)) {    
        if (!_.inRange(currentTag.rangeFrom, 0, currentTag.rangeTo)) {
            errors.rangeFrom = 'FROM_TAG_CANNOT_BE_GREATER_THAN_TO_TAG';
        } else if (isTagAlreadyExist(tags, currentTag)) {
            errors.rangeFrom ='TAG_ALREADY_EXISTS';
        }
    }

    return {
        errors
    };
};
</code></pre>
","235659","","","","","2016-12-08 15:46:34","Data validation using RxJS","<functional-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41042560","2","","41032177","2016-12-08 15:04:43","","2","","<p>The question is: what parts do you want to rewrite to rxjs? Those are two pure functions that run synchronously from what I can see, I do not really see much a usecase for rxjs here - of course you could always utilize your functions within an rxjs stream:</p>

<pre><code>const validateRangeFrom$ = (tags, currentTag) =&gt; {
    return Observable.of(currentTag)
        .map(tag =&gt; validateRangeFrom(tags, tag));
}

validateRangeFrom$(myTags, currentTag)
    .subscribe(errors =&gt; console.log(errors));
</code></pre>

<p>But as you can see, this does not make much sense if you simply wrap it inside a stream, the <em>essence</em> of useful reactive programming is, that everything is reactive, not just some small parts, so for your example, you should start with having <code>tags$</code> and <code>currentTag$</code> as observables - let's assume that you have that, then you could do something like:</p>

<pre><code>const tags$: Observable&lt;ITag[]&gt;...     // is set somewhere, and emits a new array whenever it is changed
const currentTag$: Observable&lt;ITag&gt;... // is set somewhere and emits the tag whenever a new currentTag is set

const validateRangeFrom$ = Observable
    .combineLatest(tags$, currentTag$, (tags, tag) =&gt; ({tags, tag}))
    .map(({tags, tag}) =&gt; validateRangeFrom(tags, tag));

validateRangeFrom$.subscribe(errors =&gt; console.log(errors));
</code></pre>

<p>This will automatically trigger the validation for you whenever a new tags-array is emitted or a new currentTag is selected/set - but again: your validation-method is kept the same - as even in reactive programming you have to do validation and logic-operations at some point, the reactive part usually just concerns the flow of the data (see: <code>tags$</code> and <code>currentTag$</code>)</p>
","1518765","","1518765","","2016-12-08 15:46:34","2016-12-08 15:46:34","","","","1","","","","CC BY-SA 3.0"
"41043355","1","41056550","","2016-12-08 15:45:01","","0","340","<p>In the following plunk when you click on the Select Market an Observable is populated with an array of data.  The first item is highlighted in yellow because it has a property set to selected.  When focus is on the input box you can arrow down in the list.  The problem is the BehaviorSubject is firing and grabbing the list of data from the server each time.  How can I modify the selected property without searchTerms BehaviorSubject firing each time?  the method searchInputArrowKeyPressed in the market-search.component.ts file is where the arrow keys are being handled.</p>

<pre><code>public searchInputArrowKeyPressed(event): void {
    this.markets = this.markets
        .map((markets: Market[]) =&gt; {
            for(let market of markets) {
                if(market.selected) {
                    if(event === 'down' &amp;&amp; markets.indexOf(market) &lt; markets.length) {
                        markets[markets.indexOf(market) + 1].selected = true;
                    }
                    if(event === 'up' &amp;&amp; markets.indexOf(market) &gt; 0) {
                        markets[markets.indexOf(market) - 1].selected = true;
                    }
                    market.selected = false;
                    return markets;
                }
            }
        });
}
</code></pre>

<p><a href=""https://plnkr.co/edit/TBYb5QBau9Vmz8PqQpCl?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/TBYb5QBau9Vmz8PqQpCl?p=preview</a></p>

<p>Thank you in advance for any and all help!</p>
","349274","","","","","2016-12-09 08:55:23","Modifying Observable in Angular2 Causes BehaviorSubject to Fire","<angular><observable><rxjs5><behaviorsubject>","1","4","1","","","CC BY-SA 3.0"
"41056550","2","","41043355","2016-12-09 08:55:23","","2","","<p>I agree with @n00dl3, reassigning the stream looks unnatural. I've modified your plunker so that every event (data, search, up/down and enter) has it's own stream. E.g.:</p>

<pre><code>public searchInputArrowKeyPressed(event): void {
    this.upDownEvents.next(event);
}
</code></pre>

<p>Modification to the data is done through pushing updated array in data stream.</p>

<pre><code>    this.upDownEvents
      .withLatestFrom(this.markets)
      .subscribe(([event, markets]) =&gt; {
          for(let market of markets) {
              if(market.selected) {
                  // change selected

                  this.markets.next(markets);
                  return;
              }
          }
      });
</code></pre>

<p>Please, look <a href=""https://plnkr.co/edit/eacd5nZ5IoFWN69OYBtI?p=preview"" rel=""nofollow noreferrer"">here</a> </p>
","1010664","","","","","2016-12-09 08:55:23","","","","0","","","","CC BY-SA 3.0"
"41074085","1","41074474","","2016-12-10 09:36:03","","2","461","<p>I'm subscribing to a <strong>BehaviorSubject</strong> <code>routes$</code> that emits an array of directions</p>

<p>e.g. <code>['left', 'top', 'left']</code></p>

<p>Then I want to log each element of this array with 200ms delay, now after all element have been logged, I want to log <code>route finished</code>.</p>

<p>I tried the complete event <code>()=&gt;{}</code> and <code>finally()</code> operator but they both don't fire since <code>routes$</code> is still alive and might emits new directions.</p>

<pre><code>/** Stream recent directions */
this.route$.switchMap(() =&gt; {
  return Observable
    .interval(200)
    .timeInterval()
    .take(this.route$.getValue().length)
}).subscribe(
  (v) =&gt; {
    if (v.value === this.route$.getValue().length) return;
    let i = v.value;
    this.moveStep(this.route$.getValue()[i]);
  }
);
</code></pre>

<p>Currently I'm using this workaround </p>

<pre><code>.subscribe(
  (v) =&gt; {
    if (v.value === this.route$.getValue().length) return;
    let i = v.value;
    this.moveStep(this.route$.getValue()[i]);

    /** Check if it is the last iteration */
    if(i + 1 === this.route$.getValue().length){
      console.log('route finished');
      this.state = PlayerState.Idle;
    }
  }
);
</code></pre>

<p>Is there a native way to achieve this in observable?</p>
","1015648","","1015648","","2016-12-10 10:45:06","2016-12-10 10:58:30","Observable iteration complete event","<javascript><typescript><rxjs><observable><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"41074474","2","","41074085","2016-12-10 10:25:53","","3","","<p>If I understand correctly what you're trying to do you want to emit a value when the array passed to the BehaviorSubject has been completely iterated and you want to get just the last value.</p>

<p>Try to avoid using <code>.getValue()</code> directly from inside the Observable chain because the content of <code>.getValue()</code> is something you should be working with in the chain already.</p>

<pre><code>var routes$ = new BehaviorSubject(['default']);

routes$.switchMap((arr) =&gt; {
    return Observable.interval(200)
        .take(arr.length)
        .map(i =&gt; arr[i])
        .timeInterval()
        .do(null, null, () =&gt; console.log('Complete'));
}).subscribe(value =&gt; {
    console.log(value);
});

routes$.next(['left', 'top', 'left']);

setTimeout(() =&gt; {
    routes$.next(['top', 'right', 'down']);
}, 1000);
</code></pre>

<p>This prints to console:</p>

<pre><code>TimeInterval { value: 'left', interval: 208 }
TimeInterval { value: 'top', interval: 241 }
TimeInterval { value: 'left', interval: 207 }
Complete
TimeInterval { value: 'top', interval: 204 }
TimeInterval { value: 'right', interval: 200 }
TimeInterval { value: 'down', interval: 205 }
Complete
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/muxasa/5/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/muxasa/5/edit?js,console</a></p>

<p>Notice that the <code>['default']</code> is never reemitted because <code>switchMap()</code> receives a new array when calling <code>routes$.next(['left', 'top', 'left']);</code></p>
","310726","","310726","","2016-12-10 10:58:30","2016-12-10 10:58:30","","","","4","","","","CC BY-SA 3.0"
"41077300","1","41082143","","2016-12-10 15:47:38","","9","6083","<p>I have a hot <code>Observable</code> fed by a socket. I can use the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/pausable.md"" rel=""nofollow noreferrer"">pausable</a> to pause the socket feed. But once I 'unpause' the observable, I need to display the last values that the socket could have sent while the subscription was paused. I don't want to keep track of the last values the socket sends manually. How could this be pausible? </p>

<p>From the example in the documentation, see comments below:</p>

<pre><code>var pauser = new Rx.Subject();
var source = Rx.Observable.fromEvent(document, 'mousemove').pausable(pauser);

var subscription = source.subscribe(
    function (x) {
        //somehow after pauser.onNext(true)...push the last socket value sent while this was paused...
        console.log('Next: ' + x.toString());
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    });

// To begin the flow
pauser.onNext(true); 

// To pause the flow at any point
pauser.onNext(false);  
</code></pre>
","2275792","","3345644","","2020-02-11 20:59:46","2020-02-11 20:59:46","Pause, upon resume give last paused value","<rxjs><rxjs5>","1","0","4","","","CC BY-SA 4.0"
"41082143","2","","41077300","2016-12-11 01:33:48","","8","","<p>You don't even need <code>pausable</code> to do this. (Note as well that you tagged RxJS5 but <code>pausable</code> only exists in <code>RxJS 4</code>). You simply need to convert your <code>pauser</code> into a higher order <code>Observable</code>:</p>

<pre><code>var source = Rx.Observable.fromEvent(document, 'mousemove')
  // Always preserves the last value sent from the source so that
  // new subscribers can receive it.
  .publishReplay(1);

pauser
  // Close old streams (also called flatMapLatest)
  .switchMap(active =&gt; 
    // If the stream is active return the source
    // Otherwise return an empty Observable.
    Rx.Observable.if(() =&gt; active, source, Rx.Observable.empty())
  )
  .subscribe(/**/)

//Make the stream go live
source.connect();
</code></pre>
","2521865","","","","","2016-12-11 01:33:48","","","","3","","","","CC BY-SA 3.0"
"41090268","1","41096738","","2016-12-11 19:34:42","","0","102","<p>This is what my data looks like:</p>

<pre><code>{
  ""Category"" : {
    ""-KVuXp30tdhR1CqmCb_X"" : {
      ""name"" : ""Category1"",
      ""parentCategoryId"" : """"
  },
    ""-KVuY0CjGePvUo2qVcGb"" : {
      ""name"" : ""Category2"",
      ""parentCategoryId"" : """"
  },
    ""-KW9U76wJg-4hgnMUvu2"" : {
      ""name"" : ""Category1sub1"",
      ""parentCategoryId"" : ""-KVuXp30tdhR1CqmCb_X""
  },
    ""-KYODOJXjqnRMkVSsIFs"" : {
      ""name"" : ""Category2Sub1"",
      ""parentCategoryId"" : ""-KVuY0CjGePvUo2qVcGb""
  },
    ""-KYOKdbX22UCeU2EZcYQ"" : {
      ""name"" : ""Category1Sub3"",
      ""parentCategoryId"" : ""-KVuXp30tdhR1CqmCb_X""
  },
    ""-KYOM3dV9pX0Isx-7V5C"" : {
      ""name"" : ""Category2Sub2"",
      ""parentCategoryId"" : ""-KVuY0CjGePvUo2qVcGb""
  }
 }
}
</code></pre>

<p>I want to list under main categories and sub categories. </p>

<ul>
<li>Category1</li>
<li>Category2</li>
<li>Category1 >> Category1sub1</li>
<li>Category2 >> Category2Sub1</li>
<li>Category1 >> Category1Sub3</li>
<li>Category2 >> Category2Sub2</li>
</ul>

<p>The sample code <a href=""https://plnkr.co/edit/zfilRg"" rel=""nofollow noreferrer"">here (plunker)</a>.</p>

<p>What am I doing wrong. How do i do it.</p>

<p>Thanks.</p>
","7205781","","","","","2016-12-12 08:24:06","Angularfire2 Observable concat not working","<angular><rxjs5><angularfire2>","1","0","","","","CC BY-SA 3.0"
"41096738","2","","41090268","2016-12-12 08:24:06","","1","","<p><code>AngularFire</code>'s list method returns Observabel that never ends so there is no point in using it in <code>concat</code>. If you want to get only first value you should use <code>take</code>.</p>

<p>There is no <code>db</code> property on your service, hence</p>

<pre><code>this.db.object
</code></pre>

<p>will throw an error (you didn't see an error because that code hadn't been executed).</p>

<p>Look at this <a href=""https://plnkr.co/edit/Kc23OhyV86RvSneGL0XU?p=preview"" rel=""nofollow noreferrer"">plunker</a> and ask if something is not clear.</p>
","1010664","","","","","2016-12-12 08:24:06","","","","1","","","","CC BY-SA 3.0"
"41112618","1","41113451","","2016-12-13 01:58:38","","12","18607","<p>What's the difference between these two?</p>

<pre><code>return Observable.create(function(observer) {
    if (array)
        observer.next([]);
    else
        observer.next(null);
    observer.complete();
});
</code></pre>

<p>and </p>

<pre><code>return Observable.from( array ? [] : null );
</code></pre>

<p>I thought it could be the same but didn't work the same.</p>
","145989","","","","","2020-02-01 09:46:16","RxJS: Observable.create() vs. Observable.from()","<javascript><rxjs><observable><rxjs5>","4","0","1","","","CC BY-SA 3.0"
"41113034","1","41113214","","2016-12-13 02:54:35","","0","25","<p>I have the following attempt at a reducer</p>

<pre><code>import { ActionReducer, Action, Store } from '@ngrx/store';
import { Observable } from 'rxjs'
import { Name } from './name.model'

export const ADD_NAME = 'ADD_NAME';

export const name: ActionReducer&lt;any&gt; = ( state = new Name(), action: Action ) =&gt; {
  switch ( action.type ) {
    case ADD_NAME:
      return [ state, action.payload ];

    default:
      return state;
  }
};
</code></pre>

<p>I would like to store a Name instance in the Store. Currently the ADD_NAME returns an array. How can I store just a single instance instead of array</p>
","2258442","","","","","2016-12-13 03:19:04","Storing and instance instead of an array in rxjs5 Store","<angular><angular2-forms><rxjs5><reducers>","1","0","","","","CC BY-SA 3.0"
"41113074","1","41113241","","2016-12-13 03:00:15","","4","1532","<p>I'd like to use RxJS's <code>just</code>.<br>
What I need it for is <code>Observable.just(null)</code>, which can't be done with <code>Observable.from()</code>.</p>

<p>I'm trying </p>

<pre><code>import 'rxjs/add/operator/just';
</code></pre>

<p>But it's not present in where it should be - <code>node_modules/rxjs/add/operator</code>, so this fails to compile.</p>

<p>How can I add this operator? </p>
","145989","","","","","2016-12-13 03:23:16","RxJS: How to import Just","<javascript><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41113214","2","","41113034","2016-12-13 03:19:04","","0","","<p>You can write this with typescript 2.1+:</p>

<pre><code>case ADD_NAME:
  return { ...state, action.payload };
</code></pre>

<p>or</p>

<pre><code>case ADD_NAME:
  return Object.assign({}, state, action.payload);
</code></pre>
","1876949","","","","","2016-12-13 03:19:04","","","","1","","","","CC BY-SA 3.0"
"41113241","2","","41113074","2016-12-13 03:23:16","","11","","<p>That depends on the version of Rx.js:</p>

<ul>
<li><a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""noreferrer"">4.0</a> includes a <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/return.md"" rel=""noreferrer""><code>.just</code></a> method;</li>
<li><a href=""https://github.com/ReactiveX/rxjs"" rel=""noreferrer"">5.0</a> doesn't. Instead, use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-of"" rel=""noreferrer""><code>.of</code></a> method.</li>
</ul>

<p>Like this:</p>

<pre><code>Rx.Observable.of(null).forEach(x =&gt; console.log(x))
</code></pre>
","835591","","","","","2016-12-13 03:23:16","","","","0","","","","CC BY-SA 3.0"
"41113451","2","","41112618","2016-12-13 03:51:08","","18","","<p>The <code>create(...)</code> is a generic <code>Observable</code> factory method for creating an <code>Observable</code> in which you will explicitly dictate how values are passed to the <code>Subscriber</code></p>

<p>For instance, if you were to create a timer base <code>Observable</code> (don't it already exists as <code>Observable.timer</code>) you could do:</p>

<pre><code>   Observable.create(observer =&gt; {
     const timeoutId = setTimeout(() =&gt; {
       observer.next(0);
       observer.complete();
     }, 500);

     return () =&gt; clearTimeout(timeoutId);
   });
</code></pre>

<p>The <code>from(...)</code> is what I call a <em>conformance</em> operator in that it attempts to coerce a passed in data type into an <code>Observable</code> (make it conform). This means that it will accept a variety of types and convert them into <code>Observables</code>. These types include:</p>

<ul>
<li>Arrays</li>
<li>Promises</li>
<li>Generators</li>
<li>Observable-like things</li>
</ul>

<p>There are specific converters as well that you can find such as <code>fromArray</code> and <code>fromPromise</code> which specifically convert those types, but <code>from</code> more of a swiss-army knife of those methods</p>

<p>If you just need a single value you should be using <code>Observable.of</code> (the docs appear to be out of date, <code>just/return</code> was renamed to <code>of</code> in RxJS 5 and I don't think they are aliased anymore).</p>

<p>i.e.</p>

<pre><code>// Don't quote me on the import part
import 'rxjs/add/observable/of';

Observable.of(1, 2, 3, 4).subscribe();
</code></pre>
","2521865","","145989","","2018-03-12 18:30:23","2018-03-12 18:30:23","","","","0","","","","CC BY-SA 3.0"
"41121614","1","41121704","","2016-12-13 12:52:25","","0","680","<p>I am trying to find the cleanest solution to use <code>filter()</code> operator in order to filter my observables.</p>

<p>Here I am replicating the service call to get a <code>femaleList</code> separately </p>

<pre><code>export class MyComp implements OnInit {

    maleList: IContact[] = [];
    femaleList: IContact[] = [];    

    constructor(private _contactService: ContactService) { }
    ngOnInit() : void {
        this._contactService.getContacts()
         .filter(male =&gt; male.gender === 'M')
        subscribe(maleList =&gt; this.maleList = maleList);

        this._contactService.getContacts()
         .filter(female =&gt; female.gender === 'F')
        subscribe(femaleList =&gt; this.femaleList = femaleList);
     } }
</code></pre>

<p><strong>Contactlist</strong></p>

<pre><code> [{
      ""id"" : 1,
      ""name"" : ""Todd"",
      ""gender"" : ""M""
    }, {
      ""id"" : 2,
      ""name"" : ""Lillian"",
      ""gender"" : ""F""
    }]
</code></pre>

<p>Is there any option in RxJS operators with single observable to assign to two variables.</p>

<p>How can i filter the Contacts and assign it to <code>maleList</code> and <code>femaleList</code> using <strong>RxJS</strong> <code>filter()</code> operator.</p>

<p>Thanks in advance</p>
","4728339","","310726","","2016-12-13 13:13:59","2018-04-26 08:56:52","RxJS filter() operator","<angular><rxjs><angular2-services><rxjs5><rxjs-dom>","3","0","1","","","CC BY-SA 3.0"
"41121704","2","","41121614","2016-12-13 12:56:59","","2","","<p>You don't need a filter:</p>

<pre><code>this._contactService.getContacts()
  .subscribe(person =&gt; {
    if(person.gender === 'F'){
      this.femaleList.push(person);
    } else {
      this.maleList.push(person);
    }
</code></pre>
","242098","","","","","2016-12-13 12:56:59","","","","1","","","","CC BY-SA 3.0"
"41123476","1","41125537","","2016-12-13 14:25:26","","1","645","<p>I have the following code that dispatch 3 actions:</p>

<ul>
<li>deleteLineFailed</li>
<li>showConfirmationMessage</li>
<li>Wait 2s </li>
<li>hideConfirmationMessage</li>
</ul>

<p>For some reasons, the only way I was able to make it work is in the reverse order, what is it I'm doing wrong?</p>

<pre><code>const deleteLineEpic = (action$, store) =&gt;
action$.ofType(types.DELETE_LINE_REQUEST)
    .flatMap((action) =&gt; {
        return Observable.of(hideConfirmationMessage(action.line.productID))
                .delay(2000)
                .merge(
                    Observable.of(deleteLineFailure(action.line.productID)),
                    Observable.of(showConfirmationMessage(action.line.productID))
                );
        }
    });
</code></pre>
","235659","","","","","2016-12-13 16:13:11","RxJS Observables called in the reverse order","<redux><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"41125537","2","","41123476","2016-12-13 16:07:51","","2","","<p>I think the following happens:</p>

<pre><code>deleteLine        -----X------------
showConfirmation  -------Y----------
hideConfirmation  --------- 2s -----Z

merge             -----X-Y- 2s -----Z
</code></pre>

<p>All 3 streams get merged, and the one with the delay emits after two seconds while the other emit the action immediately.</p>

<p>So it might be better to do this:</p>

<pre><code>const deleteLineEpic = (action$, store) =&gt;
action$.ofType(types.DELETE_LINE_REQUEST)
    .flatMap((action) =&gt; {
        return Observable.merge(
            Observable.of(deleteLineFailure(action.line.productID),
            showConfirmationMessage(action.line.productID)),
            Observable.of(hideConfirmationMessage(action.line.productID))
                .delay(2000)
        )}
);
</code></pre>

<p>Here the actions in the first <code>Observable.of</code> get immediately emitted after each other, while hide actions is emitted later on.  </p>
","1353465","","1353465","","2016-12-13 16:13:11","2016-12-13 16:13:11","","","","0","","","","CC BY-SA 3.0"
"41127134","1","41128266","","2016-12-13 17:28:30","","0","350","<p>I'm rewriting a simple Angular2 view component to using Observables and the async pipe. It shows a list of results and there is a selected result which should be highlighted.</p>

<p>Before my component had the following properties:</p>

<pre><code>results: Result[] = [];
selectedResult: Result = null;
</code></pre>

<p>And the loop in the view looked something like this:</p>

<pre><code>&lt;div *ngFor=""let r of results"" [class.active]=""r === selectedResult"" /&gt;
</code></pre>

<p>Now I have the following view component with observables:</p>

<pre><code>@Component({
    moduleId: module.id,
    selector: 'results-view',
    templateUrl: 'results-view.component.html'
})
export class ResultsViewComponent implements OnInit {

    constructor(private resultService: ResultService,
        private route: ActivatedRoute) { }

    results: Observable&lt;Result[]&gt; = null;
    selectedResult: Observable&lt;Result&gt; = null;

    private selectRequests = new Subject&lt;string&gt;();

    ngOnInit(): void {
        let deviceId = this.route.snapshot.params['deviceId']

        this.results = this.resultService.getResults(deviceId);
        this.selectedResult = Observable.combineLatest(this.selectRequests.asObservable(), this.results, (sr, res) =&gt; {
            return res.filter(r =&gt; r.resultId == sr)[0];
        });      
    }

    selectResult(resultId: string): void {
        this.selectRequests.next(resultId);
    }
}
</code></pre>

<p>And the following view:</p>

<pre><code>&lt;table class=""table table-hover""&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Alert&lt;/th&gt;
            &lt;th&gt;Actions&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr *ngFor=""let r of (results | async)"" [class.active]=""r === selectedResult""&gt;
            &lt;td&gt;{{r.Name}}&lt;/td&gt;
            &lt;td&gt;
                &lt;a href=""javascript:void(0)"" (click)=""selectResult(r.resultId)""&gt;&lt;span class=""glyphicon glyphicon-search"" aria-hidden=""true""&gt;&lt;/span&gt;&lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>

<p>This is not working. I also tried the angular expression</p>

<pre><code>""r === (selectedResult | async)""
</code></pre>

<p>but it is not working either. The only thing that happened is that the <code>getResults</code> method was executed multiple times against the server.</p>

<p>What is the correct way of doing selection handling with observables?</p>
","487356","","","","","2016-12-13 19:43:38","Highlight selected item with Angular2 and RxJs","<angular><rxjs><rxjs5><angular2-observables>","2","1","","","","CC BY-SA 3.0"
"41128266","2","","41127134","2016-12-13 18:39:12","","0","","<p>This is how it works now:</p>

<p>In the view I'm not comparing object references anymore but the object's ids (strings). So the loop in the view looks like this:</p>

<pre><code>&lt;tr *ngFor=""let r of (results | async)"" [class.active]=""r?.resultId == (selectedResult | async)?.resultId""&gt;
</code></pre>

<p>This left me with the problem that for every row a new subscription is created which in turn caused a <code>getResult()</code> back to the server.</p>

<p>My first attempt was to modify my observable like this:</p>

<pre><code>this.results = this.resultService.getResults(deviceId).share();
</code></pre>

<p>Funnily this still left me with two calls back to the server (why???). But this one seems to work fine:</p>

<pre><code>this.results = this.resultService.getResults(deviceId).publishLast().refCount();
</code></pre>

<p>This solution was inspired by <a href=""http://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html"" rel=""nofollow noreferrer"">this</a> blog post.</p>
","487356","","","","","2016-12-13 18:39:12","","","","0","","","","CC BY-SA 3.0"
"41146245","2","","40992711","2016-12-14 15:26:19","","1","","<p>I found a solution to share.</p>

<p>Here plunker updated:</p>

<p><a href=""https://plnkr.co/edit/c1cahMtVARQnLgnHWlEe?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/c1cahMtVARQnLgnHWlEe?p=preview</a></p>

<p>Basically i create a simple observable using : <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/create.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/create.md</a></p>

<p>then i call programmatically next method and complete finally:</p>

<pre><code> public runInstructionAndGetResult(): Observable&lt;string&gt; {
    return Observable.create((ops)=&gt; {
      ops.next(1);
      this.runAnInstruction()
        .concatMap((data) =&gt; {
            ops.next(2);
            console.info(""flatMap of runAnInstruction:"", data);
            return this.getInstructionExecutionStatusInPolling()
                .filter(data =&gt; data != ""Polling"")
                .take(1)
                .concatMap((data) =&gt; {
                    ops.next(3);
                    console.info(""flatMap of getInstructionExecutionStatusInPolling:"", data);
                    return this.getInstructionResult();
                }).map((data) =&gt; {
                    console.info(""Map of getInstructionResult:"", data);
                    ops.next(4);
                    ops.complete();
                    return data;
                });
        }).subscribe();
        });
  }
</code></pre>
","4556732","","","","","2016-12-14 15:26:19","","","","0","","","","CC BY-SA 3.0"
"41174181","1","","","2016-12-15 22:14:20","","2","270","<p>I have the following <code>Rxjs</code> code</p>
<pre><code>  Observable.combineLatest(
        this.form.statusChanges,
        this.form.valueChanges,
        ( status, value ) =&gt; ({ status, value }) )
              .filter( ( { status } ) =&gt; status === 'VALID' )
              .debounceTime( 500 )
              .subscribe( ( { value } ) =&gt; createAddress( this._store, value ) )
</code></pre>
<p>I observed the following:</p>
<ol>
<li>No value is passed to the store until the values are valid.</li>
<li>Once the value is valid, the input of an invalid value passes to the store and after that no other passes.</li>
</ol>
<p>Why does the filter NOT filter the first invalid value after a valid Object?</p>
<h2>EDIT 1 | SOLVED</h2>
<h3>Place the filter immediately before the subscribe() function as shown below:</h3>
<pre><code>Observable.combineLatest(
    this.form.statusChanges,
    this.form.valueChanges,
    ( status, value ) =&gt; ({ status, value }) )
          .debounceTime( 500 )
          .filter( ( { status } ) =&gt; status === 'VALID' )
          .subscribe( ( { value } ) =&gt; createAddress( this._store, value ) )
</code></pre>
","2258442","","-1","","2020-06-20 09:12:55","2016-12-16 02:40:25","Failure of Observable.filter to prevent invalid value after a valid one","<angular><angular2-forms><rxjs5>","0","3","","","","CC BY-SA 3.0"
"41176489","1","41185413","","2016-12-16 02:42:44","","8","4782","<p>Before upgrading RxJS to <code>5.0.0-rc.0</code> I was using <code>.cache()</code> a lot to share a subscription in my Angular application. The great advantage in using this was that any new subscription would get the last published value.</p>

<p>The RxJS team decided to remove it, and now I find myself manually wiring a private <code>BehaviorSubject</code> or <code>ReplaySubject</code> and then calling <code>.asObservable()</code> all the time. This seems like a lot of boilerplate given the easy way we had to do this before.</p>

<p>Am I missing some easier way? I can't find the <code>.replay()</code> operator, and the <code>.share()</code> and <code>.publishReplay()</code> operators don't seem to do this either.</p>

<p>Thanks!</p>
","625581","","310726","","2016-12-16 13:23:18","2017-09-23 17:14:18","RxJS 5 and alternatives to the cache operator","<angularjs><angular><rxjs><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"41185413","2","","41176489","2016-12-16 13:23:08","","8","","<p>This is what I use to show off RxJS. The following example caches the latest mocked HTTP response for 1 second. It's based on RxJS multicasting via <code>publishReplay()</code> and <code>refCount()</code>.</p>

<pre><code>var counter = 1;
var updateTrigger = Observable.defer(() =&gt; mockDataFetch())
    .publishReplay(1, 1000)
    .refCount()
    .take(1);

function mockDataFetch() {
    return Observable.of(counter++)
        .delay(100);
}

function mockHttpCache() {
    return updateTrigger;
}

mockHttpCache().toPromise()
    .then(val =&gt; console.log(""Response from 0:"", val));

setTimeout(() =&gt; mockHttpCache().toPromise()
    .then(val =&gt; console.log(""Response from 200:"", val))
, 200);

setTimeout(() =&gt; mockHttpCache().toPromise()
    .then(val =&gt; console.log(""Response from 1200:"", val))
, 1200);

setTimeout(() =&gt; mockHttpCache().toPromise()
    .then(val =&gt; console.log(""Response from 1500:"", val))
, 1500);

setTimeout(() =&gt; mockHttpCache().toPromise()
    .then(val =&gt; console.log(""Response from 3500:"", val))
, 3500);
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/todude/3/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/todude/3/edit?js,console</a></p>

<p>This prints to console:</p>

<pre><code>Response 0: 1
Response 50: 1
Response 200: 1
Response 1200: 2
Response 1500: 2
Response 3500: 3
</code></pre>
","310726","","641914","","2017-09-23 17:14:18","2017-09-23 17:14:18","","","","2","","","","CC BY-SA 3.0"
"41192132","1","","","2016-12-16 20:40:20","","1","533","<p>I'm new to RxJS and so still learning how to use the library. The documentation for <code>concatMap</code> gives the following warning:</p>

<blockquote>
  <p>Warning: if source values arrive endlessly and faster than their
  corresponding inner Observables can complete, it will result in memory
  issues as inner Observables amass in an unbounded buffer waiting for
  their turn to be subscribed to.</p>
</blockquote>

<p>This is a problem for me because I have a memory intensive but fast concatMap feeding a slow concatMap. It's set up like this:</p>

<pre><code>let uploadObs = Observable.range(0, blockCount).concatMap(blockIndex =&gt; {
    // This part is fast and memory intensive. I'd like to use
    // a bounded buffer here or something similar to control
    // memory utilization

    let blockReaderObs = ...;
    // ... read a block from a large file object in blockReaderObs
    return blockReaderObs;
}).concatMap((blockData, index) =&gt; {
    // This part involves a POST so is much slower than reading a
    // file block
    let objFromBlockData = someTransformation(blockData);
    return this.http.post(someUrl, objFromBlockData)
        .map(transformResponse);
});
</code></pre>

<p>What is the right approach to dealing with this kind of problem in RxJS?</p>
","160015","","","","","2018-07-26 20:18:24","Memory management with RxJS Observable.concatMap?","<rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41193702","2","","40792748","2016-12-16 23:10:40","","0","","<p>I solved it like this:
I have an variable <code>let isEmpty=true;</code> and set it to false when I receive the first Object in the <code>Observable</code>:</p>

<pre><code>spots.subscribe(() =&gt; {
   this.empty = false;
   ...
});
</code></pre>
","1904790","","","","","2016-12-16 23:10:40","","","","0","","","","CC BY-SA 3.0"
"41197546","1","41197583","","2016-12-17 10:18:48","","24","56845","<p>I am new to Typescript. I want to select ids from observable</p>

<p>This is my observable</p>

<pre><code>let myObj = [{
  ""id"": 1,
  ""text"": ""Mary""
}, {
  ""id"": 2,
  ""text"": ""Nancy""
}, {
  ""id"": 3,
  ""text"": ""Paul""
}, {
  ""id"": 4,
  ""text"": ""Cheryl""
}, {
  ""id"": 5,
  ""text"": ""Frances""
}]
</code></pre>

<p>Expected Result :</p>

<pre><code>let selectedIds = [1,2,3,4,5];
</code></pre>

<p>Can I do this without creating an array and pushing the ids in a for loop. </p>
","4728339","","3001761","","2016-12-17 10:22:02","2016-12-17 13:40:41","Typescript Select Ids from object","<arrays><angular><typescript><rxjs><rxjs5>","2","3","3","2016-12-22 13:08:27","","CC BY-SA 3.0"
"41197583","2","","41197546","2016-12-17 10:23:20","","67","","<p>Use <code>Array#map</code> to map one array to another:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const myObj = [{""id"":1,""text"":""Mary""},{""id"":2,""text"":""Nancy""},{""id"":3,""text"":""Paul""},{""id"":4,""text"":""Cheryl""},{""id"":5,""text"":""Frances""}];

const selectedIds = myObj.map(({ id }) =&gt; id);

console.log(selectedIds);</code></pre>
</div>
</div>
</p>
","5157454","","","","","2016-12-17 10:23:20","","","","1","","","","CC BY-SA 3.0"
"41197720","1","41198015","","2016-12-17 10:41:50","","1","4562","<p>I want to make infinite loop with an interval variable using rxjs Observable 
so I'm trying to rewrite this function in rxjs</p>

<pre><code>takeAWalk(player){
    setTimeout(() =&gt; {

      console.log(""Player is walking..."");

      takeAWalk(player);
    }, getRandomDelayBetween(1000, 2500));
}
</code></pre>

<p>I tried</p>

<pre><code>Observable
  .timer(0, getRandomDelayBetween(1000, 2500))
  .take(10)
  .timeInterval()
  .subscribe(res=&gt;{
    console.log(""player is walking ..."");
  });
</code></pre>

<p>but the problem that this is finite to 10 and the interval is constant  (<code>getRandomDelayBetween</code> is only called once).</p>

<p>Which operators should I use to produce the same functionality of <code>takeAWalk</code> function?</p>
","1015648","","","","","2018-12-17 13:31:34","rxjs infinite loop with an interval variable","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41198015","2","","41197720","2016-12-17 11:19:43","","6","","<p>There are many ways to write this in rxjs, you could try something like this:</p>

<pre><code>Rx.Observable.of(null)
  .concatMap(() =&gt; Rx.Observable.timer(Math.random() * 1500))
  .do(() =&gt; console.log(""player is walking ...""))
  .repeat()  // optionally .repeat(10)
  .subscribe();
</code></pre>

<p>Check out the example live here: <a href=""http://jsbin.com/levakipunu/edit?js,console"" rel=""noreferrer"">http://jsbin.com/levakipunu/edit?js,console</a></p>
","1518765","","","","","2016-12-17 11:19:43","","","","0","","","","CC BY-SA 3.0"
"41218210","1","","","2016-12-19 08:06:31","","3","583","<p>I'm using Angular2 and Firebase via Angularfire2 to get some data from a Firebase Realtime Database (basically a large JSON object).</p>

<p>What I have is a poll system. Polls are in a 'Polls' node, poll responses are in a 'Poll-Responses' node. To link these together I use a 'Poll-Response-Links' node.</p>

<p>So basically, to get responses for a poll, I have to get all links and then get the responses from the links.</p>

<p>The below code works, but I feel as though it's terrible practice. Saying this, I have no idea how to do it correctly.</p>

<pre><code>this.teamPollsService.getPollLinkList(id).subscribe((linkList) =&gt; {
    this.responses = [];
    for (let link of linkList) {
        this.teamPollsService.getResponse(link['$key']).subscribe((response) =&gt; {
            this.responses.push(response);
        });
    }
});
</code></pre>

<p>I'm hoping someone could shed some light on the correct way to do this and the reasons behind it?</p>

<p>Any help would be greatly appreciated.</p>

<p>Thanks.</p>
","1480867","","310726","","2016-12-19 11:37:18","2016-12-19 11:37:18","What is the correct way to avoid using a nested observable subscription in a loop?","<angular><typescript><firebase><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41224749","1","41224786","","2016-12-19 14:27:32","","25","23348","<p>What is the best way to <code>sort</code> a list of items coming from an <code>Observable</code> and still be able to use the <code>async pipe</code>? (I read that making a custom sort pipe is not really efficient.) I want to avoid subscribing and keeping a local copy of data and thus just using async pipe...</p>

<pre><code>//can I use map here and filter items right in the observable and get rid of subscribe?

this.test$ = Observable.of(['one', 'two', 'three'])
    .subscribe((data) =&gt; {
        data.sort((a, b) =&gt; {
            return a &lt; b ? -1 : 1;
         });
        this.data = data;
     });
</code></pre>

<p>template:</p>

<pre><code>&lt;div *ngFor='let item of data'&gt;
&lt;!-- want to be able to use async pipe here --&gt;
</code></pre>
","2275792","","","","","2016-12-19 14:29:28","Angular 2 - Sort list from Observable","<angular><rxjs5>","1","0","6","","","CC BY-SA 3.0"
"41224786","2","","41224749","2016-12-19 14:29:28","","30","","<p>If you call <code>.subscribe()</code> you get a <code>Subscription</code>, the async pipe expects an <code>Observable</code>.</p>

<p>If you change it to</p>

<pre><code>this.test$ = Observable.of(['one', 'two', 'three'])
.map((data) =&gt; {
    data.sort((a, b) =&gt; {
        return a &lt; b ? -1 : 1;
     });
    return data;
 });
</code></pre>

<p>you can use the async pipe with <code>test$</code></p>
","217408","","","","","2016-12-19 14:29:28","","","","1","","","","CC BY-SA 3.0"
"41225446","1","41226036","","2016-12-19 15:02:51","","3","1077","<p>I want to emit array items over time (a one second interval between each emit) and when all items have been emitted, repeat over and over.</p>

<p>I know how to do this, but I want to know if there is something more succinct than ..</p>

<pre><code>const MY_ARRAY = ['one','two','three'];
const item$ = Rx.Observable.interval(1000).take(MY_ARRAY.length).repeat().map(x =&gt; MY_ARRAY[x]);
item$.subscribe(x =&gt; console.log(x));
</code></pre>

<p>thanks</p>

<p>output is ..</p>

<blockquote>
  <p>""one""</p>
  
  <p>""two""</p>
  
  <p>""three""</p>
  
  <p>""one""</p>
  
  <p>""two""</p>
  
  <p>""three""</p>
  
  <p>etc</p>
</blockquote>

<p>EDIT:</p>

<p>ATOW, the answers here are summarised as ..</p>

<pre><code>const ARR = ['one', 'two', 'three'];

// TAKE YOUR PICK THEY ALL DO THE SAME
const item$ = Rx.Observable.interval(1000).map(i =&gt; ARR[i % ARR.length]);
// const item$ = Rx.Observable.interval(1000).zip(ARR, (a, x) =&gt; x).repeat();
// const item$ = Rx.Observable.interval(1000).zip(ARR).repeat().map(x =&gt; x[1]);
// const item$ = Rx.Observable.interval(1000).take(ARR.length).repeat().map(i =&gt; ARR[i]);

item$.subscribe((x) =&gt; {
  console.log(x);
});
</code></pre>
","1205871","","1205871","","2016-12-19 16:11:27","2021-04-18 05:26:32","RxJS5 emit array items over time and repeat forever","<angular><rxjs><rxjs5>","4","0","2","","","CC BY-SA 3.0"
"41226036","2","","41225446","2016-12-19 15:31:40","","6","","<pre><code>Observable.interval(1000).map(i =&gt; MY_ARRAY[i % MY_ARRAY.length])
</code></pre>
","242098","","","","","2016-12-19 15:31:40","","","","6","","","","CC BY-SA 3.0"
"41231382","1","41231517","","2016-12-19 21:33:20","","0","184","<p>I have a list of objects returned from the server via an Observable. That list is displayed in the template with ngFor. I also have a dropdown to sort the list.</p>

<p>I have the sort working properly when the server returns the list but now I am trying to also sort the list when the comboBox is selected. </p>

<p>How can I sort the stream from the dropdown and the source and not have to use local variable to store the data? </p>

<p>Sample Code:</p>

<pre><code>let sortButton$ = new Subject();
let sortProp = 'myProperty';

this.handleSortButton(sortProp) {
    sortButton$.next(sortProp);
}

// how can I retain my Observable and sort the values from the server when 
// a) the values come back from server (works with below)
// b) the sort dropdown sends a new property value via the subject
this.test$ = Observable
                .of(['one', 'two', 'three'])
                .map((data) =&gt; _.sortBy(data,this.sortProp));
</code></pre>

<p>Template:</p>

<pre><code>&lt;div *ngFor='let item of test$'&gt;
</code></pre>
","2275792","","","","","2016-12-19 21:44:34","Angular 2 & RxJS - Sort from 2 sources","<angular><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41231517","2","","41231382","2016-12-19 21:44:34","","2","","<p>You can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""nofollow noreferrer""><code>combineLatest</code></a>:</p>

<pre class=""lang-ts prettyprint-override""><code>this.test$ = Observable
  .of(['one', 'two', 'three'])
  .combineLatest(this.sortButton$.startWith(this.sortProp))
  .map(([data, sort]) =&gt; _.sortBy(data,sort))
</code></pre>

<p>Don't forget to import it:</p>

<pre class=""lang-ts prettyprint-override""><code>import 'rxjs/add/observable/combineLatest';
import 'rxjs/add/operator/startWith';
</code></pre>
","1876949","","","","","2016-12-19 21:44:34","","","","0","","","","CC BY-SA 3.0"
"41232914","1","41233455","","2016-12-20 00:00:50","","0","378","<p>I am working in an NG2 app using TypeScript and want to create an observable around a call to Amazon AWS SDK.</p>

<pre><code>var foo =  Observable.create( (observer) =&gt; {
  this.s3.upload({
    Key: ""value""
  }, (err, data) =&gt; {
    if (err) {
      console.log(err)
      return
    }
    observer.next(data)
  });
})
</code></pre>

<p>Unfortunately, <code>this</code> is now bound to the Observable.  How should I approach this if I want <code>this</code> to remain bound to the parent class?</p>
","1295896","","","","","2016-12-20 01:09:58","Creating Observer in RxJS (TypeScript) 5.0 that does not bind to `this`","<typescript><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"41233455","2","","41232914","2016-12-20 01:09:58","","1","","<p>You can just wrap the observer function and bind your outside <code>this</code> to it:</p>

<pre><code>var foo = Observable.create((function(observer) {
  this.s3.upload({
    Key: ""value""
  }, (err, data) =&gt; {
    if (err) {
      console.log(err);
      return
    }
    observer.next(data)
  });
}).bind(this));
</code></pre>

<p>It's important to make sure the wrapped function is a classic function and not an arrow function, or <code>this</code> within the function will end up being the <code>window</code>.</p>
","3696076","","","","","2016-12-20 01:09:58","","","","0","","","","CC BY-SA 3.0"
"41237924","1","41249164","","2016-12-20 08:38:10","","-1","32","<p>I have the following connectable observable:</p>

<pre><code>//emit value every 1 second
const source = Rx.Observable.interval(1000);
const example = source
  //side effects will be executed once
  .do(() =&gt; console.log('Do Something!'))
  //do nothing until connect() is called
  .publish();

/*
  source will not emit values until connect() is called
  output: (after 5s) 
  ""Do Something!""
  ""Subscriber One: 0""
  ""Subscriber Two: 0""
  ""Do Something!""
  ""Subscriber One: 1""
  ""Subscriber Two: 1""
*/
const subscribe = example.subscribe(val =&gt; console.log(`Subscriber One: ${val}`));

//call connect after 5 seconds, causing source to begin emitting items
setTimeout(() =&gt; {
 example.connect(); 
},5000)

setTimeout(() =&gt; {
 subscribe.unsubscribe(); 
},7000)
</code></pre>

<p>Why the source observable is still emit an item, even I unsubscribe it?</p>
","1743843","","","","","2016-12-20 18:41:33","Why values still emitted","<javascript><typescript><rxjs5>","1","1","","","","CC BY-SA 3.0"
"41248567","1","41248733","","2016-12-20 18:00:22","","0","521","<p>We run our integration tests within Node, using enzyme's mount and jsdom to render the full app. For each test, we create a new store</p>

<pre><code>return createStore(
    reducer,
    stateShape,
    composeEnhancers(
        applyMiddleware(epicMiddleware, navMiddleware)
    )
);
</code></pre>

<p>Unfortunately, doing this for multiple tests I've noticed that each epic has been attached multiple times, so instead of one epic acting one an action 10 of the same one are! Is there a way I can run cleanup at the end of each test so that the epics are detached and no longer listening?</p>

<p>We're using redux, redux-observable, and enyzme+mocha to test. Thanks!</p>
","3882323","","","","","2021-10-06 21:50:56","Remove/disconnect epics from redux-observable","<node.js><redux><mocha.js><rxjs5><redux-observable>","2","0","","","","CC BY-SA 3.0"
"41248733","2","","41248567","2016-12-20 18:10:58","","1","","<p>Every time you create a new store, you'll need to create a new instance of the epicMiddleware that you give it.</p>

<p>Alternatively, there is <a href=""https://redux-observable.js.org/docs/api/EpicMiddleware.html#replaceEpic"" rel=""nofollow noreferrer""><code>epicMiddleware.replaceEpic(rootEpic)</code></a> which lets you replace the currently running root epic, but I'm not sure that will solve your problem in this case.</p>
","1770633","","","","","2016-12-20 18:10:58","","","","0","","","","CC BY-SA 3.0"
"41249164","2","","41237924","2016-12-20 18:41:33","","1","","<p><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/connect.md"" rel=""nofollow noreferrer""><code>.connect()</code></a> is basically a subscription as well, so in order to <em>stop</em> the stream, you have to <em>""disconnect""</em> it, like this e.g.:</p>

<pre><code>let connection;
setTimeout(() =&gt; {
 connection = example.connect(); 
},5000)

setTimeout(() =&gt; {
 connection.unsubscribe();
 subscribe.unsubscribe(); 
},7000)
</code></pre>
","1518765","","","","","2016-12-20 18:41:33","","","","0","","","","CC BY-SA 3.0"
"41251908","1","41257729","","2016-12-20 21:57:27","","3","1288","<p>Having a hard time with this. I'm new to working with RxJs Observables so I need some guidance.</p>

<p>I'm trying to build an Observable logging stream that does two things.</p>

<ol>
<li>Whenever a new line/value is written to the log file, push that new value to the stream.</li>
<li>Begin pre-populated with values from the log file.</li>
</ol>

<p>I've accomplished both of the above criteria. The challenge is now using it with an *ngFor. </p>

<p>*ngFor requires an array from an Observable so it can do comparison to add/remove (my best guess). But my observable returns only an array of the last item pushed through. </p>

<pre><code>//logviewer.page.ts constructor()
this.logs = Subject.create();
this.logs$ = this.logs.asObservable()
            .startWith(""logs\\error.log"")
            .flatMap((fileName: string) =&gt; {
                //start by reading the existing log files as a string
                return this.$localStorageService.readAsStringAsync(fileName);
            })
            .map((contents: string) =&gt; {
                //this part splits up the log file line-by-line into an log entry
                let logs = contents.split(/\r\n|\r|\n/).filter(n =&gt; n.length &gt; 0);
                logs.forEach((s, ix, parent) =&gt; {
                    let x = JSON.parse(s);
                    parent[ix] = { timestamp: new Date(parseFloat(x[0])), message: x[1] };
                })
                return logs; //an array of objects { timestamp, message }
            })
            //merge the existing application log stream
            //throughout the application we log errors, info, etc
            //if a new entry is made it will appear here
            .merge(this.$loggerService.applicationLog$.map((x) =&gt; {                    
                //return an array with one object { timestamp, message }
                return [{ timestamp: new Date(parseFloat(x[0])), message: x[1] }];
            }))
</code></pre>

<p>Now my template is very simple, for now.</p>

<pre><code>//logviewer.template.ts
&lt;div *ngFor=""let entry of logs$ | async""&gt;
    {{entry|json}}
&lt;/div&gt;
</code></pre>

<p>Now to test it, I have a button to add an entry</p>

<pre><code>//logviewer.page.ts
addEntry() {
    this.$loggerService.error(""this is a test"");
}

//LoggerService.service.ts
private applicationLog: ReplaySubject&lt;any[]&gt;;
get applicationLog$(): Observable&lt;any[]&gt; {
    return this.applicationLog.asObservable();
}

error(...args) {
    let data = [Date.now().toString()].concat(args.map&lt;string&gt;((n, ix) =&gt; { return toString(n); }));

    // ... write to file

    // fire the subject
    this.applicationLog.next(data);
}
</code></pre>

<p>Now when I click <code>addEntry</code>, the plumbing all works, and the value is fired through the observable sequence correctly. But my *ngFor only updates with a single value. It doesn't keep the history of all the previous log entries. Just the last array returned, which makes sense.</p>

<p>How do I make my observable sequence always return an array of all values. I can make it return one entry at a time, but I need to full history to satisfy *ngFor</p>

<p>I had a lack of understanding of *ngFor and the async pipe. I thought that it subscribe to the observable, and automatically add any new entries to the ngFor, but this isn't the case.</p>
","158958","","","","","2016-12-21 07:53:34","Configure an Observable to return all previous values as an array when a new value is pushed?","<angular><typescript><rxjs5><ngfor>","1","0","","","","CC BY-SA 3.0"
"41255718","1","41262155","","2016-12-21 05:26:43","","4","6384","<p>I have 3 observable arrays like below.</p>

<pre><code>persons = [
   {
      ""firstName"":""john"",
      ""lastName"":""public"",
      ""locationID"":""1"",
      ""departmentID"":""100""
   },
   {
      ""firstName"":""sam"",
      ""lastName"":""smith"",
      ""locationID"":""2"",
      ""departmentID"":""101""
   }
]

departments = [{""departmentID"": ""100"",
               ""name"": ""development""
               },
               {""departmentID"": ""101"",
                ""name"": ""sales""
               }]

locations = [{""locationID"": ""1"", ""name"": ""chicago""},
              {""locationID"":""2"", ""name"": ""ny""}]
</code></pre>

<p>I am trying to combine these 3 into below result ,</p>

<pre><code>result = [
   {
      ""firstName"":""john"",
      ""lastName"":""public"",
      ""location"":""development"",
      ""department"":""sales""
   },
   {
      ""firstName"":""sam"",
      ""lastName"":""smith"",
      ""location"":""ny"",
      ""department"":""sales""
   }
]
</code></pre>

<p>To get the desired result, I have used map function on persons observable to give new object array.</p>

<pre><code>this.store&lt;Person&gt;('persons')
.map(function(person){
     let p = new personDetail()
     p.firstName = person.firstName,
     p.lastName = person.lastName
     return p;
})
</code></pre>

<p><code>PersonDetail</code> object has <code>firstName</code>, <code>lastName</code>, <code>location</code> and <code>department</code> properties. How do I do a lookup into departments observable and get a matching row for <code>departmentID</code> to get the department name ?</p>

<p>I am new to rxjs library, please let me know if there is a better way to attain the desired result.</p>
","1079162","","310726","","2016-12-21 11:50:04","2017-01-13 15:15:07","Combine multiple observable arrays into new object array","<javascript><angular><typescript><rxjs><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"41257729","2","","41251908","2016-12-21 07:53:34","","3","","<p>Try to use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-scan"" rel=""nofollow noreferrer"">scan</a> operator:</p>

<pre><code>this.logs$ = this.logs.asObservable()
        ...
        .merge(this.$loggerService.applicationLog$.map((x) =&gt; {                    
            //return an array with one object { timestamp, message }
            return [{ timestamp: new Date(parseFloat(x[0])), message: x[1] }];
        }))
        .scan((acc, x) =&gt; {
            acc.push(...x);
            return acc;
        }, []);
</code></pre>
","1010664","","","","","2016-12-21 07:53:34","","","","0","","","","CC BY-SA 3.0"
"41260580","1","41262198","","2016-12-21 10:29:21","","0","24","<p>I have following function: </p>

<pre><code>_processCalenderSelect: function (oCalendarSelectOb, oEditButton) {
  let self = this;

  return oCalendarSelectOb
    .switchMap(function (oCalendar) {
      return oEditButton.getPressed()? Rx.Observable.of(oCalendar) : Rx.Observable.never();
    })
    .mergeMap(function (oCalendar) {
      return Rx.Observable.from(oCalendar.getSource().getSelectedDates());
    })
    .map(function (oDateRange) {
      return oDateRange.getStartDate();
    });

},
</code></pre>

<p>the first parameter is just an observable and the second is an object.   </p>

<p>Look at the <code>switchMap</code> method, I am asking if the button is pressed or not. </p>

<p>My question is, do I break Reactive Functional Paradigm, when I ask for the button state inside the closure?</p>

<pre><code>.switchMap(function (oCalendar) {
      return oEditButton.getPressed()? Rx.Observable.of(oCalendar) : Rx.Observable.never();
    })
</code></pre>
","1743843","","1743843","","2016-12-21 10:38:21","2016-12-21 11:51:51","According to reactive functional paradigm","<rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41262112","1","","","2016-12-21 11:47:33","","2","129","<p>I am using RxJS with Angular2.</p>

<p>I often find myself emitting to a private subject in an Angular2 service which emits to a public stream / observable.</p>

<p>The typical pattern I am using in my component is ..</p>

<pre><code>ngOnInit() {
  service.myStream$.subscribe( ... )
}

clickSomethingHandler() {
  service.emit(this.someValue);
}
</code></pre>

<p>And in my service ...</p>

<pre><code>private mySubject = new Subject&lt;any&gt;();

public myStream$ = mySubject.map( ... ) // etc

public emit(value) {
    mySubject.next(value);
}
</code></pre>

<p>Is this the best approach? Any other approaches or improvements on this?</p>

<p>Thanks</p>
","1205871","","","","","2016-12-21 11:47:33","What angular2 RxJS subscription pattern should I use?","<angular><rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"41262155","2","","41255718","2016-12-21 11:49:39","","8","","<p>Since you'll very likely want to fetch lists of departments and locations from a remote service (make another HTTP request) I'd do it right away with Observables as well.</p>

<pre><code>Observable.from(persons)
    .mergeMap(person =&gt; {
        let department$ = Observable.from(departments)
            .filter(department =&gt; department.departmentID == person.departmentID);

        let location$ = Observable.from(locations)
            .filter(location =&gt; location.locationID == person.locationID);

        return Observable.forkJoin(department$, location$, (department, location) =&gt; {
            return {
                'firstName': person.firstName,
                'lastName': person.lastName,
                'location': location.name,
                'department': department.name,
            };
        });
    })
    .toArray()
    .subscribe(result =&gt; console.log(result));
</code></pre>

<p>This prints to console:</p>

<pre><code>[ { firstName: 'john',
    lastName: 'public',
    location: 'chicago',
    department: 'development' },
  { firstName: 'sam',
    lastName: 'smith',
    location: 'ny',
    department: 'sales' } ]
</code></pre>

<p>There're two Observables <code>department$</code> and <code>location$</code> that are filtered with <code>filter()</code> operator to get the only item with matching ID. Then <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/forkjoin.md"" rel=""nofollow noreferrer""><code>forkJoin()</code></a> operator waits until both of them are complete. Operator <code>mergeMap()</code> then reemits the value returned from <code>forkJoin()</code>. At the end with <code>toArray()</code> we collect all items into a single array.</p>

<p>Instead of <code>Observable.from(...)</code> you can have whatever service you'll need (eg. <code>http.get(...)</code>).</p>

<p>See live demo: <a href=""https://jsbin.com/nenekup/4/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/nenekup/4/edit?js,console</a></p>

<p>Similar questions: <a href=""https://stackoverflow.com/questions/40346728/merge-subarrays-using-observables/40347238"">Merge subarrays using Observables</a> and <a href=""https://stackoverflow.com/questions/40250882/subscribing-to-a-nested-observable/40257871"">Subscribing to a nested Observable</a></p>
","310726","","-1","","2017-05-23 11:46:48","2016-12-21 11:55:38","","","","2","","","","CC BY-SA 3.0"
"41262198","2","","41260580","2016-12-21 11:51:51","","1","","<p>Without knowing how your streams are triggered, this is ""technically O.k."", however as you probably already guessed, you are kind of breaking the ""spirit"" of having pure, stateless functions by introducing a non-stream-state, the <code>oEditButton</code> - the stream cannot be guaranteed to have the same result with the same inputs every time, because there is some ""external"" state(button pressed or not).</p>

<p>So the ""cleaner"" approach would be (unsure if that works for your application) to have something like an <code>oEditButtonClicked$</code>-event-stream, that will trigger processing of selected dates.</p>

<pre><code>oEditButtonClicked$
    .switchMapTo(oCalenderSelect$)
    .mergeMap(cal =&gt; Rx.Obserbalbe.from(cal.getSource....))
</code></pre>

<hr>

<p>As a side-note, if you are not able to introduce that event-stream, you could still improve your code by using <code>skipWhile</code>:</p>

<pre><code>return oCalendarSelectOb
    .skipWhile(() =&gt; oEditButton.getPressed())
    .mergeMap(function (oCalendar) {
      return Rx.Observable.from(oCalendar.getSource().getSelectedDates());
    })
    .map(function (oDateRange) {
      return oDateRange.getStartDate();
    });
</code></pre>

<p>(this does NOT resolve the initial question though, just a hint on the side)</p>
","1518765","","","","","2016-12-21 11:51:51","","","","4","","","","CC BY-SA 3.0"
"41265648","1","41265986","","2016-12-21 14:54:34","","0","177","<p>I have a toggle button and a calendar, that looks like 
<a href=""https://i.stack.imgur.com/H4Hvg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/H4Hvg.png"" alt=""enter image description here""></a></p>

<p>As you can see on the image, the <code>edit</code> is a toggle button and when it got pressed, then the calendar will be editable.  </p>

<p>The edit toggle button is defined as hot observable:</p>

<pre><code>let oEditOb = this._createEditObservable(this.getById(""cal-edit""));
_createEditObservable: function (oEditBtn) {
      return Rx.Observable.create(function (subscriber) {
        oEditBtn.attachPress(function (oEvent) {
          subscriber.next(oEvent);
        });
      });
    },
</code></pre>

<p>Also the select event on calendar:</p>

<pre><code>let oCalendarSelectOb = this._createCalendarSelectObservable(this.getById(""calendar-view""));

    _createCalendarSelectObservable: function (oCalendar) {
      return Rx.Observable.create(function (subscriber) {
        oCalendar.attachSelect(function (oEvent) {
          subscriber.next(oEvent);
        })
      });
    },
</code></pre>

<p>When the toggle button got pressed, then it will switch to calendar observable. To clarify consider following code snippet:</p>

<pre><code>_processCalenderSelect: function (oCalendarSelectOb, oEditButtonOb) {
      let self = this;

      return oEditButtonOb
        .filter(function (oBtn) {
          return oBtn.getPressed();
        })
        .switchMapTo(oCalendarSelectOb)
        .mergeMap(function (oCalendar) {
          return Rx.Observable.from(oCalendar.getSource().getSelectedDates());
        })
        .map(function (oDateRange) {
          return oDateRange.getStartDate();
        });

    },
</code></pre>

<p>Once it switched to calendar observable, then the calendar will be editable forever, even when I press the toggle button to disable the <code>edit</code> mode.   </p>

<p>I tried to unsubscribe the calendar select observable:</p>

<pre><code>oEditPressedOb.subscribe(function (oSource) {
        if(!oSource.getPressed()){
          oSubscription.unsubscribe();
        }
        console.log(oSource);
      });
</code></pre>

<p>But then the calendar select will be not streamed anymore after enable the <code>edit</code> mode again.</p>
","1743843","","","","","2016-12-21 15:11:09","Activate observable again after unsubscribe","<javascript><rxjs><reactive-programming><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41265986","2","","41265648","2016-12-21 15:11:09","","2","","<p>Try to use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""nofollow noreferrer"">combineLatest</a>:</p>

<pre><code>_processCalenderSelect: function (oCalendarSelectOb, oEditButtonOb) {
  let self = this;

  let selectedDates = oCalendarSelectOb
    .mergeMap(function (oCalendar) {
      return Rx.Observable.from(oCalendar.getSource().getSelectedDates());
    })
    .map(function (oDateRange) {
      return oDateRange.getStartDate();
    });

  return Rx.Observable
    .combineLatest(
      oEditButtonOb.map(function (oBtn) {
        return oBtn.getPressed();
      }),
      selectedDates
    )
    .filter(function (input) {
      return input[0];
    })
    .map(function (input) {
      return input[1];
    });
},
</code></pre>
","1010664","","","","","2016-12-21 15:11:09","","","","0","","","","CC BY-SA 3.0"
"41268670","1","41268791","","2016-12-21 17:35:04","","2","549","<p>I'm trying to show a confirmation Modal, before deleting a line using RxJS.</p>

<ul>
<li>The code below works fine if I delete 1 line.</li>
<li>When I delete a second line, then <code>deleteLineFulfilled</code> is called 2 times.</li>
<li>If I delete a third line, then <code>deleteLineFulfilled</code> is called 3 times and so on...</li>
</ul>

<p>Any idea why?</p>

<pre><code>const deleteLineEpic = (action$, store) =&gt;
action$.ofType(DELETE_LINE_REQUEST)
    .flatMap((action) =&gt; Observable.merge(
                Observable.of(showModalYesNo('CONFIRM_DELETE')),
                action$.ofType(MODAL_YES_CLICKED).map(() =&gt;
                    deleteLineFulfilled(action.line)
                )
                .takeUntil(action$.ofType(MODAL_NO_CLICKED))
           ));
</code></pre>
","235659","","","","","2017-04-13 19:59:50","RxJS 5 - function called twice","<rxjs5><redux-observable>","2","0","1","","","CC BY-SA 3.0"
"41268791","2","","41268670","2016-12-21 17:42:12","","3","","<p><code>action$</code> is a perpetual observable, and it will only stop when an action of the type <code>MODAL_NO_CLICKED</code> is dispatched - from your code it's hard to say when that happens, you should add an <code>.take(1)</code> before the <code>.takeUntil(...)</code>.</p>

<hr>

<p>However with this architecture you have to make sure that there <em>has</em> to be either an <code>MODAL_YES_CLICKED</code> or <code>MODAL_NO_CLICKED</code> emitted and that the emission cannot be skipped.</p>

<p>A simpler way would be to implement the confirm-dialog, subscribe to the result and then only dispatch the delete-action if the result was <code>YES</code> and if the result was <code>NO</code> don't even dispatch the action. That way you'll have a much cleaner action-epic.</p>
","1518765","","1518765","","2016-12-21 17:48:32","2016-12-21 17:48:32","","","","2","","","","CC BY-SA 3.0"
"41272692","1","","","2016-12-21 22:04:54","","8","1871","<p>I am following some Rx.Observable tutorials from an Angular 2 application and using an AutoComplete style of system.</p>

<p>As I type into a field, the valueChanges event fires from the Angular 2 FormControl.</p>

<p>This is chained through to Observable that is making a HTTP request against a JSON endpoint.</p>

<p>The moment the endpoint returns a 404 Status, the valueChanges event stops working.</p>

<p>I can see the error in my subscribe method, but not really sure what the best technique is to recover and keep going.</p>

<p>I am also a little confused why the KeyUp or ValueChange event would stop firing.</p>

<p><strong>Sample Value Change - Observable Chain</strong></p>

<pre><code>this.userNameControl
    .valueChanges
    .do(r =&gt; {
            // As soon as a 404 status is thrown from getGitHuybUser$, all value change (keyup) events stop working
            console.log
        }
    )
    .switchMap(userName =&gt; {
        return this.getGitHubUser$(userName);
    })
    .catch(err =&gt; {
        return Observable.of(err)
    })
    .subscribe(v =&gt; {
            console.log(v);
        },
        (err) =&gt; {
            // As soon ass there is a 404 status, I end up here
            console.log(err);
        },
        () =&gt; {
            console.log('Complete');
        });

getGitHubUser$(username) {
    return this.http
        .get(`https://api.github.com/users/${username}`)
}
</code></pre>

<p><strong>HTML Form Control</strong></p>

<pre><code>&lt;input type=""text"" [value]=""userName"" [formControl]=""userNameControl"" /&gt;
</code></pre>

<p><strong>I tried returning Observable.empty() and Observable.never() in the catch</strong></p>

<pre><code>.catch(err =&gt; {
    // Observable.of(err)
    // return Observable.empty();
    return Observable.never();
})
</code></pre>

<p>And the result was that the <code>subscribe</code> method called my <code>complete</code> method and still and so the valueChanges still do not fire.</p>
","473923","","473923","","2016-12-22 01:34:04","2016-12-22 01:36:20","ValueChanges stops working as soon as an error occurs in an Rx.Observable","<javascript><angularjs><angular><observable><rxjs5>","1","1","2","","","CC BY-SA 3.0"
"41273093","1","41273724","","2016-12-21 22:37:29","","3","1621","<p>I'm trying to return an observable from a function that uses Rx.Subject internally. Of course, as with any good API, the implementation details should be entirely abstracted from the consumer. However, using Subject.asObservable() it appears possible for any consumer to issue new values to all observers. </p>

<p>Example:</p>

<pre><code>const subject = new Rx.Subject();
const observable = subject.asObservable();

observable.source === subject; // true

observable.forEach(value =&gt; console.log(value));
observable.source.next('Hello'); 
// Causes the forEach above to print ""Hello""
</code></pre>

<p>So my question is, is there a <em>built-in</em> way to expose an Observable to consumers without giving them access to the original subject? If not this is clearly bad design on RxJs' part.</p>

<p>NOTE: This is for RxJS v5</p>
","1678348","","1678348","","2016-12-22 01:24:13","2016-12-22 01:24:13","How to create Observable from Subject without exposing the Subject to consumers in RxJs v5","<javascript><rxjs><observable><rxjs5><subject-observer>","1","0","","","","CC BY-SA 3.0"
"41273724","2","","41273093","2016-12-21 23:42:47","","1","","<p>The only way, that I know of, to <strong>truly</strong> encapsulate this would be to subscribe to the subject inside your function and and have another (either subject or custom obervable) returned that emits those value(s).</p>

<p>But any operator (even the creation-operators like <code>Observable.combineLatest(subject)</code>) has <em>some</em> way to access the source.</p>

<p>Another way to ""solve"" this would be to use Typescript, because the TS-compiler would tell you, that you cannot access a protected property <code>source</code> on <code>Observable</code>, since it is not a public attribute: <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts#L30"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts#L30</a> - of course in ES5 there is no such thing as ""protected"" and therefor it will be still accessible through the console e.g.</p>
","1518765","","","","","2016-12-21 23:42:47","","","","2","","","","CC BY-SA 3.0"
"41279686","1","41286190","","2016-12-22 09:23:57","","2","52","<p>I am using Subject in my code and wondering if it is the recommended to do it in this way.  </p>

<p>First of all, for what I am using the Subject is, when the toggle button got pressed, then other buttons will be set as inactive. </p>

<p><a href=""https://i.stack.imgur.com/GwIry.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GwIry.png"" alt=""enter image description here""></a></p>

<p>After <code>edit</code> got pressed:
<a href=""https://i.stack.imgur.com/hpbc7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hpbc7.png"" alt=""enter image description here""></a></p>

<p>Subject definition and subscriber implementation code:</p>

<pre><code>  let oButtonSubject = new Rx.Subject();
  this._subscribeButtonState(oButtonSubject);

_subscribeButtonState: function (oButtonSubject) {
      let self = this;
      return oButtonSubject
        .subscribe(function (oBtnState) {
          let oModel = self.getModel(""vmButtonsState"");
          oModel.setProperty(""/edit"", oBtnState.bEdit);
          oModel.setProperty(""/mass"", oBtnState.bMass);
          oModel.setProperty(""/save"", oBtnState.bSave);
          oModel.setProperty(""/cancel"", oBtnState.bCancel);
        });
    },
</code></pre>

<p>The code above will set the state of buttons.  </p>

<p>Every time, when the <code>edit</code> got pressed, the <code>next</code> method got called and push data to <code>oButtonSubject</code>.</p>

<pre><code>_subscribeEditPressOb: function (oEditPressed, oButtonSubject) {
      let self = this;
      return oEditPressed
        .map(function (oSource) {
          return oSource;
        })
        .subscribe(function (oSource) {

            // Determine select state for the calendar.
            // The calendar is only allowed to select, if
            // EDIT button is clicked.
            if (oSource.getId().indexOf(""cal-edit"") &gt;= 0 &amp;&amp; oSource.getPressed()) {
              oButtonSubject.next({bEdit: true, bMass: false, bSave: false, bCancel: false});
            } else {
              oButtonSubject.next({bEdit: true, bMass: true, bSave: true, bCancel: true});
            }
          },
          function (err) {
            jQuery.sap.log.fatal(err);
          });
    },
</code></pre>

<p>The code above subscribe to the <code>edit</code> button when it got pressed, after push the data to the subject.</p>

<p>It is the right approach to use subject?</p>
","1743843","","","","","2016-12-22 15:37:22","Recommended to use Subject or not","<javascript><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41286190","2","","41279686","2016-12-22 15:09:53","","3","","<p>A <code>Subject</code> is meant as an entrance from the non-reactive world into the Rx world. In your case you are using a <code>Subject</code> to <em>emit events</em> based on <em>click events</em> on the edit button.</p>

<p>I would suggest you do not use a Subject for this specific implementation but use your clicks directly as a stream by using <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent"" rel=""nofollow noreferrer""><code>fromEvent</code></a></p>

<p>The following is an example (ignore the rough edges; it persists state in the DOM) (<a href=""https://jsbin.com/qunijob/2/edit?js,console,output"" rel=""nofollow noreferrer"">jsbin</a>)</p>

<pre><code>const editButton = document.getElementById('enable-edit-mode')
const saveChangesButton = document.getElementById('save-changes');
const cancelChangesButton = document.getElementById('cancel-save-changes');

const enableEditModeStream = Rx.Observable.fromEvent(editButton, 'click')
.do(() =&gt; {
  editButton.setAttribute('disabled','disabled')
  saveChangesButton.removeAttribute('disabled');
  cancelChangesButton.removeAttribute('disabled');
});

const saveChangesStream = Rx.Observable.fromEvent(saveChangesButton, 'click')
  .do(() =&gt; {
    console.log('saving changes')
  });
const cancelChangesStream = Rx.Observable.fromEvent(cancelChangesButton, 'click');

const saveCancelEditModeStream = Rx.Observable.merge(
  saveChangesStream,
  cancelChangesStream
)
.do(() =&gt; {
  editButton.removeAttribute('disabled');
  saveChangesButton.setAttribute('disabled','disabled')
  cancelChangesButton.setAttribute('disabled','disabled')
});


Rx.Observable.merge(
  enableEditModeStream,
  saveCancelEditModeStream
)
.subscribe();
</code></pre>
","106909","","106909","","2016-12-22 15:37:22","2016-12-22 15:37:22","","","","2","","","","CC BY-SA 3.0"
"41286476","1","41288856","","2016-12-22 15:25:12","","18","29216","<p>I'm trying to get the value from a simple ajax request, but I don't understand how to do that. Here is the code: </p>

<pre><code>Rx.Observable
  .ajax({ url: 'https://jsonplaceholder.typicode.com/posts', method: 'GET', responseType: 'json' })
  .subscribe(function(data) { return data.response; });
</code></pre>

<p>I searched everywhere and there is no simple explanation. </p>

<p>Thanks!</p>
","2266945","","","","","2018-12-28 02:58:45","Rxjs 5 - Simple Ajax Request","<ajax><rxjs><rxjs5>","3","0","12","","","CC BY-SA 3.0"
"41288856","2","","41286476","2016-12-22 17:35:18","","29","","<p><code>Observable.ajax</code> can accept <code>string</code> or <code>Object</code> with the following interface:</p>

<blockquote>
<pre><code>interface AjaxRequest {
  url?: string; // URL of the request
  body?: any;  // The body of the request
  user?: string; 
  async?: boolean; // Whether the request is async
  method?: string; // Method of the request, such as GET, POST, PUT, PATCH, DELETE
  headers?: Object; // Optional headers
  timeout?: number;
  password?: string;
  hasContent?: boolean;
  crossDomain?: boolean; //true if a cross domain request, else false
  withCredentials?: boolean;
  createXHR?: () =&gt; XMLHttpRequest; //a function to override if you need to use an alternate XMLHttpRequest implementation
  progressSubscriber?: Subscriber&lt;any&gt;;
  responseType?: string;
}
</code></pre>
  
  <p>see <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/internal/observable/dom/AjaxObservable.ts"" rel=""noreferrer"">AjaxObservable.ts on GitHub</a></p>
</blockquote>

<p>And here is examples:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { Observable, combineLatest } = rxjs; // = require(""rxjs"")
const { ajax } = rxjs.ajax; // = require(""rxjs/ajax"")
const { map } = rxjs.operators; // = require(""rxjs/operators"")

// simple GET request example
const simple$ = ajax('https://httpbin.org/get');

// POST request example
const complex$ = ajax({
  url: 'https://httpbin.org/post',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'x-rxjs-is': 'Awesome!'
  },
  body: {
    hello: 'World!',
  }
});

const htmlSubscription = combineLatest(simple$, complex$)
  .subscribe(([simple, complex]) =&gt; {
    const simpleResponse = JSON.stringify(simple.response, null, 2);
    const complexResponse = JSON.stringify(complex.response, null, 2);
    document.getElementById('root').innerHTML = `
      &lt;div&gt;
        &lt;span&gt;&lt;b&gt;GET&lt;/b&gt; https://httpbin.org/get&lt;/span&gt;
        &lt;pre&gt;${simpleResponse}&lt;/pre&gt;

        &lt;span&gt;&lt;b&gt;POST&lt;/b&gt; https://httpbin.org/post&lt;/span&gt;
        &lt;pre&gt;${complexResponse}&lt;/pre&gt;
      &lt;/div&gt;`;
  });</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@6.2.2/bundles/rxjs.umd.min.js""&gt;&lt;/script&gt;
&lt;div id=""root""&gt;loading ...&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","3772379","","3772379","","2018-08-24 23:16:06","2018-08-24 23:16:06","","","","5","","","","CC BY-SA 4.0"
"41304086","1","41304659","","2016-12-23 15:32:41","","1","594","<p>I'm having problems with making an RxJS5 observable stream behave in a way that I want it to.</p>

<p>The stream is supposed to send an HTTP request to a website using axios, and if the response is an HTTP error (which axios coerces to a JavaScript error), the observable sequence should wait 10 milliseconds and then try resending the request (for some reason the website that I'm sending the request to doesn't like it when you retry sending the request immediately and keeps throwing errors, but mostly behaves fine with a 10 ms delay).</p>

<pre><code>Rx.Observable
  .fromPromise(axios('http://example.com/12345'))
  .map(x =&gt; new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(x)
    }, 2000)
  }))
  .debounceTime(2000)
  .do(console.log)
  .retry(10)
  .subscribe(console.log, console.error)
</code></pre>

<p>I have an example on Codepen with a few changes, to make it more apparent, how the stream works: <a href=""http://codepen.io/leakyabstractions/pen/pNmvyZ?editors=0010"" rel=""nofollow noreferrer"">http://codepen.io/leakyabstractions/pen/pNmvyZ?editors=0010</a></p>

<p>I tried using <code>.delay()</code>, <code>.debounceTime()</code>, <code>.timer()</code>, <code>.timeInterval()</code> and <code>.timeout()</code> in the place of the <code>.map()</code> operator, but nothing (including <code>.map()</code>) works. What am i doing wrong?</p>
","6002579","","","","","2016-12-28 12:25:19","How to delay retrying to send an HTTP request with RxJS5?","<javascript><reactive-programming><rxjs5><reactive-extensions-js><reactive>","2","0","","","","CC BY-SA 3.0"
"41304659","2","","41304086","2016-12-23 16:15:10","","1","","<p>So basically what you are looking for is a ""retry after 10ms, but only 10 times""? (this is what your <code>retry(10)</code> suggests.
I think a sophisticated solution would include <code>retryWhen</code> here:</p>

<pre><code>const mockedRestError$ = Rx.Observable.throw(""http://example.com/12345"");

// we'll start with an empty string, because otherwhise
// we could not log the ""start...""
Rx.Observable.of("""")
  .do(() =&gt; console.log(""start...""))
  .switchMapTo(mockedRestError$)
  .retryWhen(tenTimesWithDelay)
  .subscribe(console.log, console.error, console.info); // is never called, because 


function tenTimesWithDelay(errors) {
  return errors
    .scan((count, err) =&gt; {
      ++count;
      // optionally to throw the error all the way down to the subscription
      // comment the throw out to have the stream simply complete
      if (count &gt;= 10) {
        throw err;
      }
      return count;
    }, 0)
    .takeWhile(count =&gt; count &lt; 10)
    .do(count =&gt; console.log(`Retry #${count} in 100ms...`))
    .delay(100);
}
</code></pre>

<p>Here is the code-pen: <a href=""http://codepen.io/anon/pen/bBydwZ?editors=0010"" rel=""nofollow noreferrer"">http://codepen.io/anon/pen/bBydwZ?editors=0010</a></p>

<p>Please also note, that I set the delay to 100ms instead of 10ms just so it shows a little cleaner in the console.</p>
","1518765","","","","","2016-12-23 16:15:10","","","","0","","","","CC BY-SA 3.0"
"41318193","1","41319408","","2016-12-25 02:01:28","","0","620","<p>I am learning angular 2 and rxjs. I have 3 variables, A B C.</p>

<ul>
<li>B depends on the value of A</li>
<li>C depends on the value of A and B</li>
</ul>

<p>I am trying to setup up the observables such that: When A is updated, B and C will be auto updated. When B is updated, C will be auto updated. I tried two setups but they are not satisfactory.</p>

<ul>
<li>First setup: B subscribes observable A; C subscribes observable B <strong>withlatestfrom</strong> A. The changes in A did cascade down to B then to C but the value from A is not the latest.</li>
<li>Second setup: B subscribes observable A; C subscribes <strong>combineLatest</strong> observable of A and B. This setup works but I get two updates for C, first from B and then from A.</li>
</ul>

<p>How can I set up my observables / subscription such that when A is updated, C will only get updated once with latest value from A and B?</p>

<p>EDIT - CODES ADDED</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var A = new Rx.BehaviorSubject(1);
var A_Observable = A.asObservable();
var B = new Rx.BehaviorSubject(10);
var B_Observable = B.asObservable();

A_Observable.subscribe(function(A_value) {
  var newB = A_value * 10;
  // console.log(""B auto updating to "" + newB);
  B.next(newB);
});

// LATEST FROM OBSERVABLE
var latestFromObservable = B_Observable.withLatestFrom(A_Observable);
latestFromObservable.subscribe(function(data) {
  console.log(""LATEST FROM : Value for A is "" + data[1] + "" ; Value for B is "" + data[0]);
});

// COMBINE ALL OBSERVABLE
var combineAllObservable = Rx.Observable.combineLatest(A_Observable,B_Observable);
combineAllObservable.subscribe(function(data) {
  console.log(""COMBINE LATEST : Value for A is "" + data[0] + "" ; Value for B is "" + data[1]);
});

// UPDATE TO A
setTimeout(function(){
  console.log(""UPDATING A"");
  A.next(2);
},1000);

// SATISFACTORY RESULT
setTimeout(function(){
  console.log(""SATISFACTORY RESULT : Value for A is 2 ; Value for B is 20 --- CALLED ONLY ONCE WITH LATEST VALUES"");
},2000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1618525","","1618525","","2016-12-25 06:37:19","2016-12-25 11:07:33","Rxjs - Subscribing to interdependent observables","<angular><rxjs><reactive-programming><rxjs5>","2","1","","","","CC BY-SA 3.0"
"41319408","2","","41318193","2016-12-25 07:30:41","","0","","<p>Code behaves this way because by default RxJs runs code synchronously. Chain of events for <code>withLatestFrom</code> case:</p>

<ol>
<li>You push new <code>A</code> value: <code>A.next(2);</code></li>
<li>RxjS sees that there are two usages of <code>A</code>:

<ol>
<li><code>B</code>-subscription (comes first)</li>
<li><code>withLatestFrom</code> (comes second)</li>
</ol></li>
<li>RxJs calls <code>B</code>-subscription

<ol>
<li>It pushes new value of <code>B</code></li>
<li>RxjS sees that there is a usage of <code>B</code>: <code>C</code>-subscription</li>
<li>RxJs calls <code>C</code>-subscription (with old value of <code>A</code>!)</li>
</ol></li>
<li>New value of <code>A</code> is pulled in <code>withLatestFrom</code> but <code>C</code>-subscription isn't triggered (because it is triggered only by <code>B</code> updates)</li>
</ol>

<p>Possible solution is to add <code>debounceTime(0)</code>.It will force <code>C</code>-subscription to run asynchronously when the value inside <code>withLatestFrom</code> is already updated.</p>

<p>For more info google for RxJs's <code>Scheduler</code>.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var A = new Rx.BehaviorSubject(1);
var A_Observable = A.asObservable();
var B = new Rx.BehaviorSubject(10);
var B_Observable = B.asObservable();

A_Observable.subscribe(function(A_value) {
  var newB = A_value * 10;
  // console.log(""B auto updating to "" + newB);
  B.next(newB);
});

// LATEST FROM OBSERVABLE
var latestFromObservable = B_Observable.debounceTime(0).withLatestFrom(A_Observable);
latestFromObservable.subscribe(function(data) {
  console.log(""LATEST FROM : Value for A is "" + data[1] + "" ; Value for B is "" + data[0]);
});

// COMBINE ALL OBSERVABLE
var combineAllObservable = Rx.Observable.combineLatest(A_Observable,B_Observable).debounceTime(0);
combineAllObservable.subscribe(function(data) {
  console.log(""COMBINE LATEST : Value for A is "" + data[0] + "" ; Value for B is "" + data[1]);
});

// UPDATE TO A
setTimeout(function(){
  console.log(""UPDATING A"");
  A.next(2);
},1000);

// SATISFACTORY RESULT
setTimeout(function(){
  console.log(""SATISFACTORY RESULT : Value for A is 2 ; Value for B is 20 --- CALLED ONLY ONCE WITH LATEST VALUES"");
},2000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>I want to add two things:</p>

<ol>
<li><code>withLatestFrom</code> approach is better in your case because dependency graph looks like <code>C -&gt; B -&gt; A</code> and when A is updated B is updated too. If <code>A</code> and <code>B</code> were independent then <code>combineLatest</code> would be the better choice.</li>
<li>No need in <code>Subject</code> for <code>B</code>. You can rewrite code like this (no <code>debounceTime</code>!)</li>
</ol>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var A = new Rx.BehaviorSubject(1);
var A_Observable = A.asObservable();

var B_Observable = A_Observable.map(function(A_value) {
  var newB = A_value * 10;
  // console.log(""B auto updating to "" + newB);
  return newB;
});

var latestFromObservable = B_Observable.withLatestFrom(A_Observable);
latestFromObservable.subscribe(function(data) {
  console.log(""LATEST FROM : Value for A is "" + data[1] + "" ; Value for B is "" + data[0]);
});

// UPDATE TO A
setTimeout(function(){
  console.log(""UPDATING A"");
  A.next(2);
},1000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1010664","","","","","2016-12-25 07:30:41","","","","1","","","","CC BY-SA 3.0"
"41320111","1","41321513","","2016-12-25 09:44:12","","1","1131","<p>I have following code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>console.log('start');

//emit value every second
const message = Rx.Observable.interval(1000);
//emit value as soon as subscribed
const trueObs = () =&gt; Rx.Observable.of(true);
// start emitting delayed values as soon as trueObs emits
const delayWhenExample = message.delayWhen(trueObs);
//log values start logging after one second
//ex. output: 0...1...2...3
const subscribe = delayWhenExample.subscribe(val =&gt; console.log(val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.8/dist/global/Rx.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Why <code>Rx.Observable.of(true)</code> starts to emit value without <code>subscribe</code> the observable?<br>
I understand the concept to RxJS as lazy evaluation, it does not emit values, until I am asking it.</p>
","1743843","","1945651","","2017-11-04 18:07:16","2017-11-04 18:07:16","Why Rx.Observable.of(true) starts to emit","<javascript><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"41320125","1","41320212","","2016-12-25 09:46:02","","5","10199","<p>I used to set a timeout to my angular2 http post like following:</p>

<pre><code>this.http.post('myurl',
      body, {headers: headers})
      .timeout(2000, new Error('Timeout exceeded'))
      .map(res =&gt; res.json())
      .subscribe((stuff) =&gt; {
         //Do stuff
      }, (errorResponse: any) =&gt; {
        //Manage error
      });
</code></pre>

<p>But with last version of Rjxs (5.0.1) this isn't valid anymore.</p>

<p>Timeout need an Observable as first parameter and doesn't accept ""new Error"", how should I do/write that?</p>

<p>Thx you in advance for your help</p>

<p>Note: When I remove the ""new Error(...)"", my code is then valid but at runtime, I gonna face following error</p>

<blockquote>
  <p>Error: Uncaught (in promise): TypeError: _this.http.post(...).timeout
  is not a function TypeError: _this.http.post(...).timeout is not a
  function</p>
</blockquote>
","5404186","","5404186","","2017-11-11 07:20:04","2018-09-23 06:03:56","How to implement http post timeout with last Rxjs version?","<angular><rxjs><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"41320212","2","","41320125","2016-12-25 09:59:21","","12","","<p>Got it, I had to include following:</p>

<pre><code>import 'rxjs/add/operator/timeout';

this.http.post('myurl',
  body, {headers: headers})
  .timeout(2000)
  .map(res =&gt; res.json())
  .subscribe((stuff) =&gt; {
     //Do stuff
  }, (errorResponse: any) =&gt; {
    //Manage error
  });
</code></pre>

<p>****** UPDATE for Angular >= 4.3 and Rxjs >= 5.2.2 ******</p>

<p>With the introduction of RXJS 5.2 the <code>timeout</code> operator could be done using the newly introduced <code>pipe</code>. Furthermore importing it as lettable operators might reduce the bundle size (in case all used operators would be imported as lettable).</p>

<p>Angular 4.3 introduce <code>HttpClientModule</code> which gonna at some point replace <code>HttpModule</code>.</p>

<p>Therefore here the updated code:</p>

<pre><code>import {timeout} from 'rxjs/operators/timeout'; 

let headers: HttpHeaders = new HttpHeaders();
headers.append('Content-Type', 'application/json');

let body = {something: 'my_value'};

this.http.post('myurl',
  body, {headers: headers})
  .pipe( 
     timeout(2000)
  )
  .subscribe((stuff: any) =&gt; {
     //Do stuff
  }, (errorResponse: HttpErrorResponse) =&gt; {
    //Manage error
  });
</code></pre>

<p>****** UPDATE for Rxjs >= 6 ******</p>

<p>The above code still works fine in Rxjs v6 but the <code>import</code> or the <code>timeout</code> pipe should be modified like the following:</p>

<pre><code>import {timeout} from 'rxjs/operators';

// same as above
</code></pre>
","5404186","","5404186","","2018-09-23 06:03:56","2018-09-23 06:03:56","","","","3","","","","CC BY-SA 4.0"
"41321513","2","","41320111","2016-12-25 13:29:28","","1","","<p>Your variable <code>delayWhenExample</code> is actually a <code>SubscriptionDelayObservable</code> observable, which was created by calling <code>delayWhen()</code>. It keeps track of the original <code>message</code> observable and the observable that you passed to it as an argument (delayForFiveSeconds). When you call <code>subscribe()</code>, it will also subscribe behind the scenes to both of these observables, which it needs to calculate its values.</p>

<p>This is really the whole idea of lazy evaluation. You subscribe to the observable that you need, and all of the other observables that it depends on will be subscribed to automatically - but only when necessary. Unsubscribing is also done automatically, which is very convenient when combining data from a lot of different sources.</p>
","493729","","","","","2016-12-25 13:29:28","","","","1","","","","CC BY-SA 3.0"
"41322751","1","","","2016-12-25 16:23:37","","1","50","<p>I am learning rxjs and struggle to understand the <code>window</code> method. I read the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-window"" rel=""nofollow noreferrer"">doc</a> a lot of times and I miss the aha effect.   </p>

<p>Could someone explain me on a very simple example, how can I use the <code>window</code> method and in which situation can I use it. </p>
","1743843","","","","","2016-12-25 21:59:59","Understand the window method","<javascript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41336565","1","41337597","","2016-12-26 21:44:33","","1","494","<p>I thought I could use an observable to send in new props every second and have a react (functional, stateless) component thereby update itself. I am not sure what I am missing here. Here's a <a href=""https://jsbin.com/kifagew/1/edit?html,js,console,output"" rel=""nofollow noreferrer"">jsbin</a></p>

<pre><code>const propsObs = Rx.Observable.from(['Butler', 'Fritz', 'Dusty', 'Petey'])
const inte = Rx.Observable.interval(1000).take(4)
var props={olddog:'Rusty'}
const propsOverTime = propsObs.zip(inte, (aprop,intx)=&gt;aprop) 
propsOverTime.subscribe((x)=&gt;{
  props={...props, olddog:x}
  console.log(props)
})

const App = (props) =&gt;{
  console.log(props.olddog)
  const getDog=()=&gt;props.olddog
  const thedog = getDog()
  return(
    &lt;div&gt;&lt;h4&gt;hello {thedog}&lt;/h4&gt;&lt;/div&gt;)
}
ReactDOM.render(&lt;App {...props}/&gt;, document.getElementById('app'))
</code></pre>

<p>The Observable changes props every second, each time creating a new props object. Shouldn't that be enough to force a re-render of the component?</p>
","451454","","","","","2016-12-27 00:28:18","on using rxjs to update props of a react functional stateless component","<reactjs><functional-programming><observable><rxjs5><stateless>","1","0","","","","CC BY-SA 3.0"
"41337517","1","41341131","","2016-12-27 00:13:03","","1","572","<p>I am trying to create a hot observable that does not need to be subscribed too. This is for a library and I would like to give users the ability to call certain methods and avoid the need to call subscribe() to get the observables to fire. Initially I have this:</p>

<pre><code>const q = new Queue();

q.add('foo bar baz').subscribe();   // &lt;&lt;&lt; need to call subscribe


Queue.prototype.add = Queue.prototype.enqueue = function (lines) {

    lines = _.flattenDeep([lines]);

    var lockAcquired = false;

    return this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
        })
        .flatMap(() =&gt; {
            lockAcquired = true;
            return appendFile(this, lines)
        })
        .flatMap(() =&gt; releaseLock(this))
        .catch(err =&gt; {
            if (lockAcquired) {
                return releaseLock(this);
            }
            else {
                return makeGenericObservable();
            }
        })


};
</code></pre>

<p>in order to make the observable hot, I thought I could do something like this:</p>

<pre><code>const q = new Queue();

q.add('foo bar baz');  // &lt;&lt;&lt; don't call subscribe

Queue.prototype.add = Queue.prototype.enqueue = function (lines) {

    lines = _.flattenDeep([lines]);

    var lockAcquired = false;

    return this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
        })
        .flatMap(() =&gt; {
            lockAcquired = true;
            return appendFile(this, lines)
        })
        .flatMap(() =&gt; releaseLock(this))
        .catch(err =&gt; {
            if (lockAcquired) {
                return releaseLock(this);
            }
            else {
                return makeGenericObservable();
            }
        })
        .publish()
        .share()  // this too?

};
</code></pre>

<p>however the problem is when I call <code>publish()</code>, nothing happens, and the add method never seems to get fully invoked (I assume the first observable in the sequence never fires at all, because effectively subscribe is not called). But I though <code>publish()</code> would automatically invoke the observable chain?</p>

<p>How can I make the observable returned from the add method, <em>hot</em>?</p>
","1223975","","1223975","","2016-12-27 07:56:57","2016-12-27 13:42:22","publishing observable to make it *hot*","<node.js><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"41337597","2","","41336565","2016-12-27 00:28:18","","1","","<p>A functional React component is just that.. a function. It's not ""watching"" its own props for changes. Something upstream must call your function to get new JSX. If you have an enclosing component that extends <code>React.Component</code> then you can call <code>setState</code> and pass in new props, or in your case, simply call <code>ReactDOM.render</code> with your updated JSX.</p>

<pre><code>const App = props =&gt; {
  const getDog = () =&gt; props.olddog
  const thedog = getDog()
  return(
    &lt;div&gt;&lt;h4&gt;hello {thedog}&lt;/h4&gt;&lt;/div&gt;
  )
}

propsOverTime.subscribe(x =&gt; {
  props = {...props, olddog: x}
  ReactDOM.render(&lt;App {...props}/&gt;, document.getElementById('app'))
})
</code></pre>
","3225108","","","","","2016-12-27 00:28:18","","","","0","","","","CC BY-SA 3.0"
"41341131","2","","41337517","2016-12-27 07:48:01","","4","","<p>You misunderstood. Hot observable <em>does</em> require subscription like a cold one. Difference is that hot uses some external producer (like dome element) and start listen to it on subscription. On the other hand cold observable creates producer internally on subscription. </p>

<p>It results in that you can miss some events with hot observable because external producer knows nothing about subscription and emits independently. And with cold observable you can't miss anything because producer is created on subscription.</p>

<p>Long story short you can build any chain of observable on top of either hot or cold observable but until you subscribe to it nothing will happen. </p>

<p>PS. No need to use <code>publish</code> with <code>share</code> because latter is <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-share"" rel=""nofollow noreferrer"">alias</a> for <code>.publish().refCount()</code>.</p>
","1010664","","1223975","","2016-12-27 08:39:26","2016-12-27 08:39:26","","","","13","","","","CC BY-SA 3.0"
"41346840","1","","","2016-12-27 14:19:11","","1","1027","<p>Error is thrown and replaced. But then execution is ended. How to make observable to emit 10 elements?</p>

<pre><code>const Rx = require('rxjs/Rx')

Rx.Observable.interval(1000)
  .map((i) =&gt; {
    if (i === 2) throw(new Error('omg'))
    return i
  })
  .take(10)
  .catch((err) =&gt; {
    return Rx.Observable.of('ok, we caught an error, but we don\'t want to exit')
  })
  .do(console.log, console.error)
  .subscribe()
</code></pre>
","1518708","","1518708","","2016-12-27 14:25:31","2016-12-30 18:26:07","How to make observable to continue emiting values even if error was thrown","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"41349033","1","45294082","","2016-12-27 16:52:10","","41","5980","<p>As far as I understand, following are the techniques to solve asynchronous programming workflows:</p>

<ol>
<li>Callbacks (CSP)</li>
<li>Promises</li>
</ol>

<p>Newer approaches:</p>

<ol>
<li>Rx.js Observables (or mostjs, bacon.js, xstream etc)</li>
<li>ES6 generators</li>
<li>Async/Await</li>
</ol>

<p>We are now moving away from callbacks &amp; promises to these newer approaches. What I understand currently is - Async/Await is more like a cleaner abstraction on top of ES2015 generators.</p>

<p><strong>What I am not able to understand is the conceptual difference between Observables and Generators.</strong> I have used both extensively and have no trouble in using them.</p>

<p>What confuses me is the use case for Observables and Generators. I have come to conclusion that, in the end, they are addressing the same problem - asynchronicity. Only potential difference I see is generators inherently provide imperative semantics to code while Observables using Rxjs seem to provide reactive paradigm. But is that it?</p>

<p>Should that be the criteria to choose between Observable and Generator? What are the pros and cons.</p>

<p><strong>Am I missing the big picture?</strong></p>

<p>Also with Observable eventually making into future Ecmascript, are Promises (with cancelable-token)/Observable/Generators going to compete with each other?</p>
","5723098","","","","","2021-08-08 11:55:49","How does Observables (Rx.js) compare to ES2015 generators?","<javascript><ecmascript-6><generator><reactive-programming><rxjs5>","3","5","17","","","CC BY-SA 3.0"
"41353196","1","","","2016-12-27 22:53:14","","1","866","<p>I have a message service that emits a message whenever the API method is called. The idea is so that all other components in my app can call methods from the service to display either error or success messages.</p>

<pre><code>import { Injectable } from '@angular/core';
import { MessagingComponent } from ',/messaging.component';
import { ReplaySubject } from 'rxjs';



@Injectable()
export class MessageService {

  public messages$: ReplaySubject&lt;Object&gt; = new ReplaySubject&lt;Object&gt;(1);

  constructor() {
    this.messages$.next({
        message: '',
        type: null
    });
  }

  showError(message: string, time: number): void {
    this.messages$.next({
        message,
        type: 'message-error',
        time: time
    });

  hideMessage(){
    this.messages$.next({
        message: '',
        type: null
    });
  }
</code></pre>

<p>The idea is that any other component can call <code>messageService.showError('my error message', 3000)</code>.  I'm confused as to how to get my <code>showError</code> method to call the <code>hideMessage</code> method after 3 seconds, or however long the caller provided for <code>time</code>.</p>
","3638724","","3001761","","2016-12-27 23:10:26","2016-12-28 06:03:23","Wait x seconds before adding value to observable","<angular><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"41358089","1","","","2016-12-28 08:24:29","","2","61","<p>I have following function:</p>

<pre><code>_processSelectedPlantWcOb: function (oSelectOb, oSetNewDates, oWpServiceOb, fnQueryDatesPlantWcOb) {
  let self = this;

  return oSelectOb
    .map(function (oEvent) {
      return oEvent.getSource();
    })
    .switchMap(function (oSelect) {
      return oSetNewDates.mapTo(oSelect);
    })
    .map(function (oSelect) {
      let oItem = oSelect.getSelectedItem();
      let aKeys = oItem.getKey().split(""/"");
      return {sPlant: aKeys[0], sWc: aKeys[1]};
    })
    .switchMap(function (oSelected) {
      return fnQueryDatesPlantWcOb(oWpServiceOb, oSelected.sPlant, oSelected.sWc);
    });
},
</code></pre>

<p>as you can see the last parameter is expect a function and the implementation of the function <code>fnQueryDatesPlantWcOb</code> looks as follow:</p>

<pre><code>_processQueryDatesPlantWcOb: function (oWpServiceOb, sPlant, sWc) {

  return oWpServiceOb
    .switchMap(function (oModel) {
      let oPlantFilter = new sap.ui.model.Filter(""Plant"", sap.ui.model.FilterOperator.EQ, sPlant);
      let oWcFilter = new sap.ui.model.Filter(""WorkCenter"", sap.ui.model.FilterOperator.EQ, sWc);

      return Rx.Observable.create(function (subscriber) {
        oModel.read(""/CostCenterCalendarSet"", {
          success: function (oData, oResponse) {
            subscriber.next(oResponse);
          },
          error: function (oError) {
            subscriber.error(oError);
          },
          filters: [oPlantFilter, oWcFilter]
        });
      });
    })
    .filter(function (oData) {
      return oData.data.results.length &gt; 0
    })
    .mergeMap(function (oData) {
      return Rx.Observable.from(oData.data.results);
    })
    .map(function (oData) {
      let oDate = oData.InspectionDate;
      return new Date(oDate.getFullYear(), oDate.getMonth(), oDate.getDate());
    })
    .filter(function (oDate) {
      let oToday = new Date();
      return oDate.getTime() &gt; oToday.getTime();
    })
    .map(function (oDate) {
      return oDate.getTime();
    });
},
</code></pre>

<p>As you can see, the parameters <code>sPlant</code> and <code>sWc</code> will be use in the <code>switchMap</code> function.</p>

<p>What I want to know is, do I break the functional paradigm?
In my opinion, I do not break it, because every time when I pass the same <code>sPlant</code> and <code>sWc</code> values, I will get the same result, but I am not sure.</p>
","1743843","","","","","2016-12-28 09:39:04","Breaking referentially transparent","<javascript><functional-programming><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41361866","1","41361992","","2016-12-28 12:09:22","","9","16201","<p>My Angular 2 application has 2 methods (<code>GetCategories()</code> and <code>GetCartItems()</code>) in a service , and both of these methods return <code>Observable</code>s.</p>

<p>In order to invoke these two methods one after another from my component, I have written below code:</p>

<pre><code> ngOnInit() 
{
   this.appService.GetCategories().subscribe( (data) =&gt; {
       this.appService.categories = data;


       this.appService.GetCartItems().subscribe( {
                                                    next: (data) =&gt; { this.appService.cart = data},
                                                    error: (err) =&gt; { this.toaster.error('cart==&gt;' + err)}

                                                })

   });       
}
</code></pre>

<p>Basically, calling <code>GetCartItems()</code> from within <code>subscribe()</code> of <code>GetCategories()</code>, and I feel this is NOT the right approach. This is kind of callback hell.</p>

<p>Any idea on how to implement this in a better way (like chaining <code>then()</code> in <code>Promise</code>s)?</p>
","2693545","","3345644","","2019-04-26 21:53:34","2019-04-26 21:53:34","Subscribe to multiple Observables (like chaining then() in Promises)","<angular><rxjs><rxjs5>","2","1","9","","","CC BY-SA 4.0"
"41361992","2","","41361866","2016-12-28 12:16:38","","15","","<p>Looks like <code>GetCartItems</code> doens't depend on <code>GetCategories</code>. Then you can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-zip"" rel=""noreferrer"">zip</a>:</p>

<pre><code>Observable
    .zip(
        this.appService.GetCategories()
        this.appService.GetCartItems()
    )
    .catch(err =&gt; this.toaster.error(err))
    .subscribe(([categories, cartItems]) =&gt; {
        this.appService.categories = categories;
        this.appService.cart = cartItems;
    });
</code></pre>
","1010664","","","","","2016-12-28 12:16:38","","","","1","","","","CC BY-SA 3.0"
"41362712","1","41380720","","2016-12-28 13:02:25","","4","1767","<p>I would like to use the <strong>retry</strong> property of the observer to try 3 times before it gives up and throws an error. However when I run the following code I get 'retry is not a function'. Any ideas what is going on ?</p>

<pre><code>get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    this._log.debug('SecureHttpService#get: ' + url);

    let resultObservable = Observable.create((observer) =&gt; {
      this._log.debug('resultObservable');
      this.tryReActivateToken().then(
        (result) =&gt; {
          this._log.debug('resultObservable#then#result: ' + result);
          if (result === true) {
            let headers = new Headers();
            headers.append('Authorization', 'Bearer ' + this.access_token);
            headers.append('X-Requested-With', 'XMLHttpRequest');
            // headers.append('Accept', 'json');

            this._log.debug(this.access_token);
            let superGetObs = super.get(url, { headers: headers, withCredentials: true }).retry(3);

            superGetObs.subscribe(
              (next) =&gt; { observer.onNext(next); },
              (error) =&gt; { observer.onError(error); },
              () =&gt; { observer.onCompleted(); }
            );
          } else {
            observer.onError(new Error('Could not log you in automatically'));
          }
        }, (error) =&gt; { this._log.debug('resultObservable#then#error: ' + error); observer.onError(error); });
    });

    return resultObservable;
  }
</code></pre>

<p>The full error stack: <a href=""http://pastebin.com/ScrzsNh0"" rel=""nofollow noreferrer"">http://pastebin.com/ScrzsNh0</a></p>
","3379839","","","","","2016-12-29 13:26:37","RXJS observer retry not a function","<rxjs5>","1","1","","","","CC BY-SA 3.0"
"41363423","1","","","2016-12-28 13:46:46","","0","677","<p>The main goal of my task is create timer that will be launching every n second. The project is writing on angular 2 so the best way is using Observable.</p>

<p>So what I'm trying to do:</p>

<pre><code>export interface IAsyncTimer {
    timerObservable: Observable&lt;any&gt;
    observables: Array&lt;Observable&lt;any&gt;&gt;
}

@Injectable()
export class AsyncTimer {
    private timers: Map&lt;number, IAsyncTimer&gt; = new Map&lt;number, IAsyncTimer&gt;();

    public addTimer(time: number,
                    func: Observable&lt;any&gt;) {
        let timer = this.timers.get(time);

        if (!!timer) {
            timer.observables.push(func);
        }
        else {
            let observable = Observable.interval(time)
                                       .timeInterval(),
                timer      = {
                    timerObservable: observable,
                    observables    : [func]
                };
            timer.timerObservable.switchMap(Observable.forkJoin.apply(Observable, timer.observables)).subscribe(() =&gt; {});
            this.timers.set(time, timer);
        }
    }
}
</code></pre>

<p>For example I have few component on page. Each component get data itself. Component should be updated every 10 seconds. So I'm injecting AsyncTimer and add request in timer.</p>
","3110920","","","","","2016-12-28 13:46:46","Async Timer on Rxjs","<angular><angular2-services><rxjs5>","0","7","","","","CC BY-SA 3.0"
"41364814","1","","","2016-12-28 15:14:05","","2","508","<p>I'm trying to download data from server in chunks. I don't know how many iterations there will be, I just have to get chunks until the server responds with ""no-more-data"".</p>

<p>In v4 there was <code>doWhile</code> operator but it was experimental and is removed in latest version.</p>

<p>There is a <a href=""https://stackoverflow.com/questions/34246398/"">similar question</a> (though I don't think this is a duplicate!) that suggests using <code>expand</code> but I'm not sure if it is still the best or only way to do it in v5.</p>

<p>Or maybe I'm solving the wrong problem to begin with?... I.e. is it a good practice to use RxJs in such scenarios, or am I discouraged to use it this way (e.g. using <code>expand</code> operator to achieve recursion, assuming no better way exists)???</p>

<p>If this is not something unsuitable to Reactive Extensions style in general, why did they remove the <code>doWhile</code> operator? (It's not even on any roadmap)</p>
","4866988","","-1","","2017-05-23 12:08:56","2017-05-29 13:54:41","How to loop in RxJs (v5)?","<javascript><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41366459","1","41367033","","2016-12-28 16:56:51","","1","397","<p>Observable.bindCallback only returns value if I subscribe to it directly
in other words, this works fine:</p>

<pre><code>return this.store.select(store =&gt; store.appDb.appBaseUrl)
            .take(1)
            .mergeMap(baseUrl =&gt; {
                const url = `${baseUrl}?command=GetCustomers&amp;resellerUserName=aaa&amp;resellerPassword=bbbb`;
                return this.http.get(url)
                    .map(res =&gt; {
                        var xmlData = res.text()
                        const boundCallback = Observable.bindCallback(this.processXml, (xmlData: any) =&gt; xmlData);
                        return boundCallback(this, xmlData)
                            .subscribe((x) =&gt; {
                                return x;
                            });
                    })
            })
</code></pre>

<p>however I need to avoid the subscription as I am running inside <code>@effect</code> which auto subscribes for me, so I run:</p>

<pre><code>return this.store.select(store =&gt; store.appDb.appBaseUrl)
            .take(1)
            .mergeMap(baseUrl =&gt; {
                const url = `${baseUrl}?command=GetCustomers&amp;resellerUserName=aaa&amp;resellerPassword=aaa`;
                return this.http.get(url)
                    .map(res =&gt; {
                        var xmlData = res.text()
                        const boundCallback = Observable.bindCallback(this.processXml, (xmlData: any) =&gt; xmlData);
                        var d:any = boundCallback(this, xmlData)
                        return d;
                    }).map(d=&gt;{console.log(d)})
            })
</code></pre>

<p>but instead of getting a value now I am getting a:</p>

<p>and this is d:</p>

<p><a href=""https://i.stack.imgur.com/gh5Xi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gh5Xi.png"" alt=""enter image description here""></a></p>

<p>regards</p>

<p>Sean</p>
","2040670","","","","","2016-12-28 18:38:39","Observable.bindCallback only returns value if I subscribe to it directly","<rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"41366938","1","41369318","","2016-12-28 17:29:02","","5","2556","<p>How can <code>Observable</code> class be extended by applying built-in RxJS operators to it?</p>

<p>I would like to do something like this:</p>

<pre><code>class TruthyObservable extends Observable {
  constructor(subscriber) {
    super(subscriber);

    return this.filter(x =&gt; x);
  }
}

class TruthyMappedObservable extends TruthyObservable {
  constructor(subscriber) {
    super(subscriber);

    return this.map(x =&gt; `'${x}'`);
  }
}
</code></pre>

<p>Can this be done without constructor return?</p>
","3731501","","3731501","","2016-12-28 19:57:13","2016-12-28 20:38:09","Extend RxJS Observable class with operators","<javascript><typescript><ecmascript-6><rxjs><rxjs5>","2","4","2","","","CC BY-SA 3.0"
"41367033","2","","41366459","2016-12-28 17:37:12","","2","","<p>If I understand what you want to do it should look something like this (obviously I didn't test it):</p>

<pre><code>return this.store.select(store =&gt; store.appDb.appBaseUrl)
            .take(1)
            .mergeMap(baseUrl =&gt; {
                const url = `${baseUrl}?command=GetCustomers&amp;resellerUserName=aaa&amp;resellerPassword=aaa`;
                return this.http.get(url)
                    .mergeMap(res =&gt; {
                        var xmlData = res.text()
                        const boundCallback = Observable.bindCallback(this.processXml, (xmlData: any) =&gt; xmlData);
                        return boundCallback(this, xmlData)
                    }).do(d =&gt; console.log(d))
            })
</code></pre>

<p>I used <code>mergeMap()</code> because I want to get the value from the Observable returned by <code>boundCallback()</code>.</p>

<p>Also when using <code>map()</code> you <strong>always need to return a value</strong> that is propagated further. In your example you're not returning anything so you can use just <code>do()</code> to see print what values go through.</p>

<p>Edit:</p>

<p>So this is a simplified version of what you're trying to do.</p>

<pre><code>class A {
    private processXml(context, xmlData, cb) {
        context.parseString(xmlData, {attrkey: 'attr'}, function (err, result) {
            if (err || !result) return cb(null); return cb(result);
        })
    }

    private parseString(str, _, cb) {
        return cb(null, str);
    }

    private mockHttpGet() {
        return Rx.Observable.of({
            text: () =&gt; {
                return 'abc';
            }
        });
    }

    test() {
        return this.mockHttpGet()
            .mergeMap(res =&gt; {
                var xmlData = res.text();
                const boundCallback = Rx.Observable.bindCallback(this.processXml, (xmlData: any) =&gt; xmlData);
                return boundCallback(this, xmlData)
            }).do(d =&gt; console.log(d))
    }
}

let a = new A();
a.test().subscribe(val =&gt; console.log('subscribed result', val));
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/reweraw/2/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/reweraw/2/edit?js,console</a></p>

<p>This demo prints:</p>

<pre><code>abc
subscribe abc
</code></pre>

<p>The <code>BoundCallbackObservable</code> (and this applies to operators as well) do nothing until you subscribe to them. That's why in the debugger you see just raw data.</p>

<p>My demo works as you probably want so check out how am I using <code>mergeMap()</code> to get the actual value from the nested Observable and try to replicate the same logic in you application.</p>
","310726","","310726","","2016-12-28 18:24:20","2016-12-28 18:24:20","","","","7","","","","CC BY-SA 3.0"
"41369318","2","","41366938","2016-12-28 20:32:51","","2","","<p>This pretty much depends on what you want to do but let's say you want to make a <code>TruthyObservable</code> that behaves very much like the default <code>Observable.create(...)</code> but passes only even numbers:</p>

<pre><code>import { Observable, Observer, Subscriber, Subject, Subscription } from 'rxjs';
import 'rxjs/add/operator/filter';

class TruthyObservable&lt;T&gt; extends Observable&lt;T&gt; {

    constructor(subscribe?: &lt;R&gt;(this: Observable&lt;T&gt;, subscriber: Subscriber&lt;R&gt;) =&gt; any) {
        if (subscribe) {
            let oldSubscribe = subscribe;
            subscribe = (obs: Subscriber&lt;any&gt;) =&gt; {
                obs = this.appendOperators(obs);
                return oldSubscribe.call(this, obs);
            };
        }

        super(subscribe);
    }

    private appendOperators(obs: Subscriber&lt;any&gt;) {
        let subject = new Subject();

        subject
            .filter((val: number) =&gt; val % 2 == 0)
            .subscribe(obs);

        return new Subscriber(subject);
    }

}

let o = new TruthyObservable&lt;number&gt;((obs: Observer&lt;number&gt;) =&gt; {
    obs.next(3);
    obs.next(6);
    obs.next(7);
    obs.next(8);
});

o.subscribe(val =&gt; console.log(val));
</code></pre>

<p>This prints to console:</p>

<pre><code>6
8
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/recuto/3/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/recuto/3/edit?js,console</a></p>

<p>Usually classes inheriting <code>Observable</code> override the <code>_subscribe()</code> method that actually makes the subscription internally but in ours case we want to use the callback where we can emit values by ourselves (since this Observable doesn't emit anything itself). Method <code>_subscribe()</code> is overshadowed by <code>_subscribe</code> property if it exists so we wouldn't be able to append any operators to it if we just overrode this method. That's why I wrap <code>_subscribe</code> in the constructor with another function and then pass all values through a <code>Subject</code> chained with <code>filter()</code> in <code>appendOperators()</code> method. Note that I replaced the original Observer with the <code>Subject</code> at <code>obs = this.appendOperators(obs)</code>.</p>

<p>At the end when I call eg. <code>obs.next(3);</code> I'm in fact pushing values to the <code>Subject</code> that filters them and passes them to the original <code>Observer</code>.</p>
","310726","","310726","","2016-12-28 20:38:09","2016-12-28 20:38:09","","","","0","","","","CC BY-SA 3.0"
"41369546","1","41370012","","2016-12-28 20:51:50","","0","777","<p>Will this Observable create a memory leak?
becuase every time you run it, it will keep the initial select stream open?!?!</p>

<pre><code>return this.store.select(store =&gt; store.appDb.appBaseUrl)                          
            .mergeMap(url =&gt; {
                return this.http.get(url)
                    .debug('received ' + url)
                    .map(res =&gt; res.json())
            })
</code></pre>

<p>and if so, will adding a take(1) fix it?</p>

<pre><code>return this.store.select(store =&gt; store.appDb.appBaseUrl)                          
               .take(1) // &lt;--------------- stop after 1?
               .mergeMap(url =&gt; {
                return this.http.get(url)
                    .debug('received ' + url)
                    .map(res =&gt; res.json())
            })
</code></pre>

<p>tx Sean</p>
","2040670","","","","","2016-12-28 21:32:42","Will this Observable create a memory leak?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41370012","2","","41369546","2016-12-28 21:32:42","","1","","<p>Simply having an hot observable <code>this.store.select</code> does not immediately imply that you have a memory leak. It is your task to store a reference to your subscription on that observable and dispose of it when done.</p>

<p>I find it helpful to annotate my streams with <code>.take(X)</code> as the last thing i do when i know how many elements i expect because this will make the stream dispose automatically after emitting the expected amount.</p>

<pre><code>return this.store.select(store =&gt; store.appDb.appBaseUrl)                          
  .mergeMap(url =&gt; this.http.get(url)
    .debug('received ' + url)
    .map(res =&gt; res.json())
  )
  .take(1)
</code></pre>
","106909","","","","","2016-12-28 21:32:42","","","","1","","","","CC BY-SA 3.0"
"41380720","2","","41362712","2016-12-29 13:26:37","","8","","<p>Make sure you import the <code>retry</code>-operator with <code>import ""rxjs/add/operator/retry"";</code></p>
","1518765","","","","","2016-12-29 13:26:37","","","","0","","","","CC BY-SA 3.0"
"41382789","1","41382912","","2016-12-29 15:38:15","","0","956","<p>How do i serialize an rxjs observable returned by an http call to my business object? sample is mentioned below </p>

<p>myData.json:</p>

<pre><code>[{
    ""prop1"" : ""val1"",
    ""prop2"" : ""val2"",
    ""prop3"" : ""val3"",
    ""prop4"" : ""val4"",
  }, {
    ""prop1"" : ""val11"",
    ""prop2"" : ""val22"",
    ""prop3"" : ""val33"",
    ""prop4"" : ""val44"",
  },......]
</code></pre>

<p>Observable:</p>

<pre><code> this.myData$ = this._http.get('/data/myData.json')
                  .map(response =&gt; &lt;any[]&gt;response.json());
</code></pre>

<p>template: </p>

<pre><code> &lt;ul&gt;
  &lt;li class=""text"" *ngFor=""let item of myData$ | async""&gt;
    {{item.prop1}} - {{item.prop2}} - {{item.prop3}}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>everything works great with the above code, but i need to transform the JSON objects received asynchronously to instances of a different business objects and still bind asynchronously to the template. How do i achieve this. which rxjs operator let me achieve this?</p>

<p>My business class is: </p>

<pre><code>export class Custom {

    prop10: string;
    prop20: string;

    constructor(data) {
        this.prop10 = this.evaluate(data.prop1);
        this.prop20 = data.prop2;

    }
    private evaluate(val): string {
        // do some custom business rules....
        return ""something"";
    }
}
</code></pre>

<p>my actual template</p>

<pre><code>&lt;ul&gt;
  &lt;li class=""text"" *ngFor=""let item of myData$ | async""&gt;
    {{item.prop10}} - {{item.prop20}}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
","4176253","","","","","2016-12-29 15:45:38","Serializing rxjs Observable to custom business objects","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41382912","2","","41382789","2016-12-29 15:45:38","","1","","<p>A simple additional <code>.map</code>, where you map each array-entry inside should work:</p>

<pre><code>this.myData$ = this._http.get('/data/myData.json')
                  .map(response =&gt; &lt;any[]&gt;response.json())
                  .map(items =&gt; items.map(item =&gt; new Custom(item));
</code></pre>
","1518765","","","","","2016-12-29 15:45:38","","","","1","","","","CC BY-SA 3.0"
"41387633","1","","","2016-12-29 21:45:46","","3","542","<p>Okay, so I would like to avoid recursion with observables, using a combination of external and internal events instead of recalling the same method/function.</p>

<p>Right now I have this:</p>

<pre><code>Queue.prototype.deq = function (opts) {

    opts = opts || {};

    const noOfLines = opts.noOfLines || opts.count || 1;
    const isConnect = opts.isConnect !== false;

    let $dequeue = this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    if(obj.error){

                    // if there is an error acquiring the lock we
                    // retry after 100 ms, which means using recursion
                    // because we call ""this.deq()"" again

                        return Rx.Observable.timer(100)
                            .flatMap(() =&gt; this.deq(opts));
                    }
                    else{
                        return makeGenericObservable()
                          .map(() =&gt; obj);
                    }
                })

        })
        .flatMap(obj =&gt; {
            return removeOneLine(this)
                .map(l =&gt; ({l: l, id: obj.id}))
        })
        .flatMap(obj =&gt; {
            return releaseLock(this, obj.id)
                .map(() =&gt; obj.l)
        })
        .catch(e =&gt; {
            console.error(e.stack || e);
            return releaseLock(this);
        });

    if (isConnect) {
        $dequeue = $dequeue.publish();
        $dequeue.connect();
    }

    return $dequeue;

};
</code></pre>

<p>instead of the above, which uses recursion (hopefully correctly), I'd like to use a more evented approach. If there is an error passed back from the acquireLock function, I would like to retry every 100ms, as soon as it succeeds I want to stop, I am not sure how to do this, and it's difficult for me to test it....is this about right?</p>

<pre><code>Queue.prototype.deq = function (opts) {

    // ....

    let $dequeue = this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    if(obj.error){
                        return Rx.Observable.interval(100)
                            .takeUntil(
                                acquireLock(this)
                                .filter(obj =&gt; !obj.error)
                            )
                    }
                    else{

                        // this is just an ""empty"" observable
                        // which immediately fires onNext()

                        return makeGenericObservable()
                              .map(() =&gt; obj);
                    }
                })

        })

     // ...

    return $dequeue;

};
</code></pre>

<p>Is there a way to make that more concise? I also would like to only retry 5 times or so. My primary question is - <em>How can I also create a count alongside the interval, so that every 100 ms I retry, until either the lock is acquired or a count reaches 5?</em></p>

<p>I need something like this:</p>

<pre><code>.takeUntil(this or that)
</code></pre>

<p>perhaps I can simply chain the takeUntils, like so:</p>

<pre><code>                   return Rx.Observable.interval(100)
                    .takeUntil(
                        acquireLock(this)
                        .filter(obj =&gt; !obj.error)
                    )
                    .takeUntil(++count &lt; 5);
</code></pre>

<p>I could do this:</p>

<pre><code>                return Rx.Observable.interval(100)
                    .takeUntil(
                        acquireLock(this)
                        .filter(obj =&gt; !obj.error)
                    )
                    .takeUntil( Rx.Observable.timer(500));
</code></pre>

<p>But probably looking for something a little less kludgy</p>

<p>But I don't know where to (store / keep track of) the <code>count</code> variable...</p>

<p>Also looking to make this more concise and possibly check it for correctness.</p>

<p>I have to say, if this stuff works, it's very powerful coding constructs.</p>
","1223975","","1223975","","2016-12-29 22:15:13","2016-12-30 08:13:09","Avoid recursion with RxJS5 observables","<recursion><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41389447","1","41391042","","2016-12-30 01:26:06","","1","625","<p>I have a simple RxJS5 observable like so:</p>

<pre><code>function foo(){

 return Rx.Observable.create(obs =&gt; {
          obs.next();
   });

}
</code></pre>

<p>the observable is created like so:</p>

<pre><code>const x = foo();

function bar(){

     return someObs()
       .flatMap(() =&gt; x.wait(5))  // wait for x to fire 5 times
       .map(v =&gt; ({z:v}));

}
</code></pre>

<p>What I want to do is wait for 5 events in the x observable to fire, before continuing.</p>

<p>I don't think the <code>take</code> operator is what I want, so I just called the operator ""<code>wait</code>""</p>

<p>How can I do that with RxJS5?</p>
","1223975","","","","","2016-12-30 05:23:05","RxJS - Wait until 5 events to occur before continuing","<javascript><node.js><rxjs><observable><rxjs5>","2","2","","","","CC BY-SA 3.0"
"41389688","1","41390980","","2016-12-30 02:05:16","","9","8207","<p>I'm filtering an <code>Observable</code> with the input of another <code>Observable</code> - the input for the filtering comes from the user.</p>

<p>The filtering is done with the RxJS operator <code>combineLatest</code>. Using this means that when subscribing to this stream, no values are emitted until there has been an emission from both source Observables - I'd like the created stream to emit on creation (without any filtering), before any user input takes place.</p>

<p>I think I should be using the <a href=""http://reactivex.io"" rel=""noreferrer""><code>startWith</code></a> operator so the stream has an emission on creation, but I can't work out how to seed this from an Observable. Using an Observable because data comes from Firebase and is handled with <code>FirebaseListObservable</code>'s.</p>

<p>Below is a pieced-together version of what I'm doing currently.</p>

<pre><code>let tagInput = document.getElementById('tags');
let tagExclusionStream = Observable
  .fromEvent(tagInput, 'input')
  .map((e: any) =&gt; createsArrayFromInput(e.target.value));

let allTags: Observable&lt;any[]&gt; = getAllTags();

let filteredTags = allTags
  .combineLatest(tagExclusionStream, (tags, tagExclusions) =&gt; {
     return tags.filter((tag: any) =&gt; tagExclusions.indexOf(tag.$key) == -1)
  });

// I want this to print out without needing the tagExclusionStream to emit first 
filteredTags.subscribe(tags =&gt; console.log(""Tags:"", tags))
</code></pre>

<p>Please let me know if my approach here is completely off/there's a better way as I'm new to RxJS.</p>
","2080491","","","","","2020-06-16 16:54:03","Creating an Observable using startWith from an Observable","<angular><rxjs><rxjs5>","2","0","3","","","CC BY-SA 3.0"
"41390980","2","","41389688","2016-12-30 05:17:16","","4","","<p>I think this will do the trick:</p>

<pre><code>let filteredTags = allTags
  .combineLatest(tagExclusionStream.startWith(''), (tags, tagExclusions) =&gt; {
     return tags.filter((tag: any) =&gt; tagExclusions.indexOf(tag.$key) == -1)
  });
</code></pre>

<p>Alternatively, if you use <code>tagExclusionStream</code> in different places you can do this:</p>

<pre><code>let tagExclusionStream = Observable
  .fromEvent(tagInput, 'input')
  .map((e: any) =&gt; createsArrayFromInput(e.target.value))
  .startWith('');
</code></pre>
","1010664","","","","","2016-12-30 05:17:16","","","","1","","","","CC BY-SA 3.0"
"41391042","2","","41389447","2016-12-30 05:23:05","","2","","<p>The operator you are looking for is <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-skip"" rel=""nofollow noreferrer"">skip</a></p>

<pre><code> return someObs()
   .skip(5)
   .map(v =&gt; ({z:v}));
</code></pre>
","1010664","","","","","2016-12-30 05:23:05","","","","0","","","","CC BY-SA 3.0"
"41392124","1","41398170","","2016-12-30 07:05:06","","0","1373","<p>So this code runs, but it's firing the callback in .flatmap 5 times:</p>

<pre><code>        var i = 0;
        const values = {};
        return this.obsClient.take(5)
            .flatMap(v =&gt; {
                const time = Date.now();
                values[i] = {time: time, count: v.clientCount};
                console.log('values =&gt; ', values);
                i++;
                return Rx.Observable.timer(100)
            });
</code></pre>

<p>""values => x"" will get logged 5 times.</p>

<p>I thought maybe if I did the following, it would to accumulate all 5 pieces of data before firing the flatMap callback:</p>

<pre><code>      var i = 0;
      const values = {};
      return this.obsClient.take(5).takeLast(5)
        .flatMap(v =&gt; {
            const time = Date.now();
            values[i] = {time: time, count: v.clientCount};
            console.log('values =&gt; ', values);
            i++;
            return Rx.Observable.timer(100)
        });
</code></pre>

<p>but it still logs ""values => x"" 5 times. <em>How can I accumulate the data, and pass all the data to the callback and avoid firing the callback 5 times?</em></p>
","1223975","","","","","2016-12-30 15:33:09","RxJS - how to accumulate data and act on it, without multiple callbacks","<javascript><node.js><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41393467","1","41398067","","2016-12-30 09:04:41","","2","342","<p>In one of my projects, I have the following code, and upon migrating to RxJS5, Rx.Observer seems to no longer be defined:</p>

<pre><code>let index = 0;

let obsEnqueue = this.obsEnqueue = new Rx.Subject();

this.queueStream = Rx.Observable.create(obs =&gt; {
    var push = Rx.Observer.create(v =&gt; {             // ! error
        if ((index % obsEnqueue.observers.length) === obsEnqueue.observers.indexOf(push)) {
            obs.next(v);
        }
    });
    return obsEnqueue.subscribe(push);
});

this.push = (v) =&gt; {
    obsEnqueue.next(v);
    index++;
};
</code></pre>

<p>this no longer works because <code>Rx.Observer</code> is not defined </p>

<p>in the migration guide:</p>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md</a></p>

<p>it says:</p>

<blockquote>
  <p>Observer is an interface now</p>
</blockquote>

<p>However, that shouldn't meant that Rx.Observer, even if it's an interface, shouldn't have a ""static"" method, called create.</p>

<p>Anyway, <code>Rx.Observer</code> doesn't seem to exist anymore.
I get this error:</p>

<pre><code>TypeError: Cannot read property 'create' of undefined
</code></pre>

<p>How can I create an Observer somehow yielding similar results to my code above?</p>
","1223975","","1223975","","2016-12-30 10:08:14","2016-12-31 09:35:24","Migrating from RxJS4 to RxJS5 - implementing an Observer","<javascript><node.js><rxjs><rxjs5>","4","0","","","","CC BY-SA 3.0"
"41398067","2","","41393467","2016-12-30 14:45:05","","1","","<p>From the source:</p>

<pre><code>export interface Observer&lt;T&gt; {
  closed?: boolean;
  next: (value: T) =&gt; void;
  error: (err: any) =&gt; void;
  complete: () =&gt; void;
}
</code></pre>

<p><code>Observer&lt;T&gt;</code> is an interface with the <code>onNext</code>, <code>onCompleted</code> and <code>onError</code> method. An interface is only a language construct. It is merely used by the typescript compiler to type-check objects requiring an <code>Observer&lt;T&gt;</code>. It is erased on compilation.</p>

<p>The class <code>Subscriber&lt;T&gt;</code> implements the interface <code>Observer&lt;T&gt;</code>.
It means that <code>Subscriber&lt;T&gt;</code> is the actual concrete class with the above methods.</p>

<p>So you use <code>var push = Rx.Subscriber.create(v =&gt; {  [...]</code> instead.</p>

<p>Note:</p>

<p>In the original Rx implementation, the interfaces were <code>IObservable&lt;T&gt;</code> and <code>IObserver&lt;T&gt;</code> and used extension methods to allow composition. When it came to JS, they had to have methods on the prototype of <code>Observable</code> / <code>Observer</code> itself to enable composition - so the class itself had the methods. </p>
","802116","","","","","2016-12-30 14:45:05","","","","7","","","","CC BY-SA 3.0"
"41398170","2","","41392124","2016-12-30 14:53:27","","3","","<p>If you only want the last five items in the sequence at once:</p>

<pre><code>  return this.obsClient
              .takeLast(5)
              .toArray()
              .flatMap(arr =&gt; { /*arr will be an array of the last five items in the sequence */ })
</code></pre>
","802116","","","","","2016-12-30 14:53:27","","","","0","","","","CC BY-SA 3.0"
"41402798","1","41403018","","2016-12-30 21:14:38","","4","3460","<p>Ok so there seems to be a lot of answers to this question but I haven't been able to comprehend what I should do.</p>

<p>I currently have a child component that is being created when someone clicks a play button from another child component. This is happening through a service which shares the data with my parent and then the parent passes the data and creates my child audio-player component. The problem I'm having is if the user navigates to another page and clicks to play the audio on that page the old audio still persists and the new audio doesn't start. </p>

<p>Is there a lifecycle hook or a method I could use to destroy my old audio component and create a new audio onclick?</p>

<p>Info Box - Where the initial activation happens when play button is clicked.</p>

<pre><code>export class InfoBoxComponent implements OnInit {
  ...

  activateAudioPlayer(session) {
    this.newAudioService.newAudio(session)
  }
}
</code></pre>

<p>New Audio Service</p>

<pre><code>export class NewAudioService {
  newActiveAudioSource: Subject&lt;string&gt; = new Subject&lt;string&gt;();

  newAudio(session) {
    this.newActiveAudioSource.next(session);
  }

  newActiveAudio$ = this.newActiveAudioSource.asObservable();
}
</code></pre>

<p>Frontend Component - Parent Component of Info Box and Audio Player</p>

<pre><code>@Component({ 
   template: `&lt;audio-player *ngIf='newActiveAudio' [newActiveAudio]='newActiveAudio'&gt;&lt;/audio-player&gt;`,
})

export class FrontendComponent implements OnInit {

  ...

  ngOnInit() {
    this.sub = this.newAudioService.newActiveAudio$.subscribe(
      newActiveAudio =&gt; {
        this.newActiveAudio = newActiveAudio;
      });
  }

  ngOnDestroy() {
    // prevent memory leak when component destroyed
    this.sub.unsubscribe();
  }
}
</code></pre>
","3561677","","310726","","2016-12-30 21:43:27","2020-04-10 11:42:40","Recreating a component when data changes","<angular><typescript><rxjs><rxjs5>","3","4","1","","","CC BY-SA 3.0"
"41403018","2","","41402798","2016-12-30 21:41:19","","4","","<p>A possible way could be setting <code>this.newActiveAudio = false</code> then letting Angular update the view with <code>setTimeout()</code> and then set the new value for <code>newActiveAudio</code>:</p>

<pre><code>this.sub = this.newAudioService.newActiveAudio$.subscribe(newActiveAudio =&gt; {
    this.newActiveAudio = false;
    setTimeout(() =&gt; {
        this.newActiveAudio = newActiveAudio;
    });
});
</code></pre>
","310726","","","","","2016-12-30 21:41:19","","","","2","","","","CC BY-SA 3.0"
"41403373","1","41403749","","2016-12-30 22:18:02","","0","45","<p>I am trying to figure out how to avoid recursion (if possible). I am using RxJS to create methods on a queue. The drain method calls itself recursively, if the queue is not empty. The drain method is currently designed to remove one item at a time from the queue, until it's empty. The following seems to work for this purpose, but I'd like to find out if it's possible to avoid calling drain recursively. The problem with recursion is that I probably cannot ""return"" any items from the resursive method until it's done recursing (that's my guess).</p>

<p>So my question is:</p>

<p>I want the subscriber of drain() to receive each item from the queue separately, instead of receiving all drained items from the queue at once when the method is done recursing. How can I accomplish that? Can I accomplish this with a recursive method, or perhaps I can only accomplish this with a non-recursive method? If the latter, how to do that?</p>

<blockquote>
  <p>this method will drain the queue, and stop trying when the queue is
  empty we need to lock, remove an item, then unlock, every time, so
  it's easiest to just use recursion and re-call the drain method if the
  queue is not empty</p>
</blockquote>

<pre><code>Queue.prototype.drain = function (opts) {

    opts = opts || {};
    const delay = opts.delay || 500;

    return this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    return acquireLockRetry(obj)
                });
        })
        .flatMap(obj =&gt; {
            return removeOneLine(this)
                .flatMap(l =&gt; {
                    return releaseLock(this, obj.id)
                        .map(obj =&gt; l);
                });
        })
        .flatMap(() =&gt; {
            return Rx.Observable.timer(delay)
                .flatMap(() =&gt; {
                    return this.drain()   /// &lt;&lt;&lt; recurse
                        .takeUntil(this.isEmpty());  /// &lt;&lt;&lt;&lt; until
                });
        })
        .catch(e =&gt; {
            const force = !String(e.stack || e).match(/acquire lock timed out/);
            return releaseLock(this, force);
        });

};
</code></pre>

<blockquote>
  <p>// check if the queue is empty</p>
</blockquote>

<pre><code>Queue.prototype.isEmpty = function () {

    return this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    return acquireLockRetry(obj)
                })
        })
        .flatMap(obj =&gt; {
            return findFirstLine(this)
                .flatMap(l =&gt; {
                    return releaseLock(this, obj.id)
                        .map(obj =&gt; l);
                });
        })
        .filter(l =&gt; {
            // filter out any lines =&gt; only fire event if there is no line
            return !l;
        })
        .catch(e =&gt; {
            const force = !String(e.stack || e).match(/acquire lock timed out/);
            return releaseLock(this, force);
        });

};
</code></pre>
","1223975","","","","","2016-12-30 22:59:37","Avoiding recursion with RxJS5 in simple use case","<javascript><node.js><recursion><rxjs5>","1","5","","","","CC BY-SA 3.0"
"41403749","2","","41403373","2016-12-30 22:59:37","","0","","<p>One possible solution to the problem is something like this:</p>

<pre><code>    const obs = new Rx.Subject();

    q.drain(obs).subscribe(function (v) {
        console.log('end result =&gt; ', v);
    });

    obs.subscribe(function (v) {
        console.log('next item that was drained =&gt; ', v);
    });
</code></pre>

<p>and the drain method just becomes:</p>

<pre><code>Queue.prototype.drain = function (obs, opts) {

    opts = opts || {};

    const delay = opts.delay || 500;

    return this.init()
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    console.log(' drain lock id =&gt; ', obj.id);
                    return acquireLockRetry(obj)
                });
        })
        .flatMap(obj =&gt; {
            return removeOneLine(this)
                .flatMap(l =&gt; {
                    return releaseLock(this, obj.id)
                        .map(obj =&gt; {
                            obs.next(l);
                            return l;
                        });
                });
        })
        .flatMap(() =&gt; {
            return Rx.Observable.timer(500)
                .flatMap(() =&gt; {
                    return this.drain(obs, opts)
                        .takeUntil(this.isEmpty());
                });
        })
        .catch(e =&gt; {
            console.error('\n', ' =&gt; isEmpty() error =&gt; \n', e.stack || e);
            const force = !String(e.stack || e).match(/acquire lock timed out/);
            return releaseLock(this, force);
        });

};
</code></pre>

<p>in this way, everytime an item is removed, it will fire something, and then hopefully fire an event at the very end, when the queue is completely drained.</p>
","1223975","","","","","2016-12-30 22:59:37","","","","0","","","","CC BY-SA 3.0"
"41408756","1","41409409","","2016-12-31 13:34:45","","1","425","<p>I have an observable that will subscribe as usual:</p>

<pre><code>  return oMassChangeOb
    .subscribe(function (aMassDates) {
      const oModel = self.getModel(""vmCalSpecialDates"");
      oModel.setProperty(""/aActualDates"", aMassDates);
    }, function (oErr) {
      jQuery.sap.log.fatal(oErr);
    });
</code></pre>

<p>My question is, how to run an other observable as soon as the above observable has been subscribed?  </p>

<p>I could do it as follow:</p>

<pre><code>  return oMassChangeOb
    .subscribe(function (aMassDates) {
      const oModel = self.getModel(""vmCalSpecialDates"");
      oModel.setProperty(""/aActualDates"", aMassDates);
      oSaveCancelFooterStateOb
        .subscribe(function (oBtnState) {
          const oModel = self.getModel(""vmButtonsState"");
          oModel.setProperty(""/bSave"", oBtnState.bSave);
          oModel.setProperty(""/bCancel"", oBtnState.bCancel)
        });
    }, function (oErr) {
      jQuery.sap.log.fatal(oErr);
    });
</code></pre>

<p>But I do not know, if it is the right way to go.</p>

<p>There is a <a href=""http://reactivex.io/rxjs/class/es6/Notification.js~Notification.html#static-method-createNext"" rel=""nofollow noreferrer"">notification object</a> that could be solve the scenario, but do not know how to use it. </p>
","1743843","","1743843","","2016-12-31 13:49:31","2016-12-31 15:07:38","Wait until an other observable subscribe next","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41409409","2","","41408756","2016-12-31 15:07:38","","2","","<p>From what you are writing, you basically want to run the second observable after the first one finishes, in that case, just chain both into a stream:</p>

<pre><code>return oMassChangeOb
    .do(function (aMassDates) {
      const oModel = self.getModel(""vmCalSpecialDates"");
      oModel.setProperty(""/aActualDates"", aMassDates);
    })
    .switchMapTo(oSaveCancelFooterStateOb)
    .do((oBtnState) =&gt; {
      const oModel = self.getModel(""vmButtonsState"");
      oModel.setProperty(""/bSave"", oBtnState.bSave);
      oModel.setProperty(""/bCancel"", oBtnState.bCancel)
    }).subscribe(
        undefined,
        onErr =&gt; jQuery.sap.log.fatal(oErr)
    );
</code></pre>

<hr>

<p>If the order doesn't matter you can take both streams and use <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/merge.md"" rel=""nofollow noreferrer""><code>merge</code></a>:</p>

<pre><code>Rx.Observable.merge(oMassChangeOb, oSaveCancelFooterStateOb)
    .subscribe(
        undefined,
        onErr =&gt; jQuery.sap.log.fatal(oErr)
    );
</code></pre>

<hr>

<p>As a general note: Try to move as much logic as you can into the stream itself(e.g. by using <code>.do</code> as I did above) and have the subscribe as clean and generic as possible, this will make it much easier to combine(merge, chain, ect..) multiple streams, e.g.:</p>

<pre><code>let preparedOMassChangeOb = oMassChangeOb
    .do(function (aMassDates) {
      const oModel = self.getModel(""vmCalSpecialDates"");
      oModel.setProperty(""/aActualDates"", aMassDates);
    })
    .catch(..some error-handler-logic...);

let preparedOSaveCancelFooterStateOb = oSaveCancelFooterStateOb
    .do((oBtnState) =&gt; {
      const oModel = self.getModel(""vmButtonsState"");
      oModel.setProperty(""/bSave"", oBtnState.bSave);
      oModel.setProperty(""/bCancel"", oBtnState.bCancel)
    });

Rx.Observable.merge(
    preparedOMassChangeOb,
    preparedOSaveCancelFooterStateOb
).subscribe();
</code></pre>
","1518765","","","","","2016-12-31 15:07:38","","","","0","","","","CC BY-SA 3.0"
"41410452","1","41414370","","2016-12-31 17:30:48","","1","177","<p>In RxJS version 4 there was the method hasObservers on Subjects which seems to have been removed and I am trying to migrate.  This method removal is not listed on the how to migrate page.</p>

<pre><code>hasObservers: function () { checkDisposed(this); return this.observers.length &gt; 0; }
</code></pre>

<p>What is another solution to get a boolean if a subject has a subscriber before next is called?</p>
","3790927","","310726","","2017-01-01 10:15:00","2017-01-01 10:15:00","What replaces Subject.prototype.hasObservers","<javascript><typescript><rxjs5>","2","0","0","","","CC BY-SA 3.0"
"41411811","1","41414751","","2016-12-31 21:23:56","","1","182","<p>I have the following:</p>

<pre><code>static phones: Map&lt;number, {}&gt; = new Map&lt;number, {}&gt;();
...

  Observable.combineLatest(
        this.form.statusChanges,
        this.form.valueChanges,
        ( status, value ) =&gt; ({ status, value }) )
              .debounceTime( 500 )
              .subscribe(
                  ( { status, value } ) =&gt; {

                        PhoneComponent.phones.set( this.rowIndex, value );
}
</code></pre>

<p>When the form becomes valid for the first time, the map values are set with no problems. However, if I should change on value in the form again I get the following exception (PhoneComponent is my custom component in which combineLatest is being used)</p>

<pre><code>Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.
error_handler.js:47 EXCEPTION: PhoneComponent_1.phones.set is not a function
ErrorHandler.handleError @ error_handler.js:47
next @ application_ref.js:272
schedulerFn @ async.js:82
SafeSubscriber.__tryOrUnsub @ Subscriber.js:223
SafeSubscriber.next @ Subscriber.js:172
Subscriber._next @ Subscriber.js:125
Subscriber.next @ Subscriber.js:89
Subject.next @ Subject.js:55
EventEmitter.emit @ async.js:74
NgZone.triggerError @ ng_zone.js:278
onHandleError @ ng_zone.js:257
ZoneDelegate.handleError @ zone.js:236
Zone.runTask @ zone.js:157
ZoneTask.invoke @ zone.js:335
data.args.(anonymous function) @ zone.js:970
error_handler.js:52 ORIGINAL STACKTRACE:
ErrorHandler.handleError @ error_handler.js:52
next @ application_ref.js:272
schedulerFn @ async.js:82
SafeSubscriber.__tryOrUnsub @ Subscriber.js:223
SafeSubscriber.next @ Subscriber.js:172
Subscriber._next @ Subscriber.js:125
Subscriber.next @ Subscriber.js:89
Subject.next @ Subject.js:55
EventEmitter.emit @ async.js:74
NgZone.triggerError @ ng_zone.js:278
onHandleError @ ng_zone.js:257
ZoneDelegate.handleError @ zone.js:236
Zone.runTask @ zone.js:157
ZoneTask.invoke @ zone.js:335
data.args.(anonymous function) @ zone.js:970
error_handler.js:53 TypeError: PhoneComponent_1.phones.set is not a function
    at SafeSubscriber.__WEBPACK_IMPORTED_MODULE_2_rxjs__.Observable.combineLatest.debounceTime.subscribe [as _next] (phone.component.ts:137)
    at SafeSubscriber.__tryOrUnsub (Subscriber.js:223)
    at SafeSubscriber.next (Subscriber.js:172)
    at Subscriber._next (Subscriber.js:125)
    at Subscriber.next (Subscriber.js:89)
    at DebounceTimeSubscriber.debouncedNext (debounceTime.js:98)
    at AsyncAction.dispatchNext (debounceTime.js:114)
    at AsyncAction._execute (AsyncAction.js:111)
    at AsyncAction.execute (AsyncAction.js:86)
    at AsyncScheduler.flush (AsyncScheduler.js:36)
ErrorHandler.handleError @ error_handler.js:53
next @ application_ref.js:272
schedulerFn @ async.js:82
SafeSubscriber.__tryOrUnsub @ Subscriber.js:223
SafeSubscriber.next @ Subscriber.js:172
Subscriber._next @ Subscriber.js:125
Subscriber.next @ Subscriber.js:89
Subject.next @ Subject.js:55
EventEmitter.emit @ async.js:74
NgZone.triggerError @ ng_zone.js:278
onHandleError @ ng_zone.js:257
ZoneDelegate.handleError @ zone.js:236
Zone.runTask @ zone.js:157
ZoneTask.invoke @ zone.js:335
data.args.(anonymous function) @ zone.js:970
phone.component.ts:137 Uncaught TypeError: PhoneComponent_1.phones.set is not a function
    at SafeSubscriber.__WEBPACK_IMPORTED_MODULE_2_rxjs__.Observable.combineLatest.debounceTime.subscribe [as _next] (phone.component.ts:137)
    at SafeSubscriber.__tryOrUnsub (Subscriber.js:223)
    at SafeSubscriber.next (Subscriber.js:172)
    at Subscriber._next (Subscriber.js:125)
    at Subscriber.next (Subscriber.js:89)
    at DebounceTimeSubscriber.debouncedNext (debounceTime.js:98)
    at AsyncAction.dispatchNext (debounceTime.js:114)
    at AsyncAction._execute (AsyncAction.js:111)
    at AsyncAction.execute (AsyncAction.js:86)
    at AsyncScheduler.flush (AsyncScheduler.js:36)
__WEBPACK_IMPORTED_MODULE_2_rxjs__.Observable.combineLatest.debounceTime.subscribe @ phone.component.ts:137
SafeSubscriber.__tryOrUnsub @ Subscriber.js:223
SafeSubscriber.next @ Subscriber.js:172
Subscriber._next @ Subscriber.js:125
Subscriber.next @ Subscriber.js:89
DebounceTimeSubscriber.debouncedNext @ debounceTime.js:98
dispatchNext @ debounceTime.js:114
AsyncAction._execute @ AsyncAction.js:111
AsyncAction.execute @ AsyncAction.js:86
AsyncScheduler.flush @ AsyncScheduler.js:36
ZoneDelegate.invokeTask @ zone.js:265
onInvokeTask @ ng_zone.js:227
ZoneDelegate.invokeTask @ zone.js:264
Zone.runTask @ zone.js:154
ZoneTask.invoke @ zone.js:335
data.args.(anonymous function) @ zone.js:970
</code></pre>
","2258442","","2258442","","2017-01-01 02:08:52","2017-01-01 10:21:29","combineLatest error from repeat input of valid form values","<angular><angular2-forms><rxjs5><typescript2.0>","1","1","","","","CC BY-SA 3.0"
"41414370","2","","41410452","2017-01-01 08:59:17","","1","","<p>It seems there is no analog for this function in rxjs 5. But you can add your own:</p>

<pre class=""lang-js prettyprint-override""><code>Subject.prototype.hasObservers = function hasObservers() {
    if (this.closed) {
        throw new ObjectUnsubscribedError();
    }

    return this.observers.length &gt; 0;
};
</code></pre>
","1010664","","","","","2017-01-01 08:59:17","","","","0","","","","CC BY-SA 3.0"
"41414751","2","","41411811","2017-01-01 10:21:29","","1","","<p>The error says what's wrong:</p>

<blockquote>
  <p>phone.component.ts:137 Uncaught TypeError: PhoneComponent_1.phones.set is not a function</p>
</blockquote>

<p>So the problem is not in <code>combineLatest</code>.</p>

<p>Your <code>phones</code> property is set (it's not <code>null</code>) but doesn't have <code>set</code> method. <code>Map.set</code> should exist so it looks like <code>phones</code> is not what you think it is (maybe you override it somewhere unintentionally).</p>

<pre><code>class A {
    static m: Map&lt;number, {}&gt; = new Map&lt;number, {}&gt;();
}

A.m.set(1, {'a': 123});
A.m.set(2, {'a': 321});

console.log(A.m);
</code></pre>

<p>The example above works but have a look where you call the <code>Observable.combineLatest</code> because if you look at the compiled JS you'll see that you might call <code>Observable.combineLatest</code> before the static properties are initialized:</p>

<pre><code>var A = (function () {
    function A() {
    }
    return A;
}());
A.m = new Map();
A.m.set(1, { 'a': 123 });
A.m.set(2, { 'a': 321 });
console.log(A.m);
</code></pre>
","310726","","","","","2017-01-01 10:21:29","","","","1","","","","CC BY-SA 3.0"
"41418953","1","41419064","","2017-01-01 20:55:24","","1","503","<p>What is the best way to get entire url content in angular 2. Basically i need params and queryParams. Right now i am stuck here : </p>

<pre><code>ngOnInit() {
this.activatedRoute.queryParams.subscribe(queryParam =&gt;{
  console.log(queryParam);
});
this.activatedRoute.params.subscribe(params =&gt;{
  const category = params['category'];
  this.seoService.setTitle(category);

  // This is wrong because i also need queryParams here
  this.categoryService.updateCategory(category);

     });
   }
}
</code></pre>

<p>This is the best that i could come up with. 
I aim for url`s like this /category-name?page=1&amp;sortBy=something&amp;size=30&amp;sortOrder=ASC&amp;L=UTF-8</p>

<p>I am trying to get the next value out of activatedRoute and assemble an object with all information and then call back-end service. </p>
","5029143","","5029143","","2017-01-01 21:05:53","2017-01-03 15:40:40","Fetch ActivatedRoute param and queryParam in Angular 2","<angular><rxjs5>","2","0","0","","","CC BY-SA 3.0"
"41419064","2","","41418953","2017-01-01 21:09:03","","1","","<p>You can get both with combineLatest:</p>

<pre><code>Rx.Observable.combineLatest(
    this.activatedRoute.queryParams,
    this.activatedRoute.params)
.subscribe(([queryParam, params]) =&gt; {
    ...
});
</code></pre>
","1010664","","","","","2017-01-01 21:09:03","","","","0","","","","CC BY-SA 3.0"
"41430500","1","41430610","","2017-01-02 16:49:00","","1","436","<p>I'm confused about something, which I assume is fundamental about reactive programming, so I'm looking for some clarification.</p>

<p>Why does example #1 work, but example #2 fail horribly?</p>

<p><strong>Example #1:</strong></p>

<p>Component</p>

<pre><code>export class AppComponent {
  weeklyCount: Observable&lt;number&gt;[];

  constructor(private service: MyService) {
    this.weeklyCount = [service.getCountByDay(""12/18/2016""),service.getCountByDay(""12/28/2016"")];
  }
</code></pre>

<p>Template</p>

<pre><code>&lt;ul&gt;
  &lt;li class=""text"" *ngFor=""let count of weeklyCount ""&gt;
    {{ count | async }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p><strong>Example #2</strong></p>

<p>Component</p>

<pre><code>export class AppComponent {

  constructor(private service: MyService) {
  }

  thisWeeksCount(): Observable&lt;number&gt;[] {
    var a =  this.service.getCountByDay(""12/18/2016""); 
    var b =  this.service.getCountByDay(""12/28/2016""); 
    return [a,b];
  }
</code></pre>

<p>Template</p>

<pre><code>&lt;ul&gt;
  &lt;li class=""text"" *ngFor=""let count of thisWeeksCount()""&gt;
    {{ count | async }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>I'm using AngularFire2 under the covers of the service, but the service is returning rxjs Observables.</p>

<p>Edit: ""fail horribly"" = page doesn't return results, becomes unresponsive until killed, and memory keeps growing. This makes sense based on the accepted answer.</p>
","984655","","984655","","2017-01-02 18:57:33","2017-01-02 18:57:33","Angular2 bind observable function instead of property","<angular><rxjs><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"41430572","1","","","2017-01-02 16:55:36","","3","804","<p>So all of a sudden (well after running npm update) I am getting this new error:</p>

<pre><code>Error:(109, 30) TS2345:Argument of type 'Subject&lt;any&gt;' is not assignable to parameter of type 'Observable&lt;any&gt;'.
  Property 'source' is protected but type 'Observable&lt;T&gt;' is not a class derived from 'Observable&lt;T&gt;'.
</code></pre>

<p>On this code:</p>

<pre><code>private totalPlayersSubject$: Subject&lt;any&gt; = new Subject();
...

items$.takeUntil(this.totalPlayersSubject$).subscribe((x) =&gt; {
                    this.m_stations = List&lt;any&gt;(x);
                    this.cd.markForCheck();
                }
            )
</code></pre>

<p>Any ideas as to why? As I am passing a Subject to takeUntil, which is valid AFAIK...</p>

<p>Thanks,
Sean</p>
","2040670","","2040670","","2017-01-02 17:00:16","2017-01-02 17:01:14","rxjs5 takeUntil does now allow passing of a Subject... TypeScript error","<angular><rxjs><rxjs5>","0","13","","","","CC BY-SA 3.0"
"41430610","2","","41430500","2017-01-02 16:59:10","","3","","<p>I don't know what you mean by ""fail horribly"" but these two aren't the same:</p>

<ol>
<li><p>Creates an array with two Observables that is later iterated in your template.</p></li>
<li><p>Creates a new array with Observables every time the change detection needs to check whether this expression has changed. This means <code>thisWeeksCount()</code> method is going to be called extremely often creating a lot of Observables and probably a lot of requests to your AngularFire2 database.</p></li>
</ol>

<p>So you probably want to use the first option.</p>
","310726","","","","","2017-01-02 16:59:10","","","","1","","","","CC BY-SA 3.0"
"41432346","1","","","2017-01-02 19:31:00","","22","20588","<p>I want to call a function (synchronously) and then use its return value as an initial emission (subsequently chaining some other operators on the resulting observable).</p>
<p>I want to invoke this function during subscription, so I can't just use <code>Observable.of(() =&gt; getSomeValue())</code>. I've seen <code>bindCallback</code> (previously <code>fromCallback</code>) but I don't think it can be used for this task (correct me if I'm wrong). I've seen <code>start</code> static operator in v4 docs but apparently it is not implemented in v5 (and no indication that its on the way). RxJava also has <code>fromCallable</code> operator that does exactly that afaik.</p>
<p>Only way I could think of is like this:</p>
<pre><code>Observable.create((observer: Observer&lt;void&gt;) =&gt; {
  let val = getSomeValue();
  observer.next(val);
  observer.complete();
})
</code></pre>
<p>which I think does just that. But this just seems so complicated for a simple thing that should probably have been like <code>Observable.fromFunction(() =&gt; getSomeValue())</code> And what if I want to run it asynchronously, like <code>start</code> operator does? How can I do this in the current version of RxJS?</p>
","4866988","","74089","","2021-03-10 17:38:24","2021-03-10 17:38:24","How to create Observable from function?","<javascript><rx-java><rxjs><system.reactive><rxjs5>","3","4","5","","","CC BY-SA 4.0"
"41440923","1","41441190","","2017-01-03 10:05:34","","8","7182","<p>Angular2 Observable share is not working and duplicate http calls going</p>

<p><strong>BuildingService.ts</strong></p>

<pre><code>@Injectable()
export class BuildingService {

constructor(private http: Http){       
  }

buildings$: Observable&lt;Building[]&gt;;
this.buildings: Building[];

getData() : Observable&lt;Building[]&gt;{
     this.buildings$ = this.http.get('http://localhost:8080/buildings').share().map(this.extractData);
     this.buildings$.subscribe(buildings =&gt; this.buildings = buildings);
     return this.buildings$;
  }

 private extractData(res: Response) {
    let body = res.json();
    return body;
} 

}
</code></pre>

<p><strong>component1.ts</strong></p>

<pre><code>export class component1 {
constructor( private  buildingService: BuildingService) {}

this.subscription = this.buildingService.getData()
            .subscribe(buildings =&gt; console.log(buildings),
            error =&gt;  this.errorMessage = &lt;any&gt;error);
}
</code></pre>

<p><strong>component2.ts</strong></p>

<pre><code>export class component2 {
constructor( private  buildingService: BuildingService) {}

this.subscription = this.buildingService.getData()
            .subscribe(buildings =&gt; console.log(buildings),
            error =&gt;  this.errorMessage = &lt;any&gt;error);
}
</code></pre>

<p>share is not working, multiple http calls are going. Even I tried code from <a href=""https://stackoverflow.com/a/36291681/2742156"">this link</a></p>

<p>but no use.</p>

<p>Can somebody please let me know how to avoid duplicate http calls with Angular Observable?</p>
","2742156","","-1","","2017-05-23 10:31:11","2017-10-25 08:07:10","Angular2 observable share is not working","<angular><rxjs><observable><angular2-services><rxjs5>","3","5","1","","","CC BY-SA 3.0"
"41441190","2","","41440923","2017-01-03 10:18:50","","21","","<p>I think this is just misunderstanding of what <code>share()</code> does.</p>

<p>When you call <code>this.buildings$.subscribe(...)</code> it makes a <code>ConnectableObservable</code> thanks to <code>share()</code> operator which is immediately followed by <code>connect()</code>.</p>

<p>If you make another subscription while the HTTP request is pending it will just add another Observer to the <code>ConnectableObservable</code> and when the response is ready it'll be sent to both Observers. However if you let <code>this.buildings$</code> to complete and after that you subscribe again it'll make another HTTP request because the <code>ConnectableObservable</code> is not connected to its source.</p>

<p>What you want instead is <code>.publishReplay(1).refCount()</code> (or <code>shareReplay(1)</code> since RxJS 5.4.0) that replays the last item emitted from the source. Very likely you'll also want to append <code>take(1)</code> to properly complete the chain.</p>
","310726","","310726","","2017-10-25 08:07:10","2017-10-25 08:07:10","","","","5","","","","CC BY-SA 3.0"
"41443595","1","","","2017-01-03 12:29:36","","0","62","<p>How to emit only resolved promise with mergeAll operator. </p>

<pre><code>var s1 = Rx.Observable.from([1,3,2])
var s2 = Rx.Observable.from([4,5,6])
var samplePromise = val =&gt; new Promise((resolve,reject)=&gt;{    
setTimeout(()=&gt; {if(val==3) reject(new Error(val)); else resolve(val);},val*1000)});

var mergedSource= Rx.Observable.merge(s1,s2)
  .map(val =&gt; samplePromise(val))        
  .mergeAll()
  .catch(err=&gt;console.log('err' , err)) 
var subscribeTwo = mergedSource.subscribe(val =&gt; console.log('Example:', val));
</code></pre>

<p>At this example ,  when val=3 throw error and doesnt emit others. 
How to skip rejected promises , I wanna emit only resolved promise value.</p>
","5646198","","5646198","","2017-01-03 12:37:25","2017-01-03 13:53:13","How to emit only resolved value with Rxjs 5 mergeAll operator","<javascript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41446221","1","41446301","","2017-01-03 14:54:32","","0","2656","<p>What's the difference between <code>observer.next()</code> and <code>observer.onNext()</code> in RxJs? Is one version 4 and the other 5?</p>

<p>What about <code>observer.complete()</code> and <code>observer.onCompleted()</code>?</p>

<p>I'm just starting out with RxJS and looking for RxJS v4 docs.</p>

<p>Is <a href=""http://reactivex.io/rxjs/"" rel=""nofollow noreferrer"">this the website</a> for v4 or v5 documentation?</p>
","6463558","","1087335","","2017-04-12 12:55:35","2017-04-12 12:55:35","rxjs, what's the difference about observer.next() and observer.onNext()?","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41446301","2","","41446221","2017-01-03 14:58:30","","2","","<p>These are the same. See <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#observer-interface-changes-also-subjects"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#observer-interface-changes-also-subjects</a>.</p>

<p>Website <a href=""http://reactivex.io/rxjs/"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/</a> is automatically generated from RxJS 5 docblocks.</p>

<p>RxJS 4 is mostly covered here <a href=""http://reactivex.io/documentation/observable.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/observable.html</a> (that covers also other Rx variants).</p>
","310726","","","","","2017-01-03 14:58:30","","","","0","","","","CC BY-SA 3.0"
"41452179","1","41452513","","2017-01-03 20:53:49","","34","20459","<p>I am using RxJS 5 and have this method:</p>

<pre><code>Queue.prototype.drain = function (obs, opts) {};
</code></pre>

<p>in the method, I would like to check if the user passed in an <code>Observable</code> for the first argument or if they omitted the <code>Observable</code> and just passed in an options object.</p>

<p>So basically I need to do something like this:</p>

<pre><code>if(!Rx.Observable.isObservable(obs)){  //this method is fictitious
    opts = obs || {};
    obs = Rx.Observable.interval(1000);
}
</code></pre>

<p>I assume RxJS provides users with this kind of check but I cannot find the documentation that shows you how to do this type checking.</p>

<p>Anyone know how?</p>
","","user5047085","3345644","","2019-05-23 19:30:22","2019-05-23 19:30:22","Check if object is an Observable","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 4.0"
"41452513","2","","41452179","2017-01-03 21:17:46","","56","","

<p>Since writing this answer, RxJS version 6 has been released and, in that version, an <a href=""https://github.com/ReactiveX/rxjs/blob/6.2.2/src/internal/util/isObservable.ts"" rel=""noreferrer""><code>isObservable</code></a> function was added to the public API. It can be imported like this:</p>

<pre class=""lang-js prettyprint-override""><code>import { isObservable } from ""rxjs"";
</code></pre>

<p>The function signature is:</p>

<pre class=""lang-js prettyprint-override""><code>export function isObservable&lt;T&gt;(obj: any): obj is Observable&lt;T&gt; 
</code></pre>

<p>Since it is defined with a typeguard, the compiler can help you out like this:</p>

<pre class=""lang-js prettyprint-override""><code>const result: any = ...;

if (isObservable(result)) 
{
   result.pipe(...);   // compiler now knows it's an observable.
}
</code></pre>

<hr>

<p>Internally, RxJS tests for an <code>Observable</code> <a href=""https://github.com/ReactiveX/rxjs/blob/5.0.2/src/util/subscribeToResult.ts#L27"" rel=""noreferrer"">using <code>instanceof</code></a>:</p>

<pre class=""lang-js prettyprint-override""><code>if (result instanceof Observable) {
  ...
}
</code></pre>

<p>So you could use:</p>

<pre class=""lang-js prettyprint-override""><code>if (!(obs instanceof Rx.Observable)) {
  opts = obs || {};
  obs = Rx.Observable.interval(1000);
}
</code></pre>

<hr>

<p><code>instanceof</code> can be used to determine whether or not an object is an <code>Observable</code> from the RxJS library that you happen to be using.</p>

<p>To determine if the object is a foreign observable, you can <a href=""https://github.com/ReactiveX/rxjs/blob/5.0.2/src/util/subscribeToResult.ts#L70-L77"" rel=""noreferrer"">look for a <code>Symbol.observable</code> property</a>.</p>

<p>If the property is present and is a function, you can obtain an RxJS <code>Observable</code> from the foreign observable by passing the value returned by calling the object's <code>Symbol.observable</code> property to <code>Rx.Observable.from</code>.</p>
","6680611","","16940","","2019-01-25 19:31:07","2019-01-25 19:31:07","","","","4","","","","CC BY-SA 4.0"
"41452554","1","41452899","","2017-01-03 21:20:52","","3","2222","<p>I have this code:</p>

<pre><code>let $obs = Rx.Observable.merge(
    this.obsEnqueue,
    Rx.Observable.timer(2000)
);
</code></pre>

<p>but this isn't doing want I want - want I would like to do is wait until both events fire (an event from <code>this.obsEnqueue</code> and the event from <code>Rx.Observable.timer()</code>).</p>

<p><code>merge</code> will most likely create a new Observable that will fire when the first event happens from all the observables are passed in. I would like to create a new observable that will fire after all observable passed in have fired.</p>

<p>So more generally:</p>

<pre><code>let $obs = Rx.Observable.X(
    Rx.Observable,    // wait
    Rx.Observable,    // until
    Rx.Observable,    // all of these
    ...
    Rx.Observable     // fire the next event
);
</code></pre>

<p>How can I do this? What is X?</p>
","1223975","","254882","","2019-02-08 08:19:25","2019-02-08 08:19:25","Combining Observables - waiting till all observables fire","<javascript><node.js><rxjs5>","2","2","","","","CC BY-SA 4.0"
"41452899","2","","41452554","2017-01-03 21:45:40","","4","","<p>You can use <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/zip.md"" rel=""nofollow noreferrer"">zip</a>, if you want to combine all the results when they arrive:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { Observable } = Rx;

const result = Observable.zip(
  Observable.of('data1'),
  Observable.of(true).delay(500),
  Observable.timer(1000)
);

result.forEach(console.log); // after 1000ms: ['data1', true, 0]</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3928341","","3928341","","2017-01-04 07:43:01","2017-01-04 07:43:01","","","","7","","","","CC BY-SA 3.0"
"41453418","1","41453545","","2017-01-03 22:34:04","","0","954","<p>Sometimes we need a dummy observable because the RxJS API does not seem to accept null or undefined in certain cases, for example:</p>

<pre><code>Queue.prototype.eqStream = function ($pauser) {

    if (!$pauser) {
        $pauser = Rx.Observable.timer(1);
    }

    let $obs = Rx.Observable.zip(
        this.obsEnqueue,
        pauser   // because pauser cannot be null here
    );
</code></pre>

<p>does RxJS5 have some accepted dummy Observable that just fires immediately, or should we just use one of these:</p>

<pre><code>Rx.Observable.timer(1);
Rx.Observable.from([0]);
</code></pre>

<p>It would be nice if the RxJS5 API gave us an accepted dummy Observable, like:</p>

<pre><code>Rx.Observable.dummy()
</code></pre>

<p>or something like that. Does anybody know the best practice when it comes to dummy Observables?</p>
","","user5047085","","","","2017-01-03 22:47:33","RxJS5 - dummy observables","<javascript><node.js><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41453545","2","","41453418","2017-01-03 22:44:40","","1","","

<p>If you want an observable that immediately completes and emits nothing, use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-empty"" rel=""nofollow noreferrer""><code>empty</code></a>:</p>

<pre class=""lang-js prettyprint-override""><code>let dummy = Rx.Observable.empty();
</code></pre>

<p>If you want an observable that emits a value and then completes, use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-of"" rel=""nofollow noreferrer""><code>of</code></a>:</p>

<pre class=""lang-js prettyprint-override""><code>let dummy = Rx.Observable.of('some value');
</code></pre>
","6680611","","6680611","","2017-01-03 22:47:33","2017-01-03 22:47:33","","","","3","","","","CC BY-SA 3.0"
"41456066","1","41461603","","2017-01-04 04:09:54","","0","66","<p>I have these two methods on a queue. I have implemented some form of backpressure, whereby the observables created from the methods will only fire events if the user fires a callback, all via observables. The problem is that I cannot get the onCompleted handler to fire in the main subscriber to <code>drain()</code>. What surprises me is that onNext will fire for the same subscriber, so why won't onCompleted fire? I would think that between the takeUntil call and the heavy handed $obs.complete() that the onCompleted handler in the subscriber would fire...</p>

<pre><code>Queue.prototype.isEmpty = function (obs) {

    if (!obs) {
        // this is just a dummy observable
        // I wish Rx had Rx.Observable.dummy() alongside
        // Rx.Observable.empty(), but oh well
        obs = Rx.Observable.of('dummy');
    }

    return this.init()
        .flatMap(() =&gt; {
            return obs; // when you call obs.next(), it should fire this chain again
        })
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    return acquireLockRetry(this, obj)
                })
        })
        .flatMap(obj =&gt; {
            return findFirstLine(this)
                .flatMap(l =&gt; {
                    return releaseLock(this, obj.id)
                        .map(() =&gt; {
                            console.log(' =&gt; LLLL1 =&gt; ', l);
                            return l;
                        });
                });
        })
        .filter(l =&gt; {
            // filter out any lines =&gt; only fire event if there is no line

            return !l;
        })
        .map(() =&gt; {
            //  the queue is now empty
            obs.complete(); // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; note this call
            return {isEmpty: true}
        });


};


Queue.prototype.drain = function (obs, opts) {

    opts = opts || {};

    const isConnect = opts.isConnect || false;
    const delay = opts.delay || 500;

    let $obs = obs.takeUntil(this.isEmpty(obs))
        .flatMap(() =&gt; {
            return this.init();
        })
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    return acquireLockRetry(this, obj)
                });
        })
        .flatMap(obj =&gt; {
            return removeOneLine(this)
                .flatMap(l =&gt; {
                    return releaseLock(this, obj.id)
                        .map(() =&gt; l);
                });
        });


    process.nextTick(function(){
        obs.next('foo foo foo');
        $obs.next('bar bar bar');
        $obs.complete();
    });


    return $obs;

};
</code></pre>

<p>What is driving absolute bonkers, is that I cannot get the onCompleted callback to fire, when I call the above like so:</p>

<pre><code>const q = new Queue();

const obs = new Rx.Subject();

q.drain(obs).subscribe(

    function (v) {

        console.log('end result =&gt; ', colors.yellow(util.inspect(v)));

        setTimeout(function () {
            // the following call serves as the callback which will fire the observables in the methods again
            obs.next();
        }, 100);

    },
    function (e) {
        console.log('on error =&gt; ', e);
    },
    function (c) {
        // this never gets called and it is driving me f*cking crazy
        console.log(colors.red(' DRAIN on completed =&gt; '), c);
    }

);

obs.subscribe(
    function (v) {
        console.log('next item that was drained =&gt; ', v);
    },
    function (e) {
        console.log('on error =&gt; ', e);
    },
    function (c) {
        // this gets called!
        console.log(colors.red(' =&gt; obs on completed =&gt; '), c);
    }
);
</code></pre>

<p>When I call the above, I just get this:</p>

<pre><code>next item that was drained =&gt;  foo foo foo
next item that was drained =&gt;  bar bar bar
 =&gt; obs on completed =&gt;  undefined
</code></pre>

<p>The reason I just get those 3 lines, is because I do this:</p>

<pre><code>process.nextTick(function(){
    obs.next('foo foo foo');
    $obs.next('bar bar bar');
    $obs.complete();
}); 
</code></pre>

<p>but <em>why</em> wouldn't explicitly calling <code>$obs.complete();</code> fire this callback:</p>

<pre><code> function (c) {
            // this never gets called and it is driving me f*cking crazy
            console.log(colors.red(' DRAIN on completed =&gt; '), c);
        }
</code></pre>

<p>?</p>
","","user5047085","","user5047085","2017-01-04 04:27:54","2017-01-04 10:30:06","RxJS5 => subscriber's onCompleted callback not firing","<javascript><node.js><rxjs5>","1","0","0","","","CC BY-SA 3.0"
"41458117","1","41459064","","2017-01-04 07:10:24","","0","286","<p>why angular2 is updating all the references of a variable? </p>

<p><strong>Problem Statement:</strong>
I have a service which returns observable on calling getData method</p>

<pre><code>@Injectable()
export class BuildingService {

constructor(private http: Http){       
  }

buildings$: Observable&lt;Building[]&gt;;

getData() : Observable&lt;Building[]&gt;{
     if (this.buildings$) {
        this.buildings$ = this.http.get('http://localhost:8080/buildings')
         .map(this.extractData)
         .publishReplay(1)
         .refCount();     
     }
     return this.buildings$;
  }

 private extractData(res: Response) {
    let body = res.json();
    return body;
} 
}
</code></pre>

<p>in component I'm subscribing to observable returned from getData method and doing some filtering and it is working fine</p>

<pre><code>export class Component1 implements onInit{

   constructor(private _buildingService: BuildingService) {}

   buildings: Building[] = [];

   ngOnInit() {
        this._buildingService.getData()
        .subscribe(buildings =&gt; {
            this.buildings = buildings;
            this.buildings.forEach((building, index){
                if (building.id === 0) {
                    this.buildings.splice(index, 1);
                }
            });
        });     
   }

getUnfilteredData() {
    this._buildingService.getData()
        .subscribe(buildings =&gt; {
            this.buildings = buildings;         
        });
   }
}
</code></pre>

<p>but even when I call getUnfilteredData() also, I am getting previously filtered data. Can somebody please explain why is this behaviour and how to avoid this?</p>
","2742156","","","","","2017-01-05 04:55:41","angular2 avoid updating reference variable also","<angular><typescript><observable><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41459064","2","","41458117","2017-01-04 08:12:16","","2","","<p>You are using <code>.publishReplay(1).refCount();</code> to cache the data for multiple subscribers which is working. But in your <code>ngOninit</code> you are taking the original data reference into <code>this.buildings</code> and splicing it. So your cached data is also affected.</p>

<p>Solution is to slice(make a copy) the array into <code>this.buildings</code> before filtering.</p>

<pre><code> ngOnInit() {
        this._buildingService.getData()
        .subscribe(buildings =&gt; {
            this.buildings = buildings.slice();//slice instead of taking reference
            this.buildings.forEach((building, index){
                if (building.id === 0) {
                    this.buildings.splice(index, 1);
                }
            });
        });     
   }
</code></pre>

<p>Or you could do this:</p>

<pre><code> ngOnInit() {
            this.buildings = [];
            this._buildingService.getData()
            .subscribe(buildings =&gt; {

                buildings.forEach((building){
                    if (building.id !== 0) {
                        this.buildings.push(building);
                    }
                });
            });     
       }
</code></pre>
","4826457","","4826457","","2017-01-05 04:55:41","2017-01-05 04:55:41","","","","3","","","","CC BY-SA 3.0"
"41461603","2","","41456066","2017-01-04 10:30:06","","0","","<p>Alright, I think I figured this out, what a crazy library this RxJS</p>

<p>Most likely to do things right, you should probably be using take() or takeUntil() or similar</p>

<p>So I did this:</p>

<pre><code>Queue.prototype.drain = function (obs, opts) {

    if (!(obs instanceof Rx.Observable)) {
        opts = obs || {};
        obs = new Rx.Subject();
    }
    else {
        opts = opts || {};
    }


    const isConnect = opts.isConnect || false;
    const delay = opts.delay || 500;

    process.nextTick(function () {
        obs.next();
    });


    let $obs = obs
        .flatMap(() =&gt; {
            return this.init();
        })
        .flatMap(() =&gt; {
            return acquireLock(this)
                .flatMap(obj =&gt; {
                    return acquireLockRetry(this, obj)
                });
        })
        .flatMap(obj =&gt; {
            return removeOneLine(this)
                .flatMap(l =&gt; {
                    return releaseLock(this, obj.id)
                        .map(() =&gt; ({data: l, cb: obs.next.bind(obs)}));
                });
        })
        //  here is the key part!
        .takeUntil(this.isEmpty(obs));


    return $obs;

};
</code></pre>

<p>that seems to have done the trick. I was pretty hopeless for awhile. If you want further explanation of how this works, please inquire within.</p>
","","user5047085","","","","2017-01-04 10:30:06","","","","0","","","","CC BY-SA 3.0"
"41462195","1","41462400","","2017-01-04 11:00:10","","1","58","<p>How can I do some final actions whenever the Observable is completed or aborted? Something similar to <a href=""https://api.jquery.com/deferred.always/"" rel=""nofollow noreferrer"">jQuery Deferred .always()</a> mechanism. </p>
","2145997","","","","","2017-01-04 11:10:58","Perform action at the end of Observalbe life cycle","<angular><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41462400","2","","41462195","2017-01-04 11:10:58","","2","","<p>Take a look at the <code>finally</code> method described here: <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/finally.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/finally.md</a></p>
","3504329","","","","","2017-01-04 11:10:58","","","","1","","","","CC BY-SA 3.0"
"41465143","1","41465636","","2017-01-04 13:36:01","","0","585","<p>In my snippet I am making an api request and everything works fine. I am now looking to check the response to see if the total number of items available on the server is greater than the returned result set defined by the pagesize.  If it is I would like to make additional api calls until all results are retrieved and returned to the subscriber as one response.  Which RX operator do I need to use to accomplish this and how can I pause the return of the response below until the subsequent api calls have been completed?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    getAction&lt;T&gt;(path: string, params?: {}): Observable&lt;T&gt; {
        return this._http.get(""url"")
            .map(res =&gt; {
                let response = res.json();
                // If more pages available make additional api calls &amp; return as single result
                return response;
            });
    }</code></pre>
</div>
</div>
</p>
","2009126","","","","","2017-01-04 13:59:54","RX merge multiple observables","<angular><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"41465636","2","","41465143","2017-01-04 13:59:54","","1","","<p>Have a look at <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-expand"" rel=""nofollow noreferrer"">expand</a>.</p>

<p>To fetch multiple pages of data recursively, you could do something like:</p>

<pre><code>class MyExample {
  search(offset) {
    return this.http.get(`/search?offset=${offset}`);
  }

  searchAll() {
    return this.search(0)
               .expand(results =&gt; {
                 if (loadNextPage(results)) {
                   return this.search(results.nextPageOffset);
                 } else {
                   return Observable.empty();
                 }
               });
  }
}
</code></pre>

<p><code>expand</code> allows you to do some processing based on previous results (like check if there are more pages), and specify an <code>Observable</code> with more results. The results of all these calls will be concatenated, not need to worry about carrying them over yourself.</p>
","277683","","","","","2017-01-04 13:59:54","","","","0","","","","CC BY-SA 3.0"
"41469931","1","41524298","","2017-01-04 17:32:01","","2","119","<p>I would like to buffer an observable by some arbitrary (but simple) criterion. I've set up a simple example here:</p>

<pre><code>const observable = Rx.Observable.from([1,2,3])
const filtered = observable.filter((n) =&gt; n === 3);
observable
  .buffer(filtered)
  .subscribe((n) =&gt; {
    // Why is this empty?
    console.log(n);
});
</code></pre>

<h2><a href=""http://jsbin.com/nevaro/edit?html,js,console"" rel=""nofollow noreferrer"">Bin here</a></h2>

<p>Trying to do this with <code>filter</code> only produces an empty array. I am expecting an array of <code>[1,2,3]</code>, but that seems to be not how it works. All the documentation for buffer uses asynchronous events like timer, but this isn't what I want. I would simply like to take the last n items based on some arbitrary criterion that I decide.</p>

<p>Help is much appreciated!</p>
","907125","","","","","2017-01-07 19:26:05","How can I buffer an observable by a simple in Rxjs?","<javascript><node.js><rxjs><reactive-programming><rxjs5>","2","9","0","","","CC BY-SA 3.0"
"41477119","1","41477501","","2017-01-05 04:00:29","","1","937","<p>I've put together a simple example that I believe should work.. but it doesn't :(
I need help understanding what I'm doing wrong. </p>

<pre><code>@Component({
    templateUrl: 'sandbox.template.html'
})
export class SandBoxPage implements OnInit {

    dataSubject: Subject&lt;string&gt; = Subject.create();
    data$: Observable&lt;string&gt;;

    constructor(private platform: Platform) {
        this.data$ = this.dataSubject
            .asObservable()
            .startWith(""First value in the observable"");
    }

    onClick() {
        console.log(""onClick()"");
        this.dataSubject.next(Date.now + "" value"");
    }

    ngOnInit() {
        console.log(""ngOnInit()"");
        this.data$.subscribe((v) =&gt; {
            console.log(""new value"", v);
        }, (err) =&gt; {
            console.log(""Error"", err);
        });
    }
}
</code></pre>

<p>I have a button hooked up to the <code>onClick()</code> but the console.log in my subscribe doesn't fire. It only fires once with the <code>startsWith</code> value at the start.</p>
","158958","","5706293","","2017-01-05 04:52:53","2017-01-05 04:52:53","Pushing/nexting a value from an observable subject, isn't updating a subscribed observable","<angular><typescript><ionic2><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41477501","2","","41477119","2017-01-05 04:50:44","","1","","<p>If you create a subject with <code>create</code>, you need to give it the <code>observer</code> and <code>observable</code> parameters according to the documentation.</p>

<blockquote>
  <p>Rx.Subject.create(observer, observable)</p>
</blockquote>

<p>Source: <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md#rxsubjectcreateobserver-observable"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md#rxsubjectcreateobserver-observable</a></p>

<p>Solution:
Just create it with new</p>

<pre><code>dataSubject: Subject&lt;string&gt; = new Subject&lt;string&gt;();
</code></pre>

<p>Source: <a href=""https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#bidirectional-service"" rel=""nofollow noreferrer"">https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#bidirectional-service</a></p>
","5706293","","","","","2017-01-05 04:50:44","","","","1","","","","CC BY-SA 3.0"
"41488267","1","41492972","","2017-01-05 15:05:56","","0","297","<p><a href=""https://jsfiddle.net/wz9gjqp2/"" rel=""nofollow noreferrer"">live exmaple</a></p>

<p>I would have expected it to be printed in order:</p>

<ul>
<li>Turn on the Loading screen before sending Ajax results</li>
<li>get AJAX results and records</li>
<li>Close the Loading screen</li>
</ul>

<p>The following code can be executed, and I would like to ask whether there are other ways to write</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var openLoadingPage$ = Rx.Observable.create(function(observer) {
  console.log(""open..."");
  observer.complete();
});

var closeLoadingPage$ = Rx.Observable.create(function(observer) {
  console.log(""close.."");
  observer.complete();
});

var ajax$ = Rx.Observable.create(function(observer) {
  //todo:get ajax result
  observer.next(""hello world"");
  observer.complete();
});

var result$ = Rx.Observable.of(
    openLoadingPage$,
    ajax$.delay(2000),
    closeLoadingPage$)
  .concatAll();

result$.subscribe({
  next: (value) =&gt; {
    console.log(""get ajax result:"", value);
  }
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","7291379","","7291379","","2017-01-06 05:12:26","2017-01-06 05:12:26","How to use the Observable cascade AJAX multiple methods","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"41492972","2","","41488267","2017-01-05 19:19:17","","1","","<p>Beware that when you write <code>Rx.Observable.of(myFunc1())</code>, <code>myFunc1</code> is executed right away and its return value (<code>undefined</code> in your case, because it has none) will be the single event value for the observable.</p>

<p>(same issue with <code>subscribe</code>, which takes a callback, when you pass the return value of <code>console.log(""complete"")</code>)</p>

<p>You're probably going to have more success by writing <code>.subscribe(() =&gt; console.log(""complete"")</code>) for the last part.</p>

<p>For the func part, it's hard to tell what you're trying to achieve, but here's an attempt:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function myFunc1() {
  console.log(""myFunc subscribe called"");
  return ""f1""
}

function myFunc2() {
  console.log(""myFunc2 subscribe called"");
  return ""f2""
}

var myFunc1$ = Rx.Observable.defer(() =&gt; Rx.Observable.of(myFunc1()));
var myFunc2$ = Rx.Observable.defer(() =&gt; Rx.Observable.of(myFunc2()));

myFunc1$
  .delay(2000)
  .concat(myFunc2$)
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","615903","","","","","2017-01-05 19:19:17","","","","1","","","","CC BY-SA 3.0"
"41499889","1","41500264","","2017-01-06 06:03:40","","10","4057","<p>I am confused about what the purpose of the ""dispose"" or ""unsubscribe"" function is for, which is (optionally) returned from an observable ""executor"" function, like so:</p>

<pre><code>const Rx = require('rxjs');

const obs = Rx.Observable.create(obs =&gt; {

    // we are in the Observable ""executor"" function
    obs.next(4);

     // we return this function, which gets called if we unsubscribe
    return function () {
        console.log('disposed');
    }

});

    const s1 = obs.subscribe(
        function (v) {
            console.log(v);
        },
        function (e) {
            console.log(e);
        },
        function () {
            console.log('complete');
        }
    );

    const s2 = obs.subscribe(
        function (v) {
            console.log(v);
        },
        function (e) {
            console.log(e);
        },
        function () {
            console.log('complete');
        }
    );


    s1.unsubscribe();
    s2.unsubscribe();
</code></pre>

<p>What confuses me is that such a function would actually be more likely to hold on to references in your code and therefore prevent garbage collection. </p>

<p>Can anyone tell me what the purpose is of returning a function in that scenario, what the function is called, and what it's signature is? I am having trouble figuring out information about it.</p>

<p>I also see much more complex examples of returning a subscription from the executor function, for example this:</p>

<pre><code>    let index = 0;

    let obsEnqueue = this.obsEnqueue = new Rx.Subject();

    this.queueStream = Rx.Observable.create(obs =&gt; {

        const push = Rx.Subscriber.create(v =&gt; {
            if ((index % obsEnqueue.observers.length) === obsEnqueue.observers.indexOf(push)) {
                obs.next(v);
            }
        });

        return obsEnqueue.subscribe(push);
    });
</code></pre>

<p>This seems to return a subscription instead of just a plain function. Can anyone explain what's going on with this?</p>

<p>To make it a clear question, what is the difference between doing this:</p>

<pre><code>const sub = new Rx.Subject();

const obs = Rx.Observable.create($obs =&gt; {

    $obs.next(4);
    return sub.subscribe($obs);

});
</code></pre>

<p>and not returning the result of the subscribe call:</p>

<pre><code>const sub = new Rx.Subject();

const obs = Rx.Observable.create($obs =&gt; {

    $obs.next(4);
    sub.subscribe($obs);

});
</code></pre>
","","user5047085","106909","","2017-01-06 06:37:33","2017-01-06 08:45:50","""Unsubscribe"" function callback/hook in Observable ""executor"" function","<javascript><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"41500264","2","","41499889","2017-01-06 06:36:16","","5","","<p>The <code>unsubscribe</code> function that <code>Rx.Observable.create</code> needs to return is invoked when downstream does not listen to the stream anymore, effectively giving you time to clean up resources. </p>

<p>In regards to your question; <code>.subscribe()</code> returns the subscription on which you can call <code>.unsubscribe()</code>. So if you want to do something with an other subscription you can pipe through that subscription to your downstream:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    const obs = Rx.Observable.create($obs =&gt; {
      const timer = Rx.Observable.interval(300)
        .do(i =&gt; console.log('emission: ' + i))

      return timer.subscribe($obs);
    });
    obs.take(4).subscribe(i =&gt; console.log('outer-emission:'+i))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.2/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Without the unsubscribe function you would stop listening to the observable but the interval created internally would keep on running:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const obs = Rx.Observable.create($obs =&gt; {
  const timer = Rx.Observable.interval(300)
    .do(i =&gt; console.log('emission: ' + i))
    .take(10)
    .subscribe(
      val =&gt; $obs.next(val),
      err =&gt; $obs.error(err),
      () =&gt; $obs.complete()
    );

  return function(){} // empty unsubscribe function, internal subscription will keep on running
});
obs.take(4).subscribe(i =&gt; console.log('outer-emission:'+i))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.2/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","106909","","106909","","2017-01-06 08:45:50","2017-01-06 08:45:50","","","","3","","","","CC BY-SA 3.0"
"41501354","1","41502129","","2017-01-06 07:55:51","","0","102","<p>I have following observable, that validate changes on the model.  </p>

<p>The code snippet looks as follow:</p>

<pre><code>  const oSaveCancelStateOb = this.determineSaveCancelStateOb(oTableItemChanges, oSaveCancelStateModelOb);
  oSaveCancelStateOb.subscribe(function (oOb) {
    console.log(""Subscribe 1"");
  });

  oDelBtnOb
    .switchMapTo(oSaveCancelStateOb)
    .subscribe(function (oOb) {
      console.log(""Subscribe 2"");
    });
</code></pre>

<p>The implementation of <code>determineSaveCancelStateOb</code> looks as follow:</p>

<pre><code>determineSaveCancelStateOb: function (oInspectionServiceOb, oSaveCancelStateModelOb) {
  return oInspectionServiceOb
    .map(function (bState) {
      return bState ? {bSave: true, bCancel: true} : {bSave: false, bCancel: false};
    })
    .switchMap(function (oState) {
      return oSaveCancelStateModelOb
        .map(function (oModel) {
          return {oModel: oModel, oState: oState};
        })
    });
},
</code></pre>

<p>The <code>oSaveCancelStateOb</code> verify, if somethings has changed on the model, it is a cold observable.  </p>

<p>The second observable <code>oDelBtnOb</code> is a hot observable, it listen on the mouse button click.</p>

<p>My expectation is, when I clicked on the button, it should show me on the console:</p>

<pre><code>Subscribe 1
Subscribe 2
</code></pre>

<p>But I've got only </p>

<pre><code>Subscribe 2
</code></pre>

<p>Why the first observable does not get subscribed?</p>

<p><strong>Update</strong>   </p>

<p>Take a look to the following code snippet:</p>

<pre><code>//Create an observable that emits a value every second
const sample1$ = Rx.Observable.of(true);
sample1$.subscribe(val =&gt; console.log(val))
//Create an observable that emits every time document is clicked
const sample2$ = Rx.Observable.fromEvent(document, 'click');

sample2$.switchMapTo(sample1$).subscribe(val =&gt; console.log(val))
</code></pre>

<p>When I click on the document, I am expecting the <code>true</code> will output twice.</p>
","1743843","","1743843","","2017-01-06 09:55:44","2017-01-06 13:57:52","Why observable does not get subscribed","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41502129","2","","41501354","2017-01-06 08:59:40","","1","","<p>As i understand the code your expectation is incorrect. In your last example the following will happen:</p>

<ol>
<li>after loading the code the subscription on <code>sample1$</code> will execute and process all values in the stream and for each value available emit it to the console. After that the <code>sample1$</code> subscription completes.</li>
<li>upon clicking on the document a <code>switchMapTo</code> is done to a new <code>sample1$</code> stream, its values (only <code>true</code>) are emitted and sent to the console, after which this observable completes.</li>
</ol>
","106909","","106909","","2017-01-06 13:57:52","2017-01-06 13:57:52","","","","2","","","","CC BY-SA 3.0"
"41503963","1","","","2017-01-06 10:45:25","","1","338","<p>Ok so just to learn RxJS better, decided to try my hand at creating a custom Rx operator.</p>

<p>So here is a simple one that works fine:</p>

<pre><code>Rx.Observable.prototype.multiply = function (input) {

    const source = this;

    return Rx.Observable.create(function (obs) {

        return source.subscribe(function(val){
            obs.next(input*val);
        });
    });

};
</code></pre>

<p>and we can use it like so:</p>

<pre><code>  const obs = Rx.Observable.interval(1000)
    .multiply(4)
    .forEach(function (v) {
        console.log(v);
    });
</code></pre>

<p>however, what if we get something a little more complicated, for example if our operator takes a function instead of a static value.</p>

<pre><code>Rx.Observable.prototype.handleFn = function (fn) {

    const source = this;

    return Rx.Observable.create(function (obs) {

        return source.subscribe(function(val){
            obs.next(fn.call(obs,val));
        });
    });

};
</code></pre>

<p>the above is all good and well, <em>but</em> what if we need to handle an Rx.Observable that gets returned from the input function, something like this:</p>

<pre><code>const obs = Rx.Observable.interval(1000)
    .handleFn(function(){
        return Rx.Observable.timer(399);
    })
    .forEach(function (v) {
        console.log(v);
    });
</code></pre>

<p>is there some sort of Promise.resolve() but for Observables so that I can resolve the result of Rx.Observable.timer()? Will check out the source code for <code>Rx.Observable.prototype.flatMap</code> etc.!</p>
","","user5047085","","user5047085","2017-01-06 20:00:14","2017-01-06 20:41:16","Promise.resolve() but for Observables (RxJS5)","<javascript><node.js><rxjs5><angular2-observables>","2","0","","","","CC BY-SA 3.0"
"41520312","1","","","2017-01-07 10:19:19","","2","1623","<p>Having some trouble achieving what I want with RxJS5 - I have a simple Observables chain, started with Rx.Observable.interval:</p>

<pre><code>const Rx = require('rxjs');

var i = 0;

const obs = Rx.Observable.interval(100)
    .flatMap(function () {
        return Rx.Observable.timer(Math.ceil(500*Math.random()))
            .map(function(val){
                console.log(' =&gt; These should all log first =&gt; ', val);
                return i++;
            });
    })
    .take(5)
    .merge()  // this doesn't seem to do what I want to do
    .map(function (val) {
        console.log('all done = &gt; ', val);
    });

obs.subscribe();
</code></pre>

<p>The above logs this:</p>

<pre><code> =&gt; These should all log first =&gt;  0
all done = &gt;  0
 =&gt; These should all log first =&gt;  0
all done = &gt;  1
 =&gt; These should all log first =&gt;  0
all done = &gt;  2
 =&gt; These should all log first =&gt;  0
all done = &gt;  3
 =&gt; These should all log first =&gt;  0
all done = &gt;  4
</code></pre>

<p>I am looking to log this:</p>

<pre><code> =&gt; These should all log first =&gt;  0
 =&gt; These should all log first =&gt;  0
 =&gt; These should all log first =&gt;  0
 =&gt; These should all log first =&gt;  0
 =&gt; These should all log first =&gt;  0

all done = &gt;  [0,1,2,3,4]
</code></pre>

<p>It's clear that we are not waiting for all the timer observables to finish, as you will see ""all done!"" logged many times, interspersed with ""These should all log first"".</p>

<p>How can I get the output I am looking for?</p>

<p>Normally, we could use <code>zip</code> for this, but the API for <code>zip</code> does not fit this use case, because we don't have all the timer observables in one place at the same time!</p>

<p>If my question was not clear enough, here is the analog of what I want to do, we block on all callbacks until we arbitrarily finish and we have collected all the results:</p>

<pre><code>const async = require('async');
var i = 0;

async.forever(function(cb){

    process.nextTick(function(){
       console.log('These should all log first');
       const err = i++ === 5;
       cb(err, i);
    });

}, function done(err, results){
    // let's pretend results contains all the i values
    console.log('all done');
});
</code></pre>
","1223975","","1223975","","2017-01-07 10:53:34","2017-01-07 11:40:18","Wait for chained observables to complete","<javascript><node.js><rxjs5><angular2-observables>","3","9","","","","CC BY-SA 3.0"
"41520909","1","41521028","","2017-01-07 11:25:00","","6","1358","<p>I know a little bit of BaconJS, but now I'm trying to learn RxJS by creating a ""User is typing..."" indicator. It's pretty simple, it can be explained in two simple rules:</p>

<ol>
<li>When the user is typing, the indicator should be immediately visible.</li>
<li>When the user stops typing, the indicator should still be visible until 1 second after the user's last typing action.</li>
</ol>

<p>I'm not sure if this is correct, but I have so far created two streams:</p>

<ol>
<li>One heartbeat stream that emits a <code>0</code> every second.</li>
<li>One stream to capture the user typing events and emit a <code>1</code> for every event.</li>
</ol>

<p>Then I merge them together, and simply tap into the result. If it's a <code>1</code>, then I show the indicator. If it's a <code>0</code>, then I hide the indicator.</p>

<p>This is what that looks like:</p>

<pre class=""lang-js prettyprint-override""><code>const showTyping = () =&gt;
  $('.typing').text('User is typing...');

const showIdle = () =&gt;
  $('.typing').text('');

// 1 second heartbeats are mapped to 0
const heartbeat$ = Rx.Observable
  .interval(1000)
  .mapTo(0);

// user typing events are mapped to 1
const input$ = Rx.Observable
  .fromEvent($('#input'), 'input')
  .mapTo(1);

// we merge the streams together
const state$ = heartbeat$
  .merge(input$)
  .do(val =&gt; val === 0 ? showIdle() : showTyping())
  .subscribe(console.log);
</code></pre>

<p>Here is a link to the JSBin: </p>

<p><a href=""http://jsbin.com/vekixuv/edit?js,console,output"" rel=""nofollow noreferrer"">http://jsbin.com/vekixuv/edit?js,console,output</a></p>

<p>There are several problems and questions I have with this implementation:</p>

<ol>
<li>Sometimes when the user is typing, a <code>0</code> sneaks through, so the indicator flashes away for a split second before coming back on the next user keystroke.</li>
<li>It's not guaranteed that the indicator will disappear 1 second after the user stops typing. It's only guaranteed that the indicator will disappear within 1 second (which is kind of the opposite of what we want).</li>
<li>Is using a heartbeat stream the correct RxJS way to do this? I have a feeling it might not be.</li>
</ol>

<p>I have a feeling that I am completely off-base with my implementation, I appreciate any help that you may be able to provide. Thanks.</p>
","839793","","310726","","2017-01-07 12:00:33","2017-01-07 12:00:33","How to use RxJS to display a ""user is typing"" indicator?","<javascript><rxjs><rxjs5><rxjs-dom>","2","0","2","","","CC BY-SA 3.0"
"41521028","2","","41520909","2017-01-07 11:39:04","","10","","<p>You don't even need to use two Observables and use just one with <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-debounceTime"" rel=""noreferrer""><code>debounceTime()</code></a>. All the logic you tried to make is already present in <code>debounceTime()</code> operator:</p>

<pre><code>const showTyping = () =&gt;
  $('.typing').text('User is typing...');

const showIdle = () =&gt;
  $('.typing').text('');

const input$ = Rx.Observable
  .fromEvent($('#input'), 'input')
  .do(() =&gt; showTyping())
  .debounceTime(1000)
  .subscribe(() =&gt; showIdle());
</code></pre>

<p>See live demo: <a href=""http://jsbin.com/cixipa/6/edit?js,console,output"" rel=""noreferrer"">http://jsbin.com/cixipa/6/edit?js,console,output</a></p>
","310726","","310726","","2017-01-07 11:44:06","2017-01-07 11:44:06","","","","0","","","","CC BY-SA 3.0"
"41524298","2","","41469931","2017-01-07 17:23:20","","0","","<p>As per olsn's comment, it appears that this was a bug in Rxjs 5. Changing to v4 effectively solved this problem.</p>
","907125","","907125","","2017-01-07 19:26:05","2017-01-07 19:26:05","","","","0","","","","CC BY-SA 3.0"
"41524844","1","41533612","","2017-01-07 18:17:00","","0","184","<p>How to avoid negative value ?</p>

<p>I've tried with filter but </p>

<p>if the value becomes negative</p>

<p>you should click twice to get</p>

<p>it positive.</p>

<pre><code>const start = 0;
    const min = 0;
    const max = 3
    var plus$ =  Observable.fromEvent(this.getNativeElement(this.btnPlus), 'click');
    var minus$ =  Observable.fromEvent(this.getNativeElement(this.btnMinus), 'click');
    var plusOrMinus$ = Observable.merge(plus$.mapTo(1), minus$.mapTo(-1));
    plusOrMinus$
    .scan((acc,curr) =&gt; acc+curr, start)
    .filter(x =&gt; x &gt; min)
    .subscribe(x =&gt; console.log(x));
</code></pre>

<p>and if I wanted add a max value ?</p>

<p>UPDATE</p>

<p>This do the work for min
it's a little messy ^^</p>

<pre><code>const start = 0;
    const min = 0;
    const max = 3
    const plus$ =  Observable.fromEvent(this.getNativeElement(this.btnPlus), 'click');
    const minus$ =  Observable.fromEvent(this.getNativeElement(this.btnMinus), 'click');
    const plusOrMinus$ = Observable.merge(plus$.mapTo(1), minus$.mapTo(-1));
    plusOrMinus$
    .scan((acc,curr) =&gt;{
      if(acc === start){
        if(curr &gt; 0){
          return acc+curr;
        }
      }
      if(acc &gt; start){
        return acc+curr;
      }
      else{
        throw new Error('0 value');
      }
    },
    start)
    .catch((e,obs)=&gt; obs.startWith(0))
    .subscribe(x =&gt; console.log(x));
</code></pre>
","356380","","356380","","2017-01-08 18:17:22","2017-01-08 18:17:22","Rxjs plus minus button with min max and not negative values","<rxjs5>","1","2","","","","CC BY-SA 3.0"
"41525803","1","41526330","","2017-01-07 19:53:24","","0","47","<p>Hy all, im have ask about Combination Operators from rxjs...</p>

<p>i have array of sites:</p>

<pre><code>const sites = [
    { name:'siteOne', url: 'http://www.example.com' },
    { name:'siteTwo', url: 'http://www.google.com' },
    { name:'siteThree', url: 'http://www.google.com' }
    ]
</code></pre>

<p>So, i don't want make request every time, but i need make one request per site url, than make new stream, combined with sites, like this:</p>

<pre><code>[ html, siteTwo, siteThree]
[ html, siteOne ]
</code></pre>

<p>Any way accomplish this? Thank you</p>
","7388757","","","","","2017-01-07 20:41:44","Example of rxjs5 Combination in javascript","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41526330","2","","41525803","2017-01-07 20:41:44","","1","","<p>If you want to only fetch the data once per unique url you can do something like this:</p>

<pre><code>Rx.Observable.from(sites)
  .groupBy(s =&gt; s.url)
  .flatMap(grp =&gt; grp.toArray())
  .flatMap(
    uniqueUrlGrouping =&gt; fetchHtml(uniqueUrlGrouping[0].url),
    (uniqueUrlGrouping, html) =&gt; ({ 
       url: uniqueUrlGrouping[0].url, 
       sites: uniqueUrlGrouping.map(s =&gt; s.name), 
       html:html
    })
  )
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p>Note; for the <code>toArray()</code> to work your input stream needs to be completed, otherwise it does not know when it can convert the completed grouped emissions to an array.</p>

<p>Note that the <code>.groupBy()</code> will keep all unique urls in memory until your input stream completes so it might grow to a large memory usage if your input stream is unbounded.</p>
","106909","","","","","2017-01-07 20:41:44","","","","1","","","","CC BY-SA 3.0"
"41527460","1","","","2017-01-07 22:51:49","","1","992","<p>I have this chain which should be concatenating 10 Observables into 1 Observable, where each of the 10 Observables should basically just be unwrapped to an integer:</p>

<pre><code>const Rx = require('rxjs');

var i = 0;
const obs = Rx.Observable.interval(10)
  .map(() =&gt; i++)
  .map(val =&gt; Rx.Observable.create(obs =&gt; {
          obs.next(val)
  }))
  .take(10)
  .reduce((prev, curr) =&gt; {
      return prev.concat(curr);  // concat all observables
  })
  .last(val =&gt; val.flatMap(inner =&gt; inner));

// subscribe to Observable
obs.subscribe(v =&gt; {
  console.log('\n next (and only) result =&gt; \n', v);
});
</code></pre>

<p>What's happening is that all 10 Observables should be concatenated together, but I cannot extract the values from those 10 Observables (which have become 1 Observable). So my question is, how can I unwrap that final observable and extract the value?</p>

<p>Anyone know what I am talking about?</p>
","1223975","","1223975","","2017-01-08 21:27:00","2020-04-08 11:57:47","Cannot extract/unwrap value from concatenated Observable","<node.js><rxjs5><angular2-observables>","3","0","","","","CC BY-SA 3.0"
"41527919","1","","","2017-01-07 23:55:27","","1","4642","<p>I am trying to use the filter property on a Angular formcontrol.</p>

<p>This is the code:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { FormControl } from '@angular/forms';
import { SpotifyService } from '../services/spotify.service';
import { Artist } from '../models/models';
import { Observable, Subscription } from 'rxjs/Rx';

    @Component({
      selector: 'spt-search',
      templateUrl: './search.component.html',
      styles: []
    })
    export class SearchComponent implements OnInit {
      public searchResult: Observable&lt;Array&lt;Artist&gt;&gt;;
      public searchString: string;
      public term = new FormControl;
      constructor(private spotService: SpotifyService) { }

      ngOnInit() {
        this.searchResult = this.term.valueChanges
          .debounceTime(400)
          .distinctUntilChanged()
          .filter((query: string) =&gt; query.length &gt; 1)
          .switchMap(term =&gt; this.spotService.searchMusic(this.term.value).map(res =&gt; res.artists.items));
      }
    }
</code></pre>

<p>When I try to set a filter I get this error:</p>

<pre><code>EXCEPTION: Uncaught (in promise): Error: Error in :0:0 caused by: this.term.valueChanges.debounceTime(...).distinctUntilChanged(...).filter is not a function
TypeError: this.term.valueChanges.debounceTime(...).distinctUntilChanged(...).filter is not a function
    at SearchComponent.ngOnInit (http://localhost:4200/main.bundle.js:229:14)
    at Wrapper_SearchComponent.ngDoCheck (/AppModule/SearchComponent/wrapper.ngfactory.js:22:53)
    at CompiledTemplate.proxyViewClass.View_SearchComponent_Host0.detectChangesInternal (/AppModule/SearchComponent/host.ngfactory.js:28:29)
    at CompiledTemplate.proxyViewClass.AppView.detectChanges 
</code></pre>
","1147577","","3853283","","2018-03-07 11:18:29","2021-10-29 09:35:03","How can I ensure a minimum input length with rxjs filter","<angular><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41529308","1","41533468","","2017-01-08 03:52:23","","2","433","<p>With this code in mind:</p>

<pre><code>const Rx = require('rxjs');

var i = 3;

const obs = Rx.Observable.interval(10)
    .map(() =&gt; i++)
    .map(function(val){
        return Rx.Observable.create(obs =&gt; {
            obs.next(val)
        });
    })
    .take(10)
    .concatAll();


obs.subscribe(function(v){
    console.log(v);
});
</code></pre>

<p>I would have expected the logged result to be something like:</p>

<pre><code>[3,4,5,6,7,8,9,10,11,12]
</code></pre>

<p>That is, 10 values, starting with 3.</p>

<p>However, all we get is just</p>

<pre><code>3
</code></pre>

<p>Does anybody know why that would be?</p>
","","user5047085","","","","2017-01-08 13:56:51","Observable.prototype.concatAll does not seem to yield expected result","<rxjs5><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"41533468","2","","41529308","2017-01-08 13:56:51","","2","","<p><code>concatMap</code> will wait for the first observable to complete before subscribing to the next. You forgot to add the <code>.complete()</code> to your inner observable, effectively having your stream only emit the first value <code>3</code> and waiting indefinitely for the first stream to complete before concatting the next to it. </p>

<p>Note; for a simple value emission as per your question you can also use <code>Rx.Observable.of()</code> instead of <code>Rx.Observable.create()</code></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var i = 3;

const obs = Rx.Observable.interval(10)
  .map(() =&gt; i++)
  .map(val =&gt; Rx.Observable.of(val))
  .take(10)
  .concatAll();

obs.subscribe(v =&gt; console.log(v));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","106909","","","","","2017-01-08 13:56:51","","","","11","","","","CC BY-SA 3.0"
"41533612","2","","41524844","2017-01-08 14:13:44","","1","","<p>If i understand your question correctly you want to prevent your inputs (+1/-1) from letting the total go out of bound (min, max). To do so you can use <code>Math.min(nextVal, max)</code> and <code>Math.max(nextVal, min)</code>. Combined you will end up with <code>Math.max(Math.min(nextVal, max), min)</code>. Next is using this in your <code>.scan()</code> function.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const incStream = Rx.Observable.fromEvent(document.getElementById('button_inc'), 'click').mapTo(1);
const decStream = Rx.Observable.fromEvent(document.getElementById('button_dec'), 'click').mapTo(-1);

const min = 0;
const max = 3;

Rx.Observable.merge(incStream, decStream)
  .scan((acc, curr) =&gt; Math.max(Math.min(acc + curr, max), min), 0)
  .startWith(0)
  .distinctUntilChanged()
  .subscribe(val =&gt; document.getElementById('result').value = val);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;
  &lt;input type='button' value='+1' id='button_inc' /&gt;
  &lt;input type='button' value='-1' id='button_dec' /&gt;
  &lt;input type='text' id='result' /&gt;</code></pre>
</div>
</div>
</p>

<p>The <code>.startWith(0)</code> is used to have a 0 value emitted to the stream before your first scan value arrives. <code>.distinctUntilChanged()</code> is used to not update the result with the same value (for instance when reaching <code>max</code> when using +1 multiple times).</p>
","106909","","","","","2017-01-08 14:13:44","","","","0","","","","CC BY-SA 3.0"
"41537504","1","42174935","","2017-01-08 20:27:30","","6","5641","<p>If I have a Node js stream, say for example from something like <code>process.stdin</code> or from <code>fs.createReadStream</code>, how can I convert this to be an RxJs Observable stream using RxJs5?</p>

<p>I see that <a href=""https://github.com/Reactive-Extensions/Rx-node"" rel=""noreferrer"">RxJs-Node</a> has a <code>fromReadableStream</code> method, but that looks like it hasn't been updated in close to a year.</p>
","3117409","","","","","2021-06-15 17:11:06","How to convert node readable stream to RX observable","<javascript><node.js><rxjs><rxjs5>","5","3","1","","","CC BY-SA 3.0"
"41540330","1","","","2017-01-09 02:49:54","","0","90","<p>I have these two rxjs stream in an Angular 2 component. One list contains speakers and the other list contains languages. Each speaker has a foreign key of a language found in languages list.</p>

<pre><code> speakers: FirebaseListObservable&lt;any[]&gt;;
 languages: FirebaseListObservable&lt;any[]&gt;;
</code></pre>

<p>Now I want to print language name against each speaker in <code>*ngFor</code>, or let me give you an angular expression of what things I want to print for each speaker html tag.</p>

<p><code>&lt;p&gt;{{speaker.Name}} , {{speaker.Language_Id}}, {{speaker.getLanguage()}}, {{getLanguage(speaker.Language_Id)}}&lt;/p&gt;</code>.</p>

<p>I am using <code>speaker.getLanguage()</code> and <code>getLanguage(speaker.Language_Id)</code> to know which one is better and are both possible?</p>

<p>I have not defined types on the client side in TypeScript code. Will I need to?</p>

<p>I have tried creating a function in component but it says <code>find</code> doesn't exist on type FirebaseListObservable. This is how simple it was in plane javascript :-P.</p>

<pre><code>getLanguage(languageId: number):string{
  return this.languages.find(x=&gt;x.Id==languageId).
}
</code></pre>
","2002079","","2002079","","2017-01-09 03:40:22","2017-01-09 05:42:44","How to filter single value from an rxjs stream to print in angular 2 component","<javascript><angularjs><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41544760","1","","","2017-01-09 09:29:38","","0","50","<p>I am having trouble figuring out how to access the source observable, in this scheme (just trying to figure out how to this without modifying Rx.Observable.prototype):</p>

<pre><code>      q.drain()
        .flatMap(function(val){
            return q.backpressure(val, function(cb){
                   setTimeout(cb,1000);
            });
        })
</code></pre>

<p>We call backpressure as a method on the Queue prototype:</p>

<pre><code>Queue.prototype.backpressure = function(val, fn){

    const source = ? // I don't know how to access the source observable...

    return Rx.Observable.create(sub =&gt; {

        return source.subscribe(val =&gt; {

                fn.call(source, val, function(err, val){
                    if(err){
                        sub.error(err);
                    }
                    else{
                        sub.next(val);
                    }

                });
            },
            // be sure to handle errors and completions as appropriate and
            // send them along
            err =&gt; sub.error(err),
            () =&gt; sub.complete());

    });
};
</code></pre>

<p>but the problem is I don't know if I can access the source observable in this scheme - the correct value for source is certainly <em>not</em> the <code>this</code> value inside the prototype because that belongs to the queue instance. My only hope I think is somehow to pass the source observable directly into the backpressure method. Anyone know how I can this? I don't mind putting this function elsewhere, it doesn't have to be a method on queue, but I think the same problem will exist either way.</p>

<p>If it helps, the value for <code>this</code> inside the flatMap function (if you use a regular function instead of an arrow function) is a MergeMapSubcriber object, see:</p>

<p><a href=""https://i.stack.imgur.com/0Y9uj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0Y9uj.png"" alt=""enter image description here""></a></p>

<p>However, after experimenting, I don't believe that the MergeMapSubcriber value is the one I want to use as my source; my source should be an Observable TMK, not a Subscriber.</p>
","1223975","","1223975","","2017-01-09 10:32:29","2017-01-09 10:32:29","Accessing source observable from outside Rx.Observable.prototype","<javascript><node.js><rxjs5><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"41551280","1","45374423","","2017-01-09 15:25:25","","5","371","<p>The code below is a simplified version of what I currently have:</p>

<p><strong>name.service.ts</strong></p>

<pre><code>@Injectable()
export class NameService {

    const nameURL = ""http://www.example.com/name"";

    getName() {
        return this.http.get(nameURL);
    }
}
</code></pre>

<p><strong>name1.component.ts</strong></p>

<pre><code>@Component({
    templateUrl: './name1.component.html',
    styleUrls: ['./name1.component.css']
})
export class Name1Component implmenets OnInit {

    private name1;

    constructor(
        private nameService: NameService
    ){}

    ngOnInit() {
        this.setupName();
    }

    private setupName() {

        this.nameService.getName()
            .subscribe(
                resp =&gt; this.name1 = resp,
                error =&gt; this.name1 = ""unknown""
            );
    }
}
</code></pre>

<p><strong>name2.component.ts</strong></p>

<pre><code>@Component({
    templateUrl: './name2.component.html',
    styleUrls: ['./name2.component.css']
})
export class Name2Component implmenets OnInit {

    private name2;

    constructor(
        private nameService: NameService
    ){}

    ngOnInit() {
        this.setupName();
    }

    private setupName() {

        this.nameService.getName()
            .subscribe(
                resp =&gt; this.name2 = resp,
                error =&gt; this.name2 = ""unknown""
            );
    }
}
</code></pre>

<p>Here is what I want to do, <code>name1.component.ts</code> will first call the <code>getName</code> method of the <code>NameService</code> class. <code>getName</code> will then make an ajax call and return an observable. </p>

<p>Next, <code>name2.component.ts</code> will also call the same <code>getName</code> method of the <code>NameService</code> class, and <code>getName</code> will also perform the same ajax call and return an observable.</p>

<p><strong>Is it possible using rxjs</strong> whereby when <code>getName</code> method in <code>NameService</code> makes its first ajax call, it then stores the result of the ajax call. Any subsequent function calls to the <code>getName</code> method will instead return the cache result of the first ajax call and not perform another redundant ajax. </p>
","3642636","","3642636","","2017-01-09 17:05:29","2017-07-28 13:09:39","RxJS 5 Observable and Angular2 http: Call ajax once, save the result, and subsequent ajax calls use cached result","<javascript><ajax><angular><rxjs5>","1","6","2","","","CC BY-SA 3.0"
"41556255","1","","","2017-01-09 20:20:34","","0","785","<p>With Promises, if you do this:</p>

<pre><code>    Promise.resolve(p).then(function(){
      return 5;
    })
   .then(function(val){
      return db.find(); // promise
    });
</code></pre>

<p>we can see that then operator on promises can handle any returned value, it just calls Promise.resolve() on the return result and handles it whether it's a promise or not.</p>

<p>However, with RxJS5, I am finding it difficult to find an operator that can do something similar. I get a lot of errors:</p>

<pre><code>TypeError: You provided x where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at Object.subscribeToResult (/home/oleg/WebstormProjects/oresoftware/observable-persistent-queue/node_modules/rxjs/util/subscribeToResult.js:73:27)
    at MergeAllSubscriber._next (/home/oleg/WebstormProjects/oresoftware/observable-persistent-queue/node_modules/rxjs/operator/mergeAll.js:85:42
</code></pre>

<p>for example, with this:</p>

<pre><code>Rx.Observable.range(1,9)
    .flatMap(function(){
        return Rx.Observable.timer(4)
    })
    .concatAll() // this will throw the error
    .subscribe();
</code></pre>

<p>is there an RxJS operator or pattern of operators that can handle any value and unwrap it like with Promises?</p>
","","user5047085","","","","2017-01-11 07:17:12","RxJS5 Operator that can handle wrapped *and* unwrapped values?","<rxjs5><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"41556838","1","41557117","","2017-01-09 21:00:02","","0","363","<p>This code works for me but am wondering if this is better way of handling the nested subscribes. Am fetching an array which I need to loop over and use in another http call. Is this efficient?</p>

<pre><code>this.storeService.fetchStores(this.currentCoordinates).subscribe(nearestStores =&gt; {
           nearestStores.forEach(store =&gt; {
                this.stockService.fetchStockResults(ean, store.id).subscribe(stock =&gt; {
                    this.stockResults.push({
                        storeObject: store,
                        ean: stock.ean,
                        ranged: stock.ranged,
                        inStock: stock.quantity &gt; 0 ? true : false
                    }
                    );
                });
            });
        });
</code></pre>
","1275105","","106909","","2017-01-09 21:18:49","2017-01-09 21:18:49","How to handle nested observables","<angular><rxjs5>","1","1","0","","","CC BY-SA 3.0"
"41557024","1","41557242","","2017-01-09 21:12:27","","3","273","<p>I want to create an observable that emits file additions/removal (via <code>chokidar</code>). I am able to do this by something like this:</p>

<pre class=""lang-js prettyprint-override""><code>Rx.Observable.create((subscriber) =&gt; {
  this.watcher = chokidar.watch(
     this.contentPath
  );
  this.watcher.on('addDir', () =&gt; { subscriber.next(); });
  this.watcher.on('unlinkDir', () =&gt; { subscriber.next(); });
});
</code></pre>

<p>What I want to do is, I want to <strong>stop</strong> for watching files, <strong>if there is no subscriber</strong> and start again when something subscribes to it. Something like this, but with RxJs:</p>

<pre class=""lang-js prettyprint-override""><code>class Notifier {
  constructor() {
    this.subscriberCount = 0;
  }

  subscribe(onNext, onError, complete) {
    this.subscriberCount++;
    if (this.subscriberCount === 1) {
      this.startInternalWatcher();
    }
    return () =&gt; {
      this.subscriberCount--;
      if (this.subscriberCount === 0) {
        this.stopInternalWatcher();
      }
    }
  }
}

// files are not watched
const n = new Notifier();

const s1 = n.subscribe(() =&gt; {}) // files are being wacthed
const s2 = n.subscribe(() =&gt; {}) // files are being wacthed
s1() // unsubscribed from 1, files are still watched.
s2() // unsubscribed from 2, files are not watched because no one is interested in.
</code></pre>

<p>I am new to RxJs so I might be missing some obvious solution. Is this possible?</p>
","158523","","106909","","2017-01-20 20:20:09","2017-01-20 20:20:09","RxJs - Calculate & emit values only if there is a subscriber","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41557117","2","","41556838","2017-01-09 21:18:26","","0","","<p>Its better not to do async actions in the <code>.subscribe()</code> which might also error. You can better have these calls embedded in your Rx stream so you can do error handling and things like concurrency control:</p>

<pre><code>this.storeService.fetchStores(this.currentCoordinates)
  .mergeMap(_ =&gt; _) /* emit all values from the stores array as separate values in the rx stream */
  .mergeMap(
    store =&gt; this.stockService.fetchStockResults(store.ean, store.id))
      .catch(err =&gt; Rx.Observable.of({ ean: -1, range: false, quantity: -1})),
    (store, stock) =&gt; ({
                        storeObject: store,
                        ean: stock.ean,
                        ranged: stock.ranged,
                        inStock: stock.quantity &gt; 0 ? true : false
                    }),
    10 /* concurrency; how many in-flight requests do you want?*/
  )
  .toArray()
  .subscribe(stockResults =&gt; console.log(stockResults));
</code></pre>
","106909","","","","","2017-01-09 21:18:26","","","","6","","","","CC BY-SA 3.0"
"41557242","2","","41557024","2017-01-09 21:26:58","","5","","<p>You're on the right track. First up, if you return a function from the creator <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/create.md"" rel=""noreferrer"">it will be called when the subscription is cancelled</a>, so you can use that to destroy the watcher.</p>

<p>That should solve most of your problem, but if you want to ensure there's a maximum of one ""watcher"" at one time you can tack on <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md"" rel=""noreferrer""><code>refCount</code></a>:</p>

<pre><code>return Rx.Observable.create((subscriber) =&gt; {
  this.watcher = chokidar.watch(
     this.contentPath
  );
  this.watcher.on('addDir', () =&gt; { subscriber.next(); });
  this.watcher.on('unlinkDir', () =&gt; { subscriber.next(); });

  return () =&gt; this.watcher.off('addDir unlinkDir');
})
.publish()
.refCount();
</code></pre>
","3603","","","","","2017-01-09 21:26:58","","","","0","","","","CC BY-SA 3.0"
"41561382","1","","","2017-01-10 04:57:02","","0","314","<p>I am trying to run a list of Observables either in parallel or series (doesn't matter, I just want them to actually run), something like so:</p>

<pre><code>     Rx.Observable.zip([

        Rx.Observable.timer(100),
        Rx.Observable.timer(200),
        Rx.Observable.timer(205)

    ])
        .do(function (val) {
           console.log('val =&gt;', val);
        })
        .subscribe()
</code></pre>

<p>the logging statement never gets executed and I don't know why. I even tried throwing in a concatAll for good measure.</p>

<pre><code>        Rx.Observable.zip([

            Rx.Observable.timer(100),
            Rx.Observable.timer(200),
            Rx.Observable.timer(205)

        ])
        .concatAll()
            .do(function (val) {
               console.log('val =&gt;', val);
            })
            .subscribe()
</code></pre>

<p>anyone know what's wrong?</p>

<p>What I want to do is the following, which actually works:</p>

<pre><code>   return Rx.Observable.range(0, count)
        .map(function (i) {
            return q.enq('foo ' + i);
        })
        .concatAll()
        .subscribe()
</code></pre>

<p>but I am trying to figure out how to do the same with zip or merge like I attempted at above above.</p>
","","user5047085","","user5047085","2017-01-10 05:03:18","2017-01-10 05:09:28","Using zip to run all Observables","<javascript><node.js><rxjs5><angular2-observables>","1","1","","","","CC BY-SA 3.0"
"41562341","1","41562829","","2017-01-10 06:21:35","","0","305","<p>Trying to build an observable stream that will read from two sources conditionally. A file stream based on user selection, or an in-memory stream for the current session.</p>

<p>I have a drop down where the user can select one of the following:</p>

<pre><code>Current  //in-memory stream contains entries (error, warning, trace, debug) as they happen for the current session
Error    //error.log file entries
Warning  //warning.log
Trace    //trace.log
Debug    //debug.log
</code></pre>

<p>Here's my setup code for my observable</p>

<pre><code>    //save the in-memory stream as a local variable so it returns the same instance
    let current$ = this.$loggerService.applicationLog$

    this.logs$ = this.logSeveritySubject
        .asObservable()
        .startWith(this.applicationLogName) //the currently selected value
        .flatMap((fileName: string) =&gt; {
            if (fileName === ""current"") {
                return current$;
            }

            return this.$localStorageService.readAsStringAsync(filename).map((s) =&gt; {
                let a: any[] = s.split(/\r\n|\r|\n/).filter(n =&gt; n.length &gt; 0);
                return a.reverse();
            });
        })
        .merge(this.clearLogSubject.asObservable()) //used to reset the scan back to an empty array
        .scan((x, y) =&gt; {
            if (y === null) return [];
            return y.concat(x);
        }, []);
</code></pre>

<p>Now when a user selects a new value, I push a new log file name through the subject </p>

<pre><code>this.clearLogSubject.next(null); //reset the scan back to an empty array
this.logSeveritySubject.next(this.applicationLogName); //read from the user selected option
</code></pre>

<p>The issue I'm having is, switching between the two streams starts to return duplicate entries (because the in-memory stream never completes perhaps?). It leads me to think that when <code>return current$;</code> runs multiple times, it actually puts the same instance into the final observable stream multiple times.</p>

<p>Perhaps there's a better way to code this. I basically want a user to select which log source to view from. The only caveat is that the in-memory observable never closes because it could be written to at any moment.</p>
","158958","","","","","2017-01-10 06:53:30","How do I make an observable conditionally return a stream based on user selection?","<angular><typescript><ionic2><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41562829","2","","41562341","2017-01-10 06:53:30","","3","","<p>You are using <code>flatMap</code> (alias for <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer"">mergeMap</a>) that merges events from all observables that come to it hence the duplicate entries. Use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow noreferrer"">switchMap</a> instead because it uses events from last observable only.</p>
","1010664","","","","","2017-01-10 06:53:30","","","","1","","","","CC BY-SA 3.0"
"41563900","1","","","2017-01-10 08:02:51","","6","4176","<p>I am working on a Portal in Angular 2. On login I make a request to the server to fetch the logged-in user profile. The method to fetch user profile returns an observable which is subscribed at 6 different places when the application loads.</p>
<p>If I used a cold observable, this would result in 6 API calls to the server. So i switched to a hot observable by adding .publishLast().refCount().</p>
<p>This resulted in a single request sharing the data since user profile doesn't update on subsequent requests.</p>
<p><strong>The problem starts here:</strong></p>
<p>Now I have an Edit Profile functionality which updates the user profile via an HTTP PUT and as a result of that, I would like to expire the previously subscribed Observables and somehow trigger the sequence again so API is executed again and the subscriptions receive updated data.</p>
<p>Is there some way I could restart/re-trigger an already subscribed observable sequence?</p>
<p>Here is the code for the fetch user observable</p>
<pre class=""lang-ts prettyprint-override""><code>fetch(){
    this.userObservable = Observable.fromPromise(this.getToken())
      .switchMap(token =&gt; {
        let headers = new Headers();
        headers.append('Authorization', `Bearer ${token}`);
        return this.http.get('/api/v1/admin/users/me?includes=role', {headers: headers})
      })
      .map((res: Response) =&gt; {
        let retVal: any = {
          data: new Deserializer({
            keyForAttribute: 'camelCase'
          }).deserialize(res.json())
        };
        this.user = retVal.data as MpUser;
        this.user.role = MpRoles[retVal.data.role[0].name];
        return this.user;
      })
      .publishLast()
      .refCount();
  }
</code></pre>
","792581","","74089","","2021-03-05 07:21:12","2021-03-05 07:21:12","Refresh/reload a Hot Observable sequence with RxJS","<angular><rxjs><rxjs5>","1","0","3","","","CC BY-SA 4.0"
"41575269","1","","","2017-01-10 17:54:35","","0","1221","<p>I am trying to test a component that renders background images whenever elements are visible. I detect visibility on scroll an resize events, and to ease the load I'm using <code>debounceTime</code> from RxJS. This however is a problem since the unit test fails with </p>

<blockquote>
  <p>Failed: Cannot use setInterval from within an async zone test.</p>
</blockquote>

<p>I know this is a problem due to the async nature of <code>debounceTime</code>, but I'm not sure how to prevent this / mock <code>debounceTime</code> for the test.</p>

<p>This is the Component</p>

<pre><code>import { Component } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import * as config from '../../config';
import ListComponentBase from '../../../forminputs/ListComponentBase';

@Component({
    selector: `list-component`,
    template: `
    &lt;a
        *ngFor=""let item of data.list""
        class=""box""
        routerLink=""/edit/{{item._id}}""&gt;
        &lt;div class=""name"" &gt;{{ item.name }}&lt;/div&gt;
        &lt;list-item-background
            *ngIf=""isVisible[item._id]"" [mediaObjectId]=""item.coverImageUrl""&gt;&lt;/list-item-background&gt;
    &lt;/a&gt;
    `,
    inputs: ['data', 'id'],
    outputs: ['filter', 'sorting'],
})
export class ListComponent extends ListComponentBase {
    constructor() {
        this.isVisible = {};
    }

    ngOnInit() {
        this.check();
        if (document.querySelector('nav')){
            this.scroll = Observable
                .fromEvent(document.querySelector('nav'), 'scroll')
                .debounceTime(100).subscribe((event) =&gt; {
                    this.checkVisibility();
                });
        }
        this.resize = Observable
            .fromEvent(window, 'resize')
            .debounceTime(100).subscribe((event) =&gt; {
                this.checkVisibility();
            });
    }
    check() {
        this.data.list.forEach(item =&gt; {
            this.isVisible[item._id] = this.isElementInViewport(document.querySelector(`[data-id=""${item._id}""]`));
        });
    }
    isElementInViewport(el) {
        if (!el) return false;
        const rect = el.getBoundingClientRect();
        return (
                rect.top &gt;= 0 &amp;&amp;
                rect.left &gt;= 0 &amp;&amp;
                rect.bottom &lt;= (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; /*or $(window).height() */
                rect.right &lt;= (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
        );
    }
}
</code></pre>

<p>This is the unit test</p>

<pre><code>import { Router } from '@angular/router';
import { TestBed, inject, async } from '@angular/core/testing';
import { StoreModule } from '@ngrx/store';

import RouterLinkMockModule from '../../../testing/RouterLinkMock.module';
import { ListComponent } from './list.component';
import { defaultData, collectionName } from '../../config';

const data = {
    sort: initialState.sort,
    list: [defaultData, defaultData],
    articles: { null: { name: 'test' } },
};

describe(`${collectionName} ListComponent`, () =&gt; {
    let fixture;
    beforeEach(() =&gt; {
        TestBed.configureTestingModule({
            imports: [
                RouterLinkMockModule,
            ],
            declarations: [
                ListComponent,
            ],
        });
    });

    it('should render 2 items in list', async(inject([Router], (router) =&gt; {
        fixture = TestBed.createComponent(ListComponent);
        fixture.componentInstance.data = data;
        fixture.detectChanges();
        const el = fixture.debugElement.nativeElement;
        expect(el.querySelectorAll('.box').length).toBe(2);
    })));
});
</code></pre>
","1436151","","106909","","2017-01-11 07:13:05","2017-01-20 10:35:09","Angular2 unit test with debounceTime in component ""Cannot use setInterval from within an async zone test""","<unit-testing><angular><typescript><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"41582686","2","","35980322","2017-01-11 04:25:55","","40","","<p>I think <a href=""https://github.com/ReactiveX/rxjs/issues/1722"" rel=""noreferrer"" title=""rxjs/observable/combineLatest missing"">#1722</a> is the relevant GitHub issue here.</p>

<p>I'm on a project using <code>typescript@2.0.10</code>, <code>RxJS@5.0.3</code>, and <code>webpack@2.1.0-beta.25</code>. The following works for me:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/combineLatest';

Observable.combineLatest(
  source1,
  source2
).subscribe(sink);
</code></pre>
","1345249","","","","","2017-01-11 04:25:55","","","","0","","","","CC BY-SA 3.0"
"41585968","1","41586047","","2017-01-11 08:29:23","","6","11077","<p>Is there a good way to check if not completed Observable is empty at that exact time?</p>

<pre><code>let cache = new ReplaySubject&lt;number&gt;(1);
...
// Here I want to know if 'cache' still empty or not. And, for example, fill it with initial value.
cache.isEmpty().subscribe(isEmpty =&gt; {
    if (isEmpty) {
        console.log(""I want to be here!!!"");
        cache.next(0);
    }
});
// but that code does not work until cache.complete()
</code></pre>
","1768378","","","","","2019-01-18 07:13:16","check if not completed Observable is empty","<javascript><typescript><rxjs><rxjs5>","4","1","1","","","CC BY-SA 3.0"
"41586047","2","","41585968","2017-01-11 08:34:44","","2","","<p>You could use <code>takeUntil()</code>:</p>

<pre><code>Observable.of(true)
    .takeUntil(cache)
    .do(isEmpty =&gt; {
        if (isEmpty) {
            console.log(""I want to be here!!!"");
            cache.next(0);
        }
    })
    .subscribe();
</code></pre>

<p>However this will just work once.</p>

<hr>

<p>Another way would be to ""null"" the cache and initialize it as empty by using a <code>BehaviorSubject</code>:</p>

<pre><code>let cache = new BehaviorSubject&lt;number&gt;(null as any);
...
cache
   .do(content =&gt; {
       if (content == null) {
           console.log(""I want to be here!!!"");
           cache.next(0);
       }
    })
    .subscribe();
</code></pre>

<p>And of course you could initialize the cache with some default value right away.</p>
","1518765","","","","","2017-01-11 08:34:44","","","","1","","","","CC BY-SA 3.0"
"41587218","1","41587356","","2017-01-11 09:36:27","","0","218","<p>I have an observable, that listens for the <code>keyup</code> event from an `input.</p>

<p>On every <code>keyup</code>, it makes a request to the server and if there aren't any values, it will throw an exception.</p>

<pre><code>.map(function (oResp) {
  if (oResp.data.results.length === 0) {
    throw new Error(self.getTextBundle(""insPlantInvalid""));
  } 
  return oResp.data.results;
})
</code></pre>

<p>After the exception was thrown, the observable is not going to listen for the event anymore.</p>

<p>Does the exception handling in <code>rxjs</code> work in this way? </p>
","1743843","","1227940","","2017-01-11 09:53:09","2017-01-11 10:17:50","Hot observable error handling","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41587356","2","","41587218","2017-01-11 09:43:12","","1","","<p>Yes, this is correct behavior. Exception makes the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/map.ts#L74"" rel=""nofollow noreferrer"">operator send an <code>error</code></a> notification. Both <code>error</code> or <code>complete</code> signals have to be the last signals emitted and both also <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L138"" rel=""nofollow noreferrer"">cause unsubscription</a>.</p>

<p>To resubscribe or handle errors there are operators such as <code>retry()</code>, <code>retryWhen()</code>, <code>catch()</code> or <code>onErrorResumeNext()</code>. I guess you already know these.</p>
","310726","","","","","2017-01-11 09:43:12","","","","4","","","","CC BY-SA 3.0"
"41591825","1","","","2017-01-11 13:09:10","","1","76","<p>Look at this: <a href=""https://github.com/asfernandes/rx-computed/tree/v0.0.2-alpha.5"" rel=""nofollow noreferrer"">https://github.com/asfernandes/rx-computed/tree/v0.0.2-alpha.5</a> in files <a href=""https://github.com/asfernandes/rx-computed/blob/v0.0.2-alpha.5/lib/rx-computed.ts"" rel=""nofollow noreferrer"">https://github.com/asfernandes/rx-computed/blob/v0.0.2-alpha.5/lib/rx-computed.ts</a> and <a href=""https://github.com/asfernandes/rx-computed/blob/v0.0.2-alpha.5/test/rx-computed.ts"" rel=""nofollow noreferrer"">https://github.com/asfernandes/rx-computed/blob/v0.0.2-alpha.5/test/rx-computed.ts</a></p>

<p>VSCode says there is no error, npm test runs ok, but when I use the library in another project, there is a problem of the RxJS skip method not defined.</p>

<p>The library compiles because the RxJS import in the test file is used in the lib file. How can I avoid this, as there is no sense to have it compiling with the test and not working outside.</p>
","550496","","","","","2017-01-11 13:09:10","TypeScript library + RxJS","<typescript><rxjs5><typescript2.0>","0","3","","","","CC BY-SA 3.0"
"41597197","1","41623719","","2017-01-11 17:33:20","","0","444","<p><strong>Versions</strong></p>
<p><code>npm: 3.10.9</code><br />
<code>systemjs: 0.19.41</code><br />
<code>typescript: 1.8.10</code><br />
<code>rxjs: 5.0.3</code></p>
<p><strong>Background</strong></p>
<p>I have a project (that's written in typescript) that i'm trying to add <code>rxjs</code> to, but have come across an issue when loading the bundled file through <code>systemjs</code>.</p>
<p><strong>SystemJs config</strong></p>
<pre><code>System.config({
    transpiler: 'typescript',
    paths: {
        'src:*': '/src/*',
        'npm:*': '/node_modules/*'
    },
    map: {
        'lib': 'src:lib',
        'rxjs': 'npm:rxjs/bundles/Rx.js',
        'typescript': 'npm:typescript/lib/typescript.js',
        'systemjs': 'npm:systemjs/dist/system.src.js'
    },
    packages: {
        lib: {
            defaultExtension: 'js'
        }
    }
});
</code></pre>
<p><strong>Problem</strong></p>
<p>Using the above config, i get the following error.</p>
<pre><code>Error: (SystemJS) undefined is not a constructor (evaluating '__extends(UnsubscriptionError, _super)')
</code></pre>
<p>Which is caused by the fact that systemjs incorrectly defaults to <code>amd</code> format and the <code>exporter</code> function on line 245 of <code>Rx.js</code> never gets executed.</p>
<p>From the systemjs docs:</p>
<blockquote>
<p><strong>Module format detection</strong></p>
<p>When the module format is not set, automatic regular-expression-based    detection is used. This module format detection is never completely accurate, but caters well for the majority use cases.</p>
</blockquote>
<p><strong>Attempted solution</strong></p>
<p>I presumed that explicitly setting the <code>rxjs</code> package format to <code>global</code> in the config would fix this issue.</p>
<pre><code>System.config({
    transpiler: 'typescript',
    paths: {
        'src:*': '/src/*',
        'npm:*': '/node_modules/*'
    },
    map: {
        'lib': 'src:lib',
        'rxjs': 'npm:rxjs/bundles/Rx.js',
        'typescript': 'npm:typescript/lib/typescript.js',
        'systemjs': 'npm:systemjs/dist/system.src.js'
    },
    packages: {
        lib: {
            defaultExtension: 'js'
        },
        rxjs: {
            format: 'global'
        }
    }
});
</code></pre>
<p><strong>Problem 2</strong></p>
<p>Although this fixed the first issue, it created a second. As everywhere that i attempt to use the <code>rxjs</code> imports now throws an error, as they're <code>undefined</code>.</p>
<pre><code>import {Observable} from 'rxjs'

export class SomeClass {

    ...
    
    private _isObservable(arg: any): boolean {
        return arg instanceof Observable;
    }
}
</code></pre>
<p><code>Uncaught TypeError: Right-hand side of 'instanceof' is not an object at SomeClass._isObservable</code></p>
<p>Debugging the transpiled code in the console reveals that although <code>window.Rx</code> gets correctly set to the <code>Rx</code> object, the <code>rxjs_1_1</code> object that gets set on <code>SomeClass</code>, is not the global <code>Rx</code> object, but instead another object with the <code>Rx</code> global set as a property 'Rx' on it.</p>
<p>So <code>rxjs_1.Rx.Observable</code> works, but not of rxjs_1.Observable`.</p>
<pre><code>(function(System, SystemJS) {System.register(['rxjs'], function(exports_1, context_1) {
&quot;use strict&quot;;
var __moduleName = context_1 &amp;&amp; context_1.id;
var rxjs_1;
var SomeClass;
return {
    setters:[
        function (rxjs_1_1) {
            rxjs_1 = rxjs_1_1;
        }],
    execute: function() {
        SomeClass = (function () {
            function SomeClass() {
            }
            ...
            SomeClass.prototype._isObservable = function (arg) {
                return arg instanceof rxjs_1.Observable;
            };
            return SomeClass;
        }());
        exports_1(&quot;SomeClass&quot;, SomeClass);
    }
}
</code></pre>
<p>});</p>
<p><strong>Question</strong></p>
<p>Any idea how i get it to pass in <code>Rx</code> object instead?</p>
","1798234","","-1","","2020-06-20 09:12:55","2017-11-24 10:04:19","Issue loading rxjs bundle with SystemJs","<typescript><systemjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41598997","1","41599569","","2017-01-11 19:17:23","","0","45","<p>Hy, what is functional way to create object and use values from rxjs5 observables?</p>

<pre><code>let _id = myObservableOne.pluck('id')
let _name = myObservableSecond.pluck('name')
let _path = myObservableThird.pluck('path')

let newObj = {
   id: _id,
   name: _name,
   path: _path
}
</code></pre>
","7388757","","","","","2017-01-11 19:52:43","Object assign with rxjs5","<javascript><functional-programming><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"41599569","2","","41598997","2017-01-11 19:52:43","","0","","<p>Depending if the rate of value emissions is equal for all three observables the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/zip.md"" rel=""nofollow noreferrer"">.zip()</a> operator might do what you need:</p>

<pre><code>const idStream = myObservableOne.pluck('id')
const nameStream = myObservableSecond.pluck('name')
const pathStream = myObservableThird.pluck('path')

Rx.Observable.zip(
  idStream,
  nameStream,
  pathStream,
  (id, name, path) =&gt; ({ id, name, path})
)
.subscribe(console.log);
</code></pre>
","106909","","","","","2017-01-11 19:52:43","","","","0","","","","CC BY-SA 3.0"
"41601084","1","","","2017-01-11 21:34:33","","1","449","<p>I want to poll for some boolean variable till it gets false. I'd like to compose an Observable that emits single value and completes, only when the particular variable gets false.</p>

<p>Here is what I've come with:</p>

<pre><code>    let waitTask = Observable.interval(250)
      .do(() =&gt; console.log(""DEBUG: Waiting for sync to finish.""))
      .takeWhile(() =&gt; this.syncing)
      .last()
      .defaultIfEmpty();
</code></pre>

<p>Is the above a proper (read: most elegant &amp; concise) way to do it? Especially I'm wondering about the source Observable here, the one that emits in every 250ms, will it be unsubscribed and cleaned up (underlying timer destroyed in memory == OS resources freed) when <code>takeWhile()</code> operator emits completion event? Shortly, it is safe to use the above Observable as is, without leaking any resources (because of ""forgotten"" timer)? Most probably no, but I'd like to be 100% sure.</p>

<p>P.S.: I'm writing this in RxJS but other platforms will probably have similar answer, so I'm not limiting the tags to RxJS.</p>

<p>P.P.S.: Obviously, I'm talking about the scenario when I can't convert target variable into Observable, that's the whole point. It's just a variable that I have to check every 250ms.</p>
","4866988","","4866988","","2017-01-16 10:36:48","2017-01-16 10:36:48","Periodically polling in Rx way","<javascript><rx-java><rxjs><system.reactive><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41608636","1","41608888","","2017-01-12 08:47:53","","1","228","<p>Given an array of objects which contain a message payload and time parameter like this:</p>

<p><code>var data = [
    { message:""Deliver me after 1000ms"", time:1000 },
    { message:""Deliver me after 2000ms"", time:2000 },
    { message:""Deliver me after 3000ms"", time:3000 }
];</code></p>

<p>I would like to create an observable sequence which returns the message part of each element of the array and then waits for the corresponding amount of time specified in the object. I'm open to reorganising the data structure of the array if that is necessary.</p>

<p>I've seen Observable.delay but can't see how it could be used with a dynamic value in this way. I'm working in RxJS 5.</p>
","7408601","","1518765","","2017-01-12 09:07:00","2017-01-12 09:17:00","Produce a stream of values with data-driven delays in RxJS","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"41608888","2","","41608636","2017-01-12 09:01:02","","3","","<p>You could use <code>delayWhen</code>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var data = [
    { message:""Deliver me after 1000ms"", time:1000 },
    { message:""Deliver me after 2000ms"", time:2000 },
    { message:""Deliver me after 3000ms"", time:3000 }
];

Rx.Observable
  .from(data)
  .delayWhen(datum =&gt; Rx.Observable.timer(datum.time))
  .do(datum =&gt; console.log(datum.message))
  .subscribe();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","1518765","","2017-01-12 09:17:00","2017-01-12 09:17:00","","","","0","","","","CC BY-SA 3.0"
"41617690","1","","","2017-01-12 15:59:27","","0","277","<p>I am trying to filter a ngrx <code>activities: Activity[]</code> state using <code>selectedProject</code> state. <code>selectedProject</code>'s key is used to get the observable <code>[{$key, true}, ...]</code>. How to filter the <code>activities: Activity[]</code> state ? This may be a very easy question for someone who has worked with rxjs for sometime.</p>

<pre><code>let obs: Observable&lt;Project&gt; = this.appstore.select('selectedProject');
let actskeys: FirebaseListObservable&lt;any[]&gt;;
    obs.subscribe(val =&gt; 
      {
        id = val.$key;
        actskeys = this.db.list(`/projectActs/${id}`);// This returns [{$key: true},{$key: true},...]
        this.appstore.select('activities'); // I want to filter this store using the actkeys, $key.
                }
    );
</code></pre>

<p>My try non working code</p>

<pre><code> getActsByCourseId(): Observable&lt;Activity[]&gt;{
    let id: string;
    let actskeys: FirebaseListObservable&lt;any[]&gt;;
    let obs: Observable&lt;Project&gt; = this.appstore.select('selectedProject');
    let acts = this.appstore.select('activities')
    let filteredActs: Activity[] = [];
    obs.subscribe(val =&gt; 
                {
                    id = val.$key;
                    actskeys = this.db.list(`/projectActs/${id}`);
                    actskeys.subscribe(val =&gt; {val.forEach(bb =&gt; 
                        acts
                        .filter((res: Activity[]) =&gt; res &amp;&amp; res.length &gt; 0 )
                        .map((res: Activity[]) =&gt; res.filter(val =&gt; val.$key === bb.$key))
                        .subscribe(res =&gt; console.log(res))
                        );
                        this.appstore.dispatch({ type: LOAD_Activities, payload: filteredActs});                         
                    }
                    )                      
                }
    );
    return this.appstore.select('activities');
}
</code></pre>

<p>Updated Code: Have tried combineLatest</p>

<pre><code>let selectedProject$ = this.appstore.select&lt;Project&gt;('selectedProject');
    let activities$ = this.appstore.select&lt;Activity[]&gt;('activities');
    let actskeys$: FirebaseListObservable&lt;any[]&gt;;
    let filteredActs: Observable&lt;any[]&gt; ;
    selectedProject$
        //.withLatestFrom(actskeys$, activities$)
            .map((selectedProject) =&gt; {
                    id = selectedProject.$key;
                    return actskeys$ = this.db.list(`/projectActs/${id}`);
    // filter here your activities ...
   })
   .subscribe(res =&gt; {
     filteredActs = this.getProjectActs(res);
   });
   filteredActs.subscribe(
                        res =&gt; {
                        console.log(res);
                        //  this.appstore.dispatch({ type: LOAD_Activities,     
                            payload: res});
                         }
                     );
    return this.appstore.select('activities');
    }

    getProjectActs(actskeys$:FirebaseListObservable&lt;any[]&gt;):   
    Observable&lt;any[]&gt; {
    let activities$ = this.appstore.select&lt;Activity[]&gt;('activities');
    return  Observable.combineLatest(activities$, actskeys$, (acts, keys) =&gt;    
                        {
                         return keys.map(key =&gt; {
                             acts.filter(act =&gt; act.$key === key.$key);
                        })
                    })
    };
</code></pre>

<p>I am getting <code>[undefined, undefined]</code> from the console.</p>
","3240531","","3240531","","2017-01-13 11:45:25","2017-01-13 11:45:25","Rxjs array of object data filtering","<angular><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"41621644","2","","39732822","2017-01-12 19:43:39","","1","","<p>I think you can solve your problem with a intermediate Subject in which you emit a value when streamB gets subscribed to:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const completeStreamA = new Rx.Subject();

const streamA = Rx.Observable.never()
  .takeUntil(completeStreamA);

const streamB = Rx.Observable.of('aValueOnStreamB')
  .do(() =&gt; completeStreamA.next('complete stream A'));

//clientA subscribes immediately
streamA.subscribe(
  next =&gt; console.log('a-&gt;next-&gt;'+next),
  err =&gt; console.log('a-&gt;error-&gt;' + err.message),
  () =&gt; console.log('a-&gt;complete')
);

setTimeout(() =&gt; {
  //simulate later subscription by clientB
  streamB.subscribe(
    next =&gt; console.log('b-&gt;next-&gt;'+next),
    err =&gt; console.log('b-&gt;error-&gt;' + err.message),
    () =&gt; console.log('b-&gt;complete')
  );
}, 3 * 1000);
  </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Only after the streamB gets subscribed to it will next a value into the <code>completeStreamA</code> subject which will complete streamA. The output of above code:</p>

<pre><code>a-&gt;complete
b-&gt;next-&gt;aValueOnStreamB
b-&gt;complete
</code></pre>
","106909","","","","","2017-01-12 19:43:39","","","","0","","","","CC BY-SA 3.0"
"41623719","2","","41597197","2017-01-12 21:58:27","","2","","<p>By adding <code>'Rx'</code> as the <code>meta.rxjs.exports</code> value in <code>system.config</code>, it allows you to select the <code>Rx</code> object to be imported, instead of its parent. You can use dot notation to select an even deeper object if necessary.</p>

<p>Not that you would want to, but just as an example, <code>exports: 'Rx.Observable'</code> would set the property <code>rxjs_1_1</code> to <code>Observable</code> in my original questions transpiled code.</p>

<p>So the full <code>system.config</code> would be:</p>

<pre><code>System.config({
    transpiler: 'typescript',
    paths: {
        'src:*': '/src/*',
        'npm:*': '/node_modules/*'
    },
    map: {
        'lib': 'src:lib',
        'rxjs': 'npm:rxjs/bundles/Rx.js',
        'typescript': 'npm:typescript/lib/typescript.js',
        'systemjs': 'npm:systemjs/dist/system.src.js'
    },
    packages: {
        lib: {
            defaultExtension: 'js'
        }
    },
    meta: {
        rxjs: {
            format: 'global',
            exports: 'Rx'
        }
    }
});
</code></pre>
","1798234","","","","","2017-01-12 21:58:27","","","","0","","","","CC BY-SA 3.0"
"41631045","1","41631145","","2017-01-13 09:16:13","","11","5623","<p>I have an array of observables and want to pass to <code>Rx.Observable.zip</code>. I tried and it does not get subscribed at all.  </p>

<p>Code snippet(just am example):</p>

<pre><code>const sourceOne = Rx.Observable.of('Hello');
const sourceTwo = Rx.Observable.of('World!');
const sourceThree = Rx.Observable.of('Goodbye');
const sourceFour = Rx.Observable.of('World!');
const arr$ = [sourceOne, sourceTwo, sourceThree, sourceFour];

const zip$ = (a$) =&gt; Rx.Observable.zip(a$);

const subscribe = zip$(arr$).subscribe(val =&gt; console.log(val));
</code></pre>

<p>Is there a way to pass an array to <code>Rx.Observable.zip</code>?</p>
","1743843","","","","","2021-01-21 09:04:19","pass array of observables to zip","<javascript><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41631145","2","","41631045","2017-01-13 09:21:35","","30","","<p>Operator <code>zip</code> accepts only an unpacked array.</p>
<pre><code>zip(sourceOne, sourceTwo, sourceThree, ...);
</code></pre>
<p>If you're using ES6 you can also use destructuring assignment with <code>...</code>:</p>
<pre><code>const zip$ = (a$) =&gt; zip(...arr$);
</code></pre>
<p>See live demo: <a href=""https://jsbin.com/tinaxeq/1/edit?js,console"" rel=""noreferrer"">https://jsbin.com/tinaxeq/1/edit?js,console</a></p>
","310726","","310726","","2021-01-21 09:04:19","2021-01-21 09:04:19","","","","4","","","","CC BY-SA 4.0"
"41638759","1","41640202","","2017-01-13 16:04:12","","6","2945","<p>I've just started learning this amazing stuff. I can't figure out how to get values from an array of promises. Here's where am at: </p>

<pre><code>const one = new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    resolve(1);
  }, 1000);
})
const two = new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    resolve(2);
  }, 2000);
})
const observable = Rx.Observable.from([one, two]);
observable.subscribe(v =&gt; console.log(v));
</code></pre>

<p>I get in console:</p>

<pre><code>Promise { &lt;pending&gt; }
Promise { &lt;pending&gt; }
</code></pre>

<p>I'd like to get: </p>

<ol>
<li>Result as an array of values <code>[1,2]</code></li>
<li>Result as individual values in order of promise resolution <code>1,2</code></li>
</ol>

<p>So, basically I want to emulate:</p>

<ol>
<li><code>Promise.all([one, two])</code></li>
<li><code>Promise.resolve(1), Promise.resolve(2)</code></li>
</ol>
","5663381","","310726","","2017-01-13 17:33:05","2017-07-30 05:36:21","Get values from an array of promises","<javascript><rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"41640202","2","","41638759","2017-01-13 17:27:55","","10","","<p>Static method <code>Observable.from()</code> emits each item in the array so what you have right now will just emit two <code>Promise</code> objects:</p>

<p>You're dealing with so called Higher-order Observables (aka Observables emitting Observables). This is in RxJS 5 easily solvable with <code>concatAll</code> or <code>mergeAll</code> depending on whether you care about the order they are specified or they can be collected as the resolve.</p>

<p>RxJS 5 treats Observables, Promises, iterators, array (and array like objects) the same way. This means we use your Promises just like they were Observables.</p>

<p>I'm using <code>mergeAll</code> here to show that the second Promise finished first even though they're defined in the opposite order <code>[one, two]</code>.</p>

<pre><code>const one = new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    resolve(1);
  }, 1000);
})
const two = new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    resolve(2);
  }, 500);
})

// Result as individual values in order of promise resolution 2,1
Rx.Observable.from([one, two])
  .mergeAll()
  .subscribe(v =&gt; console.log('mergeAll: ' + v));

// Result as an array of values [2,1]
Rx.Observable.from([one, two])
  .concatAll()
  .toArray()
  .subscribe(v =&gt; console.log(v));
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/tigidon/4/edit?js,console"" rel=""noreferrer"">https://jsbin.com/tigidon/4/edit?js,console</a></p>

<p>This prints to console:</p>

<pre><code>mergeAll: 2
mergeAll: 1
[2, 1]
</code></pre>
","310726","","310726","","2017-01-13 17:41:19","2017-01-13 17:41:19","","","","1","","","","CC BY-SA 3.0"
"41641780","1","","","2017-01-13 19:08:36","","0","1286","<p>In my Angular 2.x application, I have a component which subscribes to an observable exposed by a service. The observable data service is currently implemented with polling HTTP requests but that will change to a reactive WS implementation. I'd like to keep the polling out of the components so the question is: how can I take an action, like HTTP polling via <code>setInterval</code>, once I have subscribers? And, how can I take an action, like <code>clearInterval</code> when there are no more subscribers?</p>

<p>The view is asynchronously updated:</p>

<pre><code>  &lt;div *ngFor=""let headline of headlines$ | async""&gt;
    &lt;md-list-item (click)=""onSelect(headline)""&gt;
      &lt;h4 md-line&gt;{{headline.title}}&lt;/h4&gt;
    &lt;/md-list-item&gt;
    &lt;md-divider&gt;&lt;/md-divider&gt;
  &lt;/div&gt;
</code></pre>

<p>The component gets the headline observable from the service:</p>

<pre><code>export class HeadlinesComponent implements OnInit, OnDestroy {
  constructor(
      private _headlineService: HeadlineService,
  ) {
  }

  headlines$: Observable&lt;Headline[]&gt;;

  ngOnInit() {
    this.headlines$ = this._headlineService.headlines$;
  }
}
</code></pre>

<p>And the service is implemented as an observable data store:</p>

<pre><code>@Injectable()
export class HeadlineService {
  constructor(
    private _http: Http) {
    _init();
  }

  private _headlines$: BehaviorSubject&lt;Headline[]&gt; = 
    new BehaviorSubject&lt;Headline[]&gt;([]);

  get headlines$(): Observable&lt;Headline[]&gt; {
    return this._headlines$.asObservable();
  }

  private _store: {
    headlines: Headline[]
  } = { headlines: [] };

  private _save(headlines: Headline[]) {
    this._store.headlines = headlines;
    this._headlines$.next(Object.assign({}, this._store).headlines);
  }
}
</code></pre>

<p>and the store is updated via HTTP:</p>

<pre><code>  private _interval;

  private _init() {
    let self = this;
    this._interval = setInterval(function(){ self._loadHeadlines();}, 5000);
  }

  private _loadHeadlines(): Observable&lt;Headline[]&gt; {
    let self = this;
    let observable: Observable&lt;Headline[]&gt; = this._http
      .get(url, options)
      .map(response =&gt; response.json()._embedded.headlines)
      .share();

    observable.subscribe(
      headlines =&gt; self._save(headlines)
      );    

    return observable;
  }
</code></pre>

<p>As implemented, the headline service starts polling on construction instead of delaying until a subscriber is present. To get the lifecycle correct, I could expose the service's <code>_loadHeadlines</code> functionality and start polling when the component's <code>ngOnInit</code> is triggered (and stop in <code>ngOnDestroy</code>) but that exposes the service implementation details to the component (these details will change when I move to a web-sockets implementation) and I'd need have an accurate count of the number of subscribers.</p>

<p>So, is there a nice RxJs-ish way to solve this?</p>
","3342253","","3342253","","2017-01-13 19:26:19","2017-01-13 22:07:46","RxJs: take action on first and last subscriber to observable","<angular><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41650365","1","43883109","","2017-01-14 13:12:12","","2","606","<p>i'm using Behavior Subject in a angular 2 component and i want the second emitted value before last one , <a href=""http://reactivex.io/documentation/operators/skiplast.html"" rel=""nofollow noreferrer"">RxJs document</a> says i should use skipLast method on my stream to ignore them but i get an error while using it that says : </p>

<p>Property 'skipLast' does not exist on type 'Observable'</p>

<p>Angular version : 2.3.1
Rx.js version : 5.0.3</p>

<p>here is my code : </p>

<pre><code>import 'rxjs'
import { BehaviorSubject } from 'rxjs/BehaviorSubject'

@Component({
  ...
})

export class FilesComponent {
  folderId: BehaviorSubject&lt;number&gt; = new BehaviorSubject(0)

  constructor() {
    this.folderId.skipLast(2).subscribe(
      value =&gt; { console.log(value) }
    )
  }    

  clickHandler(fileId: number): void {
      this.folderId.next(fileId)
  }

}
</code></pre>
","7091035","","","","","2017-05-10 16:22:59","angular 2 - Property 'skipLast' does not exist on type 'Observable<number>'","<angular><rxjs><rxjs5>","2","5","","","","CC BY-SA 3.0"
"41654617","1","41654946","","2017-01-14 20:25:18","","1","76","<p>I have an observable that listen on table select event, it is also hot. </p>

<p>The code snippet:</p>

<pre><code>  const oTableRowSelect$ = TableOb.rowSelectionChangeEvent$(this.getById(""ins-table""));
  const test = oTableRowSelect$
    .do(function () {
      console.log(""resubscribe"");
    })
    .map(function () {
      return 4;
    });

  test.subscribe(function (o) {
    console.log(""Select1"" + o);
  });

  test.subscribe(function (o) {
    console.log(""Select2"" + o)
  });
</code></pre>

<p>As you can see, there are two subscribers, that listen on the event. So the result should share to all subscribers, that what is called a replay effect. </p>

<p>The output, that I've got is:
<a href=""https://i.stack.imgur.com/aDFwc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aDFwc.png"" alt=""enter image description here""></a></p>

<p>But I am expecting <code>resubscribe</code> output only once. What am I doing wrong?</p>
","1743843","","","","","2017-01-14 21:05:21","Why hot observable resubscribe","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41654946","2","","41654617","2017-01-14 20:57:49","","1","","<p>While your <code>oTableRowSelect$</code> might be <em>hot</em> and shared, it is only shared up the the part where you extend it somehow with additional operator(s) (in your case <code>do</code> and <code>map</code>).</p>

<p>In RxJS any extension through an operator will basically return a <em>""new""</em> stream.
In order to make this <em>""new""</em> stream hot/shared you'd have to apply an operator that makes it hot (<code>share</code>, <code>publish</code>, <code>publishReplay</code>, ect...)</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const hotBaseStream$ = new Rx.BehaviorSubject(""Hi!"");

const test = hotBaseStream$
    // -------- below this line you get a ""new"" stream, that is not hot any more
    .do(() =&gt; console.log(""resubscribe""))
    .map(() =&gt; 4)
    .publishReplay().refCount();  // remove this part and you will have back your original behavior

  test.subscribe(function (o) {
    console.log(""Select1 "", o);
  });

  test.subscribe(function (o) {
    console.log(""Select2 "", o)
  });</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","1518765","","2017-01-14 21:05:21","2017-01-14 21:05:21","","","","2","","","","CC BY-SA 3.0"
"41655811","1","41999758","","2017-01-14 22:43:41","","3","1057","<p>I'm trying to use an rxjs observable to delegate, but share, a piece of expensive work across the lifetime of an application.</p>

<p>Essentially, something like:</p>

<pre><code>var work$ = Observable.create((o) =&gt; {
  const expensive = doSomethingExpensive();
  o.next(expensive);
  observer.complete();
})
.publishReplay(1)
.refCount();
</code></pre>

<p>Now, this works fine and does exactly what I want, except for one thing: if all subscribers unsubscribe, then when the next one subscribes, my expensive work happens again. I want to keep it.</p>

<p>now, I could use a subject, or I could remove the refCount() and use connect manually (and never disconnect). But that would make the expensive work happen the moment I connect, not the first time a subscriber tries to consume work$.</p>

<p>Essentially, I want something akin to refCount that only looks at the first subscription to connect, and never disconnect. A ""lazy connect"".</p>

<p>Is such a thing possible at all?</p>
","304474","","","","","2017-02-02 10:29:34","Making a lazy, cached observable that only execute the source once","<javascript><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"41661658","1","","","2017-01-15 13:33:42","","1","167","<h2>The problem</h2>

<p>I have variable amount of sources streaming data â A, B, C. Sources could be added or removed at any time.</p>

<p>So I create stream of array of such sources D to observe this array.</p>

<p>Then I want to process inner data from this array of sources (for example how their value is being changed over time).</p>

<p>So I transform their state (toPairs) and aggregate this data in subscription for D (see code).</p>

<h2>Expectations</h2>

<ul>
<li>(ok) <strong>when</strong> I pass new data to A, B, or C, <strong>then</strong> I should see array of changed states (from, to) in subscription for D.</li>
<li>(ok) <strong>when</strong> I pass same data to A, B, or C, <strong>then</strong> I shouldn't see any output changes. </li>
<li>(err) <strong>when</strong> I pass any data to A, B, or C and this source is presented in list, <strong>then</strong> I should see just one line in output. </li>
<li>(err) <strong>when</strong> I pass same sources list to D, <strong>then</strong> I should see the same output as before</li>
<li>(err) <strong>when</strong> I pass sources list with additional item to D, <strong>then</strong> I should see the same output as before plus changes for that additional item.</li>
</ul>

<h2>Sample code</h2>

<pre><code>const Rx = require(""rxjs/Rx"");
const Promise = require(""bluebird"");

const A = new Rx.BehaviorSubject(""a1"");
const B = new Rx.BehaviorSubject(""b1"");
const C = new Rx.BehaviorSubject(""c1"");

const DEFAULT_PAIRS = ['??', '??']; // [ &lt;old value&gt;, &lt;new value&gt; ]
const toPairs = ([, oldValue], newValue) =&gt; {
  return [oldValue, newValue]
};

const A_ = A.asObservable().distinctUntilChanged().scan(toPairs, DEFAULT_PAIRS);
const B_ = B.asObservable().distinctUntilChanged().scan(toPairs, DEFAULT_PAIRS);
const C_ = C.asObservable().distinctUntilChanged().scan(toPairs, DEFAULT_PAIRS);

const D = new Rx.BehaviorSubject([A_, B_]);

D.asObservable()
  .startWith([])
  .flatMap(streams =&gt; {
    return Rx.Observable.combineLatest(
      ...streams,
      (...data) =&gt; data
    )
  })
  .subscribe(v =&gt; {
    console.log(v)
  });

Promise
  .delay(0)
  .then(() =&gt; console.log('-- change A to new value --'))
  .then(() =&gt; A.next(""a2""))
  .delay(0)
  .then(() =&gt; console.log('-- change A to new value --'))
  .then(() =&gt; A.next(""a3""))
  .delay(0)
  .then(() =&gt; console.log('-- change A to the same value --'))
  .then(() =&gt; A.next(""a3""))
  .delay(0)
  .then(() =&gt; console.log('-- change D to the same array --'))
  .then(() =&gt; D.next([A_, B_]))
  .delay(0)
  .then(() =&gt; console.log('-- change B to new value --'))
  .then(() =&gt; B.next(""b2""))
  .delay(0)
  .then(() =&gt; console.log('-- change C to new value --'))
  .then(() =&gt; C.next(""c2""))
  .delay(0)
  .then(() =&gt; console.log('-- change D to new array --'))
  .then(() =&gt; D.next([A_, B_, C_]));
</code></pre>

<h2>Output from sample code</h2>

<pre><code>[ [ '??', 'a1' ], [ '??', 'b1' ] ]
-- change A to new value --
[ [ 'a1', 'a2' ], [ '??', 'b1' ] ]
-- change A to new value --
[ [ 'a2', 'a3' ], [ '??', 'b1' ] ]
-- change A to the same value --
-- change D to the same array --
[ [ '??', 'a3' ], [ '??', 'b1' ] ]
-- change B to new value --
[ [ 'a2', 'a3' ], [ 'b1', 'b2' ] ]
[ [ '??', 'a3' ], [ 'b1', 'b2' ] ]
-- change C to new value --
-- change D to new array --
[ [ '??', 'a3' ], [ '??', 'b2' ], [ '??', 'c2' ] ]
</code></pre>

<h2>Comments</h2>

<p>As you see, every time when I pass any data to D, then I see that previous values are lost in output.</p>

<p>There is also strange thing with ""change B to new value"" section: it shows 2 outputs. The first line is correct. Then it updates one more time and prints out unexpected line with incorrect content.</p>

<h2>Expected output</h2>

<pre><code>[ [ '??', 'a1' ], [ '??', 'b1' ] ]
-- change A to new value --
[ [ 'a1', 'a2' ], [ '??', 'b1' ] ]
-- change A to new value --
[ [ 'a2', 'a3' ], [ '??', 'b1' ] ]
-- change A to the same value --
-- change D to the same array --
[ [ 'a2', 'a3' ], [ '??', 'b1' ] ]
-- change B to new value --
[ [ 'a2', 'a3' ], [ 'b1', 'b2' ] ]
-- change C to new value --
-- change D to new array --
[ [ 'a2', 'a3' ], [ 'b1', 'b2' ], [ 'c1', 'c2' ] ]
</code></pre>

<h2>Question</h2>

<p>How to fix this code in way it will print out expected lines?
Could you propose other solution for such problem?</p>
","1243636","","1243636","","2017-01-16 09:46:38","2017-01-16 09:46:38","RxJs: Subscribe to array of streams which changes dynamically","<javascript><rxjs><observable><rxjs5>","0","0","0","","","CC BY-SA 3.0"
"41668336","1","41672475","","2017-01-16 01:40:07","","7","2686","<p>In my customer-detail component I have the following code that achieves what I'm after but not in the reactive/observable way I think might be possible.</p>

<p>Instead of wrapping <code>this.isLoading = true;</code> in an if statement, is there a way to do this using reactive programming techniques? Perhaps by cancelling/dropping the delayed observable if the customer is retrieved first? Or, am I going about this the wrong way?</p>

<pre><code>export class CustomerDetailComponent implements OnInit {

  customer: Customer;
  errorMessage: string;
  isLoading: boolean;

  constructor(
    private customerService: CustomerService,
    private route: ActivatedRoute,
    private router: Router,
    private location: Location
  ) { }

  ngOnInit() { 
    let idParam = this.route.params
      .distinctUntilChanged(params =&gt; params['id']);

    idParam.subscribe(params =&gt; 
    {
      this.errorMessage = ''; 
    });

    idParam.delay(300).subscribe(params =&gt; 
    {
      if (!(this.customer &amp;&amp; this.customer.id == params['id']))
        this.isLoading = true;
    });

    idParam.switchMap((params: Params) =&gt; this.customerService.getCustomer(params['id']))
      .subscribe(customer =&gt; 
      { 
        this.customer = customer; 
        this.isLoading = false;
      },
      error =&gt; this.errorMessage = error);
  }
}
</code></pre>
","1253708","","310726","","2017-01-17 12:03:32","2020-05-01 14:56:33","Using Observables, show loading indicator after delay but cancel if loading is completed in time?","<angular><typescript><rxjs><reactive-programming><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"41670004","1","","","2017-01-16 05:30:11","","0","226","<p>Is there an Rx operator like <code>Promise.resolve()</code> which
can resolve either an Observable or plain value to a plain value?</p>

<p>For example, I can do this:</p>

<pre><code>Promise.resolve(3)
.then(function(val){
   console.log('val =&gt; ',val);
});
</code></pre>

<p>and of course, Promise.resolve() will accept a promise as well</p>

<p>however, I am having difficulty finding a analogous Rx operator,
something like:</p>

<pre><code>Rx.Observable.merge(3)
 .do(function(val){
      console.log('val =&gt; ',val);
  })
 .subscribe()
</code></pre>

<p>except <code>Rx.Observable.merge</code> will not accept all values, and will fail as is above.</p>

<pre><code>Rx.Observable.of(3)
    .map(v =&gt; {
        console.log('val =&gt; ', v);
    })
    .subscribe();
</code></pre>

<p>the above will accept a number but if you pass it an Observable, it will not unwrap the Observable.</p>

<p>Honestly, it is very frustrating that this is so difficult to determine. Having such a method/feature would allow for much more flexible code, because you could could refactor code to return non-observables and it will still work.</p>

<p>Here is the closest I have gotten so far:</p>

<pre><code>// creates an Observable from anything, which can be unwrapped
Rx.Observable.any = function (val) {

    if (!(val instanceof Rx.Observable)) {
        val = Rx.Observable.of(val);
    }

    return val;

};
</code></pre>

<p>we can test it like so:</p>

<pre><code>Rx.Observable.any([1, 2, 3])
    .map(v =&gt; {
        console.log('val =&gt; ', v);
    })
    .subscribe();

Rx.Observable.any('abc')
    .map(v =&gt; {
        console.log('val =&gt; ', v);
    })
    .subscribe();

Rx.Observable.any(4)
    .map(v =&gt; {
        console.log('val =&gt; ', v);
    })
    .subscribe();


Rx.Observable.any(Rx.Observable.timer(100))
    .map(v =&gt; {
        console.log('val =&gt; ', v);
    })
    .subscribe();
</code></pre>

<p>but I am looking for a more canonical way to do this...</p>
","1223975","","1223975","","2017-01-16 06:42:33","2017-01-16 06:42:33","Analogous Observable operator to Promise.resolve()","<javascript><node.js><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41672475","2","","41668336","2017-01-16 08:49:39","","7","","<p>You can write something along these lines:</p>

<pre><code>function getCustomer(id) {
    return Observable.of({'name': 'John', id}).delay(500);
}

Observable.of({'id': 42})
    .distinctUntilChanged(params =&gt; params['id'])
    .do(() =&gt; {
        // this.errorMessage = '';
    })
    .switchMap((params) =&gt; {
        return Observable.combineLatest(
            Observable.of(true).delay(300).startWith(null), // delay Observable
            getCustomer(params['id']).startWith(null), // customer Observable
            function(delay, customer) { // selector function
                if (customer) {
                    return customer;
                }

                if (delay &amp;&amp; !customer) {
                    console.log('this.isLoading = true;');
                }
                return null;
            })
            .filter(customer =&gt; customer)
            .distinctUntilChanged(customer =&gt; customer['id']);
    })
    .subscribe(
        customer =&gt; {
            console.log('this.isLoading = false;');
            console.log(customer);
            // this.customer = customer;
        },
        error =&gt; {
            // this.errorMessage = error;
        }
    );
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/nebutup/5/edit?js,console"" rel=""noreferrer"">https://jsbin.com/nebutup/5/edit?js,console</a></p>

<p>The inner <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""noreferrer""><code>combineLatest()</code></a> receives two Observables:</p>

<ol>
<li>The 300ms delay</li>
<li>The customer from a remote service (in this demo simulated)</li>
</ol>

<p>Then there's also projection function used to select what we want to propagate further. Both Observables use <code>.startWith(null)</code> to make make sure they have at least one item emitted so the <code>combineLatest()</code> will be triggered by a change in any of them. Then we can easily know whether the first Observable that emitted was the delay or the customer.</p>

<p>Then there's also <code>filter()</code> to remove all <code>null</code> values and <code>distinctUntilChanged()</code> to make sure we don't emit the same customer twice (this handles the case where the customer completes first). </p>

<p>Then when we run this demo and the delay is fired first the output is following:</p>

<pre><code>this.isLoading = true;
this.isLoading = false;
{ name: 'John', id: 42 }
</code></pre>

<p>This means we first show the loading and then hide it.</p>

<p>Then when we change the <code>getCustomer()</code> to complete first:</p>

<pre><code>function getCustomer(id) {
    return Observable.of({'name': 'John', id}).delay(100);
}
</code></pre>

<p>we'll get the following:</p>

<pre><code>this.isLoading = false;
{ name: 'John', id: 42 }
</code></pre>

<p>This means we never show any loading.</p>
","310726","","310726","","2017-01-19 10:20:19","2017-01-19 10:20:19","","","","2","","","","CC BY-SA 3.0"
"41672956","1","41675727","","2017-01-16 09:20:37","","0","55","<p>I have similar data structure to this:</p>

<pre><code>let userInfo =  [
      {
       id: 'id1',
       users: [
       {
        name: 'userName1',
        job: 'userJob',
       },
       {
        name: 'userName2',
        job: 'userJob',
       }
      ]
     },
      {
       id: 'id2',
       users: [
       {
        name: 'userName3',
        job: 'userJob',
       },
       {
         name: 'userName4',
        job: 'userJob',
       }
      ]
     }
    ]
</code></pre>

<p>Users are 
I expected new flattened user stream with RxJS5:</p>

<pre><code>    {
     parent: id,        // parent id, where users[] come from...
     name: 'userName'
     job: 'userJob'
    }
</code></pre>

<p>What is the clean functional way to archive this? Thank you...</p>
","7388757","","310726","","2017-01-16 11:48:04","2017-01-16 11:48:04","Advanced example of rxjs5 flattening","<javascript><functional-programming><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41675022","1","41675148","","2017-01-16 11:09:05","","0","33","<p>I have following code snippet:</p>

<pre><code>const source$ = Rx.Observable.from([1,2,3,4])
  .filter(x =&gt; x % 2)
  .map(x =&gt; x * x)
  .share();

source$.subscribe(x =&gt; console.log(`Stream 1 ${x}`));
source$.subscribe(x =&gt; console.log(`Stream 2 ${x}`));
</code></pre>

<p>As the result I've got<br>
<a href=""https://i.stack.imgur.com/k9Hjv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/k9Hjv.png"" alt=""enter image description here""></a></p>

<p>But I am excepting shared results like:</p>

<pre><code>""Stream 1 1""
""Stream 2 1""
""Stream 1 9""
""Stream 2 9""
</code></pre>

<p>Why the result does not get shared?</p>
","1743843","","","","","2017-01-16 11:16:21","Why result does not get shared?","<javascript><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"41675148","2","","41675022","2017-01-16 11:16:21","","4","","<p>This is because you're using a cold Observable (<a href=""http://reactivex.io/documentation/observable.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/observable.html</a>).</p>

<p>When you subscribe for the first time it takes the <code>refCount()</code> operator and subscribes to its source Observable which is the <code>Observable.from()</code>. This all happens synchronously so it emits all its values the the subscriber and then emits complete which makes the <code>refCount()</code> unsubscribe from the source because there're no other Observers.</p>

<p>Then you subscribe with the second Observer and this all happens again.</p>

<p>If you wanted to achieve your expected result that you could use just <code>publish()</code> to turn the source into a Connectable observable and call <code>connect()</code> manually.</p>

<pre><code>const source$ = Rx.Observable.from([1,2,3,4])
  .filter(x =&gt; x % 2)
  .map(x =&gt; x * x)
  .publish();

source$.subscribe(x =&gt; console.log(`Stream 1 ${x}`));
source$.subscribe(x =&gt; console.log(`Stream 2 ${x}`));

source$.connect();
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/waraqi/2/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/waraqi/2/edit?js,console</a></p>
","310726","","","","","2017-01-16 11:16:21","","","","0","","","","CC BY-SA 3.0"
"41675727","2","","41672956","2017-01-16 11:47:54","","0","","<p>The easiest approach would just use <code>concatMap()</code> to merge the internal Observable created with <code>Rx.Observable.from</code> with the list of users updated with their parent id.</p>

<pre><code>let userInfo =  [
  {
    id: 'id1',
    users: [
      {
        name: 'userName1',
        job: 'userJob',
      },
      {
        name: 'userName2',
        job: 'userJob',
      }
    ]
  },
  {...}
];

let source = Rx.Observable.from(userInfo)
  .concatMap(group =&gt; {
    return Rx.Observable.from(group['users'])
      .map(user =&gt; {
        user['parent'] = group.id;
        return user;
      });
  });

source.subscribe(
  res =&gt; console.log(res)
);
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/miximas/2/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/miximas/2/edit?js,console</a></p>

<p>There're a lot of similar question already:</p>

<ul>
<li><p><a href=""https://stackoverflow.com/questions/41609016/refactor-fat-arrow-nested-rxjs-stream/41609467#41609467"">refactor fat arrow nested rxjs stream</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/40346728/merge-subarrays-using-observables/40347238#40347238"">Merge subarrays using Observables</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/41092488/rxjs-json-data-with-an-array-processing-each-item-further-in-the-stream/41096657#41096657"">RxJS: JSON data with an array, processing each item further in the stream</a></p></li>
</ul>
","310726","","-1","","2017-05-23 12:08:56","2017-01-16 11:47:54","","","","0","","","","CC BY-SA 3.0"
"41698896","1","41703388","","2017-01-17 13:51:54","","9","2275","<p>Let's consider for a moment the following code</p>

<pre><code>Rx.Observable.merge(
  Rx.Observable.just(1),
  Rx.Observable.just(1).delay(1000)
).distinctUntilChanged()
  .subscribe(x =&gt; console.log(x))
</code></pre>

<p>We expect that <code>1</code> is logged just once. However what if we wanted to allow repetition of a value if its last emission was a configurable amount of time ago? I mean to <strong>get both events logged</strong>.</p>

<p>For example it would be cool to have something like the following</p>

<pre><code>Rx.Observable.merge(
  Rx.Observable.just(1),
  Rx.Observable.just(1).delay(1000)
).distinctUntilChanged(1000)
  .subscribe(x =&gt; console.log(x))
</code></pre>

<p>In which <code>distinctUntilChanged()</code> accepts some sort of timeout to allow repetition on the next element. However such a thing does not exist and I was wondering if anybody knows an elegant way to achieve this by using high level operators without messing with a filter that would require handling state</p>
","673402","","310726","","2017-01-17 16:57:38","2017-01-17 17:28:18","Rx distinctUntilChanged allow repetition after configurable time between events","<javascript><rxjs><reactive-programming><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"41703388","2","","41698896","2017-01-17 17:28:18","","9","","<p>Unless I am misunderstanding I am pretty sure this could be accomplished in a relatively straight-forward manner with <code>windowTime</code>:</p>

<pre><code>Observable
  .merge(
   Observable.of(1),
   Observable.of(1).delay(250), // Ignored
   Observable.of(1).delay(700), // Ignored
   Observable.of(1).delay(2000),
   Observable.of(1).delay(2200), //Ignored
   Observable.of(2).delay(2300)
  )
  // Converts the stream into a stream of streams each 1000 milliseconds long
  .windowTime(1000)
  // Flatten each of the streams and emit only the latest (there should only be one active 
  // at a time anyway
  // We apply the distinctUntilChanged to the windows before flattening
  .switchMap(source =&gt; source.distinctUntilChanged())  
  .timeInterval()
  .subscribe(
    value =&gt; console.log(value),
    error =&gt; console.log('error: ' + error),
    () =&gt; console.log('complete')
  );
</code></pre>

<p>See the example <a href=""https://jsbin.com/tulojogudi/edit?js,console"" rel=""noreferrer"">here</a> (borrowed @martin's example inputs)</p>
","2521865","","","","","2017-01-17 17:28:18","","","","2","","","","CC BY-SA 3.0"
"41727380","1","","","2017-01-18 19:00:59","","0","75","<p>I'm using the jQuery UI datepicker in an Angular 2 application, and it works fine with one exception.  My application has a list of radio button options that, when any one of them is checked, sets a variable called serviceTypeChosen to true (variable is initially false when app loads).</p>

<p>I want the datepicker to be disabled until the user checks one of the radio buttons, making serviceTypeChosen true.  I have a separate service that builds an order for the user, and in the datepicker component I'm subscribing to a method of the service that tracks the building of the order as the user goes through the various stages of the app.  I know that the serviceTypeChosen variable is being switched from false to true when the radio button is checked and that my subscription to the service recognizes when the variable's value changes because the console logs I have inserted behave the way I expect them to, notifying me that the datepicker is disabled until a radio button has been checked, and notifying me that it's enabling the datepicker once I check a radio button.  However, as it stands with my current code the datepicker is disabled regardless of whether or not a radio button has been checked.  </p>

<p>I've determined that the 'if' portion of the statement works properly.  If I set the disabled property of the datepicker to false, the datepicker is disabled.  If I set it to true, it works.  The issue lies in the 'else' portion of the statement.  The console log works as expected by the datepicker's disabled property is not affected.  I'm baffled.</p>

<pre><code>import { ViewChild, ElementRef, OnInit, AfterViewInit, Component } from
'@angular/core';
import {ControlValueAccessor, NG_VALUE_ACCESSOR } from 
'@angular/forms';

import { OtrixService } from '../otrix.service';

declare var jQuery: any;

@Component({
  selector: 'otrix-datepicker',
  templateUrl: './datepicker.component.html',
  styleUrls: ['./datepicker.component.scss']
})
export class DatepickerComponent implements OnInit, AfterViewInit {

  @ViewChild('readyDate') dateInput: ElementRef;

  constructor(
    private otrixService: OtrixService,
  ) {}

  ngOnInit() {

    this.otrixService.getStagedOrder().subscribe((order) =&gt; {
      if (!order.serviceTypeId) {
        console.log('Service type not yet chosen. Datepicker
        disabled.');
        jQuery(this.dateInput.nativeElement).datepicker({disabled:
        true});
        console.log(this.dateInput.nativeElement);
      } else if (order.serviceTypeId) {
        console.log('Service type chosen. Enabling datepicker.');
        jQuery(this.dateInput.nativeElement).datepicker({disabled:
        false});
      }
    });

  }

  ngAfterViewInit() {

    jQuery(this.dateInput.nativeElement).datepicker({
      minDate: new Date(), // custom settings
      maxDate: '30d',
      showAnim: 'slideDown',
      onSelect: (datePicked: boolean) =&gt; { // when user picks a date...
        let readyDate =  
        jQuery(this.dateInput.nativeElement).datepicker('getDate');
        this.otrixService.setReadyDate(readyDate);
      }
    });

  }

}
</code></pre>
","6899782","","6899782","","2017-01-18 20:42:57","2017-01-18 20:42:57","jQuery UI datepicker disabled option not being recognized by Angular 2","<jquery><angular><this><jquery-ui-datepicker><rxjs5>","0","5","","","","CC BY-SA 3.0"
"41730542","1","41739202","","2017-01-18 22:23:26","","21","17815","<p>Here is what I'm doing now to convert an <code>Observable</code> to a <code>ReplaySubject</code>:</p>
<pre class=""lang-js prettyprint-override""><code>const subject = new Rx.ReplaySubject(1);

observable.subscribe(e =&gt; subject.next(e));
</code></pre>
<p>Is this the best way to make the conversion, or is there a more idiomatic way?</p>
","247243","","74089","","2020-11-02 22:53:48","2021-06-30 23:01:31","How to convert an Observable to a ReplaySubject?","<rxjs><rxjs5>","3","5","7","","","CC BY-SA 4.0"
"41739202","2","","41730542","2017-01-19 10:15:54","","21","","<p>You can use just <code>observable.subscribe(subject)</code> if you want to pass all 3 types of notifications because a Subject already behaves like an observer. For example:</p>

<pre><code>let subject = new ReplaySubject();
subject.subscribe(
  val =&gt; console.log(val),
  undefined, 
  () =&gt; console.log('completed')
);

Observable
  .interval(500)
  .take(5)
  .subscribe(subject);

setTimeout(() =&gt; {
  subject.next('Hello');
}, 1000)
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/bayewo/2/edit?js,console"" rel=""noreferrer"">https://jsbin.com/bayewo/2/edit?js,console</a></p>

<p>However this has one important consequence. Since you've already subscribed to the source Observable you turned it from ""cold"" to ""hot"" (maybe it doesn't matter in your use-case).</p>
","310726","","310726","","2017-01-19 10:50:15","2017-01-19 10:50:15","","","","0","","","","CC BY-SA 3.0"
"41740345","1","41742677","","2017-01-19 11:10:15","","1","65","<p>Hy, i faced a problem with RxJS Combination operators...</p>

<p>here is example object:</p>

<pre><code>const userData = {
        dbKeyPath: 'www.example.com/getDbKey',
        users:[
            {name:'name1'},
            {name:'name2'},
            {name:'name3'}
        ]
    }
</code></pre>

<p>Make observable from them:</p>

<pre><code>const userDataStream  = Rx.Observable.of(userData)
const dbKeyStream : string = this.userDataStream.mergeMap(_userData =&gt; getDbKey(_userData.dbKeyPath))
const userStream = this.userDataStream.pluck('users').mergeMap(_users=&gt;Rx.Observable.from(_users))
</code></pre>

<p>My expected result is stream with combined observables:</p>

<pre><code>[user[0],dbKey],[user[1],dbKey],[user[2],dbKey]... 
</code></pre>

<p>It works pretty well with <code>withLatestFrom</code> operator:</p>

<pre><code>const result = userStream.withLatestFrom(dbKeyStream) // [user, dbkey]
</code></pre>

<p>But, how can i archive same result when i apply <code>.delay()</code> operator to <code>dbKeyStream</code> ?</p>
","7388757","","","","","2017-01-21 19:39:47","Advanced example of RxJS5 combination with delayed observable","<javascript><functional-programming><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41741334","1","41742084","","2017-01-19 12:02:25","","2","164","<p>The code below works just fine. Console outputs an array <code>[1, 2]</code>. </p>

<pre><code>const getAsyncValue = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(1);
    }, 1000)
  })
}
const getSyncValue = () =&gt; {
  return Rx.Observable.of(2);
}
const observer = (arrayOfValues) =&gt; {
  console.log(arrayOfValues);
}
Rx.Observable.of(getPromise(), getSyncValue())
  .concatAll()
  .toArray()
  .subscribe(observer)
</code></pre>

<p>I'd like to change function <code>getSyncFunction</code> to the following (because in a real world application this function might not have a reference to RxJs library):</p>

<pre><code>const getSyncValue = () =&gt; {
  return 2;
}
</code></pre>

<p>If I just do that without anything else I get an error:</p>

<blockquote>
  <p>You provided '2' where a stream was expected</p>
</blockquote>

<p>What other changes to the code do I need? Maybe hint me the operator to use.</p>
","5663381","","310726","","2017-01-19 12:43:48","2017-01-19 13:09:44","Create an array from sync and async values","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41742084","2","","41741334","2017-01-19 12:42:40","","3","","<p>The problem is not in <code>getSyncValue()</code> but in <code>concatAll()</code> that works with higher-order Observables. When you pass it just <code>2</code> it throws the error. Using <code>Rx.Observable.of(2)</code> is correct because it's an Observable that emits a single value <code>2</code> which is remitted by <code>concatAll()</code>.</p>

<p>I don't know what your code should do but you could do for example:</p>

<pre><code>Rx.Observable.of(getPromise(), getSyncValue())
  .map(v =&gt; typeof(v) == 'object' ? v : Rx.Observable.of(v))
  .concatAll()
  ...
</code></pre>

<p>However, I do recommend to rethink this because I guess you could use some easier approach than this.</p>
","310726","","310726","","2017-01-19 13:09:44","2017-01-19 13:09:44","","","","1","","","","CC BY-SA 3.0"
"41742677","2","","41740345","2017-01-19 13:13:05","","1","","<p>I would suggest using the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer"">mergeMap overload with the selectorFunc</a>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const userData = {
        dbKeyPath: 'www.example.com/getDbKey',
        users:[
            {name:'name1'},
            {name:'name2'},
            {name:'name3'}
        ]
    };

function getDbKey(path) {
  return Rx.Observable.of('the-db-key:'+path)
    .do(() =&gt; console.log('fetching db key for path: '+ path))
    .delay(1000);
}

const userDataStream  = Rx.Observable.of(userData)
  .mergeMap(
    _userData =&gt; getDbKey(_userData.dbKeyPath),
    (_userData, dbKey) =&gt; _userData.users.map(_usr =&gt; ({ user: _usr, dbKey }))
  )
.subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>This gives you the input object and each output value to combine together as you require.</p>
","106909","","106909","","2017-01-21 19:39:47","2017-01-21 19:39:47","","","","4","","","","CC BY-SA 3.0"
"41752994","1","41763089","","2017-01-19 22:36:57","","1","501","<p>I started doing functional chains using RxJs 5 and really enjoying it. I noticed a pattern that I encounter often, but couldn't find a way to solve it using RxJs's methods.</p>

<p>I get <strong>some async data</strong> using a <code>value</code> and <strong>merge them</strong> with value itself. </p>

<p>Let me show you in code:</p>

<pre><code>Rx.Observable.fromPromise(somePromise) // doesn't really matter
  .flatMap(value =&gt; {  // this is the original value I have
    const promise = aFunctionThatReturnsPromise(value);
    return Promise.all([promise, value])); // I created a promise using this value, but I still want to keep value as well
  })
  .map(([promiseValue, originalValue]) =&gt; ({ // I merge new produced values with the value itself and get rid of array.
    value1: promiseValue.value1,
    value2: promiseValue.value2
    originalValue: originalValue
  }))
  // ...rest of the chain...
</code></pre>

<p>As it can be seen, this means to create a combined promise with <code>Promise.all</code> just to keep <code>value</code> and a cleanup phase with <code>map</code> to make things nicer for following parts of the chain.</p>

<p>Is there a <strong>built-in</strong> RxJs construct for this kinds of pattern? Or is there another approach that yields to cleaner more understandable solution?</p>
","158523","","","","","2017-01-20 11:58:48","Rxjs - Merging an async response with a sync response","<rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"41763089","2","","41752994","2017-01-20 11:53:45","","2","","<p>When you want to do something with the input value combined with the output value people tend to write:</p>

<pre><code>Rx.Observable.of('foo')
  .mergeMap(i =&gt; aFunctionThatReturnsPromise(i)
    .map(asyncResult =&gt; ({ foo: i, result: asyncResult})
  )
</code></pre>

<p>This pattern can be simplified using the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer""><code>mergeMap</code> <code>resultSelector</code></a> (<code>flatMap</code> if rxjs4) into the following:</p>

<pre><code>Rx.Observable.of('foo')
  .mergeMap(
    i =&gt; aFunctionThatReturnsPromise(i),
    (i, asyncResult) =&gt; ({ syncValue: i, asyncResult })
  )
// ... rest of the chain
</code></pre>

<p>This gives you acces to your original input value and every output value received. Additional bonus is that <code>mergeMap</code> will wrap your promise into an observable without using <code>Rx.Observable.fromPromise()</code>. </p>
","106909","","106909","","2017-01-20 11:58:48","2017-01-20 11:58:48","","","","0","","","","CC BY-SA 3.0"
"41768976","1","41771578","","2017-01-20 17:10:35","","0","140","<p>When I upgrade RxJS from 5.0.0-rc.4 to 5.0.1 my HTTP unit tests fail with ..</p>

<blockquote>
  <p>TimeoutSubscriber</p>
</blockquote>

<p>The code works with 5.0.0-rc.4</p>

<p>This is the failing code. Any ideas appreciated.</p>

<pre class=""lang-js prettyprint-override""><code>  private getHttpStream$(emit: any, url: string, httpResponseMapCallback: any, method: string) {
    return this.http[method](url, emit, this.options)
      .timeout(Config.http.timeout, new Error('timeout'))

      .map((response: any) =&gt; {
        if (response.status &amp;&amp; !response.status.toString().startsWith(2)) {
          return response;
        }
        // within the callback, emit provides access to the data emitted
        return httpResponseMapCallback({emit, response});
      })

      .catch((err: any) =&gt; {
        // Different code flow in real code v unit test code
        /* istanbul ignore next */
        if (err.status &amp;&amp; err.statusText) {
          return Observable.from([err]);
        }

        return Observable.from([err.message]);
      });
  }
</code></pre>
","1205871","","106909","","2017-01-20 20:34:22","2017-01-20 20:34:22","Angular2 RxJS 5.01 upgrade TimeoutSubscriber error","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41771578","2","","41768976","2017-01-20 20:09:26","","1","","<p>The overload of <code>.timeout(timeout, customErr, scheduler)</code> with a custom error <a href=""https://github.com/ReactiveX/rxjs/issues/2257"" rel=""nofollow noreferrer"">has been removed</a>. It was <a href=""https://github.com/ReactiveX/rxjs-core-notes/blob/master/2016-12/december-05.md"" rel=""nofollow noreferrer"">one of the last changes</a> going from beta/rc to final release</p>

<p>Change your code to this:</p>

<pre><code>return this.http[method](url, emit, this.options)
  .timeout(Config.http.timeout)
</code></pre>

<p>or if you need a custom error:</p>

<pre><code>return this.http[method](url, emit, this.options)
  .timeout(Config.http.timeout)
  .catch(err =&gt; err instanceof Rx.TimeoutError ? Rx.Observable.throw(new MyCustomError()) : Rx.Observable.throw(err))
</code></pre>
","106909","","","","","2017-01-20 20:09:26","","","","1","","","","CC BY-SA 3.0"
"41771999","1","41772984","","2017-01-20 20:38:52","","4","1074","<p>Learning observable and Angular2. I want to find out the BEST practices of sharing an observable between multiple Angular2 components. As observable default is NOT multicast. So each subscription in different part of my app will open an new stream (call my API server again!). Also, I need to share the value and get the latest value of that observable. I hear people using behavior subject. But that is really confusing and I can not find a good example for that. Here is how I approach this in my authService: </p>

<pre><code>    userInfo$: Observable&lt;User&gt;;

    this.userInfo$ = this.authInfo$
    .switchMap(authInfo =&gt; this.findUserByuid(authInfo.$uid)) // finding user info base on authInfo turn or not. 
    .publishReplay(1).refCount();
</code></pre>

<p>And in my Angular2 component, I do this: </p>

<pre><code> this.authService.userInfo$.subscribe(user =&gt; {
  console.log (user);
  this.user = user;
})
</code></pre>

<p>Everything works. But I wonder could I use behavior subject in this case? Am I doing everything right by sharing the userInfo$ among ALL my components (all my components which need userinfo$ will do the above code to subscribe to it)?  </p>
","3308464","","310726","","2017-01-20 21:58:51","2017-01-20 21:58:51","Sharing an observable between components / multicast an observable in Angular2","<angular><rxjs><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41772984","2","","41771999","2017-01-20 21:56:17","","5","","<p>Operator <code>.publishReplay(1)</code> is just a shorthand for:</p>

<pre><code>.multicast(new ReplaySubject(1))
</code></pre>

<p>If you want to use <code>BehaviorSubject</code> you can use <code>.publishBehavior('default')</code> which is a shorthand for.</p>

<pre><code>.multicast(new BehaviorSubject('default'))
</code></pre>

<p>Since you're using multicasting already with <code>.refCount()</code> you should be fine but it's hard to give any advice from what we can see here.</p>

<p>If you can or can't use <code>BehaviorSubject</code> in your case depends on what you want to do. <code>BehaviorSubject</code> takes as argument a default value that is emitted to its subscribers immediately when they subscribe. <code>ReplaySubject</code> repeats a series of items from the source Observable that were emitted previously.</p>
","310726","","","","","2017-01-20 21:56:17","","","","0","","","","CC BY-SA 3.0"
"41779910","1","41784432","","2017-01-21 13:24:29","","11","9473","<p>I brought the book <em>""rxjs in action""</em> and just finish the testing section.</p>

<p>Testing rxjs codes are different then usual testing, because everything are lazy loading. </p>

<p>In the book, they mention two test method, either passing done(I am using QUnit and done signals async code is finish) or marble diagrams.   </p>

<p>My question is, which method should I choose, that I have mentioned above? </p>
","1743843","","542251","","2019-12-19 08:53:59","2020-12-31 11:15:20","The right way to test rxjs","<javascript><rxjs><rxjs5><rxjs-test-scheduler>","2","3","3","","","CC BY-SA 4.0"
"41782879","1","41783540","","2017-01-21 18:24:13","","0","115","<p>I have stripped down my problem to this simple example.</p>

<pre><code>var button1Click$ = Rx.Observable.fromEvent(document.getElementById('button1'),'click')
                      .map(function(){
                        console.log('Map:all');
                        return ""all""
                      })

var odd$ = button1Click$.filter(function(){
   return (Date.now() %2 === 1);
})
.map(function(){
      console.log('Map:odd');
       return ""odd""
     })



var combined$ = button1Click$.merge(odd$);
combined$.subscribe(function(ev){
  console.log(ev);
});
</code></pre>

<p><a href=""https://jsbin.com/diredeb/edit?js,console,output"" rel=""nofollow noreferrer"">Demo: https://jsbin.com/diredeb/edit?js,console,output</a></p>

<p>I have created a stream of clicks and a stream of odd clicks(based on current time) by filtering clicks stream.
Now I want a single stream, which receives both events 'all' and 'odd'.
So I am merging these two stream with <code>merge</code>. Problem is with <code>merge</code>, <code>map</code> defined in <code>button1Click$</code> is getting invoked twice. Suppose If I create another stream named <code>even$</code> and merge it too, <code>map</code> is getting invoked thrice. Check the demo.</p>

<p>How can I merge the streams so that <code>map</code> (defined for <code>button1Click$</code>) gets invoked only once per click.</p>
","183200","","183200","","2017-01-21 18:29:18","2017-01-21 19:27:08","Merge two streams in RxJs without replay","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41783540","2","","41782879","2017-01-21 19:27:08","","1","","<p>Just <code>share</code> the <code>button1Clicked$</code>:</p>

<pre><code>var button1Click$ = Rx.Observable.fromEvent(document.getElementById('button1'),'click')
                  .map(function(){
                    console.log('Map:all');
                    return ""all""
                  })
                  .share();
</code></pre>
","1518765","","","","","2017-01-21 19:27:08","","","","1","","","","CC BY-SA 3.0"
"41784432","2","","41779910","2017-01-21 20:57:50","","12","","<p>I have been getting this question a lot from my colleagues. I finally got around to document <a href=""http://markswanderingthoughts.nl/post/156181940080/how-i-do-testing-of-rxjs4-and-rxjs5-code"" rel=""noreferrer"">my ways of testing RxJs on my blog</a>. Since your question seems to be related to RxJs5 i will only quote the relevant part of my post here. </p>

<h2>Testing in RxJs5 the RxJs4 way</h2>

<p>When you migrate your codebase from RxJs4 towards 5 you will find out that a lot of things have been moved, renamed and above all that the implementation of the TestScheduler is no longer available. RxJs contributor kwonoj has created a <a href=""https://www.npmjs.com/package/@kwonoj/rxjs-testscheduler-compat"" rel=""noreferrer"">compatibility shim to help migration towards RxJs5</a>. You can install it using npm <code>npm install @kwonoj/rxjs-testscheduler-compat</code>. Not all features of the TestScheduler are implemented but the most important <code>.startScheduler</code> is working.</p>

<pre><code>const TestScheduler = require('@kwonoj/rxjs-testscheduler-compat').TestScheduler;
const next = require('@kwonoj/rxjs-testscheduler-compat').next;
const complete = require('@kwonoj/rxjs-testscheduler-compat').complete;

it('works in RxJs5 with the compat package', () =&gt; {
  const scheduler = new TestScheduler(); // Note; no longer the Rx.TestScheduler

  const results = scheduler.startScheduler(
    () =&gt; Rx.Observable.interval(100, scheduler).take(3),
    { created: 100, subscribed: 200, unsubscribed: 1000 } // NOTE: disposed is now renamed to unsubscribed
  );

  collectionAssert.assertEqual(res.messages, [
    next(200 + 100, 0),
    next(200 + 200, 1),
    next(200 + 300, 2),
    complete(200 + 300)
  ]);
});
</code></pre>

<h2>Testing in RxJs5 using the new Marble testing syntax</h2>

<p>The RxJs team has introduced <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md#anatomy-of-a-test"" rel=""noreferrer"">marble testing syntax</a> to more visually define how your operator or custom code should operate.</p>

<pre><code>var e1 = hot('----a--^--b-------c--|');
var e2 = hot(  '---d-^--e---------f-----|');
var expected =      '---(be)----c-f-----|';

expectObservable(e1.merge(e2)).toBe(expected);
</code></pre>

<p>At the time of writing this post they have not yet made this approach really easy to use outside of the RxJs5 library itself. There are <a href=""https://github.com/ngrx/store/blob/master/spec/helpers/marble-testing.ts"" rel=""noreferrer"">implementations available</a> to see how to do it yourself. You can also look around in the <a href=""https://github.com/ReactiveX/rxjs/blob/147ce3e4c36807b5c61c7e82ccfff1490eed54ff/.markdown-doctest-setup.js"" rel=""noreferrer"">codebase of RxJs5</a> to see how to setup your testing framework to do your own marble tests. There is an open <a href=""https://github.com/ReactiveX/rxjs/issues/1791"" rel=""noreferrer"">issue about documenting testing with RxJs5</a>. I have not yet succeeded to get my testing framework setup to do marble testing in this way.</p>
","106909","","","","","2017-01-21 20:57:50","","","","4","","","","CC BY-SA 3.0"
"41786396","1","41789882","","2017-01-22 01:25:21","","3","319","<p>Can anybody explain what the differents between these 3 variants?</p>

<p><a href=""http://jsfiddle.net/8vx2g3fr/2/"" rel=""nofollow noreferrer"">http://jsfiddle.net/8vx2g3fr/2/</a></p>

<ol>
<li>First works as excpect, all events are processed. </li>
<li>But second loses last event (3) </li>
<li>Third loses second event (2)</li>
</ol>

<p>Could you please help me to understand what the issue is and how to make the third variant process all events?</p>

<h1>1</h1>

<pre><code>let bs = new Rx.Subject();
bs
    .subscribe(v=&gt;{
        console.log(""in"", v);
        if (v % 2 == 0) {
            setTimeout(()=&gt;{
                console.log("" out"", v, ""-&gt;"" , v + 1);
                bs.next(v+1);
            }, 0);
        }
    });

bs.next(0);
bs.next(2);
</code></pre>

<p>Output:</p>

<pre><code>in 0
in 2
 out 0 -&gt; 1
in 1
 out 2 -&gt; 3
in 3
</code></pre>

<h1>2</h1>

<pre><code>let bs2 = new Rx.Subject();
bs2
    .subscribe(v=&gt;{
        console.log(""in"", v);
        if (v % 2 == 0) {            
            Rx.Observable.interval(0).take(1)
                .map(()=&gt;{console.log("" out"", v, ""-&gt;"" , v + 1);return v+1;})
                .subscribe(bs2);
        }
    });

bs2.next(0);
bs2.next(2);
</code></pre>

<p>Output:</p>

<pre><code>in 0
in 2
 out 0 -&gt; 1
in 1
 out 2 -&gt; 3
</code></pre>

<h1>3</h1>

<pre><code>let bs3 = new Rx.Subject();
bs3
    .switchMap(v=&gt;{
        console.log(""in"", v);
        if (v % 2 == 0) {            
            return Rx.Observable.interval(0).take(1)
                .map(()=&gt;{console.log("" out"", v, ""-&gt;"" , v + 1);return v+1;});
        }

    return Rx.Observable.empty();     
    }).subscribe(bs3);

bs3.next(0);
bs3.next(2);
</code></pre>

<p>Output:</p>

<pre><code>in 0
in 2
 out 2 -&gt; 3
in 3
</code></pre>
","1412449","","310726","","2017-01-22 10:37:03","2017-01-22 10:37:03","Rx.Subject loses events","<javascript><rxjs><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"41789882","2","","41786396","2017-01-22 10:34:53","","4","","<p>This all is in fact expected behavior.</p>

<p>The confusing thing is what happens when you reuse <code>Subject</code>and an operator such as <code>take()</code> multiple times.</p>

<p>Operator <code>take(1)</code> takes just a single value and send <code>complete</code> notification. This notification is received by the <code>Subject</code> because of <code>.subscribe(bs2)</code>. Now comes the most important part.<br>
When a <code>Subject</code> receives a <code>complete</code> or <code>error</code> notification it marks itself as stopped. This means it <strong>will never remit any items or notifications</strong> which is correct and expected behavior in Rx. Notifications <code>complete</code> or <code>error</code> have to be the last emissions.</p>

<p>So the <code>Subject</code> is completed by the first <code>take(1)</code> which is triggered by value <code>0</code> (the <code>bs2.next(0)</code> call).</p>

<p>Then when value <code>2</code> triggers the second run of the <code>Observable.interval(0).take(1)</code> it's received by the <code>Subject</code> but it's automatically ignored because the <code>Subject</code> is already marked as stopped.</p>

<p>The process in you third demo is exactly the same.</p>

<p>You can see it in the source code in <code>Subject.ts</code>:</p>

<ul>
<li><p><a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts#L86"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts#L86</a></p></li>
<li><p><a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts#L56"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts#L56</a></p></li>
</ul>
","310726","","","","","2017-01-22 10:34:53","","","","5","","","","CC BY-SA 3.0"
"41790649","1","41791440","","2017-01-22 12:02:38","","0","605","<p>I want to delay a Stream of data with a delay as defined in the data:</p>

<pre><code>Rx.Observable.from([
  {message: ""one"", delay: 100}, 
  {message: ""two"", delay: 500}, 
  {message: ""three"", delay: 10500}
]).subscribe((e) =&gt; console.log(e.message))
</code></pre>

<ol>
<li>It should log ""one"" after 100 ms, ""two"" after 500 ms.</li>
<li>I would like to be able to cancel the timer before the message âthreeâ is emitted.</li>
</ol>

<p>How would I define a rxjs 5 scheduler to accomplish that?</p>
","2271483","","2271483","","2017-01-22 12:20:15","2017-01-22 13:40:24","Delaying rxjs 5 Observable emission by time defined in data with scheduler","<rxjs><rxjs5>","1","5","0","","","CC BY-SA 3.0"
"41791440","2","","41790649","2017-01-22 13:25:00","","4","","<p>Depending on <em>how</em> you want to delay there are a few routes you can take:</p>

<h2>Delay the given time between each emission</h2>

<p>Using <code>.concatMap</code> every emission will have to wait for the delayed previous emission to complete before the next:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.from([
  {message: ""one"", delay: 500}, 
  {message: ""two"", delay: 500}, 
  {message: ""three"", delay: 500}
])
.concatMap(val =&gt; Rx.Observable.of(val.message).delay(val.delay))
.subscribe(val =&gt; console.log(val))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Every emission arrives after the previous has been done.</p>

<h2>Delay should be relative to start of stream:</h2>

<p>Using <code>.mergeMap</code> all emissions will be started at the time they arrive and their delay will start at that time.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.from([
  {message: ""one"", delay: 500}, 
  {message: ""two"", delay: 500}, 
  {message: ""three"", delay: 500}
])
.mergeMap(val =&gt; Rx.Observable.of(val.message).delay(val.delay))
.subscribe(val =&gt; console.log(val))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Note that all three emissions arrive at the same time. </p>

<p>By using standard Rx operators your cancellation support is built in. Just unsubscribe from the stream and all pending future emissions are ignored.</p>
","106909","","106909","","2017-01-22 13:40:24","2017-01-22 13:40:24","","","","0","","","","CC BY-SA 3.0"
"41797439","1","41797505","","2017-01-22 23:46:59","","106","47121","<p>I'm wondering what are the differences between <code>Observable.combineLatest</code> and <code>Observable.forkJoin</code>?</p>
<p>As far as I can see, the only difference is <code>forkJoin</code> expects the Observables to be completed, while <code>combineLatest</code> returns the latest values.</p>
","401353","","74089","","2021-03-19 18:31:19","2021-06-09 22:39:56","Rxjs: Observable.combineLatest vs Observable.forkJoin","<rxjs><rxjs5>","3","1","21","","","CC BY-SA 4.0"
"41797505","2","","41797439","2017-01-22 23:56:56","","155","","<p>Not only does <code>forkJoin</code> require all input observables to be completed, but it also returns an observable that produces a single value that is an array of the last values produced by the input observables. In other words, it waits until the last input observable completes, and then produces a single value and completes.</p>

<p>In contrast, <code>combineLatest</code> returns an Observable that produces a new value every time the input observables do, once all input observables have produced at least one value. This means it could have infinite values and may not complete. It also means that the input observables don't have to complete before producing a value.</p>
","507784","","507784","","2017-03-08 22:07:35","2017-03-08 22:07:35","","","","6","","","","CC BY-SA 3.0"
"41811388","1","41812340","","2017-01-23 16:45:32","","1","758","<p>I have an Angular 2 service connected to the Angular Http service with Rxjs 5 to connect to a restful web service. The getObjects call simply returns the parsed Json in the form of an Observable array of meaningful objects. I've been trying to get the observable returned to resolve with my mocked Http response, but I haven't really found a working answer to this.</p>

<p>Test code:</p>

<pre><code>import { getTestBed } from '@angular/core/testing';
import { MockBackend } from '@angular/http/testing';
import { TestScheduler } from ""rxjs"";

import { expect } from 'chai';
import { spy } from 'sinon';
import TestingUtilities from ""../shared/test.utilities"";

import Service from './service';
import ReturnObject from ""../returnobject"";

describe(`ServiceTests`, () =&gt; {
  let MOCK_DATA: string = ...mocked JSON string response...;

  let service: Service
  let backend: MockBackend
  let scheduler: TestScheduler

  function assertDeepEqualFrame(actual:any, expected:any) {
    console.log(""test"");
    if (!expected === actual) {
      throw new Error('Frames not equal!');
    }
  }

  beforeEach(() =&gt; {
    TestingUtilities.configureTestingModuleForMockHttp(getTestBed(), function () {
      return Service
    });

    backend = getTestBed().get(MockBackend);
    service = getTestBed().get(EarthquakeService);
    scheduler = new TestScheduler(assertDeepEqualFrame);
  });

  it('should return mocked data', () =&gt; {
    TestingUtilities.mockHttpResponse(backend, MOCK_DATA);

    let observables = service.getObjects();
    scheduler.expectObservable(observables).toBe("""", functionToCreateMockObjects());
  });
</code></pre>

<p>The TestingUtilities is just a convenience wrapper around the solution for mocking the Http service provided by Angular presented at <a href=""https://semaphoreci.com/community/tutorials/testing-angular-2-http-services-with-jasmine"" rel=""nofollow noreferrer"">https://semaphoreci.com/community/tutorials/testing-angular-2-http-services-with-jasmine</a>. This code above compiles, but it doesn't actually seem to return the mocked Observables nor assert on anything. I'm struggling to see exactly how the TestScheduler should be used to call an existing service and get observables back for validation. Anyone have any ideas?</p>
","1075621","","","","","2017-01-23 17:43:25","Rxjs5 Testing With Angular 2","<unit-testing><angular><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41812265","1","41812714","","2017-01-23 17:34:50","","11","8400","<p>Based on the parameters of the function I want to build the forkJoin() method.</p>

<p>For example:</p>

<ul>
<li>if parameter1 is empty => don't put a http request for it inside the
forkJoin() </li>
<li>if parameter2 is empty => don't put a http request for it
inside the forkJoin()</li>
</ul>

<p><strong>Code:</strong></p>

<pre><code>getAllByIds(parameter1: any, parameter2: any) {

    let itemList = new Array();

    return Observable.forkJoin(
         this.http.get('rest/fillin/ids/' + parameter1) // don't put this request for parameter1 if it is empty
         .map((res: Response) =&gt; res.json()),

         this.http.get('rest/textitem/ids/' + parameter2) // don't put this request for parameter2 if it is empty
         .map((res:Response) =&gt; res.json())
    ).map(
        data =&gt; {
            itemList.push(data[0]);
            itemList.push(data[1]);
            return itemList;
         }
     );
}
</code></pre>

<p>So, is it possible to build up the forkJoin() like this?</p>
","1816781","","","","","2017-01-23 18:00:28","Conditional Observable.forkJoin() building","<angular><rxjs><rxjs5><reactivex>","1","0","3","","","CC BY-SA 3.0"
"41812340","2","","41811388","2017-01-23 17:39:14","","1","","<p>I do not use the TestScheduler to test observables. But I really like the following approach that I use: </p>

<pre><code>import {TestBed, inject} from '@angular/core/testing';
import {BaseRequestOptions, Http, HttpModule, ResponseOptions, Response} from '@angular/http';
import {MockBackend} from '@angular/http/testing';
import {Book} from '../custom-types/book';
import {GoogleBooksService, API_PATH_SINGLE_BOOK} from './google-books.service';

const mockedHttpProvider = {
    provide: Http,
    deps: [MockBackend, BaseRequestOptions],
    useFactory: (backend: MockBackend, defaultOptions: BaseRequestOptions) =&gt; {
        return new Http(backend, defaultOptions);
    }
};

describe('Service: GoogleBooks', () =&gt; {
    beforeEach(() =&gt; {
        TestBed.configureTestingModule({
            imports: [HttpModule],
            providers: [
                GoogleBooksService,
                BaseRequestOptions,
                MockBackend,
                mockedHttpProvider
            ],
        });
    });

    it('should call the google books api',
        inject([GoogleBooksService, MockBackend], (service: GoogleBooksService, backend: MockBackend) =&gt; {
            let queryId: string = ""someId"";
            let expectedResponse: Book = {
                description: 'It's just Angular',
                title: 'How to test Observables'
            };

            backend.connections.subscribe(connection =&gt; {
                expect(connection.request.url).toBe(API_PATH_SINGLE_BOOK + queryId);
                let response = new ResponseOptions({body: JSON.stringify(expectedResponse)});
                connection.mockRespond(new Response(response));
            });

            service.getBookByGoogleBookId(queryId).subscribe(response =&gt; {
                expect(response).toEqual(expectedResponse);
            })
        })
    );
});
</code></pre>

<p>Service implementation:</p>

<pre><code>@Injectable()
export class GoogleBooksService {

    constructor(private http: Http) {
    }

    getBookByGoogleBookId(id: string): Observable&lt;Book&gt; {
        return this.http.get(API_PATH + id)
            .map(res =&gt; res.json());
    }
}
</code></pre>
","1863474","","","","","2017-01-23 17:39:14","","","","1","","","","CC BY-SA 3.0"
"41812714","2","","41812265","2017-01-23 18:00:28","","20","","<p>Actually this depends on what do you expect to get when you skip some HTTP requests.</p>

<p>Should the output from <code>forkJoin()</code> contain <code>null</code> values or just ignore it completely?</p>

<pre><code>function mockHTTPRequest(id) {
  return Observable.of(id).delay(100);
}

let parameter1 = 'a';
let parameter2 = false;

let sources = [];
if (parameter1) {
  sources.push(mockHTTPRequest('rest/fillin/ids/' + parameter1));
}
if (parameter2) {
  sources.push(mockHTTPRequest('rest/textitem/ids/' + parameter2));
}

Observable.forkJoin(...sources)
  .map(data =&gt; {
    console.log(data.length);
    return data;
  })
  .subscribe(values =&gt; console.log(values));
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/qorulel/5/edit?js,console"" rel=""noreferrer"">https://jsbin.com/qorulel/5/edit?js,console</a></p>

<p>This solution just doesn't create source Observables if <code>parameter1</code> or <code>parameter2</code> is false. Notice, that <code>console.log(data.length)</code> can be from <code>0</code> to <code>2</code> depending on <code>parameterX</code> values.</p>

<p>Or you can just create <code>Observable.of(null)</code> instead of the HTTP requests.</p>

<pre><code>function mockHTTPRequest(id) {
  return Observable.of(id).delay(100);
}

let parameter1 = 'a';
let parameter2 = false; 

let sources = [
  parameter1 ? mockHTTPRequest('rest/fillin/ids/' + parameter1) : Observable.of(null),
  parameter2 ? mockHTTPRequest('rest/textitem/ids/' + parameter2) : Observable.of(null)
];

Observable.forkJoin(...sources)
  .map(data =&gt; {
    console.log(data.length);
    return data;
  })
  .subscribe(values =&gt; console.log(values));
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/caheno/5/edit?js,console"" rel=""noreferrer"">https://jsbin.com/caheno/5/edit?js,console</a></p>

<p>Now the output has always 2 values. Just some of them are <code>null</code>.</p>
","310726","","","","","2017-01-23 18:00:28","","","","4","","","","CC BY-SA 3.0"
"41813747","1","","","2017-01-23 19:03:33","","4","1363","<p>I have 2 (or more) Observables returned from services, each of them only returning one value (think <code>Observable.just()</code>). Each of them is of different type (I'm writing in TypeScript so types matter).</p>

<p>Is there a way to know when all Observables resolved (using promises terminology) either successfully or failed, I need to be able to handle failures individually, and carry on.</p>

<p>contrived example:</p>

<pre><code>const obs1  = someService.getThisThing(); //Observable&lt;Type1&gt;
const obs2  = someService.getAnotherThing(); //Observable&lt;Type2&gt;

const someObj = {};

obs1.subscribe(v1 =&gt; someObj.v1 = v1);
obs2.subscribe(v2 =&gt; someObj.v2 = v2);

// call someFunc(someObj), only when both above observables resolved to a value
someFunc(someObj);
</code></pre>

<p>I have tried using <code>merge</code> but then I loose type safety as values may come in any order, and I have to inspect their type in <code>.subscribe</code> to determine which is which</p>

<p>I have tried <code>combine</code> and <code>combineLatest</code> as described <a href=""https://stackoverflow.com/questions/41250453/how-to-sequence-multiple-observables"">here</a> - but then they both resolve at the same time, and if 1 fails - everything fails</p>
","272924","","-1","","2017-05-23 10:31:19","2017-01-23 21:56:58","How to resolve multiple Observables","<javascript><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41813865","1","41814894","","2017-01-23 19:12:33","","2","937","<p>I created an Observable that caching their results for some period of time. The example is great and very useful !! But I couldn't set a timeout for the item producer. I was trying to use the timeout operator within <code>mockDataFetch()</code> but after the first failed item, the stream couldn't be recovered.
How to achieve a <code>mockDataFetch</code> with a timeout?</p>

<p>This is exactly what I did:</p>

<pre><code>const Observable = Rx.Observable;

var counter = 1;
var updateRequest = Observable.defer(() =&gt; mockDataFetch())
    .publishReplay(1, 1000)
    .refCount();

function mockDataFetch() {
    return Observable.of(counter++)
        .delay(Math.floor((Math.random() * 100) + 1))
        .timeout(50);
}

function mockHttpCache() {
    return updateRequest
        .take(1);
}
</code></pre>

<p>On the other hand, What happens if get an Excpetion within the <code>mockDataFetch</code>? I would expect that on the next item (after 1000 ms, as it's defined in the <code>publishReplay</code> method) the observable emits a new item.</p>
","3392786","","641914","","2017-09-23 17:12:46","2017-09-23 17:12:46","How to set a timeout on a RxJS Observable with a cache throught `.publishReplay()`?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41814894","2","","41813865","2017-01-23 20:21:21","","1","","<p>I think I should update the example and add this use-case because this is a pretty common situation (anyway, I'm glad you find it useful!).</p>

<p>When the Observable returned from <code>mockDataFetch()</code> sends error/complete notification the Subject inside marks itself as stopped (see explanation <a href=""https://stackoverflow.com/questions/41786396/rx-subject-loses-events/41789882#41789882"">Rx.Subject loses events</a>) so it won't reemit any items. You can ideally catch all errors with <code>catch()</code> operator inside <code>mockDataFetch()</code>:</p>

<pre><code>function mockDataFetch() {
    return Observable.of(counter++)
        .delay(Math.floor((Math.random() * 100) + 1))
        .timeout(50)
        .catch(err =&gt; Observable.of('This request is broken.'));
}
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/jiguti/5/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/jiguti/5/edit?js,console</a></p>

<p>Output from this could look for example like the following:</p>

<pre><code>Response 0: This request is broken.
Response 50: This request is broken.
Response 200: This request is broken.
Response 1200: 2
Response 1500: 2
Response 3500: This request is broken.
</code></pre>
","310726","","-1","","2017-05-23 12:08:53","2017-01-23 20:21:21","","","","1","","","","CC BY-SA 3.0"
"41818793","1","41818876","","2017-01-24 01:59:03","","16","6798","<p>My goal is to create an animation loop Ã  la <code>requestAnimationFrame</code> so that I could do something like this:</p>

<pre><code>animationObservable.subscribe(() =&gt;
{
    // drawing code here
});
</code></pre>

<p>I tried this code as a basic test:</p>

<pre><code>let x = 0;

Rx.Observable
    .of(0)
    .repeat(Rx.Scheduler.animationFrame)
    .takeUntil(Rx.Observable.timer(1000))
    .subscribe(() =&gt; console.log(x++));
</code></pre>

<p><a href=""https://jsfiddle.net/kendfrey/feb9tqar/"" rel=""noreferrer"">Here is a JSFiddle but I'm not liable for any browser crashes from running this.</a></p>

<p>I expected this to log the numbers from 0 to approximately 60 (because that is my monitor's refresh rate) over 1 second. Instead, it rapidly logs numbers (much faster than <code>requestAnimationFrame</code> would), begins to cause the page to lag, and finally overflows the stack around 10000 and several seconds later.</p>

<p>Why does the <code>animationFrame</code> scheduler behave this way, and what is the correct way to run an animation loop with RxJS?</p>
","785745","","","","","2019-03-01 15:41:25","How can I use RxJS to generate a requestAnimationFrame loop?","<javascript><rxjs><rxjs5><requestanimationframe>","3","0","3","","","CC BY-SA 3.0"
"41818876","2","","41818793","2017-01-24 02:08:50","","20","","<p>It's because the default behaviour of <code>Observable.of</code> is to emit immediately.</p>

<p>To change this behaviour, you should specify the <code>Scheduler</code> when calling <code>Observable.of</code>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let x = 0;

Rx.Observable
    .of(0, Rx.Scheduler.animationFrame)
    .repeat()
    .takeUntil(Rx.Observable.timer(1000))
    .subscribe(() =&gt; console.log(x++));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.3/dist/global/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Or, <a href=""https://mobile.twitter.com/BenLesh/status/901919142034284546"" rel=""noreferrer"">more simply</a>, replace the <code>of</code> and <code>repeat</code> operators with:</p>

<pre><code>Observable.interval(0, Rx.Scheduler.animationFrame)
</code></pre>
","6680611","","6680611","","2017-08-28 03:18:03","2017-08-28 03:18:03","","","","3","","","","CC BY-SA 3.0"
"41830912","1","","","2017-01-24 14:37:51","","1","816","<p>I am trying to create buffered emissions based on a throttled emission. The following works as expected in <strong>RxJs 2</strong>:</p>

<pre><code>.buffer(function() { return clickStream.throttle(250); })
</code></pre>

<p><a href=""http://jsfiddle.net/yiooxir/4gGgs/825/"" rel=""nofollow noreferrer"">full jsfiddle example here</a></p>

<p>But when I tried to use this in my local project it returns the following error:</p>

<blockquote>
  <p>Uncaught TypeError: You provided '() => clickStream.throttle(250)' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p>Here is my code</p>

<pre><code>import Rx from 'rxjs/Rx';

const $button = document.getElementById('button');
const $label = document.getElementById('label');

const clickStream = Rx.Observable.fromEvent($button, 'click');

const doubleClickStream = clickStream
  .buffer(() =&gt; clickStream.throttle(250))
  .map(arr =&gt; arr.length)
  .filter(len =&gt; len === 2)

clickStream.subscribe(x=&gt;console.log(x));

doubleClickStream
  .subscribe(() =&gt; $label.textContent = 'double click')
//
doubleClickStream
  .throttle(1000)
  .subscribe(() =&gt; $label.textContent = '-')
</code></pre>

<p>I know what my current knowledge about this library is not enough, maybe it related to the rxjs version (in working example it is 2.x and in my code above it is 5.x). </p>

<p>I also tried to write it as:</p>

<pre><code>.buffer(clickStream.throttle(250))
</code></pre>

<p>And it raised another exception after clicking on the button:</p>

<blockquote>
  <p>Uncaught TypeError: this.durationSelector is not a function</p>
</blockquote>

<p>Can you help me to understand that's wrong with it ?</p>
","3275977","","106909","","2017-01-24 15:20:00","2019-01-20 12:55:12","rxjs buffer doesn't work with throttle as expected for me","<javascript><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"41831316","1","","","2017-01-24 14:56:16","","0","44","<p>I'm trying implement my own pre-fetching logic in rx.js. Here is example marble diagrams:</p>

<p><a href=""https://i.stack.imgur.com/aoPUE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aoPUE.png"" alt=""Example marble diagrams""></a></p>

<p>I've modeled the problem as follows: There is a stream of <em>hints</em> that lets my program know that a user might want to <em>click</em> a certain link. I want to immediately send a request, but only <em>render</em> the <em>result</em> if the user indeed clicks the link.</p>

<p>Based on this, there are (at least) 3 things that can happen by the time the user clicks the link:</p>

<ol>
<li>The correct result already returned form the server.</li>
<li>The request is still in progress</li>
<li>(Special) There is no request -- finished or in progress -- because the user somehow didn't trigger a hint first.</li>
</ol>

<p>Some extra requirements:</p>

<ul>
<li>Only the latest hint should have a request in progress (i.e. cancel previous requests).</li>
<li>Once the user clicks on a link, new hints should not trigger a request until the result is rendered</li>
<li>New clicks should trigger new requests and cancel the previous request</li>
</ul>

<p>I've actually found a solution, but it is convoluted, maybe incorrect, and mostly I'd just like to know if there is a better way of doing it (see below).</p>
","870615","","","","","2017-10-27 09:39:54","Pre-fetching logic in Rx","<rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41836433","1","","","2017-01-24 18:35:22","","-1","896","<p>TLDR: Observable object doesn't trigger component rerendering until an action is made by the user (click on a button for example).</p>

<p>I'm updating an observable backed by a BehaviorSubject contained inside a service that is injected inside my component.</p>

<p>In my component, I'm using a simple <code>*ngIf=""myObservable$ | async""</code> to display a div.</p>

<p>I managed to replicate 2 situations, one working and one that doesn't but I can't understand what's the difference:</p>

<pre><code>//CASE 1
this._mySubject$.next(true); //THIS DOES TRIGGER RERENDERING
//CASE 2
this.http.get(url)
.map( res =&gt; res.json() )
.subscribe( body =&gt; {
    this._mySubject$.next(true); //THIS DOESN'T TRIGGER RERENDERING UNTIL AN ACTION IS MADE
});
</code></pre>
","3557424","","","","","2017-01-26 04:50:55","Angular2 Observable not triggering rerendering","<angular><rxjs><observable><rxjs5><behaviorsubject>","2","4","1","","","CC BY-SA 3.0"
"41839430","1","","","2017-01-24 21:37:53","","0","824","<p>(using angular 2 &amp; NgRedux 2 with ngrx 5.0.3)</p>

<p>usersReducer$, articlesReducer$ are Anonymous Subjects I receive from an imported module (ngRedux).</p>

<pre class=""lang-js prettyprint-override""><code>let merge$ = Observable.merge(this.usersReducer$, this.articlesReducer$);
  .do((data) =&gt; {
    let time = performance.now();
    console.log('%c REGULAR UPDATE ' + time, 'background: #555; color: #bada55', data);
  });

// TODO : why it doesn't work as expected?!
// The merge$ emits values, and here it only emits once and happens again only
// when the reducers change much later.
this.throttleSub = merge$
  .throttleTime(0.0000000000001)
  .do((data) =&gt; {
    let time = performance.now();
    this.refreshData();
    console.log('%c THROTTLE UPDATE ' + time, 'background: #222; color: #bada55', data);
  })
  .subscribe(() =&gt; {})
</code></pre>

<p>Output : <a href=""https://i.stack.imgur.com/jY8mo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jY8mo.png"" alt=""enter image description here""></a></p>

<p>NOTE: If I there is any userReducer$/articleReducer$ emit later, We'll see throttle UPDATE log.</p>

<p>My best guess that things are happening much to fast (that's why I put 0.00000001 in the time between, because 1 ms will emit throttle one time at the start), but the ms difference between them just makes me feel wrong about it.</p>

<p>Would love some help, im so confused.</p>

<p>(with debounceTime(1) instead of throttle, we get only 1 debounce log at the end, it doesn't seems possible that everything is less then 1ms from each other ! there is a server request in the middle !)</p>

<hr>

<p>EDIT:  I've made .timestamp() operator as Mark van Straten stated in his comment.   this is the output:
<a href=""https://i.stack.imgur.com/s7dkk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/s7dkk.png"" alt=""enter image description here""></a></p>

<hr>

<p>UPDATE :
I've chained the timestamp to the origin observable, and chained throttleTime into a different subscriber, I think now It's more clear.
<a href=""https://i.stack.imgur.com/gosvh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gosvh.png"" alt=""enter image description here""></a></p>
","3961668","","3961668","","2017-01-25 20:07:07","2017-01-25 20:07:07","Rxjs throttleTime works unexpected","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41859323","1","","","2017-01-25 18:48:41","","6","3183","<p>I have an Angular service that shares a data stream (http call) to several components asynchronously. I need to recall the http service based on user action once in a while. </p>

<p>I am using a ReplaySubject to save loaded values and send to subscribers who subscribe after the http call. </p>

<p>I would like to know if there is a way to clear the ReplaySubject's buffer before making subsequent http calls? 
While at it, I suspect that I need to also unsubscribe in order to not create a leak?</p>

<p>Service:</p>

<pre><code>@Injectable()
export class GreatDataService {

    public data$: ReplaySubject&lt;any&gt;;
    private subs: Subscription;

    constructor(private http: Http) {
        this.data$ = new ReplaySubject(1);
    }

    public refresh() {
        if (this.subs) {
            this.subs.unsubscribe();
            this.subs = null;
        }
        this.subs = this.http.get('/api').subscribe(this.data$)
    }
}
</code></pre>

<p>Top level section component:</p>

<pre><code>...
    constructor(private greatDataService: GreatDataService) {}
    ngOnInit() {
         this.greatDataService.refresh();
    }
...
</code></pre>

<p>Component 1:</p>

<pre><code>...
    constructor(private greatDataService: GreatDataService) {}
    ngOnInit() {
    this.greatDataService.data$.subscribe(
        x =&gt; console.log('subscriber 1: ' + x),
        err =&gt; console.log('subscriber 1: ' + err),
        () =&gt; console.log('subscriber 1: Completed')
    );
...
</code></pre>

<p>Component 2:</p>

<pre><code>...
    constructor(private greatDataService: GreatDataService) {}
    ngOnInit() {
    this.greatDataService.data$.subscribe(
        x =&gt; console.log('subscriber 2: ' + x),
        err =&gt; console.log('subscriber 2: ' + err),
        () =&gt; console.log('subscriber 2: Completed')
    );
...
</code></pre>
","2275792","","","","","2019-08-16 04:44:19","rxjs5/Angular - Clear ReplaySubject buffer","<angular><angular2-services><rxjs5>","2","0","0","","","CC BY-SA 3.0"
"41865471","1","41866929","","2017-01-26 03:27:16","","7","7245","<p>I have a service that returns an object map which is then used in Angular's <code>ngFor</code> which only takes arrays. So, I am using the map operator with lodash's _toArray to convert the data to an array.</p>
<p>Although this works, I then have to import lodash everywhere I need to do this and it seems brittle. I was going to look into creating a custom operator, but perhaps there is an operator that already does this? I can't seem to find the right one(s)</p>
<p>Data:</p>
<pre class=""lang-json prettyprint-override""><code>{ 0 : {data : 'lorem'}, 1 : {data : 'lorem'}, 2 : {data : 'lorem'} }
</code></pre>
<p>Current:</p>
<pre class=""lang-js prettyprint-override""><code>this.http
    .get('/api')
    .map(data =&gt; _.toArray(data));
</code></pre>
<p>Possible?</p>
<pre class=""lang-js prettyprint-override""><code>this.http
    .get('/api')
    .mapToArray();
</code></pre>
","2275792","","1657465","","2021-11-24 00:56:26","2021-11-24 00:56:26","RxJS5 - Operator to convert object map to array","<angular><rxjs5>","1","1","1","","","CC BY-SA 4.0"
"41866929","2","","41865471","2017-01-26 04:33:16","","15","","<p>You should be able to do what you want with RxJS's <code>map</code> operator and just the <code>Object.keys()</code> method.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable
  .of({
    0: { data : 'lorem' },
    1: { data : 'lorem' },
    2: { data : 'lorem' }
  })
  .map(data =&gt; Object.keys(data).map(k =&gt; data[k]))
  .subscribe(data =&gt; console.log(data));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.3/dist/global/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","5040725","","6680611","","2017-01-26 14:12:55","2017-01-26 14:12:55","","","","4","","","","CC BY-SA 3.0"
"41868976","1","41869894","","2017-01-26 07:56:34","","3","3290","

<p>I want to set interval in http request using rxjs. I need to send data on server from n seconds after request finish.</p>

<pre class=""lang-ts prettyprint-override""><code>Observable.interval(10000)
                  .?(() =&gt; {
                      //request for server. return Observable
                      return this.getData();
                  })
                  .subscribe(() =&gt; {
                      console.log(""Request done. After 10 second will be next request"");
                  });
</code></pre>

<p><strong>UPDATE based on <code>.expand()</code> suggested by Mark</strong></p>



<pre class=""lang-ts prettyprint-override""><code>ngOnInit() {
  this.getData()
    .expand(() =&gt; Rx.Observable.timer(10 * 1000)
      .concatMap(() =&gt; this.getData())
    )
    .subscribe(data =&gt; {
      console.log('received new data', data);
    });
}

private getData() {
  return Observable.timer(5000)
    .do(() =&gt; console.log(""timer""));
}
</code></pre>
","3110920","","106909","","2017-01-26 11:57:40","2017-07-14 10:51:01","How to Request Async by interval using rxjs in Angular 2","<angular><rxjs><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"41869894","2","","41868976","2017-01-26 09:01:56","","3","","<p>Your usecase is an excellent case for the <code>.expand</code> operator which can recursively execute and return new values. See this snippet in which i have added a lot of timestamp + debug logging to clarify what is going on.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function getData() {
  // simulate remote call which can take some time
  return Rx.Observable.of('')
    .timestamp()
    .do(i =&gt; console.log(`[debug] Going to fetch data from server @${i.timestamp}`))
    .map(i =&gt; 'the new JSON blob of data to use') // this would be your actual http.get call
    .delay(1500)
    .timestamp()
    .do(i =&gt; console.log(`[debug] Data retreived from server @${i.timestamp}`));
}

getData()
  .expand(_ =&gt; Rx.Observable.of('') // we need something to delay upon
    .timestamp()
    .do(i =&gt; console.log(`[debug] Waiting 1sec for next getData ${i.timestamp}`))
    .delay(1000)
    .concatMap(() =&gt; getData())
  )
  .take(5)
  .subscribe(val =&gt; console.log(`New data received @${val.timestamp} : ${val.value}`))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>so initially you subscribe to the <code>getData()</code> and expand its value to recursively <code>delay</code> for time before retrieving the next <code>getData()</code>. No subjects are involved in this approach and your subscription stays available for receiving the new values.</p>
","106909","","5423108","","2017-07-14 10:51:01","2017-07-14 10:51:01","","","","3","","","","CC BY-SA 3.0"
"41872700","1","41873022","","2017-01-26 11:42:01","","11","7040","<p>I'm working with the latest Angular and Typescript and RxJS 5.</p>

<p>Angular has currently made RxJS a necessity.  I've used C# primarily for over 10 years and I'm very much used to Linq/Lambdas/fluent syntax which I assume formed the basis of Reactive.</p>

<p>I would like to make an Http get call with an increasing timeout value on retry, but I'm having a problem seeing how to do that and still keeping everything in the pipeline (not using external state).</p>

<p>I get that I can do this, but it will just retry using the same timeout value.
</p>

<pre><code>myHttpObservable.timeout(1000).retry(2);
</code></pre>

<p>The documentation for RxJS has been poor in many places and asking about it on here only got my question deleted out of existence, which is sad...so I was forced to look through the source.</p>

<p>Is there a way to retry with an increasing timeout duration each time in a way that keeps state in the pipeline?  Also, I want an innitial timeout on the first attempt.</p>

<p>I've tried things similar to this at first, but realized the confusing retryWhen operator is not really intended for what I want:
</p>

<pre><code>myHttpObservable.timeout(1000).retryWhen((theSubject: Observable&lt;Error&gt;) =&gt; {
 return  aNewMyObservableCreatedinHere.timeout(2000);  
});
</code></pre>

<p>I know I could accomplish this using external state, but I'm basically looking for an elegant solution that, I think, is what they are kind of driving for with the reactive style of programming.</p>
","4279423","","4279423","","2017-01-30 11:02:21","2021-07-19 02:30:06","How do I adjust timeout duration on retry using RxJS?","<angular><rxjs><reactive-programming><rxjs5><typescript2.0>","5","3","7","","","CC BY-SA 3.0"
"41873022","2","","41872700","2017-01-26 12:02:37","","12","","<p>One of the biggest issues with RxJs5 at the moment is the documentation. It is really fragmented and not up to par with the previous version yet. By looking at <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/retrywhen.md"" rel=""noreferrer"">the documentation of RxJs4 you can see that <code>.retryWhen()</code></a> 
already has an <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/retrywhen.md#example-an-incremental-back-off-strategy-for-handling-errors"" rel=""noreferrer"">example</a> for building an exponential backoff available which can be easily migrated towards RxJs5:</p>

<pre><code>Rx.Observable.throw(new Error('splut'))
  .retryWhen(attempts =&gt; Rx.Observable.range(1, 3)
    .zip(attempts, i =&gt; i)
    .mergeMap(i =&gt; {
      console.log(""delay retry by "" + i + "" second(s)"");
      return Rx.Observable.timer(i * 1000);
    })
  ).subscribe();
</code></pre>
","106909","","106909","","2017-01-26 14:20:23","2017-01-26 14:20:23","","","","4","","","","CC BY-SA 3.0"
"41876379","1","41876786","","2017-01-26 15:01:56","","2","2053","<p>Wonder why my promise is resolving but attempting to retry.</p>

<pre><code>var getResultsStream = url =&gt; Rx.Observable.onErrorResumeNext( 
     Rx.Observable.defer( () =&gt; Rx.Observable
        .fromPromise( getSearchResults(url)
        .catch(error =&gt; Rx.Observable.of(`Error: ${error}`)) )
        .timeout(20000, new Error(`Timeout: ${url}`))
     )
     .do( e =&gt; console.log(`Retrying: ${url}`))
     .retry(3)
)
</code></pre>

<p>Is it a better way to retry a promise 3 times?</p>
","","user240993","","","","2017-01-26 15:19:56","Rxjs: retry a promise?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41876786","2","","41876379","2017-01-26 15:19:56","","4","","<p>Unless you have a special use for the <code>defer</code> and/or the <code>onErrorResumeNext</code>, you could throw that all out and simply use:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const request = url =&gt; Rx.Observable.of(url)
        .do(url =&gt; console.log(""requesting: "" + url))
        .switchMap(url =&gt; Rx.Observable.fromPromise(getSearchResults(url)))
        .timeout(20000, new Error(`Timeout: ${url}`))
        .retry(3);

request(""http://foobar.com"").subscribe(console.log, console.error);

function getSearchResults(url) {
  // simulating request-error
  throw new Error(""Could not reach: "" + url);
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.10/dist/global/Rx.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","","","","2017-01-26 15:19:56","","","","9","","","","CC BY-SA 3.0"
"41880983","1","41884813","","2017-01-26 19:03:06","","3","828","<p>I ran into an interesting issue today. I'm working on an app where we have file uploads, and we want to implement a progress bar. The app is written using React/Redux/Redux-Observable. I want to dispatch actions for upload progress. Here's what I did to implement it:</p>

<pre><code>withProgress(method, url, body = {}, headers = {}) {
    const progressSubscriber = Subscriber.create();

    return {
        Subscriber: progressSubscriber,
        Request:    this.ajax({ url, method, body, headers, progressSubscriber }),
    };
}
</code></pre>

<p>I have a class that I use to make all my ajax requests. <code>this.ajax</code> calls <code>Observable.ajax</code> with the passed in parameters.</p>

<pre><code>export const blobStorageUploadEpic = (action$) =&gt; {
    return action$.ofType(a.BLOB_STORAGE_UPLOAD)
    .mergeMap(({ payload }) =&gt; {
        const { url, valetKey, blobId, blobData, contentType } = payload;

        const { Subscriber, Request } = RxAjax.withProgress('PUT', `${url}?${valetKey}`, blobData, {
            'x-ms-blob-type': 'BlockBlob',
            'Content-Type':   contentType,
        });

        const requestObservable = Request
        .map(() =&gt; ({ type: a.BLOB_STORAGE_UPLOAD_SUCCESS, payload: { blobId } }))
        .catch((err) =&gt; Observable.of({ type: a.BLOB_STORAGE_UPLOAD_FAILURE, err }));

        return Observable.fromSubscriber(Subscriber)
        .map((e) =&gt; ({ percentage: (e.loaded / e.total) * 100 }))
        .map((percentage) =&gt; ({ type: a.BLOB_STORAGE_UPLOAD_PROGRESS, payload: { percentage} }))
        .merge(requestObservable);
    });
};
</code></pre>

<p>This is my epic. I get the subscriber back and I wrote a custom static method of <code>Observable</code> to take in a subscriber. I then merge that with the <code>Request</code> (which is an <code>Observable</code>).</p>

<pre><code>Observable.fromSubscriber = function fromSubscriber(externalSubscriber) {
    return Observable.create((subscriber) =&gt; {
        externalSubscriber.next =     (val) =&gt; subscriber.next(val);
        externalSubscriber.error =    (err) =&gt; subscriber.error(err);
        externalSubscriber.complete = () =&gt; subscriber.complete();
    });
};
</code></pre>

<p>Finally, here is the custom static method I wrote on <code>Observable</code>. I wrote this for two reasons. 1. As an example for anyone else dealing with a similar problem (I spent a lot of time trying to figure out how to make an <code>Observable</code> from a <code>Subscriber</code> before writing my own) and 2. To ask whether this is the best way to accomplish this goal. <code>rxjs</code> is deep, and I figure that there's an existing way to do this, but I just couldn't find it.</p>
","3882323","","","","","2017-01-26 23:27:42","Implementing fromSubscriber in rxjs","<javascript><rxjs><rxjs5><redux-observable>","1","0","2","","","CC BY-SA 3.0"
"41884813","2","","41880983","2017-01-26 23:27:42","","7","","<p>That is essentially what a <a href=""http://reactivex.io/documentation/subject.html"" rel=""noreferrer""><code>Subject</code></a> is for, the following should work as well:</p>

<pre><code>export const blobStorageUploadEpic = (action$) =&gt; {
    return action$.ofType(a.BLOB_STORAGE_UPLOAD)
    .mergeMap(({ payload }) =&gt; {
        const { url, valetKey, blobId, blobData, contentType } = payload;

        const progressSubscriber = new Rx.Subject();
        const request = Rx.Observable.ajax({
            method: 'PUT',
            url: `${url}?${valetKey}`,
            body: blobData,
            headers: {
                'x-ms-blob-type': 'BlockBlob',
                'Content-Type':   contentType,
            },
            progressSubscriber
        });

        const requestObservable = request
            .map(() =&gt; ({ type: a.BLOB_STORAGE_UPLOAD_SUCCESS, payload: { blobId } }))
            .catch((err) =&gt; Observable.of({ type: a.BLOB_STORAGE_UPLOAD_FAILURE, err }));

        return progressSubscriber
            .map((e) =&gt; ({ percentage: (e.loaded / e.total) * 100 }))
            .map((percentage) =&gt; ({ type: a.BLOB_STORAGE_UPLOAD_PROGRESS, payload: { percentage} }))
            .merge(requestObservable);
    });
};
</code></pre>

<hr>

<p>Here is a more generic example (live <a href=""https://jsfiddle.net/c5Lk009m/3/"" rel=""noreferrer"">@jsfiddle</a>):</p>

<pre><code>let data = """";
for (let c = 0; c &lt; 100000; ++c) {
    data += """" + Math.random();
}

const progressSubscriber = new Rx.Subject();
const request = Rx.Observable.ajax({
  method: 'POST',
  url: ""/echo/json/"",
  body: JSON.stringify({ data }),
  progressSubscriber
});

progressSubscriber
  .merge(request)
  .subscribe(console.log);
</code></pre>
","1518765","","","","","2017-01-26 23:27:42","","","","0","","","","CC BY-SA 3.0"
"41889214","1","41889234","","2017-01-27 07:57:19","","7","2062","<p>I have a variable in global scope that I need to check periodically for changes. This is how I would do it in simple JS:</p>

<pre><code>    let currentValue, oldValue;

    setInterval(()=&gt;{
       if(currentValue != oldValue){
          doSomething();
       }
    }, 1000)
</code></pre>

<p>How is it done using <code>Observables</code>?</p>
","5663381","","","","","2017-01-27 07:58:40","How to detect change in a variable?","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41889234","2","","41889214","2017-01-27 07:58:40","","7","","<pre><code>Observable.interval(1000)
    .map(() =&gt; currentValue)
    .distinctUntilChanged();
</code></pre>

<hr>

<p>Or you can optionally give a comparator-function:</p>

<pre><code>Observable.interval(1000)
    .map(() =&gt; currentValue)
    .distinctUntilChanged((oldValue, newValue) =&gt; &lt;return true if equal&gt;);
</code></pre>
","1518765","","","","","2017-01-27 07:58:40","","","","0","","","","CC BY-SA 3.0"
"41889563","1","41889618","","2017-01-27 08:22:21","","1","298","<p>I want to poll some function that returns promises and detect change in  resolved values. I need to somehow add <code>interval</code> operator here. </p>

<pre><code>const observer = (newValue) =&gt; {
  console.log('Change detected', newValue);
}

Observable.fromPromise(getValue())
  .distinctUntilChanged((oldValue, newValue) =&gt; oldValue == newValue)
  .subscribe(observer);
</code></pre>
","5663381","","","","","2017-01-27 08:26:41","How to detect change in promise value?","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41889618","2","","41889563","2017-01-27 08:26:41","","3","","<p>A typical case for <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow noreferrer""><code>switchMap</code></a></p>

<pre><code>Observable.interval(1000)
  .switchMap(() =&gt; Observable.fromPromise(getValue())
  .distinctUntilChanged((oldValue, newValue) =&gt; oldValue == newValue)
  .subscribe(observer);
</code></pre>
","1518765","","","","","2017-01-27 08:26:41","","","","0","","","","CC BY-SA 3.0"
"41901450","1","","","2017-01-27 19:18:50","","0","323","<p>I have the next Observable i trying to filter to get the user in network but .mapTo(phone => verifyPhoneInNetwork(phone, country)) return AjaxObservable instead of the ajax response</p>

<pre><code>function verifyInNetwork(contacts: any, country: string) {
  const inNetworkOb = Observable
    .from(contacts)
    .map(contact =&gt; contact.phones)
    .map(phone =&gt; verifyPhoneInNetwork(phone, country))
    .first(({response}) =&gt; {
      return !response.invalid &amp;&amp; !response.exists;
    })
    .isEmpty()
    .filter(empty =&gt; empty);
</code></pre>
","3626118","","","","","2017-01-27 19:39:17","Rxjs is getting AjaxObservable instead of ajax response","<rxjs><observable><rxjs5><rxjs-dom>","1","0","","","","CC BY-SA 3.0"
"41902682","1","41932277","","2017-01-27 20:41:46","","3","63","<p>I have a scenario where </p>

<ol>
<li>I need to call 2 http services wait for them both</li>
<li>Call some method</li>
<li>Start listening to a socket which will next often</li>
<li>Each time socket streams, call some other method </li>
</ol>

<p>If it matters, I am using Angular2. </p>

<p>What I have now is separate (and working).</p>

<p>I am wondering how I can create this in all one series of operators to guarantee the waiting for first 2 calls without having to use local vars? - if that even makes sense to do...</p>

<p>What I am working with:</p>

<pre><code>this.sub1 = Observable
    .forkJoin([http.get(/api1), http.get('/api2')])
        .subscribe(([api1ResData, api2ResData]) =&gt; {
            this.doSomething(api1ResData, api2ResData);
        });

this.sub2 = socket.get('api3')
    .subscribe(data =&gt; {
        this.doSomethingElse(api3ResData);
    });
</code></pre>
","2275792","","","","","2017-01-31 09:08:16","RxJS5 - wait for 2 http calls, then listen to socket","<rxjs5>","1","0","1","","","CC BY-SA 3.0"
"41909335","1","","","2017-01-28 11:37:15","","0","1027","<p>I have the following <strong>rxjs</strong> observable chain:</p>

<pre><code>  ngOnInit() {
    this.route.params.map(params =&gt; params['userAccountToken'])
      .switchMap(userAccountToken =&gt; this.userAccountService.activateAccount(userAccountToken))
      .switchMap(() =&gt; this.route.params.map(params =&gt; params['userAccountToken']))
      .switchMap(userAccountToken =&gt; this.signinService.signinByUserAccountToken(userAccountToken))
      .subscribe(() =&gt; this.router.navigate(['/dashboard']));
  }
</code></pre>

<p>FYI, <code>route</code> is of type: <code>ActivatedRoute</code>.</p>

<p>The issue is that I am trying to reuse the following observable:</p>

<pre><code>route.params.map(params =&gt; params['userAccountToken'])
</code></pre>

<p>Notice how I duplicate this observable: first in order to activate the account and then to signin the user...</p>

<p>I am trying to find a way to reuse the value of the token but I am not sure which operator to use.</p>

<p>The order of the calls needs to be preserved. Is <code>concatAll</code> appropriate here? </p>

<p>See below for another attempt:</p>

<pre><code>  ngOnInit() {
    this.route.params.map(params =&gt; params['userAccountToken'])
      .mergeMap(userAccountToken =&gt; Observable.concatAll(
        this.userAccountService.activateAccount(userAccountToken),
        this.sessionService.signinByUserAccountToken(userAccountToken)
      ))
      .subscribe(() =&gt; this.router.navigate(['/dashboard']));
  }
</code></pre>

<p>Also, do I need to <code>mergeMap</code> or <code>switchMap</code> on the <code>route.param.map...</code>?</p>
","536299","","","","","2017-01-28 12:01:04","Is concatAll the right RxJS operator in order to preserve order?","<angular><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"41915910","1","","","2017-01-28 23:12:20","","1","837","<p>I am working on a project with Angular2 and trying to build a lot of the highly dynamic user interface with RxJS's functionality (and Firebase as backend). </p>

<p>Now take the following scenario:</p>

<pre><code>this.af.auth
  .filter(Boolean)
  .switchMap((auth) =&gt; this.af.database.object('/usersUid/' + auth.uid));
</code></pre>

<p>This will check if the user is properly logged in and if so switch to the inner observable in order to get to the stored user information (e.g. admin property etc.)</p>

<p>This works well (with both subscribe() and with async pipe in template).</p>

<p>What confuses me is that when I tried to move the observable to a dedicated service and to retrieve it, it will return the observable ""wrapped"" in an array.</p>

<pre><code>// in original component
let userObservable = this.databaseSrv.getUserObservable(); // the userObservable will be wrapped as an Array and the component logic breaks

// in database-service  
getUserObservable(){
  return this.af.auth
  .filter(Boolean)
  .switchMap((auth) =&gt; this.af.database.object('/usersUid/' + auth.uid));
}
</code></pre>

<p>I have tried different variations with map/flatmap/merge... there is certainly something wrong with the way I return the observable, but I can't seem to wrap my head around it. </p>

<p>Any explanation of this behaviour would be greatly appreciated. </p>
","5740986","","","","","2017-01-30 18:56:31","Returning an observable with switchMap from service will return it wrapped in Array","<angular><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41917214","1","","","2017-01-29 02:58:46","","1","83","<p>Using RxJS5, what is the best way to send the next message from an Observable to only one of its subscribers? To be more specific, I want to send the next message to the oldest subscriber in the subscribers/observers list. </p>

<p>Here is my attempt, but I am having trouble verifying that it's correct:</p>

<pre><code>        let obsClient = this.obsClient = new Subject&lt;any&gt;();

        this.clientStream = Observable.create(sub =&gt; {

            const push = Subscriber.create(v =&gt; {
                // I assume that zeroeth element holds oldest sub
                if(push === obsClient.observers[0]){
                    sub.next(v);
                }
            });

            return obsClient.subscribe(push);
        });

        function onClientConnectionChange(clientCount) {
            obsClient.next({
                time: Date.now(),
                clientCount: clientCount
            });
        }
</code></pre>

<p>as you can see, we push to the Subject, but that is wrapped by this.clientStream. Any subscribers will subscribe to this.clientStream not this.obsClient.</p>
","1223975","","1223975","","2017-01-29 22:12:16","2017-01-29 22:12:16","RxJS5 - Observable send next message to only one of its subscribers","<node.js><rxjs5>","0","9","","","","CC BY-SA 3.0"
"41920678","1","41920751","","2017-01-29 12:03:51","","4","1712","<p>Below is a short code snippet of reactive code (<code>RxJs</code>)</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let subj = new Rx.Subject();
let chain = subj
    .switchMap(v =&gt; Rx.Observable.of(10*v).do(vv =&gt; console.log(""Switch map"", vv)))
    .share()
    .take(1);


function subscribe(){
  chain.subscribe(v =&gt; console.log(""Next"", v),
                  err =&gt; console.log(""Error"",err),
                  () =&gt; console.log(""Completed""));
  chain.subscribe(v =&gt; console.log(""Next2"", v),
                  err =&gt; console.log(""Error2"",err),
                  () =&gt; console.log(""Completed2""));
  subj.next(Math.random());
}

subscribe();
subscribe();
subscribe();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>According to the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""nofollow noreferrer"">documentation</a> <code>chain</code> is an <code>Observable</code> which should print the emitted value * 10 (<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow noreferrer"">switchMap</a>), while printing it only once, no matter what's the number of subscriptions it has (<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-share"" rel=""nofollow noreferrer"">share</a>), do it only for the first emitted value and then complete.  </p>

<p>The first two bullets work fine, but the last one does not. 
Here is the output I get:  </p>

<pre><code>Switch map 9.022491050934722
Next 9.022491050934722
Completed
Next2 9.022491050934722
Completed2
Switch map 9.172999425126836
Next 9.172999425126836
Completed
Next2 9.172999425126836
Completed2
Switch map 6.168790337405257
Next 6.168790337405257
Completed
Next2 6.168790337405257
Completed2
</code></pre>

<p>As you can see, <code>chain</code> is getting completed multiple times.<br>
What makes it possible to complete the same <code>Observable</code> multiple times?</p>
","1544364","","1544364","","2017-08-04 15:37:37","2017-08-04 15:37:37","RxJs Observable completes multiple times","<javascript><rxjs><observable><rxjs5><reactivex>","1","0","","","","CC BY-SA 3.0"
"41920751","2","","41920678","2017-01-29 12:12:57","","4","","<p><code>share</code> is a shortcut for the combination of <code>publish</code> and <code>refCount</code>, this means that the stream is only ""hot"" as long as there is at least 1 subscriber, so after the stream completes, all active subscribers are automatically unsubscribed, which in turn resets the stream, since there are then 0 subscribers. Also: You should put the <code>take(1)</code> before the <code>share</code> since any following operation affects the hot-state.</p>

<p>How to make the stream <em>""truely""</em> shared/hot, independed from any subscribers: Use <code>publish</code> and <code>connect</code> the stream:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let subj = new Rx.Subject();
let chain = subj
    .switchMap(v =&gt; Rx.Observable.of(10*v).do(vv =&gt; console.log(""Switch map"", vv)))
    .take(1)
    .publish();
chain.connect();

function subscribe(){
  chain.subscribe(v =&gt; console.log(""Next"", v),
                  err =&gt; console.log(""Error"",err),
                  () =&gt; console.log(""Completed""));
  chain.subscribe(v =&gt; console.log(""Next2"", v),
                  err =&gt; console.log(""Error2"",err),
                  () =&gt; console.log(""Completed2""));
  subj.next(Math.random());
}

subscribe();
subscribe();
subscribe();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","","","","2017-01-29 12:12:57","","","","6","","","","CC BY-SA 3.0"
"41932277","2","","41902682","2017-01-30 09:15:59","","3","","<p>If <code>this.doSomething(api1ResData, api2ResData)</code> is an async function returning Observable or Promise, and you want to use the result of that operation in the next one, you can use <code>switchMap</code> or <code>mergeMap</code> to output the result into another observable, then subscribe to it to do the socket operation, like:</p>

<pre><code>this.sub1 = Observable
.forkJoin([http.get(/api1), http.get('/api2')])
.switchMap(([api1ResData, api2ResData]) =&gt; {
    return this.doSomething(api1ResData, api2ResData)
})
.switchMap(doSomethingResult =&gt; {
    return socket.get('api3')
})
.subscribe(socketGetResult =&gt; {
    this.doSomethingElse(api3ResData);
});
</code></pre>

<p>If <code>this.doSomething(api1ResData, api2ResData)</code> returns another type synchronously or is void, then you can just to a <code>.do</code> operator (In case you don't need <code>doSomething</code> result), or a <code>.map</code> otherwise, if you use <code>doSomething</code> result in <code>socket.get(3)</code></p>

<pre><code>this.sub1 = Observable
.forkJoin([http.get(/api1), http.get('/api2')])
.do(([api1ResData, api2ResData]) =&gt; {
   this.doSomething(api1ResData, api2ResData)
})
.switchMap(([api1res, api2res]) =&gt; {
    return socket.get('api3')
})
.subscribe(socketGetResult =&gt; {
    this.doSomethingElse(api3ResData);
});
</code></pre>

<p>You still use <code>switchMap</code> for the <code>socket.get()</code> operation, as you need to map to another observable, and receives the previous <code>forkJoin</code> result as the <code>.do</code> operator is to execute code without changing the current observable.</p>

<p>Check <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow noreferrer"">switchMap official docs</a></p>
","1420655","","1420655","","2017-01-31 09:08:16","2017-01-31 09:08:16","","","","5","","","","CC BY-SA 3.0"
"41935424","1","41965515","","2017-01-30 12:00:56","","45","40228","<p>I am trying to call to a service on input key-up event.</p>

<p>The HTML</p>

<pre><code>&lt;input placeholder=""enter name"" (keyup)='onKeyUp($event)'&gt;
</code></pre>

<p>Below is the <code>onKeyUp()</code> function</p>

<pre><code>onKeyUp(event) {
    let observable = Observable.fromEvent(event.target, 'keyup')
        .map(value =&gt; event.target.value)
        .debounceTime(1000)
        .distinctUntilChanged()
        .flatMap((search) =&gt; {
            // call the service
        });
    observable.subscribe((data) =&gt; {
        // data
    });
}
</code></pre>

<p>It was found from the network tab of the browser that, it is calling the key-up function on every key-up event(as it is supposed to do), but what I am trying to achieve is a debounce time of 1sec between each service call. Also, the event is triggered if I move the arrow key move. </p>

<p><a href=""http://plnkr.co/edit/2YOezky5qB2h4tzXojzi?p=info"" rel=""noreferrer"">plunkr link</a></p>
","","user3260023","310726","","2017-12-20 18:15:00","2019-01-15 10:59:32","How to achieve a debounce service on input keyup event in angular2 with rxjs","<javascript><angular><typescript><rxjs><rxjs5>","4","7","18","","","CC BY-SA 3.0"
"41942723","1","","","2017-01-30 18:14:45","","7","3122","<p>Why does publishReplay(1).refCount() not replay the last value for late subscribers?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>a = new Rx.Subject(); 
b = a.publishReplay(1).refCount(); 

a.subscribe(function(x){console.log('timely subscriber:',x)});
a.next(1); 
b.subscribe(function(x){console.log('late subscriber:',x)});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""http://reactivex.io/rxjs/user/script/0-Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Expected output:</p>

<pre><code>timely subscribe: 1
late subscriber: 1
</code></pre>

<p>Actual output</p>

<pre><code>timely subscriber: 1
</code></pre>
","985325","","","","","2017-01-30 19:06:43","Why does Rxjs publishReplay(1).refCount() not replay?","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"41949355","1","","","2017-01-31 03:53:22","","0","113","<p>I see some question/answers relating to Rx Subscriptions/Observers but they may be for older versions of Rx and also not for RxJS, which may conform to a different API.</p>

<p>I was under the impression that subscriptions/subscribers and observers were all the same. If you look at the docs, they are in different adjacent sections, but seem to be exactly the same:</p>

<p>Observer:
<a href=""http://reactivex.io/rxjs/manual/overview.html#observer"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/manual/overview.html#observer</a></p>

<p>Subscription:
<a href=""http://reactivex.io/rxjs/manual/overview.html#subscription"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/manual/overview.html#subscription</a></p>

<p>what the heck is the difference? Can someone given an example with a practical difference between the two?</p>
","1223975","","","","","2017-01-31 09:36:46","Difference between RxJS5 subscription and observer","<rxjs5>","2","0","","","","CC BY-SA 3.0"
"41958805","1","41966130","","2017-01-31 13:26:35","","1","680","<p>I am trying to follow this <a href=""https://www.learnrxjs.io/operators/transformation/switchmap.html"" rel=""nofollow noreferrer"">example</a> in learning <code>switchMap</code> for <code>rxjs</code>. The running example is <a href=""http://jsbin.com/zahohikaha/1/edit?html,js,console,output"" rel=""nofollow noreferrer"">here</a> and written in TypeScript. I attempted to code something similar in TypeScript (Angular 2) in VS Code, but I get a compiler error.</p>

<pre>
Operator '+' cannot be applied to types 
'Observable | Observable' and 
'Observable | Observable'.
(parameter) curr: Observable | Observable 
</pre>

<p>My code is as follows.</p>

<pre><code>playSubject = new Subject&lt;boolean&gt;();
pauseSubject = new Subject&lt;boolean&gt;();
interval$  = Observable.interval(1000).mapTo(-1);
pause$ = Observable.from(this.pauseSubject).mapTo(Observable.of(false));
resume$ = Observable.from(this.playSubject).mapTo(this.interval$);
timer$ = Observable
  .merge(this.pause$, this.resume$)
  .startWith(this.interval$)
  .switchMap(v =&gt; Observable.of(v))
  .scan((acc, curr) =&gt; {
    return curr ? curr + acc : acc; //problem right here
  });
ngAfterViewInit() {
  this.timer$.subscribe(data =&gt; {
    console.log(data);
  });
}
play() { //bound to button click event
  this.playSubject.next(true);
}
pause() { //bound to button click event
  this.pauseSubject.next(false);
}
</code></pre>

<p>I can modify the code in the <code>scan</code> function as follows, but then I'd need to know whether <code>curr</code> was <code>Observable&lt;boolean&gt;</code> or <code>Observable&lt;number&gt;</code>.</p>

<pre><code>playSubject = new Subject&lt;boolean&gt;();
pauseSubject = new Subject&lt;boolean&gt;();
interval$  = Observable.interval(1000).mapTo(-1);
pause$ = Observable.from(this.pauseSubject).mapTo(Observable.of(false));
resume$ = Observable.from(this.playSubject).mapTo(this.interval$);
timer$ = Observable
  .merge(this.pause$, this.resume$)
  .startWith(this.interval$)
  .switchMap(v =&gt; Observable.of(v))
  .scan((acc, curr) =&gt; {
    return curr; //how do i check for Observable&lt;Type&gt;?
  });
</code></pre>

<p>Any idea on what I'm doing wrong or how to check for the Observable type inside <code>scan</code>?</p>
","2175052","","","","","2017-01-31 19:39:43","How do I distinguish between generic Observable types in TypeScript?","<angular><typescript><rxjs><rxjs5><typescript2.0>","1","5","","","","CC BY-SA 3.0"
"41960149","1","41962945","","2017-01-31 14:33:30","","1","1032","<p>I want to flatten the values I get from the store and emit them as a single array when store emits.</p>

<p>It is quite easy in a synchronous version from my <em>No-RxJS</em> example below, but I can't figure out how to do it with RxJS.</p>

<p>I assume I could use RxJS to buffer values from a single <code>.next</code> call.</p>

<p>Should I use RxJS operators for that? If yes, then how do I make the nested data structure flat?</p>

<p>Here's a minimal example of what I'm trying to achieve.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const store$ = new Rx.BehaviorSubject([])

store$.next([
  {
    id: 1,
    items: [
      {
        id: 1,
        title: 'Foo'
      },
      {
        id: 2,
        title: 'Bar'
      }
    ]
  },
  {
    id: 2,
    items: [
      {
        id: 3,
        title: 'Fizz'
      },
      {
        id: 4,
        title: 'Buzz'
      }
    ]
  },
]);

// Desired output: [ ""Foo"", ""Bar"", ""Fizz"", ""Buzz"" ]

store$
  .filter(({length}) =&gt; length &gt; 0)
  .flatMap(group =&gt; group)
  .flatMap(({items}) =&gt; items)
  .map(({title}) =&gt; title)
  .subscribe(console.log) // Emits separate values :-(

// No-RxJs approach

store$
  .filter(({length}) =&gt; length &gt; 0)
  .map(groups =&gt; groups
        .map(
          ({ items }) =&gt; items.map(
            ({ title }) =&gt; title
          )
        )
        .reduce((next, acc) =&gt; [ ...acc, ...next ], []))
  .subscribe(console.log) // Works as expected.</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","2294657","","2294657","","2017-01-31 16:57:52","2017-01-31 16:57:52","Flatten nested data-structure in a non-complete RxJS stream","<angular><ecmascript-6><rxjs><rxjs5><ngrx>","1","7","","","","CC BY-SA 3.0"
"41962945","2","","41960149","2017-01-31 16:47:17","","2","","<p>As suggested by <a href=""https://stackoverflow.com/users/2151351/zeroflagl"">@zeroflagl</a> in comments, <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-toArray"" rel=""nofollow noreferrer"">toArray</a> method worked like a charm.</p>

<p>Since it works only on completed observables, I've had to <code>swithchMap</code> to an Observable, which uses <code>take(1)</code> to get a completed observable with current store value.</p>

<pre><code>store$
    .filter(({ length }) =&gt; length &gt; 0)
    .switchMap(() =&gt; store$.take(1)
        .flatMap(group =&gt; group)
        .flatMap(({ items }) =&gt; items)
        .map(({ title }) =&gt; title)
        .toArray()
    )
    .subscribe(console.log) // Emits flat array
</code></pre>
","2294657","","-1","","2017-05-23 12:02:06","2017-01-31 16:47:17","","","","0","","","","CC BY-SA 3.0"
"41965515","2","","41935424","2017-01-31 19:04:34","","74","","<p>So the chain is really correct but the problem is that you're creating an Observable and subscribe to it on every <code>keyup</code> event. That's why it prints the same value multiple times. There're simply multiple subscriptions which is not what you want to do.</p>

<p>There're obviously more ways to do it correctly, for example: </p>

<pre><code>@Component({
  selector: 'my-app',
  template: `
    &lt;div&gt;
      &lt;input type=""text"" (keyup)='keyUp.next($event)'&gt;
    &lt;/div&gt;
  `,
})
export class App implements OnDestroy {

  public keyUp = new Subject&lt;KeyboardEvent&gt;();

  private subscription: Subscription;

  constructor() {
    this.subscription = this.keyUp.pipe(
      map(event =&gt; event.target.value),
      debounceTime(1000),
      distinctUntilChanged(),
      mergeMap(search =&gt; of(search).pipe(
        delay(500),
      )),
    ).subscribe(console.log);
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
}
</code></pre>

<p>See your updated demo: <a href=""http://plnkr.co/edit/mAMlgycTcvrYf7509DOP"" rel=""noreferrer"">http://plnkr.co/edit/mAMlgycTcvrYf7509DOP</a></p>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-15 10:59:32","2019-01-15 10:59:32","","","","3","","","","CC BY-SA 4.0"
"41966130","2","","41958805","2017-01-31 19:39:43","","1","","<p>I think to properly fix this in VS Code you need to provide the following aid to the transpiler with generic type parameters:</p>

<pre><code>timer$ = Observable
  .merge(this.pause$, this.resume$)
  .startWith(this.interval$)
  .switchMap&lt;Observable&lt;boolean&gt; | Observable&lt;number&gt;, boolean | number&gt;(v =&gt; v)
  .scan&lt;boolean | number, number&gt;((acc, curr) =&gt; {
    return curr &amp;&amp; typeof curr === ""number"" ? curr + acc : acc;
  }, 60);
</code></pre>

<p>So this tells the transpiler that the input to the <code>switchMap</code> is an <code>Observable&lt;boolean&gt;</code> or an <code>Observable&lt;number&gt;</code> and its output is either a <code>boolean</code> or <code>number</code>.</p>

<p>Then we tell the <code>scan</code> method that its input is either a <code>boolean</code> or a <code>number</code> and its seed value's type is a <code>number</code>.</p>

<p>We are not stopping here, because this would still confuse the transpiler when it encounters the <code>curr + acc</code> expression. This is because <code>curr</code>'s type is <code>boolean | number</code> and <code>acc</code>'s type is <code>number</code>.</p>

<p>For this I introduced an additional condition in the ternary operator: <code>typeof curr === ""number""</code> which makes the transpiler happy and the code will transpile. This is working because of a feature called: <a href=""https://www.typescriptlang.org/docs/handbook/advanced-types.html"" rel=""nofollow noreferrer"">type guards</a>.</p>

<p>Also note that the <code>Observable.of</code> is not necessary in the <code>switchMap</code>.</p>
","4620101","","","","","2017-01-31 19:39:43","","","","0","","","","CC BY-SA 3.0"
"41973413","1","41974190","","2017-02-01 06:39:00","","3","2381","<p>Here's where I'am:</p>

<pre><code>const observer = (item) =&gt; {
  console.log(item);
}

Observable.from([1,2,3,4,5])
  .take(3)
  .*******
  .subscribe(observer);
</code></pre>

<p>What I'd like to get in console is:</p>

<pre><code>5
4
3
</code></pre>
","5663381","","","","","2018-04-17 04:01:09","How to emit values from an array in the opposite direction starting from the last item?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"41974190","2","","41973413","2017-02-01 07:28:53","","6","","<p>To get that output, you can use <code>toArray</code> and <code>mergeMap</code>, but you need to compose them before the <code>take(3)</code>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.from([1, 2, 3, 4, 5])
  .toArray()
  .mergeMap(array =&gt; array.reverse())
  .take(3)
  .subscribe(value =&gt; console.log(value));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>That will work fine if you have an observable that emits a relatively small number of values before it completes. If you have an observable that emits an arbitrarily large number of values and you only want the last three - in reverse order - you could use <code>reduce</code> to avoid having to buffer every emitted value:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.from([1, 2, 3, 4, 5])
  .reduce((acc, value) =&gt; {
    acc.unshift(value);
    if (acc.length &gt; 3) {
      acc.pop();
    }
    return acc;
  }, [])
  .mergeAll()
  .subscribe(value =&gt; console.log(value));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","6680611","","6680611","","2018-04-17 04:01:09","2018-04-17 04:01:09","","","","0","","","","CC BY-SA 3.0"
"41988326","1","41988962","","2017-02-01 19:43:18","","1","1970","<p>So I am using Angular 2 and struggling to make an HTTP request observable to be shared across multiple observers. More specifically I would like to share the all the response types, including errors.</p>

<p>I've tried like that:</p>

<pre><code>return this._http.request(new Request(options))
  .map((res: Response) =&gt; this.refreshToken(res))
  .share()
</code></pre>

<p>and then</p>

<pre><code>this.data.request()
  .map((response: Response) =&gt; (new financeiro.FetchCompletedAction(response)))
  .catch((error: any) =&gt; {
    console.log('lancamento-effects:');
    return Observable.of(new feedback.HttpRequestFailedAction([""Erro ao inserir lanÃ§amento""]))
  })
</code></pre>

<p>this code above is suposed to send an error action that ultimately shows an error message on the user screen.</p>

<p>Actually this is happening twice..</p>

<p><a href=""https://i.stack.imgur.com/fGnU3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fGnU3.png"" alt=""enter image description here""></a></p>

<p>Also it gets printed twice on console.</p>

<p><a href=""https://i.stack.imgur.com/bDvtl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bDvtl.png"" alt=""enter image description here""></a></p>
","2429966","","","","","2019-04-30 09:21:57","Rxjs - Can't convert cold observable into a hot one","<angular><rxjs><reactive-programming><rxjs5>","2","1","","","","CC BY-SA 3.0"
"41988962","2","","41988326","2017-02-01 20:20:00","","2","","<p>Here's some code (<a href=""https://plnkr.co/edit/oCZg3yqxtCaNAybvioRl?p=preview"" rel=""nofollow noreferrer"">Plunkr</a>):</p>

<pre class=""lang-ts prettyprint-override""><code>@Component({
  selector: 'my-app',
  template: `
    &lt;button (click)=""subscribe()""&gt;Subscribe&lt;/button&gt;
  `
})
export class AppComponent {
  obs: Observable&lt;any&gt;;

  constructor(private http: Http) {
    // Create the observable ONCE + Share.
    this.obs = this.http.get('https://httpbin.org/get')
      .do(() =&gt; console.log('***SIDE EFFECT***'))
      .mapTo('***RESULT***')
      .share();
  }

  subscribe() {
    // Subscribe to the same observable TWICE.
    this.obs.subscribe(val =&gt; console.log('subs1', val));
    this.obs.subscribe(val =&gt; console.log('subs2', val));
  }
}
</code></pre>

<p>Here's what the console shows:</p>

<pre><code>***SIDE EFFECT***
subs1 ***RESULT***
subs2 ***RESULT***
</code></pre>

<p>One side-effect (i.e. HTTP request), two subscriptions.</p>

<p>Is that what you're looking for?</p>
","1153681","","","","","2017-02-01 20:20:00","","","","1","","","","CC BY-SA 3.0"
"41995884","1","42013221","","2017-02-02 06:51:37","","1","50","<p>I have this code which just reads in data from a .csv file and converts it to json and logs the data:</p>

<pre><code>const fs = require('fs');
const path = require('path');

const sd = path.resolve(__dirname + '/fixtures/SampleData.csv');
const strm = fs.createReadStream(sd).setEncoding('utf8');

const Rx = require('rxjs/Rx');
const csv2json = require('csv2json');


const dest = strm
  .pipe(csv2json({
    separator: ','
  }));

dest.on('error', function(e){
    console.error(e.stack || e);
})

const obs = Rx.Observable.fromEvent(dest, 'data')
          .flatMap(d =&gt; Rx.Observable.timer(100).mapTo(d))

obs.subscribe(v =&gt; {
    console.log(String(v));
})
</code></pre>

<p>What the code is doing is logging all the data after a 100 ms delay. <em>I actually want to delay on each line of data and log each line after a small delay.</em></p>

<p>The above code doesn't achieve that - what is the best way to control the rate at which the data is logged?</p>

<p>Hypothesis: All the lines of data come in approximately at the same time, so all are delayed 100 ms, so they end up getting printed at pretty much the same time. I need to only start delaying the next line after the previous as been logged.</p>

<p>the following code seems to do the same thing as using the timer above:</p>

<pre><code>const obs = Rx.Observable.fromEvent(dest, 'data')
      .delay(100)
</code></pre>
","1223975","","1223975","","2017-02-03 08:09:16","2017-02-03 08:09:16","Set rate using RxJS5","<node.js><rxjs5>","2","0","","","","CC BY-SA 3.0"
"41997883","1","42006671","","2017-02-02 08:57:15","","6","12363","<p>I have created a <code>Rx.Observable</code> from a stream of events:</p>

<pre><code>Rx.Observable.fromEvent(recognizeStream, 'data')
</code></pre>

<p>In which every data event looks like this:</p>

<pre><code>{ error: null, alternatives: [result1, result2, result3] }
</code></pre>

<p>I want to pluck every value inside the array of <code>alternatives</code> and merge those into the stream. What <a href=""http://reactivex.io/documentation/operators.html"" rel=""noreferrer"">operators</a> do I have to look at?</p>

<p>As far as I know the <code>flatMap</code> and <code>concatMap</code> could do the job but I don't get the idea from their example. </p>

<p>Can somebody explain which operator i should use and provide me with an example?</p>
","1187091","","106909","","2017-02-02 15:43:55","2017-06-28 07:47:07","Rxjs - How can I extract multiple values inside an array and feed them back to the observable stream synchronously","<rxjs><reactive-programming><rxjs5>","3","0","4","","","CC BY-SA 3.0"
"41999077","1","42005377","","2017-02-02 09:58:02","","0","701","<p>I wrote a generic request method that is supposed to show a loading indicator while the request is running. If an error occurs (like 404), I display the message in <code>.catch</code> and then <code>return Observable.empty()</code>, so that the following code doesn't crash (since no data is returned).</p>

<p>The big problem is that then <code>.finally</code> won't be called either. Is that a bug? Is there a workaround? Here's my code:</p>

<pre><code>res = Observable
  .of(true)
  .do(() =&gt; this.store.dispatch(new ShowLoadingIndicatorAction()))
  .switchMap(() =&gt; this.http.get(url, { headers: this.headers }))
  .publishReplay(1)
  .refCount()
  .catch(error =&gt; {
    this.messages.handleRequestError(error);
    return Observable.empty();
  })
  .finally(() =&gt; this.store.dispatch(new HideLoadingIndicatorAction()));

// then later:
res.subscribe(doStuffWithData);
</code></pre>
","2096743","","2096743","","2017-02-06 14:25:21","2017-02-06 14:25:21","finally() is not called when returning empty() in catch()","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"41999758","2","","41655811","2017-02-02 10:29:34","","4","","<h3>How does <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/publishReplay.ts"" rel=""nofollow noreferrer""><code>publishReplay()</code></a> actually work</h3>

<p>It internally creates a <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/ReplaySubject.ts"" rel=""nofollow noreferrer""><code>ReplaySubject</code></a> and makes it <code>multicast</code> compatible. The minimal replay value of <code>ReplaySubject</code> is 1 emission. This results in the following:</p>

<ul>
<li>First subscription will trigger the <code>publishReplay(1)</code> to internally subscribe to the source stream and pipe all emissions through the <code>ReplaySubject</code>, effectively caching the last <em>n</em>(=1) emissions</li>
<li>If a second subscription is started while the source is still active the <code>multicast()</code> will connect us to the same <code>replaySubject</code> and we will receive all next emissions until the source stream completes.</li>
<li>If a subscription is started after the source is already completed the replaySubject has cached the last <em>n</em> emissions and it will only receive those before completing.</li>
</ul>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const source = Rx.Observable.from([1,2])
  .mergeMap(i =&gt; Rx.Observable.of('emission:'+i).delay(i * 100))
  .do(null,null,() =&gt; console.log('source stream completed'))
  .publishReplay(1)
  .refCount();

// two subscriptions which are both in time before the stream completes
source.subscribe(val =&gt; console.log(`sub1:${val}`), null, () =&gt; console.log('sub1 completed'));
source.subscribe(val =&gt; console.log(`sub2:${val}`), null, () =&gt; console.log('sub2 completed'));

// new subscription after the stream has completed already
setTimeout(() =&gt; {
  source.subscribe(val =&gt; console.log(`sub_late-to-the-party:${val}`), null, () =&gt; console.log('sub_late-to-the-party completed'));
}, 500);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","106909","","","","","2017-02-02 10:29:34","","","","0","","","","CC BY-SA 3.0"
"42005377","2","","41999077","2017-02-02 14:55:42","","2","","<p>What RxJS-version are you using? It does works fine in this example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const res$ = Rx.Observable
  .of(true)
  .switchMap(() =&gt; Rx.Observable.throw(""Rest Error""))
  .publishReplay(1)
  .refCount()
  .catch(error =&gt; Rx.Observable.empty())
  .finally(() =&gt; console.log(""Calling Finally!""));

res$.subscribe(console.info);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","","","","2017-02-02 14:55:42","","","","3","","","","CC BY-SA 3.0"
"42006671","2","","41997883","2017-02-02 15:54:19","","19","","<p>The family of <code>xxxMap()</code> operators all deal with higher-order Observables. Which means they allow you to create Observables inside the main Observable and inline the resulting values into the primary stream. So you could read the type signature as <code>Observable&lt;Observable&lt;T&gt;&gt; =&gt; Observable&lt;T&gt;</code></p>

<p>Given a stream which every emission <em>x</em> is an Observable containing 4 value emissions:</p>

<pre><code>input:  --x----------x 
flatMap   a-a-a-a-|  b-b-b-b-|
result: --a-a-a-a----b-b-b-b-|
</code></pre>

<h1>Typecasting xxxMap(myFnc) return values</h1>

<p>The <code>xxxMap()</code> operators all work with results of type <code>Observable</code>, <code>Promise</code> or <code>Array</code>. Depending on what you put into it will get converted to Observable if needed.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.of('')
  .flatMap(() =&gt; [1,2,3,4])
  .subscribe(val =&gt; console.log('array value: ' + val));

Rx.Observable.of('')
  .flatMap(() =&gt; Promise.resolve(1))
  .subscribe(val =&gt; console.log('promise value: ' + val));

Rx.Observable.of('')
  .flatMap(() =&gt; Promise.resolve([1,2,3,4]))
  .subscribe(val =&gt; console.log('promise array value: ' + val));

Rx.Observable.of('')
  .flatMap(() =&gt; Rx.Observable.from([1,2,3,4]))
  .subscribe(val =&gt; console.log('Observable value: ' + val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>In your case you can easily flatMap the objects and return the arrays:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.of({ error: null, alternatives: ['result1', 'result2', 'result3'] })
  .flatMap(val =&gt; val.alternatives)
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<h1>Difference between all xxxMap operators</h1>

<h2>What does mergeMap do</h2>

<p><a href=""http://reactivex.io/documentation/operators/flatmap.html"" rel=""noreferrer""><code>flatMap</code></a>, better known as <em><code>mergeMap</code></em> will <a href=""http://rxmarbles.com/#merge"" rel=""noreferrer""><code>merge</code></a> all emissions whenever they come into the main stream.</p>

<p><a href=""https://i.stack.imgur.com/xd5cd.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/xd5cd.png"" alt=""enter image description here""></a></p>

<h2>concatMap</h2>

<p>concatMap will wait for all emissions to complete before <a href=""http://rxmarbles.com/#concat"" rel=""noreferrer""><code>concat</code></a> the next stream:</p>

<p><a href=""https://i.stack.imgur.com/EN4Uw.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/EN4Uw.png"" alt=""enter image description here""></a></p>

<h2>switchMap</h2>

<p>but switchMap will <strong>abandon</strong> the previous stream when a new emission is available and <em>switch</em> to emit values from the new stream:</p>

<p><a href=""https://i.stack.imgur.com/FKTG5.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/FKTG5.png"" alt=""enter image description here""></a></p>
","106909","","106909","","2017-06-28 07:47:07","2017-06-28 07:47:07","","","","4","","","","CC BY-SA 3.0"
"42013205","1","42013299","","2017-02-02 22:07:14","","4","1050","<p>How do I get multiple subscribers waiting the same promise to resolve if it is already inflight with latecomers given a new resolution?</p>

<pre><code>doSomething = () =&gt; {
  return new Promise((resolve) =&gt; {
     setTimeout(() =&gt; resolve(Math.random(), 1000)
  })
}

// how to define obs?

obs.subscribe(v =&gt; console.log(v)); // 0.39458743297857473
obs.subscribe(v =&gt; console.log(v)); // 0.39458743297857473
obs.subscribe(v =&gt; console.log(v)); // 0.39458743297857473

setTimeout(() =&gt; obs.subscribe(v =&gt; console.log(v)), 2000); // 0.9485769395265746
</code></pre>

<p>I'd like the observable to remain cold until the first subscriber, then go cold again after the result is streamed to all subsequent concurrent subscribers. I basically don't want any concurrent requests to the same underlying function.</p>
","27241","","27241","","2017-02-02 22:17:36","2017-02-02 22:53:06","RxJs - Multiple subscribers waiting on the same result of a promise","<rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42013221","2","","41995884","2017-02-02 22:08:21","","2","","<blockquote>
  <p>Hypothesis: All the lines of data come in approximately at the same
  time, so all are delayed 100 ms, so they end up getting printed at
  pretty much the same time. I need to only start delaying the next line
  after the previous as been logged.</p>
</blockquote>

<p>Your hypothesis is <strong>correct</strong></p>

<h2>Solution</h2>

<p>Swap out the <code>.flatMap()</code> in your original solution with <code>.concatMap()</code></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.from([1,2,3,4])
  .mergeMap(i =&gt; Rx.Observable.timer(500).mapTo(i))
  .subscribe(val =&gt; console.log('mergeMap value: ' + val));

Rx.Observable.from([1,2,3,4])
  .concatMap(i =&gt; Rx.Observable.timer(500).mapTo(i))
  .subscribe(val =&gt; console.log('concatMap value: ' + val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>This will ensure that every emission completes before the next emission is subscribed to and starts delaying its value.</p>
","106909","","","","","2017-02-02 22:08:21","","","","3","","","","CC BY-SA 3.0"
"42013299","2","","42013205","2017-02-02 22:13:05","","3","","<p>You can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-defer"" rel=""nofollow noreferrer""><code>defer</code></a> as the creation-operator and then <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-share"" rel=""nofollow noreferrer""><code>share</code></a> the stream:</p>

<pre><code>doSomething = () =&gt; {
  return new Promise((resolve) =&gt; {
     setTimeout(() =&gt; resolve(Math.random(), 1000));
  });
}

const obs = Rx.Observable
    .defer(doSomething)
    .share();

obs.subscribe(console.log); // resolve #1
obs.subscribe(console.log); // resolve #1
obs.subscribe(console.log); // resolve #1

setTimeout(() =&gt; obs.subscribe(console.log), 2000); // resolve #2
</code></pre>

<pre class=""lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;
</code></pre>
","1518765","","259769","","2017-02-02 22:53:06","2017-02-02 22:53:06","","","","1","","","","CC BY-SA 3.0"
"42020852","1","42021832","","2017-02-03 09:24:38","","1","3328","<p>In my service I try to solve the next problem. I have a json file with the names of other json files (cards):</p>

<pre><code>{
  ""filename1"" : ... ,
  ""filename2"" : ... ,
  ...
  ""filenameN"" : ...
}
</code></pre>

<p>I need to load all that files. ""filenameX"" files have some card data :</p>

<pre><code>{
  dataX
}
</code></pre>

<p>I need to combine loaded data in object:</p>

<pre><code>{
  ""filename1"" : { data1 },
  ""filename2"" : { data2 },
...
  ""filenameN"" : { dataN }
}
</code></pre>

<p>I create Observer for any file loading and try to combine them to a high-level single Observer which is resolved when all corresponding Observers are. Here is my code:</p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import ""rxjs/add/observable/concat"";
import ""rxjs/add/operator/map"";
...
    _loadCards(dir, cardsListFile) {
        var http = ...
        var url = ...
        return Observable.create(function (observer) {
            http.get(url + dir + ""/"" + cardsListFile + "".json"").map(res =&gt; { return res.json(); }).subscribe(list =&gt; {
                let data = {};
                let observers = [];
                for(var card in list) {
                    if(list.hasOwnProperty(card)) {
                        let obs = http.get(url + dir + ""/cards/"" + card + "".json"").map(res =&gt; { return res.json(); });
                        observers.push(obs);
                        let getData = function(card) {
                            obs.subscribe(cardData =&gt; {
                                data[card] = cardData;
                            });
                        };
                        getData(card);
                    }
                }

                let concatResult = Observable.concat(observers);
                console.log(concatResult);
                concatResult.subscribe(result =&gt; {
                    observer.onNext(data);
                    observer.onCompleted();
                });         
            });
        });
    };
</code></pre>

<p>However, concat operator of Observer doesn't work as described - it returns the same array of Observers as its input. Where is the problem and what other operators can I use to make my solution more straight forward (because now it's defenitely ugly)? </p>
","1862998","","310726","","2017-02-03 10:09:34","2017-02-03 18:37:27","Observable concat method on array returns the same array","<angular><typescript><rxjs><observable><rxjs5>","3","0","","","","CC BY-SA 3.0"
"42021745","1","","","2017-02-03 10:10:42","","8","1946","<p>I have a question regarding multicasted observables and an unexpected (for me) behaviour I noticed.</p>

<pre><code>const a = Observable.fromEvent(someDom, 'click')
  .map(e =&gt; 1)
  .startWith(-1)
  .share();

const b = a.pairwise();

a.subscribe(a =&gt; {
  console.log(`Sub 1: ${a}`);
});

a.subscribe(a =&gt; {
  console.log(`Sub 2: ${a}`)
});

b.subscribe(([prevA, curA]) =&gt; {
  console.log(`Pairwise Sub: (${prevA}, ${curA})`);
});
</code></pre>

<p>So, there is a shared observable a, which emits 1 on every click event. -1 is emitted due to the startWith operator.
The observable b just creates a new observable by pairing up latest two values from a.</p>

<p>My expectation was:</p>

<pre><code>[-1, 1] // first click
[ 1, 1] // all other clicks
</code></pre>

<p>What I observed was:</p>

<pre><code>[1, 1] // from second click on, and all other clicks
</code></pre>

<p>What I noticed is that the value -1 is emitted immediately and consumed by Sub 1, before even Sub 2 is subscribed to the observable and since a is multicasted, Sub 2 is too late for the party.</p>

<p>Now, I know that I could multicast via BehaviourSubject and not use the startWith operator, but I want to understand the use case of this scenario when I use startWith and multicast via share.</p>

<p>As far as I understand, whenever I use .share() and .startWith(x), only one subscriber will be notified about the startWith value, since all other subscribers are subscribed after emitting the value.</p>

<p>So is this a reason to multicast via some special subject (Behavior/Replay...) or am I missing something about this startWith/share scenario?</p>

<p>Thanks!</p>
","2362402","","310726","","2017-02-03 11:37:50","2017-02-03 11:37:50","Shared observable and startWith operator","<rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"42021832","2","","42020852","2017-02-03 10:15:11","","2","","<p>JSBIN with solution: <a href=""http://jsbin.com/dahaqif/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/dahaqif/edit?js,console</a></p>

<p>I'm assuming you have two observables, one to get the list of filenames, the other to get the data for a specific filename:</p>

<pre class=""lang-ts prettyprint-override""><code>const filenamesObs = Observable.of({
  ""filename1"" : null,
  ""filename2"" : null,
  ""filename3"" : null
});
// This is actually a function that returns an observable.
const filedataObs = (filename) =&gt; {
  return Observable.of(`This is the data for ${filename}`);
}
</code></pre>

<p>Now, here's how you can combine the two observables to obtain the data structure you described:</p>

<pre class=""lang-ts prettyprint-override""><code>const source = filenamesObs

  // Extract the list of filenames as an array.
  .map(obj =&gt; Object.keys(obj))

  // Flatten the array, i.e. emit each filename individually
  // vs a SINGLE array containing ALL filenames.
  .mergeMap(val =&gt; val)

  // Get the data for each filename.
  .mergeMap(filename =&gt;
    filedataObs(filename).map(data =&gt; Object.assign({}, { filename: filename, data: data }))
  )

  // At this point, you have a stream of { filename, data } objects.
  // Reduce everything back to a single object.
  .reduce((acc, curr) =&gt; {
    acc[curr.filename] = curr.data;
    return acc;
  }, {});
</code></pre>

<p>If you subscribe and log the result to the console, you'll see:</p>

<pre><code>[Object] {
  filename1: ""This is the data for filename1"",
  filename2: ""This is the data for filename2"",
  filename3: ""This is the data for filename3""
}
</code></pre>

<p><strong>Additional clarifications following Arseniy's comment</strong></p>

<ul>
<li>The first <code>mergeMap()</code> is a ""trick"" to transform the SINGLE array of values we have at the beginning into MULTIPLE, INDIVIDUAL values. Since you want to be able to process each filename individually (to fetch the corresponding data), it's more convenient to receive the filenames one by one vs as a big array containing all filenames. To make it crystal clear, you should go to my JSBIN and add the line <code>.do(console.log)</code> <strong>before</strong> and <strong>after</strong> the first <code>mergeMap()</code>. You'll immediately understand the difference.</li>
<li>The second <code>mergeMap()</code> ""projects"" the values of a source observable into a target observable. It sounds fancy but it simply means we are transforming the filenames (1st observable) into HTTP requests to get the files' data (2nd observable).</li>
<li>Finally, <code>Object.assign()</code> lets met put everything back together. Since we have data coming from two observables â the one emitting the filenames and the one emitting the file data â we need to merge everything into a single container before we can use it (or transform it further). For this I'm using <code>Object.assign()</code> to create a temporary object with two properties, <code>filename</code> and <code>data</code>. Note that is vanilla JavaScript, it has nothing to do with observables. Again, you can add a <code>.do(console.log)</code> line after the second <code>mergeMap()</code> to print out to the console what the stream contains at this point.</li>
</ul>
","1153681","","1153681","","2017-02-03 11:38:47","2017-02-03 11:38:47","","","","6","","","","CC BY-SA 3.0"
"42025620","1","42025835","","2017-02-03 13:38:48","","1","374","<p>I am trying to understand the behavior of the <strong>RxJS 5</strong> <code>share()</code> operator. </p>

<p>According to tutorials and documentation, <code>share()</code> turns a cold observable into a hot one.</p>

<p>I am trying to see that in action. Here is what I have tried:</p>

<pre><code>const search$ = Rx.Observable.ajax('https://www.googleapis.com/books/v1/volumes?q=javascript').share();
</code></pre>

<p>And then the first time I subscribe to it:</p>

<pre><code>search$.subscribe(console.log);
</code></pre>

<p>I see from the dev tools that a network request is issued:</p>

<pre><code> Request URL:https://www.googleapis.com/books/v1/volumes?q=javascript
</code></pre>

<p>then upon rerunning the same subscription:</p>

<pre><code>search$.subscribe(console.log);
</code></pre>

<p>I notice that <strong>another network request is also issued</strong>.</p>

<p>Can someone please explain why the <code>share()</code> operator is displaying this behavior? I was expecting just one network request to be issued...</p>

<p><strong>P.S.</strong> using <code>xxx.publishLast().refCount();</code> instead of <code>xxx.share();</code> does the job but my main concern is to understand the <code>share()</code> behavior in the above context.</p>
","536299","","536299","","2017-02-03 13:45:51","2017-09-23 17:12:11","Understanding the share() RxJS operator in action together with Rx.Observable.ajax","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42025835","2","","42025620","2017-02-03 13:50:48","","2","","<p><code>share</code> is a shortcut for <code>publish().refCount()</code>. The <code>refCount</code>-part means, that the stream is hot/shared as long as there is at least 1 subscriber - howver, it is being reset/cold when there are no subscribers. When your <code>ajax</code>-requests finishes, the stream completes and upon completion of a stream any subscriber is automatically being unsubscribed -> setting the subribers of the stream to 0 and therefor resetting the stream - which is why you are experiencing a second network-quest on any future subscription.</p>

<p>Why does this work with <code>publishLast().refCount()</code>? - with <code>publishLast()</code> you get a stream that never completes, therefor no subscriber is automatically unsubscribed and the stream is never being reset.</p>

<hr>

<p>For caching HTTP-Responses your approach with <code>publishLast().refCount()</code> is perfectly valid.</p>
","1518765","","641914","","2017-09-23 17:12:11","2017-09-23 17:12:11","","","","3","","","","CC BY-SA 3.0"
"42029327","1","42029377","","2017-02-03 17:00:32","","1","929","<p>How do I partition the following array so it's partition between those under 30, and those 30 and above.</p>

<p>I thought the following code would do it, but it appears to just return the array, not each element:</p>

<pre><code>let ageArr = [
    { name: 'Ken', age: 28 },
    { name: 'Mary', age: 70 },
    { name: 'Kate', age: 12 },
    { name: 'David', age: 37 },
    { name: 'Laura', age: 42 },
    { name: 'Ian', age: 19 },
    { name: 'Peter', age: 21 },
    { name: 'Isobel', age: 55 },
    { name: 'Rebecca', age: 15 }
];

let [under, over] = Oversable.of(ageArr).partition(person =&gt; person.age &lt; 30);

under.subscribe(a =&gt; console.log(a)); // [ { name: 'Ken', age: 28 }, { name: 'Kate', age: 12 }, { name: 'Ian', age: 19 }, { name: 'Peter', age: 21 }, { name: 'Rebecca', age: 15 } ]
over.subscribe(a =&gt; console.log(a)); // [ { name: 'Mary', age: 70 }, { name: 'David', age: 37 }, { name: 'Laura', age: 42 }, { name: 'Isobel', age: 55 } ]
</code></pre>

<p>But as stated above, this seems not to work. Any idea how to achieve what I'd like to?</p>
","1038786","","","","","2017-02-03 17:03:51","RxJS - partition array of objects","<rxjs><rxjs5><partition><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"42029377","2","","42029327","2017-02-03 17:03:51","","5","","<p>You need to use <code>Observable.from</code></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let ageArr = [
    { name: 'Ken', age: 28 },
    { name: 'Mary', age: 70 },
    { name: 'Kate', age: 12 },
    { name: 'David', age: 37 },
    { name: 'Laura', age: 42 },
    { name: 'Ian', age: 19 },
    { name: 'Peter', age: 21 },
    { name: 'Isobel', age: 55 },
    { name: 'Rebecca', age: 15 }
];

let [under, over] = Rx.Observable.from(ageArr).partition(person =&gt; person.age &lt; 30);

under.subscribe(a =&gt; console.log(""Under 30: "" + a.name));
over.subscribe(a =&gt; console.log(""Over 30: "" + a.name));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","","","","2017-02-03 17:03:51","","","","2","","","","CC BY-SA 3.0"
"42034248","1","42035242","","2017-02-03 22:48:55","","11","2643","<p>I frequently find my self adding the same sequence of operators to observables, e.g.</p>

<pre><code>observable$
  .do(x =&gt; console.log('some text', x))
  .publishReplay()
  .refCount();
</code></pre>

<p>I'm looking for a way to combine these 3 operators in a small reusable operator (e.g. <code>.cache('some text')</code>) that I can chain to any observable. How can I define this in Typescript, so that I could import rxjs/Observable and this operator, like I do with rxjs operators?</p>
","1867581","","","","","2017-02-22 03:41:06","Combine RxJS operators into new operator using TypeScript","<typescript><rxjs><rxjs5>","2","0","5","","","CC BY-SA 3.0"
"42035075","1","42038302","","2017-02-04 00:20:47","","1","2429","<p>I have an Observable that I'm using to convert a promise into a subscription. This results in a collection that I need to iterate through to call an HTTP Service on each element. I'm using forkJoin to wait for all those calls to finish so that I can do something else, but unfortunately, my subscription is not being called. Do you see what I'm missing here?</p>

<pre><code>Observable.fromPromise(this.users.getElements()).subscribe(results =&gt; {
  Observable.forkJoin(
    results.map(
      aUser =&gt; this.HttpService.submitUser(aUser).subscribe(
        results =&gt; {
          this.progress += 1;
        },
        err =&gt; {
          this.progress += 1;
          this.handleError(&lt;any&gt;err);
        })
    ).subscribe(
      //it never gets to either of these calls after all service calls complete
      data =&gt; {
        debugger;
        console.log(data);
        this.reset();
      },
      err =&gt; {
        debugger;
        console.log(err);
        this.reset();
      }
    ));
});
</code></pre>
","901376","","310726","","2017-02-04 08:40:54","2017-02-04 20:50:27","Observable subscription not getting called","<angular><typescript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42035242","2","","42034248","2017-02-04 00:43:57","","24","","<p>To implement the operator you have described, create a <code>cache.ts</code> file with the following content:</p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import ""rxjs/add/operator/do"";
import ""rxjs/add/operator/publishReplay"";

// Compose the operator:

function cache&lt;T&gt;(this: Observable&lt;T&gt;, text: string): Observable&lt;T&gt; {
  return this
    .do(x =&gt; console.log(text, x))
    .publishReplay()
    .refCount();
}

// Add the operator to the Observable prototype:

Observable.prototype.cache = cache;

// Extend the TypeScript interface for Observable to include the operator:

declare module ""rxjs/Observable"" {
  interface Observable&lt;T&gt; {
    cache: typeof cache;
  }
}
</code></pre>

<p>And consume it like this:</p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import ""rxjs/add/observable/of"";
import ""./cache"";

let cached = Observable.of(1).cache(""some text"");
cached.subscribe(x =&gt; console.log(x));
</code></pre>
","6680611","","6680611","","2017-02-08 07:05:02","2017-02-08 07:05:02","","","","5","","","","CC BY-SA 3.0"
"42038302","2","","42035075","2017-02-04 08:40:28","","2","","<p>One thing is you don't subscribe to each Observable passed to <code>forkJoin()</code>. The operator has to do it itself.</p>

<p>If you want to be notified when each Observable completes you can use <code>.do(undefined, undefined, () =&gt; {...})</code>.</p>

<pre><code>let observables = [
  Observable.of(42).do(undefined, undefined, () =&gt; console.log('done')),
  Observable.of('a').delay(100).do(undefined, undefined, () =&gt; console.log('done')),
  Observable.of(true).do(undefined, undefined, () =&gt; console.log('done')),
];

Observable.forkJoin(observables)
  .subscribe(results =&gt; console.log(results));
</code></pre>

<p>This prints to console:</p>

<pre><code>done
done
done
[ 42, 'a', true ]
</code></pre>

<p>Eventually there's also <code>.finally()</code> operator. However, it's not the same as using <code>.do()</code>.</p>

<p>EDIT:</p>

<p>When any of the source Observables fail the <code>forkJoin()</code> operator reemits the error (which means it also fails).<br>
This means you need to catch errors in each source Observable separately (with <code>catch()</code> operator for example).</p>

<pre><code>let observables = [
  Observable.throw(new Error())
    .catch(() =&gt; Observable.of('caught error 1'))
    .do(undefined, undefined, () =&gt; console.log('done 1')),

  Observable.of('a')
    .delay(100).catch(() =&gt; Observable.of('caught error 2'))
    .do(undefined, undefined, () =&gt; console.log('done 2')),

  Observable.of(true)
    .catch(() =&gt; Observable.of('caught error 3'))
    .do(undefined, undefined, () =&gt; console.log('done 3')),
];

Observable.forkJoin(observables)
  .subscribe(results =&gt; console.log(results));
</code></pre>

<p>Which prints:</p>

<pre><code>done 1
done 3
done 2
[ 'caught error 1', 'a', true ]
</code></pre>
","310726","","310726","","2017-02-04 20:50:27","2017-02-04 20:50:27","","","","1","","","","CC BY-SA 3.0"
"42048622","1","","","2017-02-05 04:43:37","","0","2408","<p>I am unable to access a property of an object provided by the async pipe if I build the access chain using *ngFor.</p>

<p>In the example below, suppose that <code>Parking</code> in the test line and the <code>?.filter</code> two lines beneath represent the same key on the same object. The test line will evaluate to true, but the checked property does not. Why? How do I access the propery when stamping these out with *ngFor?</p>

<p>(Additionally, how should I access <code>propName</code> on <code>compModel</code>? <code>{{(compModel | async)?.(filter.propName)}}</code> wouldn't work anyway.)</p>

<pre><code>    &lt;fieldset class=""filter-category-title""&gt;
      &lt;legend&gt;{{filter.name}}&lt;/legend&gt;
        &lt;label *ngFor=""let instance of filter.options""&gt;
          test: {{(compModel | async)?.Parking}}
          &lt;input type=""checkbox""
                 checked={{(compModel | async)?.(filter.propName)?.instance}}
                 (click)=""amenityEmit({category: filter.propName, filter: instance, resetCategory: false})""&gt;
                 {{instance}}
        &lt;/label&gt;
    &lt;/fieldset&gt;
</code></pre>

<p>*this is <strong>not</strong> related to this question: <a href=""https://stackoverflow.com/questions/33747069/problems-using-async-pipe-with-ngfor-in-angular2"">Problems using async pipe with ngFor in Angular2</a></p>
","3735060","","-1","","2017-05-23 12:32:29","2017-02-05 05:06:07","Using *ngFor properly with the async pipe","<angular><rxjs><angular2-template><angular2-directives><rxjs5>","0","3","","","","CC BY-SA 3.0"
"42057324","1","42064838","","2017-02-05 21:09:36","","1","206","<p>Do we ever need to unsubscribe from an Observable? When is the time we need to use unsubscribe?</p>

<p>I read an angularfire2 article talking about using firebase.auth to check user's login status. In the end of code, he unsubscribes from auth.subscribe.
<a href=""https://javebratt.com/angularfire2-email-auth/"" rel=""nofollow noreferrer"">https://javebratt.com/angularfire2-email-auth/</a> (please see app.component.ts).</p>

<p>I was really confused, since I thought the Observable will ""unsubscribe"" itself after completed or on error.</p>

<p><a href=""https://stackoverflow.com/questions/41334931/do-we-need-to-unsubscribe-from-observable-that-completes-errors-out"">Do we need to unsubscribe from observable that completes/errors-out?</a>
and
<a href=""https://stackoverflow.com/questions/35042929/do-you-need-to-unsubscribe-from-angular-2-http-calls-to-prevent-memory-leak"">Do you need to unsubscribe from Angular 2 http calls to prevent memory leak?</a></p>
","4480196","","-1","","2017-05-23 10:29:27","2017-02-07 17:11:24","how come we need to unsubscribe from an Observerable ?","<rxjs5><angularfire2>","3","0","1","","","CC BY-SA 3.0"
"42057483","1","42057610","","2017-02-05 21:25:18","","2","897","<p>I am unable to access a property of an object provided by the async pipe if I build the access chain using *ngFor.</p>

<p>In the example below, suppose that <code>Parking</code> in the test line and the <code>?.[filter.propName]</code> two lines beneath represent the same key on the same object. The test line will evaluate to true, but the checked property does not. Why? How do I access the propery when stamping these out with *ngFor?</p>

<p>For example, if <code>{{(compModel | async)?.Parking?.Garage}} === true</code> I would expect <code>{{(compModel | async)?.[filter.propName].instance}} === true</code> as well, but this isn't the case.</p>

<p>The syntax below doesn't work. I'm using it to demonstrate intended functionality.</p>

<pre><code>&lt;div *ngFor=""let filter of filters | async""&gt;
...
&lt;fieldset class=""filter-category-title""&gt;
      &lt;legend&gt;{{filter.name}}&lt;/legend&gt;
        &lt;label *ngFor=""let instance of filter.options""&gt;
          test: {{(compModel | async)?.Parking.instance}}
          &lt;input type=""checkbox""
                 checked={{(compModel | async)?.[filter.propName].instance}}
                 (click)=""amenityEmit({category: filter.propName, filter: instance, resetCategory: false})""&gt;
                 {{instance}}
        &lt;/label&gt;
    &lt;/fieldset&gt;
&lt;/div&gt;
</code></pre>

<p>The filter data I get from the server in the format below. I use this to build a comparison model, also below, which is how I manage the state of my search results page. (<code>[key: string]</code> is always a propName from a Filter).</p>

<pre><code>export interface Filter {
  base: boolean,
  filter: string,
  propName: string,
  unionType: string,
  inputType: string,
  options: {
    options: string[],
    sectionTitle: string
  }[] | string[]
}
</code></pre>

<p>compModel interface:</p>

<pre><code>export interface CompModel {
  [key: string]: {
    touched: boolean
    unionType: string,
    options: {
      options: string[],
      sectionTitle: string
    }[] | string[],
    updateSelf(x: CompModel, y: Action): void
  }
}
</code></pre>
","3735060","","","","","2017-02-05 21:37:49","Using observables in an Angular 2 template with *ngFor","<angular><typescript><angular2-template><angular2-directives><rxjs5>","1","4","","","","CC BY-SA 3.0"
"42057610","2","","42057483","2017-02-05 21:37:49","","1","","<p>The safe-navigation operator <code>?.</code> does not work with <code>[]</code>. There is no <code>?[]</code> operator and also no <code>?.[]</code> or <code>.[]</code> operator, therefore this can't work.</p>

<p>You can try </p>

<pre><code>{{(compModel | async) &amp;&amp; (compModel | async)[filter.propName].instance}} === true
</code></pre>

<p>otherwise you'll need to move some code to the components class</p>

<p>for example</p>

<pre><code>this.compModel = someService.getSomeObservable()
.filter(val =&gt; !!val)
</code></pre>

<p>to ensure there are no <code>null</code> values</p>
","217408","","","","","2017-02-05 21:37:49","","","","1","","","","CC BY-SA 3.0"
"42064838","2","","42057324","2017-02-06 09:55:29","","2","","<p>You're correct about unsubscribing on <code>complete</code> or <code>error</code> notification.</p>

<p>I think the key is the comment in <a href=""https://github.com/angular/angularfire2/blob/d422e62b46a80d9fb12c9a9e2cf1cf2f7db04dd3/src/auth/auth.ts#L129"" rel=""nofollow noreferrer""><code>getAuth()</code> method in <code>auth.ts</code></a>:</p>

<blockquote>
  <p>Please observe the actual authState asynchronously by subscribing to the auth service: af.auth.subscribe()</p>
</blockquote>

<p>So you should subscribe with <code>af.auth.subscribe(...)</code> to be notified when the actual <code>authState</code> changes. This means that it doesn't complete (similarly to <code>Observable.fromEvent(...)</code>) and you have to unsubscribe manually.</p>
","310726","","","","","2017-02-06 09:55:29","","","","0","","","","CC BY-SA 3.0"
"42066387","1","42066633","","2017-02-06 11:13:16","","4","2637","<p>I have a two dimentional array of <code>BehaviorSubject&lt;number&gt;s</code>. For debugging purposes I want to write the values in a formatted manner as soon as all the array cells emit value. So I wrote this:</p>

<pre><code>    Observable.zip(universe.map(row =&gt; Observable.zip(row)))
        .takeUntil(stopper)
        .subscribe(u =&gt;
            console.log(`[\n\t[${u.map(r =&gt; r.toString()).join(""],\n\t["")}]\n]`))
</code></pre>

<p>Nothing written. And also this hasn't work:</p>

<pre><code>    Observable.zip(universe[0])
        .takeUntil(stopper)
        .subscribe(u =&gt; console.log(`1[${u.toString()}]`))
</code></pre>

<p>But these following worked (the array has 5 columns):</p>

<pre><code>    Observable.zip(universe[0][0], universe[0][1], universe[0][2], universe[0][3], universe[0][4])
        .takeUntil(stopper)
        .subscribe(u =&gt; console.log(`2[${u.toString()}]`))

    Observable.zip(Observable.zip(Observable.zip(Observable.zip(universe[0][0], universe[0][1]), universe[0][2]), universe[0][3]), universe[0][4])
        .takeUntil(stopper)
        .subscribe(u =&gt; console.log(`3[${u.toString()}]`))
</code></pre>

<p>Also I have considered .zipAll() operator but there is no document about it.</p>

<p>This may be a bug in Observable.zip() code as it shows <code>ArrayLike&lt;BehaviorSubject&lt;number&gt;&gt;</code> as possible argument type in code assistance.</p>

<p>So is there any other way to get this functionality? How can I get the array values written down once all of the values are reassigned, without knowing the actual dimensions of course?</p>
","1667555","","","","","2018-09-13 14:12:05","Observable.zip does not call subscribe.next if sources are given as array","<rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42066622","1","42066761","","2017-02-06 11:26:25","","1","464","<p>My <code>App.component</code> which calls a init method in my <code>user service</code>.</p>

<pre><code>ngOnInit(){
    this.init(true).then(data =&gt; {
        console.log(""OnInit Called"")
    })     
}
</code></pre>

<p><code>User.service</code> returns a <code>promise</code> which in turn calls the <code>account.init</code></p>

<pre><code>init = (isRegistered) =&gt; {
    return new Promise((resolve, reject) =&gt; {    
        this.account.init(isRegistered).then(data =&gt; {
            //some data inialization
            console.log(""OnInit Called User Service"")            
        });          
    });   
}
</code></pre>

<p><code>Account.service</code> returns a promise which calls several services using <code>Observable</code>.forkJoin</p>

<pre><code>init = ((userType: boolean) =&gt; {
    return new Promise((resolve, reject) =&gt; {
         Observable.forkJoin([
             this.m1,
             this.m2]).subscribe(data =&gt; {
                 //persist those return data   
             });           
    });
}
</code></pre>

<ol>
<li>Why are both console.log statements never gets executed? </li>
<li>Why does it not prevent the component inialization before the Observable.forkJoin complets its service calls?</li>
</ol>
","2805694","","310726","","2017-02-06 11:52:28","2017-02-06 11:52:28","Load data before component inialization - angular 2","<javascript><angular><typescript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42066633","2","","42066387","2017-02-06 11:26:41","","10","","<p>The important thing is that <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-zip"" rel=""noreferrer""><code>zip()</code></a> operator doesn't take an array of Observables but an unpacked series of Observables instead.</p>

<p>That's why <code>Observable.zip([obs1, obs2, obs3])</code> doesn't work.</p>

<p>But <code>Observable.zip(obs1, obs2, obs3)</code> works.</p>

<p>It's not possible to help you when we don't know what <code>universe</code> is. From what you have now it seems like you could use <a href=""https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"" rel=""noreferrer"">destructuring assignment</a> (assuming you're using ES6 or TypeScript):</p>

<pre><code>Observable.zip(...universe[0]);
</code></pre>

<p>I don't know what plans are with <a href=""http://reactivex.io/rxjs/file/es6/operator/zipAll.js.html#lineNumber8"" rel=""noreferrer""><code>zipAll()</code></a> but right now it just callls <code>zip()</code>.</p>
","310726","","","","","2017-02-06 11:26:41","","","","5","","","","CC BY-SA 3.0"
"42066761","2","","42066622","2017-02-06 11:32:06","","2","","<ol>
<li>(and 2.) call to <code>resolve(...)</code> missing</li>
</ol>



<pre><code>init = (isRegistered) =&gt; {
    return new Promise((resolve, reject) =&gt; {    
        this.account.init(isRegistered).then(data =&gt; {
            //some data inialization
            console.log(""OnInit Called User Service"")            
            resolve(/*someValue */); // &lt;&lt;&lt;== missing
            // or reject(/* someValue */);
        });          
    });   
}
</code></pre>

<ol start=""2"">
<li>Why do you expect it to block anything? <code>ngOnInit()</code> can't be blocked. You can for example use <code>*ngIf</code> to not show anything before the data is not yet available. 
You can also use a router guard to prevent component creation before data is available. <a href=""https://angular.io/docs/ts/latest/guide/router.html#!#resolve-guard"" rel=""nofollow noreferrer"">https://angular.io/docs/ts/latest/guide/router.html#!#resolve-guard</a>
But there is no way to block execution in any way in JS.</li>
</ol>
","217408","","217408","","2017-02-06 11:43:08","2017-02-06 11:43:08","","","","4","","","","CC BY-SA 3.0"
"42093169","1","","","2017-02-07 15:04:23","","0","64","<p>I'm trying to recreate RxMarbles for RxJS 5, but I'm having feedback problems when I change the collection's data (specifically the length of the data source).</p>

<p>I added <code>console.log</code>s for debugging</p>

<p>Note for those who are familiar with RxMarbles, I renamed ""Diagram"" to ""Timeline"".</p>

<pre><code>import { svg } from '@cycle/dom';
import isolate from '@cycle/isolate';
import { Observable } from 'rxjs';
import { apply, flip, map, max, merge, path, prop, sortBy, zip } from 'ramda';

import { Collection } from '../collection';

import { Marble } from './marble';
import { EndMarker } from './end-marker';

function sortMarbleDoms$(marbles$) {
  const doms$ = Collection.pluck(marbles$, prop('DOM'));
  const dataList$ = Collection.pluck(marbles$, prop('data'));

  return Observable.combineLatest(doms$, dataList$, zip)
    .map(sortBy(path([1, 'time'])))
    .map(map(prop(0)));
}

function OriginalTimeline({ DOM, marbles: marblesState$, end: end$ }) {
  const marblesProps$ = end$.map(({ time }) =&gt; ({
    minTime: 0,
    maxTime: time,
  }));
  const endMarkerProps$ = marblesState$.map(marbles =&gt; ({
    minTime: marbles.map(prop('time')).reduce(max, 0),
    maxTime: 100,
  }));

  const marblesSources = { DOM, props: marblesProps$ };
  const endMarkerSources = {
    DOM,
    props: endMarkerProps$,
    time: end$.pluck('time'),
  };

  const marbles$ = Collection.gather(
    Marble, marblesSources, marblesState$
    .do(a=&gt;console.log('marblesState', a)), '_itemId');
  const marbleDOMs$ = sortMarbleDoms$(marbles$);
  const endMarker = EndMarker(endMarkerSources);

  const vtree$ = Observable.combineLatest(marbleDOMs$, endMarker.DOM)
    .map(([marbleDOMs, endMarkerDOM]) =&gt;
      svg({
        attrs: { viewBox: '0 0 100 10' },
        style: { width: 500, height: 50, overflow: 'visible' },
      }, [
        svg.line({
          attrs: { x1: 0, x2: 100, y1: 5, y2: 5 },
          style: { stroke: 'black', strokeWidth: 0.4 },
        }),
        endMarkerDOM,
        ...marbleDOMs,
      ])
    );

  const marbleData$ = Collection.pluck(marbles$, prop('data'))
    .withLatestFrom(marblesState$, zip)
    .map(map(apply(flip(merge))))

  const data$ = Observable.combineLatest(marbleData$, endMarker.time)
    .map(([marbles, endMarkerTime]) =&gt; ({
      marbles,
      end: { time: endMarkerTime },
    }))
    .debounceTime(1);

  return { DOM: vtree$, data: data$.do(a=&gt;console.log('tdata', a)) };
}

export function Timeline(sources) {
  return isolate(OriginalTimeline)(sources);
}
</code></pre>

<p>The basic structure of the app is that all necessary data is fed into a global sink to a dummy driver that just takes the data and re-emits it as is (so in theory, all outputs should be new inputs).</p>

<p>Because of this, the problem might be in other parts of my code so I'm happy to post a codepen/plunkr of the code if it helps. This is indeed working sometimes, but not all the time.</p>

<p>Here's the console outputs (abridged)</p>

<pre><code>store Object {route: ""merge"", inputs: undefined}

timeline.js:39 marblesState [Object, Object, Object, Object]
timeline.js:69 tdata Object {marbles: Array[3], end: Object}
sandbox.js:48 data [Object, Object]
app.js:26 store Object {route: ""merge"", inputs: Array[2]}
</code></pre>

<p>Notice the <code>marblesState</code> has 4 objects, but the <code>tdata</code> returns marbles with an array of 3 objects. For some reason, the Collection is only returning 3 items.</p>

<p>Any help is appreciated. Thanks!</p>
","2970371","","","","","2017-02-08 08:02:19","CycleJS Collection returning old data","<rxjs5><cyclejs>","1","0","","","","CC BY-SA 3.0"
"42111759","1","","","2017-02-08 11:22:38","","3","6177","<p>I got a problem with <code>rxjs</code> and with <code>combineLatest</code> method.
I am trying to call <code>combineLatest</code> in <code>combineLatest</code> and it doesn't work, although it returns Observable object. Help to resolve the problem, please. <code>console.log</code> is never called</p>

<p>Actually, all the observers in the different files, so I can't move <code>this.search$</code> to <code>this.services$</code></p>

<pre><code>this.search$ = store.select('search');

this.services$ = Observable.combineLatest(
    store.select('currentRegions'),
    store.select('services'),
    (regions, services) =&gt; {
        // some filter here
        return services;
    }
);

this.autocomplete$ = Observable.combineLatest(
    this.search$,
    this.services$,
    (search, services) =&gt; {
        console.log('show me, please');
        return '';
    }
);
</code></pre>

<p>Resolved: It doesn't work without any subscriber, so I had to subscribe it</p>
","2895213","","2895213","","2017-02-08 13:14:37","2017-07-04 11:04:17","rxjs call combineLatest in combineLatest","<angular><rxjs><rxjs5><ngrx>","2","1","1","","","CC BY-SA 3.0"
"42112867","1","","","2017-02-08 12:14:57","","0","49","<p>Here's the code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const oids = [1, 2, 3, 4, 5, 6, 7];

// func to get mongodb cursor
const getCursor = oid =&gt; mdb.content.collection.find({
  status: {
    $in: [1, 2]
  },
  oid
}, {
  _id: -1,
  oid: 1,
  description: 1,
});

// scan func to accumulate text
const accumulateText = (acc = '', post) =&gt; acc += ' ' + post.description;

// generating innerObservables
const getInnerObservable$ = oid =&gt; {
  // first, set the MongoDB cursor
  const cursor = getCursor(oid);

  return Rx.Observable
    // create an observable from cursor's data event
    .fromEvent(cursor, 'data')
    // and read until there's no more data
    .takeUntil(
      Rx.Observable.fromEvent(cursor, 'end')
    )
    // accumulate text from every document that fits the condition
    .reduce(accumulateText)
    // AFTER EVERY DOCUMENT HAD BEEN THROUGH THE SCAN
    // map the accumulated text through a word frequency count function
    .map(str =&gt; helpers.countWordFrequency(str))
    .catch(err =&gt; console.error(err));
};

const content$ = Rx.Observable
  .from(oids)
  // for each oid, get an inner observable
  .mergeMap(getInnerObservable$);


return new Promise((res, rej) =&gt; content$.subscribe({
    next: (v) =&gt; console.log(v),
    complete: () =&gt; res()
  }))
  .then(() =&gt; console.log('Done'));</code></pre>
</div>
</div>
</p>

<p>Basically, I know that my approach is wrong, but I'm utterly confused as to how to implement it the right way. I've added some comments in the code to help understand what I am going for.</p>

<p>I am using RxJS5 and Node 7.1.0.</p>

<p>Appreciate any help and/or feedback.</p>

<p>EDIT: I found out that there's a <code>reduce</code> method (edited the code), which seems to do the job but then eventually the documents just start to bypass it entirely for some reason. I have no idea why this is happening. Seems like there's some fundamental misunderstanding on my part.</p>

<p>EDIT2: Essentially, for some reason, some of the data simply skips the reduce method on the observer returned by the <code>getInnerObservable$</code> and somehow directly skips to the <code>map</code> method. I still have no idea why, but other than that, it works as intended. Any ideas? I'm at a complete loss, honestly.</p>
","2458659","","2458659","","2017-02-09 13:00:00","2017-02-09 13:00:00","RxJS5 -- need help figuring out the right flow","<javascript><node.js><rxjs><rxjs5>","0","5","","","","CC BY-SA 3.0"
"42115128","1","42115414","","2017-02-08 13:58:28","","0","40","<p>I have an angular 2 router guard whose <code>canActivate</code> method is defined as follows:</p>

<pre><code>canActivate() {
    return this.sessionSigninService.isAuthenticated()
      .filter(isAuthenticated =&gt; isAuthenticated !== null)
      .map(isAuthenticated =&gt; {
        if (isAuthenticated) {
          return true;
        }
        this.router.navigate(['/signin']);
        return false;
      });
  }
</code></pre>

<p>from <code>sessionSigninService</code>:</p>

<pre><code>  isAuthenticated(): Observable&lt;boolean&gt; {
    return this.store.select(fromRoot.getAuthenticated);
  }
</code></pre>

<p>FYI, <code>fromRoot.getAuthenticated</code> is initialized with a value of <code>null</code></p>

<p>When the <code>canActivate</code> method is called and a <code>null</code> value for <code>isAuthenticated</code> enters into the <code>filter()</code> operator, it seems the <code>filter()</code> blocks until the value of <code>isAuthenticated</code> changes to <code>false</code> or <code>true</code>.</p>

<p>Note that this is the desired behavior but I don't understand it...</p>

<p>Can someone please explain this behavior?</p>
","536299","","","","","2017-02-08 14:11:35","Interrogation about the RxJS 5 filter() operator","<rxjs><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"42115414","2","","42115128","2017-02-08 14:11:35","","1","","<blockquote>
  <p>Like Array.prototype.filter(), it only emits a value from the source if it passes a criterion function.</p>
</blockquote>

<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-filter"" rel=""nofollow noreferrer""><code>filter</code></a> will only propagate data when the returned value of the filter-method is <code>true</code> - when you have <code>isAuthenticated: null</code> and evaluate <code>null !== null</code> -> it will return <code>false</code>, that's why no data is propagated and the <code>map</code> will not be called.</p>

<p>As soon as you have <code>isAuthenticated: true|false</code>, the filter will evaluate to <code>true</code>, because both <code>true</code> and <code>false</code> are <code>!== null</code>, and propagate data.</p>
","1518765","","","","","2017-02-08 14:11:35","","","","2","","","","CC BY-SA 3.0"
"42115698","1","42120267","","2017-02-08 14:23:45","","1","3556","<p>I use rxjs to handle a websocket connection</p>

<pre><code>var socket = Rx.Observable.webSocket('wss://echo.websocket.org')
socket.resultSelector = (e) =&gt; e.data
</code></pre>

<p>I want to periodically (5s) sent a <code>ping</code> message and wait 3s to receive a <code>pong</code> response and subscribe to the a stream if no response has been receive.</p>

<p>I try that without success. I admit I'm a bit lost will all the operator available to handle timeout, deboune or throttle. </p>

<pre><code>// periodically send a ping message
const ping$ = Rx.Observable.interval(2000) 
  .timeInterval()
  .do(() =&gt; socket.next('ping'))

const pong$ = socket  
  .filter(m =&gt; /^ping$/.test(`${m}`))  
  .mergeMap( 
    ping$.throttle(2000).map(() =&gt; Observable.throw('pong timeout'))
  ) 

 pong$.subscribe(
   (msg) =&gt; console.log(`end ${msg}`),
   (err) =&gt; console.log(`err ${err}`),
   () =&gt; console.log(`complete`)
 )
</code></pre>

<p>But unfortunately, no ping are send.</p>

<p>I've also try to achieved that using without success.</p>

<pre><code>const ping$ = Rx.Observable.interval(2000) 
  .timeInterval()
  .do(() =&gt; socket.next('ping'))


const pong$ = socket  
  .filter(m =&gt; /^ping$/.test(`${m}`)) 

const heartbeat$ = ping$
  .debounceTime(5000) 
  .mergeMap(() =&gt; Rx.Observable.timer(5000).takeUntil(pong$))

heartbeat$.subscribe(
  (msg) =&gt; console.log(`end ${msg}`),
  (err) =&gt; console.log(`err ${err}`),
  () =&gt; console.log(`complete`)
)
</code></pre>

<p>Any help appreciated. </p>
","2125385","","3088349","","2017-02-09 10:18:37","2019-08-29 06:22:34","How to periodically check live connection using rxjs?","<javascript><websocket><rxjs><rxjs5>","3","1","0","","","CC BY-SA 3.0"
"42120267","2","","42115698","2017-02-08 17:53:30","","2","","<p>You can use <code>race()</code> operator to always connect only to the Observable that emits first:</p>

<pre><code>function sendMockPing() {
  // random 0 - 5s delay
  return Observable.of('pong').delay(Math.random() * 10000 / 2);
}

Observable.timer(0, 5000)
  .map(i =&gt; 'ping')
  .concatMap(val =&gt; {
    return Observable.race(
      Observable.of('timeout').delay(3000),
      sendMockPing()
    );
  })
  //.filter(response =&gt; response === 'timeout') // remove all successful responses
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/lavinah/6/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/lavinah/6/edit?js,console</a></p>

<p>This randomly simulates response taking <code>0 - 5s</code>. When the response takes more than 3s than <code>Observable.of('timeout').delay(3000)</code> completes first and the <code>timeout</code> string is passed to its observer by <code>concatMap()</code>.</p>
","310726","","310726","","2017-02-08 22:37:07","2017-02-08 22:37:07","","","","1","","","","CC BY-SA 3.0"
"42134817","1","","","2017-02-09 10:56:33","","2","49","<p>I have an RxJS observable stream that I'm sharing like the following:</p>

<pre><code>var sub = Observable.create(obs =&gt; {
    // logic here

    return () =&gt; {
        // call rest service to notify server
    };
})
.publish()
.refCount();
</code></pre>

<p>When the last subscriber unsubscribes, I need to make a REST request.  The obvious choice is to add that call into the <code>return</code> cleanup function - but you then have broken out of any observable sequence and any errors etc aren't easily handled.</p>

<p>I could just use a <code>Subject</code>, push a value onto it in the cleanup function, and observe it elsewhere with the REST call hanging off that.</p>

<p>Ideally I'd do something like concatenating to the disposed stream with my REST call (<code>concat</code> obviously wouldn't work as it's not completing).</p>

<p>Does anyone have any suggestions for the cleanest way of handling this?  All the options above seem a bit clunky and I feel like I've missed something.</p>
","96521","","324260","","2017-02-10 05:26:16","2017-02-10 05:26:16","Observing when stream is unsubscribed","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42136184","1","42136432","","2017-02-09 12:00:16","","1","245","<p>I'm building a simple input type text with an Observable object linked to the keyup event on it.</p>

<p>I'm using Angular2 final (""@angular/core"": ""~2.1.1"" with ""rxjs"": ""5.0.2"").</p>

<p>Here is my app.component.ts:</p>

<pre><code>import {Component} from '@angular/core';
import {Observable} from 'rxjs/Observable';

@Component({
    selector: 'my-app',
    template: `
        &lt;input id=""search"" type=""text"" class=""form-control"" placeholder=""Search..."" &gt;
    `
})

export class AppComponent {
    constructor(){
        var keyups = Observable.fromEvent($(""#search""), ""keyup"");
        keyups.subscribe(data =&gt; console.log(data));
    }
}
</code></pre>

<p>When I press key, nothing appears on the console, so it seems that the event has not been fired or the observer is watching somewhere else.
What is missing?</p>

<p>Thanks in advance</p>
","2642983","","2642983","","2017-02-09 13:20:16","2017-02-09 14:23:07","Angular2 Observable with RxJS no errors but event not fired","<jquery><angular><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42136432","2","","42136184","2017-02-09 12:12:43","","2","","<p>I think you should try to move the two lines which are in your constructor in the ngAfterViewInitMethod :</p>

<pre><code>import {Component, AfterViewInit} from '@angular/core';
import {Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';

@Component({
    selector: 'my-app',
    template: `
        &lt;input id=""search"" type=""text"" class=""form-control"" placeholder=""Search..."" &gt;
    `
})

export class AppComponent implements AfterViewInit {
    constructor(){

    }
    ngAfterViewInit()Â {
        var keyups = Observable.fromEvent($(""#search""), ""keyup"");
        keyups.subscribe(data =&gt; console.log(data));
    }
}
</code></pre>

<p>But be carefull, you also need to keep a reference to your subscription to unsuscribe when your componenet will be deleted.</p>

<p>And I don't think that this is the ""angular way"" to perform what you want.</p>

<p>I think it is better to bind the ""keyup"" event of your input to a method of your component.</p>

<pre><code>@Component({
    selector: 'my-app',
    template: `
        &lt;input (keyup)=""onKeyUpOnInput($event)"" type=""text"" class=""form-control"" placeholder=""Search..."" &gt;
    `
})

export class AppComponent implements AfterViewInit {
    constructor(){

    }
    onKeyUpOnInput(data){
      console.log(""Key up"");
    }
}
</code></pre>
","1187140","","2642983","","2017-02-09 14:23:07","2017-02-09 14:23:07","","","","2","","","","CC BY-SA 3.0"
"42141745","1","42141972","","2017-02-09 16:19:48","","0","221","<p>I have an Angular2 app that fetches data from a source that requires authentication, so the app component init event initiates the auth token fetch like this:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { NgRedux } from '@angular-redux/store';
import { rootReducer } from './app.reducer';
import * as createLogger from 'redux-logger';
import { AppActions } from './app.actions';
import { createEpicMiddleware, combineEpics } from 'redux-observable';
import { UserEpics } from './users/user.epics';
import { ReplaySubject } from 'rxjs/ReplaySubject';

@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  constructor(
    private ngRedux: NgRedux&lt;any&gt;,
    private actions: AppActions,
    private userEpics: UserEpics,
  ) {
    ngRedux.configureStore(
      rootReducer,
      { user: { auth: { token$: new ReplaySubject(1) } } },
      [
        createLogger(),
        createEpicMiddleware(combineEpics(...userEpics.epics)),
      ]);
  }
  ngOnInit() {
    this.ngRedux.dispatch(this.actions.getAuthToken());
  }
}
</code></pre>

<p>Redux is storing an Rxjs5 ReplaySubject, and this subject will be fed the token value from the reducer like this:</p>

<pre><code>case AppActions.GET_AUTH_TOKEN_DONE:
  user.auth.token$.next(action.token);
  return Object.assign({}, user, {
    auth: {
      isFetching: false,
      token$: user.auth.token$,
      reason: undefined
    }
 });
</code></pre>

<p>This code is working for me, but does it violate the immutable state principle of the redux store?</p>
","1281721","","","","","2017-02-09 16:29:52","Does ReplaySubject.next(value) violate immutable state principle of redux store?","<angular><redux><rxjs5><redux-observable>","1","0","1","","","CC BY-SA 3.0"
"42141972","2","","42141745","2017-02-09 16:29:52","","2","","<p>I'd say it does - since you can mutate the state from anywhere by calling <code>.next(...)</code> - if it was an <code>Observable</code> instead of a <code>Subject</code> it might be a little different - but in any case I personally think it'd be a bad practice to store <code>Observables</code> as part of the state.</p>
","1518765","","","","","2017-02-09 16:29:52","","","","2","","","","CC BY-SA 3.0"
"42144121","1","42144380","","2017-02-09 18:20:14","","4","2443","<p>I have the following code (simplified for this post) - assume an initial call to <code>onStart()</code>.</p>

<p>Running this works fine. If I lose the internet connection I get the <code>net::ERR_INTERNET_DISCONNECTED</code> error (as expected) <strong><em>but</em></strong> the polling stops.</p>

<p>Clearly I am not handling any errors here as that is where I'm getting stuck. I'm not clear where I handle those errors and how? Do I need to call <code>startPolling()</code> again?</p>

<p>I need the polling to continue even if there is no internet connection, so that on re-connection data is updated. Any advice please?</p>

<pre><code>onStart() {
    this.startPolling().subscribe(data =&gt; {
        // do something with the data
    });
}

startPolling(): Observable&lt;any&gt; {
    return Observable
        .interval(10000)
        .flatMap(() =&gt; this.getData());
}

getData() {
    var url = `http://someurl.com/api`;
    return this.http.get(url)
        .map(response =&gt; {
            return response.json();
        });
}
</code></pre>

<p>Thanks in advance.</p>
","344302","","310726","","2017-02-09 18:40:37","2017-02-09 18:40:37","How to handle loss of connection in Angular2 with RXJS HTTP when polling","<http><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42144330","1","42144434","","2017-02-09 18:31:17","","1","304","<p>I receive messages via a websocket connection in this format :</p>

<pre><code>    [
      {
        //msg 1
      },
      {
        //msg 2
      },
      ....
    ]
</code></pre>

<p>based on some examples I found on the web here is my code:</p>

<pre><code>public messages: Subject&lt;Message&gt; = new Subject&lt;Message&gt;();
//...
        this.messages = &lt;Subject&lt;Message&gt;&gt;this.wsService
            .connect(COMMUNICATION_URL)
            .map((response: MessageEvent): Message =&gt; {
                let data = JSON.parse(response.data);
                //data is an array [ {..} , {..}, ...]
                return data;
            });


        this.messages.subscribe(msg =&gt; {
            console.log(msg);
            // msg is an array of objects [ {..} , {..}, ...]
            // I want to be just the object
        });
</code></pre>

<p>What I want to achieve is to split the message (array) in objects and when I subscribe I want to receive those objects and not the array of objects.</p>
","714211","","","","","2017-02-09 18:37:53","RxJS 5 - websocket array messages","<javascript><typescript><websocket><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42144380","2","","42144121","2017-02-09 18:34:22","","5","","<p>If you know the error happens because of <code>this.http.get(url)</code> then you can add <code>catch()</code> operator that lets you subscribe to another Observable instead of the source Observable that sent an <code>error</code> notification.</p>

<pre><code>getData() {
    var url = `http://someurl.com/api`;
    return this.http.get(url)
        .catch(err =&gt; Observable.empty())
        .map(response =&gt; {
            return response.json();
        });
}
</code></pre>

<p>This will simply ignore the error and won't emit anything.</p>
","310726","","","","","2017-02-09 18:34:22","","","","2","","","","CC BY-SA 3.0"
"42144434","2","","42144330","2017-02-09 18:37:53","","1","","<p>Most easily just use <code>concatAll()</code> or <code>mergeAll()</code> that when used with arrays in RxJS 5 reemits all its items.</p>

<pre><code>this.messages = &lt;Subject&lt;Message&gt;&gt;this.wsService
    .connect(COMMUNICATION_URL)
    .map((response: MessageEvent): Message =&gt; {
        let data = JSON.parse(response.data);
        //data is an array [ {..} , {..}, ...]
        return data;
    })
    .concatAll();
</code></pre>

<p>I didn't test it but I think you could also use shorter variant:</p>

<pre><code>this.messages = &lt;Subject&lt;Message&gt;&gt;this.wsService
    .connect(COMMUNICATION_URL)
    .concatMap((response: MessageEvent): Message =&gt; {
        let data = JSON.parse(response.data);
        //data is an array [ {..} , {..}, ...]
        return data;
    })
</code></pre>

<p>See similar answers:</p>

<ul>
<li><p><a href=""https://stackoverflow.com/questions/40170157/rxjs-refactor-nested-map-statement/40180701#40180701"">RxJS Refactor nested map statement</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/40346728/merge-subarrays-using-observables/40347238#40347238"">Merge subarrays using Observables</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/41609016/refactor-fat-arrow-nested-rxjs-stream/41609467#41609467"">refactor fat arrow nested rxjs stream</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/40250882/subscribing-to-a-nested-observable/40257871#40257871"">Subscribing to a nested Observable</a></p></li>
</ul>
","310726","","-1","","2017-05-23 11:45:23","2017-02-09 18:37:53","","","","1","","","","CC BY-SA 3.0"
"42147242","1","42174274","","2017-02-09 21:30:09","","1","45","<p>Example file:</p>

<pre><code>&lt;currencies&gt;&lt;usd_gbp&gt;0.80&lt;/usd_gbp&gt;&lt;usd_eur&gt;0.94&lt;usd_eur&gt;&lt;/currencies&gt;
</code></pre>

<p>I have an xml file <a href=""http://somesite.com/curency.xml"" rel=""nofollow noreferrer"">http://somesite.com/curency.xml</a> that contains currency conversion rates. The file is updated periodically. I want a stream to emit changes in real time as updates happen. How would you create an rx.js observable stream that emits updates in real time?</p>

<p>So far I was looking at this example but this processes the whole file at once and ends. <a href=""http://schempy.com/2015/10/14/simple_async_with_rxjs/"" rel=""nofollow noreferrer"">http://schempy.com/2015/10/14/simple_async_with_rxjs/</a></p>

<p>How do I make a steram emit updates as they happen to the file? Do I need to merge the apiStream to an interval or is there some other way?</p>
","7259639","","7259639","","2017-02-09 21:39:58","2017-02-13 08:06:15","How to stream continuous updates from an xml file","<javascript><rxjs5>","1","3","0","","","CC BY-SA 3.0"
"42148463","1","42154109","","2017-02-09 22:55:43","","4","4379","<p>What's the difference between <code>Subject</code> and <code>AnonymousSubject</code> in <em>RxJS 5</em>?
I've searched the internet but didn't find any info about <code>AnonymousSubject</code>.</p>

<p>I've found an example on the web</p>

<pre><code>Subject.create(observer, observable);
</code></pre>

<p>Looking into rxjs source code I saw that this creates and <code>AnonymousSubject</code>.
Can you also come up with an example when is good to use <code>AnonymousSubject</code>?</p>
","714211","","","","","2020-06-12 11:16:05","Subject vs AnonymousSubject","<javascript><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"42154109","2","","42148463","2017-02-10 07:49:00","","7","","<p>The <code>AnonymousSubject</code> doesn't subscribe itself to the source Observable. It just connects the <code>source</code> and <code>destination</code>.</p>

<p>I don't know what a typical use-case for <code>AnonymousSubject</code> looks like but it's used inside <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts#L46"" rel=""noreferrer""><code>Subject.lift()</code></a>.</p>

<p>Also see: <a href=""https://stackoverflow.com/questions/40361623/rxjs-subject-subscribe-method-not-working-as-expected/40362172#40362172"">RxJs Subject.subscribe method not working as expected</a></p>
","310726","","-1","","2017-05-23 11:47:05","2017-02-10 07:49:00","","","","0","","","","CC BY-SA 3.0"
"42174274","2","","42147242","2017-02-11 09:23:49","","0","","<p>Unless the server can push notifications to subscribers of updates to the conversion rates (via websockets for instance) you are stuck with periodically polling the xml file using regular HTTP requests for changes.</p>

<pre><code>Rx.Observable.interval(500)
  .flatMap(() =&gt; getConversionRates())
  .subscribe(conversionRate =&gt; console.log(`conversionRate: ${conversionRate}`));

function getConversionRates() {
  // implement logic to do one call to the xml file
  // and emit all conversion rates as observable emissions
  Return Rx.Observable.from([{ currency: 'usd_gbp', conversion: 0.80}]) 
}
</code></pre>

<p>If you really care about duplicate emissions of exactly the same currency+conversion then you could use <code>.groupBy(x =&gt; x.currency)</code> all your emissions combined with <code>.distinctUntilChanged()</code></p>
","106909","","106909","","2017-02-13 08:06:15","2017-02-13 08:06:15","","","","0","","","","CC BY-SA 3.0"
"42174935","2","","41537504","2017-02-11 10:45:09","","16","","<p>For anyone looking for this, following Mark's recommendation, I adapted rx-node <code>fromStream</code> implementation for rxjs5.</p>
<pre><code>import { Observable } from 'rxjs';

// Adapted from https://github.com/Reactive-Extensions/rx-node/blob/87589c07be626c32c842bdafa782fca5924e749c/index.js#L52
export default function fromStream(stream, finishEventName = 'end', dataEventName = 'data') {
  stream.pause();

  return new Observable((observer) =&gt; {
    function dataHandler(data) {
      observer.next(data);
    }

    function errorHandler(err) {
      observer.error(err);
    }

    function endHandler() {
      observer.complete();
    }

    stream.addListener(dataEventName, dataHandler);
    stream.addListener('error', errorHandler);
    stream.addListener(finishEventName, endHandler);

    stream.resume();

    return () =&gt; {
      stream.removeListener(dataEventName, dataHandler);
      stream.removeListener('error', errorHandler);
      stream.removeListener(finishEventName, endHandler);
    };
  }).share();
}
</code></pre>
<p>Note that it intrinsically breaks all back pressure functionalities of streams. Observables' are a push technology. All input chunks are going to be read and pushed to the observer as quickly as possible. Depending on your case, it might not be the best solution.</p>
","2212031","","2212031","","2021-03-04 18:23:23","2021-03-04 18:23:23","","","","2","","","","CC BY-SA 4.0"
"42189538","1","42198018","","2017-02-12 15:38:05","","1","2437","

<p>I am migrating to use <strong>ngrx Effects</strong> and I have the following issue: since <code>dispatch</code> returns <code>void</code> I am not sure how prevent router navigation if an error occurs from my ngrx effect (e.g. from <code>this.userAccountService.updateFirstName(...</code>).</p>

<p>From my component class:</p>

<pre class=""lang-js prettyprint-override""><code>  updateFirstName() {
    this.formStatus.submitted = true;
    if (this.formStatus.form.valid) {
      //Dispatch from the store
      this.store.dispatch(new UpdateFirstNameAction(this.formStatus.form.value.firstName));
      //Undesired behavior: will navigate even in case of error/failure!
      this.router.navigate(['/dashboard/useraccount']);
    }
  }
</code></pre>

<p>From my effect class:</p>

<pre class=""lang-js prettyprint-override""><code>  @Effect()
  updateFirstName$: Observable&lt;Action&gt; = this.actions$
    .ofType(currentUserAccount.ActionTypes.UPDATE_FIRST_NAME)
    .map((action: UpdateFirstNameAction) =&gt; action.payload)
    .switchMap(firstName =&gt;
      this.userAccountService
        .updateFirstName(firstName)
        .map(() =&gt; new UpdateFirstNameSuccessAction(firstName))
        //I obviously can't navigate from here
    );
</code></pre>

<p>I am not sure it is a good practice (or even possible) to use the router in order to navigate from the effect.</p>

<p>Can someone please suggest a clean solution to prevent the router navigation in case of an error occurring from my effect?</p>
","536299","","536299","","2017-02-12 16:11:24","2018-03-28 00:24:36","Preventing router navigation in case of an effect failure/error","<redux><rxjs><rxjs5><ngrx><ngrx-effects>","2","5","1","","","CC BY-SA 3.0"
"42189801","1","42199718","","2017-02-12 15:57:36","","23","23671","<p>I can't figure out how <code>publishReplay().refCount()</code> works.</p>

<p>For example (<a href=""https://jsfiddle.net/7o3a45L1/"" rel=""noreferrer"">https://jsfiddle.net/7o3a45L1/</a>):</p>

<pre><code>var source = Rx.Observable.create(observer =&gt;  {
  console.log(""call""); 
  // expensive http request
  observer.next(5);
}).publishReplay().refCount();

subscription1 = source.subscribe({next: (v) =&gt; console.log('observerA: ' + v)});
subscription1.unsubscribe();
console.log(""""); 

subscription2 = source.subscribe({next: (v) =&gt; console.log('observerB: ' + v)});
subscription2.unsubscribe();
console.log(""""); 

subscription3 = source.subscribe({next: (v) =&gt; console.log('observerC: ' + v)});
subscription3.unsubscribe();
console.log(""""); 

subscription4 = source.subscribe({next: (v) =&gt; console.log('observerD: ' + v)});
subscription4.unsubscribe();
</code></pre>

<p>gives the following result:</p>

<blockquote>
  <p>call observerA: 5</p>
  
  <p>observerB: 5 call observerB: 5</p>
  
  <p>observerC: 5 observerC: 5 call observerC: 5</p>
  
  <p>observerD: 5 observerD: 5 observerD: 5 call observerD: 5</p>
</blockquote>

<p>1) Why are observerB, C and D called multiple times? </p>

<p>2) Why ""call"" is printed on each line and not in the beginning of the line?</p>

<p>Also, if i call <code>publishReplay(1).refCount()</code>, it calls observerB, C and D 2 times each. </p>

<p>What i expect is that every new observer receives the value 5 exactly once and ""call"" is printed only once.</p>
","2829055","","310726","","2017-02-13 08:26:45","2017-02-13 08:36:09","rxjs 5 publishReplay refCount","<rxjs><rxjs5>","3","0","5","","","CC BY-SA 3.0"
"42198018","2","","42189538","2017-02-13 06:40:33","","2","","

<p>I would suggest using the <a href=""https://github.com/ngrx/router-store"" rel=""nofollow noreferrer""><code>@ngrx/router-store</code></a> module. With it you can create routing actions and, using it, you have a few options.</p>

<p>You can emit multiple actions from a single effect. So your effect could use <code>concatMap</code> to emit two actions: your success action and a routing action (created with the <a href=""https://github.com/ngrx/router-store#navigation-with-a-new-state-into-history"" rel=""nofollow noreferrer""><code>go</code></a> action creator):</p>

<pre class=""lang-js prettyprint-override""><code>import { go } from '@ngrx/router-store';
import 'rxjs/add/operator/concatMap';

@Effect()
updateFirstName$: Observable&lt;Action&gt; = this.actions$
  .ofType(currentUserAccount.ActionTypes.UPDATE_FIRST_NAME)
  .map((action: UpdateFirstNameAction) =&gt; action.payload)
  .switchMap(firstName =&gt; this.userAccountService
    .updateFirstName(firstName)
    .concatMap(() =&gt; [
      new UpdateFirstNameSuccessAction(firstName),
      go(['/dashboard/useraccount'])
    ])
  );
</code></pre>

<p>However, you might also want to consider using a separate effect that manages only the routing:</p>

<pre class=""lang-js prettyprint-override""><code>import { go } from '@ngrx/router-store';
import 'rxjs/add/operator/mapTo';

@Effect()
updateFirstRouting$: Observable&lt;Action&gt; = this.actions$
  .ofType(currentUserAccount.ActionTypes.UPDATE_FIRST_NAME_SUCCESS)
  .mapTo(go(['/dashboard/useraccount']);
</code></pre>

<p>Another thing to consider is that a single effect can respond to multiple actions, so you could use a table of simple action-type-to-route mappings to do something like this:</p>

<pre class=""lang-js prettyprint-override""><code>import { go } from '@ngrx/router-store';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';

simpleRoutes: { [type: string]: string } = {
  [currentUserAccount.ActionTypes.UPDATE_FIRST_NAME_SUCCESS]: '/dashboard/useraccount'
};

@Effect()
simpleRouting$: Observable&lt;Action&gt; = this.actions$
  .map((action) =&gt; this.simpleRoutes[action.type])
  .filter(Boolean)
  .map((route) =&gt; go([route]));
</code></pre>

<p>Whichever option you choose, using routing actions for navigation that is initiated within effects makes things more easily testable. It's easy to write effect tests to ensure that when an effect receives a particular action, it emits the appropriate action. There is more information on testing effects <a href=""https://github.com/ngrx/effects/blob/master/docs/testing.md"" rel=""nofollow noreferrer"">here</a>.</p>
","6680611","","6680611","","2017-02-13 21:18:17","2017-02-13 21:18:17","","","","5","","","","CC BY-SA 3.0"
"42199718","2","","42189801","2017-02-13 08:36:09","","30","","<p><code>publishReplay(x).refCount()</code> combined does the following:</p>

<ul>
<li>It create a <code>ReplaySubject</code> which replay up to <em>x</em> emissions. If <em>x</em> is not defined then it replays the complete stream.</li>
<li>It makes this <code>ReplaySubject</code> multicast compatible using a refCount() operator. This results in <em>concurrent</em> subscriptions receiving the same emissions.</li>
</ul>

<p>Your example contains a few issues clouding how it all works together. See the following revised snippet:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var state = 5
var realSource = Rx.Observable.create(observer =&gt;  {
  console.log(""creating expensive HTTP-based emission""); 
  observer.next(state++);
//  observer.complete();
  
  return () =&gt; {
    console.log('unsubscribing from source')
  }
});


var source = Rx.Observable.of('')
  .do(() =&gt; console.log('stream subscribed'))
  .ignoreElements()
  .concat(realSource)
.do(null, null, () =&gt; console.log('stream completed'))
.publishReplay()
.refCount()
;
    
subscription1 = source.subscribe({next: (v) =&gt; console.log('observerA: ' + v)});
subscription1.unsubscribe();
 
subscription2 = source.subscribe(v =&gt; console.log('observerB: ' + v));
subscription2.unsubscribe();
    
subscription3 = source.subscribe(v =&gt; console.log('observerC: ' + v));
subscription3.unsubscribe();
    
subscription4 = source.subscribe(v =&gt; console.log('observerD: ' + v));
 </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.1.0/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>When running this snippet we can see clearly that it is not emitting duplicate values for <em>Observer D</em>, it is in fact creating new emissions for every subscription. How come?</p>

<p>Every subscription is unsubscribed before the next subscription takes place. This effectively makes the refCount decrease back to zero, no multicasting is being done.</p>

<p>The issue resides in the fact that the <code>realSource</code> stream does not complete. Because we are not multicasting the next subscriber gets a fresh instance of <code>realSource</code> through the ReplaySubject and the new emissions are prepended with the previous already emitted emissions. </p>

<p>So to fix your stream from invoking the expensive HTTP request multiple times you have to complete the stream so the publishReplay knows it does not need to re-subscribe.</p>
","106909","","","","","2017-02-13 08:36:09","","","","0","","","","CC BY-SA 3.0"
"42202576","1","","","2017-02-13 11:08:14","","0","1686","<p>I'm calling a service and returning a json object. I'd like to filter the results but can't seem to get it to work. The request works fine and I'm passing in a keyword using a filter function. I've tried to console log it but it's returning an empty array.</p>

<p>Thank in advance.</p>

<pre><code> let keywords = 'defunkt';

this.http.get('https://api.github.com/users')
  .map((res: Response) =&gt; res.json())
  .subscribe(
    data =&gt; {
      this.result = data,
        console.log(this.result.filter((keyword, index) =&gt; keywords.lastIndexOf(keyword) === index));
    },
    err =&gt; console.error(err),
    () =&gt; console.log('done')
  );
</code></pre>
","3564375","","310726","","2017-02-13 11:18:05","2017-02-13 20:13:53","angular2, RxJs filter observable results?","<angular><ecmascript-6><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"42214772","1","","","2017-02-13 22:32:09","","0","771","<p>I want to understand more of the RxJS concept. Here is the problem I am currently struggling with. I want to abstract the accesses to a DB with async calls and i want to synchronize the accesses.</p>

<p>Can i have a stream of actions,<br>
 - that do async calls to db<br>
 - i want the next action be delayed until the previous action is completed<br>
 - the caller of the action shall get an Observable for the result of the async actions.</p>

<p>Example:  </p>

<p>User of class calls Action1: Read DB item, calculate next state (e.g. increment field), write to DB<br>
then..<br>
User of class calls next actions (Action2), but Action1 is still in progress.<br>
Action2: Read DB (shall not be started before the Action1:write is finished)  </p>

<p>How can this be done with RxJS+Typescript?</p>

<p>Frank</p>

<p>/////////////////////////////////</p>

<p>Meanwhile i have this code:</p>

<pre><code>import * as Rx from 'rxjs';

var actionQueue = new Rx.Subject&lt; () =&gt; Rx.Observable&lt;any&gt;&gt;();
actionQueue
  .concatMap( v =&gt; v() )
  .subscribe( v =&gt; {});

// example action with result type number
function action1 ( v : number ) : Rx.Observable&lt;number&gt; {
  console.log( ':: action1: ', v );
  var res = new Rx.Subject&lt;number&gt;();
  actionQueue.next( () =&gt; {
    console.log( '&gt;&gt; action1: ', v );
    setTimeout( ()=&gt;{
      console.log( '&lt;&lt; action1: ', v );
      res.next(v);
      res.complete();
    }, 500 );
    return res;
  });
  return res;
}

// some actions enqueue now, after 700+2500ms
action1( 11 ).subscribe( v =&gt; console.log( 'XX action1: ', v ));
action1( 22 ).subscribe( v =&gt; console.log( 'XX action1: ', v ));
action1( 33 ).subscribe( v =&gt; console.log( 'XX action1: ', v ));

setTimeout( ()=&gt;{
  action1( 44 ).subscribe( v =&gt; console.log( 'XX action1: ', v ));
}, 700 );

setTimeout( ()=&gt;{
  action1( 55 ).subscribe( v =&gt; console.log( 'XX action1: ', v ));
}, 2500 );
</code></pre>

<p>The output shows that it does sequential stuff.<br>
As typescript/js noob... is this code having pitfalls? Is there a more elegant way?</p>

<p>Frank</p>
","2436083","","2436083","","2017-02-14 20:48:36","2017-02-15 01:03:53","Synchronize async actions with RxJS","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"42235394","1","42235435","","2017-02-14 20:16:05","","1","887","<p>I have an angular2 service which makes an API call and then returns an observable, but, RXJS is returning an error saying EXCEPTION: Rx is not defined. What else do I need to import? Surely I don;'t need to import the whole folder?</p>

<p>!--- imports</p>

<pre><code>import 'rxjs/add/observable/from';
import 'rxjs/add/operator/map';
</code></pre>

<p>!--- service code </p>

<pre><code>  const server = 'http://api.myserver.com';
  return (dispatch) =&gt; {
    dispatch(this.requestJson());

    let s = this._http.get(`${server}`);
    s.flatMap(s =&gt; {
      let theRes = JSON.parse(s._body);
      return Rx.Observable.from(theRes); &lt;--- happens right here
    }).filter(function(data) {
      console.log('all array ' + data);
      return true;
    }).subscribe(function (v) {
      console.log(v);
    });
</code></pre>
","3564375","","","","","2017-05-26 11:47:18","RXJS - EXCEPTION: Rx is not defined, ng 2","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42235435","2","","42235394","2017-02-14 20:18:55","","2","","<p>You don't need to use <code>Rx.Observable</code>, <code>Observable</code> alone will do. And add:</p>

<pre><code>import {Observable} from 'rxjs/Observable'
</code></pre>

<p><strong>Update</strong>: The Angular CLI has improved tree shaking since I posted this answer, you should definitely always import from it's own module:</p>

<pre><code>import {Observable, Subscription} from 'rxjs' // is okay
import {Observable} from 'rxjs/Observable' // much better
import {Subscription} from 'rxjs/Subscription' // much better
</code></pre>
","871956","","871956","","2017-05-26 11:47:18","2017-05-26 11:47:18","","","","0","","","","CC BY-SA 3.0"
"42247401","1","","","2017-02-15 10:57:54","","0","459","<p>Not been doing Angular2 for long, so apologies if I'm not understanding observables correctly ... in a component I'm subscribing to getData which sits in a service class. What I want is for the http get to call and emit changes automatically back to the caller/subscriber when url changes (and maybe any other URL parameters for that matter). How can this be achieved? Am I not understanding observables correctly maybe?</p>

<pre><code>@Injectable()
export class HttpService {

    url: string;

    constructor(
        private http: Http
    ) {}

    getData() {
        return this.http.get(`${this.url}`)
            .map((res:Response) =&gt; res.json());
    }

    setUrl(url) {
        this.url = url;
    }
}
</code></pre>
","4235863","","1153681","","2017-02-15 11:14:16","2017-02-15 11:58:56","AngularJS 2 observables http change detection","<angular><rxjs><angular2-services><rxjs5><angular2-http>","1","0","1","","","CC BY-SA 3.0"
"42248209","1","42248499","","2017-02-15 11:34:12","","1","42","<p>I would like to combine several replayable incomplete observables that hold the last value (<code>BehaviorSubject</code> in this case) in a similar way like <code>zip</code> does, but to make the resulting observable emit a value when any source observables emits.</p>

<p>Here's <a href=""https://jsfiddle.net/36dkga2L/"" rel=""nofollow noreferrer"">a fiddle</a>:</p>

<pre><code>const foo$ = new Rx.BehaviorSubject('foo');
const bar$ = new Rx.BehaviorSubject('bar');

setTimeout(() =&gt; foo$.next('foo 1'), 1000)
setTimeout(() =&gt; bar$.next('bar 1'), 2000)

const foobar$ = Rx.Observable.zip(foo$, bar$);

foobar$.subscribe(([foo, bar]) =&gt; console.log({ foo, bar }));
</code></pre>

<p>Due to how <code>zip</code> operator works, the code above will output:</p>

<blockquote>
  <p>{foo: ""foo"", bar: ""bar""}</p>
  
  <p>{foo: ""foo 1"", bar: ""bar 1""}</p>
</blockquote>

<p>While I would like it to be</p>

<blockquote>
  <p>{foo: ""foo"", bar: ""bar""}</p>
  
  <p>{foo: ""foo 1"", bar: ""bar""}</p>
  
  <p>{foo: ""foo 1"", bar: ""bar 1""}</p>
</blockquote>

<p>How can this be done?</p>
","3731501","","","","","2017-02-15 11:46:14","Zip replayable RxJS observables","<javascript><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42248499","2","","42248209","2017-02-15 11:46:14","","3","","<p>Use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""nofollow noreferrer""><code>combineLatest()</code></a> operator:</p>

<pre><code>const foobar$ = Rx.Observable.combineLatest(foo$, bar$);
</code></pre>

<p>Your updated demo: <a href=""https://jsfiddle.net/d1wo1usx/"" rel=""nofollow noreferrer"">https://jsfiddle.net/d1wo1usx/</a></p>
","310726","","","","","2017-02-15 11:46:14","","","","1","","","","CC BY-SA 3.0"
"42249251","1","42249398","","2017-02-15 12:20:11","","1","1659","<p>Here's legacy promise-based piece of code that works as expected and results in completed observable when the condition (the presence of global variable) is fulfilled:</p>

<pre><code>const fooPromise = new Promise(resolve =&gt; {
  const interval = setInterval(() =&gt; {
    if (window.foo) {
      clearInterval(interval);
      resolve(window.foo);
    }
  }, 100);
});

setTimeout(() =&gt; {
    window.foo = {};
}, 1000)

const foo$ = Rx.Observable.fromPromise(fooPromise);

foo$.subscribe(
    () =&gt; console.log('success'),
    () =&gt; console.log('error'),
    () =&gt; console.log('complete')
);
</code></pre>

<p>I'm trying to convert it to neater observable-only solution, a <a href=""https://jsfiddle.net/po8gzu3o/"" rel=""nofollow noreferrer"">fiddle</a>:</p>

<pre><code>'use strict';

setTimeout(() =&gt; {
    window.foo = {};
}, 1000)

const foo$ = Rx.Observable.interval(100).map(() =&gt; foo).retry(-1)

foo$.subscribe(
    () =&gt; console.log('success'),
    () =&gt; console.log('error'),
    () =&gt; console.log('complete')
);
</code></pre>

<p>It looks like I'm on the right track, but the observable isn't completed and continues spamming with values.</p>

<p>What's the appropriate way to fix this?</p>
","3731501","","","","","2017-02-15 12:36:05","RxJS Observable that polls until the condition is true","<javascript><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42249398","2","","42249251","2017-02-15 12:26:18","","1","","<p>You only need to take one <code>foo</code>, so use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-take"" rel=""nofollow noreferrer""><code>take(count)</code> operator</a> :</p>

<blockquote>
  <p>Emits only the first count values emitted by the source Observable.</p>
  
  <p>Takes the first count values from the source, then completes.</p>
</blockquote>

<pre><code>const foo$ = Rx.Observable.interval(100).map(() =&gt; foo).retry().take(1)
</code></pre>

<p><a href=""https://jsfiddle.net/stn5amky/"" rel=""nofollow noreferrer"">Fiddle</a></p>
","3633742","","3633742","","2017-02-15 12:36:05","2017-02-15 12:36:05","","","","3","","","","CC BY-SA 3.0"
"42252387","1","","","2017-02-15 14:39:54","","1","283","<p>I have a very simple component, something like</p>

<pre><code>App.component('mxComponentOverlay', {
  template: '&lt;div&gt;&lt;/div&gt;',

  bindings: {
    input: '=?',
  },

  controller: ComponentOverlay,
});
</code></pre>

<p>Input is an object, so I am doing:</p>

<pre><code>  &lt;mx-component-overlay
     input=""{ 'icon': 'add', 'subject': $ctrl.subject }""&gt;
  &lt;/mx-component-overlay&gt;
</code></pre>

<p><code>$ctrl.subject</code> was an RxJS 4, Subject, migrating to RxJS 5 this is causing a <code>Maximum call stack size exceeded</code> error.</p>

<p>If I do:</p>

<pre><code>  &lt;mx-component-overlay
     input=""$ctrl.subject""&gt;
  &lt;/mx-component-overlay&gt;
</code></pre>

<p>I dont have the issue. Any idea what can cause this?</p>

<p><strong>UPDATE</strong></p>

<p><a href=""https://jsbin.com/juzesaroja/1/edit?html,js,console"" rel=""nofollow noreferrer"">jsbin that reproduces the issue</a></p>
","2277094","","2277094","","2017-02-15 20:27:52","2017-02-15 20:27:52","Angular binding causing Maximum call stack size exceeded","<angularjs><rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"42256531","1","","","2017-02-15 17:43:01","","2","909","<p>Using Angular, I am displaying a list (array) of data from the server. Above the list there is a <code>button bar</code> and <code>dropdown</code> that allows the user to <code>filter</code> the list.</p>

<p>I created 2 <code>Subjects</code> and used <code>combineLatest</code> in the stream like this:</p>

<pre><code>this.http.get('/api')
    .combineLatest(this.firstFilter$.startWith(initialValue))
    .map(([data, firstFilter]) =&gt; _.filter(data, item =&gt; firstFilter === item.prop))
    .combineLatest(this.secondFilter$.startWith(initialValue))
    .map(([data, secondFilter]) =&gt; _.filter(data, item =&gt; secondFilter === item.prop))
</code></pre>

<p>Although this works, when debugging I noticed that when calling the secondFilter$.next() the firstFilter's map is not called... But it does still take into account both filters and displays proper data. </p>

<p>I am wondering if there is a better approach to handling 2 or more filters?</p>
","2275792","","","","","2017-02-15 22:32:21","RxJS 5 filter: 2 combineLatest","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42269713","1","","","2017-02-16 09:24:26","","2","181","<p>I have a connectable observable that will get connected, when the other stream executed:</p>

<pre><code>const source1 = Rx.Observable.of([1,2,3,4,5])
  .do(() =&gt; console.log('Do Something!'))
  .map(() =&gt; ""Always connected."")
  .publish();

source1.subscribe((v) =&gt; console.log(v));

const connect = () =&gt; {
  let c = false;
  return () =&gt; {
    if (!c) {
       console.log(""Get connected"");
       source1.connect();
       c = true;
    }
  }
}


const source2 = Rx.Observable.fromEvent(document, 'click')
   .do(() =&gt; console.log(""execute!""))
   .do(connect())
   .switchMapTo(source1);

source2.subscribe((v) =&gt; console.log(v));
</code></pre>

<p>The output</p>

<pre><code>""execute!""
""Get connected""
""Do Something!""
""Always connected.""
</code></pre>

<p>Further clicks on the document <code>source1</code> will be not subscribe anymore and my question is, why?</p>
","1743843","","","","","2017-02-17 11:21:11","Why connectable observable get execute only once","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42272022","1","42294927","","2017-02-16 11:00:59","","0","2069","<p>I have two streams, that looks as follow:</p>

<pre><code>const source1 = Rx.Observable.of([1,2,3,4,5])
  .map(() =&gt; ""I am source 1"")
  .do((x) =&gt; console.log(x));
const sub1 = source1.subscribe((v) =&gt; console.log(""Subscribe 2""));

const source2 = Rx.Observable.fromEvent(document, 'click')
   .do(() =&gt; console.log(""execute!""))
   .switchMapTo(source1)
   .do(() =&gt; console.log(""After switch map.""))
   .map((x) =&gt; ""source2"");

source2.subscribe((x) =&gt; console.log(x));
</code></pre>

<p>Without click on document I've got following output:</p>

<pre><code>""I am source 1""
""Subscribe 2""
</code></pre>

<p>Further clicks the output is:</p>

<pre><code>""execute!""
""I am source 1""
""After switch map.""
""source2""
</code></pre>

<p>How can I force the stream <code>source1</code> to subscribe by further clicks and after continue with stream <code>source2</code>?</p>

<p>I am expecting after several clicks following output:</p>

<pre><code>""I am source 1""
""Subscribe 2""
""execute!""
""I am source 1""
""After switch map.""
""source2""
</code></pre>
","1743843","","","","","2017-02-17 10:02:23","Continue stream after subscribe","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42273859","1","42274672","","2017-02-16 12:22:35","","0","32","<p>I have an observable that will throw an error, when the counter will be reach 5:</p>

<pre><code>let counter = 0;

const source2 = Rx.Observable.of(true)
    .map(() =&gt; [1,2,3,4,5]);

source2
    .subscribe((x) =&gt; console.log(x),
               (err) =&gt; console.log(err),
               () =&gt; console.log(""complete 2!!""));


const source1 = Rx.Observable.fromEvent(document, 'click')
    .do(() =&gt; console.log(""Document clicked!""))
    .do(() =&gt; counter++)
    .map(() =&gt; {

      if(counter &gt; 5) {
        counter = 0;
        throw new Error(""Counter is too big!"");
      }

      return true;

    })
    .catch((oError, oSource$) =&gt; source2)


source1
    .subscribe((x) =&gt; console.log(x),
               (err) =&gt; console.log(err),
               () =&gt; console.log(""complete!!""));
</code></pre>

<p>When the error got threw, then it will switch to <code>source2</code> as you can see on the code above.</p>

<p>When I make further clicks on the document, nothing will happen why? What happen with further clicks?</p>
","1743843","","1743843","","2017-02-16 12:32:27","2017-02-16 13:54:07","What happen with further clicks","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42274672","2","","42273859","2017-02-16 12:57:50","","1","","<p>This is one of the basic rxjs-paradigms: Whenever an error is thrown in a stream (no matter if it is a direct <code>throw new Error(..)</code> or <code>Observable.throw(...)</code>) the subscribed stream is automatically <em>finalized</em> and subscribers are unsubscribed.</p>

<p>So the behavior is expected.</p>

<p>To <em>fix</em> this in your personal case: Don't throw an error if you don't want your stream to stop and unless you want to resubscribe manually.</p>

<p>Addition: The <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-catch"" rel=""nofollow noreferrer""><code>catch</code>-operator</a> just allows for reacting to an error within the stream, independently from any subscriber - the stream itself will still be finalized though - the name <code>catch</code> kind of gives a false impression here. - You can <em>""retry""</em> the observable by returning the original source in the <code>catch</code>-operator, which will effectively create a new stream based on that source, the old stream, however, will still be finalized.</p>
","1518765","","1518765","","2017-02-16 13:54:07","2017-02-16 13:54:07","","","","9","","","","CC BY-SA 3.0"
"42280438","1","","","2017-02-16 17:08:29","","20","1599","<p>I am using RsJS 5 (5.0.1) to cache in Angular 2. It works well. </p>

<p>The meat of the caching function is:</p>

<pre><code>const observable = Observable.defer(
    () =&gt; actualFn().do(() =&gt; this.console.log('CACHE MISS', cacheKey))
  )
  .publishReplay(1, this.RECACHE_INTERVAL)
  .refCount().take(1)
  .do(() =&gt; this.console.log('CACHE HIT', cacheKey));
</code></pre>

<p>The <code>actualFn</code> is the <code>this.http.get('/some/resource')</code>.</p>

<p>Like I say, this is working perfectly for me. The cache is returned from the observable for duration of the <code>RECACHE_INTERVAL</code>. If a request is made after that interval, the <code>actualFn()</code> will be called. </p>

<p>What I am trying to figure out is when the <code>RECACHE_INTERVAL</code> expires and the <code>actualFn()</code> is called &mdash; how to return the last value. There is a space of time between when the <code>RECACHE_INTERVAL</code> expires and the <code>actualFn()</code> is replayed that the observable doesn't return a value. I would like to get rid of that gap in time and always return the last value. </p>

<p>I could use a side effect and store the last good value call <code>.next(lastValue)</code> while waiting for the HTTP response to return, but this seems naive. I would like to use a ""RxJS"" way, a pure function solution &mdash; if possible.   </p>
","207051","","1463595","","2017-02-25 19:13:25","2017-09-23 17:11:43","Reactive Caching of HTTP Service","<angular><caching><rxjs><rxjs5>","3","0","3","","","CC BY-SA 3.0"
"42294927","2","","42272022","2017-02-17 10:02:23","","1","","<p>Observables can be thought of as functions. And subscribing is like calling a function.</p>

<p>i.e</p>

<pre class=""lang-js prettyprint-override""><code>const o = Rx.Observable.of(1);
o.subscribe(x =&gt; console.log(x));
</code></pre>

<p>is very similar to</p>

<pre class=""lang-js prettyprint-override""><code>const f = () =&gt; 1;
console.log ( f() );
</code></pre>

<p>Just like calling a function doesn't modify the function. Subscribing to an Observable doesn't modify the observable. The subscription isn't <em>attached</em> to the Observable in any way. It's the returned subscription which is holding any state.</p>

<hr>

<p>The two calls to subscribe in your example are completely independant and is the same as this:</p>

<pre class=""lang-js prettyprint-override""><code>const source1 = Rx.Observable.of([1,2,3,4,5])
  .map(() =&gt; ""I am source 1"")
  .do((x) =&gt; console.log(x));
const sub1 = source1.subscribe((v) =&gt; console.log(""Subscribe 2""));

const source1_v2 = Rx.Observable.of([1,2,3,4,5])
  .map(() =&gt; ""I am the same as source 1"")
  .do((x) =&gt; console.log(x));

const source2 = Rx.Observable.fromEvent(document, 'click')
   .do(() =&gt; console.log(""execute!""))
   .switchMapTo(source1_v2)
   .do(() =&gt; console.log(""After switch map.""))
   .map((x) =&gt; ""source2"");

source2.subscribe((x) =&gt; console.log(x));
</code></pre>
","2229334","","","","","2017-02-17 10:02:23","","","","0","","","","CC BY-SA 3.0"
"42314480","1","","","2017-02-18 11:22:33","","7","7211","<p>I'm using <a href=""https://github.com/systemjs/systemjs"" rel=""noreferrer"">SystemJS</a> to load my es2015 project into the browser. </p>

<p>This is what I did</p>

<pre><code>import {Observable} from 'rxjs/Rx';

const button = document.querySelector('button');
const start$ = Observable.fromEvent(button, 'click');
</code></pre>

<p>In this case <code>Observable</code> is <code>undefined</code>. So I tried</p>

<pre><code>import Observable from 'rxjs/Observable';
</code></pre>

<p>In which case <code>Observable</code> is an object but <code>Observable.fromEvent</code> is <code>undefined</code> (it seems to be an empty object)</p>

<p>Finally I did</p>

<pre><code>import Rx from 'rxjs/Rx' // Rx.Observable
</code></pre>

<p>which did work. Any ideas why the other two didn't work? I have seen code in which they used these. What would be the preferred way to import <code>Observable</code>?</p>

<p>UPDATE: As stated below its all described in the <a href=""https://github.com/ReactiveX/rxjs#es6-via-npm"" rel=""noreferrer"">README</a>. However if I do that</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';

const start$ = Observable.fromEvent(startButton, 'click');
</code></pre>

<p>I get <code>Observable</code> is <code>undefined</code>. And if I do</p>

<pre><code>import Observable from 'rxjs/Observable';
</code></pre>

<p>the <code>Observable</code> is an empty object again. The <code>fromEvent</code> is not added. </p>

<p>I'm using RxJs 5.1.1 and here is my index.html/systemjs part:</p>

<pre><code> &lt;script src=""./node_modules/systemjs/dist/system.js""&gt;&lt;/script&gt;
  &lt;script&gt;
      SystemJS.config({
          baseURL: 'node_modules',
          packages: {
              '.': {
                  defaultJSExtensions: 'js'
              }
          },
          map: {
              'plugin-babel': 'systemjs-plugin-babel/plugin-babel.js',
              'systemjs-babel-build': 'systemjs-plugin-babel/systemjs-babel-browser.js'
          },
          transpiler: 'plugin-babel'
      });

      SystemJS.import('/js/main.js');
  &lt;/script&gt;
</code></pre>
","419425","","310726","","2017-02-20 12:06:33","2018-04-15 08:24:04","How to import `Observable` from `Rx` (not angular)","<javascript><ecmascript-6><rxjs><systemjs><rxjs5>","5","4","4","","","CC BY-SA 3.0"
"42323285","1","42333189","","2017-02-19 03:23:29","","2","88","<p>If you run the code below you'll see in the console that an xhr request is sent regardless of whether or not I'm <code>subscribed</code> to <code>subject</code>. I'd like to not make those request when I'm not subbed to it.</p>

<pre><code>// npm install rxjs
const Rx = require('rxjs/Rx');

let subject = new Rx.BehaviorSubject(null)
Rx.Observable.timer(0, 1000).subscribe(i =&gt; someApiCall(i));
//at this point xhr request will be sent every second

function someApiCall(i){
    // retrieve some data
    console.log(""xhr request sent"")
    subject.next(i);
}

//so here we are gonna subscribe to the subject, xhr made prior 
//to this subscription are useless
let subscription;
setTimeout(() =&gt; subscription = subject.subscribe(i =&gt; console.log(i)),2500);
setTimeout(() =&gt; subscription.unsubscribe(),6000);
// now we are unsubscribing but the xhr req keep going
</code></pre>

<p>The reason I'm using the behaviorSubject and not subscribing directly on the observable is because I  want the last value from the last xhr request instantly when I resubscribe.</p>
","4299560","","490326","","2017-02-19 03:34:12","2017-02-19 21:41:40","Change the subscription state of an observable with another observable","<javascript><angular><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"42329997","1","42333656","","2017-02-19 16:50:16","","1","4475","<p>I have an array, the type of the values is irrelevant. What I would like to do is emitting one value every x seconds, call a function with that value, and if that function failed for some reason, retry it after y seconds (can be a simple constant, no need for any incremental thing here).</p>

<p>What I have so far</p>

<pre><code>Rx.Observable
    .interval(500)
    .take(arr.length)
    .map(idx =&gt; arr[idx])
    .flatMap(dt =&gt; randomFunc(dt))
    .catch(e =&gt; conosle.log(e))
    .retry(5)
    .subscribe();

function randomFunc(dt) {
    return Rx.Observable.create(observer =&gt; {
        if (dt === 'random') {
            return observer.error(`error`);
        } else {
            return observer.next();
        }
    });
}
</code></pre>

<p>2 problems here though:</p>

<p>1: When <code>randomFunc</code> returns an error it seems that the whole chain starts over. I only need the failed one to retry.</p>

<p>2: <code>catch</code> never actually logs any error, even though it seems to retry on error.</p>

<p>For the first problem I've tried <code>switchMap</code> instead of <code>flatMap</code> like this:</p>

<pre><code>Rx.Observable
    .interval(500)
    .take(arr.length)
    .map(idx =&gt; arr[idx])
    .switchMap(dt =&gt; randomFunc(dt)
        .catch(e =&gt; conosle.log(e))
        .retry(5)
    )
    .subscribe();
</code></pre>

<p>This way it seemed that it retried the failed ones only, but still didn't log any error and I'm not even sure <code>switchMap</code> is good here (I'm really an Rx noob).</p>

<p>Any help would be appreciated, thanks!</p>
","4056372","","310726","","2017-02-19 22:24:40","2017-02-19 22:24:40","RxJS emit values from array every x seconds, call a function with that value, retry if failed","<javascript><rxjs><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"42333187","1","45613936","","2017-02-19 21:35:52","","11","6512","<p>So a quick question. I've been using RxJS 5 for a few months now, and I've run into a bit of behavior that I don't really understand, as I haven't been able to look it up anywhere.</p>
<p>I'm in a situation where subscribing to an observable chain with simply <code>.subscribe();</code> doesn't trigger the observable.</p>
<p>However, if I add an onNext callback (empty or not), the observable triggers, and the chain processes: <code>.subscribe(() =&gt; {});</code></p>
<p>Can anyone explain why this behavior happens?</p>
","536485","","536485","","2020-09-25 12:21:10","2020-09-25 12:21:10","RXJS 5 .subscribe() without arguments","<angular><typescript><ionic2><rxjs5><subscribe>","2","7","1","","","CC BY-SA 4.0"
"42333189","2","","42323285","2017-02-19 21:36:00","","1","","<p><a href=""https://acutmore.jsbin.com/bepiho/2/edit?js,console"" rel=""nofollow noreferrer"">https://acutmore.jsbin.com/bepiho/2/edit?js,console</a></p>

<pre class=""lang-js prettyprint-override""><code>const { Observable } = Rx;

function someApiCall(i){
  return Observable.create(observer =&gt; {
    console.log(""xhr request sent"")
    observer.next(i);
    observer.complete();
  });
}

const data = Rx.Observable.timer(0, 1000)
  // map each value to the values of someApiCall
  . mergeMap(i =&gt; someApiCall(i))
  // share the values through a replaySubject
  .publishReplay(1)
  // Only connect to the source when there is at least one subscriber
  .refCount();

data
  .take(5)
  .subscribe(v =&gt; console.log(v));

data
  .take(1)
  .subscribe(v =&gt; console.log(v));
</code></pre>

<p>Worth noting this won't work as expected if everyone does <code>.take(1)</code> when they subscribe because everyone will get the value in the <code>ReplaySubject</code> and then instantly unsubscribe before a new xhrRequest will be made.</p>

<p>i.e. Something needs to keep it <em>alive</em> long enough for the interval to keep firing.</p>
","2229334","","2229334","","2017-02-19 21:41:40","2017-02-19 21:41:40","","","","0","","","","CC BY-SA 3.0"
"42333656","2","","42329997","2017-02-19 22:23:46","","1","","<p>There're a couple of things to be aware of. The <code>retry()</code> operator just resubscribes to its source so if you don't want to start the entire iteration again you can merge/concat the async function into the chain.</p>

<pre><code>Rx.Observable.from(arr)
  .concatMap(val =&gt; {
    let attempts = 0;

    return Rx.Observable.of(val)
      .delay(500)
      .concatMap(val =&gt; randomFunc(val)
        .catch((err, caught) =&gt; {
          console.log('log error');
          if (attempts++ === 1) {
            return Rx.Observable.of(err);
          } else {
            return caught;
          }
        })
      );

  })
  .subscribe(val =&gt; console.log(val));

function randomFunc(dt) {
  return Rx.Observable.create(observer =&gt; {
    if (dt === 'random') {
      observer.error(`error received ${dt}`);
    } else {
      observer.next(dt);
      observer.complete();
    }
  });
}
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/qacamab/7/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/qacamab/7/edit?js,console</a></p>

<p>This prints to console:</p>

<pre><code>1
2
3
4
log error
log error
error received random
6
7
8
9
10
</code></pre>

<p>The <code>catch()</code> operator is the most important part. Its selector function takes two arguments:</p>

<ul>
<li><code>err</code> - The error that occurred</li>
<li><code>caught</code> - The original Observable.</li>
</ul>

<p>If we return <code>caught</code> from the selector function we'll just resubscribe to the source Observable (which is the same as <code>retry(1)</code>). Since you want to log each error message we have to use <code>catch()</code> instead of just <code>retry()</code>. By returning <code>Rx.Observable.of(err)</code> we propagate the error further and in turn it'll be received by the subscriber as <code>next</code> notification. We could also return just <code>Observable.empty()</code> to simply ignore the error.</p>
","310726","","","","","2017-02-19 22:23:46","","","","0","","","","CC BY-SA 3.0"
"42334602","1","42334858","","2017-02-20 00:19:42","","20","20680","<p>I have the following code inside my constructor:</p>

<pre><code>this.searchResults = this.searchTerm.valueChanges
    .debounceTime(500)
    .distinctUntilChanged()
    .switchMap(term =&gt; this.apiService.search({
        limit: this.searchResultsLimit,
        term: term
    }));
</code></pre>

<p>And this is my input</p>

<pre><code>&lt;input type=""text"" [formControl]=""searchTerm"" /&gt;
</code></pre>

<p>You can see the tutorial I followed to get the code <a href=""https://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html#putting-some-sugar-on-top"" rel=""noreferrer"">here</a>.</p>

<p>My API service method is as followed:</p>

<pre><code>searchCompanies(options): Observable&lt;any[]&gt; {
    return this.jsonp.get('api/search', this.formatOptions(options)).map(res =&gt; {   
        return res.json();
    });
}
</code></pre>

<p>Each time <code>searchTerm</code> is changed inside my input, the API call is fired. My problem is that the call is fired even when my input is empty (such as typing a query, then backspacing it all).</p>

<p>My question is, how can I only get my observable to fire when the value of `searchTerm is not empty/null?</p>
","1799136","","310726","","2017-02-20 00:29:18","2020-09-23 22:32:06","How to only execute an Observable if term is not null/empty?","<angular><typescript><rxjs><observable><rxjs5>","3","3","3","","","CC BY-SA 3.0"
"42334858","2","","42334602","2017-02-20 00:55:02","","9","","

<p>If you want to avoid the API call and want the search results to be reset when the search term is empty, test for an empty string in <code>switchMap</code> and return an empty observable in that situation:</p>

<pre class=""lang-js prettyprint-override""><code>this.searchResults = this.searchTerm
  .valueChanges
  .debounceTime(500)
  .distinctUntilChanged()
  .switchMap(term =&gt; term ?
    this.apiService.search({
      limit: this.searchResultsLimit,
      term: term
    }) :
    // If search term is empty, return an empty array
    // or whatever the API's response for no matches
    // would be:
    Observable.of([]) 
  });
</code></pre>
","6680611","","6680611","","2017-02-20 02:27:39","2017-02-20 02:27:39","","","","2","","","","CC BY-SA 3.0"
"42345753","1","42355557","","2017-02-20 13:24:08","","2","293","<p>I'm working on a schedule for a community radio station and wondered how I might go about updating the current show playing.</p>

<p>I've got as far as polling the server once a minute (not sure this is the way to go, but it would work at a push), but seeing as I have the end time from the API I wondered if I could set it to update after the end time passes and then set up a new Observer with the next end time.</p>

<p>Does anyone have an idea how I might accomplish that, or have a better way to approach updating the current show?</p>

<p>What I'm really struggling with is getting my head around Observables and Subscribers. How can I get access to the current end_time from <code>radioShow$</code> to see if it has passed in an <code>Observable.interval</code> for example?</p>

<p>I'll be very grateful for any help with this.</p>

<pre><code>export class PlayerComponent {

    radioShow$ = new BehaviorSubject({
        start_time: new Date(),
        end_time: new Date(),
        radio_show: {
            id: 0,
            name: ""Loading..."",
    });

    constructor(
        @Inject('api') private api, 
        private http: Http) {
            Observable.interval(1000*60)
                .switchMap(() =&gt; http.get(api + '/schedule/current/show')
                .map(res =&gt; res.json()))
                .subscribe(this.radioShow$);
    }
}
</code></pre>

<p>View player.component.html:</p>

<pre><code>&lt;div class=""io-radio-player""&gt;
  &lt;p class=""schedule-times""&gt;{{(radioShow$ | async).start_time | date:""HH:mm""}}â{{(radioShow$ | async).end_time | date:""HH:mm""}}&lt;/p&gt;
  &lt;h3 class=""margin-none""&gt;
    &lt;a [routerLink]=""['/radio-shows', (radioShow$ | async).radio_show.id]""&gt;{{(radioShow$ | async).radio_show.name | uppercase}}&lt;/a&gt;
  &lt;/h3&gt;
&lt;/div&gt;
</code></pre>

<p><strong>@martins code works, but this is what I used in the end:</strong></p>

<pre><code>radioShow$ = new BehaviorSubject({
    start_time: new Date(),
    end_time: new Date(),
    radio_show: {
        id: 0,
        name: ""Loading...""
    }
});
timer = new Subject();

@Component({
    selector: 'app-player',
    templateUrl: './player.component.html'
})
subject = new Subject();

    let request = http.get(api + '/schedule/current/show')
        .switchMap(() =&gt; http.get(api + '/schedule/current/show')
        .map(res =&gt; res.json()))
        .repeatWhen(() =&gt; this.subject)
        .publishReplay()
        .refCount();

    request
        .subscribe(this.radioShow$);

    request
        .map(response =&gt; { 
            // calculate the delay
            return Math.abs(new Date(response.end_time).getTime() - (new Date()).getTime());
        })
        .concatMap(delay =&gt; Observable.of(null).delay(delay))
        .subscribe(this.subject);
</code></pre>
","2562137","","2562137","","2017-02-21 20:47:05","2017-02-21 20:47:05","Make API Request at a given time to update current radio show Angular2 RxJS","<angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42349778","1","","","2017-02-20 16:36:08","","1","376","<p>I have two RX infinite streams (let's call them <code>mainValues</code> and <code>decoratorValues</code>). The one called <code>mainValues</code> are adding elements to a list called <code>valueList</code>. The other stream (<code>decoratorValues</code>) should assign properties to these elements in the list.</p>

<p><strong>Elements in the two streams are arriving at random times in random order</strong>, and I need to solve it in either order that <code>mainValues</code> are <strong>put into the list as soon as available</strong>, while <code>decoratorValues</code> <strong>are not lost</strong> until their corresponding elements (identified by an ID) arrive.</p>

<pre><code>const mainValues = [ { id: 1, someValue: 'a' }, { id: 2, someValue: 'b'  }, { id: 3, someValue: 'c' }];
const decoratorValues = [ { id: 3, decoratedValue: true }, { id: 2, decoratedValue: false }];

// delay here is only for demonstration purpose 
// a time independent solution can be tested with swapping it between these two
const mainValueStream = Rx.Observable.fromArray(mainValues).delay(2000);
const decoratorStream = Rx.Observable.fromArray(decoratorValues);

const valueList = [];

mainValueStream.subscribe(
  val =&gt; valueList.push(val), 
  (err) =&gt; console.log(err),
  () =&gt; console.log('complete', valueList));

// CODE time independent merging of the two streams go here

// resulting valueList should be:  [ { id: 1, someValue: 'a' }, { id: 2, someValue: 'b', decoratedValue: false }, { id: 3, someValue: 'c', decoratedValue: true } ]
</code></pre>

<h2>Solution idea</h2>

<pre><code>mainValueStream
  .concatMap(main =&gt; {
     decoratorStream
       .filter(dec =&gt; dec.id === main.id)
       .do(dec =&gt; {
          main.decoratedValue = dec.decoratedValue;
     }).subscribe(x =&gt; x);

     return [main];
  })
  .subscribe(
    val =&gt; valueList.push(val), 
    (err) =&gt; console.log(err),
    () =&gt; console.log('complete', valueList));
</code></pre>

<p>Unfortunately this only works when all of the decorator values has arrived <em>before</em> the main value stream.</p>

<p>My second idea would be adding a second stream that checks if the given value is already in <code>valueList</code> and updates it, if it has the element with the appropriate ID.</p>

<p><strong>Is there a time-independent solution that results in only one stream? Or maybe I'm stuck because I want to solve it with one stream?</strong></p>
","2018771","","2018771","","2017-02-22 14:14:43","2017-02-22 16:09:48","RxJs: updating values in a list from an other stream identified by an ID","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42354606","1","42401365","","2017-02-20 21:33:10","","3","2404","<p>I've been working on an application in Angular2/CLI/NGRX and things have been going well until recently. I'm noticing some pretty big spikes in performance especially with consecutive dispatches within the same container. </p>

<p>For example lets say I have the following defined:</p>

<pre><code>public appEnvironment$: Observable&lt;IEnvironment&gt;;

public assessment$: Observable&lt;IAssessment&gt;;
public assessmentComments$: Observable&lt;ICommentActivity[]&gt;;
public assessmentEvidence$: Observable&lt;IEvidenceActivity[]&gt;;
public assessmentIssues$: Observable&lt;IIssueActivity[]&gt;;
public assessmentSurvey$: Observable&lt;ISurvey&gt;;
public assessmentUsers$: Observable&lt;ISystemUser[]&gt;;
public assessmentSelectedNode$: Observable&lt;ISurveyChildNode&gt;;

constructor(private _store: Store&lt;fromDomain.State&gt;, private _route: ActivatedRoute) {
  this.appEnvironment$ = _store.select(fromDomain.getEnvironment).share();

  this.assessment$ = _store.select(fromDomain.getAssessment).share();
  this.assessmentComments$ = _store.select(fromDomain.getAssessmentComments).share();
  this.assessmentIssues$ = _store.select(fromDomain.getAssessmentIssues).share();
  this.assessmentEvidence$ = _store.select(fromDomain.getAssessmentEvidence).share();
  this.assessmentSurvey$ = _store.select(fromDomain.getAssessmentSurvey).share();
  this.assessmentUsers$ = _store.select(fromDomain.getAssessmentUsers).share();
  this.assessmentSelectedNode$ = _store.select(fromDomain.getAssessmentSelectedNode).share();

  this.openAssessmentId = _route.snapshot.params['id'];

  this._store.dispatch(new LoadAssessmentAction(this.openAssessmentId));
}
</code></pre>

<p>It's also worth noting that the above is all the state selection required to load the child components and their data shared across multiple components (hence the .share()) something like:</p>

<pre><code>&lt;opt-drawer-index
  #drawerShow
  [leftHeading]=""'Survey Info'""
  [leftIcon]=""'fa-bars'""
  [rightHeading]=""'Assessment Details'""
  [onForceChange]=""assessmentSelectedNode$ | async""&gt;
  &lt;section drawer-left-content&gt;
    &lt;opt-assessment-show-survey-info
      [appEnvironment]=""appEnvironment$ | async""
      [assessment]=""assessment$ | async""
      [assessmentUsers]=""assessmentUsers$ | async""&gt;&lt;/opt-assessment-show-survey-info&gt;
  &lt;/section&gt;
  &lt;section drawer-content&gt;
    &lt;opt-assessment-show-content
      [appEnvironment]=""appEnvironment$ | async""
      [assessment]=""assessment$ | async""
      [assessmentSurvey]=""assessmentSurvey$ | async""
      (selectedNode)=""changeSelectedNode($event)""&gt;&lt;/opt-assessment-show-content&gt;
  &lt;/section&gt;
  &lt;section drawer-right-content&gt;
    &lt;opt-assessment-show-details
      [activeNode]=""assessmentSelectedNode$ | async""
      [appEnvironment]=""appEnvironment$ | async""
      [assessment]=""assessment$ | async""
      [assessmentComments]=""assessmentComments$ | async""
      [assessmentEvidence]=""assessmentEvidence$ | async""
      [assessmentIssues]=""assessmentIssues$ | async""
      [assessmentUsers]=""assessmentUsers$ | async""&gt;&lt;/opt-assessment-show-details&gt;
  &lt;/section&gt;
&lt;/opt-drawer-index&gt;
</code></pre>

<p>The initial load is great and works well. I have the freeze-state active and no mutations are occurring within the state. All components are utilizing the OnPush strategy as well.</p>

<p>The problem is within the center content component I have an event emitter that talks with the container component. It sends up an object to 'select' and that fires off an action through the dispatcher to update the state with the selected option. The first couple clicks run great and then you start to notice some serious power consumption as you continue to click on different areas throughout the child components. It's almost as if the dispatcher seems to be bogged down.</p>

<p>I've tried a few things like using combineLatest() and other tools to lessen the burden on the updates, however that seemed to make matters worse. Currently the way the application loads data is as follows:</p>

<pre><code>Load Assessment -&gt; After Load Assessment Effect -&gt; Select Assessment -&gt; After Load Selected Assessment Effect
</code></pre>

<p>Anyone else run into performance issues? Is it something unrelated to NGRX and the way that I have things setup? I've mainly used the NGRX example app as a reference point for how to lay out my setup.</p>

<p><em>Edit</em></p>

<p>Here's a timeline representation of the problem I'm having. It's almost as though the click event is getting exponentially longer?</p>

<p><a href=""https://i.stack.imgur.com/panvb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/panvb.png"" alt=""Timeline""></a></p>

<p><em>Edit 2</em></p>

<p>I am using reselect and here's the effects for the page that is hanging after subsequent clicks:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {Injectable} from ""@angular/core"";

// NGRX
import {Actions, Effect} from ""@ngrx/effects"";
import {Action} from ""@ngrx/store"";

// Services
import {AssessmentService} from ""./assessment.service"";
import {SurveyService} from ""../survey/survey.service"";
import {SystemUserService} from ""../system-user/system-user.service"";

// Observable and operators
import {Observable} from ""rxjs/Observable"";
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/concatMap';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/map';

// Misc
import * as assessment from './assessment.actions';
import * as assessmentNav from './navigation/assessments-navigation.actions';

@Injectable()
export class AssessmentEffects {
  constructor(private actions$: Actions, private assessmentsService: AssessmentService,
              private surveyService: SurveyService, private systemUserService: SystemUserService) { }

  @Effect()
  effLoadAssessment$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT)
    .map((action: assessment.LoadAssessmentAction) =&gt; action.payload)
    .switchMap(guid =&gt; {
      return this.assessmentsService.getAssessment(guid)
        .map(v =&gt; new assessment.LoadAssessmentCompleteAction(v));
    });

  @Effect()
  effAfterLoadAssessment: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT_COMPLETE)
    .map((action: assessment.LoadAssessmentCompleteAction) =&gt; action.payload)
    .mergeMap(theAssessment =&gt; {
      return [
        new assessment.LoadAssessmentSurveyAction(theAssessment.surveyID),
        new assessmentNav.AssessmentNavAddAction(theAssessment),
        new assessment.LoadAssessmentUserAction(theAssessment.instanceOwner_SystemUserID)
      ];
    });

  @Effect()
  effLoadAssessmentComments$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT_COMMENTS)
    .map((action: assessment.LoadAssessmentCommentsAction) =&gt; action.payload)
    .switchMap(multiRequest =&gt; {
      return this.assessmentsService
        .getAssessmentComments(multiRequest.assessmentId, multiRequest.type, multiRequest.nodeId)
        .map(v =&gt; new assessment.LoadAssessmentCommentsCompleteAction(v));
    });

  @Effect()
  effAfterSelectedNode$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.SELECT_ASSESSMENT_NODE)
    .map((action: assessment.SelectedNodeAction) =&gt; action.payload)
    .mergeMap(theNode =&gt; {
      return [
        new assessment.LoadAssessmentCommentsAction({
          type: 'Comments',
          nodeId: theNode.id,
          assessmentId: theNode.assessmentId
        }),
        new assessment.LoadAssessmentIssuesAction({
          type: 'Issues',
          nodeId: theNode.id,
          assessmentId: theNode.assessmentId
        }),
        new assessment.LoadAssessmentEvidenceAction({
          type: 'Attachments',
          nodeId: theNode.id,
          assessmentId: theNode.assessmentId
        })
      ];
    });

  @Effect()
  effLoadAssessmentIssues$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT_ISSUES)
    .map((action: assessment.LoadAssessmentIssuesAction) =&gt; action.payload)
    .switchMap(multiRequest =&gt; {
      return this.assessmentsService
        .getAssessmentIssues(multiRequest.assessmentId, multiRequest.type, multiRequest.nodeId)
        .map(v =&gt; new assessment.LoadAssessmentIssuesCompleteAction(v));
    });

  @Effect()
  effLoadAssessmentEvidence$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT_EVIDENCE)
    .map((action: assessment.LoadAssessmentEvidenceAction) =&gt; action.payload)
    .switchMap(multiRequest =&gt; {
      return this.assessmentsService
        .getAssessmentEvidence(multiRequest.assessmentId, multiRequest.type, multiRequest.nodeId)
        .map(v =&gt; new assessment.LoadAssessmentEvidenceCompleteAction(v));
    });

  @Effect()
  effLoadAssessmentUser$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT_USER)
    .map((action: assessment.LoadAssessmentUserAction) =&gt; action.payload)
    .concatMap(guid =&gt; {
      return this.systemUserService.getSystemUser(guid)
        .map(v =&gt; new assessment.LoadAssessmentUserCompleteAction(v));
    });

  @Effect()
  effLoadAssessmentSurvey$: Observable&lt;Action&gt; = this.actions$
    .ofType(assessment.ActionTypes.LOAD_ASSESSMENT_SURVEY)
    .map((action: assessment.LoadAssessmentSurveyAction) =&gt; action.payload)
    .switchMap(guid =&gt; {
      return this.surveyService.getSurvey(guid)
        .map(v =&gt; new assessment.LoadAssessmentSurveyCompleteAction(v));
    });
}</code></pre>
</div>
</div>
</p>
","1034164","","1034164","","2017-02-21 16:46:15","2017-02-22 20:14:21","Angular2 NGRX Performance Issues On Dispatch?","<angular><rxjs><rxjs5><ngrx><ngrx-effects>","1","3","0","","","CC BY-SA 3.0"
"42355557","2","","42345753","2017-02-20 22:45:11","","1","","<p>I think you could do this with the <code>repeatWhen()</code> operator. You'll just need to use one extra <code>Subject</code> that tells it when you want to repeat the request:</p>

<pre><code>let subject = new Subject();

const response = {
  start_time: new Date(),
  end_time: new Date(),
  radio_show: {
    id: 0,
    name: ""Loading...""
  }
};

let radioShow$ = Observable.defer(() =&gt; {
    // return http.get(...);
    return Observable.of(response);
  })
  .do(() =&gt; console.log('create new HTTP request'))
  .repeatWhen(() =&gt; subject)
  .publishReplay()
  .refCount();

// responses
radioShow$
  .startWith(response)
  .subscribe(val =&gt; console.log('Response:', val));

// pooling delay
radioShow$
  .map(response =&gt; { // calculate the delay
    // return response.end_time - (new Date()).getTime();
    return Math.random() * 1000;
  })
  .concatMap(delay =&gt; Observable.of(null).delay(delay))
  .subscribe(subject);
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/kutabiw/6/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/kutabiw/6/edit?js,console</a></p>

<p>This makes random 0-3s delays between each call to simulate where you'd normally calculate the delay.</p>
","310726","","310726","","2017-02-21 18:05:14","2017-02-21 18:05:14","","","","6","","","","CC BY-SA 3.0"
"42367561","1","43004667","","2017-02-21 12:37:14","","-1","313","<p>I've been stuck with a rxjs problem for days now. I use rxjs with REACT and trying to get to a stream of property changes to run an asynchronous function to fast-forward / rewind a player. Then to further await any function calls until the callback returns. If any property changes happened in the stream while waiting for the callback just execute the last of it. To then repeat the process.</p>

<p>Here is an example code below.
<a href=""http://jsbin.com/jagoworawu/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/jagoworawu/edit?js,console</a></p>

<pre class=""lang-js prettyprint-override""><code>const setCurrentTimeStream = Observable.bindNodeCallback(player.setCurrentTime);

// Instant execute setCurrentTimeStream on first iteration.
// Prevent next setCurrentTimeStream if not callback of previous setCurrentTimeStream was called.
// Skip all except last while waiting for setCurrentTimeStream callback and then execute it.
// Then repeat the process.
const lifecycle$ = props$
  .distinctUntilKeyChanged('currentTime')
  // tried with audit and throttle but it won't execute the last one
  .audit(({ currentTime }) =&gt; setCurrentTimeStream(currentTime));
  // Probably needs something more here?
</code></pre>

<p><strong>EDIT</strong>:
After reading some documentation I came up with this. Please come with feedback or other solution preferably with native method from rxjs.</p>

<pre class=""lang-js prettyprint-override""><code>const latestExecAsync = (input, action) =&gt; Observable.create((observer) =&gt; {
  let queued = false;
  let latestValue;
  const dequeue = (reference) =&gt; {
    queued = true;
    action(reference.value, (error, value) =&gt; {
      if (error) return output.error(error);
      observer.next(reference.value);
      if (reference !== latestValue) {
        dequeue(latestValue);
      } else {
        queued = false;
      }
    });
  };
  const subscription = input.subscribe({
    next: (value) =&gt; {
      const reference = latestValue = { value };
      if (!queued) dequeue(reference);
    },
    error: e =&gt; observer.error(e),
    complete: () =&gt; observer.complete(),
  });
  return () =&gt; subscription.unsubscribe();
});

// Usage:
latestExecAync(
  props$.distinctUntilKeyChanged('currentTime'),
  ({ currentTime }, cb) =&gt; player.setCurrentTime(currentTime, cb)
)
</code></pre>
","7598072","","7598072","","2017-02-23 11:49:22","2017-03-24 16:31:35","How to continuously execute an async function not in parallel with only the latest from the stream","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42370097","1","42370362","","2017-02-21 14:29:37","","1","1358","<p>I'm very new to RxJS and here's my story. I want a ""session"" observable so new subscribers will always get current session and then all new sessions if they can appear. So I wrote something like this:</p>

<pre><code>var session = Rx.Observable.from([0,1,3])
  .do(x =&gt; console.log(""Useful job""))
  .publishReplay(1)
  .refCount();

var subscr1 = session.subscribe( x =&gt; {
    console.log(""sub1 = "" +x)
    //subscr1.unsubscribe();
})

console.log(""Completed"");
subscr1.unsubscribe();

session.subscribe( x =&gt; {
  console.log(""sub2 = "" +x)
});
</code></pre>

<p>And the output is:</p>

<pre><code>Useful job
sub1 = 0
Useful job
sub1 = 1
Useful job
sub1 = 3
Completed
sub2 = 3
</code></pre>

<p>Why there's no useful job when sub2 subscribes? I expect it to be completely cold!</p>
","2794542","","2794542","","2017-02-21 15:17:50","2017-02-21 15:44:56","How to force publishReplay() to resubscribe?","<rxjs><reactive-programming><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42370362","2","","42370097","2017-02-21 14:40:35","","1","","<p>The first parameter to <code>.publishReplay()</code> is the number of items it'll replay so you could use <code>.publishReplay(3)</code> if you know you can always expect only 3.</p>

<p>If you want to replay the entire sequence you could first collect all its items with <code>toArray()</code>, store the array in the <code>ReplaySubject</code> and then just flatten the array to individual values.</p>

<pre><code>var session = Rx.Observable.from([0,1,3])
  .toArray()
  .publishReplay(1)
  .refCount()
  .concatAll();
</code></pre>

<p>Note that <code>toArray()</code> doesn't emit anything until its source completes.</p>

<p>EDIT: I see what's the problem now.</p>

<p>Your approach is correct but the problem is in the <code>Observable.from</code> and the Subject used inside <code>publishReplay()</code>. The source Observable emits three items and send <code>complete</code> notification. When the Subject receives a <code>complete</code> or <code>error</code> notification it marks itself as <code>stopped</code> and won't reemit any items any more. And this is exactly what happens in your example.</p>

<p>If you emit values manually without sending <code>complete</code> it'll work as you expected.</p>

<pre><code>// var session = Rx.Observable.from([0,1,3])
var session = Rx.Observable.create(subscriber =&gt; {
    subscriber.next(0);
    subscriber.next(1);
    subscriber.next(3);
  })
  .do(x =&gt; console.log(""Useful job""))
  .publishReplay(1)
  .refCount();
</code></pre>

<p>This prints to console:</p>

<pre><code>Useful job
sub1 = 0
Useful job
sub1 = 1
Useful job
sub1 = 3
Completed
sub2 = 3
Useful job
sub2 = 0
Useful job
sub2 = 1
Useful job
sub2 = 3
</code></pre>

<p>See the same problem: <a href=""https://stackoverflow.com/questions/41786396/rx-subject-loses-events/41789882"">Rx.Subject loses events</a></p>
","310726","","-1","","2017-05-23 10:29:49","2017-02-21 15:37:44","","","","8","","","","CC BY-SA 3.0"
"42377993","1","42378625","","2017-02-21 21:06:41","","4","1729","<p>I wrote a function to do polling on an API that is also able to do pagination. Herefor the pagination is done using a Subject Observable and polling is done with the timer method (I also tried interval with the same result).</p>

<p>Here is my code:</p>

<pre><code>  getItems(pagination: Subject&lt;Pagination&gt;): Observable&lt;ListResult&lt;Item&gt;&gt; {
    let params: URLSearchParams = new URLSearchParams();

    return Observable
      .timer(0, 5000)
      .combineLatest(
        pagination,
        (timer, pagination) =&gt; pagination
      )
      .startWith({offset: 0, limit: 3})
      .switchMap(pagination =&gt; {
        params.set('skip', pagination.offset.toString());
        params.set('limit', pagination.limit.toString());
        return this.authHttp.get(`${environment.apiBase}/items`, {search: params})
      })
      .map(response =&gt; response.json() as ListResult&lt;Item&gt;)
      .catch(this.handleError);
  }
</code></pre>

<p>The expected behavior would be:
HTTP request is fired every 5 seconds AND when the user changes the page.</p>

<p>This is what happens:
First HTTP request is fired, but then no other request is sent to the server UNTIL pagination is used. 
After pagination is used the first time, the polling starts working too.</p>

<p>It's the first time I'm using Observables so I'm pretty sure I missed something, but I can't see what it might be.</p>

<p>I also tried this approach (maybe it was missing the timer counter in startWith), but it didn't change anything.</p>

<pre><code>[...]
  .combineLatest(
    pagination
  )
  .startWith([0, {offset: 0, limit: 3}])
[...]
</code></pre>
","848563","","310726","","2017-02-21 21:51:52","2017-02-21 21:51:52","RxJS Observable with Subject, polling via timer and combineLatest does not fire","<angular><typescript><rxjs><polling><rxjs5>","2","2","","","","CC BY-SA 3.0"
"42378625","2","","42377993","2017-02-21 21:47:24","","2","","<p>The <code>combineLatest()</code> operator requires all source Observables to emit at least one item.</p>

<p>Your demo makes only one request because you're using <code>.startWith()</code>. The <code>combineLatest()</code> never emits because the <code>pagination</code> is a <code>Subject</code> and it probably never emits any item.</p>

<p>So one option is to move <code>.startWith()</code>:</p>

<pre><code>.combineLatest(
  pagination.startWith({offset: 0, limit: 3}),
  (timer, pagination) =&gt; pagination
)
</code></pre>

<p>But maybe this doesn't help you much because you're ignoring all items coming from the <code>timer()</code> and you're using just <code>pagination</code>. So maybe you could use just <code>merge()</code> to refresh the list from one of the sources. Then the <code>timer()</code> independently increases the offset.</p>

<pre><code>Observable
  .timer(0, 1000)
  .map(i =&gt; { return {offset: i*3, limit: 3}})
  .merge(pagination.startWith({offset: 0, limit: 3}))
  .switchMap(pagination =&gt; {
    return Observable.of(pagination).delay(200)
  })
  .subscribe(val =&gt; console.log(val));
</code></pre>
","310726","","","","","2017-02-21 21:47:24","","","","1","","","","CC BY-SA 3.0"
"42390586","1","42391338","","2017-02-22 11:50:42","","2","3728","<p>I try to fetch data from 3 different REST end points. The data model consists of main data and has advanced Array with 2(might be more in the future) Objects. I want to inject an Array with options into each of advanced Objects, based on REST endpoint specified in each of them. Everything works and is returned from Observable as Object, except appended options, that come as Observables.</p>

<p>Simplified data:</p>

<pre><code>{
 simple: {
   param: ""searchQuery"",
 },
 advanced: [
  {
   param: ""food"",
   optionsModel: {
     url: ""http://address.com/food"",      
     }
  },
  {
   param: ""drinks"",
   optionsModel: {
     url: ""http://address.com/drinks"",
     }
   }
  ]
}
</code></pre>

<p>food and drinks have the same structure consisting of Objects with name and id:</p>

<pre><code> {
  data: [
   {
     name: ""DR1"",
     id: 1
   },
   {
     name: ""DR2"",
     id: 1
   },
   ...
  ]
 }
</code></pre>

<p>In my data model I don't have options[] array, so I inject it manually. Service:</p>

<pre><code> searchConfiguration$: Observable&lt;SearchConfiguration&gt; = this.http
  .get(this._configURL)
  .map((config) =&gt; {
      let configuration = config.json();
      let advancedArray = configuration.advanced;

      if(advancedArray) {
        advancedArray.forEach(advanced =&gt; {
          advanced.options = [];
          advanced.options = this.http.get(advanced.optionsModel.url)
             .map((r: Response) =&gt; r.json().data
        })
      }
    return configuration;
  })
</code></pre>

<p>Parent component:</p>

<pre><code>getSearchConfig() {
  this.searchConfiguration$ = this._bundlesService.searchConfiguration$;
} 
</code></pre>

<p>Then I have async pipe in the html to subscribe to Observable. How can I get my options appended to advanced as actual Arrays and not as a stream?</p>

<p><strong>Edit - Solution</strong></p>

<p>Thanks to martin's answer, the solution is to flatten both streams and connect them in the end with forkJoin()</p>

<pre><code>  searchConfiguration$: Observable&lt;SearchConfiguration&gt; = this.http
  .get(this._configURL)
  .map((config) =&gt; config.json())
  .concatMap((configuration) =&gt; {
      let observables = configuration.advanced.map((advanced) =&gt; {
        return this.http.get(advanced.optionsModel.url)
          .map((r: Response) =&gt;  r.json().data)
          .concatMap((options) =&gt; advanced.options = options)
      });
    return Observable.forkJoin(observables, (...options) =&gt; {
      return configuration;
    })
  });
</code></pre>
","7603425","","7603425","","2017-02-22 13:53:28","2017-02-22 13:53:28","Return object from observable inside another observable","<javascript><angular><rxjs><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42391338","2","","42390586","2017-02-22 12:20:39","","2","","<p>I didn't test it but I think you could you something as follows:</p>

<pre><code>searchConfiguration$: Observable&lt;SearchConfiguration&gt; = this.http
  .get(this._configURL)
  .map((config) =&gt; config.json())
  .concatMap(configuration =&gt; {
    var observables = configuration.advanced.map(advanced =&gt; {
      return this.http.get(advanced.optionsModel.url)
         .map((r: Response) =&gt; r.json().data);
    });

    return Observable.forkJoin(observables, (...options) =&gt; {
      configuration.options = options;
      return configuration;
    });
  })
</code></pre>
","310726","","310726","","2017-02-22 13:10:57","2017-02-22 13:10:57","","","","3","","","","CC BY-SA 3.0"
"42400213","1","42402333","","2017-02-22 19:08:11","","1","69","<p>In a template, I set an async pipe for a Observable with.</p>

<pre><code>*ngFor=""let checkIn of checkIns | async""
</code></pre>

<p>In the component, <code>this.checkIns = this.service.getCheckIns()</code>.</p>

<p>In the service, I got:</p>

<pre><code>getCheckIns(): Observable&lt;any&gt; {
  return new Observable((observer) =&gt; {
    observer.next(...)
  }
}
</code></pre>

<p>I notice if I swap out <code>new Observable()</code> with <code>Observable.create()</code>, there's no difference:</p>

<pre><code>getCheckIns(): Observable&lt;any&gt; {
  return Observable.create((observer) =&gt; {
    observer.next(...)
  }
}
</code></pre>
","6174577","","310726","","2017-02-22 21:10:21","2017-02-22 21:10:21","RXJS, What's the difference between Observable.create and new Observable?","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42401365","2","","42354606","2017-02-22 20:14:21","","12","","<p>The slowdown was actually related to the <code>@ngrx/store-devtools</code>. After I removed the module from the application the speed was phenomenal. We were hoping to use the tooling for snapshotting and replaying state, but I'm not sure we can go down that route anymore with the performance hit.</p>
","1034164","","","","","2017-02-22 20:14:21","","","","3","","","","CC BY-SA 3.0"
"42402333","2","","42400213","2017-02-22 21:10:01","","2","","<p>This is correct, these two are synonymous. </p>

<p>See source code: <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts#L56"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts#L56</a></p>

<p>The static method <code>Observable.create(...)</code> just calls <code>new Observable(...)</code> under the hood.</p>
","310726","","","","","2017-02-22 21:10:01","","","","0","","","","CC BY-SA 3.0"
"42404005","1","42404234","","2017-02-22 23:07:30","","0","67","<p>Currently, functions isEven and isOdd are called for each IF. Is there a way that the functions are called only when the evaluation of the IF correspond to the logic path of the function?</p>

<p>Example: reference of JSBin: <a href=""http://jsbin.com/wegesaweti/1/edit?html,js,output"" rel=""nofollow noreferrer"">http://jsbin.com/wegesaweti/1/edit?html,js,output</a>)</p>

<pre><code>var isEven = function(x) {
  console.log('function isEven called')
  return Rx.Observable.return(x + ' is even');
};    
var isOdd = function(x) {
  console.log('function isOdd called')
  return Rx.Observable.return(x + ' is odd');
};
var source = Rx.Observable.range(1,4)
  .flatMap((x) =&gt; Rx.Observable.if(
    function() { return x % 2; },
    isOdd(x),
    isEven(x)
));    
var subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    });
</code></pre>

<p>Current output:</p>

<pre><code>function isOdd called
function isEven called
Next: 1 is odd
function isOdd called
function isEven called
Next: 2 is even
function isOdd called
function isEven called
Next: 3 is odd
function isOdd called
function isEven called
Next: 4 is even
</code></pre>

<p>Expected output</p>

<pre><code>function isOdd called
Next: 1 is odd
function isEven called
Next: 2 is even
function isOdd called
Next: 3 is odd
function isEven called
Next: 4 is even
</code></pre>

<p>Thank you!</p>
","1750346","","","","","2017-02-22 23:25:35","How to use Observable.If without calling functions","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"42404234","2","","42404005","2017-02-22 23:25:35","","1","","<p>Base on the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/if.md"" rel=""nofollow noreferrer"">RXJS docuemntation</a> the <code>thenSource</code> and <code>elseSource</code> need to be <code>Observable</code> (or <code>Scheduler</code> for <code>elseSource</code>).</p>

<p>An alternative for your problem:</p>

<pre><code>var source = Rx.Observable.range(1,4).flatMap((x) =&gt; 
    (x % 2) == 1 ? isOdd(x) : isEven(x)
);
</code></pre>

<p>Working example: <a href=""http://jsbin.com/godubemano/1/edit?html,js,output"" rel=""nofollow noreferrer"">http://jsbin.com/godubemano/1/edit?html,js,output</a></p>
","3682091","","","","","2017-02-22 23:25:35","","","","0","","","","CC BY-SA 3.0"
"42434732","1","","","2017-02-24 09:11:43","","10","5056","<p>The code</p>

<pre><code>const a = new Rx.Subject().do(x =&gt; console.log('a'))
const b = a.mapTo(0)
const c = a.mapTo(1)
const d = Rx.Observable.merge(b, c)
d.subscribe(x =&gt; console.log('d'))
a.next(3)
</code></pre>

<p>And the output</p>

<pre><code>a
d
a
d
</code></pre>

<p>Why does a got printed twice? Isn't Rx.Subject a hot observable?</p>
","4047380","","","","","2019-05-02 06:33:25","Is Rx.Subject a hot observable?","<rxjs><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"42439144","1","","","2017-02-24 12:51:36","","0","247","<p>We're working on a project where we are creating an event processor using RxJS. We have a few 'rules', so to speak, where input is provided from a few different source and output has to be generated based on the number of times an input is above a set value (simple rule). </p>

<p>Now, all this works without any problems, but we want to move the project from beta to production. This means running multiple instances of Node.JS with RxJS on top of it. </p>

<p>We're wondering if it's possible for RxJS to share its memory using Redis for example. This way when one of the instances dies for whatever reason, another one can pick up where the dead one stopped. Ensuring that the amount of times the value was above the set value is retained.</p>

<p>This would also allow us to spread the load over multiple instances if the 'rules' get more complex and the amount of data increases.</p>

<p>Is something like this possible with RxJS, or should we build our own administration around it?</p>
","1662532","","","","","2017-03-09 01:13:30","RxJS share memory across node.js instances using Redis","<javascript><node.js><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42461969","1","","","2017-02-25 21:46:00","","1","122","<p>If i use a range and limit the output with takeWhile:</p>

<pre><code>Rx.Observable
    .range( 1, 10 )
    .do( idx =&gt; console.log('range: ', idx ))
    .takeWhile( idx =&gt; idx &lt;= 5 )
    .subscribe( idx =&gt; console.log( 'res   : ', idx ))
    ;
</code></pre>

<p>the output is:</p>

<pre><code>range:  1
res   :  1
range:  2
res   :  2
range:  3
res   :  3
range:  4
res   :  4
range:  5
res   :  5
range:  6
</code></pre>

<p>the produces values by range are not all consumed. 6 is pulled, does not pass the takeWhile, no more values are taken.</p>

<p>Now if i have a concatMap in between:</p>

<pre><code>Rx.Observable
    .range( 1, 10 )
    .do( idx =&gt; console.log('range: ', idx ))
    .concatMap( idx =&gt; {
        var res = new Rx.Subject&lt;number&gt;();
        setTimeout( () =&gt; {
            res.next( idx );
            res.complete();
        }, 10 );
        return res;
    })
    .takeWhile( idx =&gt; idx &lt;= 5 )
    .subscribe( idx =&gt; console.log( 'res:   ', idx ))
    ;
</code></pre>

<p>The output is this:</p>

<pre><code>range:  1
range:  2
range:  3
range:  4
range:  5
range:  6
range:  7
range:  8
range:  9
range:  10
res:    1
res:    2
res:    3
res:    4
res:    5
</code></pre>

<p>I would expect, that the values from range production would be limited here as well. concatMap preserves the order, so it makes only sense to pull the next value, when the previous observable is completed. But all range errors are pulled.<br>
Is this a bug? Or what is the real behavior. Can you please help to understand.</p>
","2436083","","310726","","2017-02-26 08:11:03","2017-02-26 08:11:03","RXJS concatMap should also lazy pull?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42482705","1","42482824","","2017-02-27 09:59:14","","57","43792","<p>My backend frequently returns data as an <em>array inside an RxJS 5 Observable</em> (I'm using Angular 2).</p>

<p>I often find myself wanting to <strong>process the array items individually with RxJS operators</strong> and I do so with the following code (<a href=""http://jsbin.com/quqofe/edit?js,console"" rel=""noreferrer"">JSBin</a>):</p>

<pre class=""lang-ts prettyprint-override""><code>const dataFromBackend = Rx.Observable.of([
  { name: 'item1', active: true },
  { name: 'item2', active: false },
  { name: 'item3', active: true }
]);

dataFromBackend
  // At this point, the obs emits a SINGLE array of items
  .do(items =&gt; console.log(items))
  // I flatten the array so that the obs emits each item INDIVIDUALLY
  .mergeMap(val =&gt; val)
  // At this point, the obs emits each item individually
  .do(item =&gt; console.log(item))
  // I can keep transforming each item using RxJS operators.
  // Most likely, I will project the item into another obs with mergeMap()
  .map(item =&gt; item.name)
  // When I'm done transforming the items, I gather them in a single array again
  .toArray()
  .subscribe();
</code></pre>

<p>The <code>mergeMap(val =&gt; val)</code> line doesn't feel very idiomatic.</p>

<p>Is there a better way to apply transformations to the members of an array that's emitted by an Observable?</p>

<p>NB. I want RxJS operators (vs array methods) to transform my items because I need the ability to project each item into a second observable. Typical use case: backend returns of list of item ids and I need to request all of these items from the backend.</p>
","1153681","","310726","","2018-03-06 17:23:47","2020-05-14 08:34:14","Best way to ""flatten"" an array inside an RxJS Observable","<angular><rxjs><rxjs5>","5","1","11","","","CC BY-SA 3.0"
"42482824","2","","42482705","2017-02-27 10:04:51","","62","","<p>You can use <code>concatAll()</code> or <code>mergeAll()</code> without any parameter.</p>

<pre><code>dataFromBackend.pipe(
  tap(items =&gt; console.log(items)),
  mergeAll(), // or concatAll()
)
</code></pre>

<p>This (including <code>mergeMap</code>) works only in RxJS 5 because it treats Observables, arrays, array-like objects, Promises, etc. the same way.</p>

<p>Eventually you could do also:</p>

<pre><code>mergeMap(val =&gt; from(val).pipe(
  tap(item =&gt; console.log(item)),
  map(item =&gt; item.name),
)),
toArray(),
</code></pre>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-13 10:09:25","2019-01-13 10:09:25","","","","3","","","","CC BY-SA 4.0"
"42490265","1","42490431","","2017-02-27 16:01:18","","60","52155","<p><em>tl;dr: Basically I want to marry Angular's <code>ngOnDestroy</code> with the Rxjs <code>takeUntil()</code> operator. -- is that possible?</em></p>

<p>I have an Angular component that opens several Rxjs subscriptions.
These need to be closed when the component is destroyed.</p>

<p>A simple solution for this would be:</p>

<pre><code>class myComponent {

  private subscriptionA;
  private subscriptionB;
  private subscriptionC;

  constructor(
    private serviceA: ServiceA,
    private serviceB: ServiceB,
    private serviceC: ServiceC) {}

  ngOnInit() {
    this.subscriptionA = this.serviceA.subscribe(...);
    this.subscriptionB = this.serviceB.subscribe(...);
    this.subscriptionC = this.serviceC.subscribe(...);
  }

  ngOnDestroy() {
    this.subscriptionA.unsubscribe();
    this.subscriptionB.unsubscribe();
    this.subscriptionC.unsubscribe();
  }

}
</code></pre>

<p>This works, but it's a bit redundant. I especially don't like that
- The <code>unsubscribe()</code> is somewhere else, so you gotta remember that these are linked.
- The component state is polluted with the subscription.</p>

<p>I would much prefer using the <code>takeUntil()</code> operator or something similar, to make it look like this:</p>

<pre><code>class myComponent {

  constructor(
    private serviceA: ServiceA,
    private serviceB: ServiceB,
    private serviceC: ServiceC) {}

  ngOnInit() {
    const destroy = Observable.fromEvent(???).first();
    this.subscriptionA = this.serviceA.subscribe(...).takeUntil(destroy);
    this.subscriptionB = this.serviceB.subscribe(...).takeUntil(destroy);
    this.subscriptionC = this.serviceC.subscribe(...).takeUntil(destroy);
  }

}
</code></pre>

<p>Is there a destroy event or something similar that would let me use <code>takeUntil()</code> or another way to simplify the component architecture like that?
I realize I could create an event myself in the constructor or something that gets triggered within <code>ngOnDestroy()</code> but that would in the end not make things that much simpler to read.</p>
","78967","","2370262","","2017-05-18 17:56:04","2020-01-21 05:22:30","RxJS: takeUntil() Angular component's ngOnDestroy()","<angular><components><rxjs><rxjs5>","5","0","22","","","CC BY-SA 3.0"
"42490431","2","","42490265","2017-02-27 16:08:50","","81","","<p>You could leverage a <code>ReplaySubject</code> for that:</p>

<p><strong>EDIT:</strong> Different since RxJS 6.x:
Note the use of the <code>pipe()</code> method.</p>

<pre><code>class myComponent {
  private destroyed$: ReplaySubject&lt;boolean&gt; = new ReplaySubject(1);

  constructor(
    private serviceA: ServiceA,
    private serviceB: ServiceB,
    private serviceC: ServiceC) {}

  ngOnInit() {
    this.serviceA
      .pipe(takeUntil(this.destroyed$))
      .subscribe(...);
    this.serviceB
      .pipe(takeUntil(this.destroyed$))
      .subscribe(...);
    this.serviceC
      .pipe(takeUntil(this.destroyed$))
      .subscribe(...);
  }

  ngOnDestroy() {
    this.destroyed$.next(true);
    this.destroyed$.complete();
  }
}
</code></pre>

<p>This is only valid for RxJS 5.x and older:</p>

<pre><code>class myComponentOld {
  private destroyed$: ReplaySubject&lt;boolean&gt; = new ReplaySubject(1);

  constructor(private serviceA: ServiceA) {}

  ngOnInit() {
    this.serviceA
      .takeUntil(this.destroyed$)
      .subscribe(...);
  }

  ngOnDestroy() {
    this.destroyed$.next(true);
    this.destroyed$.complete();
  }
}
</code></pre>
","1518765","","2948844","","2019-04-15 19:44:00","2019-04-15 19:44:00","","","","5","","","","CC BY-SA 4.0"
"42520478","1","42520927","","2017-02-28 23:11:24","","4","3513","<p>I need to retry a sequence of RxJS observables and throw the error object of the item in the sequence if the collection is not successful after 3 attempts.  I found this example (<a href=""https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/error_handling.html"" rel=""nofollow noreferrer"">An incremental back-off strategy for handling errors</a>): </p>

<pre><code>var source = get('url').retryWhen(
attempts =&gt;
attempts
  .zip(Observable.range(1, 3), (_, i) =&gt; i)
  .flatMap(i =&gt; {
    console.log('delay retry by ' + i + ' second(s)');
    return Rx.Observable.timer(i * 1000);
  });
);

var subscription = source.subscribe(
data =&gt; {
// Displays the data from the URL or cached data
console.log(data);
});
</code></pre>

<p>How do you throw the error belonging to the item in the collection?  The above code seems to swallow the error as opposed to surfacing it to the caller to handle.</p>
","418549","","1518765","","2017-03-01 00:02:43","2017-03-01 00:02:43","how do you throw an error from RXJS Observable retryWhen","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42520927","2","","42520478","2017-03-01 00:00:02","","5","","<p>In your stream you basically just stripped away the error and solely considered the <em>count</em> by using this selector-function in your <code>zip</code>: <code>(_, i) =&gt; i</code> - where <code>_</code> would be the error.</p>

<p>I've adjusted your stream and removed the selector-function, which is not really needed here - now it will retry 3 times and then throw the error if it fails again.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const source = Rx.Observable.create(o =&gt; {
    o.error(new Error(""always fails""));
  })
  .retryWhen(attempts =&gt; attempts
    .zip(Rx.Observable.range(1, 4))
    .flatMap(([error, i]) =&gt; {
      if (i &gt; 3) {
        return Rx.Observable.throw(error);
      }
      console.log('delay retry by ' + i + ' second(s)');
      return Rx.Observable.timer(i * 100);
    })
  );

source.subscribe(
  data =&gt; console.log(data),
  error =&gt; console.error(error)
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","","","","2017-03-01 00:00:02","","","","0","","","","CC BY-SA 3.0"
"42541244","1","42541471","","2017-03-01 20:18:27","","0","179","<p>I have two observables and I want just one value from each. In case the <code>observable2</code> pushes a value first I would like to wait and keep the received value until <code>observable1</code> pushes a value and push kept value then. Basicaly the same behaviour as with <code>skipUntil</code> with the difference that I don't want to discard the value. I guess it I could do it by concatting the observables but I would like to keep them separate.</p>

<pre><code>observable1
  .take(1)
  .subscribe(doSomething)

observable2
  .take(1)
  // .skipUntil(observable1)
  .waitUntil(observable1) // Something like this
  .subscribe(doSomethingElse)
</code></pre>
","2520530","","1264804","","2017-03-01 20:29:12","2017-03-01 20:30:39","Wait and accumulate values until other observable fires","<javascript><rxjs><rxjs5><reactivex>","1","1","1","","","CC BY-SA 3.0"
"42541471","2","","42541244","2017-03-01 20:30:39","","1","","<p>This will wait for observable1 to push and then switches to observable2:</p>

<pre><code>observable1.switchMap(() =&gt; observable2)
           .take(1)
           .subscribe(doSomethingElse);
</code></pre>

<p>If you want observable1 to only fire once (for example if you subscribe to it somewhere else like in your example), consider using <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/share.md"" rel=""nofollow noreferrer""><code>.share()</code></a>.</p>
","554340","","","","","2017-03-01 20:30:39","","","","1","","","","CC BY-SA 3.0"
"42549136","1","42550407","","2017-03-02 07:23:28","","0","337","<p>In my store a have queue containing pending network requests.
When the action <code>ATTEMPT_FLUSH</code> is emmited, I want to <em>sequentially</em> send the requests. 
However if one of them fails and emits <code>ATTEMPT_FLUSH_CANCELLED</code>, the next ones should not be attempted (until I try again in the next <code>ATTEMPT_FLUSH</code>, of course).</p>

<p>Here's what I have so far</p>

<pre><code>export const attemptFlushEpic = (action$, store) =&gt;
  action$
    .ofType(ATTEMPT_FLUSH)
    .mergeMap(() =&gt; Observable.from(store.getState().queue)) // state.queue is an array
    .concatMap(action =&gt;
        Observable.ajax(action.url)
        .map(response =&gt; removeFromQueue(action))
        .catch(err =&gt; Observable.of(attemptFlushCancelled())));
</code></pre>
","1978520","","1978520","","2017-03-02 18:48:01","2017-03-02 18:48:01","Cancel sequence of ajax calls when one fails","<rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"42550407","2","","42549136","2017-03-02 08:35:02","","2","","<p>Moving up the actual ajax call should cancel the subsequent ajax on failure.     </p>

<pre><code>export const attemptFlushEpic = (action$, store) =&gt;
  action$
    .ofType(ATTEMPT_FLUSH)
    .mergeMap(() =&gt; Observable.from(store.getState().queue)
      .concatMap(action =&gt; Observable.ajax(action.url)
        .map(response =&gt; removeFromQueue(action)))
      .catch(err =&gt; Observable.of(attemptFlushCancelled())))
    );
</code></pre>
","2218722","","","","","2017-03-02 08:35:02","","","","0","","","","CC BY-SA 3.0"
"42567039","1","42567477","","2017-03-02 22:14:47","","1","1511","<p>My app uses ngrx and ngrx effects. Here is one of my app effects:</p>

<pre><code>  @Effect()
  reloadPersonalInfo$: Observable&lt;Action&gt; = this.actions$
    .ofType(currentUserAccount.ActionTypes.RELOAD_PERSONAL_INFO)
    .filter(() =&gt; &lt;boolean&gt;JSON.parse(localStorage.getItem('authenticated')))
    .switchMap(() =&gt;
      this.userAccountService
        .retrieveCurrentUserAccount()
        .map(currentUserAccount =&gt; new LoadUserAccountAction(currentUserAccount))
        .map(() =&gt; new SigninAction())
    );
</code></pre>

<p>I am wondering why the <code>LoadUserAccountAction</code> does not enter my reducer function except if I comment out <code>//.map(() =&gt; new SigninAction())</code></p>

<p>Can anyone please help? What I am getting wrong?</p>
","536299","","1910355","","2017-03-07 21:59:22","2017-03-07 21:59:22","Chaining RxJS map operators and ngrx effects Issue","<rxjs><rxjs5><ngrx><ngrx-effects>","1","4","","","","CC BY-SA 3.0"
"42567283","1","42569622","","2017-03-02 22:33:17","","1","1319","<pre><code> export const getSomethingEpic = action$ =&gt;
  action$
    .ofType(GET_SOMETHING)
    .switchMap(action =&gt;
      ajax('url/api/something')
        .map((json) =&gt; {
          return getSomethingEndAct(json.response);
        })
        .takeUntil(action$.ofType('@@router/LOCATION_CHANGE'))
    );
</code></pre>

<p>The situation is this:</p>

<p>page A has a react router Link to page B, on page B componentDidMount I dispatch getSomething action. Ajax can be cancelled perfectly. However, if page B loaded and the ajax finished, we route to page C from page B, and then use the browser back button to route to page B again, action getSomething will be dispatched in componentDidMount again, but this time the ajax is cancelled.</p>

<p>I don't understand why the ajax is being cancelled since location change is prior to getSomething action.
Or what should I do to cancel ajax when route changed?</p>

<p>I tried to build an example, but I could not get react-router-redux to sync browser history. here is <a href=""http://jsbin.com/dewixurece/edit?js,console,output"" rel=""nofollow noreferrer"">http://jsbin.com/dewixurece/edit?js,console,output</a> 
it would be working if use hashHistory, but there will be two location change actions, which should be one instead and I don't know why.</p>

<p>it is a great lib and I really like RX programming idea, but still learning and hope we could have more examples. thanks if anyone can help.</p>
","7650257","","7650257","","2017-03-03 02:02:32","2017-03-03 02:35:35","How to cancel ajax when route changing using react router","<react-router><rxjs><rxjs5><react-router-redux><redux-observable>","1","4","1","","","CC BY-SA 3.0"
"42567477","2","","42567039","2017-03-02 22:48:18","","4","","

<p>Your <code>LoadUserAccountAction</code> is not dispatched because it's not emitted by the effect, as the final <code>.map(() =&gt; new SigninAction())</code> is seeing the <code>SigninAction</code> emitted instead.</p>

<p>It is possible to emit multiple actions from an effect, you'd just need to do it like this:</p>

<pre class=""lang-js prettyprint-override""><code>@Effect()
reloadPersonalInfo$: Observable&lt;Action&gt; = this.actions$
  .ofType(currentUserAccount.ActionTypes.RELOAD_PERSONAL_INFO)
  .filter(() =&gt; &lt;boolean&gt;JSON.parse(localStorage.getItem('authenticated')))
  .switchMap(() =&gt; this.userAccountService
    .retrieveCurrentUserAccount()
    .concatMap(currentUserAccount =&gt; [
      new LoadUserAccountAction(currentUserAccount),
      new SigninAction()
    ])
  );
</code></pre>

<p>The <code>concatMap</code> operator will flatten the array that contains the two actions so that both actions are emitted - in the order in which they are declared in the array.</p>
","6680611","","","","","2017-03-02 22:48:18","","","","0","","","","CC BY-SA 3.0"
"42569622","2","","42567283","2017-03-03 02:35:35","","1","","<p>(based on our discussion in the comments)</p>

<p>If you want to start a request when you enter a route, but cancel it if you leave that route before it's finished, you would dispatch the start action in <code>componentDidMount</code> and the cancellation action in <code>componentWillUnmount</code></p>

<pre><code>const getSomethingEpic = action$ =&gt;
  action$.ofType('GET_SOMETHING')
    .switchMap(action =&gt;
      ajax('url/api/something')
        .map((json) =&gt; {
          return getSomethingEndAct(json.response);
        })
        .takeUntil(action$.ofType('GET_SOMETHING_CANCELLED'))
    );

class B extends Component {
  componentDidMount() {
    store.dispatch({
      type: 'GET_SOMETHING'
    });
  }

  componentWillUnmount() {
    store.dispatch({
      type: 'GET_SOMETHING_CANCELLED'
    });
  }

  render() {
    return (
      &lt;h1&gt;B route&lt;/h1&gt;
    );
  }
}
</code></pre>

<p>Demo: <a href=""http://jsbin.com/zomire/edit?js,output"" rel=""nofollow noreferrer"">http://jsbin.com/zomire/edit?js,output</a></p>

<p>For simplicity sake, I just used <code>store.dispatch</code> directly. Use action creators and/or <code>connect()</code> in your real app, if you prefer that.</p>

<p>Dispatching the cancellation action, even if the ajax request has already completed isn't usually a problem--but if it is or you prefer to only dispatch it if it's truly needed, you'll need to store some sort of state you can use to know whether or not the request is still pending. You can store this state either as local component state or in the redux store.</p>
","1770633","","","","","2017-03-03 02:35:35","","","","0","","","","CC BY-SA 3.0"
"42570278","1","42570484","","2017-03-03 03:46:34","","2","186","<p>I am starting with an inner Observable from Angular's <code>route.params</code>.</p>

<p>I would like to be able to retain the values from the params 'beyond' the higher order observable <code>switchMap</code>, which in my cases performs an http call.</p>

<p>For instance:</p>

<pre><code>this.data$ = this.route.params
    .switchMap(params =&gt; this.http.get('/api', { param1: params.param1, param2: params.param2 }))
    .map(([params, data]) =&gt; {
        //possible to get params AND data here? This returns undefined.
        return something
    })
</code></pre>

<p>Is it possible to have access to the params after the switchMap?</p>
","2275792","","","","","2017-05-07 03:37:13","Angular & RxJS5 - Retain values from inner Observable beyond a higher order Observable","<angular><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42570484","2","","42570278","2017-03-03 04:07:12","","2","","<p>You could use forkJoin: </p>

<pre><code>this.data$ = this.route.params
    .switchMap(params =&gt;  
         Observable.forkJoin([
             Observable.of(params),
             this.http.get('/api', { param1: params.param1, param2: params.param2 })
    ])
    .map(([params, data]) =&gt; {

         return something
    })
</code></pre>
","3661630","","3661630","","2017-03-03 04:15:43","2017-03-03 04:15:43","","","","1","","","","CC BY-SA 3.0"
"42574558","2","","38025123","2017-03-03 09:00:34","","21","","<p>I had the same question when reading <a href=""http://reactivex.io/rxjs/manual/overview.html"" rel=""noreferrer"">http://reactivex.io/rxjs/manual/overview.html</a>. So to make it clear, <code>.publish()</code> is just shorthand for <code>.multicast(new Rx.Subject())</code> (and <code>publishBehavior</code>, <code>publishLast</code>, and <code>publishReplay</code> are similar but instantiate <code>BehaviorSubject</code>, <code>AsyncSubject</code> and <code>ReplaySubject</code> respectively).</p>
","7612287","","","","","2017-03-03 09:00:34","","","","0","","","","CC BY-SA 3.0"
"42589561","1","","","2017-03-03 22:30:35","","0","204","<p>I'm novice to RxJS,  I'm trying to implement chain of observable that behave exactly like MS-Excel. The concept: Lets assume the excel have 5 columns 'Name', 'Age', 'Sex', 'Country', 'Zipcode'. We can apply filter on each column independently that also affect the records show in the other columns.</p>

<p>Here the data-source receives the data back-end service, the data-source will have only two functions ""addRecord"" &amp; ""removeRecord"". </p>

<p>How I'm trying to achieve here lets say I will create Observable and attach to the data-source call it as OBS-1 this will receive data from data-source. The OBS-1 can have its own filters. Lets say I will create another Observable OBS-2 which will receive data OBS-1 (filtered data if any filters in OBS-1). Another Observable say OBS-3 which again receive data from OBS-2 (filtered if any in OBS-2), so on.</p>

<p>If OBS-2 is destroyed (unsubscribed) the OBS-3 will receive the data from OBS-1.</p>

<p>How do we achieve this in the RxJs?</p>
","3130446","","","","","2017-03-03 23:04:01","Rxjs 5: How to establish chain of Observable?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42598503","1","42598652","","2017-03-04 16:41:26","","4","1028","<p>I have a form where the user can enter markdown-formatted text in a textarea. I'd like to show a <em>quasi live</em> preview of the <em>parsed</em> markdown next to the field.</p>

<p>Exactly like the StackOverflow question form. ;-)</p>

<p>The values of the textarea are being emitted through an RxJS Observable but I don't want to refresh the preview for every new value. Instead I'd like to refresh the preview <strong>only after the user has stopped typing for say 500ms</strong>.</p>

<p>Here's a tentative diagram (first line is the raw values emitted by the textarea as the user types, second line is what I'd like to obtain; <strong>a value is emitted only once a specific delay WITH NO EMISSION has elapsed</strong>):</p>

<pre><code>t---t--ttt------tt-ttt------t---|
----------------t-----------t---|
</code></pre>

<p>What would be the syntax to achieve this?</p>
","1153681","","","","","2018-04-02 10:49:07","RxJS - Emit only after specific delay of idleness","<rxjs><rxjs5>","2","5","","","","CC BY-SA 3.0"
"42598652","2","","42598503","2017-03-04 16:55:58","","2","","<p>You can just use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-debounceTime"" rel=""nofollow noreferrer"">debounceTime() operator</a>.</p>

<p>You can also chain it with <code>distinctUntilChanged()</code>, to avoid recomputing the HTML if the user, for example, adds two characters and deletes them</p>
","571407","","","","","2017-03-04 16:55:58","","","","0","","","","CC BY-SA 3.0"
"42602485","1","42603009","","2017-03-04 23:15:34","","1","3193","<p>I'm building a litte RxJS Wrapper for Stomp over Websockets, which already works.</p>

<p>But now I had the idea of a really cool feature, that may (hopefully - correct me if I'm wrong) be easily done using RxJS.</p>

<h2>Current behavior:</h2>

<pre><code>myStompWrapper.configure(""/stomp_endpoint"");
myStompWrapper.connect();      // onSuccess: set state to CONNECTED

// state (Observable) can be DISCONNECTED or CONNECTED
var subscription = myStompWrapper.getState()
    .filter(state =&gt; state == ""CONNECTED"")
    .flatMap(myStompWrapper.subscribeDestination(""/foo""))
    .subscribe(msg =&gt; console.log(msg));

// ... and some time later:
subscription.unsubscribe();    // calls 'unsubscribe' for this stomp destination
myStompWrapper.disconnect();   // disconnects the stomp websocket connection
</code></pre>

<p>As you can see, I <strong>must</strong> wait for <code>state == ""CONNECTED""</code> in order to subscribe to <code>subscribeDestination(..)</code>. Else I'd get an Error from the Stomp Library.</p>

<h2>The new behavior:</h2>

<p>The next implementation should make things easier for the user. Here's what I imagine:</p>

<pre><code>myStompWrapper.configure(""/stomp_endpoint"");

var subscription = myStompWrapper.subscribeDestination(""/foo"")
    .subscribe(msg =&gt; console.log(msg));

// ... and some time later:
subscription.unsubscribe();
</code></pre>

<p><strong>How it should work internally:</strong></p>

<ol>
<li><code>configure</code> can only be called while <code>DISCONNECTED</code></li>
<li>when <code>subscribeDestination</code> is called, there are 2 possibilities:

<ol>
<li>if <code>CONNECTED</code>: just subscribe to the destination</li>
<li>if <code>DISCONNECTED</code>: first call <code>connect()</code>, then subscribe to the destination</li>
</ol></li>
<li>when <code>unsubscribe</code> is called, there are 2 possibilities:

<ol>
<li>if this was the last subscription: call <code>disconnect()</code></li>
<li>if this wasn't the last subscription: do nothing</li>
</ol></li>
</ol>

<p>I'm not yet sure how to get there, but that's why I ask this question here <code>;-)</code></p>

<p>Thanks in advance!</p>

<h1>EDIT: more code, examples and explanations</h1>

<p>When <strong>configure()</strong> is called while <strong>not</strong> disconnected it should throw an <code>Error</code>. But that's not a big deal.</p>

<p><strong>stompClient.connect(..)</strong> is non-blocking. It has an <code>onSuccess</code> callback:</p>

<pre><code>public connect() {
  stompClient.connect({}, this.onSuccess, this.errorHandler);
}

public onSuccess = () =&gt; {
  this.state.next(State.CONNECTED);
}
</code></pre>

<p><strong>observeDestination(..)</strong> subscribes to a Stomp Message Channel (= destination) and returns an <code>Rx.Observable</code> which then can be used to unsubscribe from this Stomp Message Channel:</p>

<pre><code>public observeDestination(destination: string) {
  return this.state
      .filter(state =&gt; state == State.CONNECTED)
      .flatMap(_ =&gt; Rx.Observable.create(observer =&gt; {
        let stompSubscription = this.client.subscribe(
            destination,
            message =&gt; observer.next(message),
            {}
        );

        return () =&gt; {
          stompSubscription.unsubscribe();
        }
      }));
}
</code></pre>

<p><strong>It can be used like this:</strong></p>

<pre><code>myStompWrapper.configure(""/stomp_endpoint"");
myStompWrapper.connect();

myStompWrapper.observeDestination(""/foo"")
    .subscribe(..);

myStompWrapper.observeDestination(""/bar"")
    .subscribe(..);
</code></pre>

<p><strong>Now I'd like to get rid of <code>myStompWrapper.connect()</code></strong>. The code should automatically call <code>this.connect()</code> when the first one subscribes by calling <code>observeDestination(..).subscribe(..)</code> and it should call <code>this.disconnect()</code> when the last one called <code>unsubscribe()</code>.</p>

<p><strong>Example:</strong></p>

<pre><code>myStompWrapper.configure(""/stomp_endpoint"");

let subscription1 = myStompWrapper.observeDestination(""/foo"")
    .subscribe(..); // execute connect(), because this
                    // is the first subscription

let subscription2 = myStompWrapper.observeDestination(""/bar"")
    .subscribe(..);

subscription2.unsubscribe();
subscription1.unsubscribe(); // execute disconnect(), because this 
                             // was the last subscription
</code></pre>
","1321564","","1321564","","2017-03-06 07:44:34","2017-03-06 07:44:34","RxJS: Auto (dis)connect on (un)subscribe with Websockets and Stomp","<rxjs><reactive-programming><rxjs5><reactivex><reactive>","1","0","","","","CC BY-SA 3.0"
"42603009","2","","42602485","2017-03-05 00:27:06","","0","","<p><a href=""https://stackoverflow.com/questions/42602485/rxjs-auto-disconnect-on-unsubscribe-with-websockets-and-stomp"">RxJS: Auto (dis)connect on (un)subscribe with Websockets and Stomp</a></p>

<p>I agree the code you are suggesting to tuck away into myStompWrapper will be happier in its new home.</p>

<p>I would still suggest to use a name like <code>observeDestination</code> rather than <code>subscribeDestination(""/foo"")</code> as you are not actually subscribing from that method but rather just completing your observable chain.</p>

<ol>
<li><p><em><code>configure()</code> can only be called while <code>DISCONNECTED</code></em></p>

<p>You do not specify here what should happen if it is called while not <code>DISCONNECTED</code>. As you do not seem to be returning any value here that you would use, I will assume that you intend to throw an exception if it has an inconvenient status. To keep track of such statuses, I would use a <code>BehaviourSubject</code> that starts with the initial value of <code>DISCONNECTED</code>. You likely will want to keep state within <code>observeDestination</code> to decide whether to throw an exception though</p></li>
<li><p><em>if CONNECTED: just subscribe to the destination</em></p>

<p><em>if DISCONNECTED: first call connect(), then subscribe to the destination</em></p>

<p>As I mentioned before, I think you will be happier if the subscription does not happen within <code>subscribeDestination(""/foo"")</code> but rather that you just build your observable chain. As you simply want to call <code>connect()</code> in some cases, I would simply use a <code>.do()</code> call within your observable chain that contains a condition on the state.</p></li>
<li><p>To make use of the rx-y logic, you likely want to call <code>disconnect()</code> as part of your observable unsubscribe and simply return a shared refcounted observable to start with. This way, each new subscriber does not recreate a new subscription, instead <code>.refCount()</code> will make a single subscription to the observable chain and <code>unsubscribe()</code> once there is no more subscribers downstream.</p></li>
</ol>

<p>Assuming the messages are coming in as <strong>this.observedData$</strong> in <code>myStompWrapper</code> My suggested code as part of <code>myStompWrapper</code> would look something like this:</p>

<pre><code>observeDestination() {
  return Rx.Observable.create(function (observer) {
     var subscription = this.getState()
             .filter(state =&gt; state == ""CONNECTED"")
             .do(state =&gt; state ? this.connect() : Observable.of(true))
             .switchMap(this.observedData$)
             .refCount();
             .subscribe(value =&gt; {
               try {
                 subscriber.next(someCallback(value));
               } catch(err) {
                 subscriber.error(err);
               }
             },
             err =&gt; subscriber.error(err),
             () =&gt; subscriber.complete());

 return { unsubscribe() { this.disconnect(); subscription.unsubscribe(); } };
}
</code></pre>

<p>Because I am missing some of your code, I am allowing myself to not test my code. But hopefully it illustrates and presents the concepts I mentioned in my answer.</p>
","84376","","-1","","2017-05-23 12:17:11","2017-03-05 00:27:06","","","","2","","","","CC BY-SA 3.0"
"42613512","1","","","2017-03-05 20:23:33","","0","362","<p>With this code</p>

<pre><code>const start$ = Observable.fromEvent(this.getNativeElement(this.start),'click');
    const stop$ = Observable.fromEvent(this.getNativeElement(this.stop),'click');
    const interval$ = Observable.interval(1000);
    const data = {count:0};

    const intervalThatStops$ = interval$
    .takeUntil(stop$);

start$
    .switchMapTo(intervalThatStops$)
    .startWith(data)
    .scan((acc,curr) =&gt; {
      return {
        count: acc.count+1
      };
    })
    .subscribe((x)=&gt; console.log(x.count));
</code></pre>

<p>I've got in the console</p>

<p><em>Argument of type '{ count: number; }' is not assignable to parameter of type 'number | IScheduler'.
  Type '{ count: number; }' is not assignable to type 'IScheduler'.
    Property 'now' is missing in type '{ count: number; }'.)</em></p>

<p>a quick fix should be</p>

<pre><code>.startWith&lt;any&gt;(data)
</code></pre>

<p>but what's the right way, please ?</p>

<p>Thanks in advance</p>
","356380","","","","","2017-03-05 21:03:16","Argument of type '{ count: number; }' is not assignable to parameter of type 'number","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42617667","1","","","2017-03-06 04:42:00","","4","294","<p>I want to embed a cycle.js component inside jsx.</p>

<p>I have seen examples in the <a href=""https://cycle.js.org/components.html"" rel=""nofollow noreferrer"">documentation</a> of embedding components inside other components but not when using JSX and I can't find any examples online. I am quite new to the whole reactive thing such as RxJs.</p>

<p>In the example in the <a href=""https://cycle.js.org/components.html"" rel=""nofollow noreferrer"">documentation</a> they just seem to plonk the child component into the parent component (now I can see they pass it in to the xs.combine() function):</p>

<pre><code>  const childVDom$ = labeledSlider.DOM;
  const childValue$ = labeledSlider.value;

  const vdom$ = xs.combine(childValue$, childVDom$)
    .map(([value, childVDom]) =&gt;
      div([
        childVDom,
        div({style: {
</code></pre>

<p>But when I do it in JSX it causes it to just return undefined to the DOM where the component goes (see near the bottom of this code):</p>

<pre><code>import { html } from 'snabbdom-jsx'
import * as dom from '@cycle/dom'
import Button from 'components/button'
import Rx from 'rxjs/Rx'
import styles from './index.styl'

export default function Title(sources) {
  const sinks = {
    DOM: view(sources)
  }
  return sinks
}

function view(sources) {

  const props$ = Rx.Observable.of({
    label: 'Try Now'
  })

  const childSources = {
    DOM: sources.DOM,
    props: props$
  }

const button = Button(childSources)
  const vdom$ = props$
    .map(() =&gt;
      &lt;div className=""container has-text-centered""&gt;
        &lt;p className=""logo""&gt;
          &lt;img className={`${styles.img}`}
            src=""src/img/logo_transparent_background.png""
          /&gt;
        &lt;/p&gt;
        &lt;h4 className=""subtitle is-4""&gt;
          xxx
      &lt;/h4&gt;
        {button.DOM}&lt;------- component
      &lt;/div&gt;)

  return vdom$
}
</code></pre>

<p>Now button.DOM is an observable:</p>

<pre><code>import Rx from 'rxjs/Rx'
import { html } from 'snabbdom-jsx'

export default function Button(sources) {
  const sinks = {
    DOM: view(sources)
  }
  return sinks
}

function view(sources) {
  const props$ = sources.props
  const vdom$ = props$
    .map(props =&gt;
      &lt;a className=""button is-primary is-large is-outlined""&gt;
        {props.label}
      &lt;/a&gt;
    )
  return vdom$
}
</code></pre>

<p>How do I add it to the jsx without it being undefined? I'm using RxJs. </p>

<p><strong>EDIT: I have now come up with this which still has the same undefined outcome but seems like it is on the right track:</strong></p>

<pre><code>function view(sources) {

  const props$ = Rx.Observable.of({
    label: 'Try Now'
  })

  const childSources = {
    DOM: sources.DOM,
    props: props$
  }

const button = Button(childSources)
const childVDom$ = button.DOM
  const vdom$ = Rx.Observable.of(childVDom$)
    .map((childVDom) =&gt;
      &lt;div className=""container has-text-centered""&gt;
        &lt;p className=""logo""&gt;
          &lt;img className={`${styles.img}`}
            src=""src/img/logo_transparent_background.png""
          /&gt;
        &lt;/p&gt;
        &lt;h4 className=""subtitle is-4""&gt;
          xxx
      &lt;/h4&gt;
        {childVDom}
      &lt;/div&gt;)

  return vdom$
}
</code></pre>
","3935156","","3935156","","2017-03-06 05:24:53","2017-03-06 07:34:29","cycle.js - Embed component in jsx of other component","<javascript><rxjs><jsx><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42620338","1","42621286","","2017-03-06 07:59:13","","1","1030","<p>I'm pretty new to RxJS (using 5.1.1) and trying to understand it in my Angular 2 applciation using angular-redux/store.</p>

<p>I've got a store set up and working to get different parts of my state in my application.</p>

<p>Now, I'm trying to get AppParts that have the loaded property set to true:</p>

<p>my state:</p>

<pre><code>export interface IAppState extends IRootState{
  theme: Theme;
  config: IConfig;
  mainSubTitle: string;
  appParts: AppPart[];
}
</code></pre>

<p>the select:</p>

<pre><code>@select(state =&gt; state.app.appParts) appParts$: Observable&lt;AppPart&gt;;
</code></pre>

<p>now, I'm trying to get a filtered array from this observable:</p>

<pre><code>loadedAppParts = [];

ngOnInit() {
  this.appParts$.filter(a =&gt; a.loaded).subscribe(a =&gt; { console.log(a); this.loadedAppParts.push(a); });
}
</code></pre>

<p>However, this returns an empty array. I'd like to be able to use the async pipe to get the 'loadedAppParts' if possible too, so I've also tried doing the following:</p>

<pre><code>loadedAppParts: Observable&lt;AppPart&gt; = new Observable&lt;AppPart&gt;();
ngOnInit() {
  this.loadedAppParts = this.appParts$.filter(a =&gt; a.loaded);
}
</code></pre>

<p>So, how can I get a filtered array or observable from my Observable state?</p>

<p>Forgot to add my Rootstate:</p>

<pre><code>export interface IRootState { };
</code></pre>

<p>and my initial state:</p>

<pre><code>export const INITIAL_STATE: IAppState = {
  theme: THEMES.LightGreyBlue,
  config: &lt;IConfig&gt;{
    data: {
      apiUrl: ''
    },
    general: {
      appName: 'Default name',
      appShortName: 'default'
    }
  },
  mainSubTitle: 'Default',
  appParts: [new AppPart('core', true)]
};
</code></pre>

<p>And the template part that displays the JSON to debug (for the array example):</p>

<p><code>{{ appParts$ | async | json }} {{ loadedAppParts | json }}</code></p>

<p>When using the Observable: 
<code>{{ appParts$ | async | json }} {{ loadedAppParts | async | json }}</code> </p>

<p>This returns: <code>[ { ""name"": ""core"", ""loaded"": true } ] null</code></p>
","3711246","","310726","","2017-03-06 08:56:18","2017-03-06 08:56:18","Angular 2 RxJS filter to new observable","<javascript><angular><rxjs><observable><rxjs5>","1","5","","","","CC BY-SA 3.0"
"42621286","2","","42620338","2017-03-06 08:56:05","","2","","<p>In the JSON output you can see it looks as follows:</p>

<pre><code>[ { ""name"": ""core"", ""loaded"": true } ] null
</code></pre>

<p>So the <code>appParts$</code> is in fact emitting arrays of objects (<code>Observable&lt;AppPart[]&gt;</code>) instead of just objects (<code>Observable&lt;AppPart&gt;</code>).</p>

<p>Then when you use <code>this.appParts$.filter(a =&gt; a.loaded)</code> you're trying to filter the items by <code>.loaded</code> property that doesn't exist on an Array object so it's always empty.</p>

<p>In fact you want to filter the objects inside that array. In other words you need to flatten the array into single items. This means we want to turn this:</p>

<pre><code>[ { ""name"": ""core"", ""loaded"": true }, { ""name"": ""core"", ""loaded"": true }, { ""name"": ""core"", ""loaded"": true } ]
</code></pre>

<p>into this:</p>

<pre><code>{ ""name"": ""core"", ""loaded"": true }
{ ""name"": ""core"", ""loaded"": true }
{ ""name"": ""core"", ""loaded"": true }
</code></pre>

<p>That's what the <code>mergeAll()</code> operator can do. Using <code>mergeAll()</code> is in this case the same as using <code>merge(array =&gt; Observable.from(array))</code>.</p>

<pre><code>this.appParts$.mergeAll().filter(a =&gt; a.loaded);
</code></pre>

<p>Now when you chain it with <code>.filter(a =&gt; a.loaded)</code> you're filtering the <code>AppPart</code> objects.</p>

<p>Note that when using <code>async</code> filter it subscribes to the Observable and renders always <strong>only the last item emitted</strong> from the source.</p>

<p>You can use <code>toArray()</code> to again collect the filtered items into an array:</p>

<pre><code>this.appParts$.mergeAll().filter(a =&gt; a.loaded).toArray();
</code></pre>

<p>This has one important consequence. The <code>toArray()</code> operator emits only after the source Observable has completed (but maybe this isn't an issue in your use-case).</p>

<p>Alternatively if you want to just collect all items you could use also <code>scan()</code> operator that emits the collection on every emission from the source (however this operator might cause multiple view updates).</p>

<pre><code>this.appParts$.mergeAll().filter(a =&gt; a.loaded).scan((acc, item) =&gt; {
    acc.push(item);
    return acc;
}, []);
</code></pre>
","310726","","","","","2017-03-06 08:56:05","","","","1","","","","CC BY-SA 3.0"
"42630479","1","42630674","","2017-03-06 16:18:40","","0","2156","<p>I want to build a heatbeat service for my angular2 website. A remote device is  the host of the website and the client should be able to detect if the device is not reachable/offline.
The service should  poll periodically the (webserver) remote device.</p>

<p><em>I know that a failed HTTP-Call cannot be directly equated with the online/offline status of the whole device, but for my requirements that should be enough.</em></p>

<p>Currently I'm using the following Observable which is placed inside of an angular service:</p>

<pre><code>  public getStatus() {
    return  this.http.get(this.config.apiEndpoint + this.fileName)
      .map(() =&gt; { return '1'; })
      .timeout(500)
      .catch(() =&gt; {return '0';})
      .retry()
      .delay(1500)
      .repeat();
  }
</code></pre>

<p>The target of the observable is just an almost empty file on the webserver.
A component subscribes to the observable/service and then shows a notification if the device status changes.</p>

<p>In principle the Observable works, but it provides a continuous stream of ones (online) and zeros (offline) to the component which subscribed to it. Now I have to add some logic to the component (and every other component which uses this service) to handle for example two successive zeros, that a notification is only shown once.</p>

<p>It would be much cleaner and a better separation of concerns if the service could do this extra work and only provide a result (to the component) when the status of the device changed. I also tried to use a <code>Observable.timer</code> with a <code>flatMap</code> but failed to get it working, but I expect rxjs provides a solution to this problem. </p>
","1632341","","","","","2017-03-06 16:27:50","Build heartbeat service with RxJS","<angular><typescript><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42630674","2","","42630479","2017-03-06 16:27:50","","1","","<p>you may use <code>distinctUntilChanged</code> operator, it will ensure to pass only distinct values.</p>

<p>Hope this helps!!</p>
","3508656","","","","","2017-03-06 16:27:50","","","","2","","","","CC BY-SA 3.0"
"42636194","1","","","2017-03-06 21:46:27","","3","63","<p>How can I write this code without <code>Promise</code>, only using <code>Observable</code>?</p>

<pre><code>  private method(auth: any) {
    return new Promise((resolve, reject) =&gt; {
      auth.onAuthStateChanged(value =&gt; resolve(value));
    })
  }
</code></pre>

<p>Currently it returns a <code>Promise&lt;any&gt;</code>, I'd like to make it return an <code>Observable&lt;any&gt;</code>... <a href=""https://firebase.google.com/docs/reference/node/firebase.auth.Auth#onAuthStateChanged"" rel=""nofollow noreferrer"">onAuthStateChanged</a> has this signature:</p>

<pre><code>onAuthStateChanged(nextOrObserver, error, completed) returns function()
</code></pre>
","1876949","","1876949","","2017-03-06 23:09:29","2017-03-06 23:09:29","How to write this async method using Observables only?","<typescript><rxjs5>","0","4","","","","CC BY-SA 3.0"
"42640065","1","42722038","","2017-03-07 04:10:19","","4","188","<p>I have a pretty simple conditional rendering scenario where if <code>props.showCalc</code> is true, I will render the <code>calculator</code>, but if false, I will render the <code>title</code>:</p>

<pre><code>function view(sources) {
  const props$ = sources.props
  const titleVDom$ = Title(sources).DOM
  const calcVDom$ = Calculator(sources).DOM
  const vdom$ = props$
    .map((props) =&gt;
      &lt;section className=""hero is-fullheight is-primary""&gt;
        &lt;div className=""hero-head""&gt;
        &lt;/div&gt;
        &lt;div className=""hero-body""&gt;
          {props.showCalc ? {calcVDom$} : {titleVDom$}}
        &lt;/div&gt;
        &lt;div className=""hero-foot""&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    )
  return vdom$
}
</code></pre>

<p>This doesn't work, because you can't pass a stream DOM to JSX to render. I've always had to map the stream DOM in order to render it. </p>

<p>How could I render the <code>{calcVDom$}</code> or <code>{titleVDom$}</code> in this scenario? As is, they both render ""undefined"" because they are streams.</p>

<p>I tried to map <code>calcVDom$</code>/<code>titleVDom$</code> halfway down the render function but it was becoming really messy.</p>
","3935156","","3935156","","2017-03-09 03:53:56","2017-03-10 15:41:16","Conditional rendering in cycle.js with RxJS","<javascript><rxjs><reactive-programming><jsx><rxjs5>","1","1","","","","CC BY-SA 3.0"
"42647567","1","42647651","","2017-03-07 11:49:31","","10","2596","<p>The following code emits an <code>int</code> after <code>5000ms</code> and then another in every <code>5000ms</code> later:</p>

<pre><code>let evens = Observable.interval(5000)
     .map(i =&gt; {
          return i * 2;
      });

 evens.subscribe((i) =&gt; {
      console.log(i);
 });
</code></pre>

<p>Is it possible to do this, but have the first result immediately (<code>0ms</code>), and then wait <code>5000m</code>s between subsequent results?</p>
","522330","","310726","","2017-03-07 11:56:37","2019-01-17 09:30:50","RxJS Interval without delay","<javascript><typescript><rxjs><rxjs5><reactive-extensions-js>","1","0","","","","CC BY-SA 3.0"
"42647651","2","","42647567","2017-03-07 11:53:38","","17","","<p>You can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-timer"" rel=""noreferrer""><code>timer()</code></a> where the first parameter is the initial delay:</p>

<pre><code>timer(0, 5000);
</code></pre>

<p>Or if you want the first item to be emitted immediately you can also use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-startWith"" rel=""noreferrer""><code>startWith()</code></a> operator.</p>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-17 09:30:50","2019-01-17 09:30:50","","","","0","","","","CC BY-SA 4.0"
"42655505","1","42656077","","2017-03-07 18:20:40","","1","237","<p>I am trying to learn Rxjs and I am seeing some behaviour that I did not expect. The javascript code in question is listed below</p>

<pre><code>function updateText(css_link, observable){
  observable.subscribe(x =&gt; {
    const container = document.querySelector(css_link);
    container.textContent = `${x}`;
  });
}

function log(observable) {
  observable.subscribe(i =&gt; {
    console.log(i);
  });
}

let source = Rx.Observable.timer(0, 1000)
  .map(() =&gt; {return {value: Math.random()}});

let double = source
  .map(x =&gt; {return {value: x.value * 2}});

let diff = source
  .pairwise()
  .map(a =&gt; JSON.stringify(a));

updateText(""#source"", source.map(x =&gt; x.value));
updateText(""#double"", source.map(x =&gt; x.value));
updateText(""#diff"", diff);
</code></pre>

<p>It turns out that the output of the <code>double</code> stream are double values of new random numbers, not the random numbers that came from <code>source</code>. When looking at the output of <code>diff</code> I again get the impression that the random numbers are generated independantly in <code>source</code>, <code>double</code> and <code>diff</code>. </p>

<p>I am learning Rxjs and I may be missing a point. I thought that these streams are immutable but that they do depend on one another. </p>

<p>You can find a version of this code on <a href=""https://jsbin.com/jopinol/2/edit?html,js,output"" rel=""nofollow noreferrer"">jsbin</a> with some html that is getting updated.</p>
","1600821","","310726","","2017-03-07 18:57:14","2017-03-07 18:57:14","RxJS does not play nice with Math.random()","<javascript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42656077","2","","42655505","2017-03-07 18:55:40","","2","","<p>This is because every time you subscribe you're creating a new chain with a new source Observable. This means <code>source</code>, <code>double</code> and <code>diff</code> each one of them has its own timer.</p>

<p>You can see that this is true by printing a message to console every time you're creating a new timer:</p>

<pre><code>let source = Rx.Observable.defer(() =&gt; {
  console.log('new source');
  return Rx.Observable.timer(0, 1000)
    .map(() =&gt; {return {value: Math.random()}});
});
</code></pre>

<p>Now you'll see three messages <code>""new source""</code> in console.</p>

<p>If you want to share a single source Observable you can use multicasting and in particular the <code>share()</code> operator.</p>

<pre><code>let source = Rx.Observable.defer(() =&gt; {
  console.log('new source');
  return Rx.Observable.timer(0, 1000)
    .map(() =&gt; {return {value: Math.random()}});
}).share();
</code></pre>

<p>Now you'll see only one <code>""new source""</code> in console and it should work as you expect.</p>

<p>So your source can look like this:</p>

<pre><code>let source = Rx.Observable.timer(0, 1000)
  .map(() =&gt; {return {value: Math.random()}})
  .share();
</code></pre>

<p>Your updated demo: <a href=""https://jsbin.com/guyigox/3/edit?js,console,output"" rel=""nofollow noreferrer"">https://jsbin.com/guyigox/3/edit?js,console,output</a></p>
","310726","","","","","2017-03-07 18:55:40","","","","0","","","","CC BY-SA 3.0"
"42659326","1","42660606","","2017-03-07 22:11:11","","3","170","<p>Consider the following, almost identical, two snippets.</p>

<p>The difference is:</p>

<ul>
<li>the first one uses <code>setTimeout()</code> to trigger the event</li>
<li>the second one triggers the event when the button is clicked</li>
</ul>

<p>If you check the console, you'll see that the last two lines in Snippet 1  are:</p>

<pre><code>App rendering 1 folder(s)
Observed js
</code></pre>

<p>and in Snippet 2 are:</p>

<pre><code>Observed js
App rendering 1 folder(s)
</code></pre>

<p><strong>Question:</strong> Why is the order reversed?</p>

<p><a href=""http://codepen.io/moroshko/pen/dvOdPz?editors=0010"" rel=""nofollow noreferrer"">setTimeout() playground</a></p>

<p><a href=""http://codepen.io/moroshko/pen/jBVZOo?editors=0010"" rel=""nofollow noreferrer"">Button playground</a></p>

<hr>

<h2>Snippet 1: setTimeout() trigger</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class App extends React.Component {
  constructor() {
    super();
    
    this.events$ = new Rx.Subject();
    this.eventsByName$ = this.events$.groupBy(e =&gt; e.name);
    
    this.state = {};
    
    setTimeout(() =&gt; {
      console.log('Emitting event');
      
      this.events$.next({
        type: 'ADD_FOLDER',
        name: 'js',
        permissions: 400
      });
    }, 1000);
  }
  
  componentDidMount() {
    this.eventsByName$.subscribe(folderEvents$ =&gt; {
      const folder = folderEvents$.key;
      
      console.log(`New stream for ""${folder}"" created`);

      folderEvents$.subscribe(e =&gt; {
        console.log(`Observed ${e.name}`);
      });
      
      this.setState({
        [folder]: folderEvents$
      });
    });
  }
  
  render() {
    const folders = Object.keys(this.state);
    
    console.log(`App rendering ${folders.length} folder(s)`);
    
    return (
      &lt;div&gt;
        {
          folders.map(folder =&gt; (
            &lt;div key={folder}&gt;
              {folder}
            &lt;/div&gt;
          ))
        }
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('app')
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;head&gt;
  &lt;script src=""https://unpkg.com/rxjs@5.2.0/bundles/Rx.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react@15.4.2/dist/react.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react-dom@15.4.2/dist/react-dom.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=""app""&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre>
</div>
</div>
</p>

<h2>Snippet 2: Button trigger</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class App extends React.Component {
  constructor() {
    super();
    
    this.events$ = new Rx.Subject();
    this.eventsByName$ = this.events$.groupBy(e =&gt; e.name);
    
    this.state = {};
  }
  
  componentDidMount() {
    this.eventsByName$.subscribe(folderEvents$ =&gt; {
      const folder = folderEvents$.key;
      
      console.log(`New stream for ""${folder}"" created`);
      
      folderEvents$.subscribe(e =&gt; {
        console.log(`Observed ${e.name}`);
      });
      
      this.setState({
        [folder]: folderEvents$
      });
    });
  }
  
  onClick = () =&gt; {
    console.log('Emitting event');
    
    this.events$.next({
      type: 'ADD_FOLDER',
      name: 'js',
      permissions: 400
    });
  };
  
  render() {
    const folders = Object.keys(this.state);
    
    console.log(`App rendering ${folders.length} folder(s)`);
    
    return (
      &lt;div&gt;
        &lt;button onClick={this.onClick}&gt;
          Add event
        &lt;/button&gt;
        &lt;div&gt;
          {
            folders.map(folder =&gt; (
              &lt;div key={folder}&gt;
                {folder}
              &lt;/div&gt;
            ))
          }
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('app')
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;head&gt;
  &lt;script src=""https://unpkg.com/rxjs@5.2.0/bundles/Rx.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react@15.4.2/dist/react.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react-dom@15.4.2/dist/react-dom.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=""app""&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre>
</div>
</div>
</p>
","247243","","","","","2017-03-08 01:17:16","Why button click trigger is different from setTimeout() trigger?","<reactjs><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42660606","2","","42659326","2017-03-08 00:00:57","","3","","<p>They are run in a different order because React tries to batch <code>setState()</code> calls together, so calling <code>setState()</code> does not cause the component to re-render synchronously, but instead waits until the event callback returns.</p>

<p>However, it only does this if and only if your call to <code>setState</code> was the result of a React-driven event, like <code>onClick</code> is. When you're using <code>setTimeout</code>, React (currently) has no way to know when you're done, so it cannot batch them together. Instead, it synchronously re-renders right then.</p>

<p>Best I can tell, React docs only mention this behavior indirectly in passing:</p>

<blockquote>
  <p>setState() does not immediately mutate this.state but creates a
  pending state transition. Accessing this.state after calling this
  method can potentially return the existing value.</p>
  
  <p>There is no guarantee of synchronous operation of <strong>calls to setState
  and calls may be batched for performance gains.</strong></p>
  
  <p><a href=""https://facebook.github.io/react/docs/react-component.html#setstate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#setstate</a></p>
</blockquote>

<p>If you want React to batch things, you would need to wrap your callback code inside <code>ReactDOM.unstable_batchedUpdates</code>, which as the name suggests is not a stable API so it can (and likely will) change without warning.</p>

<pre class=""lang-js prettyprint-override""><code>setTimeout(() =&gt; {
  ReactDOM.unstable_batchedUpdates(() =&gt; {
    console.log('Emitting event');

    this.events$.next({
      type: 'ADD_FOLDER',
      name: 'js',
      permissions: 400
    });
  });
}, 1000);
</code></pre>

<p>Ideally, your code would be structured in a way in which the order does not matter.</p>
","1770633","","247243","","2017-03-08 01:17:16","2017-03-08 01:17:16","","","","0","","","","CC BY-SA 3.0"
"42661489","1","42679827","","2017-03-08 01:42:43","","2","255","<p>I have a stream of events which is grouped by name.</p>

<p>Every resulting observable is passed as <code>events$</code> prop to a <code>Folder</code> component, which subscribes to it in <code>componentDidMount()</code>.</p>

<p>The problem I'm experiencing is that, <code>Folder</code>'s observer is missing the first event.</p>

<p>To reproduce, click on <kbd>Add event</kbd>. You'll see that <code>Folder</code> renders <code>undefined</code>, and doesn't update it to the data in the emitted event. <a href=""http://codepen.io/moroshko/pen/YZpvGe?editors=0010"" rel=""nofollow noreferrer"">Playground</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const events$ = new Rx.Subject();

class Folder extends React.Component {
  constructor() {
    super();
    this.state = {};
  }

  componentDidMount() {
    this.props.events$.subscribe(e =&gt; {
      this.setState({
        name: e.name,
        permissions: e.permissions
      }); 
    });
  }

  componentWillUnmount() {
    this.props.events$.unsubscribe();
  }

  render() {
    const { name, permissions } = this.state;
    
    return (
      &lt;div&gt;
        {`[${permissions}] ${name}`}
      &lt;/div&gt;
    );
  }
}

class App extends React.Component {
  constructor(props) {
    super();
    this.eventsByName$ = props.events$.groupBy(e =&gt; e.name);
    this.state = {};
  }
  
  componentDidMount() {
    this.eventsByName$.subscribe(folderEvents$ =&gt; {
      const folder = folderEvents$.key;
     
      this.setState({
        [folder]: folderEvents$
      });
    });
  }
  
  onClick = () =&gt; {
    this.props.events$.next({
      type: 'ADD_FOLDER',
      name: 'js',
      permissions: 400
    });
  };
  
  render() {
    const folders = Object.keys(this.state);
    
    return (
      &lt;div&gt;
        &lt;button onClick={this.onClick}&gt;
          Add event
        &lt;/button&gt;
        &lt;div&gt;
          {
            folders.map(folder =&gt; (
              &lt;Folder events$={this.state[folder]} key={folder} /&gt;
            ))
          }
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;App events$={events$} /&gt;,
  document.getElementById('app')
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;head&gt;
  &lt;script src=""https://unpkg.com/rxjs@5.2.0/bundles/Rx.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react@15.4.2/dist/react.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react-dom@15.4.2/dist/react-dom.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=""app""&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre>
</div>
</div>
</p>

<p>To get the missing event, I used <code>ReplaySubject(1)</code>: <a href=""http://codepen.io/moroshko/pen/zZoaoK?editors=0010"" rel=""nofollow noreferrer"">Playground</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const events$ = new Rx.Subject();

class Folder extends React.Component {
  constructor() {
    super();
    this.state = {};
  }

  componentDidMount() {
    this.props.events$.subscribe(e =&gt; {
      this.setState({
        name: e.name,
        permissions: e.permissions
      });
    });
  }

  componentWillUnmount() {
    this.props.events$.unsubscribe();
  }

  render() {
    const { name, permissions } = this.state;
    
    return (
      &lt;div&gt;
        {`[${permissions}] ${name}`}
      &lt;/div&gt;
    );
  }
}

class App extends React.Component {
  constructor(props) {
    super();
    this.eventsByName$ = props.events$.groupBy(e =&gt; e.name);
    this.state = {};
  }
  
  componentDidMount() {
    this.eventsByName$.subscribe(folderEvents$ =&gt; {
      const folder = folderEvents$.key;
     
      const subject$ = new Rx.ReplaySubject(1);

      folderEvents$.subscribe(e =&gt; subject$.next(e));
      
      this.setState({
        [folder]: subject$
      });
    });
  }
  
  onClick = () =&gt; {
    this.props.events$.next({
      type: 'ADD_FOLDER',
      name: 'js',
      permissions: 400
    });
  };
  
  render() {
    const folders = Object.keys(this.state);
    
    return (
      &lt;div&gt;
        &lt;button onClick={this.onClick}&gt;
          Add event
        &lt;/button&gt;
        &lt;div&gt;
          {
            folders.map(folder =&gt; (
              &lt;Folder events$={this.state[folder]} key={folder} /&gt;
            ))
          }
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;App events$={events$} /&gt;,
  document.getElementById('app')
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;head&gt;
  &lt;script src=""https://unpkg.com/rxjs@5.2.0/bundles/Rx.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react@15.4.2/dist/react.js""&gt;&lt;/script&gt;
  &lt;script src=""https://unpkg.com/react-dom@15.4.2/dist/react-dom.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=""app""&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre>
</div>
</div>
</p>

<p>Now, when <kbd>Add event</kbd> is clicked, <code>Folder</code>'s observer sees the event and properly renders its data.</p>

<p>This feels a bit hacky to me.</p>

<p>Is there a better way to organize the code to avoid the missing event issue?</p>

<p><a href=""https://stackoverflow.com/q/42659326/247243"">This question</a> might help.</p>
","247243","","-1","","2017-05-23 12:17:11","2017-03-08 19:06:14","React component subscribes too late. How to avoid losing the first event?","<reactjs><rxjs><rxjs5>","2","3","0","","","CC BY-SA 3.0"
"42678242","1","","","2017-03-08 17:41:15","","0","67","<p>This may be two related questions. I have several angular2 components that make async requests to a service and display results once received. The reactive way would be do do this with an Observable that the template is bound to directly. However, I find that often I need to handle errors in those subscriptions in my component code. I can't figure how to do both simultaneously, so I typically end up assigning the async result to a property and handling errors inside a zone.run() instead. </p>

<p>Additionally, I often need to map arrays returned from a service call to add stuff like an <code>isSelected</code> property for selection tracking, then later inspect the array to find the selection, like:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>refreshTeamItems() {
  this.apiService.getProgramTeams()
    .map(teams =&gt;
      teams.map(team =&gt; ({
        team,
        selected: false
      }))
    )
    .subscribe(items =&gt; {
      this.zone.run(() =&gt; this.teamItems = items);
    }, err =&gt; /* handle err */ );
}</code></pre>
</div>
</div>
</p>

<p>So, in general my question is how do I make my service layer Observables more useful in my component code rather than just naively handing them off to the template? I'm assuming there's some nice reactive composable way to do this, but I'm not an rxjs pro.</p>
","370538","","370538","","2017-03-08 18:25:08","2017-03-08 18:25:08","How can I use Observables in an Angular2 component while handling errors or allowing subsequent array access?","<angular><rxjs><rxjs5>","0","9","","","","CC BY-SA 3.0"
"42679813","1","42682803","","2017-03-08 19:05:28","","1","60","<p>Example code:</p>

<pre><code>const test1$ = Rx.Observable.interval(1000)
const test2$ = Rx.Observable.interval(1000)

// This subscription need to get every value continuously
const firstSub = test2$
  .do(val =&gt; console.log('Service: ', val))
  .subscribe()

// This subscription need to get only first value and stop
const secondSub = Rx.Observable.combineLatest(test1$, test2$)
  .do(val =&gt; console.log('Method: ', val))
  .first()
  .subscribe()
</code></pre>

<ul>
<li><strong>First subscription</strong> starts right after app startup.</li>
<li><strong>Second subscription</strong> started by click event (so it could run a few times).</li>
</ul>

<p>When I use either <code>.first()</code> or <code>.take(1)</code> operator, somehow first subscription get affected by it too, and stops getting values.</p>

<p>How can I change that behavior to still get values from first subscription, while only get one value from the second subscription and stop?</p>
","6673479","","6673479","","2017-03-08 19:26:15","2017-03-08 22:06:46",".first() operator affects other subscriptions","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42679827","2","","42661489","2017-03-08 19:06:14","","2","","<p>This is truly a timing issue. Normal Subjects do not cache, buffer, or otherwise keep anything that is emitted through them, so what is happening is this:</p>

<ol>
<li>Click button</li>
<li><code>onClick</code> calls <code>events$.next(event)</code> and it notifies any subscribers, which is currently only <code>eventsByName$</code>, which is listening because it calls <code>groupBy</code> on them and was subscribed earlier in <code>componentDidMount</code></li>
<li><code>eventsByName$</code> subscriber calls <code>setState</code>, which is batched because this the callstack leading to here was synchronous starting from a React synthetic event as described in <a href=""https://stackoverflow.com/a/42660606/1770633"">my answer to your previous question</a></li>
<li>React waits until the <code>onClick</code> callstack returns, and flushes the <code>setState</code> buffer</li>
<li>React rerenders (remember, all the <code>event$</code> subscribers have already been notified before this and the <code>&lt;Folder&gt;</code> component <strong>is not one of them yet</strong> because it hasn't even been created.</li>
<li>A new <code>&lt;Folder&gt;</code> component is created, passing in its <code>event$</code></li>
<li>That new <code>&lt;Folder&gt;</code> mounts, leading it to subscribe to <code>event$</code> it was provided, but missing a chance to catch the <code>ADD_FOLDER</code> event you emitted previously.</li>
</ol>

<p>This is why using <code>ReplaySubject</code> worked, it replays the last event you missed.</p>

<hr>

<p>Overall, I would suggest moving away from this event pattern. Since this is a contrived example to demonstrate the issue I can't be sure what problem you're trying to solve using these style, but generally speaking it has similarities to Redux. If this pattern is neccesary for your app, you might consider using Redux or adopting the same patterns with just RxJS using a <code>.scan()</code>--an example of <a href=""http://rudiyardley.com/redux-single-line-of-code-rxjs/"" rel=""nofollow noreferrer"">which is here</a>. It's hard to say whether you need this though, cause the example you gave can easily be done without RxJS and would be more clear with just normal React onClick -> setState -> rerender -> pass state as props (without any Rx in there)</p>

<p>I highly recommend against reimplementing the wheel though--redux has a vibrant middleware ecosystem and excellent Dev Tools that you'd lose rolling your own. Also, you can still use RxJS with Redux. I maintain a library just for that, <a href=""https://redux-observable.js.org/"" rel=""nofollow noreferrer"">redux-observable</a>.</p>
","1770633","","-1","","2017-05-23 11:53:56","2017-03-08 19:06:14","","","","1","","","","CC BY-SA 3.0"
"42682803","2","","42679813","2017-03-08 22:06:46","","2","","<p>There is currently a bug in the library when you use an empty (<code>undefined</code>) with <code>subscribe()</code>.</p>

<p>This is being addressed by:
<a href=""https://github.com/ReactiveX/rxjs/pull/2238"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/2238</a></p>

<p>In the meantime if you update your code like so, things will work as expected.</p>

<pre><code>const test1$ = Rx.Observable.interval(1000)
const test2$ = Rx.Observable.interval(1000)

// This subscription need to get every value continuously
const firstSub = test2$
  .do(val =&gt; console.log('Service: ', val))
  .subscribe({})

// This subscription need to get only first value and stop
const secondSub = Rx.Observable.combineLatest(test1$, test2$)
  .do(val =&gt; console.log('Method: ', val))
  .first()
  .subscribe({})
</code></pre>
","400771","","","","","2017-03-08 22:06:46","","","","1","","","","CC BY-SA 3.0"
"42684600","1","42689627","","2017-03-09 00:38:26","","3","5420","<p>I have a subscription that I want to use to signal events, in a piece of middleware code. So I have one thing that wants to subscribe an observable, and another thing that's not quite an observable.</p>

<p>I thought about using Subjects for this - that's what they seem to be for:</p>

<pre><code>const repeater = new Rx.Subject();

function subscribe(observer) {
  return repeater.subscribe(observer);
}

// in some other function, call repeater.next(val)
</code></pre>

<p>But then I started looking at what regular subscribe() calls return. I could do this instead:</p>

<pre><code>let sub = null;
function subscribe(observer) {
  return Rx.Observable.create((o) =&gt; sub = o);
}
// elsewhere sub.next(val)
</code></pre>

<p>But also?</p>

<pre><code>let unsub = null;
function subscribe(observer) {
  unsub = Rx.Observable.create(() =&gt; false).subscribe(observer)
}
// elsewhere unsub.next(val)
</code></pre>

<p>all of these things will signal val to the subscriber. The weird thing that I don't understand here is the subscription return having a <code>next()</code> available to it - I thought <code>next()</code> only lived on the observer in the Observable context.</p>

<p>I need to keep a handle on the unsubscription doodad no matter what - when the middleware is torn down, I need to signal stream completion and release some resources. It was surprising to me that unsub had a functioning next.</p>

<p>This signals to me that there's some bit of RxJS that I just plain don't grok yet, in terms of Observers and Observables and Subjects and so on. In general, I understand how to wire event sources and other similar things into an observable stream. It's really just in the context of building an observable stream out of a boring function call - whenever the function is called by an external library, this stream signals an updated observable.</p>
","1596772","","","","","2017-03-09 07:51:47","Is it an antipattern to use subscription.next()?","<rxjs><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"42687528","1","42689101","","2017-03-09 05:34:04","","0","1225","<p>I have this response from a http get</p>

<pre><code>{
    ""parents"": [{
        ""id"": 1
        , ""children"": [{
                ""name"": ""child1""
            }
            , {
                ""name"": ""child2""
            }]
    }, {
        ""id"": 2
        , ""children"": [{
                ""name"": ""child1""
        }]
    }]
}
</code></pre>

<p>and I have this interface</p>

<pre><code>export interface Child {
    parentId: string
    , name: string
}
</code></pre>

<p><strong>Question</strong></p>

<p>Which map should I do to obtain an array of children (in the response of the subscription), with the name and the id of the parent?</p>

<pre><code>getChildren(): Observable&lt;Child[]&gt; {    
    return this.http
        .get(API_URL)
        .//map function;
}
</code></pre>

<p>Or at least, tell me where to look to find some sort of answer</p>

<p>Thanks in advance.</p>
","1647238","","310726","","2017-03-09 07:24:10","2017-03-09 07:24:10","Rxjs map child objects plus parent field","<angular><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42689101","2","","42687528","2017-03-09 07:22:54","","1","","<p>You can use a single <code>map()</code> operator and then inside it use <code>Array.forEach()</code> and <code>Array.map()</code>:</p>

<pre><code>const Observable = Rx.Observable;

data = {
  ""parents"": [{
    ""id"": 1
    , ""children"": [{
      ""name"": ""child1""
    }
      , {
        ""name"": ""child2""
      }]
  }, {
    ""id"": 2
    , ""children"": [{
      ""name"": ""child1""
    }]
  }]
};

Observable.of(data)
  .map(data =&gt; {
    let results = [];
    data['parents'].forEach(item =&gt; {
      results = results.concat(item['children'].map(child =&gt; {
        return {
          'parentId': item.id,
          'name': child.name,
        };
      }));
    });

    return results;
  })
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p>This will print the following (an array containing objects as a single emission):</p>

<pre><code>[ { parentId: 1, name: 'child1' },
  { parentId: 1, name: 'child2' },
  { parentId: 2, name: 'child1' } ]
</code></pre>
","310726","","","","","2017-03-09 07:22:54","","","","2","","","","CC BY-SA 3.0"
"42689627","2","","42684600","2017-03-09 07:51:47","","6","","<p>A Subscriber extends both Subscription and Observer, adding state.  It exposes one method to change the state (namely, <code>unsubscribe()</code>), and
it also exposes observer's <code>next()</code>/<code>error()</code>/<code>complete()</code> methods,
but those methods now both honor state and also change state.</p>

<p>So, if I gave you a bare observer, you could call <code>next()</code>/<code>error()</code>/<code>complete()</code>
on it in any order, as many times as you want, even though it would be
terrible for you to call my <code>next()</code> after you've called my <code>complete()</code>.</p>

<p>On the other hand, if I gave you an Observer wrapped up in a
Subscriber, now there is state, and if you try to call <code>next()</code> on
that subscriber after you called <code>complete()</code>, I won't see it.
If you call <code>unsubscribe()</code>, I'll be detached.</p>

<p>When you call subscribe, as in</p>

<pre><code>subscriber = Rx.Observable.create(fn).subscribe(observer);
</code></pre>

<p>you're getting back the same observer, and only that observer, 
wrapped inside a Subscriber.   That's why you see the <code>next()</code>/<code>error()</code>/<code>complete()</code> methods.  But those methods are normally for internal use, and if you use them to feed an observer, it is not going to do what you expect:</p>

<pre><code>let observerA = {
    next: (x) =&gt; console.log('A: value: ' + x),
    error: (x) =&gt; console.log('A: error: ' + x),
    complete: () =&gt; console.log('A: completed')
}
let observerB = {
    next: (x) =&gt; console.log('B: value: ' + x),
    error: (x) =&gt; console.log('B: error: ' + x),
    complete: () =&gt; console.log('B: completed')
}

let observable = Rx.Observable.create(() =&gt; false);
let subscriberA = observable.subscribe(observerA);
let subscriberB = observable.map(x =&gt; 10*x).subscribe(observerB);
subscriberA.next(1); // only feeds observerA
// =&gt; ""A: value: 1""
subscriberB.next(2); // only feeds observerB
// =&gt; ""B: value: 2""  // What?
</code></pre>

<p>Odds are, for your use case, you will</p>

<ol>
<li>Want to use Subject because it gives you <code>next()</code>/<code>error()</code>/<code>complete()</code> interfaces that let you feed the front of the operator chain,</li>
<li>Want to use Subject because it lets you feed the same values to multiple observers,</li>
<li>Forget what you just learned about Subscribers because you're not going to use the <code>next()</code>/<code>error()</code>/<code>complete()</code> Subscriber interfaces.  Instead, think of the object returned by <code>subscribe()</code> as a Subscription only, and only use the <code>unsubscribe()</code> method on it.</li>
</ol>

<p>So:</p>

<pre><code>let subject = new Rx.Subject();
let subscriptionA = subject.subscribe(observerA);
let subscriptionB = subject.map(x=&gt;10*x).subscribe(observerB);
subject.next(3);
// =&gt; A: value: 3
// =&gt; B: value: 30
subscriptionA.unsubscribe()
subject.next(4);
// =&gt; B: value: 40
subscriptionB.unsubscribe()
subject.next(5);
// (no output)
</code></pre>

<p>Also see <a href=""https://stackoverflow.com/questions/36986548/when-to-use-asobservable-in-rxjs"">When to use asObservable() in rxjs?</a>.</p>
","4411346","","-1","","2017-05-23 11:46:30","2017-03-09 07:51:47","","","","1","","","","CC BY-SA 3.0"
"42701779","1","42706061","","2017-03-09 17:28:32","","1","586","<p>I am trying to stream a set of content through an observable and it stops after the first error.  It's simplist to think of this as an array of items as it behaves the same way.</p>

<ol>
<li>I am creating an observable from an array of item</li>
<li>mapping each item to a URL</li>
<li>calling the URL as a request-promise</li>
<li>perform a catch() that returns an observable.empty() in the event of an error</li>
</ol>

<p>Using RxJS 5:</p>

<pre><code>rx.Observable.from(array)
  .map(self.createUrl)
  .flatMap(x =&gt; {
            var options = {
            uri: url,
            headers: {
                ""Content-Type"": ""application/json""
            };
            return rx.Observable.fromPromise(request-promise(options));
        })
  .catch(() =&gt; {
    return rx.Observable.empty();})
  .subscribe( x =&gt; console.log('success:', x),
           e =&gt; console.log('error'),
           () =&gt; console.log('complete'));
</code></pre>

<p>When doing this sequence, the code stops after the first error is encountered.  I suspect the empty observable in #4 is terminating the observable but I'm not sure why.</p>

<p>My desired process is that all items in the array are processed regardless of errors - ultimately processing all successful items and resuming after each error.</p>
","289156","","289156","","2017-03-09 17:35:17","2017-03-09 21:46:22","rxjs completes an observable immediately after error instead of continuing","<node.js><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"42705511","1","42706293","","2017-03-09 21:13:33","","4","9725","<p>What I'm trying to achieve is to run a series of observables conditionally.</p>

<pre><code>return observable.map(response =&gt; response)
       .flatmap(response1 =&gt; observable1(response1))
       .flatmap(response2 =&gt; observable2(response2))
       .flatmap(response3 =&gt; observable3(response3))
</code></pre>

<p>I need to check the response1 and invoke the remaining observables if needed, else I need to return response1 and break the execution and so on. </p>

<p>I've gone through the following SO questions but they doesn't seem to answer my question</p>

<blockquote>
  <p><a href=""https://stackoverflow.com/questions/40273065/conditionally-choose-observable-in-rxjs"">Conditionally choose observable in RxJS</a></p>
  
  <p><a href=""https://stackoverflow.com/questions/34728827/rxjs-if-with-observable-as-conditional"">RXJS if with observable as conditional</a></p>
  
  <p><a href=""https://stackoverflow.com/questions/41946077/handle-error-in-rxjs-flatmap-stream-and-continue-processing"">Handle Error in RxJs flatMap stream and continue processing</a></p>
</blockquote>

<p>I'm new to rxjs, so forgive me if the question seems too lame.</p>

<p>Any help will be appreciated. </p>

<p>Thanks</p>
","4067241","","-1","","2017-05-23 12:25:40","2017-09-23 17:09:55","How to use the 'flatmap' operator conditionally ? (Angular 2/rxjs)","<angular><ecmascript-6><rxjs><rxjs5><flatmap>","4","2","2","","","CC BY-SA 3.0"
"42706061","2","","42701779","2017-03-09 21:46:22","","3","","<p>You just need to put the <code>catch()</code> inside the <code>flatMap</code>:</p>

<pre><code>rx.Observable.from(array)
  .map(self.createUrl)
  .flatMap(x =&gt; {
    var options = {
      uri: url,
      headers: {
        ""Content-Type"": ""application/json""
      }
    };
    return rx.Observable
      .fromPromise(request-promise(options))
      .catch(() =&gt; rx.Observable.empty());
  })
  .subscribe( x =&gt; console.log('success:', x),
           e =&gt; console.log('error'),
           () =&gt; console.log('complete'));
</code></pre>

<p>Now when then inner Observable emits an error it'll be caught immediately and won't propagate to the main stream through <code>.flatMap()</code>.</p>
","310726","","","","","2017-03-09 21:46:22","","","","0","","","","CC BY-SA 3.0"
"42706293","2","","42705511","2017-03-09 22:00:29","","6","","<p>This is like calling multiple consecutive HTTP requests where results depend on each other. This is where you want to use <code>concatMap()</code> instead because it'll wait until the Observable returned from the callback function completes.</p>

<p>It's hard to tell what exactly you want to do from your description but if you need to stop propagating the results (and avoid calling unnecessary HTTP requests) have a look <code>takeWhile()</code> operator or simple <code>filter()</code> operators.</p>

<p>With <code>filter()</code>:</p>

<pre><code>return observable
    .concatMap(response =&gt; response)
    .filter(response1 =&gt; response1.whatever === true)
    .concatMap(response1 =&gt; observable1(response1))
    .filter(response2 =&gt; response2.whatever === true)
    .concatMap(response2 =&gt; observable2(response2))
    .filter(response3 =&gt; response3.whatever === true)
</code></pre>

<p>This simply won't propagate the item further if it fails the <code>filter</code> test. However the source <code>observable</code> can still emit values that'll go through the chain. In other words the <code>filter</code> operator doesn't complete the chain.</p>

<p>With <code>takeWhile()</code>:</p>

<pre><code>return observable
    .concatMap(response =&gt; response)
    .takeWhile(response1 =&gt; response1.whatever === true)
    .concatMap(response1 =&gt; observable1(response1))
    .takeWhile(response2 =&gt; response2.whatever === true)
    .concatMap(response2 =&gt; observable2(response2))
    .takeWhile(response3 =&gt; response3.whatever === true)
</code></pre>

<p>If any of the <code>takeWhile()</code> result into false it'll complete the chain and no other value can be emitted.</p>
","310726","","641914","","2017-09-23 17:09:55","2017-09-23 17:09:55","","","","3","","","","CC BY-SA 3.0"
"42706426","1","","","2017-03-09 22:10:12","","0","134","<p>I have an angular service that I want to return an object I have defined in an interface.</p>

<p>The tutorial I am following assumes that the response is identical to the interface but in my scenario I want to process the object a bit in order to just return some of the data.</p>

<p>My service method based on the tutorial is:</p>

<pre><code>getResults(): Observable&lt;IPageSpeedResult&gt; {
        return this._http.get(this._pageSpeedApiUrl)
            .map((response: Response) =&gt; &lt;IPageSpeedResult&gt; response.json())
            .do(data =&gt; console.log('All: ' +  JSON.stringify(data)))
            .catch(this.handleError);
    }
</code></pre>

<p>How do I extend the map method to include my logic for building the IPageSpeedResult object from the returns data that I want?  I basically need to access an array and then iterate over it to populate the return object.</p>
","657477","","657477","","2017-03-10 10:54:58","2017-03-10 10:54:58","Custom mapping function for observable","<javascript><angular><rxjs5>","2","1","","","","CC BY-SA 3.0"
"42722038","2","","42640065","2017-03-10 15:29:31","","3","","<p>You could chain the streams and merge the results before mapping them to the JSX? Something like</p>

<pre><code>function view(sources) {

  const props$ = sources.props;
  const titleVDom$ = Title(sources).DOM;
  const calcVDom$ = Calculator(sources).DOM;

  const vdom$ = props$
    .mergeMap((props) =&gt; titleVDom$.map((title) =&gt; [ props, title ]))
    .mergeMap((data) =&gt; calcVDom$.map((calc) =&gt; data.push(calc)))
    .map((data) =&gt;
      &lt;section className=""hero is-fullheight is-primary""&gt;
      &lt;div className=""hero-head""&gt;
      &lt;/div&gt;
      &lt;div className=""hero-body""&gt;
        {data[0].showCalc ? {data[2]} : {data[1]}}
      &lt;/div&gt;
      &lt;div className=""hero-foot""&gt;
      &lt;/div&gt;
    &lt;/section&gt;
  );

  return vdom$;
}
</code></pre>

<p>You could also achieve the same thing using <code>forkJoin</code>:</p>

<pre><code>function view(sources) {

  const props$ = sources.props;
  const titleVDom$ = Title(sources).DOM;
  const calcVDom$ = Calculator(sources).DOM;

  return Rx.Observable.forkJoin([
    props$,
    titleVDom$,
    calcVDom$
  ]).map((data) =&gt;
      &lt;section className=""hero is-fullheight is-primary""&gt;
      &lt;div className=""hero-head""&gt;
      &lt;/div&gt;
      &lt;div className=""hero-body""&gt;
        {data[0].showCalc ? {data[2]} : {data[1]}}
      &lt;/div&gt;
      &lt;div className=""hero-foot""&gt;
      &lt;/div&gt;
    &lt;/section&gt;
  );
}
</code></pre>

<p>The difference being that forkJoin will subscribe to all of the Observables (triggering any action) simultaneously while the mergeMap method will chain them, only triggering the second and third when (and if) the preceding ones have emitted a value.</p>
","5564154","","5564154","","2017-03-10 15:41:16","2017-03-10 15:41:16","","","","0","","","","CC BY-SA 3.0"
"42723728","1","42725982","","2017-03-10 16:55:37","","0","48","<p>I have a scenario where I need to:</p>

<ol>
<li>Get route params</li>
<li>Use route params to call http service</li>
<li>Once http responds, use same route params to call a socket service</li>
<li>Each time socket responds, update data from http service</li>
</ol>

<p>Ideally I would like to keep this in a stream.</p>

<p>If only I could use <code>CombineLatest</code>? or involve the <code>Scan</code> operator?</p>

<pre><code>this.data$ = this.route.params
               .switchMap(params =&gt; {
                   return Observable.forkJoin([
                       Observable.of(params),
                       this.http.get('api', { prop1: params.prop1, prop2: params.prop2 })
                   ])
               }).combineLatest(([params, data]) =&gt; {
                    this.socket.get('event', { prop1: params.prop1, prop2: params.prop2 }),
                        updateData
                })


    private updateData(data, socketData): any[] {
        //only returns data = [params, data]
        //socketData always undef
        return data;
    }
</code></pre>
","2275792","","","","","2017-03-10 19:08:18","Angular & RxJS5 - updating data from http & socket","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42725982","2","","42723728","2017-03-10 19:08:18","","1","","<p>From how I understood your flow I don't need you need any of the <code>combineLatest</code> or <code>scan</code> operators, you just need to nest two <code>switchMaps</code>:</p>

<pre><code>this.data$ = this.route.params
                .switchMap(params =&gt; this.http.get('api', { prop1: params.prop1, prop2: params.prop2 })
                    .switchMap(httpResult =&gt; this.socket.get('event', { prop1: params.prop1, prop2: params.prop2 }) // assuming socket.get(...) is a perpetual stream
                        .map(socketResult =&gt; doWhateverCombinationWith(httpResult, socketResult))
                        .startWith(httpResult); // not sure if this is required, your question is kind of vague, but essentially this will cause the stream to emit the original httpResult before there is socketData
                    )
                );
</code></pre>
","1518765","","","","","2017-03-10 19:08:18","","","","1","","","","CC BY-SA 3.0"
"42732988","1","42734681","","2017-03-11 08:17:59","","9","5252","<p>For example, I have a function like this:</p>

<pre><code>export function timeRange(start: number, end: number): Rx.Observable&lt;number&gt; {
  return Rx.Observable.interval(1000)
  .map(n =&gt; n + start)
  .take(end - start + 1)
}
</code></pre>

<p>And I had a unit test that ran timeRange(10, 100) and asserted values against it.</p>

<p>The problem is the time intervals would make my test too long to run.  </p>

<p>How would you reduce the time interval without touching the function itself?</p>

<p>I tried reading the docs on schedulers but I didn't get it.</p>
","656334","","656334","","2017-03-11 09:22:32","2019-12-17 12:51:34","How do I test a function that returns an observable using timed intervals in rxjs 5?","<rxjs><rxjs5>","4","0","2","","","CC BY-SA 3.0"
"42734681","2","","42732988","2017-03-11 11:35:24","","7","","

<p>There're a couple of caveats but you can test your function as follows:</p>

<pre class=""lang-js prettyprint-override""><code>const Rx = require('rxjs');
const chai = require('chai');

function timeRange(start, end, interval = 1000, scheduler = Rx.Scheduler.async) {
  return Rx.Observable.interval(interval, scheduler)
    .map(n =&gt; n + start)
    .take(end - start + 1)
}

let scheduler = new Rx.TestScheduler(chai.assert.deepEqual);
let source = timeRange(2, 8, 50, scheduler);
let values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8};
scheduler.expectObservable(source).toBe('-----2----3----4----5----6----7----(8|)', values);

scheduler.flush();
</code></pre>

<p>A few points to notice:</p>

<ul>
<li><p>The function takes four arguments now. The interval and the <code>Scheduler</code> that we need to use to pass the <code>TestScheduler</code>.</p></li>
<li><p>The <code>TestScheduler</code> needs to get a method to deep compare objects. It'll be used to compare arrays of <code>Notification</code> objects.</p></li>
<li><p>You can't use <code>1000</code> because maximum time allowed is <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/testing/TestScheduler.ts#L10"" rel=""nofollow noreferrer"">hardcoded as 750</a>. Note, that this is just virtual time and is unrelated to real time so <code>50</code> we're using in this test isn't the same as <code>50ms</code>. We just need to fit inside that <code>750</code> time frame.</p></li>
<li><p>Then marble tests as typical marble test. See <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md</a> for more information. Just be aware that I can't use the same global <code>mocha</code> functions as the default RxJS operators.</p></li>
<li><p>I had to specify also the values because marble tests by default use strings and I need to force integers to ensure deep equality.</p></li>
</ul>

<p>You can test that this fails by changing one marble value:</p>

<pre class=""lang-js prettyprint-override""><code>let values = {'2': 42, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8};
</code></pre>

<p>Also, you can see what the notification objects are by printing them to console:</p>

<pre class=""lang-js prettyprint-override""><code>let scheduler = new TestScheduler((actual, expected) =&gt; {
   console.log('Actual:', actual, '\n\n', 'Expected:', expected);
   chai.assert.deepEqual(actual, expected);
});
</code></pre>

<p><strong>Using RxJS 5 <code>mocha</code> helpers</strong></p>

<p>At this moment RxJS 5 doesn't expose the <code>mocha</code> testing helpers. I'm actually using it in another project I'm working on right now (including generating diagram images). You can have a look here <a href=""https://github.com/martinsik/rxjs-extra"" rel=""nofollow noreferrer"">https://github.com/martinsik/rxjs-extra</a> into <code>package.json</code> what scripts I'm using. It works well but the setup is a little hard to understand. It involves downloading the RxJS 5 archive, copying a few files and patching it with a <a href=""https://github.com/martinsik/rxjs-plus/tree/master/spec-patch"" rel=""nofollow noreferrer"">couple of files</a>. Then the default options for <code>mocha</code> test are set with <a href=""https://github.com/martinsik/rxjs-plus/blob/master/test/mocha.opts"" rel=""nofollow noreferrer""><code>mocha.opts</code></a> that is based on the original from RxJS 5.</p>
","310726","","542251","","2019-12-17 12:51:34","2019-12-17 12:51:34","","","","0","","","","CC BY-SA 4.0"
"42734838","1","42734849","","2017-03-11 11:50:15","","0","876","<p>I have a simple instance where i create an observable that acts as a countdown timer by using a interval of 1000ms. Works great but my issue is it wont render the component until after the interval time, so if its 1000ms or 10000ms it takes that load to do first paint.</p>

<p>Is there a way i can skip interval on initial load? Here's what i currently have:</p>

<pre><code>this.countDown = Observable
  .interval(1000)
  .map(res=&gt;{ 

    /** I have some logic here. **/

  })
</code></pre>
","3620044","","4694994","","2017-08-22 20:10:59","2017-08-22 20:10:59","How to ignore Observable .interval() on component first load in Angular 2","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42734849","2","","42734838","2017-03-11 11:51:33","","6","","<p>You can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-timer"" rel=""noreferrer""><code>Observable.timer</code></a> instead that takes as the first argument the initial delay:</p>

<pre><code>Observable.timer(0, 1000)
    .whatever()
</code></pre>
","310726","","","","","2017-03-11 11:51:33","","","","2","","","","CC BY-SA 3.0"
"42742523","1","","","2017-03-12 01:03:39","","1","253","<p>I'm using rxjs to make an ajax request and would like to have an observable to show the progress. At <a href=""https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/doc/operators/ajax.md"" rel=""nofollow noreferrer"">this docs page</a> they describe a progressObserver but i cannot seem to get it to work:</p>

<pre><code>const progress = Observable.create();

progress.subscribe(
  ev =&gt; console.log('progress', ev),
  err =&gt; console.error(err),
  () =&gt; console.log('done')
);

ajax({
  method: 'POST',
  url: `http://my-server-route`
  body: formData, // code for formData not included
  progressObserver: progress // this is where the magic should happen?!
}).subscribe(
  () =&gt; console.log('ajax done'),
  () =&gt; console.log('ajax error')
);
</code></pre>

<p>The console throws: cannot read property subscribe of undefined on the line with this code:</p>

<pre><code>err =&gt; console.log(err)
</code></pre>

<p>I've tried some things with Subscriber but I'm not comfortable enough with rxjs to get this working.</p>
","1452244","","","","","2017-03-12 01:03:39","How to use rxjs progressOberserver","<javascript><ajax><rxjs><observable><rxjs5>","0","3","","","","CC BY-SA 3.0"
"42747954","1","","","2017-03-12 13:25:04","","0","687","<p>I assume that when testing code with Promises it is required to use fakeAsync/tick combination to guarantee that promises are resolves/rejects. This is because tick drains microtasks queue when invoked.</p>

<p>However, what about Observables? Should we also use fakeAsync/tick to guarantee that subscribe handler is invoked?
Looks like unit tests with Observables are completed fine, with all the subscribed Observer instances notified, without fakeAsync/tick so I'm not sure if this is required or not.</p>

<p>Thank you</p>
","5151355","","","","","2017-07-06 14:26:25","fakeAsync and tick when unit testing code with Promise and Observables","<unit-testing><angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42747998","1","42760005","","2017-03-12 13:28:46","","5","2634","<p>I have an rxjs ReplaySubject that will either emit a value or null depending on what environment I am on.  Meaning if in a certain environment I make a service call and get the data.  If I am not in that environment I just call next(null) on the replay subject.  In the component where I subscribe to this all works fine if the service call was made.  If I had done next(null) then my callback is never fired.  </p>

<p>My assumption is that the null value will not be returned because it was set before I subscribed but I thought that was the entire point of ReplaySubject. I have googled then until I ran out of different ways to explain the issue and all I get is the read me file for ReplaySubject.  Hoping somebody can tell me what I am doing wrong.  I thought maybe it was because I passed in null so I passed in ""Hello"" instead and still nothing.  Here is a code sample:</p>

<pre><code>public Data = new ReplaySubject&lt;any&gt;(1);
init(){
 if(!window.Something){
   //subscribe callback is never fired in this case.
   this.Data.next(null);
 }else{
    this.http.get(...).map(...{
     //this works 
     this.Data.next(result);
    });
 }}
</code></pre>

<p>The mistake I made actually had nothing to do with Rx.  I can't remember exactly but it was making so the condition was never true.  This kept the code from executing.</p>
","446518","","446518","","2017-05-09 10:19:03","2017-05-09 10:19:03","Rx.ReplaySubject subscription callback not being called","<angular><rxjs><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"42750266","1","","","2017-03-12 16:55:16","","11","23965","<p>I got a problem with typescript and RxJs v5.</p>

<h2>Please Look the UPDATE sections.</h2>

<p>I did <code>yarn add @reactivex/rxjs</code> (also <code>yarn add rxjs</code>) and on my index.ts did <code>import Rx from '@reactivex/rxjs';</code> and got this error: <a href=""https://i.stack.imgur.com/GVBMq.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/GVBMq.png"" alt=""VSCode Error""></a></p>

<p>Also, if I run <code>node ./node_modules/.bin/tsc</code> I got this error back too <code>error TS2307: Cannot find module '@reactivex/rxjs'.</code></p>

<h2>UPDATE</h2>

<p>Also doing</p>

<pre><code>import { Observable } from 'rxjs/Observable'
</code></pre>

<p>throws the <em>same</em> error
<a href=""https://i.stack.imgur.com/HjASg.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/HjASg.png"" alt=""enter image description here""></a>.</p>

<h2>UPDATE 2</h2>

<p>Well this seems to be more related to TS itself than to RxJS.</p>

<pre><code>""compilerOptions"": {
    ""module"": ""commonjs"",
    ""allowJs"": true,
    ""outDir"": ""dist"",
    ""target"": ""es2015"",
    ""noImplicitAny"": true,
    ""noEmit"": true,
    ""strictNullChecks"": true,
    ""suppressExcessPropertyErrors"": false,
    ""suppressImplicitAnyIndexErrors"": false,
    ""allowUnreachableCode"": false,
    ""allowUnusedLabels"": false,
    ""noImplicitReturns"": true,
    ""noFallthroughCasesInSwitch"": true,
    ""lib"": [
        ""es2015"",
        ""dom""
    ]
}
</code></pre>

<p>Having this ^ configuration seems to fix the VSCode issues, but running <code>tsc</code> against <code>src/index.ts</code> doesn't work</p>

<pre><code>node_modules/rxjs/Observable.d.ts(69,60): error TS2693: 'Promise' only refers to a type, but is being used as a value here.
</code></pre>
","1405803","","1405803","","2017-03-12 23:31:53","2021-05-13 19:14:53","RxJs and Typescript. TS2307: Cannot find module '@reactivex/rxjs'","<typescript><rxjs><rxjs5>","8","3","2","","","CC BY-SA 3.0"
"42760005","2","","42747998","2017-03-13 09:15:23","","1","","<p>Using <code>.next(null)</code> on any Observable is correct. Everything is a value in RxJS including <code>null</code> and <code>undefined</code>. So the problem is probably somewhere else than this. </p>

<p>This is what you're doing right now and it both cases (when you uncomment the second <code>if</code>) it works as should. The value is stored in the <code>ReplaySubject</code> and then replayed or pushed directly to the current observer:</p>

<pre><code>let subject = new ReplaySubject(1);

// if (!window.document) {
if (!window.whatever) {
  subject.next(null);
} else {
  setTimeout(() =&gt; {
    subject.next('Hello');
  }, 500);
}

subject.subscribe(val =&gt; console.log(val));
</code></pre>

<p>See live demo: <a href=""https://jsbin.com/cigocak/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/cigocak/edit?js,console</a></p>
","310726","","","","","2017-03-13 09:15:23","","","","3","","","","CC BY-SA 3.0"
"42780734","1","","","2017-03-14 08:08:42","","3","55","<p>What's the difference/relationship between those two github groups:</p>

<ul>
<li>Reactive-Extensions (<a href=""https://github.com/Reactive-Extensions"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions</a>)</li>
<li>ReactiveX (<a href=""https://github.com/ReactiveX"" rel=""nofollow noreferrer"">https://github.com/ReactiveX</a>)</li>
</ul>
","1253826","","310726","","2017-03-19 15:17:46","2017-03-19 15:17:46","What's the relationship between Reactive-Extension and ReactiveX","<rxjs><reactive-programming><rxjs5><reactivex><reactive-extensions-js>","1","0","","","","CC BY-SA 3.0"
"42793905","1","45259623","","2017-03-14 18:33:55","","1","1405","<p>wondering how to bubble up errors from observable to subscriberâs err function without terminating the stream</p>

<p>for example, making http calls, when the result is a 404 or any other error i catch and throw error in stream. This causes stream to terminate and enter err function block in subscriber</p>

<p>However, is there a way to catch and keep stream open and pass on value to error block in the subscriber.  This is to deal with the said 404 error in the subscribers and not in stream.  For doing things like error handling and UI changes based on error.</p>

<p>UPDATE WITH CODE:
I have a subscriber like so:</p>

<pre><code>this.blahService.getSomething(id)
  .subscribe((response: Response) =&gt;{

      this.cancelBtnText= 'Cancelled';
      this.canCancel = false;


    },
    err =&gt;{
      console.log('ERRROR:::', err);
    });
</code></pre>

<p>and Subject like so:</p>

<pre><code>return this.http.get(this.config.apiEndpointUrl, this.options)
  .map((r: Response) =&gt; &lt;blah&gt;r.json())
  .catch((error: any) =&gt; {
    console.error('A friendly error occurred', error);
    return Observable.throw(error.message || error);
  });
</code></pre>

<p>on http errors this will cause <code>catch</code> function to be called.  However, when i throw error this terminates stream and all its subscribers, so the next time the event comes around to call service my subscriber is no longer listening to it and is completely unsubscribed, and therefore, no information is ever sent back to subscribe.  </p>

<p>This changes when i change the <code>throw</code> to a <code>.empty()</code>, in the service, since this does not terminate stream but now the <code>error</code> function in subscriber is no longer called. </p>
","2697567","","2697567","","2017-03-14 18:49:45","2017-07-22 22:33:44","Keeping Observable Stream Alive after Thrown Error","<angular><observable><rxjs5>","1","4","","","","CC BY-SA 3.0"
"42809658","1","42809962","","2017-03-15 12:23:35","","30","18542","<p>I'm trying to use <code>forkJoin</code> on two Observables. One of them starts as a stream... If I subscribe to them directly I get a response, <code>forkJoin</code> isn't firing though. Any ideas?</p>
<pre><code>private data$: Observable&lt;any[]&gt;;
private statuses$: Observable&lt;any[]&gt;;
private queryStream = new Subject&lt;string&gt;();    

....

this.data$ = this.queryStream
    .startWith('')
     .flatMap(queryInput =&gt; {
            this.query = queryInput
            return this._companyService.getCompanies(this.queryRequired + ' ' + this.query, this.page, this.sort);
                })
            .share();
    
...

Observable.forkJoin(this.statuses$, this.companies$)
            .subscribe(res =&gt; {
                console.log('forkjoin');
                this._countStatus(res[0], res[1]);
            });


// This shows arrays in the console...

this.statuses$.subscribe(res =&gt; console.log(res));
this.companies$.subscribe(res =&gt; console.log(res));

// In the console
Array[9]
Array[6]
</code></pre>
","1013182","","74089","","2021-03-05 08:50:10","2021-09-20 12:28:56","Observable forkJoin not firing","<angular><typescript><rxjs><rxjs5>","6","0","5","","","CC BY-SA 4.0"
"42809962","2","","42809658","2017-03-15 12:37:01","","18","","<p>A very common problem with <code>forkJoin</code> is that it requires all source Observables to emit at least one item and all of them have to complete.</p>

<p>In other words if <code>this.statuses$</code> or <code>this.companies$</code> doesn't emit any item and until they both complete the <code>forkJoin</code> won't emit anything.</p>

<pre><code>this.statuses$.subscribe(
    res =&gt; console.log(res),
    undefined,
    () =&gt; console.log('completed'),
);
</code></pre>
","310726","","310726","","2017-03-15 12:51:22","2017-03-15 12:51:22","","","","4","","","","CC BY-SA 3.0"
"42818208","1","42818382","","2017-03-15 18:45:09","","1","169","<p>My specific situation is that I want to run a cache race between localforage and a rest endpoint that looks like:</p>

<ul>
<li>start request for resource</li>
<li>if localforage returns before rest, signal that to subscribers</li>
<li>when rest returns, signal that to subscribers</li>
<li>if rest returned before localforage, don't signal the localforage response.</li>
</ul>

<p>The idea here is that in most cases, localforage will have some, probably out-of-date data that can be returned really quickly, but that the data will be updated when the rest endpoint request completes. I could just do a merge on these two streams, assuming that localforage will always return before the rest request (a not-unreasonable assumption, but still an assumption). The problem is that if the rest response is authoritative and is for some reason faster than the localforage response, the out-of-date cache data will be signaled <em>after</em> the correct rest response.</p>

<p>So I kind of want to do a <code>.race()</code> on these streams, but not really, since if streamA completes first, I want to merge with streamB. If streamB completes first, I want to cancel streamA.</p>

<p>So far, I've played with <code>takeUntil</code> and <code>race</code>, and this kind of works:</p>

<pre><code>const streamA = Rx.Observable.fromFOO();
const streamB = Rx.Observable.fromBAR().publish();
const cacheRace = streamA.takeUntil(streamB).merge(streamB);
cacheRace.subscribe(listener);
streamB.connect();
</code></pre>

<p>I need to use the publish / connect thing, because streamB would otherwise actually kick off two REST requests- one for takeUntil and one for merge. This is pretty unsatisfying. It feels like the operator I'm missing is takeUntilButNextOnce() or something, or an operator that merges two streams but completes the merged stream if one of the two streams completes (but doesn't complete if the other completes).</p>

<p>I can <em>instead</em> fiddle around with custom observables and/or subjects and just dealing with preserving state inside the closed-over scope, which then lets me use plain old logic here.</p>
","1596772","","","","","2017-03-15 20:53:48","Signalling the end of an observable, but capturing that signal","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42818382","2","","42818208","2017-03-15 18:53:25","","1","","<p>A simple <code>merge</code> in combination with a <code>takeUntil</code> should do it - also just <code>share</code> the rest-call, that should take care of the double-request issue that you mentioned.</p>

<pre><code>const fromRest$ = myRestService.getDataFromServer().share();
const fromForage$ = ...;
data$ = Observable.merge(
    fromRest$,
    fromForage$.takeUntil(fromRest$)
);
</code></pre>
","1518765","","1518765","","2017-03-15 20:53:48","2017-03-15 20:53:48","","","","0","","","","CC BY-SA 3.0"
"42825763","1","42827023","","2017-03-16 05:11:10","","6","1395","<p><code>share()</code> operator is applied to a BehaviorSubject. 
BehaviorSubject has initial value.</p>

<p>Goal is to create a single shared subscribtion. <strong>But this shared subscribtion does not seem to work when BehaviorSubject has an initial value.</strong></p>

<p>Getting unexpected results.</p>

<p>Code shown below:</p>

<pre><code>let subject = new Rx.BehaviorSubject(0);
let published = subject
                  .do(v =&gt; console.log(""side effect""))
                  .share();

published.subscribe((v) =&gt; console.log(v+"" sub1""));
published.subscribe((v) =&gt; console.log(v+"" sub2""));

subject.next(1);
</code></pre>

<p>Result: </p>

<pre><code>""side effect""
""0 sub1""
""side effect""
""1 sub1""
""1 sub2""
</code></pre>

<p>Expected Result: </p>

<pre><code>""side effect""
""0 sub1""
""1 sub1""  &lt;------------- this is missing from actual result
""side effect""
""1 sub1""
""1 sub2""
</code></pre>
","4104145","","310726","","2017-03-17 13:43:34","2017-03-17 13:43:34","BehaviorSubject initial value not working with share()","<rxjs><rxjs5><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"42827023","2","","42825763","2017-03-16 06:44:42","","6","","<p>I understand what's confusing here.</p>

<p>The <code>BehaviorSubject</code> emits only on subscription. However, you're using the <code>share()</code> operator which internally is just a shorthand for <code>publish()-&gt;refCount()</code>. When the first observer subscribes it triggers the <code>refCount()</code> and it makes the subscription to its source which causes the side-effect in <code>do()</code> and also prints the default value in the observer <code>0 sub1</code>:</p>

<pre><code>""side effect""
""0 sub1""
</code></pre>

<p>Then you subscribe with another observer but this subscription is made only to the <code>Subject</code> class inside the <code>publish()</code> operator (that's what it's made for). So the second observer won't receive the default <code>0</code> nor trigger the side effect.</p>

<p>When you later call <code>subject.next(1)</code> it'll made the last three lines of output:</p>

<pre><code>""side effect""
""1 sub1""
""1 sub2""
</code></pre>
","310726","","","","","2017-03-16 06:44:42","","","","1","","","","CC BY-SA 3.0"
"42832974","1","42837588","","2017-03-16 11:35:24","","16","10122","<p>Pretty new to redux-observables, rxjs and observables. Wanted to know how can I handle another action, say 'ActionTwo' in the same epic </p>

<pre><code>const Epic1 = (action$,store) =&gt; {
return action$.ofType('ActionOne')
 .mergeMap((action) =&gt; {
      return ajax({'method': 'GET', 'url': 'someUrl')
         .map(response =&gt; resultActoin(action.userId, response.response));


       }
  );
 }
</code></pre>

<p>Something like</p>

<pre><code>const Epic1 = (action$){
   if('ActionOne') make a API call.
   if('ActionTwo') make some other API call.
   else do nothing.

}
</code></pre>
","7720321","","","","","2018-05-01 17:44:56","How to handle multiple action types in one epic? Any cons of doing the same?","<redux><observable><rxjs5><redux-observable>","1","0","1","","","CC BY-SA 3.0"
"42834982","1","","","2017-03-16 13:07:20","","1","63","<p>RxJS 5 fails to work when injected as content script in firefox web extension and giving the following errors:<br>
<code>TypeError: a.Math.random is not a function
TypeError: Rx.Subject is not a constructor
</code></p>
","6868871","","","","","2017-03-16 13:51:07","RxJS 5 firefox web extensions: TypeError: Math.random is not a function","<rxjs5><firefox-addon-webextensions>","1","0","","","","CC BY-SA 3.0"
"42836517","1","42837505","","2017-03-16 14:12:34","","1","305","<p>I'm using redux-persist and redux-observable in my application and noticed that my API calls wrapped in observable are happening before store state is restored. And restoration overrides fetched value with stale data.
How could rootEpic be paused, while buffering, until persist/REHYDRATE action arrives?</p>
","4513589","","4513589","","2017-03-16 14:40:45","2017-03-17 13:31:44","Pause rootEpic until persist completion","<redux><rxjs><react-redux><rxjs5><redux-observable>","2","0","","","","CC BY-SA 3.0"
"42837505","2","","42836517","2017-03-16 14:52:23","","1","","<p>If you wanna wait until an ""event"" occurred you can use <code>.skipUntil</code>. For example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const action$ = new Rx.Subject();

// In your epic
action$
  .skipUntil(action$.filter(({ type }) =&gt; type === 'hydrated'))
  .subscribe(x =&gt; console.log(x));

// ""Rehydrate""
action$.next({ type: 'hello!' });
action$.next({ type: 'hello?' });
action$.next({ type: 'any body there?' });
action$.next({ type: 'hydrated' });
action$.next({ type: 'do' });
action$.next({ type: 'you' });
action$.next({ type: 'see' });
action$.next({ type: 'me' });
action$.next({ type: 'now' });</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>I guess, in order to not add this to all of your epics, you could <code>.mergeMap()</code> your root epic or something :)</p>

<hr>

<p><em>After discussion in the comments below</em>:</p>

<p>This issue might also occur with other middleware. Thus, it might be a better solution to not fire any actions until the re-hydration is done.</p>
","298969","","298969","","2017-03-17 13:31:44","2017-03-17 13:31:44","","","","4","","","","CC BY-SA 3.0"
"42837588","2","","42832974","2017-03-16 14:56:11","","38","","<p>Is it the same API call? If so, <code>ofType()</code> accepts more than one type. You can just do <code>action$.ofType('ActionOne', 'ActionTwo')</code>.</p>

<p>If you want to make a request to another API/URL, I would recommend to make another epic. You can ""merge"" all you epics with <code>combineEpics</code> see: <a href=""https://redux-observable.js.org/docs/basics/SettingUpTheMiddleware.html"" rel=""noreferrer"">https://redux-observable.js.org/docs/basics/SettingUpTheMiddleware.html</a></p>
","298969","","","","","2017-03-16 14:56:11","","","","4","","","","CC BY-SA 3.0"
"42839497","1","","","2017-03-16 16:19:15","","2","96","<p>In RxJS4, the following code would freeze your environment:</p>

<pre class=""lang-js prettyprint-override""><code>Rx.Observable.of(10)
  .repeat()
  .take(1)
  .subscribe(value =&gt; {
     console.log(value);
  });
</code></pre>

<p>That's because it would run <code>repeat</code> on an immediate scheduler, and never get to <code>take</code>. Now in RxJS5 there is no immediate Scheduler, but if I run that same code, everything works as expected. What exactly changed and what scheduler are we running on? I thought the default was <em>no</em> scheduler by default, and that would freeze <code>repeat</code> too, if I understand correctly.</p>
","78640","","106909","","2017-03-16 19:26:40","2017-03-16 19:26:40","Confused about default Scheduling behavior in RxJS5","<rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42840616","1","42840971","","2017-03-16 17:11:44","","1","909","<p>I am looking forward to merge streams and refreshing all subscribers.</p>

<p>For functional programming purposes concat do not update the current observable and I do not get what is the right way to do it.</p>

<p>This how I would like things to happen : </p>

<pre class=""lang-js prettyprint-override""><code>var observable = Rx.Observable.from(['stream1']);
var subscription = observable.subscribe(
    function(x) {
        console.log('Next: ' + x);
    },
    function(err) {
        console.log('Error: ' + err);
    },
    function() {
        console.log('Completed');
    });
observable.concat(Rx.Observable.from(['stream2']));
</code></pre>

<p>This code only reads the first stream then goes to completed.
When concat it creates an new Observable that I dont really want as I already subscribed to the first one.</p>

<p>What is the right way to do it as I can not even push into the first observable ?</p>

<p>Thanks !</p>
","6144622","","106909","","2017-03-16 19:25:21","2017-03-16 19:25:59","RxJs merging streams","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42840971","2","","42840616","2017-03-16 17:29:27","","2","","<p>What you are trying to do is not exactly possible like that, but you basically have two options to go, both involve the usage of a <code>Subject</code>:</p>

<p>1) Manual emitting of data</p>

<pre class=""lang-js prettyprint-override""><code>const obs$ = Rx.Observable.of(""stream1"");
const subj$ = new Rx.Subject();

Rx.Observable.merge(obj$, subj$)
    .subscribe(
        x =&gt; console.log('Next: ' + x),
        x =&gt; console.log('Error: ' + x),
        () =&gt; console.log('Complete')
    );

subj$.next(""stream2"");
subj$.next(""stream3"");
</code></pre>

<p>However: In this scenario, the <strong>complete</strong> will never be called, because a <code>Subject</code> never completes on its own - so if you need your <code>complete</code>-handler to be triggered you would have to add a manual <code>subj$.complete();</code> to the end.</p>

<hr>

<p>2) Multicasting through a subject</p>

<pre class=""lang-js prettyprint-override""><code>const obs$ = Rx.Observable.of(""stream1"");
const subj$ = new Rx.Subject();

subj$.subscribe(
    x =&gt; console.log('Next: ' + x),
    x =&gt; console.log('Error: ' + x),
    () =&gt; console.log('Complete')
);

obs$.subscribe(x =&gt; subj$.next(x));
const obs2$ = Rx.Observable.of(""stream2"");
obs2$.subscribe(x =&gt; subj$.next(x));
</code></pre>

<p>In this scenario the <code>Subject</code> will basically act as a <em>""proxy""</em> that will only propagate data, but no error- or complete-triggers.</p>

<p>Both solutions are not really ""nice"" - but maybe you can outline your use-case a little better, I'm sure there's a proper solutions for it that does not involve any complicated workaround.</p>

<hr>

<p>In case you just want to have a way to continuously provide data form a perpetual Observable, you should use a <code>BehaviorSubject</code> - it works in a way, that you can emit data on it and subscribe to it at the same time:</p>

<pre class=""lang-js prettyprint-override""><code>class Service {
    public data$ = new BehaviorSubject(someInitialDataOrNull);

    public getData() {
        makeSomeHttpCall()
            .subscribe(data =&gt; data$.next(data));
    }
}

class Component {
    constructor() {
        theService.data$.subscribe(data =&gt; console.log(data));
    }
}
</code></pre>

<p>Here is a link to the old docs of the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md"" rel=""nofollow noreferrer""><code>BehaviorSubject</code></a> (it basically still works the same way expect for <code>onNext</code> being <code>next</code> now, ect...)</p>
","1518765","","106909","","2017-03-16 19:25:59","2017-03-16 19:25:59","","","","2","","","","CC BY-SA 3.0"
"42886144","1","42886181","","2017-03-19 11:39:13","","1","80","<p>I am a newbie to angular 2 and Observable.
I have a function <code>getCurrentUserDetails()</code> as service, which returns an observable with the details of current user. I am using this on every route access.</p>

<p>I want to limit my http request to database each time i access this function.</p>

<p>I want to create a function which returns the data if available else create a http request get the data and return that data.</p>

<p>Below is the code which i tried: </p>

<pre><code>private currentUser: any;
getCurrentUserDetails(){

        if(!this.currentUser){
            this.currentUser = this._http.get('getcurrentuserdetails').map((res:Response) =&gt; res.json()).share();
            return this.currentUser;
        }
        else {
            return this.currentUser;
        }
    }
</code></pre>
","5124462","","310726","","2017-03-19 11:44:15","2017-09-23 17:08:42","HTTP request as Observables","<angular><rxjs><observable><rxjs5><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"42886181","2","","42886144","2017-03-19 11:43:01","","1","","<p>I guess you want to do something like this instead of the <code>share()</code> operator:</p>

<pre><code>publishReplay()-&gt;refCount()-&gt;take(1)
</code></pre>

<p>This means that every time you subscribe to this Observable you'll receive the cached value and the <code>take(1)</code> operator will make the chain complete immediately without subscribing to the source and causing more HTTP requests.</p>
","310726","","641914","","2017-09-23 17:08:42","2017-09-23 17:08:42","","","","0","","","","CC BY-SA 3.0"
"42896948","1","","","2017-03-20 06:15:48","","2","1533","<p>I'm using angular 2 to create a file upload queue with chunk upload support.</p>

<p>here is the basic idea, I have a <code>added</code> EventEmitter fires when a validated file selected, then in ngOnInit I listen to this <code>added</code> event and map to a bunch of uploads like this:</p>

<pre><code>this.start
.concatMap(item =&gt; item.file.size &gt; this.chunkSize ? this.uploadChunks(item) : this.upload(item),
    (outer: QueueFile, inner: Response) =&gt; ({item: outer, response: inner}))
.subscribe((x: any) =&gt; this.uploadSucceed(x.item, x.response),
    (x: any) =&gt; this.uploadFailed(x.item, x.resp));
</code></pre>

<p>and the <code>uploadChunks</code> function like this:</p>

<pre><code>private uploadChunks(item: QueueFile) {
    return Observable.range(0, Math.ceil(item.file.size / this.chunkSize), Scheduler.queue)
        .map(x =&gt; [x * this.chunkSize, Math.min(item.file.size, (x + 1) * this.chunkSize)])
        .map(x =&gt; this.createChunkFormData(x[0], x[1], item))
        .concatMap(data =&gt; this.http.post(this.url, data));
}
</code></pre>

<p>and I want to provide a cancel upload of chunks, but in this design, it seems there is no way to stop the chunks upload.</p>

<p>If I record the subscription to the start event, and unsubscribe it, then the whole queue will stops uploading.</p>

<p>Is it anyway to stop the uploadChunks? or maybe my method is totally wrong, if that so, how can I do this with rxjs?</p>
","2293291","","","","","2017-03-20 06:15:48","is there any way to cancel rxjs's concatMap's inner observable?","<angular><rxjs5>","0","3","","","","CC BY-SA 3.0"
"42897681","1","","","2017-03-20 07:08:57","","1","316","<p>I have an array of N (integer) urls. I want to make web requests.</p>

<p><strong>Requirements</strong></p>

<ol>
<li>update status: we are starting to make web requests</li>
<li>Requests are made one after another</li>
<li>Before each web request we update the status which URL we are going to call.</li>
<li>Update status: Finish (after all urls received)</li>
</ol>

<p>I want to emit following events</p>

<ul>
<li>Begin with urls</li>
<li>Emit: String: Staring web requests</li>
</ul>

<p>Loop Start (urls should be loaded 1 after another, not all at once. Data is emitted as soon as its received)</p>

<ul>
<li>Emit: String: Loading url N[i]</li>
<li>Emit: Object: Data of url N[i]</li>
</ul>

<p>Loop End</p>

<ul>
<li>Emit: String: Finish</li>
</ul>

<p>Following is my solution. I am looking for better solution</p>

<p><a href=""http://jsbin.com/dajuwoxigo/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/kotizid/edit?html,js,console</a></p>

<pre><code>//Fake Webrequest. Returns a promise
function fakeWebrequest(url){
    return new Promise(function(resolve){
        console.log('Making Web request for: '+url);
        setTimeout(function(){
          resolve('RESPONSE: of: '+ url);
        },500);
    });
}


//Urls lists
//null added at end to indicate end. Its a hack
let urls$ = Rx.Observable.of(['url 1','url 2',null]);


//Status Update
let status1$= urls$.map(()=&gt;'Start downloading...')

//Queue
let queue$ =  urls$.flatMap((url)=&gt;url)
              .concatMap((url)=&gt;{
                    if(url==null){
                        return Rx.Observable.of(null)
                    }
                    let status$= Rx.Observable.of(`Loading ${url}`);
                    let promise$= Rx.Observable.fromPromise(fakeWebrequest(url))
                    return status$.merge(promise$);
              })

let finalSeq$ = status1$.merge(queue$);



finalSeq$.subscribe(function(res){
    if(res==null){
        //End
    }else{
        console.log(res);
    }    
})
</code></pre>

<p><strong>Problems with my code</strong></p>

<ol>
<li>null added at end of url</li>
<li>Subscribe event has to handle different type of data, which mean I have to add ifs to guess which event was fired. eg if res in subscribe is string it must be status. if its null sequence must have ended.</li>
</ol>

<p>I am looking for a better solution. Please suggest.</p>
","183200","","183200","","2017-04-13 05:26:36","2017-04-13 05:26:36","RxJs: Sequence of Web Request. What's a better solution than mine?","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"42903684","1","","","2017-03-20 12:31:35","","3","2813","<p>I have a very simple periodic activity which is scheduled by RxJS 5 and I'm a bit curious about how to unit test this type of code using RxJS 5:</p>

<pre><code>start() {
  this._subscription = Observable
                        .interval(this._interval, SchedulerProvider.getScheduler())
                        .subscribe(_ =&gt; this.doSomething());
}
stop() {
  this._subscription.unsubscribe();
}
</code></pre>

<p>What I tried is to stub my <code>SchedulerProvider.getScheduler</code> function to return a <code>new TestScheduler()</code> during my tests (by default it just returns <code>undefined</code> so the production code just uses the default scheduler) - and then try to setup virtual ""ticks"" for the interval:</p>

<pre><code>myTestSchedulerInstance.createColdObservable('xxxxxxxx', {x: 1}); // tick ten times
unitUnderTest.start();
myTestSchedulerInstance.flush();
... assert that doSomething() should be called 10 times ....
</code></pre>

<p>But it doesn't work. I guess <code>createColdObservable</code> and <code>createHotObservable</code> just returns a new observable based on the marble-syntax input string - but this doesn't affect my interval.</p>

<p>I went through the docs and I'm a bit confused now about the marble testing in RxJS 5, because the examples in the docs (and everywhere else) look like this:</p>

<ul>
<li>in the first step: create a test scheduler</li>
<li>then create a cold/hot observable using this scheduler</li>
<li>your unit under test applies some operators on the created observable - which produces another observable</li>
<li>then you assert on the resulting observable using <code>expectObservable</code></li>
</ul>

<p>But my use-case is different. I don't want to return the <code>Observable.interval</code>, because I'm only interested in the side-effect of my subscription. Is it possible to write such a test using RxJS 5?</p>

<p>The only alternatives which I see right now:</p>

<ul>
<li>use sinon's fake timers</li>
<li>inside <code>start()</code>, map the side effect to the interval and after subscribing to it, return the observable containing the side effect -> and use it in the assertion using <code>expectObservable</code></li>
</ul>

<p>But each solution seems to be a bit messy.</p>
","1307609","","","","","2017-03-20 12:31:35","How to unit test Observable.interval with RxJS 5?","<unit-testing><rxjs><reactive-programming><sinon><rxjs5>","0","7","","","","CC BY-SA 3.0"
"42904267","1","42904906","","2017-03-20 12:59:26","","4","1761","<p>I'm using mousemove event to create an observable.</p>

<pre><code>Observable.fromEvent(document, 'mousemove')
</code></pre>

<p>I need to emit every 10-th event. What do I do? </p>
","5663381","","310726","","2017-03-20 13:30:28","2018-07-25 20:03:09","How to emit every n-th value?","<javascript><rxjs><reactive-programming><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"42904906","2","","42904267","2017-03-20 13:30:10","","8","","<p>I can think of four different ways to do it:</p>

<p><strong>bufferCount()</strong></p>

<pre><code>Observable.range(1, 55)
  .bufferCount(10)
  .map(arr =&gt; arr[arr.length - 1])
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p><strong>windowCount()</strong></p>

<pre><code>Observable.range(1, 55)
  .windowCount(10)
  .switchMap(window =&gt; window.takeLast(1))
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p><strong>debounce()</strong></p>

<pre><code>let source = Observable.range(1, 55).publish();

source
  .debounce(val =&gt; debounceNotifier)
  .subscribe(val =&gt; console.log(val));

let debounceNotifier = source
  .bufferCount(10)
  .publish();
debounceNotifier.connect();

source.connect();
</code></pre>

<p><strong>scan()</strong></p>

<pre><code>Observable.range(1, 55)
  .scan((acc, val) =&gt; {
    if (acc.length === 10) {
      acc = [];
    }
    acc.push(val);
    return acc;
  }, [])
  .filter(acc =&gt; acc.length === 10)
  .map(acc =&gt; acc[acc.length - 1])
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p>However, when using <code>scan()</code> it'll will discard the last value <code>55</code>.</p>

<p>See demo for all of them: <a href=""https://jsbin.com/yagayot/14/edit?js,console"" rel=""noreferrer"">https://jsbin.com/yagayot/14/edit?js,console</a></p>
","310726","","","","","2017-03-20 13:30:10","","","","2","","","","CC BY-SA 3.0"
"42911585","1","","","2017-03-20 18:44:25","","0","134","<p>I'm creating an RXJS observable to perform a task given an input of an array of URLs:</p>

<pre><code>let scrapeObservable: Observable&lt;IProduct&gt; = Observable.from(urlList)
  .mergeMap(url =&gt; Observable.forkJoin(
    Observable.of(url),
    getPageDom(url), // Returns Observable that completes with PageDom
    getExtractionRule(parseURL(url)[""Host""]) // returns observable with data needed to perform work on the page dom
  ).delay(timeDelay += intervalTime)) // scrapes one url every set interval - using 0 in this case
  .mergeMap(result =&gt; getProductInfoFromDOMObservable(result[0], result[1], result[2][0], result[2][1], requiredFields)) // performs work on page dom using data above.
  .merge(maxConcurrentRequests) // prevents more than an certain number of processes from taking place simultaneously.
  .catch(handleError);
</code></pre>

<p>When I subscribe to this observable it appears as though for some inputs (rather large lists of URLs >500) it never calls complete or error.  It's like the observable just hangs.  I can't figure out why this is happening but it is causing problems with my code.  For small inputs it works correctly, and it doesn't always fail for large inputs, just some of the time.</p>

<p>Any ideas on what might be causing this behavior?</p>
","5186877","","5186877","","2017-03-20 18:50:55","2017-03-20 18:50:55","Rather Complex RXJS Observable never completing","<javascript><rxjs><rxjs5>","0","3","","","","CC BY-SA 3.0"
"42913345","1","","","2017-03-20 20:28:00","","1","1638","<p>Jquery request objects have a property by the name 'data' which is used to set form data and make a form request with the right headers.</p>

<p>I wanted to achieve the same in rxjs ajax but could not find a way. 
The only exhaustive list of request configuration properties I could find was this <a href=""https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/doc/operators/ajax.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/doc/operators/ajax.md</a></p>
","7720321","","1518765","","2017-03-21 07:42:29","2017-03-21 07:59:25","How to make a FORM PUT request through rxjs ajax?","<ajax><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42924938","1","","","2017-03-21 10:49:39","","1","52","<p>This question is about RxJS5.</p>

<p>Context: I tried using TestScheduler, it all works fine until I plug in the promises.</p>

<p>For instance let's take ""someFunction"" from the example below. How would I validate the output expected within 1 minute period (without actually having to wait 1 minute in the test).</p>

<pre><code>const asyncFunction = new Promise( (resolve) =&gt;
   setTimeout((() =&gt; resolve(1)), 0)
);

const someFunction = () =&gt;
  Rx.Observable.fromInterval(15000)
    .flatMap( each =&gt; Rx.Observable.from(asyncFunction()))
    .map(each =&gt; each + 1)
</code></pre>
","6306919","","","","","2017-03-21 13:01:57","How do I unit test RxJS5 when using promises?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"42934075","1","42934476","","2017-03-21 17:19:41","","2","484","<p>I have the following simple code:</p>

<pre><code>let a: Observable&lt;any&gt; = Observable.from([1,2,3,4,5]).share();
let b: Subject&lt;any&gt; = new Subject();

a.subscribe(b)
a.subscribe(value =&gt; console.log(""New observable value: "" + value));
b.subscribe(value =&gt; console.log(""New subject value: "" + value));

b.next(""value1"");
b.next(""value2"");
</code></pre>

<p>The only console lines I see are the ones with ""New observable value: "" for each of the values in the array. If I comment out line 3, then I get all the ""New observable value"" lines and the ""New subject value"" lines, but the subjects do not of course get any of the values omitted by the observable (part of the array).</p>

<p>So basic question - why is this? Why doesn't my subject see any of the array elements 1,2,3,4,5? It subscribes to the observable, so it should get these events (<code>share()</code> should broadcast to all subscribers), but this seems to be a misunderstanding on my part.</p>

<p>What I'm looking for here is to make a single subscription to the subject, and see all the values that come in from the observable plus any values emitted via the call to <code>next()</code>. Is my code wrong, or am I trying to do things the wrong way?</p>
","4247200","","310726","","2017-03-21 17:40:11","2017-03-21 17:46:59","Subjects subscribing to observables","<angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"42934476","2","","42934075","2017-03-21 17:41:58","","2","","<p>Your basic issue is the order of your subscriptions, by the time you are subscribing your <code>console.log</code> the <code>Subject</code> already received the data. (Check out the code-sample below to see it running)</p>

<p>The second issue, why the <code>next(""value1"")</code> is not working, is because <code>a.subscribe(b)</code> will also call the <code>.complete()</code> on <code>b</code> after the emission of <code>1,2,3,4,5</code>.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let a = Rx.Observable.from([1,2,3,4,5]).share();
let b = new Rx.Subject();

b.subscribe(value =&gt; console.log(""New subject value: "" + value));
a.subscribe(value =&gt; console.log(""New observable value: "" + value));
a.subscribe(b);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<hr>

<p><strong>One</strong> way how to fix this: Don't subscribe the complete <code>Subject</code>, but just the <code>next</code>-call. Keep in mind though, that this is just <strong>one</strong> way to get this to work, depending on your specific case there might be a better solution available.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let a = Rx.Observable.from([1,2,3,4,5]).share();
let b = new Rx.Subject();

b.subscribe(value =&gt; console.log(""New subject value: "" + value));
a.subscribe(value =&gt; console.log(""New observable value: "" + value));
a.subscribe(data =&gt; b.next(data));

b.next(""value1"");
b.next(""value2"");</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","1518765","","2017-03-21 17:46:59","2017-03-21 17:46:59","","","","1","","","","CC BY-SA 3.0"
"42954976","1","42955181","","2017-03-22 14:45:23","","1","554","<p>I'm not sure if this is a bug in rxjs or I'm missing something. When returning an error throwing observable in a <code>switchMap</code> the error isn't thrown by the main observable.</p>

<pre><code>export class AppComponent {

    constructor() {
        this.doStuff();
    }

    doStuff() {
      Observable.of('any observable').switchMap(() =&gt; {
        return this.oops();
      });
    }

    oops() {
      return Observable.throw('doh');
    }
}
</code></pre>

<p>Here is a plunker: <a href=""https://plnkr.co/edit/f6dgGe3qvwX1Myn3PRfR"" rel=""nofollow noreferrer"">https://plnkr.co/edit/f6dgGe3qvwX1Myn3PRfR</a></p>

<p>There is no error thrown in the console. Why is that? I thought <code>switchMap</code> would just 'replace' the Observable with another?</p>
","2170547","","310726","","2017-03-22 14:55:32","2017-03-22 14:55:32","rxjs: switchMap ignores error","<angular><rxjs><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"42955181","2","","42954976","2017-03-22 14:53:21","","3","","<p>The Observable chain is not going to do anything until you subscribe to it.</p>

<pre><code>doStuff() {
  Observable.of('any observable').switchMap(() =&gt; {
    return this.oops();
  }).subscribe();
}

oops() {
  return Observable.throw('doh');
}
</code></pre>

<p>Note, that the projection function for the <code>switchMap()</code> can throw an exception and it'll be sent as an <code>error</code> notification. So you could also just use the following and the result will be the same:</p>

<pre><code>oops() {
  throw new Error('doh');
}
</code></pre>
","310726","","","","","2017-03-22 14:53:21","","","","0","","","","CC BY-SA 3.0"
"42976902","1","42977531","","2017-03-23 13:04:32","","1","929","<p>Nothing too much serious here, just curious.<br>
I wanted to make an example for something and came up with this code : </p>

<pre><code>const { Observable, Subject } = Rx

const timeout$ = new Subject()

const obs$ = Observable
  .of(1)
  .takeUntil(timeout$)
  .delay(2000)
  .subscribe(x =&gt; console.log(x))

timeout$.next()
timeout$.complete()
</code></pre>

<p>I thought this code would <strong>not</strong> display the <code>console.log</code> but it does.</p>

<p>Can someone explain me why ?<br>
Is this a bug or just a bad understanding from me about <code>takeUntil</code> ?</p>

<p>Here's a Plunkr to demo <a href=""https://plnkr.co/edit/wpKztBabnBeIuNZS28wu?p=info"" rel=""nofollow noreferrer"">https://plnkr.co/edit/wpKztBabnBeIuNZS28wu?p=info</a></p>
","2398593","","","","","2021-09-08 11:54:36","RxJs : Weird behavior with takeUntil?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"42977531","2","","42976902","2017-03-23 13:31:13","","6","","<p>Notice that if you switch the order of the <code>takeUntil()</code> and <code>delay()</code> it won't be emitted as expected:</p>
<pre><code>Observable
  .of(1)
  .delay(2000)
  .takeUntil(timeout$)
  .subscribe(x =&gt; console.log(x));
</code></pre>
<p>What you see happens because the <code>delay()</code> schedules the emission before that <code>takeUntil()</code> sends <code>complete</code> notification.<br />
Right now in RxJS 5.2.0 the <code>takeUntil()</code> operator doesn't force unsubscribe from its source which is the problem here. So when the <code>takeUntil()</code> is notified by <code>timeout$</code> it remains subscribed to its source Observable and therefore the scheduled emission from <code>delay()</code> isn't disposed.</p>
<p>Notice there's no <code>this.unsubscribe()</code> call when handling emission from the notification Observable: <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/takeUntil.ts#L61"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/operator/takeUntil.ts#L61</a></p>
<p>There're other operators with the same behavior. For example <code>first()</code> and <code>takeWhile()</code>.</p>
<p>On the other hand for example the <code>take()</code> operator does unsubscribe:</p>
<p><a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/take.ts#L80"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/operator/take.ts#L80</a></p>
<p>This behavior is in fact reported and whether this is a bug or not is being discussed right now:</p>
<ul>
<li><p><a href=""https://github.com/ReactiveX/rxjs/issues/2455"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2455</a></p>
</li>
<li><p><a href=""https://github.com/ReactiveX/rxjs/pull/2470"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/2470</a></p>
</li>
<li><p><a href=""https://github.com/ReactiveX/rxjs/pull/2463"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/2463</a></p>
</li>
<li><p><a href=""https://github.com/ReactiveX/rxjs/pull/2457"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/2457</a></p>
</li>
</ul>
","310726","","310726","","2021-09-08 11:54:36","2021-09-08 11:54:36","","","","1","","","","CC BY-SA 4.0"
"42982578","1","","","2017-03-23 17:06:01","","3","180","<p>Inside a <code>.catch()</code>, how can I find the value that caused the error?</p>

<p>For example, lets say you have code like this:</p>

<pre><code>Rx.Observable.of(42)
.map((val) =&gt; {
  throw new Error('oops!');
})
.catch((err) =&gt; {
  // how can I get `42` here?
});
</code></pre>

<p>How can you know what ended up causing the error?</p>

<p>For bonus points, is this possibly in <code>.finally()</code>?</p>
","1017787","","3743222","","2017-04-10 00:04:19","2017-04-10 00:04:19","In RxJS, how can you get the value that caused an error?","<javascript><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"43004667","2","","42367561","2017-03-24 16:31:35","","0","","<p>I finally came up with the with the behavior I was looking for. Using only rxjs native methods. :)</p>

<pre class=""lang-js prettyprint-override""><code>const currentTime$ = props$.pluck('currentTime');
const $trailingCurrentTime = new Subject();

const stream$ = Observable
  .merge(currentTime$, $trailingCurrentTime)
  .audit(currentTime =&gt; setCurrentTime$(currentTime))
  .filter(currentTime =&gt; {
    if (currentTime !== player.currentTime) {
      $trailingCurrentTime.next(currentTime);
    }
    return currentTime === player.currentTime;
  });
</code></pre>

<p><a href=""http://jsbin.com/wedefojuyo/edit?js,console,output"" rel=""nofollow noreferrer"">http://jsbin.com/wedefojuyo/edit?js,console,output</a></p>
","7598072","","","","","2017-03-24 16:31:35","","","","0","","","","CC BY-SA 3.0"
"43036928","1","","","2017-03-27 02:14:21","","2","580","<p>With promises, we can use a variant of <code>.then</code> to split up the chain when an error occurs. Here is an example using <code>fetch</code></p>

<pre><code>fetch('http://website.com').then(
  // Perform some logic
  (response) =&gt; response.json().then(({ answer }) =&gt; `Your answer: ${answer}`),
  // Skip json parsing when an error occurs
  (error) =&gt; 'An error occurred :(',
).then(console.log);
</code></pre>

<p>This allows me to skip the response processing logic and only respond to errors that were raised in the original fetch statement. Something similar in RxJS might look like this:</p>

<pre><code>Observable.fromPromise(fetch('http://website.com'))
  // if I put .catch here, the result will be piped into flatMap and map
  .flatMap(response =&gt; response.json())
  .map(({ answer }) =&gt; `Your answer: ${answer}`)
  // if I put .catch here, errors thrown in flatMap and map will also be caught
  .subscribe(console.log);
</code></pre>

<p>As the comments in the code state, I can't simply put a catch operator in as it doesn't have the same behaviour as my promise chain.</p>

<p>I know I can get it with custom operators involving materialising, or merging an error catching observable with this one, but it all seems like pretty major overkill. Is there a simple way to achieve the promise chain behaviour?</p>
","1136593","","1136593","","2017-03-27 02:22:28","2017-11-15 10:49:08","Split observable on error in RxJS","<javascript><promise><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43040302","1","","","2017-03-27 07:27:41","","0","698","<p>I want to integrate Facebook login into an Angular 2 app. The Facebook SDK is loaded asynchronously and I want to wrap this async call in an Observable.</p>

<pre><code>fbInit() {
 var deferred = Observable.create(observer =&gt; {
  this._window.instance.fbAsyncInit = () =&gt; {
    this._window.instance.FB.init({
      appId      : 'xxxxxxxxxxxxxxx',
      xfbml      : true,
      version    : 'v2.8'
    });
    this._window.instance.FB.AppEvents.logPageView();
    console.log(""fbInit"");
    observer.next();
  };

  (function(d, s, id){
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) {return;}
    js = d.createElement(s); js.id = id;
    js.src = ""//connect.facebook.net/en_US/sdk.js"";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
 });
 return deferred;
}
</code></pre>

<p>(this._window.instance returns the window object)</p>

<p>Once this call has succeeded, I want to get the login status of the user by using the FB object, that is put on the global window object. I used RxJs' <code>bindCallback</code> function to wrap a normal callback into an Observable.</p>

<pre><code>getFbStatus() {
  console.log(""getFbStatus"");
  return Observable.bindCallback(this._window.instance.FB.getLoginStatus);
}
</code></pre>

<p>Now I want to consecutively run the async queries one after another:</p>

<p>1) initialize the FB SDK and put <code>FB</code> on the global <code>window</code> object<br>
2) check login status<br>
3) do stuff depending on login status</p>

<p>Using promises this task would be very simple. After some research I found that <code>flatMap</code> or <code>concat</code> would solve my problem. Neither attempts were successful. This is what I've tried:</p>

<pre><code>const initFb$ = this.fbInit();
const getFbStatus$ = this.getFbStatus();
const combined$ = Observable.concat(initFb$, getFbStatus$);

combined$.subscribe(
  res =&gt; console.log(res),
  err =&gt; console.error(err)
)
</code></pre>

<p>When running this, the following error occurs:  </p>

<pre><code>TypeError: Cannot read property 'getLoginStatus' of undefined
</code></pre>

<p>It seems that <code>getFbStatus</code> is called, before the Facebook SDK is loaded.</p>

<p>What am I missing here?
Any help greatly appreciated.</p>
","5599949","","","","","2017-04-18 13:21:05","Wrapping the Facebook login into RxJS Observables in an Angular2 app","<angular><facebook-javascript-sdk><facebook-login><rxjs5><angular2-observables>","1","0","2","","","CC BY-SA 3.0"
"43068860","1","43069830","","2017-03-28 11:53:25","","0","757","<p>I'm pretty new to RXxJS, so I might be looking at it the wrong way, but I have a service that returns an array of 'Verpleegperiodes':</p>

<pre><code>export class Verpleegperiode{
  verpleegperiodeId?: number;
  beginDatumUur?: moment.Moment;
  eindDatumUur?: moment.Moment;
  bed: string;
  kamer: string;
  dienst: Dienst;
  dossier: Dossier;
}
</code></pre>

<p>And in my component, I'm trying to get an array of 'Verpleegperiodes' grouped by the 'kamer' property, which is for ex. '101', '102', '103', ...
So I'd like an Observable stream of for ex.: </p>

<pre><code>[{verpleegperiodeId: 1, kamer: '101'},{verpleegperiodeId: 3, kamer: '101'}]
[{verpleegperiodeId: 6, kamer: '102'}]
</code></pre>

<p><strong>Or even better, if this is possible with RxJS</strong>:</p>

<pre><code>{ kamer: '101', verpleegperiodes: [{verpleegperiodeId: 1, kamer: '101'},{verpleegperiodeId: 3, kamer: '101'}] }
{ kamer: '102', verpleegperiodes: [{verpleegperiodeId: 6, kamer: '102'}] }
</code></pre>

<p>For this, I've found documentation for Group By: <a href=""https://www.learnrxjs.io/operators/transformation/groupby.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/transformation/groupby.html</a></p>

<p>Using this, I've added this code (using the dienstId parameter of the route) to produce this:</p>

<pre><code>this.activeVerpleegperiodes$ = this._route.params
  .switchMap((params: Params) =&gt; this._infohosService.getActiveVerpleegperiodesByDienstId(params['dienstId']))
  .flatMap(verpleegperiodes =&gt; verpleegperiodes)
  .groupBy(vp =&gt; { console.log(vp.kamer); return vp.kamer; })
  .flatMap(group =&gt; { return group.reduce((acc, curr) =&gt; { return [...acc, curr]; }, []); })
  .map(f =&gt; { console.log(f); return f; } );
</code></pre>

<p>I have added some console.log's to check the values. The console.log in the groupBy part returns: </p>

<pre><code>101
101
102
...
</code></pre>

<p>I've already put some console.log's in the reduce function to log the acc and curr values, which are grouping the correct values in 1 array.
However, the console.log in the map function never logs. Not even undefined or [].</p>

<p>In my template I try to print the async value of the stream too:</p>

<pre><code>{{ activeVerpleegperiodes$ | async | json }}
</code></pre>

<p>This is always null.</p>

<p>How can I get the required result?</p>
","3711246","","","","","2020-06-11 11:23:45","Angular 2 RxJS groupBy flatMap empty","<angular><rxjs><reactive-programming><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43069830","2","","43068860","2017-03-28 12:38:58","","1","","<p>If you array of <code>Verpleegperiodes</code> arrives in one time, you don't need RxJs.  </p>

<p><strong>RxJs is here to help you manipulate values over time.</strong></p>

<p>You may be interested in something like that : <a href=""https://stackoverflow.com/a/34890276/2398593"">https://stackoverflow.com/a/34890276/2398593</a> (or lodash, but lodash seems overkill only for that).</p>
","2398593","","2398593","","2020-06-11 11:23:45","2020-06-11 11:23:45","","","","0","","","","CC BY-SA 4.0"
"43104030","1","","","2017-03-29 20:56:46","","4","4782","<p>I have a third party library that I am intending to integrate with RxJS. This is a messaging library called Tiger Text. According to them I can listen to an event called messages and when the stream has a message I can use it to further utilize it. The code snippet for the same is as follows:-</p>

<pre><code>var client = new TigerConnect.Client({ defaultOrganizationId: 'some-org-id' })

client.signIn('user@mail.com', 's3cr3t', { udid: 'unique-device-id' }).then(function (session) {
  onSignedIn(session)
})

function onSignedIn(session) {
  console.log('Signed in as', session.user.displayName)

  client.messages.sendToUser(
    'someone@mail.com',
    'hello!'
  ).then(function (message) {
    console.log('sent', message.body, 'to', message.recipient.displayName)
  })

  client.events.connect()

  client.on('message', function (message) {
    console.log(
      'message event',
      message.sender.displayName,
      'to',
      message.recipient.displayName,
      ':',
      message.body
    )
  })
}
</code></pre>

<p>Now please have a look at the place where you have the below mentioned piece of code.</p>

<pre><code>client.on('message', function (message) {
    console.log(
      'message event',
      message.sender.displayName,
      'to',
      message.recipient.displayName,
      ':',
      message.body
    )
  })
</code></pre>

<p>I wanted to know how to use RxJS so as to create an observable out of this piece of code so as to subscribe to the stream and whenever we have a change I take the new data and process it as I wish.</p>

<p>Please Advice.</p>
","519305","","1071020","","2017-10-31 23:11:57","2019-05-01 19:32:53","How to Observe a Custom Event using RXJS in Angular 2?","<javascript><angular><rxjs><rxjs5>","2","5","3","","","CC BY-SA 3.0"
"43106827","1","43106966","","2017-03-30 01:16:11","","5","3263","<p>I'am currently switched from promises to observables. I am using Redux-Observable for my react app. Basically, I am looking for the best operator that will enable mutliple, concurrent ajax calls and return the responses when all the observables have sucessfully finished executing. 
Here is a code snippet from my app.</p>

<pre><code>let epicPostAd = (action$, store, {ajax}) =&gt;
  action$.ofType(POST_AD)
   .debounceTime(1000)
   .mergeMap(({ payload }) =&gt;
     ajax(generateAjaxRequestSetting(POSTS_URL, 'post', payload,CT_JSON))
      .map(response =&gt; postAdSuccessful(response))
      .catch(e =&gt; Observable.of(postAdUnsuccessful(e.xhr.response)))
      .takeUntil(action$.ofType(LOCATION_CHANGE))
    )
</code></pre>

<p>It is a simple ajax request that posts given ad and dispatches <code>POST_AD_SUCCESSFUL</code> when response is 201 else dispatches <code>POST_AD_UNSUCCESSFUL</code> on error. 
But the issues is I want to make subsequent ajax observable stream when there is a response. Such as </p>

<pre><code>.map(response =&gt; /* start a stream of ajax observables then process the response */)
</code></pre>

<p>I will appreciate if you show me the optimal way of achieving this.</p>
","6712925","","","","","2017-03-30 02:11:17","Concurrent Ajax requests with Rxjs","<ajax><rxjs><rxjs5><redux-observable>","2","0","1","","","CC BY-SA 3.0"
"43106966","2","","43106827","2017-03-30 01:30:49","","10","","<p>Sounds like you're looking for the <a href=""https://www.learnrxjs.io/operators/combination/forkjoin.html"" rel=""noreferrer""><code>forkJoin</code> operator</a>.</p>

<p>It will subscribe to all the Observables you pass to it and after they <strong>all</strong> complete, it will emit the last value from each inside an array.</p>

<p>It wasn't entirely clear where in your Epic you wanted to do this, so I just made a generic example:</p>

<pre><code>const somethingEpic = (action$, store, { ajax }) =&gt;
  action$.ofType(SOMETHING)
    .mergeMap(() =&gt;
      Observable.forkJoin(
        ajax('/first'),
        ajax('/second'),
        ajax('/third')
      )
      .do(results =&gt; {
        // the results is an array, containing each
        const [first, second, third] = results;
        console.log(first, second, third);
      })
      .map(results =&gt; ({
        type: 'SOME_RESULTS',
        results
      }))
    );
</code></pre>

<p>Technically, it supports a final <code>resultSelector</code> argument you can use instead of using the <code>map</code> operator after it, but I tend not to use it because I've found it's less clear with only negligible performance benefits in common redux-observable style cases. But it's still good to know. Can be handy for more ""data-normalization"" stuff rather than ""transform this into an action"" stuff.</p>

<pre><code>const somethingEpic = (action$, store, { ajax }) =&gt;
  action$.ofType(SOMETHING)
    .mergeMap(() =&gt;
      Observable.forkJoin(
        ajax('/first'),
        ajax('/second'),
        ajax('/third'),
        results =&gt; ({
          type: 'SOME_RESULTS',
          results
        })
      )
    );
</code></pre>

<hr>

<p>ALSO, if you're asking yourself ""what operator do I use?"" you should try the operator wizard located in the documentation: <a href=""http://reactivex.io/rxjs/"" rel=""noreferrer"">http://reactivex.io/rxjs/</a></p>

<p>Scroll down to the part that says:</p>

<blockquote>
  <p><strong>Do you need to find an operator for your problem? Start by choosing an option from the list below:</strong></p>
  
  <ul>
  <li>I have one existing Observable, and...</li>
  <li>I have some Observables to combine together as one Observable, and...</li>
  <li>I have no Observables yet, and...</li>
  </ul>
  
  <p><strong>Hint: open your DevTools to experiment with RxJS.</strong></p>
</blockquote>

<p>Though in this case, <code>forkJoin</code> is correctly suggested but when you click on it, it isn't yet documented :sadface: But a google search would present many different websites explaining what it does and how to use it (in RxJS and in other Rx implementations in other languages). Like <a href=""https://www.learnrxjs.io/operators/combination/forkjoin.html"" rel=""noreferrer"">this helpful website</a></p>
","1770633","","1770633","","2017-03-30 01:37:25","2017-03-30 01:37:25","","","","2","","","","CC BY-SA 3.0"
"43107336","1","43108109","","2017-03-30 02:15:17","","4","1341","<p>I'm collecting all the events of an Observable to a <code>data</code> array:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const obs$ = Rx.Observable
  .interval(500)
  .take(4);

let data = [];
const start = performance.now();

obs$.subscribe(
  value =&gt; {
    data.push({
      time: performance.now() - start,
      data: value
    });
  },
  () =&gt; {},
  () =&gt; {
    console.log(JSON.stringify(data, null, 2));
  }
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.2.0/bundles/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Is it possible to ""foresee the future"" and get the same <code>data</code> array <strong>without waiting 2 seconds</strong>?</p>

<p>To clarify, I'm trying to find a way to wrap somehow a given Observable (<code>obs$</code> in the example above) with a custom timer/scheduler so I could get the events immediately.</p>
","247243","","247243","","2017-03-30 02:56:57","2017-03-30 03:41:12","How to get RxJS Observable events in zero time?","<javascript><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"43108109","2","","43107336","2017-03-30 03:41:12","","5","","<p>You can create an instance of the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/scheduler/VirtualTimeScheduler.ts"" rel=""noreferrer""><code>VirtualTimeScheduler</code></a> and can specify it in the call to <code>interval</code>.</p>

<p>If you then call <code>flush</code> on the scheduler after subscribing, the events will be emitted immediately:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const scheduler = new Rx.VirtualTimeScheduler();

const obs$ = Rx.Observable
  .interval(500, scheduler)
  .take(4);

let data = [];
const start = scheduler.now();

obs$.subscribe(
  value =&gt; {
    data.push({
      time: scheduler.now() - start,
      data: value
    });
  },
  () =&gt; {},
  () =&gt; {
    console.log(JSON.stringify(data, null, 2));
  }
);

scheduler.flush();</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.2.0/bundles/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","6680611","","","","","2017-03-30 03:41:12","","","","2","","","","CC BY-SA 3.0"
"43111948","1","43112392","","2017-03-30 08:05:30","","2","459","<p>I'm trying to use RxJS and Angular2 to build a search field. I have a simple text input field that I'm observing for valueChanges. </p>

<p>I then use the inputted value to call a first REST service which returns a search results object that contains a list of customers.</p>

<p>Then for each customer returned I call a second REST service to get the customer details and store the returned details in the customer object.</p>

<p>My screen then loops over the customers to display them.</p>

<p>But I have two problems that I can't seem to figure out:</p>

<ol>
<li>I want the results to appear as soon as the first service returns
and then update the screen when the second service returns but at
the moment nothing displays until all the service calls are
completed. </li>
<li>When someone changes the input field I want the results to disappear
immediately but for some reason that is no happening and I can't
figure out why e.g. if I enter in a search term that returns no
matches, the results from the previous search remain on screen.</li>
</ol>

<p>My code looks like:</p>

<pre class=""lang-js prettyprint-override""><code>this.customers = this.term.valueChanges
            .filter(term =&gt; {
                return term !== null;
            })
            .switchMap(term =&gt; {
                return this.customerService.search(term)
            })
            .map(searchResults =&gt; {
                return searchResults.customers;
            })
            .flatMap(customers =&gt; {
                if (customers.length &gt; 0) {
                    // this.customers = customers;
                    return Observable.forkJoin(
                        customers.map((customer: Customer) =&gt; {
                            return this.customerDetailService.getDetails(customer)
                                .map((details: any) =&gt; {
                                    customer.details = details;
                                    return customer;
                                });
                        }));
                }
                return customers;
            });
</code></pre>



<p>And the screen looks like:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;div *ngIf=""customers|async; let customers""&gt;

    &lt;ul&gt;
        &lt;li *ngFor=""let customer of customers""&gt;

           {{customer.name}}
           {{customer.details.age}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>



<p>Any help would be appreciated.</p>

<p>Thanks,
Kevin.</p>
","4014","","","","","2017-03-30 18:21:50","Angular2 & RxJS multiple HTTP calls - display as soon as first response returned","<angular><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"43112392","2","","43111948","2017-03-30 08:28:22","","1","","<p>What is <code>this.customers</code> ? A combination of the initial fetch and every update that comes later. So this should work :</p>

<pre class=""lang-js prettyprint-override""><code>let search = this.term.valueChanges
  .filter(term =&gt; term !== null)
  .switchMap(term =&gt; this.customerService.search(term))
  .map(searchResults =&gt; searchResults.customers);

let details = search.switchMap(customers =&gt; {
  if (customers.length &gt; 0) {
    // this.customers = customers;
    return Observable.forkJoin(
      customers.map((customer: Customer) =&gt; {
        return this.customerDetailService.getDetails(customer)
          .map((details: any) =&gt; {
            customer.details = details;
            return customer;
          });
      }));
  }
  return customers;
});

this.customers = Observable.merge(search, details);
</code></pre>
","3633742","","3633742","","2017-03-30 18:21:50","2017-03-30 18:21:50","","","","9","","","","CC BY-SA 3.0"
"43123110","1","","","2017-03-30 16:11:31","","2","1433","<p>I am using rxjs <code>publishReplay(1)</code> and <code>refCount</code> to cache http response. What's the best way to put an expiry time for the caching. I am getting a token using http call which expires every 1 hour. </p>

<pre><code>@Injectable()
export class SearchService{
public url: string;
private token:Observable&lt;any&gt; = null;

constructor(private _http:Http){

}

getSecurityToken(url:string): any {

    headers.append(""securitycode"",""*******"");

    if(!this.token){
        this.token = this._http.post(url,{headers:headers})
            .map(this.extractData)
            .publishReplay(1)
            .refCount()
            .catch(this.handleError);
    }
    return this.token;
}     


private extractData(res: Response) {
    console.log(res.status);
    if(res.status == 204) { 
        return [];
    }
    else{
        let body = res.json();
        return body;
    }
}

private handleError (error: any) {
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : 'Server error';
   console.error(errMsg); // log to console instead
   return Observable.throw(errMsg);
}
</code></pre>
","3951332","","3951332","","2017-03-30 18:00:33","2021-04-23 00:08:12","How to add an expiry time for cached Angular2 http response using rxjs observables","<angular><caching><rxjs><rxjs5><angular2-observables>","2","0","","2021-04-23 13:19:29","","CC BY-SA 3.0"
"43125495","1","43127368","","2017-03-30 18:16:57","","3","341","<p>I am experimenting with a Redux-like pattern to maintain state in a service for a particular feature. My intent is that a consumer can subscribe to separate streams of data by calling <code>getItem1()</code> or <code>getItem2()</code>, then call action methods such as <code>initializeItem1()</code> or <code>initializeItem2()</code> on the service as desired to dispatch actions that will change the state of the store. In the service, data may be obtained either from an http call or something else as is simulated in the provided plnkr.</p>

<p><a href=""https://plnkr.co/edit/f3HLp5C8ckIpjNsM8dTm?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/f3HLp5C8ckIpjNsM8dTm?p=preview</a></p>

<p>Specifically, what I do not understand is why, in my sample code, the observable returned by <code>getItem1()</code> does not emit a value unless I change <code>this.service.initializeItem1().subscribe();</code> to <code>this.service.initializeItem1().subscribe(() =&gt; {});</code>. Can someone please explain if this seems like a bug in rxjs, if there is a good / known explanation as to why this behaves this way, or if I am just missing something? I appreciate any insight the community can provide me with. Thanks.</p>

<p><strong>Component</strong></p>

<pre><code>//our root app component
import {Component, OnInit} from '@angular/core'
import {Observable} from 'rxjs/Rx'
import {SampleService} from './sample.service'

@Component({
  selector: 'my-app',
  template: `
    &lt;div&gt;
      &lt;h2&gt;Item 1 Value&lt;/h2&gt;
      &lt;div&gt;{{ item1 }}&lt;/div&gt;

      &lt;h2&gt;Item 2 Value&lt;/h2&gt;
      &lt;div&gt;{{ item2 }}&lt;/div&gt;
    &lt;/div&gt;
  `,
})
export class App implements OnInit {
  name:string;
  item1: string;
  item2: string;
  constructor(private service: SampleService) { }

  ngOnInit() {
    this.item1 = this.service.getItem1().subscribe(item1 =&gt; this.item1 = item1);
    this.item2 = this.service.getItem2().subscribe(item2 =&gt; this.item2 = item2);

    /* broken */
    //Item 1 does not display
    //Item 2 displays as expected
    this.scenario1();

    /* works */
    //Item 1 displays as expected
    //Item 2 displays as expected
    // this.scenario2();
  }

  private scenario1() {
    this.service.initializeItem1().subscribe();
    this.service.initializeItem2().subscribe();
  }

  private scenario2() {
    this.service.initializeItem1().subscribe(() =&gt; {});
    this.service.initializeItem2().subscribe();
  }
}
</code></pre>

<p><strong>Service</strong></p>

<pre><code>import {Injectable} from '@angular/core'
import {Observable, Subject} from 'rxjs/Rx'
import { Http, Headers } from '@angular/http';

@Injectable()
export class SampleService {
  constructor(private http: Http) { }
  private headers: Headers = new Headers({ 'Content-Type': 'application/json' });
  private _store: Subject&lt;any&gt; = new Subject&lt;any&gt;();
  private store = this._store.asObservable()
      .startWith({})
      .scan(reducer);

  public initializeItem1(): Observable&lt;string&gt; {
    return this.http.get('api/foobar')
      .map(response =&gt; response.json().item).do(data =&gt; {
        console.log('not hit in scenario 1, but hit in scenario 2:', data);

        this._store.next({
          type: 'INITIALIZE_1',
          payload: data
        });
      });
  }

  public initializeItem2(): Observable&lt;string&gt; {
    return Observable.of('foobar-2').do(data =&gt; {
      console.log('hit in scenario 1 and scenario 2:', data);

      this._store.next({
        type: 'INITIALIZE_2',
        payload: data
      });
    });
  }

  getItem1(): Observable&lt;string&gt; {
        return this.store.map(store =&gt; store.settings1);
    }

  getItem2(): Observable&lt;string&gt; {
      return this.store.map(store =&gt; store.settings2);
  }
}

function reducer(store, action) {
    switch(action.type) {
        case 'INITIALIZE_1':
            return Object.assign({ }, store, {
                initialSettings: action.payload,
                settings1: action.payload
            });
        case 'INITIALIZE_2':
            return Object.assign({ }, store, { settings2:action.payload });
        default:
            return store;
    }
}
</code></pre>
","3174602","","3174602","","2017-03-31 12:50:30","2017-03-31 12:50:30","RXJS do operator not getting hit in stream when subscribe is called without a callback parameter","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43126397","1","","","2017-03-30 19:04:42","","0","66","<p>I have a component that fetches content from a service to process it. The thing is I can have multiple calls to this function, which results in duplicates on my array. I the following workaround:</p>



<pre class=""lang-ts prettyprint-override""><code>    getOptions(): Observable&lt;PickQuality[]&gt; {
    console.log(""MY LENGTH: "", this.options.length) // &lt;=== Always returns 0 because the callback hasn't run yet
    if(this.options.length == 0) {
        this.championService.getChampions()
            .subscribe(champions =&gt; {
                champions.forEach(champion =&gt; this.options.push(new PickQuality(champion, 0)));
                this.reevaluate();
                this.optionsSubject.next(this.options);
            });

        return this.optionsSubject.asObservable();
    }
    else
        return Observable.of(this.options);
}
</code></pre>

<p>and it didn't work, and then I tried the following trick inside the callback (where the <code>this.options.length</code> is correctly recognized):</p>

<pre class=""lang-ts prettyprint-override""><code>                    if(this.options.length != 0) return; // &lt;=== Looks bad!
</code></pre>

<p>which actually worked but seemed extremely inefficient to me, since the call to my service is still executed. How can I fix this?</p>
","7524842","","573032","","2021-10-26 14:45:10","2021-10-26 14:45:10","How to avoid duplicates populating array with async service","<javascript><angular><asynchronous><rxjs><rxjs5>","2","1","","","","CC BY-SA 4.0"
"43127368","2","","43125495","2017-03-30 20:04:55","","3","","<p>This is a bug in RxJS 5 up to the RxJS 5.2.0 version. It's fixed already but it hasn't been released yet.</p>

<p>The only workaround is to use any subscriber for example <code>() =&gt; {}</code> (I think using just <code>{}</code> should work as well).</p>

<p>Merged PR on RxJS GitHub fixing this issue:</p>

<ul>
<li><a href=""https://github.com/ReactiveX/rxjs/pull/2238"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/2238</a></li>
</ul>

<p>Related Issues:</p>

<ul>
<li><p><a href=""https://github.com/ReactiveX/rxjs/issues/2283"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2283</a></p></li>
<li><p><a href=""https://github.com/ReactiveX/rxjs/issues/2237"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2237</a></p></li>
</ul>
","310726","","","","","2017-03-30 20:04:55","","","","1","","","","CC BY-SA 3.0"
"43129707","1","","","2017-03-30 22:58:19","","0","1655","<p>I am trying to create an observable (fixedObservable here) which will be fed by multiple dynamically created observable over time. Whenever a subscription is made than the subscriber should get the most recent value from the fixedObservable. Although I have achieved it but I wanted to know if there is any simple solution to it. You can find the code here <a href=""https://jsfiddle.net/dzm2t3pa/8/"" rel=""nofollow noreferrer"">https://jsfiddle.net/dzm2t3pa/8/</a> .</p>

<p>Thanks
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var resultdiv = document.getElementById('result');

function print(message) {
  var paraEl = document.createElement('p');
  paraEl.innerHTML = message;
  resultdiv.appendChild(paraEl);
}
var startTime = new Date();

var fixedObservable = new Rx.Subject();
var subscription;

function subscribe() {
  subscription = fixedObservable.subscribe(function(value) {
    print('subscriber 1:' + value + ' :after ' + (new Date() - startTime) / 1000 + ' secs');
  });
}

function unsubscribe() {
  subscription.unsubscribe();
}
// Subscribe to the fixedObservable(i.e Subject) initiallly
subscribe()

//Unsubscribe and resubscribe after 11 sec here to see what
// happens in that period.
//Observation: The values generated in that period are not received as needed.
setTimeout(unsubscribe, 11000);
setTimeout(subscribe, 22000);

//just a simple check with multiple subscribers later.All the
//subscribers get the latest value. 
/*setTimeout(function(){
  fixedObservable.subscribe(function(value){
   	print('subscriber 2:'+value+' :after '+(new Date()-startTime)/1000+' secs');
   });
},30000);*/
//setTimeout(function(){},)

//Initial Observables which feed the data to fixedObservable
var dynamicObservable1 = Rx.Observable.interval(4000);
var dynamicObservable2 = Rx.Observable.interval(5000);
var counter1 = 0;
//subscribe to dynamic observable and pass the data to fixedObservable
dynamicObservable1.subscribe(function(value) {
  counter1 += 1;
  fixedObservable.next(counter1 + 'th value from 1');
});
var counter2 = 0;
dynamicObservable2.subscribe(function(value) {
  counter2 += 1;
  fixedObservable.next(counter2 + 'th value from 2');
});

//create a dynamicObservable after 5secs to feed the data and 
// then destroy it after 2.5 sec i.e at 7.5 sec from start.
//Observation: 2 value from this stream is received and then stops
setTimeout(function() {
  var counter3 = 0;
  var dynamicObservable3 = Rx.Observable.interval(1000);
  var subs = dynamicObservable3.subscribe(function(value) {
    counter3 += 1;
    fixedObservable.next(counter3 + 'th value from 3');
  });
  setTimeout(function() {
    subs.unsubscribe()
  }, 2500)
}, 5000);

setTimeout(function() {
  unsubscribe();
}, 50000)</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js""&gt;&lt;/script&gt;
&lt;div id=""result""&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","2763523","","2763523","","2017-03-31 02:56:42","2017-03-31 07:57:53","RXJS: Single Observable from dynamically created Observables","<javascript><rxjs><observable><rxjs5><subject-observer>","1","1","","","","CC BY-SA 3.0"
"43130007","1","","","2017-03-30 23:29:25","","3","2133","<p>I have a bunch of events to send up to a service. But the requests are rate limited and each request has a count limit:</p>

<ul>
<li>1 request per second: <code>bufferTime(1000)</code></li>
<li>100 event items per request: <code>bufferCount(100)</code></li>
</ul>

<p>The problem is, I am not sure how to combine them in a way that makes sense.</p>

<h3>Allowing pass-through</h3>

<p>Complicating this further, I need to make sure that events go through instantaneously if we don't hit either limit.</p>

<p>For example, I don't want it to actually wait for 100 event items before letting it go through if it's only one single event during a non-busy time.</p>

<h3>Legacy API</h3>

<p>I also found that there was a <code>bufferWithTimeOrCount</code> that existed in RxJS v4, although I am not sure how I'd use that even if I had it.</p>

<h3>Test playground</h3>

<p>Here is a JSBin I made for you to test your solution:</p>

<p><a href=""http://jsbin.com/fozexehiba/1/edit?js,console,output"" rel=""nofollow noreferrer"">http://jsbin.com/fozexehiba/1/edit?js,console,output</a></p>

<p>Any help would be greatly appreciated.</p>
","839793","","","","","2018-04-21 11:55:41","Rate-limiting and count-limiting events in RxJS v5, but also allowing pass-through","<javascript><rxjs><rxjs5><reactivex>","3","0","3","","","CC BY-SA 3.0"
"43133405","1","43135334","","2017-03-31 05:57:46","","5","3488","<p>I am working on a project (Angular2) where I am creating Observables dynamically and putting them in an array</p>

<pre><code>var ObservableArray : Observable&lt;any&gt;[] = [];
//filling up Observable array dynamically
for (var i = 0; i &lt; this.mainPerson.children.length; i++) {       
ObservableArray.push(Observable.fromPromise(this.determineFate(this.mainPerson.children[i])));
  }
}


var finalObservable: Observable&lt;any&gt; = Observable.concat(ObservableArray);

finalObservable
  .subscribe( data =&gt; {
    //here  I expected to execute determineFate() for all observables inside array  
    console.log(""determine fate resolved data returned ["" + data + ""]"");
  }, error =&gt; {
    console.error(""error on Age Year for Characters"")
  },() =&gt; {  
    //Here I expect this gets executed only when all Observables inside my array finishes 
    console.log(""determine fate resolved data returned COMPLETED"");
    //DB call
  });

  determineFate(..): Promise&lt;boolean&gt; {
       ...
       return either true / false if success or error;

 }
</code></pre>

<p>I want to execute all observables in a series (<code>forkJoin</code> seems to run in parallel - so used concat). Once all observables are executed, want to execute some DB related code. But it seems my code inside 'Completed' block does not wait for all Observables to finish. How can I achieve this? </p>

<p>Thanks in advance  </p>
","2869612","","310726","","2017-03-31 10:16:27","2017-03-31 10:16:27","Execute dynamically created array of observables in series","<javascript><angular><rxjs><rxjs5>","1","2","2","","","CC BY-SA 3.0"
"43135334","2","","43133405","2017-03-31 07:49:03","","8","","<p>Using <code>Observable.concat(ObservableArray)</code> will just flatten the array and emit each Observable from <code>ObservableArray</code> one by one. Btw, using the static version of <code>concat</code> makes sense only with two or more parameters (see <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-concat"" rel=""noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-concat</a>).</p>

<p>Instead you can iterate the array of Observables and wait until they complete one by one with the <code>concatAll()</code> operator.</p>

<p>This example simulates your use-case:</p>

<pre><code>var observableArray = [];
// filling up Observable array dynamically
for (var i = 0; i &lt; 10; i++) {
  observableArray.push(Observable.of('Value ' + i));
}

Observable.from(observableArray)
  .concatAll()
  .subscribe(console.log, null, () =&gt; console.log('completed'));
</code></pre>

<p>The <code>Observable.from()</code> emits each Observable separately and <code>concatAll()</code> subscribes to each one of them in the order they were emitted.</p>

<p>This demo prints to console the following output:</p>

<pre><code>Value 0
Value 1
Value 2
Value 3
Value 4
Value 5
Value 6
Value 7
Value 8
Value 9
completed
</code></pre>
","310726","","","","","2017-03-31 07:49:03","","","","0","","","","CC BY-SA 3.0"
"43141168","1","","","2017-03-31 12:51:34","","0","166","<p>I'm trying to wrap my head around reactive programming and observables.</p>

<p>What is the reactive way to solve the following scenario?</p>

<p>I have an object with 2 properties.</p>

<p>At anytime, one, both or neither of these properties can be set.</p>

<p>Each of these properties dispach events that I can listen to.</p>

<p>Only when both properties are set I want to listen to their update events and run some kind of aggregation on their properties.</p>
","4962759","","","","","2017-08-10 09:23:31","RxJS. Creating an Observable from 2 properties","<rxjs><reactive-programming><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"43148003","1","43148730","","2017-03-31 19:09:02","","3","2037","<p>I don't understand what the following documentation means in this <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switch"" rel=""nofollow noreferrer"">RxJS example</a>. Can someone answer?</p>

<blockquote>
  <p>The outcome is that <code>switched</code> is essentially a timer that restarts
  on every click. The interval Observables from older clicks do not
  merge with the current interval Observable.</p>
</blockquote>

<p>Here is the code:</p>

<pre><code>var clicks = Rx.Observable.fromEvent(document, 'click');
// Each click event is mapped to an Observable that ticks every second
var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000));
var switched = higherOrder.switch();
// The outcome is that `switched` is essentially a timer that restarts
// on every click. The interval Observables from older clicks do not merge
// with the current interval Observable.
switched.subscribe(x =&gt; console.log(x));
</code></pre>
","1768008","","","","","2017-03-31 19:57:40","What does the switch statement in this RxJS example do?","<switch-statement><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"43148730","2","","43148003","2017-03-31 19:57:40","","8","","<p>The easiest model to understand for switch is <code>autocomplete</code>.</p>

<p>In the typical autocomplete scenario you will take input from a user, and call a service that returns a promise.   You then attach to the promise through <code>.then()</code> to update your UI.</p>

<pre><code>function onChange(text: string) {
    this.request(url).then((data) =&gt; this.updateListBox(data))
}
</code></pre>

<p>If the user enters text multiple times you'll call <code>onChange</code> each time.  The order of responses at that point is not guarnteed. The endpoint you're calling could very well return you responses out of order.  <code>1</code>, <code>3</code>, <code>2</code>.  So the user will see the second request they made, instead of the last request they made.</p>

<p>Now what switch does, is given an input observable, it only actively listens to the last observable emitted to it. For example...</p>

<pre><code>this.onChange
   .map(text =&gt; Observable.fromPromise(this.request(text))
   .switch()
   .subscribe((data) =&gt; this.updateListBox(data));
</code></pre>

<p>Each time a value comes in through <code>onChange</code> we will still make the request as per normal.  Once a second value emits from <code>onChange</code> we <code>unsubscribe</code> from the first observable (request 1).  And subscribe to the second observable (request 2).</p>

<p>So that once you update the UI, you only ever update with the latest set of data that you care about.</p>
","400771","","","","","2017-03-31 19:57:40","","","","3","","","","CC BY-SA 3.0"
"43151306","1","","","2017-04-01 00:05:59","","1","1636","<p>Is it possible to post multipart/form-data with RxJS Ajax observable? 
I tried to do so by setting <code>Content-Type</code> in ajax settings object like so.</p>

<pre><code>import { ajax } from 'rxjs/observable/dom/ajax';

let data = {
  ad = 'ad_id',
  image = &lt;HTML5 File object&gt;
}

let settings = {
  url: '/some-url',
  body: data,
  method: 'post',
  headers: {
    'Content-Type': 'multipart/form-data; boundary=---------2e50046',
    ...
  }
  ...
}
</code></pre>

<p>And used <code>ajax(settings)</code> to post the form</p>

<p>However, it does not seem to work when sent to backend server. I use <code>Django Rest Framework</code> in the backend.</p>

<p>I hope you can help me out on this.</p>
","6712925","","6712925","","2017-04-01 00:14:25","2019-10-16 12:41:28","Posting mutipart/form-data with RxJS ajax","<ajax><django-rest-framework><rxjs><rxjs5>","0","9","","","","CC BY-SA 3.0"
"43158320","1","","","2017-04-01 14:52:22","","1","206","<p>When looking through the rxjs directory structure, there seems to be two copies of the <strong><em>observable</em></strong> and <strong><em>operator</em></strong> folders - one inside the <code>add</code> folder as well as outside <a href=""https://github.com/ReactiveX/rxjs/tree/master/src/add"" rel=""nofollow noreferrer"">add</a>.</p>

<p>Can someone explain why those two copies exist?</p>
","865220","","11742","","2017-04-02 02:36:46","2017-04-06 23:59:42","What is the folder add in rxjs 5 for?","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"43159798","1","","","2017-04-01 17:15:11","","0","303","<p>A stream constains the following objects</p>

<pre><code>const data = [
  { type: 'gps',   id: 1, val: 1 },
  { type: 'gps',   id: 2, val: 2 },
  { type: 'speed', id: 2, val: 3 },
  { type: 'gps',   id: 3, val: 4 },
  { type: 'speed', id: 4, val: 5 },
  { type: 'gps',   id: 4, val: 6 },
  { type: 'gps',   id: 5, val: 7 }
]
</code></pre>

<p>In case the ids are the same, the objects are merged. If no id matches up, the object is ignored:</p>

<pre><code>[
   [{type: 'gps', id:2, val:2}, { type: 'speed', id: 2, val: 3 }],
   [{ type: 'speed', id: 4, val: 5 },{ type: 'gps',   id: 4, val: 6 }]
]
</code></pre>

<p>My idea was to group objects with the same type, ending up with two new streams</p>

<pre><code>Rx.Observable.from(data)
  .groupBy((x) =&gt; x.type)
  .flatMap((g) =&gt; ...)
  ....
</code></pre>

<p>and then to merge/zip them again if the <code>id</code> is equal.</p>

<p>I'm not sure how to specify this in Rx and I'm also not sure if this is a good approach.</p>
","2493690","","","","","2017-04-02 06:33:17","How to conditionally merge objects from a single Observable stream?","<stream><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43161639","1","43165389","","2017-04-01 20:24:53","","1","1643","<p>I'm trying to understand the use of observables,</p>

<p>everything is ok in the simple cases, but in one case I want to compress several images.</p>

<p>I'm using  <code>ng2-img-tools</code></p>

<blockquote>
  <p>Method to compress an image. This reduces the quality of an image down
  until it fits a certain fileSize which is given as maxSizeInMB. Set
  ignoreAlpha to true if you want to ignore the alpha channel for png
  images and compress them nonetheless (not recommended - the alpha
  channel will be lost and the resulting image might differ from the
  original image). <strong>Returns an observable that for every file given,
  onNext receives either a File when everything went as planned or an
  error Object if something went wrong</strong>.</p>
</blockquote>

<p>In my code, I'm doing the following : </p>

<pre><code>compressImages(filesToUpload:File[]):Observable&lt;any&gt; {
    if (filesToUpload &amp;&amp; filesToUpload.length &gt; 0) {
      return this.ng2ImgToolsService.compress(filesToUpload,GlobalService.MAX_FILE_SIZE_MB).map(response =&gt;  {
        console.log(""response is"");
        console.log(response)
        return response;
      });
    }
    return Observable.of(""no_image"").map(response =&gt;  ""no_image"");

  }


this.imageService.compressImages(filesToUpload).flatMap(result =&gt; {
          console.log(result)
          return  this.http.post(...);
        }
      ).catch(UtilsService.handleError);
</code></pre>

<p>the problem is result returns only 1 file, I know i should use <code>result.next()</code> somewhere but I have no idea how.</p>
","667726","","","","","2017-04-02 19:23:19","angular 2 observable next","<angular><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43165389","2","","43161639","2017-04-02 06:43:16","","1","","<p>The issue is that you need <code>subscribe</code> to the function, not perform another map. When you subscribe to an observable, you're implicitly receiving the value of <code>onNext()</code> as <strong>result</strong></p>

<pre><code>this.imageService.compressImages(filesToUpload).subscribe(
    result =&gt; {
        // this contains the value of onNext()
        console.log(result)
        return     this.imageService.compressImages(filesToUpload).subscribe(
    result =&gt; {
        // this contains the value of onNext()
        console.log(result)
        return  this.http.post(...);
    }, error =&gt; {
        // error
    } this.http.post(...);
    }, error =&gt; {
        // error
    }
</code></pre>

<p><a href=""https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/creating_and_subscribing_to_simple_observable_sequences.html"" rel=""nofollow noreferrer"">more info on subscribing</a></p>

<p><strong>EDIT</strong></p>

<hr>

<p>if you'd like to collect all item in the stream and operate on them as one list, you can use <code>toList()</code> like so:</p>

<pre><code>this.imageService.compressImages(filesToUpload).toList().subscribe(
    result =&gt; {
        // this contains all values from the stream
        console.log(result)
        return  this.http.post(...);
    }, error =&gt; {
        // error
    }
</code></pre>
","1409312","","1409312","","2017-04-02 19:23:19","2017-04-02 19:23:19","","","","4","","","","CC BY-SA 3.0"
"43165694","1","43182845","","2017-04-02 07:21:49","","0","57","

<p>What I understand yes we dont need to subscribe to effects like observables as we are not consuming the results,
for example like:</p>

<pre class=""lang-ts prettyprint-override""><code>const subscribe = source.subscribe(val =&gt; console.log(val))
</code></pre>

<p>But is it possible to log without subscribing ?
Here is my code, say I want to log, addUserStats$ effect.</p>

<p>user-profile-effects.ts:</p>

<pre class=""lang-ts prettyprint-override""><code>@Injectable()
export class UserProfileEffects {

  constructor(
    private actions$: Actions,
    private userProfileActions: UserProfileActions,
    private userProfile: UserProfile,
    private auth: Authorization
  ) { }

  @Effect()
  updateToken$ = this.actions$
    .ofType(UserProfileActions.UPDATE_TOKEN)
    .map(action =&gt; action.payload)
    .map((token: string) =&gt; this.auth.accessToken = token)
    .switchMap(token =&gt; this.userProfile.getStats(true))
    .map(response =&gt; this.userProfileActions.updateData(response));

  @Effect()
  addUserStats$ = this.actions$
    .ofType(UserProfileActions.UPDATE)
    .map(action =&gt; action.payload)
    .map((data: any) =&gt; this.userProfileActions.addStats(data.items));
}
</code></pre>

<p>effects.ts:</p>

<pre class=""lang-ts prettyprint-override""><code>export default [
  NowStatEffects,
  UserProfileEffects
];
</code></pre>

<p>core.module.ts:</p>

<pre class=""lang-ts prettyprint-override""><code>import effects from './effects';
@NgModule({
  imports: [
    CoreStoreModule,
    ...effects.map(effect =&gt; EffectsModule.run(effect)),
  ],
  declarations: [
  ],
  exports: [
    CoreStoreModule,
  ],
  providers: [
    ...APP_SERVICES
  ]
})
export class CoreModule {
  constructor(@Optional() @SkipSelf() parentModule: CoreModule) {
    throwIfAlreadyLoaded(parentModule, 'CoreModule');
  }
}
</code></pre>
","865220","","865220","","2017-04-02 23:16:48","2017-04-03 10:57:55","How can I log values of effects given that we don't subsribe to them anywhere?","<angular><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"43165848","1","43166538","","2017-04-02 07:40:48","","2","251","<p>If <code>flatMap()</code> is equivalent to <code>map().mergeAll()</code>,
then what is <code>switchMap()</code> equivalent to ?</p>
","865220","","","","","2017-04-02 09:02:08","What is switchMap equivalent to in unflattened form?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43166538","2","","43165848","2017-04-02 09:02:08","","4","","<p>The <code>switchMap()</code> operator is equivalent to using <code>map().switch()</code>.</p>

<p>Since the <code>switch()</code> operator works only with higher-order Observables the preceding <code>map()</code> has to return an Observable. There's no <code>switchAll()</code> operator because the <code>switch()</code> operator already works with higher-order Observables(just like all <code>*all()</code> operators).</p>
","310726","","","","","2017-04-02 09:02:08","","","","0","","","","CC BY-SA 3.0"
"43178768","1","","","2017-04-03 07:22:52","","0","199","<p>I have a view that <code>subscribe</code> to a <code>FirebaseListObservable</code> and a form that does CRUD operations on a <em>range</em> of objects in that list.</p>

<p>It will iterate over the keys and update the database like so:</p>

<pre><code>let list = this.angularFire.database.list('items/' + listkey);
keys.forEach((key) =&gt; list.update(key, item[key]));
</code></pre>

<p>The problem is that the subscription issue a new list for each update, whereas I only need the list when all the transactions are complete.</p>

<p>I have tried to manipulate the list before updating the database using the <code>FirebaseObjectObservable</code> on the <code>listkey</code> but it throws an error due to invalid characters in the metafields (like <code>$key</code> and <code>$exist</code>).</p>

<p>Right now I am using a <code>debounceTime</code> on the subscription but I am not sure if that is the proper implementation or not.</p>

<p><em>Is there a way to concat the updates into a single transaction?</em></p>
","308645","","308645","","2017-04-03 07:26:23","2017-04-03 07:26:23","Concat multiple database actions into one single transaction in Angularfire2","<angular><firebase><rxjs><rxjs5><angularfire2>","0","5","1","","","CC BY-SA 3.0"
"43182845","2","","43165694","2017-04-03 10:57:55","","2","","<p>You can tap into observable stream by chaining <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-do"" rel=""nofollow noreferrer""><code>do()</code></a> operator. It will:</p>

<blockquote>
  <p>Perform a side effect for every emission on the source Observable, but return an Observable that is identical to the source.</p>
</blockquote>

<pre class=""lang-ts prettyprint-override""><code>  @Effect()
  addUserStats$ = this.actions$
    .ofType(UserProfileActions.UPDATE)
    .map(action =&gt; action.payload)
    .do((data: any) =&gt; console.log(data.items))
    .map(payload =&gt; { /* do something else */ )
</code></pre>

<p>or shorter version:</p>

<pre><code>    .do(console.log)
</code></pre>
","1876949","","","","","2017-04-03 10:57:55","","","","0","","","","CC BY-SA 3.0"
"43207769","1","","","2017-04-04 12:50:52","","0","48","<p>I have the following problem that I want to solve with RxJS (Angular 4)</p>

<ul>
<li>if not logged in request for data fails (403 forbidden)</li>
<li>if the request fails with 403 I want to retry the request for the data when I'm logged in</li>
<li>while I'm logged in I want to request data once when the user visits a view that requires the data</li>
</ul>

<p>I have the following streams</p>

<pre><code>const isLoggedIn$ = store.select('currentuser').filter(user =&gt; user.id)
const loadActions$ = storeActions$.filter(action =&gt; action.type == 'LOAD_DATA_REQUEST')
</code></pre>

<p>I have some code but it's not fulfilling all of the conditions above</p>

<pre><code>loadActions$.take(1).subscribe(() =&gt; { http.get('/api/data') ... })
</code></pre>

<p>Works when I'm logged in and I am allowed to access the data but fails when I'm not logged in.</p>
","1436151","","3633742","","2017-04-04 13:03:29","2017-04-04 17:58:51","RxJS retry to get data after logged in - if logged in try once","<angular><rxjs5><ngrx>","1","0","","","","CC BY-SA 3.0"
"43208903","1","43209801","","2017-04-04 13:38:09","","2","553","<p>I'm trying to create a caching function in angular using RxJS Observable. Originally I've created this method using angularjs <code>$q</code>'s deferred promise. Observables and RxJS are new to me and I find this method of working still somewhat confusing.</p>

<p>This is my current implementation of a <code>getOrCreate</code> caching function. Retrieve a single value for a key from storage (<code>this.get()</code>) and if it's not in there you retrieve it elsewhere (<code>fetcher</code>).</p>

<p>Assume <code>fetcher</code> is a slower data source than <code>this.get()</code>. Multiple requests for the same key could fire while we're still retrieving from <code>this.get()</code> so I put in an aggregator: only a single observable is created for multiple requests of the same key.</p>



<pre class=""lang-js prettyprint-override""><code>protected observableCache : {[key: string] : Observable&lt;any&gt;} = {};

get&lt;T&gt;(key : string): Observable&lt;T&gt; { /* Async data retrieval */ }

getOrCreate&lt;T&gt;(key : string, fetcher: () =&gt; Observable&lt;T&gt;) : Observable&lt;T&gt; {
  const keyHash = this.hash(key);

  // Check if an observable for the same key is already in flight
  if (this.observableCache[keyHash]) {
    return this.observableCache[keyHash];
  } else {

    let observable : Observable&lt;T&gt;;

    this.get(key).subscribe(

      // Cache hit
      (result) =&gt; { observable = Observable.of(result); },

      // Cache miss. Retrieving from fetching while creating entry
      () =&gt; {
        fetcher().subscribe((fetchedResult) =&gt; {
          if(fetchedResult) {
            this.put(key, fetchedResult);
          }
          observable = Observable.of(fetchedResult);
        });
      }
    );


   // Register and unregister in-flight observables
   this.observableCache[keyHash] = observable;
   observable.subscribe(()=&gt; {
      delete this.observableCache[this.hash(key)];
   });

    return observable;
  }
}
</code></pre>

<p>This is my current version of that code but it doesn't look like I'm properly handling async code:</p>

<ul>
<li>Observable will be returned before it's instantiated: <code>return observable</code> fires before <code>observable = Observable.of(result)</code>;</li>
<li>There's probably a much better pattern of aggregating all requests for the same key while <code>this.get()</code> is still in-flight.</li>
</ul>

<p>Can someone help with finding the Observer patterns should be used?</p>
","557552","","557552","","2017-04-04 14:10:34","2017-04-04 15:27:15","Observable patterns for caching and defered data retrieval","<angularjs><caching><rxjs><observable><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"43209801","2","","43208903","2017-04-04 14:15:04","","3","","<p>I think this might work. Rewritten as:</p>

<pre><code>getOrCreate&lt;T&gt;(key : string, fetcher: () =&gt; Observable&lt;T&gt;) : Observable&lt;T&gt; {
    const keyHash = this.hash(key);

    // Check if an observable for the same key is already in flight
    if (this.observableCache[keyHash]) {
        return this.observableCache[keyHash];
    }

    let observable : ConnectableObservable&lt;T&gt; = this.get(key)
        .catch(() =&gt; { // Catch is for when the source observable throws  error: It replaces it with the new Rx.Observable that is returned by it's method
            // Cache miss. Retrieving from fetching while creating entry
            return this.fetchFromFetcher(key, fetcher);
        })
        .publish();

    // Register and unregister in-flight observables
    this.observableCache[keyHash] = observable;
    observable.subscribe(()=&gt; {
        delete this.observableCache[keyHash];
    });
    observable.connect();

    return observable;
},

fetchFromFetcher(key : string, fetcher: () =&gt; Observable&lt;T&gt;) : Observable&lt;T&gt; {
    // Here we create a stream that subscribes to fetcher to use `this.put(...)`, returning the original value when done
    return Rx.Observable.create(observer =&gt; {
        fetcher().subscribe(fetchedResult =&gt; {
            this.put(key, fetchedResult);
            observer.next(fetchedResult);
        },
        err =&gt; observer.error(err),
        () =&gt; observer.complete())
    });
}
</code></pre>

<p>Explanations:</p>

<ol>
<li>Observables are very different from promises. They are to work with async stuff, and there are some similarities, but they are quite different</li>
<li>As <code>this.get(...)</code> seems asynchronous, your <code>let observable</code> won't get filled until it yields a value, so when you assign it to your cache it's normal that's null.</li>
<li>A great thing about observables (and the main difference with promises) is that you can define a stream before anything gets executed. In my solution, nothing gets called until I call <code>observable.connect()</code>. This avoids so many .subscriptions</li>
<li>So, in my code I get the <code>this.get(key)</code> stream, and tell it that if it fails (<code>.catch(...)</code>) it must fetch the result, but once that's fetched then put it into your cache (<code>this.put(key, fetchedResult</code>)</li>
<li>Then I <code>publish()</code> this observable: This makes it so it behaves more like promises do, it makes it ""hot"". This means that all subscribers will get the values from the same stream, instead of creating a new stream that starts from 0 everytime one subscribes to it.</li>
<li>Then I store it in the observable pool, and set to delete it when it finishes.</li>
<li>Finally, I <code>.connect()</code>. This is only done if you <code>publish()</code> it, it's the thing that actually subscribes to the original stream, executing everything you want.</li>
</ol>

<p>To make it clear, because this is a common error coming from Promises, in angular if you define a stream as:</p>

<pre><code>let myRequest = this.http.get(""http://www.example.com/"")
    .map((result) =&gt; result.json());
</code></pre>

<p>The request it's not sent yet. And everytime you do <code>myRequest.subscribe()</code>, a new request to the server is made, it won't reuse the ""first subscription"" result. That's why <code>.publish()</code> is very useful: It makes that when you call <code>.connect()</code> it creates a subscription that triggers the request, and will share the last result received (Observables support streams: Many results) with all incoming subscriptions to the published observable.</p>
","1026619","","1026619","","2017-04-04 15:27:15","2017-04-04 15:27:15","","","","7","","","","CC BY-SA 3.0"
"43219118","1","43223063","","2017-04-04 23:00:35","","1","237","<p>I've been struggling to come up with an Rx strategy for a particular situation. I'm hoping someone could point me in the right direction.</p>

<p>Basically, I have a socket feed that I would like to skip based on a boolean value. When the stream is skipping the socket, I need to keep a running buffer of the latest value sent from socket. </p>

<p>Once I am no longer skipping the socket events, then push down the stream the last value that was emitted when it was skipping, but only under another condition (bool), and re-start listen to socket events </p>

<p>So basically:</p>

<ul>
<li>Listen to socket feed</li>
<li><code>takeWhile(bool)</code></li>
<li>When start listening again, apply last values while skipping
socket, if <code>reapply==true</code></li>
</ul>

<p>Didn't get far, but this is what I have:</p>

<pre><code>Rx.Observable.interval(1000)
.skipWhile(()=&gt;isSkipping)
.bufferWhileSkipping??
.applySkippedValuesAfterSkipping(ifisReapply)??
.subscribe(val=&gt;console.log(val));
</code></pre>

<p>Perhaps <code>skipWhile</code> is not the right approach but was the only one that kind of made senseâ¦</p>
","2275792","","310726","","2017-04-05 06:06:53","2017-04-05 06:06:53","RxJS 5: skipping socket feed while keeping latest values","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43223063","2","","43219118","2017-04-05 06:06:19","","1","","<p>You could do it similarly to the following (I'm assuming your <code>isSkipping</code> can be an Observable):</p>

<pre><code>const isSkipping = new BehaviorSubject(false);

Observable.interval(100)
  .take(20)
  .window(isSkipping)
  .withLatestFrom(isSkipping)
  .switchMap(([observable, skipping]) =&gt; skipping
    ? observable.takeLast(1).map(val =&gt; 'last:' + val)
    : observable)
  .subscribe(console.log);

setTimeout(() =&gt; isSkipping.next(true), 500);
setTimeout(() =&gt; isSkipping.next(false), 1050);
setTimeout(() =&gt; isSkipping.next(true), 1500);
setTimeout(() =&gt; isSkipping.next(false), 1850);
</code></pre>

<p>Every time <code>isSkipping</code> emits a value the <code>window</code> operator creates a new Observable that just re-emits everything or chains the <code>.takeLast(1)</code> operator when skipping is set to <code>true</code>.</p>

<p>The example above prints the following output to the console:</p>

<pre><code>0
1
2
3
last:9
10
11
12
13
last:16
17
18
19
</code></pre>
","310726","","","","","2017-04-05 06:06:19","","","","0","","","","CC BY-SA 3.0"
"43225866","1","43247585","","2017-04-05 08:29:07","","0","125","<p>I've got an Angular 2 application where I have an 'AlgemeneInfoService' with a getAlgemeneInfo() method that returns an Observable.</p>

<p>Using angular-redux/store, I've got a store that has a 'Dossier' and 'Verpleegperiode' object in it, both having an Id that the AlgemeneInfoService uses to get the 'AlgemeneInfo' object. (the VerpleegperiodeId can be null)</p>

<p><strong>I'm trying to put the ActiveAlgemeneInfo, which should be refreshed by calling the AlgemeneInfoService when the state-object of either Dossier or Verpleegperiode changes, in the state-object.</strong></p>

<p>My plan was using an ActiveAlgemeneInfoService that handles these subscriptions and has a method getActiveAlgemeneInfo() which returns the 'selectedAlgemeneInfo' that is set with a subscription to the ActiveAlgemeneInfo state object:</p>

<pre><code>@select(state =&gt; state.dieet.activeAlgemeneInfo) 
private activeAlgemeneInfo$: Observable&lt;AlgemeneInfo&gt;;
</code></pre>

<p>In the constructor of the service, I set the subscriptions:</p>

<pre><code>Observable.combineLatest(
  this.activeInfohosVerpleegperiode$,
  this.activeInfohosDossier$
)
.distinctUntilChanged()
.subscribe(([v, d]) =&gt; {
  const verpleegperiodeId = v != null ? v.verpleegperiodeId : null;
  const dossierId = d.dossierId;
  console.log(`vp id: ${verpleegperiodeId} - d id: ${dossierId}`);
  this._setActiveAlgemeneInfo(dossierId, verpleegperiodeId);
});

this.activeAlgemeneInfo$.subscribe(algemeneInfo =&gt; this.selectedAlgemeneInfo = algemeneInfo);
</code></pre>

<p>And in the service, I've also got a method:</p>

<pre><code>private _setActiveAlgemeneInfo = (dossierId: number, verpleegperiodeId: number) =&gt; {
this._algemeneInfoService
  .getAlgemeneInfo(dossierId, verpleegperiodeId)
  .subscribe(algemeneInfo =&gt; this._dieetActions.selectAlgemeneInfo(algemeneInfo));
}
</code></pre>

<p>When the service is constructed and the method getActiveAlgemeneInfo() is called:</p>

<pre><code>public getActiveAlgemeneInfo = (): Observable&lt;AlgemeneInfo&gt; =&gt; {
     return this.activeAlgemeneInfo$;
}
</code></pre>

<p>it just spams http requests, while when I console.log the Observable.combineLatest(), the Dossier and Verpleegperiode are exactly the same as the previous request.</p>

<p>How can I get this to work?</p>
","3711246","","3711246","","2017-04-05 13:55:37","2017-04-06 06:40:38","RxJS combine streams and use value of both to call a third","<angular><redux><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43247585","2","","43225866","2017-04-06 06:40:38","","0","","<p>You should move the <code>distinctUntilChanged</code> - because it does not do a <em>""deep"" comparison</em>, it only compares the reference - and for <code>combineLatest</code> this will always be a new array.</p>

<p>Try the following and see if that helps with your issue:</p>

<pre><code>Observable.combineLatest(
  this.activeInfohosVerpleegperiode$.distinctUntilChanged(),
  this.activeInfohosDossier$.distinctUntilChanged()
)
.subscribe(([v, d]) =&gt; {
</code></pre>

<hr>

<p>Alternatively you should provide a compare-method that does perform a deep-comparison like so:</p>

<pre><code>Observable.combineLatest(
  this.activeInfohosVerpleegperiode$,
  this.activeInfohosDossier$
)
.distinctUntilChanged(_.isEqual) // from: https://lodash.com/docs/#isEqual
.subscribe(([v, d]) =&gt; {
</code></pre>
","1518765","","","","","2017-04-06 06:40:38","","","","0","","","","CC BY-SA 3.0"
"43269919","1","","","2017-04-07 04:54:06","","1","285","<p>I have a very tricky situation in my <code>Angular 2</code> app. In my auth service, I have a function <code>loggedIn</code> which reads jwt access token from local storage and checks if it is expired or not and is used to gate the routes. It is called in <code>canActivate</code> implementations: </p>

<pre><code>canActivate(....):Observable&lt;boolean&gt;{
    return this.checkLogin();
}

checkLogin():Observable&lt;boolean&gt;{
    return this._authSvc.isLoggedIn();
}

///AUTHSERVICE

isLoggedIn():Observable&lt;boolean&gt; {
    let ex = tokenNotExpired('access_token');
    if (ex) {
      let jwt = new JwtHelper();

      let t = jwt.decodeToken(localStorage['access_token']);
      if (t.Id) {
        this.Id = t.Id;
      }
    }
    return Observable.of(new Boolean()).map(x =&gt; ex);
}
</code></pre>

<p>Recently, I implemented the capability to refresh the token on the backend (<code>ASP.Net Web API 2</code>). Now, the idea is to refresh the access token if it is expired using the refresh token. I tried to plumb it from <code>isLoggedIn</code> method. If the access token is expired, I will return <code>Observable&lt;boolean&gt;</code> as:</p>

<pre><code>if(ex){
}else{
    return this.refreshToken();//&lt;---NEW OBSERVABLE
}
</code></pre>

<p>from below function:</p>

<pre><code>/*method to refresh the access token*/
refreshToken():Observable&lt;boolean&gt;{
    //setup stuff
    var res= this.http.post(url,data,opts).map(r=&gt; data=r.json());

    res.subscribe(data=&gt;{
        localStorage['access_token'] = data.access_token;
        localStorage['refresh_token'] = data.refresh_token;
        let jwt = new JwtHelper();
        let t = jwt.decodeToken(localStorage['access_token']);
        if (t.Id) {
          this.Id = t.Id;
        }
    }, error=&gt;{console.log(error);
    });

    return res;
}
</code></pre>

<p>But this is causing all the hell to break loose. There are endless requests which all fail (as the first one resets the <code>refresh token</code>).</p>

<p>What I want to do is make only one request even if the function is triggered multiple times from <code>canActivate</code>. Is it possible in any way?</p>
","13198","","","user10747134","2019-02-10 17:24:43","2019-02-10 17:24:43","How to restrict HTTP call until previous one is finished","<angular><rxjs5><angular2-observables>","2","0","2","","","CC BY-SA 3.0"
"43306910","1","","","2017-04-09 12:55:51","","3","3855","<p>I'm trying to create Pipe
Which should send a request to the server, wait for an answer, and return the result</p>

<pre><code>import {Pipe, PipeTransform,  Inject} from ""@angular/core"";
import {translationService} from ""./translation.service"";


@Pipe({name: 'translate'})
export class translatePipe implements PipeTransform {
    public translationService: translationService;

constructor(@Inject(translationService) translationService: translationService){
    this.translationService = translationService;
}
transform(value: string) {
    this.translationService.translate(value).subscribe(function(ret){
        return ret;
    });

}
}
</code></pre>

<p>Service that sends the request</p>

<pre><code>import {Observable}         from ""rxjs/Observable"";
import {Observer}           from ""rxjs/Observer"";

import {Injectable} from ""@angular/core"";
import {promise} from ""selenium-webdriver"";
import {Http, Response} from ""@angular/http"";
import {Constants} from ""../../shared/constants"";

@Injectable()
export class translationService{
    private _translations: Observable&lt;Object&gt; = null;

    constructor(public http:Http, public constants:Constants){
        this._translateServiceApiUrl = this.constants.APIHost + this.constants.APIPath + this.constants.serviceApiPaths['translations'] + '/it-IT?tags=site';
}

    public getTranslate(): Observable&lt;Object&gt;{
        if (!this._translations || this._translations == null){
            this._translations = this.http
                .get(this._translateServiceApiUrl)
                .map((res:Response)=&gt;res.json() as Object)
        }
        return this._translations;
    }

    public translate(value: string){
        return this.getTranslate();
    }
}
</code></pre>

<p>When you try to call Pipe, returns a void, although the console.log shows that the data was received.</p>
","6613563","","2576218","","2017-11-28 10:18:06","2017-11-28 10:18:06","Pipe with Observable","<angular><pipe><observable><rxjs5>","0","2","","","","CC BY-SA 3.0"
"43313799","1","","","2017-04-10 01:32:32","","12","4249","<p>In the following example <code>toPromise</code> does not work:</p>

<p><a href=""https://jsfiddle.net/tossp/nmf9jg32/"" rel=""noreferrer"">https://jsfiddle.net/tossp/nmf9jg32/</a></p>

<p>My code:</p>

<pre><code>function getPostData() {
    return fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(res =&gt; res.json())
}
var source = Rx.Observable.fromEvent(document.body, 'click');

var example = source.concatMap(
            e =&gt; Rx.Observable.from(getPostData()), 
            (e, res, eIndex, resIndex) =&gt; res.title);

example.subscribe({
    next: (value) =&gt; { console.log('subscribe!!!',value); },
    error: (err) =&gt; { console.log('Error: ' + err); },
    complete: () =&gt; { console.log('complete'); }
});
example.do((value)=&gt;console.log('do!!!',value)).toPromise().then((value)=&gt;console.log('toPromise!!!',value));
</code></pre>
","3064170","","7414939","","2017-04-11 09:03:26","2019-10-29 13:12:51","rxjs5 toPromise not working","<javascript><rxjs5>","2","1","","","","CC BY-SA 3.0"
"43336549","1","43338150","","2017-04-11 04:03:02","","35","38350","<p>I am moving from the Promise world to the Observable world. One thing I usually do with Promise is to chain a series of tasks and make them run in sequence. For example, I have three tasks: <code>printLog1()</code> to print 1 to the console, <code>printLog23()</code> to print 2 and 3 to the console, and <code>printLog4()</code> to print 4.</p>

<p>When I want to print 1-2-3-4, I would write a promise chain like</p>

<pre><code>printLog1()
  .then(() =&gt; {
    printLog23();
  })
  .then(() =&gt; {
    printLog4();
  });
</code></pre>

<p>Now I want the same functionality with Observable and I can rewrite the <code>printLog()</code> function into an Observable like</p>

<pre><code>printLog1 = Rx.Observabale.of(1).map((i) =&gt; console.log(i));
printLog23 = Rx.Observabale.of(2, 3).map((i) =&gt; console.log(i));
printLog4 = Rx.Observabale.of(4).map((i) =&gt; console.log(i));
</code></pre>

<p>Then I have three observables that emits different values to the console. How do I chain them so that these three observables would run in order and print <code>1-2-3-4</code>?</p>
","4064930","","310726","","2018-03-01 06:48:15","2019-01-15 11:10:47","How to force observables to execute in sequence?","<rxjs><rxjs5>","1","0","5","","","CC BY-SA 3.0"
"43338150","2","","43336549","2017-04-11 06:20:22","","54","","<p>If you want to be sure the order of emissions is the same as the order in which you specified the source Observables you can use <code>concat</code> or <code>concatMap</code> operators.</p>

<p>The <code>concat*</code> operators subscribe to an Observable only after the previous Observable completes (it works with Promises as well, see <a href=""http://reactivex.io/rxjs/class/es6/MiscJSDoc.js~ObservableInputDoc.html"" rel=""noreferrer"">http://reactivex.io/rxjs/class/es6/MiscJSDoc.js~ObservableInputDoc.html</a>).</p>

<p>In you case it'd look like the following:</p>

<pre><code>import { concat } from 'rxjs'; // Note, concat from 'rxjs', is not the same as concat from 'rxjs/operators'

concat(printLog1, printLog23, printLog4);
</code></pre>

<p>... or with <code>concatMap</code> if the request for one Promise depends on the response from the previous Promise:</p>

<pre><code>printLog1.pipe(
  concatMap(response =&gt; ...),
  concatMap(response =&gt; ...),
);
</code></pre>

<p>... or when the order doesn't matter you can use <code>merge</code> that subscribes to all Observables/Promises immediately and reemits their results as they arrive:</p>

<pre><code>merge(printLog1, printLog23, printLog4);
</code></pre>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-15 11:10:47","2019-01-15 11:10:47","","","","3","","","","CC BY-SA 4.0"
"43343684","1","","","2017-04-11 10:43:14","","1","133","<p>How do I put data in a ConnectableObservable? I'm asking this for the case where the data of an observable is not available until an async function completes. A simple example:</p>



<pre class=""lang-js prettyprint-override""><code>function myFunc() {
  let observable = Rx.Observable.create().publish();
  setTimeout(() =&gt; console.info('TIMEOUT') || observable.of('data').connect(), 300);
  return observable;
}

myFunc().subscribe(x =&gt; console.log(x));
</code></pre>

<p>I have also tried</p>

<pre class=""lang-js prettyprint-override""><code>observable.map(() =&gt; 'data').connect()
observable.flatMap(() =&gt; Observable.of('data')).connect()
</code></pre>

<p>as an alternative to <code>.of()</code> in my example without success.</p>
","557552","","557552","","2017-04-11 13:14:49","2017-04-11 16:14:30","Adding data to ConnectableObservable","<asynchronous><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43365918","1","43366157","","2017-04-12 09:42:06","","0","399","<p>I am trying to create a generic <code>DataService</code> with hateoas implementation. 
There's a REST api <code>/root</code> which provides all the hateoas link. 
For example,</p>

<pre><code>{
    _links : {
        login : {
            href : '/login',
            method : 'POST'
        },
        orders : {
            href : '/orders',
            method : 'GET'
        },
        orderById : {
            href : '/order/{id}',
            method : 'GET'

        }
        .......
    }
}
</code></pre>

<p>On application load, The <code>DataService</code>  should make a call to <code>/root</code> api and store the response in an instance variable, say <code>rootLinks</code>. It should be available for the entire session. </p>

<p>Then <code>DataService</code> should provide a <code>followLinkByName</code> method which get's the <code>href</code> from available <code>rootLinks</code> and triggers a new http request. </p>

<pre><code>const rootUrl: string = '/root';
const baseUrl: string = 'http://localhost:8080';

@Injectable()
export class DataService {

  private observable$: Observable&lt;any&gt;;
  private rootLinks: any;

  constructor(private http: Http) {
    this.ngOnInit();
  }

  ngOnInit() {
    this.getRootLinks().subscribe();
  }

  private getRootLinks() {
    if (this.rootLinks) {
      return Observable.of(this.rootLinks);
    } else if (this.observable$) {
      return this.observable$;
    } else {
      this.observable$ = this.http.get(rootUrl).map(this.extractRootLinkData);
      return this.observable$;
    }
  }

  private extractRootLinkData(response: Response) {
    this.observable$ = null;                             // LINE 1
    let data = response.json();
    this.rootLinks = data._links;
  }


  private extractData(response: Response) {
    let body = response.json();
    return body;
  }



  followLinkByName(linkName: String): Observable&lt;any&gt; {
    let link;
    if (this.observable$) {                              // LINE 2
      return this.observable$.map((res) =&gt; {
        link = res._links[linkName];
        // make a http request and return the response
      });
    } else {
      link = this.rootLinks[options.linkName];
      options.link = link;
      // make a http request and return the response
    }
  }

}
</code></pre>

<p>I have added this <code>DataService</code> in <code>core module's</code> providers array, 
and <code>core module</code> is  imported to the <code>app module</code>. </p>

<p>Now there's a <code>LoginComponent</code> from <code>pages</code> module which uses this <code>DataService</code> to login. Though in line 1, the <code>observable$</code> is assigned to null, it is available at line 2 when a call is made from <code>LoginComponent</code>.</p>

<p>Snapshots, 
1. on application load it invoke <code>/root</code> api and once the data is available, assigns the observable to null.
<a href=""https://i.stack.imgur.com/sRaKw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sRaKw.png"" alt=""enter image description here""></a> </p>

<p>2.when trying to login, 
<a href=""https://i.stack.imgur.com/RqgKW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RqgKW.png"" alt=""enter image description here""></a></p>
","1822974","","1968","","2017-09-19 11:57:12","2017-09-19 11:57:12","Assigning Observable reference to null inside map operator does not make any effect","<angular><angular2-services><rxjs5><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"43366157","2","","43365918","2017-04-12 09:51:41","","2","","<p>Since the <code>this.http.get(rootUrl)</code> call is asynchronous are you sure you're not losing <code>this</code> context when you're using <code>.map(this.extractRootLinkData)</code>?</p>

<p>I think when the <code>extractRootLinkData()</code> method is called as a callback to <code>map()</code> the <code>this</code> context is equal to <code>window</code>. So you're executing statement <code>this.observable$ = null</code> on <code>window</code> which doesn't exist anyway.</p>

<p>You can use an anonymous function instead:</p>

<pre><code>this.observable$ = this.http.get(rootUrl).map(response =&gt; this.extractRootLinkData(response));
</code></pre>

<p>... or bind the <code>this</code> context:</p>

<pre><code>this.observable$ = this.http.get(rootUrl).map(this.extractRootLinkData.bind(this));
</code></pre>

<p>Also see: <a href=""https://stackoverflow.com/questions/20279484/how-to-access-the-correct-this-inside-a-callback"">How to access the correct `this` context inside a callback?</a></p>
","310726","","-1","","2017-05-23 10:31:06","2017-04-12 09:51:41","","","","0","","","","CC BY-SA 3.0"
"43366694","1","43369152","","2017-04-12 10:16:17","","7","26885","<p>I have a method that needs to wait for an observable to finish. I know observable are great for returning single pieces of data over time but I need to know when this observable has completely finished returning all of its data so I can run validation code on the object it has returned.</p>

<p>The method getCustom subscribes to an observable run on the supplied url  which then returns the observable.</p>

<p>I am not too sure if this is the best way to approach this situation so I would appreciate if anyone could give me any advice or a direction to handle this.</p>

<pre class=""lang-js prettyprint-override""><code>  private validateQuoteRetrievalAnswers(reference: string) {

         // Get the risk from the server
        this.riskManager.getRiskFromServer(reference);

        if (this.riskManager.risk) {
            // Validate risk that was returned
        }
    }
</code></pre>

<pre class=""lang-js prettyprint-override""><code>getRiskFromServer(quoteReference: string) {

    this.riskService.getCustom(""Url"").subscribe =&gt; {
        // need to know when the observable has returned the risk
    });

}
</code></pre>
","","user4129529","3633742","","2017-04-12 16:12:36","2017-04-12 16:12:36","Waiting for an observable to finish","<angular><typescript><rxjs5><angular2-observables>","1","3","1","","","CC BY-SA 3.0"
"43369152","2","","43366694","2017-04-12 12:09:57","","4","","<p>how i would tackle this challenge:</p>

<p>Query you back-end and when we've got what we need push it to a Subject</p>

<pre><code>riskSubject = new Subject&lt;Risk&gt;();

getRiskFromServer(quoteReference: string) {
  this.riskService.getCustom(""Url"")
  .subscribe( 
    data =&gt; { this.riskSubject.next(data); },
    error =&gt; { console.log(error) }
 });
}
</code></pre>

<p>and then subscribe to subject and wait until you get what you need and start validating </p>

<pre><code>private validateQuoteRetrievalAnswers(reference: string) {

         // Get the risk from the server
        this.riskManager.getRiskFromServer(reference);
        // subscribe to subject
        this.riskManager.riskSubject.subscribe(
         data =&gt; {
           //do your validation
        })
}
</code></pre>

<blockquote>
  <p>The heart of an observable data service is the RxJs Subject. Subjects implement both the Observer and the Observable interfaces, meaning that we can use them to both emit values and register subscriptors.</p>
  
  <p>The subject is nothing more than a traditional event bus, but much more powerful as it provides all the RxJs functional operators with it. But at its heart, we simply use it to subscribe just like a regular observable</p>
</blockquote>

<p>source: <a href=""http://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/"" rel=""nofollow noreferrer"">angular-university.io</a></p>

<p>OR you can use Observable.fromPromise(promise) but this will make things a bit more complicated to understand if you are new to ng2</p>
","5208282","","5208282","","2017-04-12 12:16:34","2017-04-12 12:16:34","","","","1","","","","CC BY-SA 3.0"
"43398244","1","43553370","","2017-04-13 17:21:20","","2","1418","<p>I'm trying to cache ajax data called via an a redux-observable epic.</p>

<p>My goal is to call the API only the first time I dispatch <code>LOAD_DATA_REQUEST</code>, then the second time return the cached data.</p>

<p>Below is the code I've tried, but the data is not cached, the API is being call whenever I dispatch <code>LOAD_DATA_REQUEST</code>.</p>

<pre><code>const loadDataEpic =
        action$ =&gt; action$.ofType(LOAD_DATA_REQUEST)
            .mergeMap(action =&gt; getData$(action.criteria)
                .map(x =&gt; loadDataSuccess(x.response))
                .catch(error =&gt; Observable.of(loadDataFailure(error.xhr)))
            );

const getData$ = criteria =&gt; Observable.ajax.post('some-url', criteria)
    .publishLast()
    .refCount();

export default combineEpics(
    loadDataEpic 
);
</code></pre>

<p>I also tried this:</p>

<pre><code>const getData$ = criteria =&gt; Observable.ajax.post('some-url', criteria)
    .publishReplay(1)
    .refCount();
</code></pre>

<p>and</p>

<pre><code>const getData$ = criteria =&gt; Observable.ajax.post('some-url', criteria)
    .shareReplay();
</code></pre>
","235659","","235659","","2017-04-13 17:29:46","2017-04-21 23:33:24","How to cache ajax data with redux-observable - RxJS 5","<rxjs5><redux-observable>","2","3","3","","","CC BY-SA 3.0"
"43400594","1","","","2017-04-13 19:48:17","","9","5120","<p>I'm attempting to repeat a request until the response has data using RxJS, at which point I'd like to call a success (or failure) handler, but I'm having trouble w/RxJS. Here's my current approach:</p>

<pre><code>// ... redux-observable action observable
.mergeMap(() =&gt;
    fetchData()
    .repeatWhen(response =&gt;
        response.takeWhile(({ data }) =&gt; !data.length)
        .of(response)
    )
)
.map(successFunction)
.catch(failureFunction);
</code></pre>

<p>Disclaimer: I'm quite new to RxJS....</p>
","3220800","","13618646","","2021-09-27 09:47:12","2021-09-27 09:47:12","How do I repeat an ajax request until a condition is met with RxJS Observable?","<javascript><rxjs><rxjs5><reactivex>","3","1","2","","","CC BY-SA 4.0"
"43411517","1","","","2017-04-14 12:27:25","","0","101","<p>I was trying to return filter function but return doesn't seem to work with callbacks. Here <code>this.store.let(getIsPersonalized$)</code> is an observable emitting boolean values and <code>this.store.let(getPlayerSearchResults$)</code> is an observable emiting objects of video class.
How do I run this synchronously, can I avoid asynchronus callback altogether given that I can't modify the observables received from store.</p>

<pre><code>isPersonalized$ = this.store.let(getIsPersonalized$);
videos$ = this.store.let(getPlayerSearchResults$)                       
                    .map((vids) =&gt; this.myFilter(vids));

myFilter(vids) {
   this.isPersonalized$.subscribe((x){
      if(x){
         return this.fileterX(vids);//Return from here
      }
      else {
         return this.filterY(vids);//Or Return from here
      }
  });
}

fileterX(vids) {
  return vids.filter((vid) =&gt; vids.views&gt;100;);
}

fileterY(vids) {
  return vids.filter((vid) =&gt; vids.views&lt;20;);
}
</code></pre>
","865220","","865220","","2017-04-14 12:32:46","2017-04-14 13:16:05","How to return from within an observer?","<rxjs><rxjs5><ngrx>","2","0","","","","CC BY-SA 3.0"
"43415342","1","","","2017-04-14 16:17:34","","1","925","<p>eg</p>

<pre><code> this.store.dispatch(this.nowChannellistActions.toggleChannel(channel));
 this.store.dispatch(this.playerSearchActions.searchCurrentQuery());    
</code></pre>

<p>In the above code I want the second dispatch to start only after completetion of all reducers and effects of first. dispatch being asynchronus and yet not returning anything and not proving a callback either, I can't easily figure out how to do that.</p>
","865220","","865220","","2017-04-15 15:49:02","2017-04-15 15:49:02","How to chain dispatch in ngrx?","<javascript><rxjs><rxjs5><ngrx><ngrx-effects>","0","5","","","","CC BY-SA 3.0"
"43440192","1","43441246","","2017-04-16 17:46:30","","1","922","<p>I understand we can use the min operator on an array of numbers. But how would i use it on an array of objects, with a number property?</p>

<pre><code>var source = Rx.Observable.fromArray([1,3,5,7,9,2,4,6,8]).min();
</code></pre>

<p>This is how the docs describe it. This will emit <code>1</code>. How do i do this...</p>

<pre><code>var source = Rx.Observable.fromArray([{a: 1, b:""first""},{a: 3, b:""second""},{a: 5, b:""third""}]).min();
</code></pre>

<p>I want to use <code>min</code> by the inner property values. So, compare the values of <code>a</code> in each object in the array and emit that object.</p>

<p>I understand min takes a compare function, but i don't know if it can be used here. </p>

<p>I also want it to emit the object, not the minimum property value.</p>

<p>Edit:</p>

<p>So, i'm using Ngrx in an Angular 4 app and trying to use the <code>min</code> operator on a <code>store.select</code> Observable. For some reasong, the below code, where i first subscribe and then create another observable from the response and then use the min works, but if i skip the subscribe and try to use the min operator like the lower code, it fails and emits the complete array of ClientFacilities.</p>

<p>Anybody know what's going on? Aren't they both the same thing?</p>

<p>This works:</p>

<pre><code>this.store.select(fromRoot.getClientFacilitiesArray).take(1).subscribe(res =&gt; {
                    Observable.from(res).min&lt;ClientFacility&gt;((a, b) =&gt; a.leaders_assigned - b.leaders_assigned)
                        .subscribe(res =&gt; console.log(res));
                })
</code></pre>

<p>This fails:</p>

<pre><code>this.store.select(fromRoot.getClientFacilitiesArray).take(1)
.min&lt;ClientFacility&gt;((a, b) =&gt; a.leaders_assigned - b.leaders_assigned)
                        .subscribe(res =&gt; console.log(res));
</code></pre>
","3324298","","3324298","","2017-04-17 05:09:30","2017-04-17 05:09:30","Rxjs use min operator on array property","<angular><operators><min><rxjs5><ngrx>","1","6","","","","CC BY-SA 3.0"
"43441246","2","","43440192","2017-04-16 19:32:07","","3","","<p><code>Rx.Observable.fromArray([1,3,5,7,9,2,4,6,8]).min()</code> is an example for RxJS 4 that won't work with RxJS 5.</p>

<p>The proper place for RxJS 5 documentation is <a href=""http://reactivex.io/rxjs/"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/</a> , while <a href=""http://reactivex.io/documentation/"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/</a> contains RxJS 4 documentation.</p>

<p>According to <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-min"" rel=""nofollow noreferrer""><code>min</code> operator documentation</a>, it can accept compare function, which behaves similarly the one accepted by <a href=""https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"" rel=""nofollow noreferrer"">array <code>sort</code> method</a>.</p>

<p><a href=""http://plnkr.co/edit/6xJTQkTxTY2sR4En8RV4?p=preview"" rel=""nofollow noreferrer"">Here</a> is an example:</p>

<pre><code>Rx.Observable.from([{a: 1, b:""first""},{a: 3, b:""second""},{a: 5, b:""third""}])
.min((objA, objB) =&gt; objA.a - objB.a)
.subscribe(val =&gt; console.log(val));
</code></pre>
","3731501","","3731501","","2017-04-16 19:45:44","2017-04-16 19:45:44","","","","2","","","","CC BY-SA 3.0"
"43444630","1","43447673","","2017-04-17 03:14:09","","2","539","<p>The RxJS <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/withlatestfrom.md"" rel=""nofollow noreferrer"">withLatestFrom</a> is an instance method. An instance of an Observable has to be newed up/created to call the method. </p>

<p>The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/merge.md"" rel=""nofollow noreferrer"">merge</a> method is a static method. There is no need of an instance needed.</p>

<p>Why the RxJS <code>withLatestFrom</code> is not a static method but an instance method? </p>
","1768008","","310726","","2017-04-17 08:31:58","2017-04-17 08:31:58","Why withLatestFrom RxJS method not static?","<rxjs><reactive-programming><rxjs5>","2","0","","","","CC BY-SA 3.0"
"43447673","2","","43444630","2017-04-17 08:09:54","","3","","<p>I think a good example is the <code>combineLatest</code> operator that exists as both static and instance method. The order of source Observables to <code>combineLatest</code> doesn't matter. Its internals work the same way and the output is going to be the same (just the order of values in the resulting array is going to be different which is irrelevant). The same applies to <code>concat</code>, <code>merge</code>, <code>zip</code>, <code>forkJoin</code> and so on.</p>

<p>However with the <code>withLatestFrom</code> operator it's different and the order of Observables matters. There's one source Observable that controls when the operator emits. If you changed the order it'd produces different results. For example if you had the following:</p>

<pre><code>Observable.withLatestFrom(o1, o2, o3)
</code></pre>

<p>This means you could also use the following:</p>

<pre><code>Observable.withLatestFrom(...observables)
</code></pre>

<p>Now you can't know which Observable is the source and it's going to be hard to debug what's going on.</p>

<p>So the reason why there's no <code>Observable.withLatestFrom</code> static method is because it doesn't make much sense. The order of Observables matters and it'd make things just more obfuscated.</p>

<p>For the same reason other operators such as <code>buffer</code> or <code>window</code> don't have their static forms even though there's no technical limitation. It'd just allow you to write more imperative code instead of simply chaining operators.</p>
","310726","","","","","2017-04-17 08:09:54","","","","0","","","","CC BY-SA 3.0"
"43450579","1","43451071","","2017-04-17 11:29:06","","4","9485","<p>I have some RxJS code and this is part of it:</p>

<pre><code>.mergeMap(action =&gt; {
  const user = store.getState().user;
  return ajax.post(`${config.API_BASE_URL}/api/v1/rsvps`, {
    rsvp: {
      meetup_id: action.payload,
      user_id: user.id,
    }
  })
  .map(action =&gt; calendarActions.rsvpAdded(action.payload));
})
</code></pre>

<p>However, my server is telling me that the params are not in the right format:</p>

<pre><code>[info] POST /api/v1/rsvps
[debug] Processing by ParrotApi.RsvpController.create/2
  Parameters: %{""rsvp"" =&gt; ""[object Object]""}
  Pipelines: [:api_auth]
[info] Sent 400 in 10ms
</code></pre>

<p>I tried using JSON.stringify but that didn't work. It just made my params a string.</p>

<pre><code>rsvp: JSON.stringify({
  meetup_id: action.payload,
  user_id: 123,
})
</code></pre>

<p><code>Parameters: %{""rsvp"" =&gt; ""{\""meetup_id\"":1,\""user_id\"":123}""}</code></p>
","1555312","","310726","","2017-08-08 08:44:07","2017-12-05 09:59:09","RxJS v5: How to make a POST request with params?","<javascript><ajax><rxjs><rxjs5><redux-observable>","1","2","2","","","CC BY-SA 3.0"
"43451071","2","","43450579","2017-04-17 12:00:47","","9","","<p>I don't know what parameter format is expected by your server but if you want to send JSON payload you should also include proper headers <code>Content-Type: application/json</code>. With RxJS 5 it's like the following:</p>

<pre><code>ajax.post('url', {param: 42}, { 'Content-Type': 'application/json' });
</code></pre>

<p>Now, the body payload is going to be automatically converted to JSON. (See <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/dom/AjaxObservable.ts#L286"" rel=""noreferrer"">AjaxObservable.ts#L286</a>.</p>

<p>Or if you don't want to send headers you'll need to convert the entire object to JSON yourself:</p>

<pre><code>ajax.post('url', JSON.stringify({param: 42}));
</code></pre>

<p>By the way, you definitely don't want to combine these two methods (including the headers and calling <code>JSON.stringify</code> yourself) because this would convert the same payload to JSON twice.</p>
","310726","","","","","2017-04-17 12:00:47","","","","1","","","","CC BY-SA 3.0"
"43462628","1","43463287","","2017-04-18 02:31:16","","8","2845","<p>I am trying to use <a href=""https://github.com/ReactiveX/RxJS"" rel=""noreferrer"">rxjs 5</a> to write a Node.js server in TypeScript, but I hit an error when converting <code>fs.readFile</code> to its rxjs form. I expect the following code would work in TypeScript</p>

<pre><code>// This is a JavaScript example from the official documentation. It should
// also work at the TypeScript envrionment.

import * as fs from 'fs';
import { Observable } from 'rxjs';

let readFileAsObservable = Observable.bindNodeCallback(fs.readFile);

// This is the line that throws the error.
let result = readFileAsObservable('./roadNames.txt', 'utf8');

result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
</code></pre>

<p>However, my editor reports a TypeScript error when I add the second parameter <code>'utf-8'</code></p>

<pre><code>Supplied parameters do not match any signature of call target.
</code></pre>

<p>I try to find a guide on how to use the <code>fs.readFile()</code> in rxjs and TypeScript but there isn't much luck.</p>
","4064930","","6680611","","2017-04-18 03:55:35","2017-06-01 10:25:30","Cannot create observable from Observable.bindNodeCallback(fs.readFile) in TypeScript","<typescript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"43463287","2","","43462628","2017-04-18 03:54:16","","18","","<p><code>bindCallback</code> and <code>bindNodeCallback</code> can be tricky with TypeScript, as it all depends upon how TypeScript infers the function parameters.</p>

<p>There is likely a better way, but this is what I do to see exactly what is being inferred: assign the observable to something totally incompatible and look closely at the effected error. For example, this:</p>

<pre><code>const n: number = Observable.bindNodeCallback(fs.readFile);
</code></pre>

<p>will effect this error:</p>

<pre><code>Type '(v1: string) =&gt; Observable&lt;Buffer&gt;' is not assignable to type 'number'.
</code></pre>

<p>So it's obvious that TypeScript is matching the path-only overload of <code>readFile</code>.</p>

<p>In situations like this, I often use an arrow function to specify exactly which overload I want to use. For example, this:</p>

<pre><code>const n: number = Observable.bindNodeCallback((
  path: string,
  encoding: string,
  callback: (error: Error, buffer: Buffer) =&gt; void
) =&gt; fs.readFile(path, encoding, callback));
</code></pre>

<p>will effect this error:</p>

<pre><code>Type '(v1: string, v2: string) =&gt; Observable&lt;Buffer&gt;' is not assignable to type 'number'.
</code></pre>

<p>So it's now matching the desired overload and the following will work:</p>

<pre><code>let readFileAsObservable = Observable.bindNodeCallback((
  path: string,
  encoding: string,
  callback: (error: Error, buffer: Buffer) =&gt; void
) =&gt; fs.readFile(path, encoding, callback));

let result = readFileAsObservable('./package.json', 'utf8');
result.subscribe(
  buffer =&gt; console.log(buffer.toString()),
  error =&gt; console.error(error)
);
</code></pre>
","6680611","","","","","2017-04-18 03:54:16","","","","3","","","","CC BY-SA 3.0"
"43472607","1","","","2017-04-18 12:46:52","","0","117","<p>I have to call three web services from an Angular2 app, and I have to chain them. Both of them can be called together, so I use forkJoin. But later, I have to use an Id returned from one of the service to call another service.
Which is the proper way of chain the last service with the result of the forkJoin?</p>

<p>Althought I can use flatMap, this last service does not make a transformation of what it is got from the forkJoin (map and flatMap are called transforming operators. They should only be used when weâre transforming the returned data to something else).</p>

<p>Should I subscribe to the forkJoin and then, in case of the success, subscribe again to the last service (I don't like it)? Or should I use Zip (or ZipAll) operator?
Thank you very much in advance.</p>

<p>Edit: I'm gonna provide an example.
Let says I have to get some project information, and I have three services:</p>

<ol>
<li><p><code>getProject(projectId)</code>: get information about a project, like its title, duration, ... and an projectPropertiesId with some properties then the project can have.</p></li>
<li><p><code>getProperties()</code>: get the list of all properties than any project can have.</p></li>
<li><p><code>getProjectProperties(propertiesId)</code>: get a list of the selected properties.
One solution could be:</p></li>
</ol>

<pre class=""lang-js prettyprint-override""><code>this.subscriber1 = Observable.forkJoin(this.projectService.getProject(projectId), this.projectService.getProperties())
.subscribe(data =&gt; {
  this.project = data[0];
  this.properties = data[1];
  this.subscriber2 = 
  this.projectService.getProperties(this.project.propertiesId)
    .subscribe(selectedProperties =&gt; {
       // save the selected properties...
    }
});
</code></pre>

<p>Shouldn't be better to after you have the forkJoin, use the Zip operator to chain the last service call (projectService.getProperties) instead to have a subscriber inside another subscriber?</p>
","5811905","","3633742","","2017-04-18 15:30:58","2017-04-19 02:25:05","RxJs5 in Angular: Which is the proper way of chaining Observable that does not transform data?","<angular><rxjs5>","1","3","","","","CC BY-SA 3.0"
"43497775","1","","","2017-04-19 13:53:24","","0","491","<p>I'm trying to have an array of categories that contains item but without no luck.
This is the code:</p>

<pre><code>public getItemsAndSubcategoriesFromCatAndCategory(catalogue_key: string, category_key: string): Observable&lt;any&gt; {
        return this.categoriesService.getSubCategories(catalogue_key, category_key)
            .combineAll()
            .switchMap((val) =&gt; {
                const obj = {};
                this.getItemsInSubcategory(catalogue_key, val[0].key).map((items) =&gt; {
                    obj[val[0].key] = items;
                });
                return obj;
            });
    }
</code></pre>

<p>the error is:</p>

<blockquote>
  <p>Argument of type (val: {}) => {} is not assignable to parameter of
  type (value: {}, index: number) => ObservableInput&lt;{}></p>
</blockquote>

<p>any Idea?</p>
","3880234","","1251861","","2017-04-19 14:00:20","2017-07-21 09:20:25","angular - rxjs Observable array","<angular><rxjs5>","1","1","","","","CC BY-SA 3.0"
"43522009","1","43522924","","2017-04-20 14:12:16","","2","2870","<p>I'm calling 2 services in a <code>forkJoin</code>, the second service may fail, but I want the <code>stream</code> to continue if the second service does fails.</p>

<p>What I have so far:</p>

<pre><code>Observable.forkJoin([
    this.http.get('/service1'),
    this.http.get('/service2').catch(error =&gt; Observable.empty())
])
    .do(([result1, result2]: any[]) =&gt; {
        //When service2 fails, I never get in here with .empty()

    })
</code></pre>

<p><code>Observable.of(undefined)</code> or <code>Observable.of(error)</code> works. But, I was under the impression that returning just an <code>empty Observable</code> from the <code>catch</code> would make the call fail silently and the stream would continue?</p>

<p>How can I ensure that the stream continues if service2 fails?</p>
","2275792","","2275792","","2017-04-20 14:59:49","2017-04-20 14:59:49","angular 2: rxjs forkJoin http error continue stream","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43522924","2","","43522009","2017-04-20 14:50:17","","5","","<p><code>Observable.empty()</code> simply invoke <code>complete</code> method of <code>observer</code> object, so it does not do anything else.
And this is how <code>forkJoin</code> work:</p>

<blockquote>
  <p>When all observables complete emit the last value from each.</p>
</blockquote>

<p><code>Observable.empty()</code> does not have any last value, so <code>forkJoin</code> cannot know how to <code>emit the last value</code>. if you <code>Observable.of(undefined)</code> this mean, you call <code>next</code> method with <code>undefined</code> then <code>complete</code> method will call. so the last value is <code>undefined</code>.</p>

<blockquote>
  <p>How can I ensure that the stream continues if service2 fails?</p>
</blockquote>

<p>you can add error handler and complete handler for testing purpose.</p>

<p>Demo here: <a href=""http://jsbin.com/babirakiyi/1/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/babirakiyi/1/edit?js,console</a></p>

<p>Thank <a href=""https://stackoverflow.com/users/351705/yury-tarabanko"">@Yury Tarabanko</a> for test case:</p>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/524259a9bf2154824ddced89efc71c2e4149b2a9/spec/observables/forkJoin-spec.ts#L165-L174"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/524259a9bf2154824ddced89efc71c2e4149b2a9/spec/observables/forkJoin-spec.ts#L165-L174</a></p>
","3676586","","-1","","2017-05-23 12:09:36","2017-04-20 14:57:09","","","","1","","","","CC BY-SA 3.0"
"43526314","1","43527127","","2017-04-20 17:38:11","","7","2118","<p>I'm using a stream which is throttled when I scroll the window.<br>
While throttling (as long as scrolling), it emits values to the console.</p>

<p>However  , when stream is idle (user is <em>not</em> scrolling the window) - I want a timer to kick in. However - if the user starts scrolling again -  I don't want that timer to emit values.</p>

<p>Currently I'm doing this : </p>

<pre><code>  const observable = Rx.Observable.fromEvent(window, 'scroll');

  const subscriber = observable
      .throttleTime(300 )
      .map(() =&gt; 'throttle')
      .merge(Rx.Observable.interval(1000).map(() =&gt; 'tick') )
      .subscribe(
          (x) =&gt; {
            console.log('Next: event!', x);
          },
          (err) =&gt; {
            console.log('Error: %s', err);
          },
          () =&gt; {
            console.log('Completed');
          });
</code></pre>

<p>The problem is that  , while scrolling -  I see both <code>""throttle""</code> AND <code>""tick""</code>  (  I should only  see ""throttle"")</p>

<p>Think of this from another POV. A job always has to run. If I scroll - that throttled scroll - should invoke the job. If I don't scroll  - a timer should kick in and start doing the job . (and stops if user start scrolling again).</p>

<p><strong>Question:</strong><br>
How can I start a timer after an idle time of not scrolling ?</p>

<p><a href=""https://plnkr.co/edit/JX3QCjj6a9sBPM4fivZL?p=preview"" rel=""nofollow noreferrer""><strong>PLNKR</strong></a> </p>
","859154","","859154","","2017-04-23 07:20:48","2017-04-23 07:20:48","RXJS - start a timer only when idle?","<javascript><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"43527127","2","","43526314","2017-04-20 18:24:14","","2","","<p>I'd do it like this:</p>

<pre><code>const scroll$ = Rx.Observable.fromEvent(window, 'scroll')
    .throttleTime(300 /* ms */)
    .publish();

scroll$.connect();

const subscriber = scroll$
    .map(() =&gt; 'throttle')
    .race(Rx.Observable.interval(1000).map(() =&gt; 'tick'))
    .take(1)
    .repeat()
    .subscribe(
        (x) =&gt; {
          console.log('Next: event!', x);
        },
        (err) =&gt; {
          console.log('Error: %s', err);
        },
        () =&gt; {
          console.log('Completed');
        });
</code></pre>

<p>This uses the <code>race()</code> operator to subscribe only to the Observable that emits first which is the 1s <code>interval</code> or the scroll event. Right after that I want to start this again with another interval so I use <code>take(1).repeat()</code>.</p>

<p>I also had to turn the <code>scroll$</code> Observable into a hot Observable to keep the <code>throttleTime()</code> running among the repeated subscriptions.</p>

<p>Your updated demo: <a href=""https://plnkr.co/edit/sWzSm32uoOQ1hOKigo4s?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/sWzSm32uoOQ1hOKigo4s?p=preview</a></p>
","310726","","","","","2017-04-20 18:24:14","","","","4","","","","CC BY-SA 3.0"
"43527607","1","","","2017-04-20 18:50:11","","1","58","<p>everyone,
I'm learning Web App program use Angular 2, and I want implement a Service.</p>

<p>This service like this:</p>

<pre><code>@Injectable
export class MyService {
  private _data: Any;
  private _dataReady: boolean = false;

  getData(): Observable&lt;any&gt; {

    if (this._dataReady)
      return Observable.of(this._data);
    else {

       http.get('url').subscribe(response=&gt;{
          this._data = do_some_calc(response, this._data);

          if (need_more_data(this._data)) {
             Recursive http.get('url')....
          } else {
             this._dataReady = true;
             return Observable.of(this._data);
          }

       });
    }
  }

}
</code></pre>

<p>the difficult part for me is when data is not ready, need get some data from web, and depend the information from the new arrived data, may be need get another data from web again.</p>

<p>how implement this part and finally return client a Observalbe?</p>

<p>I know how to implement this use callback function , but I very interest how to use RxJS implement.</p>

<p>Thanks.</p>
","1036923","","310726","","2017-04-20 20:55:26","2017-09-23 17:01:05","how to use RxJS do this job","<angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43553370","2","","43398244","2017-04-21 23:18:50","","7","","<p>As ddcc3432 mentioned, I personally would defer to storing the cached results in the redux store itself. This is the most natural place for it.</p>

<p>Here's a general example of doing that, assuming you maintain some sort of loading state as well. If you don't need a loading state, than dispatching some action when serving from cache isn't neccesary? You can just ignore by filter <code>LOAD_DATA_REQUEST</code> as ddcc3432 mentioned.</p>

<pre><code>const yourDataCache = (state, action) =&gt; {
  switch (action.type) {
    case LOAD_DATA_REQUEST:
      return {
        ...state,
        // however you index your requests
        [action.criteria]: {
          isLoading: true
        }
      };

    case LOAD_DATA_SUCCESS:
      return {
        ...state,
        // however you index your responses
        // here I'm assuming criteria is a string and is
        // also included in the response. Change as needed
        // for your real data
        [action.criteria]: {
          isLoading: false,
          ...action.response
        }
      };

    case LOAD_DATA_CACHED:
      return {
        ...state,
        // however you index your responses
        [action.criteria]: {
          isLoading: false, // just change the loading state
          ...state[action.criteria] // keep existing cache!
        }
      };

    default:
      return state;
  }
};

const loadDataEpic = (action$, store) =&gt; 
  action$.ofType(LOAD_DATA_REQUEST)
    .mergeMap(action =&gt; {
      const { yourDataCache } = store.getState();

      // If the data is already cached, we don't need to
      // handle errors. All this code assumes criteria is
      // a simple string!
      if (yourDataCache[action.criteria]) {
        return Observable.of({
          type: LOAD_DATA_CACHED,
          criteria: action.criteria
        });

      } else {
      return getData(action.criteria)
        .map(x =&gt; loadDataSuccess(x.response))
        .catch(error =&gt; Observable.of(loadDataFailure(error.xhr)))
      }
    });
</code></pre>

<p>You might find it easier to store the loading (e.g. <code>isLoading</code>) state in its own reducer, so you don't need to do additional merging of it with the actual response payloads--I personally do that, but I didn't in this example as I've most don't and it sometimes throws them off.</p>

<hr>

<p>However, you clarified that you wish to use RxJS replay instead, so here's one way of doing that</p>

<p>(see my comments on your answer first)</p>

<p>If you want to cache based on the ""criteria"", you can create your own little helper that does this:</p>

<pre><code>const cache = new Map();

const getData = criteria =&gt; {
  if (cache.has(criteria)) {
    return cache.get(criteria);
  } else {
    // Using publishReplay and refCount so that it keeps the results
    // cached and ready to emit when someone subscribes again later
    const data$ = Observable.ajax.post('some-url', criteria)
      .publishReplay(1)
      .refCount();

    // Store the resulting Observable in our cache
    // IMPORTANT: `criteria` needs to be something that will later
    // have reference equallity. e.g. a string
    // If its an object and you create a new version of that object every time
    // then the cache will never get a hit, since cache.has(criteria) will return
    // false for objects with different identities. `{ foo: 1 } !== { foo: 1}`
    cache.set(criteria, data$);
    return data$;
  }
};

const loadDataEpic = action$ =&gt;
  action$.ofType(LOAD_DATA_REQUEST)
    .mergeMap(action =&gt;
      getData(action.criteria)
        .map(x =&gt; loadDataSuccess(x.response))
        .catch(error =&gt; Observable.of(
          loadDataFailure(error.xhr)
        ))
    );
</code></pre>

<p>However, it's <strong>critical</strong> that <code>criteria</code> is something that will always have strict reference equality given the same intent. If it's an object and you create a new object every time, they will never get a cache hit because they are not the same <em>reference</em>, they have different identities--regardless of whether they have the same content.</p>

<pre><code>let a = { foo: 1 };
let b = { foo: 1 };
a === b;
// false, because they are not the same object!
</code></pre>

<p>If you need to use objects and cannot otherwise key off some primitive (like an ID string), you will need some way to serialize them.</p>

<pre><code>JSON.stringify({ foo: 1, bar: 2 }) === JSON.stringify({ foo: 1, bar: 2 })
// true, but only if the keys were defined in the same order!!

JSON.stringify({ bar: 2, foo: 1 }) === JSON.stringify({ foo: 1, bar: 2 })
// false, in most browsers JSON.stringify is not ""stable"" so because
// the keys are defined in a different order, they serialize differently
// See https://github.com/substack/json-stable-stringify
</code></pre>

<p>Try as much as possible to use and send unique IDs to the server, rather than complex JSON. Sometimes it's inescapable for various reasons, but try hard! As you see with cache stuff, it will make your life much easier.</p>

<hr>

<p>You may want to consider cache eviction. Does this cache always keep results indefinitely while the window is open? Is that bad? Depending on how often, the size, etc this could cause significant memory leaks. Careful :)</p>
","1770633","","1770633","","2017-04-21 23:33:24","2017-04-21 23:33:24","","","","0","","","","CC BY-SA 3.0"
"43591819","1","43591862","","2017-04-24 15:14:30","","3","1574","<p>I have two observables and I want listen to the one that emits its first value last, is there an operator for this ? Something like that :</p>

<pre><code>let obs1 = Rx.Observable.timer(500,500);
let obs2 = Rx.Observable.timer(1000,1000); // I want the values from this one
let sloth = Rx.Observable.sloth(obs1,obs2);
</code></pre>

<p>where the <code>sloth</code> observable would emit the values from <code>obs2</code> as it is the one who emits its first value last.</p>

<p>If that's not the case, is there any other way ?</p>
","3633742","","3633742","","2017-04-24 15:36:40","2020-02-25 16:01:45","Is-there an opposite of the `race` operator in RxJS?","<javascript><rxjs><rxjs5>","5","0","1","","","CC BY-SA 3.0"
"43591862","2","","43591819","2017-04-24 15:17:24","","2","","<p>I see this possibility, for now, but I'm curious if someone find anything else :</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let obs1 = Rx.Observable.timer(500,500).map(i=&gt;`cheetah ${i}`);
let obs2 = Rx.Observable.timer(1000,1000).map(i=&gt;`sloth ${i}`);
let sloth = Rx.Observable.merge(
  obs1.take(1).mapTo(obs1),
  obs2.take(1).mapTo(obs2)
).takeLast(1).mergeAll()

sloth.subscribe(data=&gt;console.log(data))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.3.0/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Edit</strong> as pointed out by @user3743222 (very nice nickname :-D ), it would not work for hot observables, but this should be fine :</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let obs1 = Rx.Observable.timer(500,500).map(i=&gt;`cheetah ${i}`).publish();
let obs2 = Rx.Observable.timer(1000,1000).map(i=&gt;`sloth ${i}`).publish();
obs1.connect();
obs2.connect();
let sloth = Rx.Observable.merge(
  obs1.take(1).map((val)=&gt;obs1.startWith(val)),
  obs2.take(1).map((val)=&gt;obs2.startWith(val))
).takeLast(1).mergeAll();
    
sloth.subscribe(data=&gt;console.log(data));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.3.0/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3633742","","3633742","","2017-04-25 08:10:20","2017-04-25 08:10:20","","","","0","","","","CC BY-SA 3.0"
"43602770","1","","","2017-04-25 06:00:52","","7","3543","<p>I have two streams of objects, the accounts and balances.  </p>

<p>I need to merge (join) the two streams according to the <code>id</code> and <code>account_id</code> </p>

<pre><code>var accounts = Rx.Observable.from([
    { id: 1, name: 'account 1' },
    { id: 2, name: 'account 2' },
    { id: 3, name: 'account 3' },
]);

var balances = Rx.Observable.from([
    { account_id: 1, balance: 100 },
    { account_id: 2, balance: 200 },
    { account_id: 3, balance: 300 },
]);
</code></pre>

<p>What is expected:</p>

<pre><code>var results = [
    { id: 1, name: 'account 1', balance: 100},
    { id: 2, name: 'account 2', balance: 200},
    { id: 3, name: 'account 3', balance: 300},
];
</code></pre>

<p>Is this feasible with RxJs ?</p>

<p>To be clear I know how to do this with plain js/lodash or something similar. In my case I am getting these streams from Angular Http Module, so I am asking If I could get benefit of RxJs in this case</p>
","1104402","","1104402","","2017-04-25 08:09:58","2018-04-05 05:07:17","joining two streams of observables in RxJs according to specific conditions","<javascript><rxjs><reactive-programming><rxjs5>","2","4","4","","","CC BY-SA 3.0"
"43620219","1","43621535","","2017-04-25 20:18:59","","2","535","<p>Looking at the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-combineLatest"" rel=""nofollow noreferrer""><em>definition</em></a> of <code>combineLatest</code></p>

<blockquote>
  <p>Combines multiple Observables to create an Observable whose values are
  calculated from the latest values of each of its input Observables.</p>
</blockquote>

<p>or</p>

<blockquote>
  <p>Whenever any input Observable emits a value, it computes a formula
  using the latest values from all the inputs, then emits the output of
  that formula.</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/rmYyn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rmYyn.png"" alt=""enter image description here""></a></p>

<p>It's pretty clear to see that at each period of time / emission , the result at that emission is the combination of the latest  emissions.</p>

<p>If so , looking at this code </p>

<pre><code>const obs1 = Rx.Observable.of(1, 2, 3, 4, 5);
const obs2 = Rx.Observable.of('a', 'b', 'c')
const obs3 = obs2.combineLatest(obs1, (a, b) =&gt; a+b);

const subscribe = obs3.subscribe(latestValues =&gt; {
  console.log(latestValues   );
});
</code></pre>

<p>The result is : </p>

<pre><code>c1,c2,c3,c4,c5
</code></pre>

<p>And when I change</p>

<pre><code>obs2.combineLatest(obs1..
</code></pre>

<p>to</p>

<pre><code>obs1.combineLatest(obs2..
</code></pre>

<p>â I get <code>5a,5b,5c</code></p>

<p><strong>Question:</strong></p>

<p>The docs don't specify any difference regarding  the order of invocation (if so - why do I get different results) ? </p>

<p>Why don't I see other combinations with the other source ? It seems that one source is taking its last value and <em>only then</em> -  join it to each value from the OTHER source. </p>

<p>It seems like that this is what actually happening:</p>

<pre><code>[other source]---a---b---c------------------------
[first source]-------------1----2-----3-----4----5
[result]-------------------c1---c2----c3----c4---c5
</code></pre>

<p>And when I swap the order (obs1&lt;->obs2) :</p>

<pre><code>[first source]-----1--2---3--4--5----------------
[other source]---------------------a-----b------c
[result]---------------------------5a----5b-----5c
</code></pre>

<p>What's going on here? why does one stream has to finish in order for the join to start ?</p>

<p>Why don't I see something like this ( or a variation) : </p>

<pre><code>[first source]-----1-----2--------3-------4------5---
[other source]---------a-----b------c----------------
[result]---------------1a------2b------3b---4c-------5c
</code></pre>

<p><a href=""http://jsbin.com/wufokeqemo/1/edit?html,js,console"" rel=""nofollow noreferrer""><strong>JSBIN</strong></a></p>
","859154","","","","","2017-04-25 21:47:42","combineLatest behaviour in Rxjs 5?","<javascript><rxjs><rxjs5><combinelatest>","1","0","","","","CC BY-SA 3.0"
"43621535","2","","43620219","2017-04-25 21:47:42","","4","","<p>This is because values from your source Observables are emited synchronously unless you use a Scheduler. This means that first <code>obs1</code> emits all values and only the last one is remembered by <code>combineLatest</code> and than <code>obs2</code> starts emiting all its values (the same appplies if you switch the two Observables). Now the <code>combineLatest</code> has values for both Observables so any emission from the second Observables will make the operator emit a value.</p>

<p>Why it works like this is because <code>Observable.of</code> is implemented as <code>ArrayObservable</code> internally and by default it doesn't use any Scheduler. This means that all its emissions happen synchronously. See <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/ArrayObservable.ts#L118"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/observable/ArrayObservable.ts#L118</a></p>

<p>Btw, you can add <code>Rx.Scheduler.async</code> as the last parameter to both source Observables.</p>
","310726","","","","","2017-04-25 21:47:42","","","","2","","","","CC BY-SA 3.0"
"43623868","1","","","2017-04-26 02:12:42","","16","17346","<p>Hi I have the following code and I would like to know how to prevent the main (upstream) Observable from getting deleted when an error is thrown.</p>

<p>How can I change the following code so that all numbers expect '4' get displayed?</p>

<p>I am looking for a general pattern solution that would work in other cases with different operators. This is the simplest case I could come up with.</p>

<pre><code>const Rx = require('rxjs/Rx');

function checkValue(n) {
  if(n === 4) {
    throw new Error(""Bad value"");
  }
  return true;
}
const source = Rx.Observable.interval(100).take(10);

source.filter(x =&gt; checkValue(x))
  .catch(err =&gt; Rx.Observable.empty())
  .subscribe(v =&gt; console.log(v));
</code></pre>
","1010258","","859154","","2018-02-20 12:24:55","2018-02-20 12:24:55","RxJS how to ignore an error with catch and keep going","<javascript><exception><error-handling><rxjs5>","2","0","3","","","CC BY-SA 3.0"
"43624880","1","43625052","","2017-04-26 04:10:11","","1","1295","<p>I thought I understood combineLatest, but given my output - I'm not understanding it. I thought with combineLatest that all observables emit their last values whenever ANY of the observables emit.</p>

<p>(note: I just did the take(5) to limit my console output)</p>

<p>So, given this trivial example - </p>

<pre><code>const int1$ = Rx.Observable.interval(1000).take(5)
const int2$ = Rx.Observable.interval(500).take(5)
const int3$ = Rx.Observable.interval(3000).take(5)
const all$ = Rx.Observable.combineLatest(
  int1$, int2$, int3$ 
)

all$.subscribe(latestValues =&gt; {
  const [int1, int2, int3] = latestValues;
  console.log(`
      interval one @ 1000 ${int1},
      interval two @ 500 ${int2},
      interval three @ 3000 ${int3}
  `)
})
</code></pre>

<p>I thought to see</p>

<pre><code>""
      interval one @ 1000 0,
      interval two @ 500 1,
      interval three @ 3000 0
  ""
""
      interval one @ 1000 1,
      interval two @ 500 2,
      interval three @ 3000 0
  ""
""
      interval one @ 1000 1,
      interval two @ 500 3,
      interval three @ 3000 1
  ""
""
      interval one @ 1000 2,
      interval two @ 500 4,
      interval three @ 3000 1
</code></pre>

<p>BUT I am getting</p>

<pre><code>""
      interval one @ 1000 2,
      interval two @ 500 4,
      interval three @ 3000 0
  ""
""
      interval one @ 1000 3,
      interval two @ 500 4,
      interval three @ 3000 0
  ""
""
      interval one @ 1000 4,
      interval two @ 500 4,
      interval three @ 3000 0
  ""
""
      interval one @ 1000 4,
      interval two @ 500 4,
      interval three @ 3000 1
</code></pre>

<p>slightly confused. Your thoughts on why I am not seeing what I expect would be awesome!</p>
","1054992","","6264830","","2017-04-26 07:35:26","2017-05-31 05:03:50","RxJS combineLatest confusion","<javascript><reactive-programming><rxjs5>","1","1","","","","CC BY-SA 3.0"
"43625052","2","","43624880","2017-04-26 04:28:16","","3","","<p><a href=""http://reactivex.io/documentation/operators/combinelatest.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators/combinelatest.html</a> 
CombineLatest emits an item whenever any of the source Observables emits an item </p>

<p>(so long as each of the source Observables has emitted at least one item) &lt;&lt;== THIS</p>

<p>int3 is not emitted any items before 3000ms, so Rx waits for it, then calls onNext with latest items</p>

<p>Possible solution: try to use timer instead (emits first value at 0s, then once every n s)</p>

<pre><code>const int1$ = Rx.Observable.timer(0,1000).take(5)
const int2$ = Rx.Observable.timer(0,500).take(5)
const int3$ = Rx.Observable.timer(0,3000).take(5)
const all$ = Rx.Observable.combineLatest(
  int1$, int2$, int3$ 
)

all$.subscribe(latestValues =&gt; {
  const [int1, int2, int3] = latestValues;
  console.log(`
      interval one @ 1000 ${int1},
      interval two @ 500 ${int2},
      interval three @ 3000 ${int3}
  `)
})
</code></pre>
","6264830","","6264830","","2017-05-31 05:03:50","2017-05-31 05:03:50","","","","1","","","","CC BY-SA 3.0"
"43625294","1","","","2017-04-26 04:49:37","","1","685","<p>I am getting a TypeScript compiler error with RxJS 5 when I use <code>startWith</code>. However if I move this (initial) value into the <code>scan</code> operator everything compiles and run fine.</p>

<p>I can't figure out the source of the error. Sample code from my Angular 4 test app shown below.</p>

<p>Compile error:</p>

<pre><code>rxjs-counter: master$ ng s                                                                                                      
** NG Live Development Server is running on http://localhost:4200 **                                                            
Hash: ef256d342c83fd7c92a6                                                                                                      
Time: 15133ms                                                                                                                   
chunk    {0} polyfills.bundle.js, polyfills.bundle.js.map (polyfills) 165 kB {4} [initial] [rendered]                           
chunk    {1} main.bundle.js, main.bundle.js.map (main) 5.48 kB {3} [initial] [rendered]                                         
chunk    {2} styles.bundle.js, styles.bundle.js.map (styles) 9.77 kB {4} [initial] [rendered]                                   
chunk    {3} vendor.bundle.js, vendor.bundle.js.map (vendor) 2.98 MB [initial] [rendered]                                       
chunk    {4} inline.bundle.js, inline.bundle.js.map (inline) 0 bytes [entry] [rendered]                                         

ERROR in /home/yadav/dev/javascript/rxjs-counter/src/app/app.component.ts (46,19): Argument of type '{ count: number; }' is not 
assignable to parameter of type 'IScheduler | ((v: CounterData) =&gt; { count: number; })'.                                        
  Object literal may only specify known properties, and 'count' does not exist in type 'IScheduler | ((v: CounterData) =&gt; { coun
t: number; })'.                                                                                                                 
webpack: Failed to compile. 
</code></pre>

<p>Sample template: (app.component.html)</p>

<pre><code>&lt;h1&gt;
  {{title}}
&lt;/h1&gt;
&lt;div&gt;{{count}}&lt;/div&gt;
&lt;div&gt;
  &lt;button (click)=""onStart()""&gt;Start&lt;/button&gt;
  &lt;button (click)=""onStop()""&gt;Stop&lt;/button&gt;
  &lt;button (click)=""onReset()""&gt;Reset&lt;/button&gt;
&lt;/div&gt;
</code></pre>

<p>Sample code: (app.component.ts)</p>

<pre><code>import { Component } from '@angular/core';
import { Observable, Subject } from 'rxjs/Rx';

interface CounterData {
  count: number;
}

interface CounterFunc {
  (arg: CounterData);
}

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Reactive Counter';
  count = 0;

  // Observable (streams)
  start$: Subject&lt;number&gt;;
  stop$: Subject&lt;number&gt;;
  reset$: Subject&lt;number&gt;;

  counter$: Observable&lt;CounterData&gt;;
  intervalUntil$: Observable&lt;number&gt;;

  constructor() {
    this.start$ = new Subject();
    this.stop$ = new Subject();
    this.reset$ = new Subject();

    // Observable that cancels on a stream.
    this.intervalUntil$ = Observable
      .interval(500)
      .takeUntil(this.stop$);

    // Notice that takeUntil is on the inner Observable, putting it on the outer Observable
    // would kill the entire Observable chain, and we would need to re-subscribe on it again.
    this.counter$ = this.start$
      .switchMapTo(Observable.merge(
          this.intervalUntil$.mapTo(this.incCount),
          this.reset$.mapTo(this.resetCount)
      ))
      .startWith({count: 0})
      .scan((acc: CounterData, curr: CounterFunc) =&gt; curr(acc));

    // Assign observer to cancelable interval stream.
    this.counter$
      .subscribe((v: CounterData) =&gt; {
        this.count = v.count;
        console.log(v);
      });
  }

  resetCount(v: CounterData) {
    return {count: 0};
  }

  incCount(v: CounterData) {
    return {count: v.count + 1};
  }

  onStart() {
    this.start$.next();
  }

  onStop() {
    this.stop$.next();
  }

  onReset() {
    this.reset$.next();
  }

}
</code></pre>
","1010258","","","","","2017-04-27 11:04:14","RxJS startWith generates a TypeScript compiler error in Angular 4 app","<angular><typescript><compiler-errors><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43651560","1","43652635","","2017-04-27 07:43:38","","9","713","<p>I'm having a hard time figuring out how exactly this import statement works (in an Angular application written in Typescript):</p>

<pre><code>import 'rxjs/add/operator/toPromise';
</code></pre>

<p>I get that <code>rxjs</code> is mapped to the respective <code>node_modules</code> subfolder in the SystemJS config file, but then I'm stuck. I see that there is an index.js file but I don't see whether or how this helps to resolve the <code>add/operator/...</code> part.</p>

<p>Similarly, I don't understand this one:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
</code></pre>

<p>Again, there is no file <code>Observable.*</code> file in this place. I guess that it somehow works via the index.js file but I'd really like to get a more thorough understanding because I read that it is easy to import all of RxJS by accident which increases page load times.</p>

<p>I had a closer look at the Typescript module resolution documentation but I have the feeling that this is not sufficient to explain it.</p>

<p><strong>Update:</strong> After reading the accepted answer below I figured out I had been looking at the <code>node_modules/rx</code> directory instead of <code>node_modules/rxjs</code> so the import statements match perfectly with the directory structure.</p>
","302793","","310726","","2017-04-27 10:56:43","2017-04-27 10:56:43","Trying to understand RxJS imports","<angular><typescript><rxjs><rxjs5>","1","0","3","","","CC BY-SA 3.0"
"43652635","2","","43651560","2017-04-27 08:32:43","","6","","<p>It's pretty simple because TypeScript by default looks into <code>node_modules</code> directory.</p>

<p>Importing the following:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
</code></pre>

<p>is resolved as <code>node_modules/rxjs/Observable.d.ts</code> which is enough to compile the code. </p>

<p>Similarly importing <code>rxjs/add/operator/toPromise</code> is resolved as <code>node_modules/rxjs/add/operator/toPromise.ts</code>. Btw you can use the <code>--traceResolution</code> compiler option to see what TypeScript path are tested.</p>

<p>When you have your compiled JS (eg. in <code>commonjs</code> format) you can run your app in <code>node</code> because it'll call <code>require('rxjs/Observable')</code> which will resolve to <code>node_modules/rxjs/Observable.js</code>. Then similarly with <code>rxjs/add/operator/toPromise</code>.</p>

<p>Be aware that the code structure of RxJS github page is different than the actual npm package. Basically, just the <code>package.json</code> and the <a href=""https://github.com/ReactiveX/rxjs/tree/master/src"" rel=""noreferrer""><code>src</code></a> dir with compiled <code>.js</code> and <code>.d.ts</code> files are uploaded to the npm repository (the original <code>.ts</code> source files are in <code>node_modules/rxjs/src</code> but you never want to work directly with them).</p>
","310726","","310726","","2017-04-27 09:52:10","2017-04-27 09:52:10","","","","4","","","","CC BY-SA 3.0"
"43659462","1","43669405","","2017-04-27 13:34:09","","7","9040","<p>I can get the observable to fire the value once. But I want it to occure whenever the value of the variable changes. Effectively I need a watcher. Which is what I thought the point of an observable was. To observe a value or state of things and update anything that was subscribed to it.</p>

<p>Anyways, here's the code</p>

<pre><code>import { Component, OnInit } from '@angular/core';

var Rx = require('rxjs/Rx');

import { Subject } from ""rxjs/Rx"";

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.scss']
})
export class HomeComponent implements OnInit {

  private testBool: boolean = false;
  private observable;

  constructor() {  

    this.observable = Rx.Observable.of(this.testBool);

    this.observable.subscribe(
      (value) =&gt; console.log(value)
    )
  }

  toggleBool() {
    this.testBool = !this.testBool;

  }

}
</code></pre>

<p>so whenever the value of this.testBool changes, I want the subscribe to get updated. In it's current state, I get one console log and then nothing. I click the button that updates the boolean but the observer subscriber never fires again.</p>

<p>Am I missing some crucial point and this isn't how I'm supposed to use this? </p>

<p>And I know that I can bind the observer to the button click, but that's not how I want to achieve this. This would be a service level example. So anything anywhere could update the value.</p>

<p>I've read about subjects but I'm still learning. So maybe I'm supposed to be doing something with that?</p>

<p>Thanks</p>
","1255188","","","","","2021-10-04 13:19:47","how to emit a change in rxjs based on a value","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43660497","1","43669519","","2017-04-27 14:20:27","","2","2552","<p>With the following piece of code (taken from an @Effect() in ngrx/store)</p>

<pre><code>.switchMap(({token, param1, param2}) =&gt; {
  return Observable.combineLatest(
    this.service.getData2(token, param1),
    this.service.getData2(token, param2),
    this.service.getData3(token),
  );
})
</code></pre>

<p>What would be the most succinct yet correct pattern to catch the errors?
Should the .catch follow every <code>getData*</code> call? We don't want <code>.catch()</code> at the end of the main <code>@Effect()</code> chain, do we?</p>

<p>The question is similar to <a href=""https://stackoverflow.com/questions/41755718/how-to-trap-errors-from-chained-rxjs-observables-when-using-combinelatest"">this one</a>, yet a bit different in that I don't a <code>.subscribe()</code> call here.</p>
","776686","","-1","","2017-05-23 12:09:56","2017-04-27 23:29:24","Handling errors when using combineLatest on several service calls","<rxjs><rxjs5><ngrx-effects>","1","0","","","","CC BY-SA 3.0"
"43661646","1","","","2017-04-27 15:12:02","","0","660","<p>What I'm trying to do is pull some data from mongodb using streams, do some operations on data, use keys of incoming data to do another query in mongo and then join the data.</p>

<p>The actual code is much more complex but i will illustrate with simpler example.</p>

<p>The problem I have is that on complete never gets fired and I'm assuming because the outer observable never completes.</p>

<pre><code>const o$ = RxNode.fromStream(getDataFromMongo(), 'end'))
    .filter(doSomeFiltering)
    .bufferCount(100)
    .flatMap(bufferedData =&gt; {
        let ids = _.map(bufferedData, 'id');

        return RxNode.fromStream(getMoreDataFromMongodb(ids))
            .reduce(createMapIdObject(), {})
            .flatMap(createdMap =&gt; {  //because i get here, outer never complets
                return Observable.from(bufferedData)
                .map(item =&gt; ({
                    id: item.id,
                    size: createdMap[item.id].size
                }));
            });
    })
    .subscribe(
        c =&gt; console.log(c),
        err =&gt; console.log(err),
        () =&gt; console.log('COMPLETE') // never happens
    );
</code></pre>

<p><strong>How can i get the complete to fire? Or is there a better way to do what I'm trying to achieve?</strong></p>

<p>If I chain <code>.finally(() =&gt; console.log(done)</code>  on <code>Observable.from</code> inside nested <code>flatMap</code>, that gets fired. So inner observable is completing but outer doesn't.</p>
","2410055","","","","","2017-05-23 08:56:10","RXJS observable not completing on flatMap(Observable::from)","<javascript><mongodb><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"43669231","1","43684442","","2017-04-27 22:59:33","","3","110","<p>For a variable of type <code>Observable&lt;T&gt;</code>, I tried to assign an <code>Observable&lt;S&gt;</code> where <code>S</code> is a partial of <code>T</code> and surprised that there's no assignment error during compilation.</p>

<p>Would love to pick your brains to understand the cause of this behaviour.</p>

<pre><code>// RxJS 5.3.0
// TS 2.2.2

interface Super {
  a: number;
  b: number;
}

interface Subset {
  a: number;
}

type Maybe&lt;T&gt; = T | undefined;

// Both of the following produce errors
const super1: Super = {a: 1} as Subset;
const superMaybe: Maybe&lt;Super&gt; = { a: 1 } as Maybe&lt;Subset&gt;;

// But this doesn't error
const superObservable: Rx.Observable&lt;Super&gt; = Rx.Observable.of&lt;Subset&gt;({a: 1});
</code></pre>
","1598723","","310726","","2017-04-28 16:02:51","2017-04-28 16:02:51","[Typescript][RxJS] Why is there no type error when returning an observable of partial type?","<typescript><rxjs><rxjs5><typescript2.0>","1","1","0","","","CC BY-SA 3.0"
"43669405","2","","43659462","2017-04-27 23:17:16","","12","","<p>You want to subscribe and send a new value to the observable. In that case you will need a <code>Subject</code>. In this case we are using a BehaviorSubject, in a BehaviorSubject you can set a default value.</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { BehaviorSubject } from &quot;rxjs/Rx&quot;;

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.scss']
})
export class HomeComponent implements OnInit {
  private testBool: boolean = false;
  private observable: BehaviorSubject&lt;boolean&gt; = new BehaviorSubject&lt;boolean&gt;(false);

  constructor() {  
    this.observable.subscribe((value) =&gt; console.log(value))
  }

  toggleBool() {
    this.testBool = !this.testBool;
    this.observable.next(this.testBool);
  }
}
</code></pre>
","2564847","","3950160","","2021-10-04 13:19:47","2021-10-04 13:19:47","","","","4","","","","CC BY-SA 4.0"
"43669519","2","","43660497","2017-04-27 23:29:24","","3","","<p>This totally depends on the desired behaviour. Lets asume you are fetching 3 animals which you will display. What do you want to happen when one fail?</p>

<ul>
<li>Do not display any animal. -> add a <code>catch</code> to the end</li>
<li>Display the other animals. -> add <code>catch</code> to each data call.</li>
</ul>
","2564847","","","","","2017-04-27 23:29:24","","","","0","","","","CC BY-SA 3.0"
"43684442","2","","43669231","2017-04-28 16:01:39","","0","","<p>This is in fact unrelated to RxJS. This is a TypeScript issue which is already fixed in the future <code>2.4</code> version. That's why it works when you install <code>typescript@next</code>.</p>

<p>See: <a href=""https://github.com/Microsoft/TypeScript/issues/14770"" rel=""nofollow noreferrer"">https://github.com/Microsoft/TypeScript/issues/14770</a></p>
","310726","","","","","2017-04-28 16:01:39","","","","0","","","","CC BY-SA 3.0"
"43685614","1","43686021","","2017-04-28 17:16:12","","1","2178","<p>EDIT 2: What worked even better was <code>shareReplay(1)</code>, as stated in the update of <a href=""https://stackoverflow.com/a/43686021/4811678"">@karser's answer</a>.</p>

<hr>

<p>EDIT 1: What ended up working best was this:</p>

<pre><code>@Injectable()
export class MyGlobalService {

  private resource$;
  private resource$Connected;

  constructor(private http: Http) {
    this.resource$Connected = false;
    this.resource$ = this.http
      .get('/api/resource')
      .map((res: Response) =&gt; res.json())
      .publishReplay(1);
  } 

  getResource(): Observable&lt;any&gt; {
    if (!this.resource$Connected) {
      this.resource$.connect();
      this.resource$Connected = true;
    }
    return this.resource$;
  }

}
</code></pre>

<p>It only makes the AJAX call once, and it doesn't call until some consumer requires the resource.</p>

<hr>

<p>ORIGINAL QUESTION:</p>

<p>I'm trying to cache an angular HTTP call and multicast the most recent result to all current and future subscribers. The ajax results won't change over the application lifetime, so I don't want to make any extra calls for a resource I already have. Therefore, I want it to continue to stay ""connected"" even when all the subscribers unsubscribe. Is this possible?</p>

<p>What I initially tried was this:</p>

<pre><code>// in a global service 

getResource(): Observable&lt;any&gt; {
  return this.http
    .get('/api/resource')
    .map((res: Response) =&gt; res.json())
    .publishLast()
    .refCount();
}
</code></pre>

<p>This works well for multiple <code>async</code> pipes in the same component, but if that component is destroyed (and thus <code>refCount</code> goes to 0) the HTTP request will be repeated on a later instantiation of the component.</p>

<p>To combat this, I started manually caching the results:</p>

<pre><code>resourceResults: any;

getResource(): Observable&lt;any&gt; {
  if (resourceResults) {
    return Observable.of(this.resourceResults);
  }
  return this.http
    .get('/api/resource')
    .map((res: Response) =&gt; res.json())
    .do(x =&gt; this.resourceResults = x)
    .publishLast()
    .refCount();
}
</code></pre>

<p>This works fine, but I feel like there is a more rx way to do it.</p>

<p>I've tried using <code>connect()</code>, but that seems to suffer the same issue as my first example. Once all the subscribers have unsubscribed, using <code>connect()</code> causes the HTTP request to happen again</p>

<pre><code>resource$ = this.http
  .get('/api/resource')
  .map((res: Response) =&gt; res.json())
  .publishLast()
  .refCount();

getResource(): Observable&lt;any&gt; {
  this.resource$.connect();
  return this.resource$;
}
</code></pre>

<p>Any ideas?</p>
","4811678","","-1","","2017-05-23 11:54:46","2017-09-23 17:00:34","Keep observable connected even with no subscribers","<angular><rxjs><rxjs5>","3","2","","","","CC BY-SA 3.0"
"43686021","2","","43685614","2017-04-28 17:43:23","","1","","<p>publishReplay/connect works. Here is <a href=""https://plnkr.co/edit/bgSX1ZjSNGEovw9YSwrZ?p=preview"" rel=""nofollow noreferrer"">the working plunker</a>:</p>

<pre><code>import {Injectable} from '@angular/core';
import {Http, Response} from '@angular/http';
import {Observable} from ""rxjs/Observable"";

@Injectable()
export class YourService {
    resource:Observable&lt;any&gt;;

    constructor(private http: Http) {
        this.resource = this.http.get('https://api.github.com/users/karser')
            .map((res: Response) =&gt; res.json())
            .do(res =&gt; console.log('response', res))
            .publishReplay(1);
        this.resource.connect();
    }
}
</code></pre>

<p>The output:</p>

<pre><code>Subscribing
response Object {login: ""karser"", id: 1675033â¦}
Unscibscribed
Subscribing once again
</code></pre>

<p>UPDATE: RxJS 5.4 has <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/sharereplay.md"" rel=""nofollow noreferrer"">shareReplay</a> operator which apparently does the same thing. See <a href=""https://plnkr.co/edit/ZCxtWbhStCnggjgjD0ne?p=preview"" rel=""nofollow noreferrer"">the updated plunkr</a></p>

<pre><code>this.http.get('https://api.github.com/users/karser')
    .map((res: Response) =&gt; res.json())
    .shareReplay(1);
</code></pre>

<p>From <a href=""https://github.com/ReactiveX/rxjs/pull/2443#issue-211913196"" rel=""nofollow noreferrer"">pull request</a>:</p>

<blockquote>
  <p><code>shareReplay</code> returns an observable that is the source multicasted
  over a <code>ReplaySubject</code>. That replay subject is recycled on error from
  the source, but not on completion of the source. This makes
  <code>shareReplay</code> ideal for handling things like caching AJAX results, as
  it's retryable. It's repeat behavior, however, differs from share in
  that it will not repeat the source observable, rather it will repeat
  the source observable's values.</p>
</blockquote>
","1642477","","1642477","","2017-05-11 11:00:29","2017-05-11 11:00:29","","","","4","","","","CC BY-SA 3.0"
"43692850","1","43723896","","2017-04-29 07:11:27","","2","811","<p>Here I'm using <code>redux-observable</code> and having some issues testing the error handling.</p>

<p>See the following logout user epic:</p>

<pre><code>const logoutUserEpic = (action$) =&gt; action$
    .ofType(LOGOUT_USER)
    .mergeMap(() =&gt;
        Observable.from(
            graphQl(AuthLogout)
                .catch((error) =&gt; failure(error))
        )
        .mergeMap(() =&gt; Observable.of(
                receive(),
                push('/login')
            )
        )
    )
</code></pre>

<p>Here's a test that mocks out the <code>graphQl</code> service to make sure that it fires the failure action when the promise rejects:</p>

<pre><code>it('should return the error action', () =&gt; {
    const error = Error('fail')
    request.graphQl = () =&gt; Promise.reject(error)

    const action$ = ActionsObservable.of((logoutUser()))

    return logoutUserEpic(action$)
    .toArray()
    .forEach((actions) =&gt; {
        expect(actions).toEqual([{
            meta: { isFetching: false },
            payload: error,
            type: FAILURE
        }])
    })
})
</code></pre>

<p>In the test it dispatches the actions that are flattened in mergeMap rather than the expected failure action in the catch.</p>

<p>Is it valid to have the error handling set up like this or am I showing my noobishness with RxJs?</p>
","1770624","","","","","2017-05-01 17:57:13","Testing error handling for redux-observable epics","<redux><rxjs><rxjs5><reactivex><redux-observable>","1","0","1","","","CC BY-SA 3.0"
"43698166","1","","","2017-04-29 16:48:53","","1","624","<p><em>I already know that in order to enable communication between components (or other parts) - I can create a centralized Injectable service :</em> </p>

<pre><code>@Injectable()
export class PubSubService
{
    private publishSubscribeSubject_: Subject &lt;any&gt; = new Subject();
    emitter_: Observable &lt;any&gt; ;

    constructor()
    {
        this.emitter_ = this.publishSubscribeSubject_.asObservable();
    }

    publish(data:string): void
    {
        this.publishSubscribeSubject_.next(data);
    }
}
</code></pre>

<p>Now â all injected components can subscribe to the public <code>emitter_</code> (without enabled doing <code>.next(..)</code>).</p>

<p><em>But</em> then I saw another approach which uses <code>logic-channels</code>  - so now the service looks like this : </p>

<pre><code>@Injectable()
export class PubSubService {
  private publishSubscribeSubject_:Subject&lt;any&gt; = new Subject();
  emitter_:Observable&lt;any&gt;;

  constructor() {
    this.emitter_ = this.publishSubscribeSubject_.asObservable();
  }

  publish(channel:string, event:any):void {
    this.publishSubscribeSubject_.next({
      channel: channel,
      event: event
    });
  }

  subscribe(channel:string, handler:((value:any) =&gt; void)):Subscriber {
    return this.emitter_
      .filter(emission =&gt; emission.channel === channel)
      .map(emission =&gt; emission.event)
      .subscribe(handler);
  }
}
</code></pre>

<p>Those channels are merely strings which are bypassed to the elements via  :</p>

<pre><code>  &lt;node subscribeChannel=""foo""   publishChannel=""bar""&gt;
  &lt;/node&gt;
  &lt;node subscribeChannel=""bar""   publishChannel=""foo""&gt;
  &lt;/node&gt;
</code></pre>

<p><em>Notice</em> how two same-type-nodes subscribe to a <em>different</em> channel and publish to <em>different</em> channels.</p>

<p><code>NodeComponent</code> is :</p>

<pre><code>export class NodeComponent implements OnDestroy {
  @Input() publishChannel:string;
  @Input() subscribeChannel:string;
  count:number = 0;
  private pubSubServiceSubscription_:Subscription;


  constructor(private pubSubService_:PubSubService) {}

  send() {
    this.pubSubService_
      .publish(this.publishChannel, {});
  }

  ngAfterViewInit() {
    this.pubSubService_
      .subscribe(this.subscribeChannel, 
                 event =&gt; ++this.count);
  }

  ngOnDestroy() {
    this.pubSubServiceSubscription_.unsubscribe();
  }

}
</code></pre>

<p><strong>Question:</strong></p>

<p>What (if any) do I gain from this infrastructure  ?</p>

<p>I can think that it allows me to subscribe to a specific <code>""banana""</code> channel within a <code>fruits Subject</code>  (which can't deal with <code>""furnitures""</code>).</p>

<p>But when I think about it all subscribers to fruits will have a reference to that subject .</p>

<p>What is a benefit in that structure , and in what scenarios will it help me ? </p>

<p><em>( I would love to see an example where not using it , will do something bad).</em></p>

<p><a href=""https://plnkr.co/edit/Y1T3ycCByiMqYHOFPTAw?p=preview"" rel=""nofollow noreferrer""><strong>PLNKR</strong></a></p>
","859154","","","","","2017-04-29 16:48:53","Observable channels in RXJS with Angular?","<javascript><angular><rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"43712287","1","43712335","","2017-04-30 23:09:47","","-1","1209","<p>I am trying to filter an array ( which has all type of values) to get the integers only. following is the code, </p>

<pre><code>let numbers=  [1,2,3,'test',2.33,true];

  let my = Observable.from(numbers).filter( n =&gt; Number.isInteger(Number(n)));

  my.subscribe((value) =&gt; console.log(value),undefined,() =&gt; console.log('completed'));
</code></pre>

<p>The problem is that my output looks as follows,</p>

<pre><code>1, 2 , 3 , true , completed
</code></pre>

<p>so it is converting the bollean values to a number than returning it thinking it is a number. Do we have a nicer way to filter only numbers from an mixed array ??</p>
","2225263","","2225263","","2017-04-30 23:14:39","2017-04-30 23:16:30","Filter integers(numbers) from an mixed array in Typescript","<typescript><ecmascript-6><observable><rxjs5>","1","7","0","","","CC BY-SA 3.0"
"43712335","2","","43712287","2017-04-30 23:16:30","","1","","<p>How about</p>

<pre><code>let result = numbers.filter(v =&gt; Number.isInteger(v as number));
</code></pre>
","251311","","","","","2017-04-30 23:16:30","","","","6","","","","CC BY-SA 3.0"
"43713500","1","43713650","","2017-05-01 02:26:40","","5","7449","<p>I have a table that shows information, upon clicking on a table row, user can update the values
once he completes the request, the table is not updated with the new values and I must do an F5 to refresh the view.</p>
<p>How do I force a new get request upon completing the request</p>
<p>here is the relevant code</p>
<p>MY SERVICE</p>
<pre class=""lang-ts prettyprint-override""><code>import { Injectable } from '@angular/core';

import { Http, Response } from '@angular/http';

import {Observable} from 'rxjs/Rx';

import { BehaviorSubject } from 'rxjs/BehaviorSubject';

// Import RxJs required methods
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';

import { Device } from '../model/Device';

@Injectable()
export class DeviceService {

  devices$: BehaviorSubject&lt;Device[]&gt;;

  constructor(private http : Http) {
    this.initializeDevices();
  }

  initializeDevices() {
    var url = &quot;./api/read/network/device&quot;;
    //var url = '../assets/data/devices.json';
    if (!this.devices$) {
      this.devices$ = &lt;BehaviorSubject&lt;Device[]&gt;&gt; new BehaviorSubject(new Array&lt;Device&gt;());
      this.http.get(url)
        .map((res:Response) =&gt; res.json())
        .subscribe(devices =&gt; {
          this.devices$.next(devices);
      });
    }
  }

  subscribeToDevices(): Observable&lt;Device[]&gt;  {
    return this.devices$.asObservable();
  }

}
</code></pre>
<p>my component</p>
<pre class=""lang-ts prettyprint-override""><code>import { Component, OnInit, ViewChild } from '@angular/core';

import { DeviceService } from '../../services/device.service';
import { MacService } from '../../services/mac.service';
import { Device } from '../../model/Device';

@Component({
  selector: 'app-device-table',
  templateUrl: './device-table.component.html',
  styleUrls: ['./device-table.component.sass']
})
export class DeviceTableComponent implements OnInit {

  devices;
 
  //reference to the datatable needed to count filtered rows
  @ViewChild
  ('dt') dt;

  constructor(private deviceService : DeviceService, private macService : MacService) { }

  ngOnInit() {
    this.registerEvents();
    this.getDevices();
  }

  getDevices(){
    this.deviceService.subscribeToDevices().subscribe(
      devices =&gt; this.processDevices(devices),
      error =&gt; console.log(error)
    );
  }

  processDevices(devices){
    //just data manipulation
  }

  emitShowDialogEvent(device) {
    if(!device.macAddress) {
      return;
    }
      this.macService.broadcastShowDialogEvent(device.macAddress);
  }

  registerEvents(){

    this.macService.dataChangedEvent.subscribe(event =&gt;{
      console.log('data changed event');
      this.getDevices();  //not provoking a new GET request to the API :(
    });
  }

}
</code></pre>
<p>I have another component, MACService, that upon sending a POST request emits an event that is captured as dataChangedEvent</p>
","1832932","","74089","","2021-03-05 07:19:31","2021-03-05 07:19:31","How to refresh an observable in angular2 after a POST","<angular><rxjs><observable><rxjs5>","1","0","1","","","CC BY-SA 4.0"
"43713650","2","","43713500","2017-05-01 02:51:49","","3","","<p>Two ways you can use.</p>

<p>One is call GET request inside POST subscribe event.</p>

<pre><code>this.guardianService.editGuardian(this.guardData).subscribe(res=&gt; {
  this.loadData();  // this is function who makes GET request
});
</code></pre>

<p>The other way is to use ReplaySubject.</p>

<pre><code>private subject: Subject&lt;any&gt; = new ReplaySubject&lt;any&gt;(1);

get $getSubject(): Observable&lt;any&gt; {
  return this.subject.asObservable();
}

loadData() {
    this._http.get(url, header)
        .map(x=&gt;x.json())
        .subscribe(data=&gt; {
          this.subject.next(data);
        });
}

postData(data) .....
</code></pre>

<p>This is Service.
Here here goes component</p>

<pre><code>this.serviceHandle.$getSubject.subscribe(res =&gt; {
  //here goes any thing you want to do.
});
this.serviceHandle.loadData(); // this function will make reqeust


this._accountService.editAccountData(account).subscribe(res=&gt; {
  this.serviceHandle.loadData();
});
</code></pre>
","7313391","","","","","2017-05-01 02:51:49","","","","2","","","","CC BY-SA 3.0"
"43715301","1","43748366","","2017-05-01 06:39:43","","3","912","<p>I'm trying to use react native <a href=""https://facebook.github.io/react-native/docs/geolocation.html"" rel=""nofollow noreferrer"">Geolocation</a> to <code>getCurrentPosition</code> and then as soon as the position is returned, use <a href=""https://github.com/devfd/react-native-geocoder"" rel=""nofollow noreferrer"">react native geocoder</a> to use that position to get the location. I'm using <a href=""https://github.com/redux-observable/redux-observable"" rel=""nofollow noreferrer"">redux-observable</a> epics to get all of this done. </p>

<p>Here are my two epics:</p>

<p><strong>location.epic.js</strong></p>

<pre><code>import { updateRegion } from '../map/map.action'
import Geocoder from 'react-native-geocoder'

export const getCurrentLocationEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_LOCATION)
    .mergeMap(() =&gt;
      Observable.fromPromise(Geocoder.geocodePosition(makeSelectLocation()))
        .flatMap((response) =&gt; Observable.of(
          getCurrentLocationFulfilled(response)
        ))
        .catch(error =&gt; Observable.of(getCurrentLocationRejected(error)))
    )

export const getCurrentPositionEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_POSITION)
    .mergeMap(() =&gt;
      navigator.geolocation.getCurrentPosition(
        (position) =&gt; Observable.of(
          updateRegion(position),
          getCurrentLocation(position)
        ),
        error =&gt; Observable.of(getCurrentPositionRejected(error)),
        { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }
      ).do(x =&gt; console.log(x))
    ).do(x =&gt; console.log(x))
</code></pre>

<p>As soon as the app starts, this code executes:</p>

<pre><code>class Vepo extends Component {
  componentDidMount() {
    const { store } = this.context
    this.unsubscribe = store.subscribe(() =&gt; { })
    store.dispatch(fetchCategories())
    store.dispatch(getCurrentPosition())
  }
</code></pre>

<p><code>fetchCategories()</code> is an action that has an epic too, but that is working. dispatching the <code>getCurrentPosition()</code> action runs through the epic above. The only output that I can see is that my reducer handles <code>getLocationRejected()</code> as it console logs this:</p>

<pre><code>there was an issue getting your current location:  Error: invalid position: {lat, lng} required
    at Object.geocodePosition (geocoder.js:15)
    at MergeMapSubscriber.project (location.epic.js:17)
    at MergeMapSubscriber._tryNext (mergeMap.js:120)
    at MergeMapSubscriber._next (mergeMap.js:110)
    at MergeMapSubscriber.Subscriber.next (Subscriber.js:89)
    at FilterSubscriber._next (filter.js:88)
    at FilterSubscriber.Subscriber.next (Subscriber.js:89)
    at Subject.next (Subject.js:55)
    at Object.dispatch (createEpicMiddleware.js:72)
    at Object.dispatch (devTools.js:313)
</code></pre>

<p>Here is my reducer:</p>

<pre><code>const searchPage = (
  initialLocationState = initialState.get('searchForm').get('location'),
  action: Object): string =&gt; {
  switch (action.type) {
    case GET_CURRENT_LOCATION_FULFILLED: {
      return action.payload
    }
    case GET_CURRENT_LOCATION_REJECTED: {
      console.log('there was an issue getting your current location: ', 
        action.payload)
      return initialLocationState
    }
    case GET_CURRENT_POSITION_REJECTED: {
      console.log('there was an issue getting your current position: ', 
        action.payload)
      return initialLocationState
    }
    default:
      return initialLocationState
  }
}
</code></pre>

<p>Is there anything obvious I am doing wrong? My attempt to debug by adding <code>.do(x =&gt; console.log(x))</code> does nothing, nothing is logged to the console. <code>updateRegion()</code> never does fire off because that dispatches an action and the reducer <code>UPDATE_REGION</code> never executes. But the execution must make it into the success case of <code>getCurrentPosition()</code> eg:</p>

<pre><code>(position) =&gt; Observable.of(
              updateRegion(position),
              getCurrentLocation(position)
            ),
</code></pre>

<p>must execute because the <code>getCurrentLocation(position)</code> does get dispatched. </p>

<p>Where am I going wrong?</p>
","3935156","","3935156","","2017-05-01 07:54:52","2018-02-02 23:45:46","redux-observable to get current location","<react-native><redux><rxjs><rxjs5><redux-observable>","1","3","","","","CC BY-SA 3.0"
"43715959","1","43718422","","2017-05-01 07:49:23","","1","385","<p>I use RxJs to process data replayed from a file. Each data item contains a <code>timereceived</code> property. While replaying, I want to create buffers with all data items originally received within a given timespan x. In other words: I want to add all items to the current buffer while the timespan between the first buffer element received and the current element received is less than timespan x.</p>

<p>Example test:</p>

<pre><code>it('should be able to create buffers based on time received', function() {
    // given
    let source = require('rx').Observable.from([
        {val: 1, timereceived: 10},
        {val: 2, timereceived: 20},
        {val: 3, timereceived: 100},
        {val: 4, timereceived: 110},
        {val: 5, timereceived: 120}
    ]);

    // when
    let actual = app.bufferWithTimeReceived(source, 105).toArray();

    // then
    console.log(actual);
    assert.equal(actual.length, 2); // first contains val 1-3, second val 4-5
})
</code></pre>

<p>If I would not replay all data from the file but just receive it in real time, I could use bufferWithTime for that and would be fine.</p>

<h2>Update with another example</h2>

<pre><code>    // given
    let source = require('rxjs/Rx').Observable.from([
        {val: 1, timereceived: 10},
        {val: 2, timereceived: 20},
        {val: 3, timereceived: 100},
        {val: 4, timereceived: 110},
        {val: 5, timereceived: 120},
        {val: 6, timereceived: 9920},
        {val: 7, timereceived: 9930}
    ]);

    // when
    app.bufferWithTimeReceived(source, 30).subscribe(console.log);


    // then
    // expected output would be [val 1-2][val 3-5][val 6-7] (empty arrays in between would be ok)
</code></pre>

<h2>Update end</h2>

<p>Now I played around with different approaches. My last one was:</p>

<pre><code>exports.bufferWithTimeReceived = (source, timespan) =&gt; {
    return Rx.Observable.defer(() =&gt; Rx.Observable.create(function (observer) {
        let currBuffer = [];
        source.subscribe(x =&gt; {
            if (currBuffer.length == 0)
                currBuffer = [x];
            else {
                if (x.timereceived-currBuffer[0].timereceived &lt; timespan)
                    currBuffer.push(x);
                else {
                    observer.onNext(currBuffer);
                    currBuffer = [x];
                }
            }
        },
        (err)=&gt;observer.onError(err),
        ()=&gt;observer.onCompleted());
    }));
};
</code></pre>

<p>Unfortunately this only leads to <code>oArrayObservable { source: Defer { _f: [Function] } }</code> as an error message, which is not very helpful. I also wondered how <a href=""https://stackoverflow.com/questions/32625247/rx-divide-stream-into-segments-lists-by-condition"">Rx - Divide stream into segments (lists) by condition</a> might could help me?! </p>

<p>Bonus question: Any hint how I could make this buffer overlapping?</p>
","479330","","-1","","2017-05-23 10:31:34","2017-05-01 11:37:08","How do I implement something like ""bufferWhile"" in RxJs?","<javascript><rxjs><reactive-programming><rxjs5>","2","0","","","","CC BY-SA 3.0"
"43718422","2","","43715959","2017-05-01 11:31:57","","0","","<p>Thanks to martin's answer I thought again about groupBy and this seems to work for me:</p>

<pre><code>exports.bufferWithTimeReceived = (source, timespan) =&gt; {
        let currTime;
        return source.groupBy(x =&gt; {
            if (!currTime)
                currTime = x.timereceived;
            if (x.timereceived-currTime &gt; timespan)
                currTime = x.timereceived;
            return currTime;            
        })
        .map(observable =&gt; observable.toArray())
        .mergeAll()
};
</code></pre>

<p>But I wonder if <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-bufferWhen"" rel=""nofollow noreferrer"">bufferWhen</a> could offer a more elegant solution?!</p>
","479330","","479330","","2017-05-01 11:37:08","2017-05-01 11:37:08","","","","0","","","","CC BY-SA 3.0"
"43723896","2","","43692850","2017-05-01 17:57:13","","2","","<p>The issue is that you're catching the error on the Promise itself and then your <code>mergeMap</code> is ignoring the result of the Promise so you're throwing away <code>failure(error)</code> (presumably an error action)</p>

<pre><code>const logoutUserEpic = (action$) =&gt; action$
    .ofType(LOGOUT_USER)
    .mergeMap(() =&gt;
        Observable.from(
            graphQl(AuthLogout)
                .catch((error) =&gt; failure(error))
                // If there is an error, you caught it and transformed it
                // instead into a failure(error) down the success path
        )
        // If there was an error, it is now no longer an error and this
        // mergeMap will just throw that failure(error) away
        .mergeMap(() =&gt; Observable.of(
                receive(),
                push('/login')
            )
        )
    )
</code></pre>

<p>Instead, you should catch the error using RxJS, in this case placing it after the <code>mergeMap</code>--note that RxJS's <code>catch</code> and Promise <code>catch</code> are similar but not the same thing!</p>

<pre><code>const logoutUserEpic = (action$) =&gt; action$
  .ofType(LOGOUT_USER)
  .mergeMap(() =&gt;
    Observable.from(graphQl(AuthLogout))
      .mergeMap(() =&gt; Observable.of(
        receive(),
        push('/login')
      ))
      .catch((error) =&gt; Observable.of(failure(error)))
  )
</code></pre>
","1770633","","","","","2017-05-01 17:57:13","","","","0","","","","CC BY-SA 3.0"
"43733434","1","43733652","","2017-05-02 08:32:36","","4","1158","<p>I want to convert a function:</p>

<p><code>static getCurrentPosition(geo_success, geo_error?, geo_options?)</code> </p>

<p>to an observable. </p>

<p>As you can see, the first argument to the function is the success callback. </p>

<p>RxJS 5 <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-bindCallback"" rel=""nofollow noreferrer"">bindCallback</a> works on functions where the success callback is the last parameter.</p>

<p>Is there a way to use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-bindCallback"" rel=""nofollow noreferrer"">bindCallback</a> on 
<code>static getCurrentPosition(geo_success, geo_error?, geo_options?)</code> ?</p>

<p>If not then I will manually convert the function to a <code>Promise</code> like number 2 <a href=""https://stackoverflow.com/a/22519785/3935156"">here</a></p>

<p>The function in question can be found <a href=""https://facebook.github.io/react-native/docs/geolocation.html"" rel=""nofollow noreferrer"">here</a></p>

<p>I would like to implement this as an observable:</p>

<pre><code>navigator.geolocation.getCurrentPosition(
  (position) =&gt; {
    updateRegion(position)
    store.dispatch(getCurrentLocation(position))
  },
  error =&gt; Observable.of(getCurrentPositionRejected(error)),
  { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }
)
</code></pre>

<p>My attempt at implementing the answer below:</p>

<pre><code>    class Vepo extends Component {
      componentDidMount() {
        const { store } = this.context
        this.unsubscribe = store.subscribe(() =&gt; { })
        store.dispatch(fetchCategories())
        store.dispatch(getCurrentPosition())

************implementation starts here******************************
        const bound = Observable.bindCallback((options, cb) =&gt; {
          if (typeof options === 'function') {
            cb = options
            options = null
          }

          navigator.geolocation.getCurrentPosition(cb, null, options)
        })
       let x = bound(this.getPosition)

        x.subscribe(
        function (x) {
          console.log('Next: %s', x)
        },
        function (err) {
          console.log('Error: %s', err)
        },
        function () {
          console.log('Completed')
        })

       x.onNext()
      }

      getPosition(position) {
        console.log(position)
        return position
      }
</code></pre>

<p>And it <code>console.log()</code>'s only from inside <code>getPosition()</code></p>
","3935156","","-1","","2017-05-23 12:10:32","2017-05-02 09:42:37","RXJS 5 bindCallback when the callback is the first argument","<javascript><react-native><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43733652","2","","43733434","2017-05-02 08:45:12","","6","","<p>Create a new function with rearranged arguments</p>

<pre><code>const bound = Rx.Observable.bindCallback((options, cb) =&gt; {
  if(typeof options === 'function') {
    cb = options
    options = null
  }

  navigator.geolocation.getCurrentPosition(cb, null, options)
})
</code></pre>

<p>Or use <code>bindNodeCallback</code> if you want to handle errors.</p>
","351705","","","","","2017-05-02 08:45:12","","","","5","","","","CC BY-SA 3.0"
"43748204","1","43748526","","2017-05-02 22:26:43","","3","1588","<p>When I comment out <code>getCurrentPositionEpic</code> in the below code, the app works. But if I leave it uncommented I get the error:</p>

<blockquote>
  <p>Actions must be plain objects. Use custom middleware for async
  actions.</p>
</blockquote>

<pre><code>export const rootEpic = combineEpics(
  fetchCategoriesEpic,
  getCurrentLocationEpic,
  getCurrentPositionEpic
)

const store = createStore(
  rootReducer,
  initialState,
  composeWithDevTools(
    applyMiddleware(createEpicMiddleware(rootEpic))
  )
)
</code></pre>

<p><strong>location.epic.js</strong></p>

<pre><code>const getCurrentPosition$ = getCurrentPositionObservable(
  { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }
)

getCurrentPosition$.subscribe(
  (position) =&gt; {
    console.log(position)
    const positionObject = {
      lat: position.coords.latitude,
      lng: position.coords.longitude
    }
    //store.dispatch(updateRegion(positionObject))
    //getCurrentLocation(positionObject)
  },
  (err) =&gt; {
    console.log('Error: %s', err)
  },
  () =&gt; {
    console.log('Completed')
  })

export const getCurrentLocationEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_LOCATION)
    .mergeMap(() =&gt;
      Observable.fromPromise(Geocoder.geocodePosition(makeSelectLocation()))
        .flatMap((response) =&gt; Observable.of(
          getCurrentLocationFulfilled(response)
        ))
        .catch(error =&gt; Observable.of(getCurrentLocationRejected(error)))
    )

export const getCurrentPositionEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_POSITION)
    .mapTo(() =&gt; getCurrentPosition$
      .flatMap((response) =&gt; Observable.of(
        getCurrentPositionFulfilled(response)
      ))
      .catch(error =&gt; Observable.of(getCurrentLocationRejected(error)))
    )
</code></pre>

<p>the below code is just a helper used to convert react native <code>navigator.geolocation.getCurrentPosition</code> to an observable instead of a function taking a callback. </p>

<p><strong>callBackToObservable.js</strong></p>

<pre><code>import { Observable } from 'rxjs'

export const getCurrentPositionObservable = Observable.bindCallback(
  (options, cb) =&gt; {
    if (typeof options === 'function') {
      cb = options
      options = null
    }
    navigator.geolocation.getCurrentPosition(cb, null, options)
  })
</code></pre>

<p>What could be causing the error?</p>

<p>trying passing in the store:</p>

<pre><code>export const getCurrentPositionFulfilledEpic = (action$, store) =&gt;
  action$.ofType(GET_CURRENT_POSITION_FULFILLED)
        .mergeMap(() =&gt;{
  console.log(store)***************** store is populated here
  return Observable.fromPromise(Geocoder.geocodePosition({
    lat: store.getState().get('searchForm').get('position').lat,***but not here
    lng: store.getState().get('searchForm').get('position').lng
  }))
    .flatMap((response) =&gt; Observable.of(
      getCurrentLocationFulfilled(response)
    ))
    .catch(error =&gt; Observable.of(getCurrentLocationRejected(error)))
}
)
</code></pre>

<p>Using <a href=""http://Geocoder.geocodePosition"" rel=""nofollow noreferrer"">https://github.com/devfd/react-native-geocoder</a> for <code>Geocoder.geocodePosition</code></p>
","2602079","","2602079","","2017-05-03 00:21:49","2017-05-03 00:21:49","redux-observable Actions must be plain objects. Use custom middleware for async actions","<react-native><redux><react-redux><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"43748366","2","","43715301","2017-05-02 22:42:27","","5","","<blockquote>
  <p>What would be your technique for using an epic on a function which takes a callback function? getCurrentPosition() takes a callback and the callback handles the payload. Basically if you remove Observable.of( from inside getCurrentPosition(), that's how getCurrentPosition() is correctly used - and has been working for me without redux-observable. </p>
</blockquote>

<p>Wrapping anything in a custom Observable is fairly simple, very similar to creating a Promise except Observables are lazy--this is important to understand! <a href=""http://reactivex.io/rxjs/manual/overview.html#observable"" rel=""nofollow noreferrer"">RxJS Docs</a></p>

<p>In the case of geolocation, there are two main APIs, <code>getCurrentPosition</code> and <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition"" rel=""nofollow noreferrer""><code>watchPosition</code></a>. They have identical semantics except that <code>watchPosition</code> will call your success callback every time the location changes, not just a single time. Let's use that one since it's natural to model it as a stream/Observable and most flexible.</p>

<pre><code>function geolocationObservable(options) {
  return new Observable(observer =&gt; {
    // This function is called when someone subscribes.

    const id = navigator.geolocation.watchPosition(
      (position) =&gt; {
        observer.next(position);
      },
      error =&gt; {
        observer.error(error);
      },
      options
    );

    // Our teardown function. Will be called if they unsubscribe
    return () =&gt; {
      navigator.geolocation.clearWatch(id);
    };
  });
}

geolocationObservable({ enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 })
  .subscribe(
    position =&gt; console.log(position),
    e =&gt; console.error(e)
  );
  // will log every time your location changes, until you unsubscribe
</code></pre>

<p>Since it's now an Observable, if you only want the current location you can just do <code>.take(1)</code>.</p>

<p>So using it inside your epic might be like this</p>

<pre><code>// If you want, you could also use .share() to share a single
// underlying `watchPosition` subscription aka multicast, but
// that's outside the scope of the question so I don't include it
const currentPosition$ = geolocationObservable({
  enableHighAccuracy: true,
  timeout: 20000,
  maximumAge: 1000
});

export const getCurrentPositionEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_POSITION)
    .mergeMap(() =&gt;
      currentPosition$
        .take(1) // &lt;----------------------------- only the current position
        .mergeMap(position =&gt; Observable.of(
          updateRegion(position),
          getCurrentLocation(position)
        ))
        .catch(error =&gt; Observable.of(
          getCurrentPositionRejected(error)
        ))
    );
</code></pre>

<hr>

<p>As a side note, you might not need to dispatch both <code>updateRegion()</code> and <code>getCurrentLocation()</code>. Could your reducers just listen for a single action instead, since they both seem to be signalling the same intent?</p>
","1770633","","1770633","","2018-02-02 23:45:46","2018-02-02 23:45:46","","","","0","","","","CC BY-SA 3.0"
"43748526","2","","43748204","2017-05-02 23:00:04","","5","","<p>The problem is your usage of <code>mapTo</code>. You're basically saying ""map this action to an Observable"" so now your epic returns an Observable of Observable of actions <code>Observable&lt;Observable&lt;Action&gt;&gt;</code> instead of just an Observable of actions.</p>

<p>Said another way, your epic is now emitting Observables instead of emitting actions. You'd instead need to use a merging strategy operator like <code>mergeMap</code>, <code>switchMap</code>, etc to merge to flatten/merge the inner Observable chain into the top-level one. <code>flatMap</code> is an alias to <code>mergeMap</code>, btw.</p>

<pre><code>export const getCurrentPositionEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_POSITION)
    .mergeMap(() =&gt; getCurrentPosition$
      .flatMap((response) =&gt; Observable.of(
        getCurrentPositionFulfilled(response)
      ))
      .catch(error =&gt; Observable.of(getCurrentLocationRejected(error)))
    )
</code></pre>

<hr>

<p>One other thing--you don't need to use <code>flatMap</code> aka <code>mergeMap</code> to map the <code>getCurrentPosition$</code> to the <code>getCurrentPositionFulfilled</code> action because it's 1:1. You only would need that if it's 1 to many.</p>

<pre><code>export const getCurrentPositionEpic = action$ =&gt;
  action$.ofType(GET_CURRENT_POSITION)
    .mergeMap(() =&gt; getCurrentPosition$
      .map((response) =&gt; getCurrentPositionFulfilled(response))
      .catch(error =&gt; Observable.of(getCurrentLocationRejected(error)))
    )
</code></pre>

<p>There's no real <em>harm</em> in using it your way, but it might confuse others who maintain the code later.</p>
","1770633","","","","","2017-05-02 23:00:04","","","","0","","","","CC BY-SA 3.0"
"43759177","1","43771313","","2017-05-03 11:46:32","","0","294","<p>I have an issue with RXjs' distinceUntilChanged on input field after changing the value on JavaScript.</p>

<p>Steps to reproduce:</p>

<ol>
<li><p>set text ""a"" inside the input</p></li>
<li><p>click on the remove button >> as result the input is empty, with using of javascript</p></li>
<li>set again ""a"" inside the input</li>
<li>click again on the remove button. but now the input stays with the ""a"" value</li>
</ol>

<p>If we would insert another value that is different from 'a', it will work.
Of course, if I remove distinceUntilChanged from my observable, it will work as well.</p>

<p>Code snippet:</p>

<pre><code>@Component({
selector: 'app',
template: `
        &lt;input #input [value]=""value ? value : ''"" (input)=""filter$.next(input.value)""&gt;

        {{val}}
        &lt;div&gt;
            &lt;button (click)=remove()&gt;Remove&lt;/button&gt;
        &lt;/div&gt;
   `
   })

export class App {

  filter$ = new Subject();
  val:string;
  value:string;

  constructor() {

  }

  ngOnInit(): void {
    this.filter$
    .distinctUntilChanged()
    .subscribe((value) =&gt; {
        this.val = value;
        this.value = value;
    }));
    }

    remove(){
    console.log('test');
    this.value = """";
    this.val = """";
   }

 }
</code></pre>

<p>I created a <a href=""https://plnkr.co/edit/JRaSpc2QukKK22H9DeWd?p=preview"" rel=""nofollow noreferrer"">Plunker</a> example with my problem:</p>
","5600573","","5600573","","2017-05-03 18:02:54","2017-05-03 22:59:33","Angular 2 | RXjs issue with distinctUntilChanged after updating view","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43771313","2","","43759177","2017-05-03 22:59:33","","1","","<p>It's because you're just changing the display's text. Your remove function should look like this:</p>

<pre><code>remove() {
  this.filter$.next("""")
}
</code></pre>
","3587412","","","","","2017-05-03 22:59:33","","","","0","","","","CC BY-SA 3.0"
"43792349","1","","","2017-05-04 20:36:42","","0","488","<p>I'm doing something similar though not exactly like drag and drop. I want to click > track movement for a preview > stop tracking on click again > get metadata from last click. But, users can click on multiple things to stop tracking and I want to know what it was since the side effects are different depending on the second item clicked. </p>

<p>Basically, its </p>

<pre><code>clickSomething$ = merge(anythingTheyCanClick);
click$.switchMap(click =&gt; moveData.takeUntil(clickSomething$)) //need to get value from clickSomething$
</code></pre>

<p>This is a specific request for getting the value from a stop observable in takeUntill, but if that's not possible or impractical, an inclusive buffer or window technique (e.g. buffer/window on click, but keep the clicks) could also solve the problem. </p>
","3610034","","310726","","2017-05-06 08:10:03","2017-05-07 00:38:13","How to get value from stop observable in takeUntil","<javascript><reactive-programming><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"43803280","1","43803962","","2017-05-05 11:01:08","","1","102","<p>In the following code, are the functions <code>onReady1()</code> and <code>onReady2()</code> equivalent? What are the differences? Is there a better way to write this function? </p>

<p>The <code>onReadyx()</code> functions should return the user if it is available right away, or it would wait until its available. There will be multiple calls to this function at any given time.</p>

<pre><code>export class UserService {
    private _user: IUser;

    private userObservable: Observable&lt;IUser&gt;;

    constructor(private http: Http) {
        this.userObservable = this.getCurrentUser();
    }

    public onReady1() {
        return Observable.create((observer: Observer&lt;IUser&gt;) =&gt; {
            if (this._user) {
                observer.next(this._user);
                observer.complete();
                return;
            }

            this.userObservable.subscribe(user =&gt; {
                this._user = user;
                observer.next(user);
                observer.complete();
            });
        });
    }

    public onReady2() {
        return Observable.defer(() =&gt; {
            if (this._user) {
                return Observable.of(this._user);
            }

            return this.userObservable.do(user =&gt; this._user = user);
        });
    }

    private getCurrentUser() {
        return this.http.get('/currentuser')
            .map(response =&gt; response.json() as IUser);
    }

}
</code></pre>
","6621","","6621","","2017-05-05 11:34:24","2017-05-05 11:35:22","Better way to return conditional rxjs Observable","<typescript><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"43803962","2","","43803280","2017-05-05 11:35:22","","2","","<p>Use publishLast   </p>

<pre><code>export class Service {
  private sharedStream$: Observable&lt; IUser&gt;;

 constructor(public http: AuthHttp) {
   this.sharedStream$ = this. getCurrentUser()
    .publishLast()
    .refCount();
 }

 getUserObservable(): Observable&lt; IUser&gt; {
  return this.sharedStream$;
 }
}
</code></pre>
","6922095","","","","","2017-05-05 11:35:22","","","","0","","","","CC BY-SA 3.0"
"43843981","1","43859723","","2017-05-08 09:19:43","","0","499","<p>I have method which return Observable, like this:</p>

<pre><code>public getCpuUsage(): Observable&lt;string&gt;  {
    return Observable.create((observer: Observer&lt;string&gt;) =&gt; {
        let plugin = new Plugin();
        plugin.open();
        plugin.OnEvent = (info: string, ack: string, nak: string) =&gt; {
            console.log(""CPU ["" + info + ""].param1["" + ack + ""].param2["" + nak + "" ]"");
            observer.next(info);
            plugin.close();
            observer.complete();
        };
        plugin.executeCommand('getCPUUsage');
    });
}
</code></pre>

<p>Object plugin has callback when will deliver info about cpu. It's work fine.</p>

<p>Other class can call this method like:</p>

<pre><code>public executeInfo(): string {
    this.getCpuUsage()
        .subscribe({
            next: (infoAboutCpu) =&gt; {
                console.log("" Result: "" + infoAboutCpu);
                return infoAboutCpu;
            }
        });

    console.log('Call this line');
    return '-1';
}
</code></pre>

<p>In log a see:<br>
first log: 'Call this line'<br>
second log(after 1-2 seconds, because callback called): 'Result: ${value_cpu_info}'</p>

<p>How I can block current thread, until get result from Observable ? Method executeInfo() must return correct value.</p>
","1994379","","1994379","","2017-05-08 09:49:07","2017-05-09 01:45:57","Block current thread RXJS","<multithreading><typescript><asynchronous><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"43859723","2","","43843981","2017-05-09 01:45:57","","0","","<blockquote>
  <p>Block current thread RXJS</p>
</blockquote>

<p>There is only 1 thread in JavaScript. You can block it with</p>

<pre><code>while(true) {
 // insert break logic here
}
</code></pre>

<p>But I highly recommend you reconsider the requirement.</p>
","390330","","","","","2017-05-09 01:45:57","","","","2","","","","CC BY-SA 3.0"
"43864866","1","43864927","","2017-05-09 08:31:06","","1","254","<p>I would like to change the font color depending on some conditions ==> both datas on comming back from observable returning by Http request, I try out theses codes bellow (Typescript+Angular)</p>

<pre><code>&lt;td *ngFor=""let user of userService.users | async""&gt;{{user.data.apps.details[0].label}}
          &lt;span [style.color]=""user?.data.apps.details[0].state_id as colorId 'green' : 'orange' : 'red'""&gt;

&lt;/td&gt;
</code></pre>

<p>""user"" is my Observable and ""userService"" my http service, the datas inside curly braces {{}} are fetch from a Json object</p>
","6018581","","","","","2017-05-09 10:29:36","NgStyles inside NgFor in Angular 4","<angular><typescript><ecmascript-6><angular2-directives><rxjs5>","1","4","","","","CC BY-SA 3.0"
"43864927","2","","43864866","2017-05-09 08:33:40","","2","","<p>This is not a valid expression</p>

<pre><code>user?.data.apps.details[0].state_id as colorId 'green' : 'orange' : 'red'
</code></pre>

<p><strong>update</strong></p>

<p>This should to what you want if <code>.state_id</code> returns <code>0</code>, <code>1</code>, or <code>2</code>:</p>

<pre><code>&lt;span [style.color]=""['green', 'orange', 'red'][user?.data.apps.details[0].state_id]""&gt;
</code></pre>
","217408","","217408","","2017-05-09 10:29:36","2017-05-09 10:29:36","","","","24","","","","CC BY-SA 3.0"
"43871778","1","43874450","","2017-05-09 13:53:39","","1","1186","<p>I am wondering why the onComplete callback in the example bellow never gets executed. The next callback is executed as expected. If I throw an error inside the observable created by foo, the error callback also gets executed. Only the complete callback does not get executed. </p>

<p>JSBin: <a href=""http://jsbin.com/punoridajo/edit?html,js,console,output"" rel=""nofollow noreferrer"">http://jsbin.com/punoridajo/edit?html,js,console,output</a></p>

<pre><code>let button = document.getElementById('click-me');

let clicks$ = Rx.Observable.fromEvent(button, 'click');

let foo = () =&gt; new Rx.Observable(observer =&gt; {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  observer.next(4);
  observer.next(5);
  console.log('Calling on complete')
  observer.complete();
})

clicks$
  .mergeMap(() =&gt; foo())
  .subscribe(
    e =&gt; console.log(e),
    err =&gt; console.error(err),
    () =&gt; console.info('Completed') //Never gets executed
)
</code></pre>

<p>Everything works as expected When I subscribe directly to the Observable returned by foo. Is it not possible to call complete inside an Observable in association with mergeMap, switchMap or concatMap?</p>
","4382345","","","","","2017-05-09 15:50:21","RxJS on complete callback not executed with mergeMap","<reactive-programming><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43874450","2","","43871778","2017-05-09 15:50:21","","1","","<p>Because click$ observable is not completed. Use take(1) or something to complete it.</p>

<pre><code>clicks$
.take(1)
.mergeMap(() =&gt; foo())
.subscribe(
   e =&gt; console.log(e),
  err =&gt; console.error(err),
  () =&gt; console.info('Completed') //Never gets executed
)
</code></pre>
","6922095","","","","","2017-05-09 15:50:21","","","","0","","","","CC BY-SA 3.0"
"43879955","1","43879956","","2017-05-09 21:12:29","","2","339","<p>My Angular 4 application build via Angular CLI stopped working, apparently out of the blue: </p>

<pre><code>ng --version` 
</code></pre>

<p>results in the following error:</p>

<pre><code>RxJS could not find any global context (window, self, global)
Error: RxJS could not find any global context (window, self, global)
    at /home/jan/.nvm/versions/node/v7.10.0/lib/node_modules/@angular/cli/node_modules/rxjs/util/root.js:15:11
    at Object.&lt;anonymous&gt; (/home/jan/.nvm/versions/node/v7.10.0/lib/node_modules/@angular/cli/node_modules/rxjs/util/root.js:16:3)
    at Module._compile (module.js:571:32)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:488:32)
    at tryModuleLoad (module.js:447:12)
    at Function.Module._load (module.js:439:3)
    at Module.require (module.js:498:17)
    at require (internal/module.js:20:19)
    at Object.&lt;anonymous&gt; (/home/jan/.nvm/versions/node/v7.10.0/lib/node_modules/@angular/cli/node_modules/rxjs/Observable.js:2:14)
</code></pre>
","3342253","","","","","2017-05-10 16:03:17","""RxJS could not find any global context""","<angular><angular-cli><rxjs5>","2","1","","","","CC BY-SA 3.0"
"43879956","2","","43879955","2017-05-09 21:12:29","","3","","<p>Downgrade RxJS to 5.1.1; in <code>package.json</code> remove the caret (<code>^</code>):</p>

<pre><code>""rxjs"": ""5.1.1"",
</code></pre>

<p>and then</p>

<pre><code>npm install
</code></pre>

<p><strong>Update May 10, 2017:</strong></p>

<p>Last night, the <a href=""https://github.com/ReactiveX/rxjs/releases"" rel=""nofollow noreferrer"">RxJS project removed the offending 5.3.2 release and released 5.3.3</a> which addresses this problem so, you can now use a <a href=""https://bytearcher.com/articles/semver-explained-why-theres-a-caret-in-my-package-json/"" rel=""nofollow noreferrer"">caret dependency</a>, again, e.g.:</p>

<pre><code>""rxjs"": ""^5.1"",
</code></pre>

<p><strong>Explanation</strong>:</p>

<p>The RxJS project released 5.3.2 on May 2 which has a backwards compatibility issue. This caused any project with a <a href=""https://bytearcher.com/articles/semver-explained-why-theres-a-caret-in-my-package-json/"" rel=""nofollow noreferrer"">caret dependency</a> on RxJS 5 to fail. The offending 5.3.2 RxJS release was removed on May 9 and replaced with a fixed 5.3.3 release so caret dependencies now work, again.</p>
","3342253","","3342253","","2017-05-10 16:03:17","2017-05-10 16:03:17","","","","2","","","","CC BY-SA 3.0"
"43883109","2","","41650365","2017-05-10 03:26:03","","3","","<p>skip last operator is now added to RxJS 5 <a href=""https://github.com/ReactiveX/rxjs/pull/2316"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/2316</a></p>
","7091035","","310726","","2017-05-10 16:22:59","2017-05-10 16:22:59","","","","0","","","","CC BY-SA 3.0"
"43903636","1","","","2017-05-10 22:24:34","","0","45","<p>I'm trying to solve a problem related to refresh tokens. So basically, I have function that checks if somebody is logged in:</p>

<pre><code>isLogged(): Observable&lt;any&gt; {
  const valid = isTokenValid();
  if (valid) return Observable.of(true);
  else { return this.refresh() }
}
</code></pre>

<p>Obviously, this function returns observable. Now I have refresh function:</p>

<pre><code>refresh() {
  if (this.existingSubscription) return this.existingSubscription;
  this.existingSubscription = this.http.post(...
  return this.existingSubscription;
}
</code></pre>

<p>This generally works, BUT, this.existingSubscription.subscribe still executes request, so I get execution of 2 requests instead of 1. (1 promise, multiple subscribers).</p>

<p>E.g. When token is not valid and I send 5 requests at the same time, it sends 5 same request token requests instead of 1.</p>

<p>this.existingsSubscription.subscribe is executing code all over again instead of subscribing to the existing request that has already been made.</p>

<p>Am I doing something wrong?</p>
","2528911","","2528911","","2017-05-11 09:03:11","2017-05-11 09:03:11","Returning existing promise with RxJs and Angular 2","<angular><rxjs><angular2-services><rxjs5>","0","2","","2017-05-11 11:49:50","","CC BY-SA 3.0"
"43911353","1","43963212","","2017-05-11 09:20:11","","1","1185","<p>Currently can create an observable explicitly as follows:</p>

<pre><code>const Rx = require(""rxjs"");
const request = require(""request"");

        return Rx.Observable.create(function (observer) {
            request(options, function (error, response, body) {
                if (error) {
                    observer.error(error);
                } else {
                    observer.next(response);
                    observer.complete();
                }
            });
        });
</code></pre>

<p>Is there a shorthand way to do this with the RxJs library (or another library)?</p>
","1505487","","1505487","","2017-05-11 10:07:04","2017-05-14 11:12:10","How to create an RxJs Observable from a node request","<javascript><node.js><rxjs><rxjs5><node-request>","1","2","","","","CC BY-SA 3.0"
"43912849","1","43939347","","2017-05-11 10:28:44","","5","1416","<p><a href=""https://i.stack.imgur.com/ctAyN.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/ctAyN.png"" alt=""a-thousand-words""></a></p>

<h1>From picture to code?</h1>

<p>How to get the Out observable from Data and Gates?</p>

<ul>
<li>Data is an observable of any kind e.g. JSON objects to be sent to a remote backend</li>
<li>Gates is a boolean observable, where the ticks correspond to true and the crosses to false. For example, Internet connectivity whereby true means the network became accessible and false reflects a disconnection. </li>
<li>Out is the resulting observable, which emits the same as Data, sometimes immediately, sometimes with a delay, depending on the gate that preceded. For instance, I could subscribe to the Out in order to post the emitted JSON objects to a remote API while connected to the Internet. </li>
</ul>
","742084","","742084","","2017-05-11 10:39:47","2019-02-05 21:29:45","Conditional emission delays with rxjs","<angular><rxjs><observable><reactive-programming><rxjs5>","4","7","1","","","CC BY-SA 3.0"
"43917872","1","43918629","","2017-05-11 14:11:11","","0","554","<p>My angular service returns observable. However, whenever I subscribe to it, it is being called all over again. In this particular example, you can see that request for getting users is being sent 10 times instead of once with multiple observers.</p>

<p>Expected behaviour: Create observable and subscribe to it. Only one request is sent and all subscriptions receive the same value.</p>

<pre><code>@Injectable()
class ExampleService {
  constructor(private http: Http) { }
  read() {
    return this.http.get('https://api.github.com/users');
  }
}

@Component({
  selector: 'my-app',
  template: `
    &lt;div&gt;
      &lt;h2&gt;Hello {{name}}&lt;/h2&gt;

      &lt;button (click)='test()'&gt;Test&lt;/button&gt;
    &lt;/div&gt;
  `,
})
export class App {
  name:string;
  subscription: Observable&lt;any&gt;;

  constructor(private exampleService: ExampleService) {
    this.name = `Angular! v${VERSION.full}`
  }

  test() {
    for (let x = 0; x &lt; 10; x++) {
      if (this.subscription) {
        console.log('Using existing subscription');

        this.subscription.subscribe(
          response =&gt; {
            console.log('From another')
          })
      } else {
        this.subscription = this.exampleService.read();
        this.subscription.subscribe(
          response =&gt; {
            console.log('From originalSubscription');
            this.subscription = null;
          });
      }

    }
  }

}
</code></pre>

<p>Any help?</p>
","2528911","","","","","2017-05-11 14:40:14","Subscribing to existing observable in RxJs","<rxjs><angular2-services><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43918629","2","","43917872","2017-05-11 14:40:14","","1","","<p>Try this:</p>

<pre><code>@Injectable()
class ExampleService {
  constructor(private http: Http) { }
  read() {
    return this.http.get('https://api.github.com/users').publishReplay().refCount();
  }
}
</code></pre>
","2564847","","","","","2017-05-11 14:40:14","","","","2","","","","CC BY-SA 3.0"
"43939347","2","","43912849","2017-05-12 13:46:29","","1","","<p>Inspired by contributions to this post, the following seems to yield the desired behaviors:</p>

<pre><code>const ticks$ = gates$.filter(b =&gt; b)
const crosses$ = gates$.filter(b =&gt; !b)
const tickedData$ = data$.windowToggle(ticks$, _ =&gt; crosses$.take(1)).switch()
const crossedDataBuffers$ = data$.bufferToggle(crosses$, _ =&gt; ticks$.take(1))
const crossedData$ = Rx.Observable.from(crossedDataBuffers$)
const out$ = tickedData$.merge(crossedData$)
</code></pre>

<p>It could possibly be made simpler, have a play at <a href=""https://jsfiddle.net/KristjanLaane/6kbgnp41/"" rel=""nofollow noreferrer"">https://jsfiddle.net/KristjanLaane/6kbgnp41/</a></p>
","742084","","","","","2017-05-12 13:46:29","","","","0","","","","CC BY-SA 3.0"
"43963212","2","","43911353","2017-05-14 11:12:10","","0","","<p>Here is my solution:</p>

<pre><code>    return (options) =&gt; {
        const boundCallback = Rx.Observable.bindNodeCallback(request, toResponseOnly);
        return boundCallback(options);
    };

function toResponseOnly(response) {
    return response;
}
</code></pre>

<p>The second function is required to ensure only the response is passed on, otherwise the params to the callback are passed on as an array.</p>
","1505487","","","","","2017-05-14 11:12:10","","","","0","","","","CC BY-SA 3.0"
"43966834","1","43966971","","2017-05-14 17:24:22","","2","1118","<p>I am trying to create a loop that iterates over the elements in an array and I want to run the loop all over again once it completes. </p>

<p>I have started with the following snippet </p>

<pre><code> Observable.interval(1000).startWith(0)
                            .repeat()
                            .take(array.length)
                            .map(i =&gt; array[i])
                            .subscribe(item =&gt; { 
// some operation here 
             });    
</code></pre>

<p>but it didn't work in my case. </p>
","1646729","","","","","2017-05-22 15:04:22","rxjs angular2 iterate over array with infinite loop","<angular><loops><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"43966971","2","","43966834","2017-05-14 17:36:41","","3","","<p>The problem with your code is that you placed <code>take</code> after <code>repeat</code>, thus <code>take</code> will unsubscribe both the source and <code>repeat</code>.</p>

<p>Another option would be to just take the <code>% n</code>th element of the array, since <code>interval</code> emits numbers, we can use that. I noticed you added <code>startWith</code> to <code>interval</code>. Another way to get an interval that starts without delay is to use <code>timer(0, interval)</code>. Thus our final code might look like:</p>

<pre><code>Observable.timer(0, 1000)
  .map(e =&gt; array[e % array.length])
  .subscribe(item =&gt; { ... })
</code></pre>
","402027","","","","","2017-05-14 17:36:41","","","","1","","","","CC BY-SA 3.0"
"43970243","1","43991013","","2017-05-15 01:01:26","","1","102","<p>I am writing a custom operator to load a csv file and emit each line as data. This operator is supposed to work like the <code>of</code> operator, which is a static function to create observable. I follow the instruction of <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/operator-creation.md"" rel=""nofollow noreferrer"">operator creation</a> and add the operator function directly to Observable prototype.</p>

<p><strong>All following code is written in JavaScript ES6.</strong></p>

<p>My source code is this</p>

<pre><code>import { Observable } from 'rxjs';
import { createInterface } from 'readline';
import { createReadStream } from 'fs';

function fromCSV(path, options) {

  return Observable.create((subscriber) =&gt; {
    let readStream = createReadStream(path);
    let reader = createInterface({ input: readStream });
    let isHeader = true;
    let columns;

    reader.on('line', (line) =&gt; {
      if (isHeader) {
        columns = line.split(',');
        isHeader = false;
      } else {
        let values = line.split(',');
        let valueObject = {};

        for (let i = 0, n = columns.length; i &lt; n; i++) {
          valueObject[columns[i]] = values[i] || undefined;
        }

        subscriber.next(valueObject);
      }
    });

    reader.on('close', () =&gt; subscriber.complete());
    readStream.on('error', (error) =&gt; subscriber.error(error));
  });
}

Observable.prototype.fromCSV = fromCSV;
</code></pre>

<p>The operator function looks totally correct, but when I try to use this operator like</p>

<pre><code>import { Observable } from 'rxjs';
import './rx-from-csv';

Observable.fromCSV(testCSV)
  .subscribe((row) =&gt; {
    console.log(row);
  });
</code></pre>

<p>It throws an error <code>TypeError: _rxjs.Observable.fromCSV is not a function</code>. So the function binding fails and I have no idea why it happens :-( Any help is appreciated.</p>

<p>This particularly confuses me because I have successfully done a similar operator binding for <a href=""https://github.com/haoliangyu/rx-to-csv/blob/master/src/rx-to-csv.js#L61"" rel=""nofollow noreferrer"">another custom csv operator</a>.</p>
","4064930","","4064930","","2017-05-16 00:57:25","2017-05-16 01:11:13","Unable to add custom operator to the Observable class","<javascript><rxjs5>","2","0","","","","CC BY-SA 3.0"
"43976982","1","","","2017-05-15 10:21:03","","5","625","<p>I am trying to use rxjs in my project. I have following sequences, what I expected is that the 1rd sequence will only be handled after a value arrive in another sequence, and only the latest value in the 1st sequence will be reserved. Any suggestion for it?</p>

<pre><code>s1$ |a---b----c-

s2$ |------o----
</code></pre>

<p>expected result:</p>

<pre><code>s3$ |------b--c-
</code></pre>
","6501991","","310726","","2017-05-16 07:52:04","2017-05-16 08:06:17","how to buffer the latest value until another value arrive in another sequence by rxjs?","<javascript><typescript><rxjs5>","3","2","1","","","CC BY-SA 3.0"
"43983477","1","","","2017-05-15 15:34:52","","1","313","<p>I'm tring do build a custom function to reaload my http request every minutes (so don't need to refresh the page)...thanks in advance</p>

<p>So I got a code as bellow:</p>

<pre><code>const usersURL = 'http://my.super.url.php'

@Injectable()
export class UserService {



 users: Observable&lt;User[]&gt;

 constructor (public http:Http) {

       this.users = http.get(usersURL)
                      .map(res =&gt; [res.json()]);


this.users.subscribe(

usersURL =&gt; console.log(usersURL), // Here we catch up the values

() =&gt; {}, // Here we catch up errors

() =&gt; console.log(""completed!"") // Here we catch up if its completed
)
 setTimeout(function(){
     this.users.subscribe.reload();
   }, 60000); // Here I'm trying to reload my call to web API every minutes
</code></pre>

<p>}</p>

<p>}</p>
","6018581","","","","","2017-05-15 15:34:52","Reload function on http request using observable Angular 4","<javascript><json><angular><typescript><rxjs5>","0","8","","","","CC BY-SA 3.0"
"43989889","1","44033163","","2017-05-15 22:41:44","","9","4580","<p>How do I create an Angular 4 client for a Java <a href=""https://projectreactor.io/"" rel=""noreferrer"">Project Reactor</a> reactive <code>Flux</code> API? The sample below has two APIs: a <code>Mono</code> API; and, <code>Flux</code> API. Both work from <code>curl</code>; but in Angular 4 (4.1.2) only the <code>Mono</code> API works; any ideas how to get Angular 4 to work with the <code>Flux</code> API?</p>

<p>Here's a trivial Spring Boot 2.0.0-SNAPSHOT application with a <code>Mono</code> API and a <code>Flux</code> API:</p>

<pre><code>@SpringBootApplication
@RestController
public class ReactiveServiceApplication {

    @CrossOrigin
    @GetMapping(""/events/{id}"")
    public Mono&lt;Event&gt; eventById(@PathVariable long id) {
        return Mono.just(new Event(id, LocalDate.now()));
    }

    @CrossOrigin
    @GetMapping(value = ""/events"", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;Event&gt; events() {
        Flux&lt;Event&gt; eventFlux = Flux.fromStream(
            Stream.generate(
                ()-&gt;new Event(System.currentTimeMillis(), LocalDate.now()))
            );

        Flux&lt;Long&gt; durationFlux = Flux.interval(Duration.ofSeconds(1));

        return Flux.zip(eventFlux, durationFlux).map(Tuple2::getT1);
    }

    public static void main(String[] args) {
        SpringApplication.run(ReactiveServiceApplication.class);
    }
}
</code></pre>

<p>with a Lombok-ed event:</p>

<pre><code>@Data
@AllArgsConstructor
public class Event {
    private final long id;
    private final LocalDate when;
}
</code></pre>

<p>These reactive APIs work from curl as I'd expect:</p>

<pre><code>jan@linux-6o1s:~/src&gt; curl -s http://localhost:8080/events/123
{""id"":123,""when"":{""year"":2017,""month"":""MAY"",""monthValue"":5,""dayOfMonth"":15,""dayOfWeek"":""MONDAY"",""era"":""CE"",""dayOfYear"":135,""leapYear"":false,""chronology"":{""calendarType"":""iso8601"",""id"":""ISO""}}}
</code></pre>

<p>and similarly for the non-terminating Flux API:</p>

<pre><code>jan@linux-6o1s:~/src&gt; curl -s http://localhost:8080/events
data:{""id"":1494887783347,""when"":{""year"":2017,""month"":""MAY"",""monthValue"":5,""dayOfMonth"":15,""dayOfWeek"":""MONDAY"",""era"":""CE"",""dayOfYear"":135,""leapYear"":false,""chronology"":{""calendarType"":""iso8601"",""id"":""ISO""}}}

data:{""id"":1494887784348,""when"":{""year"":2017,""month"":""MAY"",""monthValue"":5,""dayOfMonth"":15,""dayOfWeek"":""MONDAY"",""era"":""CE"",""dayOfYear"":135,""leapYear"":false,""chronology"":{""calendarType"":""iso8601"",""id"":""ISO""}}}

data:{""id"":1494887785347,""when"":{""year"":2017,""month"":""MAY"",""monthValue"":5,""dayOfMonth"":15,""dayOfWeek"":""MONDAY"",""era"":""CE"",""dayOfYear"":135,""leapYear"":false,""chronology"":{""calendarType"":""iso8601"",""id"":""ISO""}}}

...
</code></pre>

<p>The similarly trivial Angular 4 client with RxJS:</p>

<pre><code>@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent  implements OnInit, OnDestroy {
  title = 'app works!';
  event: Observable&lt;Event&gt;;
  subscription: Subscription;

  constructor(
    private _http: Http
    ) {
  }

  ngOnInit() {
    this.subscription = this._http
      .get(""http://localhost:8080/events/322"")
      .map(response =&gt; response.json())
      .subscribe(
        e =&gt; { 
          this.event = e;
        }
      );
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
}
</code></pre>

<p>works fine for the <code>Mono</code> API:</p>

<pre><code>""http://localhost:8080/events/322""
</code></pre>

<p>but the <code>Flux</code> API:</p>

<pre><code>""http://localhost:8080/events""
</code></pre>

<p>never triggers the event handler, unlike <code>curl</code>.</p>
","3342253","","3342253","","2017-05-16 02:33:48","2017-05-17 19:30:05","Angular client of Spring Boot 2 Reactor Flux API","<java><angular><rxjs5><angular-http><project-reactor>","3","2","2","","","CC BY-SA 3.0"
"43991013","2","","43970243","2017-05-16 01:11:13","","0","","<p>It turns out that I used a wrong way to add static function. See <a href=""https://stackoverflow.com/questions/1635116/javascript-class-method-vs-class-prototype-method#1635143"">this post</a> for more information.</p>

<p>To add a static function to the <code>Observable</code> class, the code needs to be</p>

<pre><code>Observable.fromCSV = fromCSV;
</code></pre>

<p>Adding the function to the class's prototype will make it only available after newing that class.</p>
","4064930","","-1","","2017-05-23 12:03:02","2017-05-16 01:11:13","","","","0","","","","CC BY-SA 3.0"
"43991942","1","43992034","","2017-05-16 03:20:23","","0","142","<p>When I submit a search form, The url query params will changed.</p>

<p>And when I refresh the page, I want get the queryparams, autocompleted the search forms.</p>

<p>But I do not want Subscribe the changed, because I want get it only once.</p>

<p>This is my search model: </p>

<pre><code>constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private activatedRoute: ActivatedRoute
){
    this.searchForms = this.formBuilder.group({
        cardId: [],
        cardType: [],
        beginTime: [],
        endTime: []
    });

    // this.activatedRoute.queryParams.getValue() 
    // I want use getValue method, But it throw a error msg:
    // ""Property 'getValue' does not exist on type 'Observable&lt;Params&gt;'""
    // I do not know this method is correct.
    // Or have ohter better implementations.
    // And when i get queryparams, how to set the search model?
}
</code></pre>
","1421473","","","","","2017-05-16 03:52:23","angular2 how to get queryparams after refresh page once used fill search form?","<javascript><angular><typescript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"43992034","2","","43991942","2017-05-16 03:31:46","","1","","<p>You can subscribe to the first event only using <code>first</code>. And the <code>subscribe</code> callback will be called only once:</p>

<pre><code>this.activatedRoute.queryParams.first().subscribe(params =&gt; {
    // do something
})
</code></pre>
","2419531","","2419531","","2017-05-16 03:52:23","2017-05-16 03:52:23","","","","0","","","","CC BY-SA 3.0"
"43997209","1","43997479","","2017-05-16 09:16:25","","0","2850","<p>anybody knows if it is possible to set a Timeout on an http request using Observable, see my code bellow, what I would like is:
 as soon as my datas are changed in my web API (or backend server) I want  to refresh my datas in the view, then the user could know something new is happening...hope I am clear enough...if you don't understand please ask... Or another possibility is: every minute a function could make a new call to the server to check if there is some changes..</p>

<pre><code>  export interface User {
 name: any[];
 data: any[];   
  }

 const userURL = 'http://my.apiserver.com';



@Injectable()
export class UserService {



 users: Observable&lt;User[]&gt;
    constructor (public http:Http) {
         this.users = http.get(usersURL)
                  .retry(3)  
                  .map(res =&gt; [res.json()]);

 }
</code></pre>
","6018581","","6018581","","2017-05-16 10:04:54","2017-05-16 10:04:54","Observavable combined with a setTimeout in Angular 4","<angular><typescript><rxjs5><angular-http>","2","9","","","","CC BY-SA 3.0"
"43997479","2","","43997209","2017-05-16 09:26:35","","1","","<p>You can use <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/timer.md"" rel=""nofollow noreferrer""><code>timer</code></a> and <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/switch.md"" rel=""nofollow noreferrer""><code>switch</code></a> operators:</p>

<pre><code>this.users = Observable.timer(1000)
  .switch(() =&gt; http.get(usersURL).retry(3))
  .map(res =&gt; [res.json()])
</code></pre>
","242098","","2419531","","2017-05-16 09:39:38","2017-05-16 09:39:38","","","","10","","","","CC BY-SA 3.0"
"44001685","1","44001877","","2017-05-16 12:37:10","","0","1628","<p>I am trying to loop through the keys in an object and iterate over them after a set interval between one key to another. 
I am trying to achieve this using the interval operator but I have been unsuccessful in doing so. </p>

<pre><code>let obj = { 'a': [1,23,3], 'b': [12,23,2] };
 for(let key in data) {
      Observable.interval(5000).subscribe( () =&gt; {
         // perform operation with data[key]      
       });
  }
</code></pre>

<p>I don't see any delay between my loops and all i am getting is a sudden iteration which is not different from the normal loop beahvior. </p>
","1646729","","310726","","2017-05-16 12:46:52","2017-08-17 12:10:13","Delaying and iterating an object with rxjs","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"44001877","2","","44001685","2017-05-16 12:45:41","","2","","<p>That's because you're creating a new Observable in each iteration.</p>

<p>I guess you wanted to make something like this:</p>

<pre><code>Observable.from(Object.keys(obj))
    .concatMap(item =&gt; Observable.of(item).delay(5000))
    .subscribe(item =&gt; console.log(item));
</code></pre>

<p>The actual delay is performed by <code>concatMap</code> that waits until each inner Observable completes before subscribing to the next one.</p>
","310726","","1294002","","2017-08-17 12:10:13","2017-08-17 12:10:13","","","","2","","","","CC BY-SA 3.0"
"44015778","1","44016013","","2017-05-17 04:43:20","","0","993","<p>I am implementing auto-save for a react-redux-firebase side project using redux-observable. Currently I have a updateFretboardEpic that is responding to any actions that modify a Fretboard component currently possessing a reference (firebaseKey) to the Firebase database. After 1 second debounce, updateFretboard should save the new state of the component to Firebase.</p>

<pre><code>import {
  ADD_STRING,
  REMOVE_STRING,
  INC_STR_PITCH,
  DEC_STR_PITCH,
  ADD_FRET,
  REMOVE_FRET,
  UPDATE_FRETBOARD
} from '../actions/action-types';

import {
  updateFretboard
} from '../actions/fretboard-actions';

export const updateFretboardEpic = (action$, store) =&gt; {
  return action$.ofType(
      ADD_STRING,
      REMOVE_STRING,  
      INC_STR_PITCH,
      DEC_STR_PITCH,
      ADD_FRET,
      REMOVE_FRET
    )
    .filter(() =&gt; store.getState().fretboard.firebaseKey !== undefined)
    .debounceTime(1000)
    .map(() =&gt; updateFretboard(
      store.getState().fretboard.fretboardData,
      store.getState().fretboard.firebaseKey
    ));
};
</code></pre>

<p>However, I am currently getting the following error:</p>

<pre><code>Uncaught Error: Actions must be plain objects. Use custom middleware for async actions.
    at Object.performAction (&lt;anonymous&gt;:3:2312)
    at liftAction (&lt;anonymous&gt;:2:27846)
    at dispatch (&lt;anonymous&gt;:2:31884)
    at bundle.ff2509bâ¦.js:9896
    at SafeSubscriber.dispatch [as _next] (vendor.ff2509bâ¦.js:51341)
    at SafeSubscriber.__tryOrUnsub (bundle.ff2509bâ¦.js:392)
    at SafeSubscriber.next (bundle.ff2509bâ¦.js:339)
    at Subscriber._next (bundle.ff2509bâ¦.js:279)
    at Subscriber.next (bundle.ff2509bâ¦.js:243)
    at SwitchMapSubscriber.notifyNext (bundle.ff2509bâ¦.js:6579)
</code></pre>

<p>Prior to implementing redux-observable, updateFretboard was using Redux-Thunk to dispatch an action:</p>

<pre><code>export function updateFretboard(fretboardData, firebaseKey = undefined) {
  return dispatch =&gt; { fretboards.child(firebaseKey).update(fretboardData); };
}
</code></pre>

<p>Using that as it stands with redux-observable will produce the error without any auto-save. Instead of returning a thunk, I changed it to this:</p>

<pre><code>export function updateFretboard(fretboardData, firebaseKey = undefined) {
  return fretboards.child(firebaseKey).update(fretboardData);
}
</code></pre>

<p>Interestingly, updateFretboardEpic will auto-save for the first action in the stream, return the error, and will not auto-save for any subsequent actions thereafter. updateFretboard does not currently flow through any of my reducers (it is only responsible for passing new state to Firebase), although I may choose in the future to receive a promise to know when the save occurred and pass it through my reducers.</p>

<p>I am new to RxJS/redux-observable, so I suspect there is a better way of doing this. Thoughts? </p>
","5566388","","","","","2017-05-17 20:26:42","Implementing Auto-Save in React-Redux-Firebase App using Redux-Observable","<firebase><react-redux><rxjs5><redux-thunk><redux-observable>","2","0","1","","","CC BY-SA 3.0"
"44016013","2","","44015778","2017-05-17 05:04:16","","3","","<p>When using redux-observable without any other side effect middleware (like redux-thunk) means all actions you dispatch must be plain old JavaScript objects--that includes anything your epics emits.</p>

<p>It's not clear what <code>updateFretboard()</code> returns, except that is probably isn't a POJO action; it's whatever <code>fretboards.child(firebaseKey).update(fretboardData)</code> returns.</p>

<p>If instead of emitting an action, you actually meant to just perform that as a side effect but ignore its return value entirely, you would use something like the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-do"" rel=""nofollow noreferrer""><code>do()</code> operator</a>, which is used to make a side effect without actually modifying the next'd values. You could then combine that with the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-ignoreElements"" rel=""nofollow noreferrer""><code>ignoreElements()</code> operator</a> to prevent your epic from emitting anything ever.</p>

<pre><code>export const updateFretboardEpic = (action$, store) =&gt; {
  return action$.ofType(
      ADD_STRING,
      REMOVE_STRING,  
      INC_STR_PITCH,
      DEC_STR_PITCH,
      ADD_FRET,
      REMOVE_FRET
    )
    .filter(() =&gt; store.getState().fretboard.firebaseKey !== undefined)
    .debounceTime(1000)
    .do(() =&gt; updateFretboard(
      store.getState().fretboard.fretboardData,
      store.getState().fretboard.firebaseKey
    ))
    .ignoreElements();
};
</code></pre>

<p>Keep in mind that by using <code>ignoreElements()</code> this particular epic will <strong>never</strong> emit anything (though it will still propagate errors/complete). It becomes basically ""readonly"".</p>

<p>If you didn't use <code>ignoreElements()</code>, your epic would actually re-emit the same action it matched, causing unwanted recursion.</p>

<hr>

<p>You might also find it easier to invert control of what gets saved and what doesn't. Instead of having to maintain a list of actions that should trigger an autosave, you could instead have actions have some sort of property that your epic listens for to know to save.</p>

<p>e.g.</p>

<pre><code>// Listens for actions with `autosave: true`
export const updateFretboardEpic = (action$, store) =&gt; {
  return action$.filter(action =&gt; action.autosave)
    // etc...
};

// e.g.
store.dispatch({
  type: ADD_STRING,
  autosave: true
});
</code></pre>

<p>Adjust convention to your apps needs, accordingly.</p>
","1770633","","1770633","","2017-05-17 20:26:42","2017-05-17 20:26:42","","","","2","","","","CC BY-SA 3.0"
"44033163","2","","43989889","2017-05-17 19:21:44","","5","","<p>Here's a working Angular 4 SSE example as Simon describes in his answer. This took a while to piece together so perhaps it'll be useful to others. The key piece here is Zone -- without Zone, the SSE updates won't trigger Angular's change detection.</p>

<pre><code>import { Component, NgZone, OnInit, OnDestroy } from '@angular/core';
import { Http } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Subscription } from 'rxjs/Subscription';
import 'rxjs/add/operator/map';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent  implements OnInit {
  event: Observable&lt;MyEvent&gt;;
  private _eventSource: EventSource;
  private _events: BehaviorSubject&lt;MyEvent&gt; = new BehaviorSubject&lt;MyEvent&gt;(null);
  constructor(private _http: Http, private _zone: NgZone) {}
  ngOnInit() {
    this._eventSource = this.createEventSource();
    this.event = this.createEventObservable();
  }

  private createEventObservable(): Observable&lt;MyEvent&gt; {
    return this._events.asObservable();
  }

  private createEventSource(): EventSource {
      const eventSource = new EventSource('http://localhost:8080/events');
      eventSource.onmessage = sse =&gt; {
        const event: MyEvent = new MyEvent(JSON.parse(sse.data));
        this._zone.run(()=&gt;this._events.next(event));
      };
      eventSource.onerror = err =&gt; this._events.error(err);
      return eventSource;
  }
}
</code></pre>

<p>The corresponding HTML is simply:</p>

<pre><code>&lt;b&gt;Observable of sse&lt;/b&gt;
&lt;div *ngIf=""(event | async); let evt; else loading""&gt;
  &lt;div&gt;ID: {{evt.id}} &lt;/div&gt;
&lt;/div&gt;
&lt;ng-template #loading&gt;Waiting...&lt;/ng-template&gt;
</code></pre>

<p>The event is trivial:</p>

<pre><code>export class MyEvent {
  id: number;
  when: any;

  constructor(jsonData) {
    Object.assign(this, jsonData);
  }
}
</code></pre>

<p>and since my TS does not include <code>EventSource</code> or <code>Callback</code>, I stubbed them in:</p>

<pre><code>interface Callback { (data: any): void; }

declare class EventSource {
    onmessage: Callback;
    onerror: Callback;
    addEventListener(event: string, cb: Callback): void;
    constructor(name: string);
    close: () =&gt; void;
}
</code></pre>
","3342253","","3342253","","2017-05-17 19:30:05","2017-05-17 19:30:05","","","","0","","","","CC BY-SA 3.0"
"44033322","1","","","2017-05-17 19:31:21","","0","302","<p>I started learning RxJS recently. I was experimenting with it a bit and came across following issue.</p>

<p>When chaining together delay and interval I would assume that each value will be emitted after (interval + delay) but this is not the case here. What's more strange to me is that when these two funcs are chained some values are printed at the same time without any delay. How should I understand it? What am I missing?</p>

<p>I'm using RxJS 5.0.3 and I was working in jsbin: <a href=""https://jsbin.com/xoyuded/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/xoyuded/edit?js,console</a></p>

<p>This one:</p>

<pre><code>Rx.Observable.interval(1000).take(10).subscribe(x =&gt; console.log(x));
</code></pre>

<p>gives:</p>

<pre><code>21:16:28.335 runner-4.0.2.min.js:1 Console was cleared
21:16:29.757 runner-4.0.2.min.js:1 0
21:16:30.756 runner-4.0.2.min.js:1 1
21:16:31.756 runner-4.0.2.min.js:1 2
21:16:32.756 runner-4.0.2.min.js:1 3
21:16:33.756 runner-4.0.2.min.js:1 4
21:16:34.751 runner-4.0.2.min.js:1 5
21:16:35.755 runner-4.0.2.min.js:1 6
21:16:36.751 runner-4.0.2.min.js:1 7
21:16:37.751 runner-4.0.2.min.js:1 8
21:16:38.751 runner-4.0.2.min.js:1 9
</code></pre>

<p>This one:</p>

<pre><code>Rx.Observable.interval(1000).take(10).delay(1000).subscribe(x =&gt; console.log(x));
</code></pre>

<p>gives:</p>

<pre><code>runner-4.0.2.min.js:1 Console was cleared
21:17:42.749 runner-4.0.2.min.js:1 0
21:17:42.750 runner-4.0.2.min.js:1 1
21:17:43.752 runner-4.0.2.min.js:1 2
21:17:44.753 runner-4.0.2.min.js:1 3
21:17:45.753 runner-4.0.2.min.js:1 4
21:17:47.751 runner-4.0.2.min.js:1 5
21:17:47.752 runner-4.0.2.min.js:1 6
21:17:49.748 runner-4.0.2.min.js:1 7
21:17:49.749 runner-4.0.2.min.js:1 8
21:17:51.748 runner-4.0.2.min.js:1 9
</code></pre>
","2230231","","2230231","","2017-05-21 09:12:36","2017-05-26 20:31:37","Chaining Rx interval and delay","<rxjs><rxjs5>","1","4","0","","","CC BY-SA 3.0"
"44037125","1","44037230","","2017-05-18 01:22:33","","0","921","<p>I am trying to get polling working within Angular 2 with <code>Observables</code>. I know there are a number of other answers out there, however I cannot get them to work for me.</p>

<p>I know its a pure understanding thing, so an explanation of the answer (what its doing and why) and not pure code would be appreciated.</p>

<p><strong>test.service.ts</strong></p>

<pre><code>@Injectable()
export class EtlService {

constructor(private http: Http) { }

//Get ETL by status
get(): Observable&lt;EtlByStatus&gt; {
    var url = 'someURL';

    return this.http
        .get(url)

        .map(response =&gt; {
            return {
                headers: response.json().data.headers,
                dataSet: response.json().data.data
            }
        });
}
</code></pre>

<p>Calling this service works as expected with a simple subscribe:</p>

<pre><code>this._service
            .get()
            .subscribe(
                res=&gt; {
                    this.headers= res.headers;
                    this.data = res.dataSet;
});
</code></pre>

<p>However, my issue is polling. As best I can tell, polling should be done from within the <code>Component</code> to allow the service to be more reusable - the HTTP request is simple, and can be processed any number of ways.</p>

<p><strong>test.component.ts</strong></p>

<pre><code>pollGet(timer: number = 30000): Observable&lt;GetInterface&gt; {
        return Observable.interval(timer)
            .switchMap((res) =&gt; {
                this._service.get();
            })
            .map(res =&gt; res)
            .subscribe(res =&gt; {
                console.log('testing');
            })
    }
</code></pre>

<p>The above returns <code>res =&gt; void is not assignable</code> and <code>type void is not assignable to type ObservableInput</code>. I've tried turning the get line in the middle into a return, and that gives more errors and returns messages that <code>subscribe</code> is a function.</p>

<p>As such, how do you use <code>Observables</code> for polling? I am sure its my understanding of <code>map</code>, <code>switchMap</code> and <code>subscribe</code> and how they all play as part of an <code>observable</code> but I cannot figure it out.</p>
","3192719","","","","","2017-05-18 03:26:37","Http Service polling with observables","<angular><observable><rxjs5>","2","2","","","","CC BY-SA 3.0"
"44037230","2","","44037125","2017-05-18 01:40:45","","1","","<p>your function <code>pollGet</code> is attending to return <code>Observable&lt;GetInterface&gt;</code>, based on reusable principle, so the <strong>finally</strong> subscribe is not fit here because it will turn the return type to <code>subscription</code>.</p>

<p>About <code>switchMap</code>:</p>

<p><code>switchMap</code> is used for combining observable chain which the <strong>Observable</strong> in <code>switchMap</code> is based on the result of the original Observable. So here you should return type Observable in <code>switchMap</code>.</p>

<p>according to your code, the observable in <code>switchMap</code> are not related to any original observable results, so here you can simply using <code>map</code>.</p>

<p>so the final working code block would be as below:</p>

<pre><code>pollGet(timer: number = 30000): Observable&lt;any&gt; {
    return Observable
               .interval(timer)
               .map(() =&gt; {
                   //return this.http.get('111');
                   // make sure your r_service.get return an Observable as the example above: http.get
                   return this._service.get();
               })
               .map(res =&gt; res);
}
</code></pre>
","7579471","","7579471","","2017-05-18 02:17:30","2017-05-18 02:17:30","","","","2","","","","CC BY-SA 3.0"
"44039278","1","44039647","","2017-05-18 05:28:40","","28","44290","<p>I am implementing the following functions in Angular2's Component:</p>

<pre><code>export class MypageEditComponent {

  ngOnInit() {
    this.timer = Observable.timer(100, 100);
    this.timer.subscribe(t =&gt; {
      this.setFormData();
  }


  private setFormData() {
    this.editUserAcountType = this.authStore.registerInfo.account_type;
    this.editAddress = this.authStore.registerInfo.email;
    this.editUserName = this.authStore.registerInfo.username;
  }
}
</code></pre>

<p>I want to stop the repeat of <code>Observable.timer</code> once the value is correctly stored with <code>setFormData()</code>. </p>

<p>But do not know how, please tell me.</p>
","7718856","","310726","","2018-02-17 16:27:17","2019-12-18 13:13:56","How to Stop observable.timer in Angular2","<javascript><angular><typescript><rxjs><rxjs5>","5","3","5","","","CC BY-SA 3.0"
"44039647","2","","44039278","2017-05-18 05:57:34","","64","","<p>There're are basically two ways:</p>

<ul>
<li>call <code>unsubscribe()</code> on the Subscription object returned from the <code>subscribe()</code> call .</li>
<li>use an operator</li>
</ul>

<p>To just <code>unsubscribe</code> you could do it like this.</p>

<pre><code>ngOnInit() {
  this.subscription = timer(100, 100).subscribe(t =&gt; {
    this.setFormData();
  });
}

private setFormData() {
  ...
  this.subscription.unsubscribe();
}
</code></pre>

<p>Or you can use Subject to complete the Observable via <code>takeUntil()</code> operator:</p>

<pre><code>this.subject = new Subject();

ngOnInit() {
  timer(100, 100).pipe(
    takeUntil(this.subject),
  ).subscribe(t =&gt; this.setFormData());
}

private setFormData() {
  ...
  this.subject.next();
}
</code></pre>

<p>Have a look these as well:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/40563065/difference-between-unsubscribe-to-take1/40564340#40564340"">Difference between .unsubscribe to .take(1)</a></li>
<li><a href=""https://stackoverflow.com/questions/42490265/rxjs-takeuntil-angular2-components-ngondestroy/42493315#42493315"">RxJS: takeUntil() Angular component&#39;s ngOnDestroy()</a></li>
</ul>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-01-15 11:06:57","2019-01-15 11:06:57","","","","1","","","","CC BY-SA 4.0"
"44043627","1","","","2017-05-18 09:20:00","","5","7799","<p>I'm trying to have an infinite scrolling section in my application. To achieve this I'm using <a href=""https://www.npmjs.com/package/angular2-perfect-scrollbar"" rel=""noreferrer"">this component</a> to handle the scroll events and so on. When the scroll reaches the bottom of the div I'm calling a function to get more data. So far so good.</p>

<p>To make this function more efficient I'm trying to wait a few seconds before the call is made as well as make sure that the data is processed properly. To do this I've been looking at the example shown on the <a href=""https://angular.io/docs/ts/latest/guide/server-communication.html#!#listen-for-search-terms"" rel=""noreferrer"">Angular website that showcases a wikipedia search</a>.</p>

<p>I have a similar setup to what is being shown in the article, my problem is that I'm getting the following error when I call <code>switchMap()</code>:</p>

<p><code>Type 'void' is not assignable to type 'ObservableInput&lt;{}&gt;'</code></p>

<p>This is a sample of my code:</p>

<pre><code>private scrollEndActive: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();

ngOnInit() {
    ...
    this.scrollEndActive
        .debounceTime(1000)
        .distinctUntilChanged()
        .switchMap(data =&gt; {
            // ... get data from server
        })
}

...

// event to trigger call to server
scrollEnd() {
    this.scrollEndActive.next(true);
}
</code></pre>

<p>With the code above this is what I'm getting:<a href=""https://i.stack.imgur.com/PqyB2.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/PqyB2.png"" alt=""enter image description here""></a></p>

<p>From the research I've made it seems to be an issue related to the fact that one should return the Observable (<a href=""https://stackoverflow.com/questions/43115390/type-void-is-not-assignable-to-type-observableinput"">Type &#39;void&#39; is not assignable to type &#39;ObservableInput&lt;{}&gt;&#39;</a>). But in my case I'm not sure what is the issue.</p>

<p>I'm working with:</p>

<ul>
<li>Angular 4.0.1</li>
<li>TypeScript 2.2.2</li>
<li>RxJS 5.2.0</li>
</ul>
","2312637","","-1","","2017-05-23 12:18:20","2018-04-11 11:11:51","Angular 2 - RxJS Switch Map Issue","<angular><typescript><rxjs><rxjs5>","2","7","","","","CC BY-SA 3.0"
"44049904","1","44050088","","2017-05-18 14:00:50","","3","2116","<p>I'm trying to build an infinite polling in my Http service because I'm building a king of of dashborad who survey data's comming from a servor, here's my code who's almost working (in my console I see the Json comming but it doesn't reflect to my view...I would like to inject in my users: Observable</p>

<pre><code>const usersURL = 'http://my.super.servor.php'

@Injectable()
export class UserService {

 users: Observable&lt;User[]&gt;

   constructor (public http:Http) {
     this.users = http.get(usersURL)
              genre mobile ou autre
              .map(res =&gt; [res.json()]);

        let i = this.users.subscribe(
          usersURL =&gt; console.log(usersURL),
         () =&gt; {}, // Here we catch up errors
         () =&gt; console.log(""completed!"") // Here we catch up if its completed
        )

    // Here's where I'm trying to do the polling every 5 secondes
    let tick$ = Observable.interval(5000);

    let response$ = 
      tick$
          .flatMap(() =&gt; http.get(usersURL))
          .map(res =&gt; [res.json()]);

    let stockPoller = response$.subscribe(res =&gt; console.log(res));
  }
</code></pre>
","6018581","","4905253","","2018-01-10 10:05:28","2018-01-10 10:05:28","Infinite polling with Angular 4 and Http observables","<javascript><angular><long-polling><rxjs5><angular-http>","1","1","1","","","CC BY-SA 3.0"
"44050088","2","","44049904","2017-05-18 14:07:37","","5","","<p>You just assign your polling observable to <code>this.users</code>:</p>

<pre><code>this.users = tick$.flatMap(() =&gt; http.get(usersURL)).map(res =&gt; [res.json()]);
</code></pre>
","674326","","","","","2017-05-18 14:07:37","","","","10","","","","CC BY-SA 3.0"
"44059390","1","44089555","","2017-05-18 23:48:29","","3","363","<p>I would like to emit all original values from an RxJS stream, and then emit a summary upon completion.</p>

<p>Reduce stops the original values from emitting. Scan emits each total rather than the original values.</p>

<p>Here is my hacky solution:</p>

<pre><code>let total = {
  total: 0
};

Rx.Observable.range(1, 3)
  .do(val =&gt; {
    total.total += val;
  })
  .concat(Rx.Observable.of(total))
  .subscribe(
    value =&gt; {
      console.log('Next:', value)
    }
  );

// Next: 1
// Next: 2
// Next: 3
// Next: { total: 6 }
</code></pre>

<p>What is a simple way to do this with pure RxJS streams?</p>
","2716010","","","","","2017-05-20 18:40:07","RxJS: How to emit original values, then reduce upon completion?","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"44083537","1","44084416","","2017-05-20 08:16:31","","4","1201","<p><em>I would like to observe rolling averages with rxjs ^5</em></p>

<h2>Half-solution</h2>

<pre><code>const data$ = Rx.Observable.range(1, 9);
const dataToAverage$ = data$.bufferCount(4, 1);
const movingAverage$ = dataToAverage$.map(arr =&gt;
                       arr.reduce((acc, cur) =&gt; acc + cur) / arr.length);
</code></pre>

<ul>
<li>The above code works fine, except that the first data array it averages is <code>1,2,3,4</code>.</li>
<li>How could I average <code>1</code> and <code>1,2</code> and <code>1,2,3</code> as well?</li>
<li>Have a play at <a href=""https://jsfiddle.net/KristjanLaane/kLskp71j/"" rel=""nofollow noreferrer"">https://jsfiddle.net/KristjanLaane/kLskp71j/</a></li>
</ul>
","742084","","","","","2017-05-20 09:51:18","Running average with rxjs 5","<rxjs><average><observable><reactive-programming><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"44084416","2","","44083537","2017-05-20 09:51:18","","6","","<p>I'd do it like this:</p>

<pre><code>Observable.range(1, 9)
    .scan((acc, curr) =&gt; {
        acc.push(curr);

        if (acc.length &gt; 4) {
            acc.shift();
        }
        return acc;
    }, [])
    .map(arr =&gt; arr.reduce((acc, current) =&gt; acc + current, 0) / arr.length)
    .subscribe(console.log);
</code></pre>

<p>The <code>scan()</code> just collects at most 4 items and the <code>map()</code> then calculates the average.</p>

<pre><code>1
1.5
2
2.5
3.5
4.5
5.5
6.5
7.5
</code></pre>
","310726","","","","","2017-05-20 09:51:18","","","","1","","","","CC BY-SA 3.0"
"44089555","2","","44059390","2017-05-20 18:40:07","","4","","<p>Use multicast</p>

<pre><code>Rx.Observable.range(1, 3)
 .multicast(new Rx.Subject(), (shared)=&gt; {
    return Rx.Observable.merge(shared, shared.reduce((acc, x)=&gt;acc+x,0))
 })
.subscribe(x=&gt;console.log(x))
</code></pre>
","6922095","","","","","2017-05-20 18:40:07","","","","3","","","","CC BY-SA 3.0"
"44106113","1","44106333","","2017-05-22 06:38:05","","0","34","<p>use case is consist of three service call and service call should be in serialize.</p>

<ol>
<li>get organization by ID.</li>
<li>Using ID to calling the <strong>join</strong> service.</li>
<li>After successfully joining than calling <strong>markRead</strong> notification service.</li>
</ol>

<p>what i try is following.</p>

<pre><code>  getOrgById(22)
 .flatMap((org)=&gt;org.join())
 .flatMap(()=&gt;notification.markRead(1))
  .subscribe(()=&gt;{
  })
</code></pre>

<p>So the main issue is, how to get the organization information in subscribe.</p>
","2437693","","","","","2017-05-22 06:51:46","how to resolve the following use case in angular 2 using Rxjs","<javascript><angular><rxjs5>","1","2","","","","CC BY-SA 3.0"
"44106333","2","","44106113","2017-05-22 06:51:46","","1","","<p>With observables of values, you could use <code>.do</code>, which takes the result of the previous observable, can do something with it and returns an observable of the same result:</p>



<pre class=""lang-ts prettyprint-override""><code>getOrgById
    .do(org =&gt; console.log(org))
    .subscribe(org =&gt; {
      ...
    });
</code></pre>

<p>As far as I'm aware, though, there isn't a <code>flat</code> equivalent of <code>do</code> for observables of observables. You could get the same behaviour by returning it yourself from each step:</p>

<pre class=""lang-ts prettyprint-override""><code>getOrgById(22)
    .flatMap(org =&gt; org.join().map(() =&gt; org))
                           // ^ like this
    .flatMap(org =&gt; notification.markRead(1).map(() =&gt; org))
    .subscribe(org =&gt; {
      ...
    });
</code></pre>
","3001761","","","","","2017-05-22 06:51:46","","","","2","","","","CC BY-SA 3.0"
"44113416","1","","","2017-05-22 12:54:57","","0","401","<p>I am triyng to build a dynamic DataTable using PrimeNG 2.0.5 with Angular 4 but I've got an error : ""GET <a href=""http://localhost:3000/application-detail.component.html"" rel=""nofollow noreferrer"">http://localhost:3000/application-detail.component.html</a> 404 (Not Found)"" and also ""Unhandled Promise rejection: Failed to load application-detail.component.html ; Zone:  ; Task: Promise.then ; Value: Failed to load application-detail.component.html undefined"" ....thanks in advance</p>

<p>Here's my code:</p>

<p>app.detail.component.html ===></p>

<pre><code>&lt;p-dataTable [value]=""users"" routerLink=""my-dashboard""&gt;
&lt;p-column *ngFor=""let user of userService.users | async"" [field]=""users.status"" [header]=""user.data.apps.details[2].state""&gt;&lt;/p-column&gt;
&lt;p-column *ngFor=""let user of userService.users | async"" header=""Type""&gt;{{user.status}}&lt;/p-column&gt;
&lt;p-column *ngFor=""let user of userService.users | async"" header=""Etat""&gt;{{user.data.apps.details[2].state}}&lt;/p-column&gt;
&lt;p-column *ngFor=""let user of userService.users | async"" header=""Depuis""&gt;{{user.data.apps.details[2].since}}&lt;/p-column&gt; 
&lt;/p-dataTable&gt;
</code></pre>

<p>Here's my Observable: users: Observable</p>

<p>app.detail.component.ts ===></p>

<pre><code>import { Component, OnInit } from '@angular/core';
import {DataTableModule,SharedModule} from 'primeng/primeng'; 
import { UserService } from './user.service';



@Component({
  selector: 'app-detail',
  templateUrl: 'application-detail.component.html',
  styleUrls: ['application-detail.component.css'],

})
  export class AppDetailComponent { 

      constructor(public userService: UserService) { }
  }
</code></pre>
","6018581","","","","","2017-05-22 12:54:57","Issue with PrimeNG DataTable binding from Http Observable","<angular><rxjs5><primeng-datatable>","0","10","","","","CC BY-SA 3.0"
"44115543","1","","","2017-05-22 14:30:11","","0","395","<p>I am trying to use <code>Rxjs</code> with a small Node program that will do some I/O operations. Void operations (such as <code>writeFile</code>) have been done as Observables without any emitted values. It can be represented in a marble diagram as:</p>

<pre><code>writeFile (success) ---------|
writeFile (error)   ---------X
</code></pre>

<p>I am trying to do something like the following:</p>

<pre><code>removeDir    -------|
writeFiles          -------|
transformFiles             -------|
</code></pre>

<p>To accomplish these operations in the correct order, I have code that looks something like this:</p>

<pre><code>// helpers.ts
import { Observable } from '@reactivex/rxjs';
export function removeDir(dir: string): Observable&lt;void&gt; { ... }
export function writeFiles(fromDir: string, toDir: string): Observable&lt;void&gt; { ... }
export function transformFiles(dir: string): Observable&lt;void&gt; { ... }

// main.ts
import { Observable } from '@reactivex/rxjs';
import { removeDir, writeFiles, transformFiles } from './helpers';

const filesReady = removeDir('output')
  .concat(Observable.defer(() =&gt; writeFiles('input', 'output')))
  .concat(Observable.defer(() =&gt; transformFiles('output')));

filesReady.subscribe({
  error(err) {
    // Something went wrong!
  }
  complete() {
    // Do something when files are ready
  }
})
</code></pre>

<p>This example is a bit simplified, but I run into issues in places where I want to compose Observables together. Many <code>Rxjs</code> operators does not work well with only complete events.</p>

<p>Is there a better way to compose <code>Rxjs</code> with I/O events?
I find some concepts around <code>Rxjs</code> confusing, so any help is greatly appreciated.</p>
","5915514","","","","","2017-05-22 14:30:11","Using Rxjs with Node I/O operations","<node.js><typescript><rxjs5>","0","4","","","","CC BY-SA 3.0"
"44119987","1","44121349","","2017-05-22 18:42:52","","0","171","<p>I've just included RxJS 5.4.0 and RxJS-DOM 7.0.3 on a page and got this error in the console:</p>

<blockquote>
  <blockquote>
    <p>TypeError: Cannot read property 'AbstractObserver' of undefined</p>
  </blockquote>
</blockquote>

<p>Please help with this error.</p>
","2896495","","","","","2017-05-22 20:11:14","RxJS-DOM - Cannot read property 'AbstractObserver' of undefined","<rxjs5><rxjs-dom>","1","0","","","","CC BY-SA 3.0"
"44121349","2","","44119987","2017-05-22 20:11:14","","1","","<p>Rx-DOM is not fully compatible will RxJS 5. </p>

<p>See open tickets on github:</p>

<ul>
<li><a href=""https://github.com/ReactiveX/rxjs/issues/1223"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/1223</a></li>
<li><a href=""https://github.com/Reactive-Extensions/RxJS-DOM/issues/105"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS-DOM/issues/105</a></li>
</ul>

<p>To avoid this error you need to use RxJS 4.</p>
","5419325","","","","","2017-05-22 20:11:14","","","","0","","","","CC BY-SA 3.0"
"44123124","1","","","2017-05-22 22:36:04","","0","835","<p>I'm running into an exception that's killing my application, and I can't seem to catch() / consume it. I'm very new to this so I'm probably doing something wrong with the <code>catch</code>?</p>

<pre><code>private callConfigService(): Observable&lt;Map&lt;string,string&gt;&gt; {

    try {
        let confObs = this.contentService.fetchContentUsingGET(id, store, locale, null, false)
            .catch((res) =&gt; {
                console.log('Retrieving config FAILED! ', res);    // not hit
                return Observable.from([new Map&lt;string,string&gt;()]);
            }
        ).subscribe(
            (res) =&gt; { console.log('fetchContentUsingGET : ', res); },  // not worried about success scenario
            (err) =&gt; { console.log('error response: ', err); }  // not hit
         );  
    } catch (exception) {
        console.log('???', exception);  // not hit
    } finally {
        console.log('?????');   // hit
    }
    return Observable.of(new Map&lt;string,string&gt;()); // not hit
}
</code></pre>

<p>Unfortunately the <code>fetchConfigUsingGET</code> call is from a library, so I'm not sure what's inside. But it looks like a hot observable because it yields a 404 exception without me even calling <code>subscribe()</code></p>

<p>What I don't get is why the <code>catch()</code> is completely skipped?</p>

<pre><code>Uncaught * e {_body: ""{""status"":404,""error"":""StatusCodeError"",""data"":""404 - undefined""}"", status: 404, ok: false, statusText: ""Not Found"", headers: tâ¦}          bundle.umd.js:5
</code></pre>
","2759883","","2759883","","2017-05-23 18:15:17","2017-05-23 18:15:17","rxjs Observable.catch() not working","<angular><rxjs><reactive-programming><rxjs5>","1","6","","","","CC BY-SA 3.0"
"44134789","1","44135241","","2017-05-23 12:25:58","","1","55","<p>Is there a way to map an Observerable into another by chaining? I'm currently doing this:</p>

<pre><code>const myObserverable = fnThatReturnsObserverable();
return anotherFunctionThatReturnsObserverable(myObserverable);
</code></pre>

<p>Is there a way to do this in a chained manner?</p>

<pre><code>return fnThatReturnsObserverable().someOperator(anotherFunctionThatReturnsObserverable)
</code></pre>
","363992","","363992","","2017-05-23 12:41:43","2017-05-23 13:22:15","Wrap Rx JS Observable by chaining","<javascript><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"44135241","2","","44134789","2017-05-23 12:45:04","","2","","<pre><code>fnThatReturnsObserverable()
    .let(obs =&gt; anotherFunctionThatReturnsObserverable(obs));
</code></pre>

<p>More information on it <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/let.md"" rel=""nofollow noreferrer"">here</a>.</p>
","2564847","","2564847","","2017-05-23 13:12:56","2017-05-23 13:12:56","","","","0","","","","CC BY-SA 3.0"
"44147013","1","44147610","","2017-05-24 00:21:34","","0","470","<p><a href=""https://jsfiddle.net/90z9cy7j/2/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<pre><code>  let sub = new Rx.Subject();
  let val = 0;
  Rx.Observable.fromEvent(window, 'scroll')
  .do(_ =&gt; val++)
  .debounceTime(500)
  .subscribe(c =&gt; sub.next(val)); 

  sub.subscribe(v =&gt; console.log(v));
</code></pre>

<p>I have an observable on scroll event. I would like to ignore the values from it unless some time has passed.</p>

<p>it would look like this (e being events, and the <code>debounceTime</code> being <code>500</code>):</p>

<pre><code> ---e1----e2----e3----e4----e6-----e7 &lt;- events

 ---n1----------------------n6------- &lt;- notifications

 0--100------------------600------ &lt;- time
</code></pre>

<p>And like this:</p>

<pre><code> ---e1----e2----e3----e4----------------- &lt;- events

 ---n1------------------------------------- &lt;- notifications

 0--100--------------------500------------- &lt;- time
</code></pre>
","4299560","","4299560","","2017-05-24 00:28:17","2017-05-25 00:56:47","Debounce Rx.Observable & ignore values emitted in between","<javascript><rxjs><reactive-programming><rxjs5>","1","3","","","","CC BY-SA 3.0"
"44147610","2","","44147013","2017-05-24 01:43:19","","3","","<p><a href=""https://css-tricks.com/the-difference-between-throttling-and-debouncing/"" rel=""nofollow noreferrer"">Debouncing and throttling are different</a>. You seem to want <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/throttle.md"" rel=""nofollow noreferrer"">throttle</a>.</p>

<p>The fundamental difference is that whereas debouncing reduces <em>n</em> events to one, throttling lets through only one event per time window.</p>

<pre><code>let val = 0;
const sub = Rx.Observable.fromEvent(window, 'scroll')
  .do(_ =&gt; val++)
  .throttle(500);

sub.subscribe(v =&gt; console.log(v));
</code></pre>

<p>However, this is not perfect. The user might scroll within a 500ms window in such a way that you would miss the last scroll. One <a href=""http://www.cloudypoint.com/Tutorials/discussion/javascript-solved-rxjs-debounce-event-after-throttle/"" rel=""nofollow noreferrer"">solution</a> involves combining throttling and debouncing. I'm not sure this is the best idea, though.</p>

<p>By the way, you do not need to subscribe to one observable only to push values from it onto another observable. Just subscribe to the first observable.</p>
","","user663031","","user663031","2017-05-25 00:56:47","2017-05-25 00:56:47","","","","0","","","","CC BY-SA 3.0"
"44152835","1","44152942","","2017-05-24 08:20:09","","1","364","<p>Is there a way to start emitting values conditionally from an observable? In my case, subscribers of the <code>.asObservable()</code> function should only get a first value AFTER <code>CurrentUser</code> has been initialized.</p>

<pre><code>export class CurrentUser {

    private currentUser$: Observable&lt;CurrentUser&gt;;
    private currentUserBehaviorSubject: BehaviorSubject&lt;CurrentUser&gt;;

    public name: string = """";

    constructor() {
        this.currentUserBehaviorSubject = new BehaviorSubject(this);
        this.currentUser$ = this.currentUserBehaviorSubject.asObservable();
    }

    public asObservable(): Observable&lt;CurrentUser&gt; {
        // 
        if(user.name.length &gt; 0){
            return this.currentUser$;
        }
        else {
            // ?????
        }
    }

    public initialize(string name){
        this.name = name;
        this.currentUserBehaviorSubject.next(this);
    }
}

export class SampleComponent {
    constructor(
        currentUser: CurrentUser
    ) {
        currentUser.asObservable().subscribe(
            (u: CurrentUser) =&gt; {
                // i only want an INITIALIZED user here
            },
            error =&gt; {},
            () =&gt; { }
        );
    }
}
</code></pre>
","502999","","310726","","2017-05-24 08:32:03","2017-05-24 08:46:37","Observable - start to emit conditionally","<angular><typescript><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"44152942","2","","44152835","2017-05-24 08:25:32","","3","","<p>It looks like you could in your <code>asObservable()</code> method always return an Observable and just suppress emissions using the <code>skipUntil()</code> operator until <code>currentUserBehaviorSubject</code> emits (I guess that's how you know CurrentUser has been initialized):</p>

<pre><code>public asObservable(): Observable&lt;CurrentUser&gt; {
    return this.currentUser$
        .skipUntil(this.currentUserBehaviorSubject);
}
</code></pre>
","310726","","","","","2017-05-24 08:25:32","","","","0","","","","CC BY-SA 3.0"
"44164032","1","44164125","","2017-05-24 16:34:19","","8","2921","<p>Recently when I use Rxjs 5, I downloaded Rxjs by using npm install Rxjs@5.0.1, from downloaded code under node_modules, I found Observable.d.ts in Rxjs folder, I saw it declare its constructor like below:</p>

<pre><code> *
 * @constructor
 * @param {Function} subscribe the function that is  called when the Observable is
 * initially subscribed to. This function is given a Subscriber, to which new values
 * can be `next`ed, or an `error` method can be called to raise an error, or
 * `complete` can be called to notify of a successful completion.
 */
constructor(subscribe?: &lt;R&gt;(this: Observable&lt;T&gt;, subscriber: Subscriber&lt;R&gt;) =&gt; TeardownLogic);
</code></pre>

<p>My question is: what is the usage of this keyword in function type declaration of subscribe?: (this: Observable, ...), Does TypeScript has some documentation for this keyword usage like here? Thank you.</p>
","1126944","","","","","2017-05-24 16:39:25","this keyword for function parameter","<typescript><rxjs5>","1","0","4","","","CC BY-SA 3.0"
"44164125","2","","44164032","2017-05-24 16:39:25","","9","","<p>You can (since version 2.0 of typescript) specify what is the <code>this</code> you're expecting when a function is invoked.</p>

<p>As described in <a href=""https://github.com/Microsoft/TypeScript/wiki/What&#39;s-new-in-TypeScript#specifying-the-type-of-this-for-functions"" rel=""noreferrer"">Specifying the type of this for functions</a>:</p>

<blockquote>
  <p>Following up on specifying the type of this in a class or an
  interface, functions and methods can now declare the type of this they
  expect.</p>
  
  <p>By default the type of this inside a function is any. Starting with
  TypeScript 2.0, you can provide an explicit this parameter. this
  parameters are fake parameters that come first in the parameter list
  of a function</p>
</blockquote>

<p>Notice that this won't get translated into js, so it's not a real argument in the function.</p>
","942852","","","","","2017-05-24 16:39:25","","","","1","","","","CC BY-SA 3.0"
"44170927","1","","","2017-05-25 01:34:27","","1","47","<p>For examples, I have the following code that I can write in two ways:</p>

<pre><code>1. 
ObsevableA.do(() =&gt; { 
   doSomething();
})
.subscribe();

2.
ObservableA.subscribe(() =&gt; {
  doSomething();
});
</code></pre>

<p>The end result seems to be the same. Any thoughts on each approach? What is the best practice I should be using? Thanks.</p>
","142372","","","","","2017-05-27 01:19:15","rxjs - what is the difference from result perspective to do actions in .do() and .subscribe()","<rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"44183519","1","44184720","","2017-05-25 14:50:11","","9","10097","<p>For the life of me, I can not make this work.
I've searched and searched, but I couldn't find any example (all examples out there are with <code>.fromEvent()</code>, none on a <code>http.get</code>).</p>

<p>In my template, I have this input:</p>

<pre><code>&lt;input type=""text"" (input)=""categoriesSearch($event)""&gt;
</code></pre>

<p>In my component, I have the following:</p>

<pre><code>categoriesSearch(event) {
    this.categoriesSubscription = this.apiService
        .getCategoriesList(this.uploadForm.get('categories').value)
        .debounceTime(3000)
        // .throttleTime(3000)
        .subscribe(
            (response) =&gt; {
                this.categories = response.data;
            }
        );
}
</code></pre>

<p>And this is the method in my ApiService:</p>

<pre><code>getCategoriesList(keyword = null) {
    const headers = new Headers();
    headers.append('Content-Type', 'application/json');
    headers.append('Bearer', this.authService.user.token);

    const getParams: URLSearchParams = new URLSearchParams();
    getParams.set('keyword', keyword);
    return this.http.get(this.apiHost + '/categories', { headers: headers, search: getParams })
        .map(response =&gt; response.json());
}
</code></pre>

<p>In the <code>categoriesSearch()</code> method, I've tried both <code>debounceTime()</code> and <code>throttleTime()</code> (I also imported them, of course <code>import 'rxjs/add/operator/debounceTime'</code>, <code>import 'rxjs/add/operator/throttleTime'</code>).</p>

<p>But the http.get request is not debounced or throttled at all! If I type 10 characters in 3 seconds, it makes 10 http requests.</p>

<p>How on earth do I tell <code>this.http.get</code> to only make a request if at least 3 seconds have passed since the previous request or since 'no request' (meaning an initial 3 seconds delay)? Ok, maybe here I should say ""since I've last typed something in my input"".</p>

<p>I've also tried using debounceTime()/throttleTime() in the service directly, before the <code>.map()</code> operator - but the result is the same.</p>
","3107662","","3107662","","2017-05-31 12:12:56","2021-09-30 08:09:53","Can't make debounceTime() or throttleTime() to work on an Angular http request","<angular><rxjs5>","3","1","1","","","CC BY-SA 3.0"
"44184720","2","","44183519","2017-05-25 15:51:14","","16","","<blockquote>
  <p>But the http.get request is not debounced or throttled at all! If I
  type 10 characters in 3 seconds, it makes 10 http requests.</p>
</blockquote>

<p>your implementing in a wrong way. you need capture input first, apply denounce and do HTTP request.</p>

<p>you can implement in several ways </p>

<p><strong>1) Observable.fromEvent</strong></p>

<pre><code> &lt;input type=""text"" #input&gt;
</code></pre>

<p>Component </p>

<pre><code> @ViewChild('input') text: ElementRef;

  ngAfterViewInit() {
    let text$ = Observable.fromEvent(this.text.nativeElement, 'keyup')
     .do(() =&gt; console.log(""keyup""))
    .debounceTime(3000)
     .distinctUntilChanged()
    .switchMap(() =&gt; getCategoriesList())
        .subscribe(res =&gt; console.log(res));
  }
</code></pre>

<p><strong>2) Using subject</strong> </p>

<pre><code>&lt;input type=""text"" (keyup)=""search($event)""&gt;
</code></pre>

<p>component </p>

<pre><code>  searchTerms = new Subject&lt;string&gt;();

search(term: string): void {
    this.searchTerms.next(term);
  }

ngOnInit(): void {

    this.searchTerms
      .debounceTime(3000)
      .distinctUntilChanged()
      .switchMap(() =&gt; getCategoriesList())
      .subscribe(term =&gt; { 
       console.log();
     });
</code></pre>

<p><strong>3) Using form control</strong> </p>

<pre><code> &lt;input type=""text"" [formControl]=""term""&gt;
</code></pre>

<p>component</p>

<pre><code>  term = new FormControl();

  ngOnInit() {
    this.items = this.term.valueChanges
                 .debounceTime(3000)
                 .distinctUntilChanged()
                 .switchMap(term =&gt; getCategoriesList(term))
                 .subscribe(res =&gt; console.log(res));
  }
</code></pre>
","4667424","","4667424","","2017-05-25 16:03:21","2017-05-25 16:03:21","","","","5","","","","CC BY-SA 3.0"
"44187493","1","","","2017-05-25 18:30:13","","3","2015","<p>I have an API call that throws an exception. In my component I have a subscription on the api observable, and I want to throw an error received on the subscription out to be handled by my custom angular error handler. </p>

<p>However, in my code I throw the error in the onError handler, but it is not bubbling out to the global error handler.</p>

<p>Component call:</p>

<pre><code>this.searchService.search(this.searchField.value)
          .subscribe(
            result =&gt; { this.result = result.artists.items; },
            err =&gt; { 
              console.log('subscribe on error');
              this.errorMessage = 'Error Occurred';
              //This error does not bubble out to the global angular error handler.
              throw new Error('Error here'); 
            },
        () =&gt; { console.log('Completed'); }
          );
</code></pre>

<p>Service Call:</p>

<pre><code>search(term: string) {
    return this.http.request(`https://api.spotify.com/v1/dsds?q=${term}&amp;type=artist`)
      .map((response) =&gt; {
        return Observable.throw(result);
      }).catch((err: any)=&gt;{
        console.log('in catch in service');
         return Observable.throw(err);

      })
      ;
  }
</code></pre>

<p>Here is a link to a plnkr to demonstrate the problem. using the latest version of rxjs.</p>

<p><a href=""https://plnkr.co/edit/BI4njaMbtR7pfplQvgru?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/BI4njaMbtR7pfplQvgru?p=preview</a></p>

<p>I am using http.request in this case because in my actual app we are using NSwag studio to generate the typescript clients for calling the web apis.</p>

<p>** Update**</p>

<p>I created a new plunker and went to a previous version of rxjs, and in version 5.0.1 an exception throw in the catch, does bubble up to angular's global error handler.</p>

<p>see example here: <a href=""https://plnkr.co/edit/ZMhTNbBfWaz4Y0TiI0jR?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/ZMhTNbBfWaz4Y0TiI0jR?p=preview</a></p>

<p>The only difference is the version of rxjs in the config.js file. </p>

<pre><code>   'rxjs': 'https://npmcdn.com/rxjs@5.0.1',
</code></pre>
","2374059","","1385174","","2019-02-11 11:14:04","2019-02-11 11:14:04","RxJS + Angular 4 throw error in subscribe onError not bubbling out to custom global error handler","<angular><typescript><rxjs5>","0","5","","","","CC BY-SA 3.0"
"44196352","1","","","2017-05-26 07:50:05","","1","1147","<p>While I was working on some project I came across this type <code>Subscriber&lt;T&gt;</code>. I am not able to declare a property with appropriate type.</p>

<p>Problem is when I do, </p>

<pre><code>let sub = this._api.getDefaultMedia().subscriptions.play.subscribe(
            () =&gt; {
                this.play();
            }
        );
console.log(sub);
</code></pre>

<p>It prints me the following which is of type <code>Subscriber</code></p>

<p><a href=""https://i.stack.imgur.com/ZN86L.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZN86L.png"" alt=""enter image description here""></a></p>

<p>But if I try to assign a variable which is of type <code>Subscription</code></p>

<pre><code>private subPlay : Subscription;

 this.subPlay = this._api.getDefaultMedia().subscriptions.play.subscribe(
            () =&gt; {
                this.play();
            }
        );
</code></pre>

<p>It gives me the following error Type <code>Subscription</code> is not assignable to type <code>Subscription</code></p>

<p><a href=""https://i.stack.imgur.com/dAtrZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dAtrZ.png"" alt=""enter image description here""></a></p>

<p>Even though it says it is returning <code>Subscription</code>, when I do console it is of type <code>Subscriber</code>.</p>

<p>So what is the difference or similarity between these two?</p>
","2079900","","310726","","2017-05-26 09:26:31","2017-05-26 09:26:31","Diff between Subscription and Subscriber<T> angular2","<angular><rxjs><subscription><rxjs5><angular2-observables>","1","5","","","","CC BY-SA 3.0"
"44205065","1","","","2017-05-26 15:20:15","","1","533","<p>Hi I need pass the data from one component to another, for this I am using the class BehavorSubject(I tried too with Subject class, but doesnt works for me). This is my code:
Home page has a filter, and when is selected a filter, it called the service and it service should change a variable of homePage</p>

<pre><code>HomePage.ts
@Component({
  providers: [PatientService],
})
export class HomePage {
   subscription: Subscription;
   constructor(  public auth: AuthService,
                public patientService: PatientService) {
      this.subscription = this.patientService.nameGiven.subscribe(
        nameGiven =&gt; {
          this.patientsByElement = nameGiven.toString();
      });
   ------ more code---
}

Filtro.ts
export class FiltroPage {
    showFilter(filter : FiltroT): void{
        ... code ...
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() =&gt; {
            this.PatientService.getPatientsByTags(this.token,this.filterSelected);
        }  , 1000);
    }
}

patient-service.ts
import { Subject }    from 'rxjs/Subject';
import { Observable ,BehaviorSubject } from 'rxjs/Rx';
@Injectable()
export class PatientService {
    nameSource =  new BehaviorSubject(""asd"");
    nameGiven = this.nameSource.asObservable();
    this.nameSource.next('hi!!!');  //**it works but only in the constructor**
    this.nameGiven.subscribe(()=&gt;{
       console.log(""it changed"");
    });

    getPatientsByTags(token: String, tags: Array&lt;string&gt;){
        return new Promise(resolve =&gt; {
            this.http.get(ConnectionParams.DevEnv + ProceduresNames.TagsByPatient + ProceduresNames.TagIdEtiqueta + tags, options)
            .map(res =&gt; res.json())
            .subscribe(data =&gt; {
              if(data.data.poAnicuRegistros){
                console.log(""here"")
                this.nameSource.next('hi TON :/');  // &lt;-- ***here is the problem. It doesnt work***
              }
              else
                console.log(""XX"");
              resolve( this.data);
            });
        });
    }
}
</code></pre>
","6705909","","6705909","","2017-05-26 15:39:38","2017-06-30 15:14:48","Angular 2: BehaviorSubject/Subject does not work outside constructor","<ionic2><angular2-services><rxjs5><subject><behaviorsubject>","1","1","","","","CC BY-SA 3.0"
"44249759","1","44254978","","2017-05-29 20:11:40","","0","70","<p>So let's say there is an endpoint that returns things of the structure:</p>

<pre><code>{
  results: [
    {hoofed: {
      //animal1
      }
    },
    {feline: {
      //animal2
    }},
    {other: {
      //animal3
    }}
  ]
}
</code></pre>

<p>Say I have something like so:</p>

<pre><code>import {RxHR} from '@akanass/rx-http-request'

return RxHR.get('www.third_party.com')
  .pluck('body')
  .map(JSON.parse)
  .pluck('results')
  .map((animals) =&gt; animals.map((animal) =&gt; animal['hoofed'] || animal['feline']))
</code></pre>

<p>I would expect this to have the following behaviour:</p>

<p>1) Extract the response body.</p>

<p>2) parse the JSON</p>

<p>3) Extract all results</p>

<p>4) Pull the values at either hoofed or feline keys producing:</p>

<pre><code>[animal1, animal2]
</code></pre>

<p>Instead, this only returns the first item to match one of the conditions,e.g. <code>[animal1]</code> rather than mapping the array onto another array as I would expect. My question is, why? And how can I achieve such an inner transformation?</p>
","1772334","","1772334","","2017-05-29 21:16:04","2017-05-30 06:27:34","rxjs inner native map is exiting early","<javascript><rxjs><observable><rxjs5>","2","2","","","","CC BY-SA 3.0"
"44254978","2","","44249759","2017-05-30 06:27:34","","1","","<p>I came up with something generic in case you have an unknown number of animals : </p>

<pre><code>const { Observable } = Rx;

// simulate exactly how we'll receive the HTTP response
const mockedData = JSON.stringify({
  body: JSON.stringify({
    results: [{
      hoofed: {
        name: 'animal1'
      }
    }, {
      feline: {
        name: 'animal2'
      }
    }, {
      other: {
        name: 'animal3'
      }
    }]
  })
});

// mock the RxHR lib and return the equivalent of an HTTP request with observable.of and delay
const RxHR = {
  get: (url) =&gt; Observable.of(mockedData).delay(1000)
};

// take an HTTP response and return the body
const resToJson = (res) =&gt; {
  const fullRes = JSON.parse(res);
  const body = JSON.parse(fullRes.body);
  return body;
};

// for a given array of objects (1), having other objects(2) as value
// return an array of objects(2)
const flattenObjects = (objArr) =&gt; objArr.reduce((acc, curr) =&gt; {
  const keys = Object.keys(curr);
  keys.forEach(key =&gt; acc.push(curr[key]));
  return acc;
}, []);

// nicely display the output : debug only
const niceOutput = (obj) =&gt; console.log(JSON.stringify(obj, null, 2));

const animals$ = RxHR
  .get('www.third_party.com')
  .map(resToJson)
  .map(json =&gt; json.results)
  .map(flattenObjects);

animals$
  .do(niceOutput)
  .subscribe();
</code></pre>

<p>Output :  </p>

<pre><code>[
  {
    ""name"": ""animal1""
  },
  {
    ""name"": ""animal2""
  },
  {
    ""name"": ""animal3""
  }
]
</code></pre>

<p>If you want to try it out, here's a working Plunkr :<br>
<a href=""https://plnkr.co/edit/UkjfSrgHKoS3kqXwiYXA?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/UkjfSrgHKoS3kqXwiYXA?p=preview</a></p>
","2398593","","","","","2017-05-30 06:27:34","","","","0","","","","CC BY-SA 3.0"
"44270611","1","","","2017-05-30 19:40:14","","1","1332","<p>I have a function that will optionally set a header with data retrieved from <code>localStorage</code>. The <code>localStorage</code> operation returns a promise that I can turn into an Observable. Once the headers are set (or not), I want to make an http request and return the Observable as a result:</p>

<pre><code>let startObs;
if (useHeaders) {
  startObs = Observable.fromPromise(this.getStoredHeaders());
}
else {
  startObs = Observable.empty();
}

// wait for startObs here

return this.http.get(url, headers);
</code></pre>

<p>Essentially I want to wait for <code>startObs</code> to complete and then return the <code>http.get</code> Observable. I have tried using something like <code>startObs.concat(this.http.get())</code> or <code>startObs.switch(this.http.get())</code>, but this emits from both the source observable and the <code>http.get</code> observable. I <em>only</em> want to emit the <code>http.get</code> Observable.</p>

<p>Is there any way to subscribe only to the last observable in a chain while waiting for a previous observable to complete?</p>
","454533","","310726","","2017-05-31 07:07:22","2017-05-31 07:07:22","Wait for an observable to complete, start another, and subscribe to its output","<angular><typescript><ionic2><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"44272402","1","44272602","","2017-05-30 21:39:58","","20","14081","<p>Basically I'm trying to inflate <code>BehaviorSubject&lt;[]&gt;</code> with array of data which will be loaded in chunks.</p>

<p><code>BehaviorSubject&lt;[]&gt;</code> will be added with new chunk of data (like <code>Array.push</code>) but I don't want to use another array to store and add to <code>BehaviorSubject.next</code> because this will cause rendering to take too long as the data grow over time.</p>

<p>Any suggestion?</p>
","3130446","","","","","2018-06-05 18:35:03","RxJs: Incrementally push stream of data to BehaviorSubject<[]>","<angular><rxjs5>","2","0","3","","","CC BY-SA 3.0"
"44272602","2","","44272402","2017-05-30 21:54:58","","39","","<p>You can use <code>getValue()</code> method to achieve what you want to do.</p>

<p>Example:</p>

<pre><code>data = new BehaviorSubject&lt;any[]&gt;([]);

addData(foo:any):void{
  // I'm using concat here to avoid using an intermediate array (push doesn't return the result array, concat does).
  this.data.next(this.data.getValue().concat([foo]));
}
</code></pre>
","4102561","","","","","2017-05-30 21:54:58","","","","1","","","","CC BY-SA 3.0"
"44296558","1","","","2017-06-01 00:16:59","","1","537","<p>I have two Observable  , the second Observable(convertScore$) need use return value  from first Observable (displayScore$) .</p>

<p>I use do operator that can be combine two main Observerbles, but second do operator(function:fakeImgSrcFromHttp) inside the first Observable(displayScore$) can't excute , Why??</p>

<hr>

<p>I expected the result isï¼ </p>

<ul>
<li>covert score: <strong>100</strong> To OtherData</li>
<li>bind ImgSrc to HtmlTag: <strong>it's a src string</strong> </li>
<li>display score: <strong>100</strong></li>
<li>complete</li>
</ul>

<p>this is my code , or <a href=""https://jsbin.com/zuhuxeruxi/edit?js,console"" rel=""nofollow noreferrer"">you can view it from JSBIN</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/***** From A Service *****/
var convertScore$ = fakeScoreFromHttp()
              .do(score =&gt; covertScoreToOtherData(score))
              .do(score =&gt; {
                fakeImgSrcFromHttp(score)
                .do(imgSrc =&gt; {
                  console.log(""bind ImgSrc to HtmlTag:"" + imgSrc);
                })
              });

function fakeScoreFromHttp(){
  return Rx.Observable.of(100);
}

function fakeImgSrcFromHttp(score){
  // ToDo : if score is something, then do else do....
  
  // return
  return Rx.Observable.of(""it's a src string"");
}

function covertScoreToOtherData(score){
  console.log(""covert score:"" + score + "" To OtherData"")
}

/***** From B Service *****/
var displayScore$ = convertScore$.do(score =&gt; displayScore(score));
                
displayScore$.subscribe({
    // next: (value) =&gt; { },
    // error: (err) =&gt; { console.log('Error: ' + err); },
    complete: (score) =&gt; { 
      console.log('complete'); 
    }
});

function displayScore(score){
  console.log(""display score:""+score);
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","7291379","","7291379","","2017-06-21 23:38:22","2017-06-21 23:38:22","how combine two observable and use first Observable return value","<javascript><ajax><angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"44298775","1","","","2017-06-01 04:52:34","","0","78","<p>I have a stream of numbers e.g 1 - 10 emitted after every 250ms. </p>

<pre><code>1 -(250ms)- 2 -(250ms)- 3 -(250ms)- 4 -(250ms)- 5 -(250ms)- 6 and so on..

Rx.Observable.from([1, 2, 3, 4, 5])
.zip(Rx.Observable.timer(0, 25), x =&gt; x)
.subscribe(x =&gt; console.log(x));
</code></pre>

<p>I want to add an added delay after every 3 items. i.e on 3, 6, 9</p>

<pre><code>1 -(250ms)- 2 -(250ms)- 3 -(2000ms)- 4 -(250ms)- 5 -(250ms)- 
6 -(2000ms) - 7 -(250ms)- 8 -(250ms)- 9 -(2000ms)- 10
</code></pre>

<p>How to get this.</p>
","6868871","","","","","2017-06-01 16:14:53","Rxjs add delay on specific iteration","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"44300339","1","44399736","","2017-06-01 06:46:29","","1","218","<p>I want to create a stream that </p>

<ol>
<li>splits values and processes each partial on a separate stream</li>
<li>each stream will transform data, I have no control over the applied transformation</li>
<li>(re-)joins the partial values with their corresponding counter part</li>
</ol>

<p>The reason I want to do this is to ensure the integrity of the value. Or at least for some part of it.</p>

<p>Because each stream could have some async operations they do not appear in order when joining the streams. Using some sort of <code>concat()</code> also doesn't work because it would block all incoming values. Processing should be done in parallel.</p>

<p>To illustrate:</p>

<pre><code>                            o
                            |
                            | [{a1,b1}, {a2,b2}, ...]
                            |
                            +
                           / \
                   {a&lt;x&gt;} /   \ {b&lt;x&gt;}
                         /     \
                        |       |
                        |       + async(b&lt;x&gt;) -&gt; b'&lt;x&gt;
                        |       |
                        \       /
                         \     /
                          \   /
                           \ /
                            + join(a&lt;x&gt;, b'&lt;x&gt;)
                            |
                            | [{a1,b'1}, {a2,b'2}, ...]
                            |
                       (subscribe)
</code></pre>

<p>I know this can be done via a <code>result selector</code> function. E.g.</p>

<pre><code>input$.mergeMap(
  ({a, b}) =&gt; Rx.Observable.of(b).let(async), 
  ({a}, processedB) =&gt; ({a, b:processedB})
);
</code></pre>

<p>But, (a) this will result in <code>async</code> to always be setup/tear down for each value. I would like the partial stream to only be initialized once. Also, (b) this only works with one asynchronously stream.</p>

<p>I also tried to use <code>window*</code>, but couldn't figure out how to rejoin values again. Also tried to use <code>goupBy</code> with no luck.</p>

<hr>

<p><strong>EDIT:</strong></p>

<p>Here is my current attempt. It has the mentioned issue (a). <code>Init...</code> and <code>Completed...</code> should only be logged once.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const doSomethignAsync = data$ =&gt; {
  console.log('Init...') // Should happen once.
  return data$
    .mergeMap(val =&gt; Rx.Observable.of(val.data).delay(val.delay))
    .finally(() =&gt; console.log('Completed...')); // Should never happen
};

const input$ = new Rx.Subject();
const out$ = input$
  .mergeMap(
    ({ a, b }) =&gt; Rx.Observable.of(b).let(doSomethignAsync),
    ({ a }, asyncResult ) =&gt; ({ a, b:asyncResult })
  )
  
  .subscribe(({a, b}) =&gt; {
    if (a === b) { 
      console.log(`Re-joined [${a}, ${b}] correctly.`);
    } else {
      console.log(`Joined [${a}, ${b}]...`); // Should never happen
    }
  });


input$.next({ a: 1, b: { data: 1, delay: 2000 } });
input$.next({ a: 2, b: { data: 2, delay: 1000 } });
input$.next({ a: 3, b: { data: 3, delay: 3000 } });
input$.next({ a: 4, b: { data: 4, delay: 0 } });</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","298969","","298969","","2017-06-01 12:00:59","2017-06-06 21:14:55","Branching and (re-)joining value pairs in RxJS","<javascript><rxjs><rxjs5>","1","4","1","","","CC BY-SA 3.0"
"44317078","1","44317539","","2017-06-01 21:05:44","","1","105","<p>I had an issue to filter an observable array, in my case it's <code>resources$</code> (an observable which contains all 'resourses' as JSON), and I have another observable called <code>usedResources$</code>, what I want to achieve is simply get <code>unusedResources$</code> from those 2 variables <strong>(resources - usedResources = unusedResources)</strong>, is there any RxJS way to achieve this?</p>
","7056165","","","","","2017-06-01 21:43:29","Filtering Observable array elements from another Observable array","<javascript><json><typescript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"44317539","2","","44317078","2017-06-01 21:43:29","","1","","<p>If you have multiple streams and you want to combine each item from them somehow, usually that means either <code>combineLatest</code> or <code>zip</code> depending on your desired combination strategy.</p>

<h3>combineLatest | <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""nofollow noreferrer"">documentation</a></h3>

<p>If you want to compute the latest from the most recent item from each stream, regardless of how fast or slow they emit relative to eachother, you would use <code>combineLatest</code>; either <code>Observable.combineLatest</code> or the prototype based <code>stream$.combineLatest</code> which has the same effect but includes the stream you call it on instead of being a static factory. I personally use the static form more often for clarity.</p>

<p>This is probably what you want.</p>

<pre><code>const unusedResources$ = Observable.combineLatest(
  resources$,
  usedResources$,
  (resources, usedResources) =&gt; ({
    something: resources.something - usedResources.something
  })
);
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { Observable } = Rx;

const resources$ = Observable.interval(5000).map(i =&gt; ({
  something: (i + 1) * 1000
}));

const usedResources$ = Observable.interval(1000).map(i =&gt; ({
  something: (i + 1) * 10
}));

const unusedResources$ = Observable.combineLatest(
  resources$,
  usedResources$,
  (resources, usedResources) =&gt; ({
    something: resources.something - usedResources.something
  })
);

unusedResources$.subscribe(
  unusedResources =&gt; console.log(unusedResources)
);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.4.0/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<hr>

<h3>zip | <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-zip"" rel=""nofollow noreferrer"">documentation</a></h3>

<p>If you instead want to combine each item 1:1 i.e. waiting for every stream to emit an item for a given index, you can use <code>zip</code>. However, under the hood it uses an unbounded buffer, so if your streams don't emit at around the same interval you can potentially balloon your memory usage or even run out entirely. For the most part, this should only be used for streams which have a finite, predictable count and interval. For example, if you made N number of ajax calls and want to combine the results of them 1:1.</p>
","1770633","","","","","2017-06-01 21:43:29","","","","0","","","","CC BY-SA 3.0"
"44327710","1","","","2017-06-02 11:22:47","","1","62","<p>Let's say one has an API that accepts queries and returns streams of results, as some of results can change.</p>



<pre><code>type Query = { 
  species?: ""dog"" | ""cat"" | ""rat"", 
  name?: ""string"",
  status?: ""lost"" | ""found""
}
type Result = { species: string, name: string, status: string }[]
</code></pre>

<p>Let's say there are multiple components passing queries to this API and some of them might be the same. One does not want to send needless requests to server and likes to optimize - in order to do this API can be wrapped and calls intercepted.</p>

<pre><code>interface ServiceApi {
  request(query: Query): Observable&lt;Result&gt;
}

class WrappedServiceApi implements ServiceApi {
  constructor(private service: ServiceApi) { }

  request(query: Query): Observable&lt;Result&gt; {
    // intercepted
    return this.service.request(query);
  }
}
</code></pre>

<p><strong>But how to approach this kind optimization using RxJS 5?</strong></p>

<p>Doing it around RxJS might look similar to this:</p>

<pre><code>class WrappedServiceApi implements ServiceApi {

  private activeQueries;
  constructor(private service: ServiceApi) { 
    this.activeQueries = new Map&lt;string, Observable&lt;Result&gt;&gt;();
  }

  request(query: Query): Observable&lt;Result&gt; {
    // it's easy to stringify query
    const hashed: string = hash(query);
    if (this.activeQueries.has(hashed)) {
      // reuse existing stream
      return this.activeQueries.get(hashed);
    } else {
      // create multicast stream that remembers last value
      const results = this.service.request(query).publishLast();
      // store stream for reuse
      this.activeQueries.set(hashed, results);
      // delete stream 5s after it closed
      results.toPromise().then(
        () =&gt; setTimeout(
          () =&gt; this.activeQueries.delete(hashed), 
          5000
        )
      );
      return results;
    }
  }
}
</code></pre>

<p>Can the same be achieved in more declarative rx-way?</p>
","3243730","","","","","2017-09-23 17:00:05","Reusing streams of data for some time","<javascript><functional-programming><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44343393","1","44343713","","2017-06-03 11:24:31","","6","3037","<p>I have the following code inside the constructor of my Angular2 component class:</p>

<pre><code>var observable = Observable.create(function (observer) {
      observer.next(1);
      observer.next(2);
      observer.next(3);
      observer.complete();
    }).observeOn(Scheduler.async);
</code></pre>

<p>I imports include the following:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/observeOn';
import { Scheduler } from 'rxjs/Scheduler';
import 'rxjs/scheduler/async';
</code></pre>

<p>I tried the following import as well instead of the last import above:</p>

<pre><code>import { async } from 'rxjs/scheduler/async';
</code></pre>

<p>I have the following error message while building my project using Angulat CLI:</p>

<pre><code>Property 'async' does not exist on type 'typeof Scheduler'
</code></pre>

<p>What am I missing?</p>
","7422115","","310726","","2017-06-03 12:47:32","2019-02-26 17:51:26","RxJS dependency issue with Scheduler.async","<angular><typescript><rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"44343713","2","","44343393","2017-06-03 12:02:48","","7","","<p>yes, this is correct, because:</p>

<pre><code>import { Scheduler } from 'rxjs/Scheduler';
</code></pre>

<p>this mean, you imported this class: <a href=""https://github.com/ReactiveX/rxjs/blob/5.4.0/src/Scheduler.ts#L8-L63"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.4.0/src/Scheduler.ts#L8-L63</a></p>

<p>and</p>

<pre><code>import { async } from 'rxjs/scheduler/async';
</code></pre>

<p>is <a href=""https://github.com/ReactiveX/rxjs/blob/5.4.0/src/scheduler/async.ts#L47"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.4.0/src/scheduler/async.ts#L47</a></p>

<p>So you can see, <code>Scheduler</code> does not have <code>async</code> property, I guess you wanna convert this thing <code>Rx.Scheduler.async</code> <a href=""https://github.com/ReactiveX/rxjs/blob/5.4.0/src/Rx.ts#L180-L198"" rel=""noreferrer"">source code here</a>, you could try this solution:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/observeOn';

import { async } from 'rxjs/scheduler/async';

var observable = Observable.create(function (observer) {
      observer.next(1);
      observer.next(2);
      observer.next(3);
      observer.complete();
    }).observeOn(async);
</code></pre>
","3676586","","3676586","","2017-06-03 12:44:45","2017-06-03 12:44:45","","","","3","","","","CC BY-SA 3.0"
"44349969","1","44365409","","2017-06-04 01:27:57","","0","164","<p>I would like to calculate and update my map's region every time the map's markers change. So I'm trying to create an observable from the map's markers and subscribe to it:</p>

<pre><code>class Map extends Component {

  componentDidMount() {
    const { store } = this.context
    this.unsubscribe = store.subscribe(() =&gt; { })
    const markers$ = Observable.from(this.props.markers)
    markers$.subscribe(x =&gt; console.log('observable', x))
  }
</code></pre>

<p>Initially I am just console.logging the markers - but eventually I will want to run <code>getRegionForCoordinates</code> and then <code>this.props.updateRegion</code> whenever the markers change. Nothing ever logs to the console. What am I doing wrong? <strong><code>this.props.markers</code> is an empty array initially.</strong></p>

<p><strong>Map.js</strong></p>

<pre><code>import { StyleSheet } from 'react-native'
import React, { Component } from 'react'
import MapView from 'react-native-maps'
import { connect } from 'react-redux'
import {
  Button,
  Container
} from 'native-base'
import { Observable } from 'rxjs'

import selectMarkers from './markers.selector'

import { updateRegion } from './map.action'
import Icon from 'react-native-vector-icons/FontAwesome'
import { toggleMenu } from '../search-page/searchPage.action'
import mapStyle from './style'

const mapStateToProps = (state) =&gt; ({
  region: state.get('map').get('region'),
  markers: selectMarkers(state)
})

const mapDispatchToProps = (dispatch) =&gt; ({
  onRegionChange: (region) =&gt; {
    dispatch(updateRegion(region))
  },
  onToggleMenuClick: () =&gt; {
    dispatch(toggleMenu())
  }
})



const getRegionForCoordinates = (points) =&gt; {
  // points should be an array of { latitude: X, longitude: Y }
  let minX, maxX, minY, maxY;

  // init first point
  ((point) =&gt; {
    minX = point.latitude
    maxX = point.latitude
    minY = point.longitude
    maxY = point.longitude
  })(points[0])

  // calculate rect
  points.map((point) =&gt; {
    minX = Math.min(minX, point.latitude)
    maxX = Math.max(maxX, point.latitude)
    minY = Math.min(minY, point.longitude)
    maxY = Math.max(maxY, point.longitude)
  })

  const midX = (minX + maxX) / 2
  const midY = (minY + maxY) / 2
  const deltaX = (maxX - minX)
  const deltaY = (maxY - minY)

  return {
    latitude: midX,
    longitude: midY,
    latitudeDelta: deltaX,
    longitudeDelta: deltaY
  }
}

class Map extends Component {

  componentDidMount() {
    const { store } = this.context
    this.unsubscribe = store.subscribe(() =&gt; { })
    const markers$ = Observable.from(this.props.markers)
    markers$.subscribe(x =&gt; console.log('observable', x))
  }

  componentWillUnmount() {
    this.unsubscribe()
  }

  render() {
    return (
      &lt;Container&gt;
        &lt;MapView
          style={styles.map}
          region={this.props.region}
          onRegionChangeComplete={this.props.onRegionChange}
        &gt;
          {
            this.props.markers.map(marker =&gt; {
              return (
                &lt;MapView.Marker
                  coordinate={{ latitude: marker.latitude, longitude: marker.longitude }}
                  title={marker.name}
                /&gt;
              )
            })}
        &lt;/MapView&gt;
        &lt;Button
          small
          icon
          style={mapStyle.toggleMenuButton}
          onPress={() =&gt; this.props.onToggleMenuClick()}&gt;
          &lt;Icon name=""sliders"" size={20} color=""#FFFFFF"" /&gt;
        &lt;/Button&gt;
      &lt;/Container&gt;
    )
  }
}

Map.contextTypes = {
  store: React.PropTypes.object
}

Map.propTypes = {
  region: React.PropTypes.shape({
    latitude: React.PropTypes.number,
    longitude: React.PropTypes.number,
    latitudeDelta: React.PropTypes.number,
    longitudeDelta: React.PropTypes.number
  }).isRequired,
  onRegionChange: React.PropTypes.func.isRequired,
  onToggleMenuClick: React.PropTypes.func.isRequired,
  markers: React.PropTypes.array
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Map)

const styles = StyleSheet.create({
  map: {
    ...StyleSheet.absoluteFillObject,
    zIndex: -1
  }
})
</code></pre>

<p><strong>markers.selector.js</strong></p>

<pre><code>import { createSelector } from 'reselect'


const searchResultsSelector = state =&gt; {
  return state.get('searchResults')
}

const selectMarkers = createSelector(
  searchResultsSelector,
  (searchResults) =&gt; {
    const shops = searchResults ? searchResults.map(result =&gt; {
      return result.shops.map(shop =&gt; {
        return {
          id: shop.f1,
          name: shop.f2,
          latitude: shop.f4,
          longitude: shop.f3
        }
      })
    }) : searchResults
    const shopIds = []
    const flattenedShops = [].concat.apply([], shops)
    const uniqueShops = flattenedShops.map(shop =&gt; {
      if (!shopIds.includes(shop.id)) {
        shopIds.push(shop.id)
        return shop
      }
    })
    const finalMarkers = uniqueShops.filter(n =&gt; n != undefined)
    return finalMarkers
  }
)

export default selectMarkers
</code></pre>
","3935156","","3935156","","2017-06-04 01:43:35","2017-06-05 09:18:30","RxJS subscribe never executes","<reactjs><react-native><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"44351478","1","44360012","","2017-06-04 06:47:02","","1","1249","<p>I am creating a slider with images and videos and am want to assign a certain amount of screen time for each type. </p>

<pre><code>let data =  [{""path"":""http://localhost:8091/public/testimg.jpg"",""type"":""image""},{""path"":""http://localhost:8091/public/testvideo.mp4"",""type"":""video""}]
Observable.timer(0, 3000)
                            .map(e =&gt; { 
                                console.log(e); return data[e % data.length]; 
                            })
                            .subscribe(item =&gt; {
                                this.activeItem = item;
                            });
</code></pre>

<p>I am able to set a generic time for all the slides using the code above but am unable to do set separate values for each of the items in the array. </p>

<p>Here is what I actually want to achieve
1) Iterate through the array from 0 to the last index once it has completed iterating infinitely
2) To be able to set a time when the next iteration takes place based on the type property inside each object.</p>

<p>Right now only 1) is satisfiable.</p>
","1646729","","1646729","","2017-06-04 17:01:16","2017-06-06 08:00:25","Dynamic timer in rxjs","<javascript><arrays><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"44360012","2","","44351478","2017-06-05 00:03:00","","2","","<p>The trick would be to use concatMap. It will create from each item an immediate observable with the item followed by a delay of an empty Observable. After that delay the observable completes, and the next one will be concatenated. This will be repeated infinitely with the repeat() operator.</p>

<pre><code>let data =  [{""path"":""http://localhost:8091/public/testimg.jpg"",""type"":""image""},{""path"":""http://localhost:8091/public/testvideo.mp4"",""type"":""video""}];

const delayByMediaType = {image: 1000, video: 5000};

Observable.from(data)
    .concatMap(media =&gt; 
        Observable.of(media).concat(Observable.empty().delay(delayByMediaType[media.type]))
    )
    .repeat()
    .do(console.log)
    .subscribe(item =&gt; this.activeItem = item);
</code></pre>
","3306656","","","","","2017-06-05 00:03:00","","","","1","","","","CC BY-SA 3.0"
"44365409","2","","44349969","2017-06-05 09:08:14","","1","","<p>[EDIT]<br>
below is the solution using rx observables, but quickly after posting it, I was thinking: <strong>are you sure you need the power of <code>Observables</code> to achieve what you want?</strong> </p>

<p>I think you should consider only using the <code>componentWillReceiveProps</code> which is the React way to observe changes. It might very well suit you needs, I think.<br>
You can totally trigger a <code>getRegionForCoordinates</code> and <code>this.props.updateRegion</code> in this callback without the need of any observable.<br>
[END EDIT]</p>

<p>I see what you are trying to achieve. First, you have to understand that <code>Observable.from</code> only takes a single object/value and then ignores any change made to the initial object.</p>

<pre><code>const value = [1]
const obs$ = Observable.from(arr)
obs$.subscribe(console.log.bind(console)) // &lt; this will only print once
value.push(2); // &lt; this will be ignored and wont fire anything
</code></pre>

<p>But, hopefully for you, there is a way to tell <code>React</code> ""warn me when properties change"". And that's exactly what you want. You want to catch any change made to the <code>this.props.markers</code> and feed it to your observable.</p>

<p>We are going to use Rect's <code>componentWillReceiveProps</code> <a href=""https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops</a> to do that</p>

<p>First thing we need to do, is to keep a reference to the <code>marker$</code> (so it can be accessed in another method:</p>

<pre><code>componentDidMount() {
  //...
  this.markers$ = new Observable.Subject()
  //you can subscribe here to this observable
  this.markers$.next(this.props.markers)
}
</code></pre>

<p>And we will also need to implement the <code>componentWillReceiveProps</code> that will feed our <code>markers$</code></p>

<pre><code>componentWillReceiveProps(nextProps) {
  this.markers$.next(nextProps.markers)
}
</code></pre>

<p>And now, this will trigger a <code>subscribe</code> call on your <code>markers$</code>.</p>
","2745879","","2745879","","2017-06-05 09:18:30","2017-06-05 09:18:30","","","","2","","","","CC BY-SA 3.0"
"44369387","1","44375629","","2017-06-05 12:52:32","","8","10175","<p>I would like to watch over an object, so all the subscribers will be informed for any changes of it.</p>

<p>I saw it already been <a href=""https://stackoverflow.com/questions/32683488/rxjs-observing-object-updates-and-changes"">asked before</a>, 
yet the answer is irrelevant since RXjs verion 5 do not include the <strong>ofObjectChanges</strong> in it's API anymore.</p>

<p>I've looked at some ""hacks"" like creating an observer which return a function:</p>

<pre><code>let myObservable =  new Observable((observer) =&gt; {
  return (data) =&gt; {
    observer.next(data)
  }
}) 
//...
myObservable.subscribe()('someData')
</code></pre>

<p>However, I'm sure there is more elegant way of doing it.
Any Ideas?</p>
","7126139","","","","","2017-06-06 21:22:57","How to watch object changes with rxjs 5","<javascript><rxjs><rxjs5>","3","2","4","","","CC BY-SA 3.0"
"44375258","1","44376794","","2017-06-05 18:20:05","","2","817","<p>Is there a way to prevent a subscription to a stream (either observable or subject) from completing after calling the error function on the observable/subject?</p>

<pre><code>var subject = new Rx.Subject();
subject.subscribe(function(){alert(""OnNext"")}, function(){alert(""OnError"")});

var next = document.querySelector(""#next"").addEventListener('click', function(){
  subject.next();
})
var error = document.querySelector(""#error"").addEventListener('click', function(){
  subject.error();
});
</code></pre>

<p>From what I understand, calling <code>subject.error()</code> completes the event stream. So keeping the observable open would break the contract of the Observable object. So how can I handle the lifecycle of the observable in such a way that would recreate the subscription after an error occurs? Here is a <a href=""http://plnkr.co/edit/UHAwTuNHDNhUtIilExlT?p=preview"" rel=""nofollow noreferrer"">plnkr</a> demonstrating the behavior.</p>
","2394409","","310726","","2017-06-05 20:03:17","2017-09-23 16:58:52","RxJS Keep Subject/Observable Subscription Active After Error","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44375629","2","","44369387","2017-06-05 18:43:48","","0","","<p>You need to use Behavior Subject . <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md</a></p>
","413418","","","","","2017-06-05 18:43:48","","","","0","","","","CC BY-SA 3.0"
"44376794","2","","44375258","2017-06-05 20:02:55","","1","","<p>Simply said, you can't. At least not with Subjects.</p>

<p>Subjects have internal state and when they emit or receive <code>error</code> notification they <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subject.ts#L72"" rel=""nofollow noreferrer"">mark themself as stopped</a> and will never ever emit anything.</p>

<p>Otherwise, you could use <code>catch()</code> or <code>retry()</code> operators that resubscribe to their source Observable but this wouldn't help you when using Subjects.</p>
","310726","","641914","","2017-09-23 16:58:52","2017-09-23 16:58:52","","","","0","","","","CC BY-SA 3.0"
"44388032","1","44388680","","2017-06-06 10:52:13","","2","1654","<p>I have a requirement to listen to a stream of items from an observable. When certain conditions arise an asynchronous task will be performed on the item and the component will be 'busy' until this completes. I would like to pause handling items in the subscription until this task has completed (as the processing of the following items is dependent on the result) and then resume from the next item in the sequence without any loss.</p>

<p><strong>the next part is probably best read whilst looking at the Plunk <a href=""https://embed.plnkr.co/XPntV8/"" rel=""nofollow noreferrer"">here</a></strong></p>

<p>To achieve this I have used a <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-buffer"" rel=""nofollow noreferrer"">buffer</a> with a <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow noreferrer"">swtichMap</a>. I thought these would do the job on their own but switchMap destroys and recreates the subscription the sequence gets reset every time.</p>

<pre class=""lang-js prettyprint-override""><code>export class AppComponent implements OnInit {
    source$: Observable&lt;any&gt;;
    clearBuffer$ = new Subject();
    busy$ = new Subject();

    private itemSubscription: Subscription;
    private stayAliveSubscription: Subscription;

    items: any[] = [];

    constructor() { }

    ngOnInit() {
      this.source$ = Observable.range(1, 500).zip(
        Observable.interval(500),
        function (x, y) { return x; }
      ).share();

      this.busy$
        .subscribe(result =&gt; {
          if (!result) {
            this.clearBuffer$.next();
          }
        }, error =&gt; {
          console.log(error);
        });
    }

    start() {
      if (!this.itemSubscription) {
        this.itemSubscription =
          this.busy$.switchMap(busy =&gt; {
            if (busy) {
              return this.source$.buffer(this.clearBuffer$);
            } else {
              return this.source$;
            }
          })
            .subscribe(items =&gt; {
              if (Array.isArray(items)) {
                this.items.push('buffered: ' + items.join());
              } else {
                this.items.push('live feed: ' + items);
              }
            }, error =&gt; {
              this.items.push(error);
            });

        this.stayAliveSubscription = this.source$
          .subscribe(result =&gt; {
            console.log(result);
          }, error =&gt; {
            console.log(error);
          });

        this.busy$.next(false);
      }
   }
...
}
</code></pre>

<p>To fix this the <strong>source$</strong> observable is now shared and a separate subscription is started (<strong>stayAliveSubscription</strong>) so a single subscription is used throughout. This seems messy to me and I wanted to ask if anyone can show me better/alternative approaches to the problem.</p>

<p>I put the working sample in a Plunk <a href=""https://embed.plnkr.co/XPntV8/"" rel=""nofollow noreferrer"">here</a> click start to start the subscription and then set/unset the busy toggle to buffer and continue.</p>

<p><strong>edit: working code with concatMap</strong></p>

<p>I changed the <a href=""https://embed.plnkr.co/2DqP04/"" rel=""nofollow noreferrer"">Plunk</a> to use concatMap. I've pasted the code below as well. The key is that the busy observable returned in concatMap must complete you can't just return the busy$ observable multiple times and call next on it when the busy status changes.</p>

<pre class=""lang-js prettyprint-override""><code>    source$: Observable&lt;any&gt;;
    busy$ = new Subject();
    busy: boolean;

    private itemSubscription: Subscription;
    private stayAliveSubscription: Subscription;

    items: any[] = [];

    constructor() { }

    ngOnInit() {
      this.source$ = Observable.range(1, 500).zip(
        Observable.interval(500),
        function (x, y) { return x; }
      );

      this.busy$
        .subscribe(busy =&gt; {
          this.busy = &lt;any&gt;busy;
        });
    }

    start() {
      if (!this.itemSubscription) {
        this.itemSubscription = this.source$.concatMap(item =&gt; {
          const busySubject = new Subject();
          this.busy$
            .subscribe(result =&gt; {
              busySubject.next(item);
              busySubject.complete();
            });

          if (this.busy) {
            return busySubject;
          } else {
            return Observable.of(item);
          }

        })
          .subscribe(item =&gt; {
            this.items.push(item);
          }, error =&gt; {
            this.items.push(error);
          });
      }

      this.setBusy(false);
    }
</code></pre>
","3534636","","3534636","","2017-06-11 11:09:18","2020-10-06 06:35:39","Pausing and resuming an observable stream, please suggest better options","<angular><typescript><rxjs5>","2","1","","","","CC BY-SA 3.0"
"44388680","2","","44388032","2017-06-06 11:20:52","","2","","<p>I don't fully understand what you are trying to do, but if it is just a matter of preserving the order of the emitted values while the ""async task"" can take a long (random) time, I guess you could use the <code>concatMap</code> operator.</p>

<h2>Theory</h2>

<blockquote>
  <h3><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concatMap"" rel=""nofollow noreferrer""><code>concatMap</code></a></h3>
  
  <p>Projects each source value to an Observable which is merged in the output Observable, in a serialized fashion waiting for each one to complete before merging the next.
  <a href=""https://i.stack.imgur.com/lriH2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lriH2.png"" alt=""concatMap operator marble diagram""></a></p>
</blockquote>

<h2>Practice</h2>

<p>In this example, the <code>src</code>Observable emits a value every 100ms and each value is mapped to a new observable that emits a value between 0 and 2000ms (the async task). You can see the order is safe.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let src = Rx.Observable.timer(0,100);
src.concatMap(i=&gt;{
  return Rx.Observable.timer(Math.random()*2000).mapTo(i); // this is the async task
}).subscribe(data=&gt;console.log(data));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.4.0/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<h2>Making a hot Observable</h2>

<p>You should also not use these subscriptions to make your observable emit data. Actually you should transform your <a href=""https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html"" rel=""nofollow noreferrer"">cold observable to a hot one</a> using <code>.publish()</code>  and <code>.connect()</code> instead of <code>share()</code>and <code>subscribe()</code> :</p>

<pre><code>this.source$ = Observable.range(1, 500).zip(
        Observable.interval(500),
        function (x, y) { return x; }
      ).publish();
// blah blah blah some code
this.source$.connect();
</code></pre>
","3633742","","3633742","","2017-06-07 07:49:44","2017-06-07 07:49:44","","","","4","","","","CC BY-SA 3.0"
"44399736","2","","44300339","2017-06-06 20:59:35","","1","","<p>This is a rather complex problem to solve and exactly how you do it will depend on very specific details to your use case that weren't included.</p>

<p>That said, here's <em>one possible way</em> that makes a bunch of assumptions. It's made to be somewhat generic, like a custom operator to be used with <code>let</code>.</p>

<p>(side note: I named it ""collate"" but this is a bad and highly misleading name for this, but whatevs no time to name things...)</p>

<pre><code>const collate = (...segments) =&gt; source$ =&gt;
  source$
    .mergeMap((obj, index) =&gt; {
      return segments.map(({ key, work }) =&gt; {
        const input = obj[key];
        const output$ = work(input);

        return Observable.from(output$).map(output =&gt; ({
          index,
          result: { [key]: output }
        }))
      })
    })
    .mergeAll()
    .groupBy(
      obj =&gt; obj.index,
      obj =&gt; obj.result,
      group$ =&gt; group$.skip(segments.length - 1)
    )
    .mergeMap(group$ =&gt;
      group$.reduce(
        (obj, result) =&gt; Object.assign(obj, result),
        {}
      )
    );
</code></pre>

<p>And here's a usage example:</p>

<pre><code>const result$ = input$.let(
  collate({
    key: 'a',
    work: a =&gt; {
      // do stuff with ""a""
      return Observable.of(a).map(d =&gt; d + '-processed-A');
    }
  }, {
    key: 'b',
    work: b =&gt; {
      // do stuff with ""b""
      return Observable.of(b).map(d =&gt; d + '-processed-B');
    }
  })
);
</code></pre>

<p>Given input <code>{ a: '1', b: '1 }</code> it would output <code>{ a: '1-processed-A', b: '1-processed-B' }</code> and so on, grouped correctly while doing as much concurrently as possible--the only buffering it does is to match all the segments together for a particular input.</p>

<p>Here's a running demo <a href=""https://jsbin.com/yuruvar/edit?js,output"" rel=""nofollow noreferrer"">https://jsbin.com/yuruvar/edit?js,output</a></p>

<hr>

<h3>Breakdown</h3>

<p>There's probably more clear/simpler ways to doing this, especially if you can hardcode some things instead of making them generic. But let's breakdown what I did.</p>

<pre><code>const collate = (...segments) =&gt; source$ =&gt;
  source$
    // for every input obj we use the index as an ID
    // (which is provided by Rx as autoincrementing)
    .mergeMap((obj, index) =&gt; {
      // segments is the configuration of how we should
      // chunk our data into concurrent processing channels.
      // So we're returning an array, which mergeMap will consume
      // as if it were an Observable, or we could have used
      // Observable.from(arr) to be even more clear
      return segments.map(({ key, work }) =&gt; {
        const input = obj[key];
        // the `work` function is expected to return
        // something Observable-like
        const output$ = work(input);

        return Observable.from(output$).map(output =&gt; ({
          // Placing the index we closed over lets us later
          // stitch each segment back to together
          index,
          result: { [key]: output }
        }))
      })
    })
    // I had returned Array&lt;Observable&gt; in mergeMap
    // so we need to flatten one more level. This is
    // rather confusing...prolly clearer ways but #YOLO
    .mergeAll()
    // now we have a stream of all results for each segment
    // in no guaranteed order so we need to group them together
    .groupBy(
      obj =&gt; obj.index,
      obj =&gt; obj.result,
      // this is tough to explain. this is used as a notifier
      // to say when to complete() the group$, we want complete() it
      // after we've received every segment for that group, so in the
      // notifier we skip all except the last one we expect
      // but remember this doesn't skip the elements downstream!
      // only as part of the durationSelector notifier
      group$ =&gt; group$.skip(segments.length - 1)
    )
    .mergeMap(group$ =&gt;
      // merge every segment object that comes back into one object
      // so it has the same shape as it came in, but which the results
      group$.reduce(
        (obj, result) =&gt; Object.assign(obj, result),
        {}
      )
    );
</code></pre>

<hr>

<p>I didn't think or worry about how error handling/propagation might work because that's highly dependant on your usecase. If you have no control over the processing of each segment, then also including some sort of timeout and <code>.take(1)</code> would be advised otherwise you may leak subscriptions.</p>
","1770633","","1770633","","2017-06-06 21:14:55","2017-06-06 21:14:55","","","","1","","","","CC BY-SA 3.0"
"44418812","2","","35316583","2017-06-07 17:05:59","","85","","<p>As @Adam and @Ploppy mentioned, the Observable.interval() is now <strike>deprecated</strike> not the preferred way of creating such an observable. The preferred way of doing this is via the IntervalObservable or TimerObservable.
[currently in Typscript 2.5.2, rxjs 5.4.3, Angular 4.0.0]</p>

<p>I wanted to add some usage to this answer to demonstrate what I found the best way of doing this in the Angular 2 framework.</p>

<p>First your service (created in angular cli via the 'ng g service MyExample"" command). Assuming the service is RESTful (http get request returns a json):</p>

<p>my-example.service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http, Response} from ""@angular/http"";
import { MyDataModel } from ""./my-data-model"";
import { Observable } from ""rxjs"";
import 'rxjs/Rx';

@Injectable()
export class MyExampleService {
  private url = 'http://localhost:3000'; // full uri of the service to consume here

  constructor(private http: Http) { }

  get(): Observable&lt;MyDataModel&gt;{
    return this.http
      .get(this.url)
      .map((res: Response) =&gt; res.json());
  }
}
</code></pre>

<p>*** see bottom updates to service for Angular 5 ***</p>

<p>Now your component code ('ng g component MyExample'):</p>

<p>my-example.component.ts:</p>

<pre><code>import { Component, OnDestroy, OnInit } from '@angular/core';
import { MyDataModel } from ""../my-data-model"";
import { MyExampleService } from ""../my-example.service"";
import { Observable } from ""rxjs"";
import { IntervalObservable } from ""rxjs/observable/IntervalObservable"";
import 'rxjs/add/operator/takeWhile';

@Component({
  selector: 'app-my-example',
  templateUrl: './my-example.component.html',
  styleUrls: ['./my-example.component.css']
})
export class MyExampleComponent implements OnInit, OnDestroy {
  private data: MyDataModel;
  private display: boolean; // whether to display info in the component
                            // use *ngIf=""display"" in your html to take
                            // advantage of this

  private alive: boolean; // used to unsubscribe from the IntervalObservable
                          // when OnDestroy is called.

  constructor(private myExampleService: MyExampleService) {
    this.display = false;
    this.alive = true;
  }

  ngOnInit() {
    // get our data immediately when the component inits
    this.myExampleService.get()
      .first() // only gets fired once
      .subscribe((data) =&gt; {
        this.data = data;
        this.display = true;
      });

    // get our data every subsequent 10 seconds
    IntervalObservable.create(10000)
      .takeWhile(() =&gt; this.alive) // only fires when component is alive
      .subscribe(() =&gt; {
        this.myExampleService.get()
          .subscribe(data =&gt; {
            this.data = data;
          });
      });
  }

  ngOnDestroy(){
    this.alive = false; // switches your IntervalObservable off
  }
}
</code></pre>

<p>=== edit ===</p>

<p>Updated the component ts code to consolidate the subscriptions via a TimerObservable:</p>

<pre><code>import { Component, OnDestroy, OnInit } from '@angular/core';
import { MyDataModel } from ""../my-data-model"";
import { MyExampleService } from ""../my-example.service"";
import { Observable } from ""rxjs"";
import { TimerObservable } from ""rxjs/observable/TimerObservable"";
import 'rxjs/add/operator/takeWhile';

@Component({
  selector: 'app-my-example',
  templateUrl: './my-example.component.html',
  styleUrls: ['./my-example.component.css']
})
export class MyExampleComponent implements OnInit, OnDestroy {
  private data: MyDataModel;
  private display: boolean; // whether to display info in the component
                            // use *ngIf=""display"" in your html to take
                            // advantage of this

  private alive: boolean; // used to unsubscribe from the TimerObservable
                          // when OnDestroy is called.
  private interval: number;

  constructor(private myExampleService: MyExampleService) {
    this.display = false;
    this.alive = true;
    this.interval = 10000;
  }

  ngOnInit() {
    TimerObservable.create(0, this.interval)
      .takeWhile(() =&gt; this.alive)
      .subscribe(() =&gt; {
        this.myExampleService.get()
          .subscribe((data) =&gt; {
            this.data = data;
            if(!this.display){
              this.display = true;
            }
          });
      });
  }

  ngOnDestroy(){
    this.alive = false; // switches your TimerObservable off
  }
}
</code></pre>

<p>=== edit ===</p>

<p>my-example-service.ts (using the HttpClient a la Angular 5):</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient} from ""@angular/common/http"";
import { MyDataModel } from ""./my-data-model"";
import { Observable } from ""rxjs"";
import 'rxjs/Rx';

@Injectable()
export class MyExampleService {
  private url = 'http://localhost:3000'; // full uri of the service to consume here

  constructor(private http: HttpClient) { }

  get(): Observable&lt;MyDataModel&gt;{
    return this.http
      .get&lt;MyDataModel&gt;(this.url);
  }
}
</code></pre>

<p>Note change to use the HttpClient rather than Http (deprecated in angular5) and the get method which allows for parsing the response into our data model without having to employ the rxjs .map() operator. While the service changes for angular 5, the component code remains unchanged.</p>
","3319326","","3319326","","2018-04-13 04:59:19","2018-04-13 04:59:19","","","","11","","","","CC BY-SA 3.0"
"44428557","1","44431950","","2017-06-08 06:48:41","","1","662","<p>I'm using <code>rxjs</code> with typescript. I wrote following two simple functions. But I guess <code>rxjs</code> already has such functionality. Does <code>rxjs</code>?</p>

<pre><code>export function isObservable(value: any): value is Observable&lt;any&gt; {
  return value instanceof Observable;
}

export function createObservable&lt;T&gt;(value: T | Observable&lt;T&gt;): Observable &lt; T &gt; {
  return isObservable(value) ? value : Observable.of(value);
}
</code></pre>
","5087916","","310726","","2017-06-08 11:01:38","2017-06-08 13:41:34","Rxjs: shorthand of create observable from value or observable","<typescript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"44431847","1","44432142","","2017-06-08 09:30:28","","1","303","<p>I have service for login and use it in the following way:</p>

<pre><code>// LoginComponent
    this.authService.loginDb(credentials)
          .subscribe(() =&gt; {
              this.router.navigate(['/dashboard']);
            },
            (error) =&gt; {
              this.errorMessage = error.description
            });

//auth.service
public loginDb(credentials: Credentials): Observable &lt;any&gt; {
    //make call to third party API
    return this.auth0.client.login({
            ...
        })
        .map((resp) =&gt; {
            // here decode token and then make another request to my server for saving user
            this.token = &lt;Token&gt; this.jwtHelper.decodeToken(resp.idToken);
            return this.userService.createOrUpdateUser(this.token)
                .subscribe(() =&gt; {
                    this.localStorageService.set('token', resp.idToken);
                    this.localStorageService.set('decoded_token', this.token);
                    this.loggedIn = true;
                })
        })
}
</code></pre>

<p>The problem is, for example there is error on my server and <code>this.userService.createOrUpdateUser</code> is failed then <code>error</code> wont handle this in <code>LoginComponent</code>. So, I want <code>error</code> to handle for inner request too. Moreover, I see that <code>subscribe</code> is called before second request is finished.</p>

<p>I believe there is some operator in rxjs for this, but I can't find it.</p>
","348173","","310726","","2017-06-08 11:01:57","2017-06-08 11:01:57","RxJs Handle error when there is another request inside map","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44431950","2","","44428557","2017-06-08 09:34:40","","1","","<p>I don't think RxJS 5 has exactly this functionality already because it's you who should be aware of what type of data you're working with.</p>

<p>However, you can make use of the fact that RxJS handles any Observables, Promises, Observable-like, array-like and so on ... objects the same way and write the following:</p>

<pre><code>const val1 = Observable.of(42);
const val2 = [42];

Observable.from(val1).subscribe(console.log);
Observable.from(val2).subscribe(console.log);
</code></pre>

<p>This will in both cases print just <code>42</code> even though once I used an Observable with a single value and then an array with a single value.</p>

<p>See live demo: <a href=""https://jsbin.com/fubobon/3/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/fubobon/3/edit?js,console</a></p>
","310726","","","","","2017-06-08 09:34:40","","","","0","","","","CC BY-SA 3.0"
"44432142","2","","44431847","2017-06-08 09:41:42","","3","","<p>If you replace <code>map()</code> with <code>concatMap()</code> it'll wait until its inner Observable completes. Also if the inner Observable emits an error it'll be propagated down the chain.</p>

<p>In general try to avoid nesting <code>subscribe()</code> calls.</p>

<pre><code>public loginDb(credentials: Credentials): Observable &lt;any&gt; {
    //make call to third party API
    return this.auth0.client.login({
            ...
        })
        .do(resp =&gt; {
            this.localStorageService.set('token', resp.idToken);
            this.localStorageService.set('decoded_token', this.token);
        })
        .concatMap((resp) =&gt; {
            // here decode token and then make another request to my server for saving user
            this.token = &lt;Token&gt; this.jwtHelper.decodeToken(resp.idToken);
            return this.userService.createOrUpdateUser(this.token);
        })
        .do(() =&gt; {
            this.loggedIn = true;
        });
}
</code></pre>

<p>A used two <code>do()</code>s to perform some side-effects but maybe in you particular use case you won't need them or use them in a different way.</p>
","310726","","","","","2017-06-08 09:41:42","","","","2","","","","CC BY-SA 3.0"
"44458064","1","44537898","","2017-06-09 12:37:37","","0","1751","<p>Here's my code:</p>

<pre><code>const dummydata = {
  param1: 72766,
  param2: 'ELS'
}

var foo = JSON.stringify(dummydata)

let headers = new Headers();
headers.append('content-type', 'application/json');

this.http.post(url, foo, { headers: headers }).map(res =&gt; res.json()).subscribe(
  () =&gt; { alert('Success'); }
);
</code></pre>

<p>For some reason there's no data going to the server as <code>form-data</code>in <code>Request Payload</code> and the type is getting converted to <code>OPTIONS</code> instead of <code>POST</code>
On the other hand if I remove, <code>headers</code>, then the <code>form-data</code> is going but another error occurs:</p>

<pre><code>415 Unsupported Media Type
</code></pre>

<p>UPDATE: JQuery Ajax is working</p>

<p>UPDATE2: Already tried this:</p>

<pre><code>let headers = new Headers({ 'Content-Type': 'application/json' });
let options = new RequestOptions({ headers: headers });
</code></pre>
","4650975","","4650975","","2017-06-09 12:50:35","2017-06-14 07:12:56","angular 2 http post not working","<angular><http><rxjs5>","5","4","0","","","CC BY-SA 3.0"
"44460661","1","44462275","","2017-06-09 14:43:02","","10","3825","<p>If i specify three guards on a route, it seems as though all guards are evaluated immediately.</p>

<p><code>{path: '', component: OptionsComponent, canActivate: [ GuardOne, GuardTwo, GuardThree]}</code></p>

<p>The problem I have is I don't want <code>GuardTwo</code> to run until GuardOne has finished. Is there any way to achieve this?</p>
","1666769","","2545680","","2017-08-10 16:14:27","2017-08-10 16:14:27","How to wait for guards in Angular","<javascript><angular><rxjs><rxjs5>","1","6","3","","","CC BY-SA 3.0"
"44462275","2","","44460661","2017-06-09 16:05:15","","13","","<p>I don't think that's possible in the 4.1.3. <a href=""https://github.com/angular/angular/blob/7edc5e96f373d7c74092b92874fa6c69b308d8dc/packages/router/src/router.ts#L921"" rel=""noreferrer"">Here</a> is the code that runs the guards:</p>

<pre><code>  private runCanActivate(future: ActivatedRouteSnapshot): Observable&lt;boolean&gt; {
    const canActivate = future._routeConfig ? future._routeConfig.canActivate : null;
    if (!canActivate || canActivate.length === 0) return of (true);
    const obs = map.call(from(canActivate), (c: any) =&gt; {
      const guard = this.getToken(c, future);
      let observable: Observable&lt;boolean&gt;;
      if (guard.canActivate) {
        observable = wrapIntoObservable(guard.canActivate(future, this.future));
      } else {
        observable = wrapIntoObservable(guard(future, this.future));
      }
      return first.call(observable);
    });
    return andObservables(obs);
  }
</code></pre>

<p>This simplified piece:</p>

<pre><code>// array of all guards
canActivate.map((guard)=&gt;{
     observable = guard.canActivate()
})
</code></pre>

<p>runs all guards in a sequence without waiting for the previous to finish.</p>

<p>One possible solution would be to have one service that implements <code>CanActivate</code> and combines other guards:</p>

<pre><code>class Combined {
  constructor(private gA: GuardA, private gB: GuardB) {}

  canActivate(r, s) {
        return gA.canActivate(r, s).then(()=&gt;{ return gB.canActivate() });
  }
}

... 
{path: '', component: OptionsComponent, canActivate: [ Combined ]}
</code></pre>
","2545680","","2545680","","2017-06-09 20:10:55","2017-06-09 20:10:55","","","","7","","","","CC BY-SA 3.0"
"44466093","1","44528732","","2017-06-09 20:18:18","","0","196","<p>I have a stream which needs to skip while bool is true. </p>

<p>However, when that bool is set back to false, I need to apply the last stream value missed when it was skipping.</p>

<pre><code>Rx.Observable
.interval(1000)
.skipWhile(val =&gt; true|false)&lt;---when back to false, get last missed value?
.subscribe(val =&gt; console.log(val)); 
</code></pre>
","2275792","","","","","2017-06-13 18:15:21","RxJS5 - skipWhile but keep values while skipping?","<rxjs5>","1","4","","","","CC BY-SA 3.0"
"44486372","1","44486675","","2017-06-11 16:53:32","","1","52","<p>I have a stream that emits some data.</p>

<pre><code>const data$ = Rx
  .Observable
  .interval(500)
  .map(() =&gt; Math.random() * 100)
</code></pre>

<p>And I would like to compute a mean value for all produced values over a period of time (every second for example)</p>

<p>If the <code>data$</code> stream emits <code>-2-2-2-4|</code>, I'd like the resulting stream to be <code>---2---3|</code></p>

<p>How would you do that with <code>rxjs</code> (version 5)</p>
","2745879","","","","","2017-06-11 19:22:16","Computing a mean value every x ms","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"44486675","2","","44486372","2017-06-11 17:27:28","","2","","<p><code>bufferTime</code> is a way to go:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable
  .interval(500)
  .map(() =&gt; Math.random() * 100)
  .do(console.log)
  .bufferTime(2000)
  .map(items =&gt; {
    return items.reduce((acc, cur) =&gt; acc + cur, 0) / items.length;
  })
  .take(3)
  .subscribe(val =&gt; {
    console.log('mean: ' + val);
  })</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.3.1/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Ok, Maxime's point is valid. If you need to calculate mean of great number of values consider using <code>windowTime</code>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var interval = Rx.Observable.interval(2000);

Rx.Observable
  .interval(500)
  .map(() =&gt; Math.random() * 100)
  .do(console.log)
  .window(interval)
  .map(win =&gt; {
    return win.reduce((acc, cur) =&gt; {
      acc.count++;
      acc.sum += cur;
      return acc;
    }, {
      count: 0,
      sum: 0,
    });
  })
  .mergeAll()
  .filter(val =&gt; val.count != 0)
  .map(val =&gt; val.sum / val.count)
  .take(3)
  .subscribe(val =&gt; {
    console.log('mean: ' + val);
  })</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.3.1/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1010664","","1010664","","2017-06-11 19:22:16","2017-06-11 19:22:16","","","","1","","","","CC BY-SA 3.0"
"44488714","1","44497738","","2017-06-11 20:59:15","","0","826","<p>first of all, my app without the publishReplay() is working fine now but I want to optimize the requests by using some kind of caching to avoid going to the backend everytime to check if the user is logged in.  I have the following context. I have auth aware components that need to be hidden or shown depending on the user being logged in or not. I have </p>

<p>a)an <strong>AuthGuard</strong> to guard for certain routes, it redirects the user to sign in route if the user is not logged in:</p>

<pre><code>import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
import { AuthService } from './auth.service';
import { Observable } from 'rxjs/Observable';


@Injectable()
export class AuthGuard implements CanActivate {

  constructor(private authService: AuthService, private router: Router){}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
     return this.authService.isAuthenticated().map(isAuth =&gt; {
       console.log('is authenticated',isAuth);
            if (isAuth) {
                return true;
            }else{
                this.router.navigate(['/signin']);
                return false;
            }
        });
  }
}
</code></pre>

<p>b) an <strong>AuthService</strong> with the method isAuthenticated to check with the backend if the user is logged in(I'm using conventional sessions stored on a db). Here at the end of the chain im using publishReplay(3) cause I have 3 components that are auth aware at loading time. Note that if I remove that method everything works just fine and the authguard does its job, if I add it then I go to for examples localhost:4200/dashboard and the app freezes, links doesn't work and auth guard code is not getting to get executed since I put a console.log 'is authenticated' (as shown above) on AuthGuard and it's not showing on the console, giving the idea that the execution never gets there. If I remove publishReplay then I see the message again on the console:</p>

<p>isAuthenticated(): Observable {</p>

<pre><code>  let options = new RequestOptions({ headers: this.getHeaders(), withCredentials: true });
  return this.http.get('http://localhost:3000/api/addsfiliates/sponsor/check/login',options)
    .map(response =&gt; {
      let res = response.json();
      console.log(""response"");
      if (res.code == 200) {
        this.userIsAuthenticated.next(true);
        return true;
      }
    }
  ).catch((err)=&gt;{
    //maybe add in the future if the code is 403 then send him to login otherwise send him elsewhere
    return Observable.of(false);
  }).publishReplay(3);
</code></pre>

<p>}</p>

<p>c)A route file guarding the routes, just for context explaining:</p>

<pre><code>const appRoutes: Routes = [
  { path: '', redirectTo: '/', pathMatch:'full'},
  { path: '', component: MainComponent },
  { path: 'signin', component:SigninComponent},
  { path: 'signup', component: SignupComponent},
  { path: 'dashboard', canActivate:[AuthGuard],component: DashboardComponent,
    children: [
      { path: '', redirectTo:'dashboard/overview', pathMatch: 'full'},
      { path: 'overview', component: OverviewCampaignsComponent },
      { path: 'active', component: ActiveCampaignsComponent},
      { path: 'history', component: HistoryCampaignsComponent}
    ] }

]
</code></pre>

<p>Am I taking the right approach here to do the caching for the auth aware components? If I am, how can I use this publish replay method to make it work with my use case? Thank you very much</p>
","5935343","","","","","2017-06-12 10:58:44","Rxjs/Angular 4- using publishReplay() on Auth status checking makes my app unresponsive if I enter an AuthGuarded URL on the address bar","<angular><rxjs><rxjs5><http-caching><angular2-observables>","1","0","","","","CC BY-SA 3.0"
"44497738","2","","44488714","2017-06-12 10:58:44","","1","","<p><code>publishReplay</code> returns <code>ConnectableObservable</code> you need to call <code>connect</code> on it then it will connect to the source observable:</p>

<pre><code>let obs = this.http.get(...)
    .publishReplay(1);
obs.connect;
return obs;
</code></pre>

<p>This should fix your app but you will not accomplish what you want. Because on each call you still create a new observable and thus make a call to the server. </p>

<p>The simpliest straightforward solution is:</p>

<pre><code>export class AuthService {
    private isAuthenticatedValue: boolean;

    isAuthenticated(): Observable&lt;boolean&gt; {
        if(this.isAuthenticatedValue != null) {
            return Observable.of(this.isAuthenticatedValue);
        }

        return this.http.get(...)
            ...
            .do(flag =&gt; {
                this.isAuthenticatedValue = flag;
            })
    }
}
</code></pre>

<p>Additionaly you should clear cached value periodically because session can expire on the server. You can do it by clearing the value with <code>setTimeout</code>.</p>
","1010664","","","","","2017-06-12 10:58:44","","","","5","","","","CC BY-SA 3.0"
"44524505","1","44529339","","2017-06-13 14:33:41","","1","326","<p>In retrywhen, i able to re-execute http request upon failure just like example at <a href=""https://stackoverflow.com/questions/40906748/rxjs-observables-run-retrywhen-after-some-more-async-requests/40918207#40918207"">RxJs Observables: run retryWhen after some more async requests</a>. I would like ajax(..) to re-input new option once it fails. Let say I would like to change header or url after first time http request fail. Any example?</p>
","108869","","108869","","2017-06-13 14:44:30","2017-06-13 18:49:31","Update Ajax url after retrywhen","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44528732","2","","44466093","2017-06-13 18:15:21","","0","","<p>Use multicast to share start and the rest values. pairwise to pairt prev and next value and concat to combine start and the rest.</p>

<pre><code> Rx.Observable.interval(500)
   .multicast(new Rx.Subject(), shared =&gt; {
      let start$ = shared
                  .pairwise()
                  .skipWhile((x)=&gt;x[1]&lt;5) // this is the condition to skip
                  .first()         
                  .switchMap(el=&gt;Rx.Observable.concat(Rx.Observable.of(el[0]), 
                                 Rx.Observable.of(el[1])));
      return Rx.Observable.concat(start$, shared);
}).subscribe(x=&gt;console.log(x));
</code></pre>
","6922095","","","","","2017-06-13 18:15:21","","","","0","","","","CC BY-SA 3.0"
"44529339","2","","44524505","2017-06-13 18:49:31","","3","","<p>All what <code>retryWhen</code> does is that it re-subscribes to its source Observable. What this means is up to you.</p>

<p>For example you can use <code>Observable.defer()</code> to return a different Observable on every re-subscription:</p>

<pre><code>let retries = 0;

Observable.defer(() =&gt; {
    if (retries++ === 3) {
      return Observable.of('whatever');
    }
    return this.http.get(...);
  })
  .retryWhen((errors: Observable) =&gt; errors)
  .subscribe(...);
</code></pre>

<p>Similarly you could use for example <code>Observable.create()</code>.</p>
","310726","","","","","2017-06-13 18:49:31","","","","0","","","","CC BY-SA 3.0"
"44537898","2","","44458064","2017-06-14 07:12:56","","0","","<p>I found a better way to tackle this CORS issue by configuring a proxy for the API calls with Angular CLI:</p>

<p>I created a <code>proxy.conf.json</code>:</p>

<pre><code>{
  ""/API"": {
    ""target"": ""http://myserver.com"",
    ""secure"": false
  },
  ""/API2"":{
    ""target"": ""http://myserver.com"",
    ""secure"": false
  }
}
</code></pre>

<p>Then in <code>package.json</code> under <code>scripts</code>:</p>

<pre><code>""start"": ""ng serve --proxy-config proxy.conf.json"",
</code></pre>

<p>Now for calling the APIs simply provide the URLs like ""/API/getData"" and CLI will automatically redirect to the <code>http://myserver.com/API/getData</code> </p>
","4650975","","","","","2017-06-14 07:12:56","","","","0","","","","CC BY-SA 3.0"
"44541990","1","","","2017-06-14 10:21:46","","1","236","<p>I have created a service that uses <code>RxJS</code> to wrap <code>$http</code> calls.</p>

<p>I have several components subscribing to the same observable and I want them to share the AJAX result instead of making multiple requests.</p>

<p><strong>Service code:</strong></p>

<pre><code>export function SearchService($http) {
    'ngInject';

    const autocompleteResults$ = new Subject()
        .debounceTime(250)
        .switchMap(query =&gt; Observable.fromPromise($http.post('/search', { query })))
        .share()
        .map(result =&gt; result.data);


    function autocomplete(query) {
        autocompleteResults$.next(query);
    }

    return {
        autocomplete,
        autocompleteResults$
    };
}
</code></pre>

<p><strong>Component code:</strong></p>

<pre><code>export const myComponent = {
    bindings: {
        query: '&lt;'
    },
    templateUrl: templateUrl,
    controller: myController
};

function myController($SearchService) {
    'ngInject';
    const $ctrl = this;

    $ctrl.$onInit = $onInit;
    $ctrl.$onChanges = $onChanges;

    function $onInit() {
        SearchService.autocompleteResults$
            .subscribe(
                handleSuccess,
                handleError
            );
    }

    function $onChanges(changes) {
        if (changes.query &amp;&amp; changes.query.currentValue)
            SearchService.autocomplete(changes.query.currentValue);
    }
}
</code></pre>

<p>I have <strong>2</strong> active components of <code>myComponent</code> that respond to the query changes.</p>

<p>Since <code>Angular</code> services are singletons, each component should get the same observable instance when subscribing to it, but there are always 2 AJAX calls instead of 1.</p>

<p>I tried using the <code>share</code>, <code>publish</code>, <code>publishReplay</code>, <code>shareReplay</code> and <code>refCount</code> operators with no success.</p>
","4836967","","","","","2017-09-23 16:57:43","Angular 1 service - RxJS share operator not working properly","<angularjs><rxjs><angularjs-service><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44559803","1","","","2017-06-15 06:08:35","","0","438","<p>I have 2 classes, MyService and FooComponent as shown below:</p>

<pre><code>class MyService {
    getStuff(): Observable&lt;Any&gt; () {
        //Implementation that may take sometime to return
    }
}

class FooComponent {
    private myServiceSubscription: Subscription;
    public FooModel : MyDateType;

    constructor(private myService: MyService){
        this.FooModel = null;
        this.myServiceSubscription = null;
    }

    Init() {
        this.myServiceSubscription = this.myService.getStuff().subscribe(response =&gt; {
            //Construct this.FooModel from response;
        }
    }

    Done() {
        if (this.myServiceSubscription !== null) {
            myServiceSubscription.unsubscribe();
        }
    }
}
</code></pre>

<p>The FooComponent takes an instance of MyService and calls getStuff method in its Init method. Note the subscription call using RxJs module. This means the Init method returns before the subscribe event fires. Based on this code, I have following unit test (using Jasmine framework):</p>

<pre><code>describe('Component: Foo', () =&gt; {

    it('Load Foo Model', (() =&gt; {

        var myService = new MyService();
        var instance = new FooComponent(myService);
        instance.Init();

        if (instance.FooModel == null)
        {
            fail(""FooModel is null even after calling Init() method."");
        }
    }));

});
</code></pre>

<p>This test always fails because the test does not wait until subscribe event is fired in the FooComponent's Init method and hence FooComponent instance FooModel is not populated.</p>

<p>What can I do so that some how the test waits for the subscribe event to fire and FooModel is populated?</p>
","889309","","","","","2017-06-17 09:41:04","How to wait for internal subscribe event to fire in unit testing in TypeScript/JavaScript code?","<javascript><unit-testing><jasmine><rxjs5><typescript2.0>","1","2","","","","CC BY-SA 3.0"
"44590408","1","","","2017-06-16 13:24:34","","2","485","<p>I'm trying to write unit tests for component that uses observable data services. I have a problem with data service, which makes a HTTP call and can return data with a delay.</p>

<p>I mocked the service to return an observable of a subject. Then in 'it' blocks I push what I need down that stream (errors, correct data etc). In this case however I cannot simulate passage of time - the application is never in a loading state, since data service responds immediatly. So I added delay operator to the mock. Advancing the time using tick() doesn't seem to work correctly with the delay operator however.</p>

<p>I tried it in other way: for the mock I used TestScheduler. Then I advance time using flush(). However the problem with flush is that it advances the time to the end of the stream (I can't do step by step). I can't change the emitted values by per-test basis as well, since the observable is hardcoded. I would need to configure the TestBed again with a different mock provider if I want a different observable.</p>

<p>Did anyone have some success testing observables in this manner?</p>

<p>EDIT: </p>

<p>I would like to achieve something like this:</p>

<pre><code>1. I create service mock and inject it as a provider for my component.

2a. I make the mock service return a ColdObservable using TestScheduler.
e.g. stream = TestScheduler.createColdObservable('-a', {a: myData})

it('should show loading status, () =&gt; {
    expect(component.loading).toBe(true);
    flush();
    expect(component.loading).toBe(false);
});

2b. I make the mock service return a subject. Then I next the values I need 
for tests.

it('should handle errors, () =&gt; {
    stream.next(error);
    expect(component.errors.length).toBe(1);
});
</code></pre>

<p>In the first example, when I'm using TestScheduler, I can't next() any values. In the second example when I'm using subject I can't do flush() or handle time in any way (emissions happen instantly).</p>

<p>I'm looking for a way to have both:
1. I can change what's emitted on per-test basis.
2. I can simulate time passage.
Without the need to go through configuring the TestBed again with different provider.</p>
","3147767","","3147767","","2017-06-16 15:38:21","2017-06-16 15:38:21","Simulate observable time passage in Angular 4 tests","<angular><unit-testing><jasmine><rxjs5>","0","1","","","","CC BY-SA 3.0"
"44599304","1","44599609","","2017-06-16 23:36:07","","2","3465","<p>My situation: I have a datastore where I can get models that can be observed using RxJS Observables. The general type signature is</p>

<pre><code>const foo = new Model({id: 123}, dataStore);
foo.asObservable().subscribe((v) =&gt; /* do stuff with values of this model */ );
</code></pre>

<p>the general notion is that treating data like observables helps in two ways: (a) when you've got a cold cache situation (like the browser's localStorage has some out-of-date data) but still want to display something while the actual data is being fetched, and (b) when you've got the proper data loaded already, but changes are made to it either locally or on the backend that need to propagate up. This works reasonably well so far.</p>

<p>The next-level problem is that models have relationships to other models (parents have many children, for example). As per usual in this, the I can do stuff like</p>

<pre><code>foo.asObservable().subscribe(v =&gt; console.log(v.relationships.children))
</code></pre>

<p>and (ignore null errors here), I'd get [1, 2, 3] initially and then [1, 2, 3, 4] when 4 is added to the parent-child-relationship. With me so far?</p>

<p>The problem is that I often want to access these children, not as indices, but as observable models in their own right (so I can display the first names of all the members of a user community, for example, where both the community and all the members are data models). I'm currently doing this with a lot of boilerplate in my controller code, involving a lot of calls to <code>.combineLatest</code>.</p>

<p>What I want to do is define a custom operator for objects of this type so I can boilerplate it all together. Ideally it would look like:</p>

<pre><code>foo.asObservable().inflateRelationship('members').subscribe(
  (v) =&gt; // v === [{name: 'steve'}, {name: 'gertude'} ...] etc
);
</code></pre>

<p>I actually have this partly working, but the problem is kicking off the actual chain. I'm following the <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/operator-creation.md"" rel=""nofollow noreferrer"">instructions for extending Observable</a>, creating a new CustomObservable class that implements <code>lift</code>, but my issue is that I can't use static Observable methods here, like Observable.merge(), to generate my initial observable in <code>Model.asObservable</code>.</p>

<p>My problem comes here:</p>

<pre><code>const preload$ = Observable... 
  // create the ""load from cache and backend observable""
const update$ = Observable ... 
  // create the ""update after load when the storage updates observable"" 

return new CustomObservable(context).merge(preload$, update$);
</code></pre>

<p>It's that last line that fails. I want to return this CustomObservable made from a merge operator on the two regular observable streams. I need to add the context to the constructor there, because that context contains references to the data stores needed to actually inflate the child models (without that, the stream of id arrays is kind of pointless).</p>

<p>So that's my specific problem: I've created an Observable operator that I want to add to CustomObservable as a class, so I can just use the downstream operators like normal, but I can't seem to properly get the whole chain kicked off. </p>

<p>Any pointers, even to existing projects that correctly (and non-trivially) extend the Observable class would be welcome. I tried digging into the source code, but I can't even figure that part out (it looks like the Observable class statics are added somewhere else, and it's super-unclear how at first glance, since nothing's defined in the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts"" rel=""nofollow noreferrer"">Observable class itself</a>).</p>
","1596772","","","","","2017-06-17 00:25:16","Extending Observable with custom functionality","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"44599609","2","","44599304","2017-06-17 00:25:16","","5","","<p>This is one of those ""write a really long question to stack overflow and figure out the answer shortly after you've posted it"" sort of situations, but I figured I'd write up the answer just for posterity's sake.</p>

<p>Assuming you've followed the instructions to subclass Operator, what you do is</p>

<pre><code>asObservable() {
  // do a bunch of stuff making different things
  return Observable.merge(one$, two$)
    .let(obs =&gt; new CustomObservable(context, obs);
</code></pre>

<p>and then in CustomObservable you have</p>

<pre><code>class CustomObservable extends Observable {
  constructor(context, source) {
    super();
    this.source = source;
  }
  customOperator() {}
  lift(operator) {
    const obs = new CustomObservable(context, this);
    obs.operator = operator;
    return obs;
  }
}
</code></pre>

<p>and this lets me do</p>

<pre><code>Model.asObservable()
.filter() // normal RxJs operator here
.customOperator() // yay
.map() // back to other RxJs operators
.subscribe(v =&gt; console.log(v)) // or whatever
</code></pre>

<p>so, yay. Now my angular models can look a lot more spare.</p>
","1596772","","","","","2017-06-17 00:25:16","","","","1","","","","CC BY-SA 3.0"
"44599854","1","44599994","","2017-06-17 01:09:41","","0","120","<p>I have this epic:</p>

<pre><code>export const fetchProductsFulfilledEpic = action$ =&gt;
  action$.ofType(FETCH_PRODUCTS_FULFILLED)
    .mergeMap(action =&gt; {
      return Observable.of(
        updateSearchResults(action.payload),
        toggleMenu(),
        updateRegion(action.payload)
      ).catch(error =&gt; Observable.of(
        fetchProductsRejected(error))
        )
    })
</code></pre>

<p>I would like to only return </p>

<pre><code>updateSearchResults(action.payload),
toggleMenu(),
updateRegion(action.payload)
</code></pre>

<p>if <code>action.payload.products.length</code> is greater than 0, otherwise, show an alert.</p>

<p>Attmept:</p>

<pre><code>export const fetchProductsFulfilledEpic = action$ =&gt;
  action$.ofType(FETCH_PRODUCTS_FULFILLED)
    .mergeMap(action =&gt; {
      Observable.if(() =&gt; action.payload.products.length &gt; 0,
        Observable.of(
          updateSearchResults(action.payload),
          toggleMenu(),
          updateRegion(action.payload)
        ), Observable.of(...enter alert observable here...)
      ).catch(error =&gt; Observable.of(
        fetchProductsRejected(error))
        )
    })
</code></pre>

<p>getting error:</p>

<blockquote>
  <p>You provided 'undefined' where a stream was expected. You can provide
  an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p>How do I return the <code>Observable.of</code> above, and return an observable with <code>showAlertDialog</code> if <code>action.payload.products.length &lt; 1</code>. </p>
","3935156","","3935156","","2017-06-17 01:35:15","2017-06-17 07:22:01","Return different observable if payload length is < 1","<javascript><redux><rxjs><rxjs5><redux-observable>","1","2","","","","CC BY-SA 3.0"
"44599994","2","","44599854","2017-06-17 01:40:35","","2","","<p>How about a normal conditional inside the <code>mergeMap</code>?</p>

<pre><code>export const fetchProductsFulfilledEpic = action$ =&gt;
  action$.ofType(FETCH_PRODUCTS_FULFILLED)
    .mergeMap(action =&gt; {
      if (action.payload.products.length &gt; 0) {
        return Observable.of(
          updateSearchResults(action.payload),
          toggleMenu(),
          updateRegion(action.payload)
        );
      } else {
        return Observable.of(
          showAlertDialog()
        );
      }
    })
</code></pre>

<hr>

<p>As a side point, your <code>catch</code> is currently extraneous since an <code>Observable.of</code> will never throw errors:</p>

<pre><code>.mergeMap(action =&gt; {
  return Observable.of(
    updateSearchResults(action.payload),
    toggleMenu(),
    updateRegion(action.payload)
  // this is catching errors on the above Observable but
  // this Observable will never ever throw errors
  ).catch(error =&gt; Observable.of(
    fetchProductsRejected(error)
  ))
})
</code></pre>
","1770633","","1770633","","2017-06-17 07:22:01","2017-06-17 07:22:01","","","","3","","","","CC BY-SA 3.0"
"44604853","1","","","2017-06-17 12:50:41","","0","902","<p>I have a situation in Angular (4) where an async-pipe doesn't bind to an Observable set in <code>ngAfterViewInit()</code>, unless I initialise it in the constructor using <code>Observable.interval(1000)</code>. If I remove the <code>.interval</code>-part, the async pipe will not subscribe to the observable when <code>ngAfterViewInit()</code> runs.</p>

<p>I would like to initialise the observables like this in the top of the class, but that breaks the functionality:</p>

<pre><code>resultStream: Observable&lt;string&gt;;
genderStream: Observable&lt;number&gt;;
</code></pre>

<p>I have to declare them like this:</p>

<pre><code>// Weird fix: I need to add .interval(?) for async pipe to work later on...
resultStream: Observable&lt;string&gt; = Observable.interval(1000).map(() =&gt; """");
genderStream: Observable&lt;number&gt; = Observable.interval(1000);
</code></pre>

<p>So my solution now feels a bit unsatisfactory, since I have to use the <code>.interval()</code> setup.</p>

<p>The problem is reproduced in this plunker: <a href=""https://plnkr.co/edit/q3TR5iszU1swFrTjajEa"" rel=""nofollow noreferrer"">https://plnkr.co/edit/q3TR5iszU1swFrTjajEa</a></p>

<p>Click a gender, and enter an integer in the input field to show a result.</p>

<p>Can you help me with an easy/elegant solution for this?
Thanks. </p>

<p>The complete class is this:</p>

<pre><code>import { Component, OnInit, ViewChild, ElementRef, AfterViewInit, ChangeDetectionStrategy } from '@angular/core';
import { Observable } from 'rxjs/Rx';


@Component({
    selector: 'my-app',
    template: `
    &lt;div class=""row""&gt;
    &lt;div class=""col-md-6""&gt;
        &lt;form class=""form-inline""&gt;
            &lt;input #distance class=""form-control"" placeholder=""Distance""&gt;
            &lt;button #femaleGender type=""button"" class=""btn btn-default"" [class.active]=""(genderStream | async) === 1""&gt;Female&lt;/button&gt;
            &lt;button #maleGender type=""button"" class=""btn btn-default"" [class.active]=""(genderStream | async) === 0""&gt;Male&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
    &lt;div class=""col-md-6""&gt;
        &lt;h4&gt;Result: {{ resultStream | async }}&lt;/h4&gt;
    &lt;/div&gt;
    &lt;/div&gt;
`,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class AppComponent implements AfterViewInit {

    // Weird fix: I need to add .interval(?) for async pipe to work later on...
    resultStream: Observable&lt;string&gt; = Observable.interval(1000).map(() =&gt; """");
    genderStream: Observable&lt;number&gt; = Observable.interval(1000);

    @ViewChild('distance') distance: ElementRef;
    @ViewChild('maleGender') maleGender: ElementRef;
    @ViewChild('femaleGender') femaleGender: ElementRef;


    ngAfterViewInit() {
        let distance$ = Observable.fromEvent(this.distance.nativeElement, 'keyup')
            .map((event: Event) =&gt; event.target)
            .map((element: HTMLInputElement) =&gt; element.value)
            .map(value =&gt; parseInt(value))
            .filter(value =&gt; !isNaN(value));

        // In the calculation 0 is used for males and 1 for females.
        let male$ = Observable.fromEvent(this.maleGender.nativeElement, 'click').map(() =&gt; 0);
        let female$ = Observable.fromEvent(this.femaleGender.nativeElement, 'click').map(() =&gt; 1);
        let gender$ = Observable.merge(male$, female$);

        this.genderStream = gender$;

        this.resultStream = Observable.combineLatest(
            distance$,
            gender$,
            (distance, gender) =&gt; calculateResult(distance, gender).toFixed(1)
        );
    }
}

const calculateResult = (distance: number, gender: number) =&gt; 18.38 + (0.033 * distance) - (5.92 * gender);
</code></pre>
","3368477","","3368477","","2017-06-17 12:53:38","2017-06-17 13:07:29","Async pipe doesn't bind to Observable in Angular","<angular><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"44609744","1","","","2017-06-17 21:55:18","","-1","1130","<p>I've angular(4) application and I'm using <code>EventEmitter</code>'s for some events.</p>

<p>So, each <code>eventEmitter</code> has about ~ 50 subscriptions. And I want to know the way for quick destroy all of them.</p>

<p>1) I know the way when we will push each Observable/Subject object to the array, but it's really dirty way. We have a lot of ugly code in our application and my eyes are pouring blood when I see it.</p>

<p>2) I know another way when we can use <code>.takeUntil</code> or <code>.takeWhile</code> but it isn't solution! (Correct me if I'm wrong) Because subscribers will not respond to events, but Observer will have subscribers. (If you remember it's about ~ 50 for each observer). And subscribers will remain in memory. I'm not sure, but seems that GC can't destroy those objects. And It's really bad!</p>

<p>So, as I understand - we should use <code>.unsubscribe</code> or <code>.complete</code> for kill observers with subscribers. And.... how we can do it? Do you now beautiful way except arrays?</p>

<p>P.S. I also had thoughts regarding TS decorators for collect objects for destroy, but I haven't got success result...</p>
","4205768","","","","","2017-06-18 10:42:30","How to destroy totally RXjS Objects in Angular","<javascript><angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44625667","1","","","2017-06-19 08:31:29","","0","2106","<p>I am trying to implement search with multiple terms. N<a href=""https://i.stack.imgur.com/cu92O.png"" rel=""nofollow noreferrer""> chart flow of want i tried to implement</a></p>

<p>i read this blog: <a href=""https://netbasal.com/manage-your-filters-like-a-pro-in-angular-with-combinelatest-e7b0204be2df"" rel=""nofollow noreferrer"">https://netbasal.com/manage-your-filters-like-a-pro-in-angular-with-combinelatest-e7b0204be2df</a> it similar case. but i didn't understand how i can implement it with dynamic observables(search terms input). 
let say i have filter with 30 search terms. the easy solution will be to use combineLatest to all search terms components but its not efficient.
My goal is to subscribe to observables on their first change.</p>

<p>i tried to use the combineLatest operator with dynamic array but it didnt work:(.</p>

<p>my code: </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import {Component, OnInit, Input, ViewChildren, QueryList, AfterViewInit} from '@angular/core';
import {Table} from ""../../models/table"";
import {InputFilterComponent} from ""../types/input-filter/input-filter.component"";
import {Observable} from ""rxjs/Observable"";

@Component({
  selector: '[phantom-thead-filter]',
  template: '&lt;th&gt;Actions&lt;/th&gt;
  &lt;th *ngFor=""let col of cols"" class=""ng2-smart-th {{ col.title }}"" [ngClass]=""col?.class""&gt;
    &lt;input-filter [col]=""col"" [table]=""table""&gt;&lt;/input-filter&gt;
  &lt;/th&gt;
  ',
  styleUrls: ['./phantom-thead-filter.component.css']
})
export class PhantomTheadFilterComponent implements OnInit, AfterViewInit {
  @Input() cols;
  @Input() table: Table;
  @ViewChildren(InputFilterComponent) filters : QueryList&lt;InputFilterComponent&gt;;

  constructor() { }

  ngOnInit() {
  }

  ngAfterViewInit() {
    const filters = this.filters.map(f =&gt; f.getFilterWatcher());
    Observable.combineLatest(filters)
      .map(( filters : any[] ) =&gt; {
        filters.map((filter) =&gt; {
          return filter;
        });
      });
  }

}




import {Component, Input, OnInit} from '@angular/core';
import {FormControl} from ""@angular/forms"";
import {Table} from ""../../../models/table"";

@Component({
  selector: 'input-filter',
  template: '&lt;input [formControl]=""inputControl""
                    class=""form-control""
                    type=""text""
                    placeholder=""input"" /&gt;',
  styleUrls: ['./input-filter.component.css']
})
export class InputFilterComponent implements OnInit {
  inputControl = new FormControl();
  @Input() col;
  @Input() table: Table;
  changeFilter: any;
  constructor() { }

  ngOnInit() {
    this.changeFilter =this.inputControl.valueChanges
      .skip(1)
      .distinctUntilChanged()
      .debounceTime(400)
      .map((value: string) =&gt; {
        return value;
      }).startWith(null);
  }

  getFilterWatcher() {
    return this.changeFilter;
  }

  ngOnDestroy() {
    this.changeFilter.unsubscribe();
  }

}</code></pre>
</div>
</div>
</p>
","2112513","","","user663031","2017-06-19 10:03:46","2017-06-19 10:03:46","rxjs angular 2: search filter with multiple terms","<angular><rxjs><angular2-services><rxjs5>","2","1","","","","CC BY-SA 3.0"
"44626899","1","","","2017-06-19 09:31:48","","0","56","<p>How can I implement the following code using Observables in rxjs?</p>

<p>What I am trying to achieve here is that I have an array of functions, each of  which accepts an object, modifies it and returns the object to the next function in the stack.</p>

<pre><code>function A(res:SomeType){
    //Do Something
    return res;
}

function B(res:SomeType){
    //Do Something
    return res;
}

function C(res:SomeType){
    //Do Something
    return res;
}

let fnPipe = [];

fnPipe.push(A); 
fnPipe.push(B);
fnPipe.push(C);

obj= {key:""val""};

fnPipe.forEach((fn)=&gt;{
    obj= fn(obj);
});
console.log(obj);
</code></pre>

<p>How can I implement the same using observables in rxjs?</p>
","2951982","","1171702","","2018-05-30 11:16:44","2018-05-30 11:16:44","How to implement following using rxjs Observables?","<javascript><rxjs><observable><rxjs5>","1","1","","","","CC BY-SA 4.0"
"44641246","1","44644237","","2017-06-19 23:04:29","","32","13818","<p>I have a RxJS5 pipeline looks like this</p>

<pre><code>Rx.Observable.from([2, 3, 4, 5, 6])
  .takeWhile((v) =&gt; { v !== 4 })
</code></pre>

<p>I want to keep the subscription until I see 4, but I want to last element 4 also to be included in the result. So the example above should be</p>

<pre><code>2, 3, 4
</code></pre>

<p>However, according to <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-takeWhile"" rel=""noreferrer"">official document</a>, <code>takeWhile</code> operator is not inclusive. Which means when it encounters the element which doesn't match predicate we gave, it completes the stream immediately without the last element. As a result, the above code will actually output</p>

<pre><code>2, 3
</code></pre>

<p>So my question is, what's the easiest way I can achieve <code>takeWhile</code> but also emit the last element with RxJS?</p>
","25077","","","","","2019-03-11 08:05:42","RxJS takeWhile but include the last value","<rxjs><reactive-programming><rxjs5>","6","4","3","","","CC BY-SA 3.0"
"44644237","2","","44641246","2017-06-20 05:06:16","","50","","<p>Since RxJS 6.4.0 this is now possible with <code>takeWhile(predicate, true)</code>.</p>

<p><strike>There's already an opened PR that adds an optional <code>inclusive</code> parameter to <code>takeWhile</code>: <a href=""https://github.com/ReactiveX/rxjs/pull/4115"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/pull/4115</a></strike></p>

<p>There're at least two possible workarounds:</p>

<ol>
<li><p>using <code>concatMap()</code>:</p>

<pre><code>of('red', 'blue', 'green', 'orange').pipe(
  concatMap(color =&gt; {
    if (color === 'green') {
      return of(color, null);
    }
    return of(color);
  }),
  takeWhile(color =&gt; color),
)
</code></pre></li>
<li><p>Using <code>multicast()</code>:</p>

<pre><code>of('red', 'blue', 'green', 'orange').pipe(
  multicast(
    () =&gt; new ReplaySubject(1),
    subject =&gt; subject.pipe(
      takeWhile((c) =&gt; c !== 'green'),
      concat(subject.take(1),
    )
  ),
)
</code></pre></li>
</ol>

<p>I've been using this operator as well so I made it to my own set of additional RxJS 5 operators: <a href=""https://github.com/martinsik/rxjs-extra#takewhileinclusive"" rel=""noreferrer"">https://github.com/martinsik/rxjs-extra#takewhileinclusive</a></p>

<p>This operator has been also discussed in this RxJS 5 issue: <a href=""https://github.com/ReactiveX/rxjs/issues/2420"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/issues/2420</a></p>

<p>Jan 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-03-11 08:05:42","2019-03-11 08:05:42","","","","0","","","","CC BY-SA 4.0"
"44680701","1","44734952","","2017-06-21 15:43:36","","2","324","<p>Let's say I have a <code>sequence</code> like this:</p>

<pre><code>Rx.Observable
.interval(1000)
.subscribe(data =&gt; {console.log(data)})
</code></pre>

<p>With <code>operators</code>, how can I '<code>restart</code>' the sequence, meaning <code>unsubscribe</code> and <code>resubscribe</code>. </p>

<p>The real scenario is that the <code>sequence</code> is a socket stream, upon certain conditions we need to <code>unsubscribe</code> and <code>resubscribe</code>, kind of like the <code>retryWhen(errors)</code> works, but not with errors...would ideally be something like...<code>retryWhen(bool:Subject)</code>.</p>
","2275792","","310726","","2017-06-24 09:32:50","2017-06-24 09:32:50","RxJS - retry or reset","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"44680851","1","44692617","","2017-06-21 15:49:29","","0","1023","<p>I have some bussiness logic function to call , which has a logic that must use HttpGet , And I have to wait until it returns the result to contiune ,if i use jquery's ajax can simple do it all , do not know whether the Observable also has similar way?</p>

<hr>

<p>I hope the resut is : </p>

<ul>
<li>John</li>
<li>Andy</li>
</ul>

<p>but now the result is only show <strong>Andy</strong>  :(</p>

<hr>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function main(){  
/*
  I have more than 70 sharing rules to deal with different Logic
  (e.g. getAge , getSomthing...), in order to simplify the problem ,
  I only list two rules as a demonstration
*/
  methods = [
    getNameFromServer,
    getSomeOneName
  ];
  
  const result = [];  
  methods.forEach(method =&gt; {
    method(result);
  })
  
  console.log(result);
}

function getNameFromServer(result){
  Rx.Observable.of('John')
    .delay(1000)
    .subscribe(name =&gt; {   
      console.log('now async get name , but I need it will be sync')
      result.push(name)
    });
  
  // can I use sync Ajax like jquery's code?
  // $.ajax({ 
  //          ... ,
  //          async: false 
  //        })
  //  .done(response =&gt; result.push(response.xxx))
}

function getSomeOneName(result){
  result.push('Andy');
}


// execute
main();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=""utf-8""&gt;
  &lt;meta name=""viewport"" content=""width=device-width""&gt;
  &lt;title&gt;JS Bin&lt;/title&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","7291379","","7291379","","2017-06-23 00:01:49","2017-06-23 02:58:31","Can the Observable call in Angular 4 be like jquery's sync ajax way?","<javascript><ajax><angular><rxjs><rxjs5>","1","6","","","","CC BY-SA 3.0"
"44692617","2","","44680851","2017-06-22 07:16:38","","1","","<p>In any modern browser you can use <code>async</code>/<code>await</code> to get a synchronous behavior. You must:</p>

<ul>
<li>Declare your <code>main</code> as <code>async</code></li>
<li>Replace the <code>forEach</code> with <code>for</code>..<code>of</code> (callbacks don't work well with <code>await</code>)</li>
<li>Convert your <code>Observable</code> to <code>Promise</code> to make it awaitable, then return it</li>
<li>Replace <code>subscribe</code> with <code>do</code>. You still get the side effects but <code>do</code> returns the observable so you can immediately chain <code>toPromise</code>. The observer is automatically subscribed by <code>toPromise</code></li>
</ul>

<p>Code would be:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>async function main(){  

      methods = [
        getNameFromServer,
        getSomeOneName
      ];
      
      const result = [];
      for (let method of methods) {
        await method(result);
      }
      console.log(result);
    }
    
    function getNameFromServer(result){
      return Rx.Observable.of('John')
        .delay(1000)
        .do(name =&gt; {   
          console.log('now async get name , but I need it will be sync')
          result.push(name)
        })
        .toPromise();
      
      // can I use sync Ajax like jquery's code?
      // $.ajax({ 
      //          ... ,
      //          async: false 
      //        })
      //  .done(response =&gt; result.push(response.xxx))
    }
    
    function getSomeOneName(result){
      result.push('Andy');
    }
    
    
    // execute
    main();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=""utf-8""&gt;
  &lt;meta name=""viewport"" content=""width=device-width""&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","1516080","","7291379","","2017-06-23 02:58:31","2017-06-23 02:58:31","","","","2","","","","CC BY-SA 3.0"
"44734952","2","","44680701","2017-06-24 09:32:37","","2","","<p>I'd do it using <code>switchMap()</code> because it automatically unsubscribes from the old Observable and subscribes to the new one. In this case we'll use only <code>.switchMap(() =&gt; source)</code>:</p>

<pre><code>const subject = new Subject();

const source = Observable.create(obs =&gt; {
    console.log('Observable.create');
    obs.next(42);
});

subject.switchMap(() =&gt; source)
    .subscribe(v =&gt; console.log('next:', v));


setTimeout(() =&gt; subject.next(), 1000);
setTimeout(() =&gt; subject.next(), 5000);
</code></pre>

<p>This prints the following:</p>

<pre><code>Observable.create
next: 42
Observable.create
next: 42
</code></pre>

<p>Just instead of <code>source</code> you'll have your WebSocket source (or whatever you have).</p>
","310726","","","","","2017-06-24 09:32:37","","","","1","","","","CC BY-SA 3.0"
"44738231","1","44739450","","2017-06-24 15:54:56","","0","187","<p>So let's say I have a function that returns an <code>Observable</code> of the object <code>ObjectReturned</code> below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>interface ObjectReturned {
  id: string,
    information: info[],
    anotherObj: AnotherObj[]
}

interface AnotherObj {
  information: info[]
}

interface info {
  name: string
}</code></pre>
</div>
</div>
</p>

<p>Given that <code>ObjectReturned.info[]</code> and <code>AnotherObj.info[]</code> both <strong>always contain only one element each</strong>, how can I use the <code>map</code> operator of <code>Observable</code> to ""flatten"" the <code>info</code> array above so that I can access the returned result (<code>Observable&lt;ObjectReturned&gt;</code>) using <code>objectReturned.name</code> and <code>objectReturned.anotherObj.name</code> directly?</p>
","243302","","243302","","2017-06-24 16:55:12","2017-06-24 18:07:05","Using Observable map operator to flatted an array","<rxjs><observable><rxjs5>","1","2","","","","CC BY-SA 3.0"
"44739450","2","","44738231","2017-06-24 18:07:05","","0","","<pre><code>objectReturned.map( obj =&gt; Object.assign(obj, {name: information[0].name});
</code></pre>

<p>this gives </p>

<pre><code>{
  id: string,
  name: string,
    anotherObj: AnotherObj[]
}
</code></pre>

<p>You can further apply the same to <code>anotherObj</code> too. let me know if this is what you are looking for. </p>
","413418","","","","","2017-06-24 18:07:05","","","","0","","","","CC BY-SA 3.0"
"44743823","1","44743964","","2017-06-25 06:32:03","","17","12069","<p>I am using <code>Rxjs</code> in an <code>angualr-cli</code> application.</p>

<p>in viewer.component.ts </p>

<pre><code>    //Other Imports
    import { Observable } from 'rxjs/Observable';
    //omitting for brevity
   export class ViewerComponent implements OnInit, AfterViewInit, OnDestroy {
    someFunction(someArg){
    //omitting for brevity
    let someArray: any = [];
    //Add some info
    Observable.forkJoin(someArray).subscribe(data =&gt; {
              //Do something with data
            });
    }
    //omitting for brevity
    }  
</code></pre>

<p>I get and error as   </p>

<pre><code>ERROR TypeError: __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__.Observable.forkJoin is not a function
    at ViewerComponent.webpackJsonp../src/app/component/viewer.component.ts.ViewerComponent.someFunction(http://localhost:4200/main.bundle.js:4022:73)
    at http://localhost:4200/main.bundle.js:3951:31
</code></pre>

<p>But if I Import <code>Rxjs</code> completely (<code>import 'rxjs';</code>) everything works. No error.
I cont seem to understand whats additional that needed.
I also tries importing <code>rxjs/Observable/forkjoin</code> but nothing to avail.</p>

<p>Any pointers on how to go about this.</p>
","756987","","756987","","2017-06-25 06:41:03","2020-04-21 10:12:15","Error rxjs_Observable__.Observable.forkJoin is not a function?","<angular><angular-cli><rxjs5><fork-join>","4","4","5","","","CC BY-SA 3.0"
"44743964","2","","44743823","2017-06-25 06:51:27","","30","","<p>As explained <a href=""https://github.com/ReactiveX/RxJS#es6-via-npm"" rel=""noreferrer"">here</a>, you have two options:</p>

<ol>
<li>Either import all operators as a single package</li>
<li>Or import each operator individually</li>
</ol>

<p>In the first case you would use import like this:</p>

<pre><code>import Rx from 'rxjs/Rx';

Rx.Observable.forkJoin(1,2,3)
</code></pre>

<p>In the second like this:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/forkJoin';
</code></pre>

<p>I believe what you're looking for is the second option.</p>
","2545680","","2545680","","2017-06-25 07:05:04","2017-06-25 07:05:04","","","","3","","","","CC BY-SA 3.0"
"44745048","1","","","2017-06-25 09:35:35","","0","96","<p>I have a <code>state</code> object with string keys and values. Events are coming in, containing key-value pairs to change the <code>state</code>.</p>

<p>I need a debounced stream that:</p>

<ul>
<li>validates the events and drop all modifications in the debounce cycle if they lead to an invalid state</li>
<li>outputs the diff to the last valid state</li>
</ul>

<p>For example, for the initial state of <code>{k1: ""v1""}</code>, and an event of <code>{k2: ""v2""}</code>, output <code>{k2: ""v2""}</code>.</p>

<p>But for the events: <code>{k3: ""v3""}</code> and <code>{k4: ""invalid""}</code>, drop both changes. So when a new event <code>{k5: ""v5""}</code> comes in, the <code>k3</code> key is still undefined.</p>

<p>I was able to implement it, but only by using a new Subject that keeps track of the last valid state: (<a href=""https://jsfiddle.net/sashee/oo2ad4eq/1/"" rel=""nofollow noreferrer"">jsfiddle</a>)</p>

<pre class=""lang-js prettyprint-override""><code>const lastValidState = new Rx.Subject();

const res = modifications
  .buffer(debounce)
  .withLatestFrom(lastValidState.startWith(state))
  .map(([mods, last]) =&gt; {
    // calculate next state
    return [Object.assign({}, last, ...mods), last];
  }).filter(([newState]) =&gt; {
    // check new state
    return Object.keys(newState).every((k) =&gt; !newState[k].startsWith(""invalid""));
  // update Subject
  }).do(([newState]) =&gt; lastValidState.next(newState)).share()
  .map(([newState, last]) =&gt; {
    // output diff
    return Object.assign({}, ...Object.keys(newState).filter((k) =&gt; newState[k] !== last[k]).map((k) =&gt; ({[k]: newState[k]})))
  }
)
</code></pre>

<p>This code works well, but I don't like the new Subject it introduces. I would prefer a solution that does not rely on that and use only RxJS operators.</p>

<p>I've tried to use <code>pairwise</code>, but I could not figure out how to pair a stream with the last value of itself.</p>
","2032154","","106909","","2017-07-10 05:48:48","2017-07-10 05:48:48","RxJS incrementally validate a stream of events","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"44752525","1","","","2017-06-26 02:47:54","","3","1509","<h3>Situation</h3>

<p>I was wondering if it was possible to reset the <code>distinctUntilChanged</code> part 
so that it would reaccept a repeated value.</p>

<p>So my situation is, right now I'm using the function like this (shortened greatly as just an example).</p>

<pre><code>    Rx.Observable.fromEvent(textInput, 'keyup')
      .pluck('target','value')
      .filter( (text) =&gt; {
          text = text.trim();
          if (!text.length) // empty input field
          {
              this.setState({ list: [] });
          }
          return text.length &gt; 0;
      })
      .debounceTime(300)
      .distinctUntilChanged()
</code></pre>

<p>So at the very end of this, the results create a series of divs which I can click on, which then changes the value of the input (calls function below).</p>

<pre><code>fill_name(name)
{
  $(""#company_input"").val(name);
  this.setState({ list: [] });
} 
</code></pre>

<p>So if I typed in <code>a</code> in the input, then I delete it all with the backspace and retype a, the observable won't call my function. </p>

<h3>What I want</h3>

<p>I want some way for the <code>fill_name</code> function to reset the <code>distinctUntilChanged</code> part so I can search for <code>a</code> again after clicking on my generated divs.</p>
","6554121","","","","","2017-06-26 04:08:26","Rxjs - Reset distinctuntilchanged","<javascript><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"44757111","1","","","2017-06-26 09:55:52","","5","440","<p>I came across this method in RxJS 4 and it seems quite helpful, however I can't seem to find it anywhere in RxJS 5.</p>

<p><a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/errors.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/errors.md</a></p>

<p>Does anyone know if anything in RxJS 5 does similar behavior?</p>
","142372","","3345644","","2018-08-14 21:40:05","2020-05-29 19:18:44","'mergeDelayError' does not exist in RxJS 5","<rxjs><rxjs5>","1","1","","","","CC BY-SA 4.0"
"44763462","1","44789973","","2017-06-26 15:42:52","","0","311","<p>I am trying to do a ""complexe alert system"" in redux + redux-observable.</p>

<p>The requirement are:</p>

<ul>
<li>an action should request an alert: REQUEST_ALERT</li>
<li>an action should create alert + add an id: SET_ALERT (done in epic)</li>
<li>an alert should be close after 3 s: DISMISS_ALERT (done in epic)</li>
<li>an alert can be close by a user click: DISMISS_ALERT</li>
</ul>

<p>(We could refactor to use directly SET_ALERT Without REQUEST_ALERT directly inside the reducer but this is not the problem here)</p>

<p>I almost achieve my goal with: </p>

<pre><code>// generate the alert from the request
// you can ignore it if refactor with only REQUEST_ALERT
export const generateAlert$ = (action$) =&gt; {
  return action$.ofType(REQUEST_ALERT)
    .map(action =&gt; ({
        type: SET_ALERT,
        payload: generateAlertPayload(), 
        // just create action de type SET_ALERT and add an id 
      })
    )
  }
// the real important part
export const timeoutDismissAlert$ = (action$) =&gt; {
  return action$.ofType(SET_ALERT)
    .mergeMap(action =&gt;
      Rx.Observable.empty()
      .concat(
        // I wait for max delay and send the payload dismiss_alert
        Rx.Observable.of(action)
          .delay(maxDelay)
          .map(({payload}) =&gt; ({type: DISMISS_ALERT, payload: payload.id}))
          // I make a race with the user click vs the delay 
          .race(
            action$.ofType(DISMISS_ALERT)
              .skipWhile(({payload}) =&gt; payload !== action.payload.id)
              .first()
              .map(() =&gt; null)
          )
      )
      // I would like to dispatch an action only if the delay win
      .map((a) =&gt; a ? a : {type: ""I_DONT_WANT""})
    )
  }
</code></pre>

<p>does there is a way to not dispatch an action at the end of an epic ? or better Rxjs way to achieve it ?</p>
","6281070","","6281070","","2017-06-26 15:48:55","2017-06-27 21:48:41","A complex alert system Redux-observable. not dispatch action at the end of an epic","<javascript><rxjs><rxjs5><redux-observable>","1","1","1","","","CC BY-SA 3.0"
"44789973","2","","44763462","2017-06-27 21:12:05","","0","","<p>To me it looks like you just want to ""cancel"" your delayed observable whenever a user clicks, and <code>takeUntil</code> could help with that.</p>

<p>I imagine the desired epic to look something like this:</p>

<pre><code>// action creator
const dismissAlert = payload =&gt; ({ type: DISMISS_ALERT, payload });

// epic
const dismissAlert$ = action$ =&gt; {
    return action$.ofType(SET_ALERT)
        .mergeMap(action =&gt; {
            const dismiss$ = action$.ofType(DISMISS_ALERT)
                .filter(({ payload }) =&gt; payload === action.payload.id);

            // the interesting part
            return Rx.Observable.timer(maxDelay)
                .mapTo(dismissAlert(action.payload.id))
                .takeUntil(dismiss$);
        });
};
</code></pre>

<p>Now the nested observable produces either a single DISMISS_ALERT action or nothing if user clicks before <code>maxDelay</code> interval elapses.</p>
","1463575","","1463575","","2017-06-27 21:48:41","2017-06-27 21:48:41","","","","0","","","","CC BY-SA 3.0"
"44794281","1","44794699","","2017-06-28 05:28:59","","1","141","<p>How do I simplify this sequence, as I seem to be re-creating the pyramid of doom, and there ought to be a more Rx-y way.</p>

<pre><code>public isEligibleForOffers(): Observable&lt;Boolean&gt; {
    return Observable.create((observer) =&gt; {
        this.getAccounts().subscribe(
            (accounts) =&gt; {
                if (!this.accountsAreInCredit(accounts)) {
                    observer.next(false);
                } else {
                    this.getOffers(accounts).subscribe(
                        (data: Offers) =&gt; {
                            let isEligible = (data.eligible &amp;&amp; this.eligibleForAny(data) === true &amp;&amp; this.registeredForAny(data) !== true);
                            observer.next(isEligible);
                        }
                    );
                }
            });
    });
}
</code></pre>

<p>I need to make an XHR call to get a collection of accounts, and if the accounts are in credit, make another XHR call to get current offers, and if the user is eligible for any offer return true otherwise false.</p>

<p>Essentially</p>

<ul>
<li>Make an initial XHR call</li>
<li>When you have the result</li>
<li>Make a 2nd XHR call using the results from the 1st call</li>
<li>When you have the result</li>
<li>Make some final decision.</li>
</ul>

<p>The difference between what I'm asking and what I've seen on SO is twofold: </p>

<ul>
<li>These async operations are in sequence and non-overlapping</li>
<li>The payload from the first response is used in the second</li>
</ul>

<p>Another similar case might be (1) Get a token, then (2) use the token in a subsequent request.</p>
","159806","","","","","2017-06-28 08:50:38","Better way of RxJS Sequence","<angular><sequence><rxjs5>","2","0","","","","CC BY-SA 3.0"
"44794699","2","","44794281","2017-06-28 06:01:32","","0","","<p>If you want to chain the observables, use <code>switchMap</code> or <code>flatMap</code>. Also, you do not need to purposely create another Observables using <code>Observable.create()</code>, since your <code>this.getAccounts()</code> is already returning an observable.</p>

<p>This should be more succinct:</p>

<pre><code>public isEligibleForOffers(): Observable&lt;Boolean&gt; {
    return this.getAccounts().switchMap(accounts =&gt; {
        if (this.accountsAreInCredit(accounts)) {
            return this.getOffers(accounts)
                .map((data: Offers) =&gt; {
                    return (data.eligible &amp;&amp; this.eligibleForAny(data) === true &amp;&amp; this.registeredForAny(data) !== true);
                })
        }
        //you can be explicit by returning a an Observable of false:
        return Obersvable.of(false);
    })
}
</code></pre>

<p>And you can just use it like this:</p>

<pre><code>this.isEligibleForOffers()
    .subscribe(flag =&gt; {
        //flag is a boolean
        if(flag){
            //do something
        }else{
            //do something else
        }
    })
</code></pre>
","2829204","","2829204","","2017-06-28 06:10:31","2017-06-28 06:10:31","","","","0","","","","CC BY-SA 3.0"
"44810195","1","44810196","","2017-06-28 18:38:52","","47","43958","<p>When I compile, I get the following compiler error in the RxJS declaration files:</p>

<pre><code>node_modules/rxjs/Subject.d.ts(16,22): error TS2415: Class 'Subject&lt;T&gt;' incorrectly extends base class 'Observable&lt;T&gt;'.
  Types of property 'lift' are incompatible.
    Type '&lt;R&gt;(operator: Operator&lt;T, R&gt;) =&gt; Observable&lt;T&gt;' is not assignable to type '&lt;R&gt;(operator: Operator&lt;T, R&gt;) =&gt; Observable&lt;R&gt;'.
      Type 'Observable&lt;T&gt;' is not assignable to type 'Observable&lt;R&gt;'.
         Type 'T' is not assignable to type 'R'.
</code></pre>

<p>What's going on here, and how do I get around this without downgrading to TypeScript 2.3 or earlier?</p>
","4386952","","4386952","","2017-06-30 18:46:11","2021-01-11 11:02:58","How do I get around this ""Subject incorrectly extends Observable"" error in TypeScript 2.4 and RxJS 5.x?","<typescript><rxjs><rxjs5><typescript2.4>","9","0","8","","","CC BY-SA 3.0"
"44810196","2","","44810195","2017-06-28 18:38:52","","131","","<h1>Solution</h1>
<p>RxJS 5.4.2 should now work perfectly with TypeScript 2.4.1. <strong>Simply upgrade to 5.4.2+ if possible.</strong></p>
<pre class=""lang-sh prettyprint-override""><code>npm install --save rxjs@^5.4.2
</code></pre>
<p>Then try restarting your editor and/or recompile if you don't see an immediate change.</p>
<p>If not, the below solution should work.</p>
<h1>Why it's happening</h1>
<p>TypeScript 2.4 has a strictness change, and <code>Subject&lt;T&gt;</code> isn't lifting to the correct <code>Observable</code>. The signature really should have been</p>
<pre><code>&lt;R&gt;(operator: Operator&lt;T, R&gt;) =&gt; Observable&lt;R&gt;
</code></pre>
<p>This will be fixed in RxJS 6.</p>
<h1>Alternative Solution</h1>
<p>Newer versions of RxJS will have this fixed, but as a temporary workaround, <strong>you can use the <code>noStrictGenericChecks</code> compiler option.</strong></p>
<p>In <code>tsconfig.json</code>, put it in <code>&quot;compilerOptions&quot;</code> and set it to <code>true</code>.</p>
<pre><code>{
    &quot;compilerOptions&quot;: {
        &quot;noStrictGenericChecks&quot;: true
    }
}
</code></pre>
<p>On the command line it's <code>--noStrictGenericChecks</code>.</p>
","4386952","","4386952","","2021-01-11 11:02:58","2021-01-11 11:02:58","","","","7","","","","CC BY-SA 4.0"
"44814242","1","44816760","","2017-06-28 23:49:58","","1","780","<p>I need to set the <code>currentUser: BehaviorSubject&lt;&gt;()</code> every time the http auth API returns an authorized user. Right now I'm using <code>do</code> to send the new user into the <code>BehaviorSubject</code> but it seems like a dirty way to accomplish such a task.</p>

<p>Is there a fork method or something similar that will update an observer and return the original observable?</p>

<p><strong>What I have</strong></p>

<pre><code>public currentUser: BehaviorSubject&lt;any&gt; = new BehaviorSubject&lt;any&gt;(null);

authUser(email: String, password: String) {
  return this.http.post('api.com/auth', {
    email: email,
    password: password
  })
  .do(user =&gt; this.currentUser.next(user))
}
</code></pre>

<p><strong><em>What I want</em></strong></p>

<pre><code>return this.http.post('api.com/auth', {
  email: email,
  password: password
})
.fork(this.currentUser)
</code></pre>
","580487","","580487","","2017-10-02 01:42:44","2017-10-02 01:42:44","Best method to ""fork"" observable","<angular><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"44816760","2","","44814242","2017-06-29 05:08:14","","1","","<p>There are different ways to tackle this problem but in my opinion you should use <code>subscribe</code> instead of <code>do</code> and <code>authUser</code> should not return anything.  Why have two ways to access the same thing (the current user)?</p>

<pre><code>//private field and getter are optional but allows you to expose the
//field as an observable and not a subject
private _currentUser: BehaviorSubject&lt;any&gt; = new BehaviorSubject&lt;any&gt;(null);

get currentUser(): Observable&lt;any&gt; {
  return this._currentUser;
}

authUser(email: String, password: String): void {
  this.http.post('api.com/auth', {
    email: email,
    password: password
  })
  .subscribe(user =&gt; this._currentUser.next(user))
}
</code></pre>

<p>If you want to do cleanup (it is an asynchronous operation so you may want to know when it is done) you could do:</p>

<pre><code>authUser(email: String, password: String): Observable&lt;void&gt; {
  let requestObs = this.http.post('api.com/auth', {
    email: email,
    password: password
  }).shareReplay();
  requestObs.subscribe(user =&gt; this._currentUser.next(user));
  return requestObs.map(user =&gt; null);
}
</code></pre>

<p>And of course, if you really want the return value you can just drop that last map statement.  In the end it isn't really much different than your <code>do</code>.</p>
","202694","","202694","","2017-07-01 14:07:26","2017-07-01 14:07:26","","","","2","","","","CC BY-SA 3.0"
"44835982","1","44836104","","2017-06-29 22:35:36","","0","1719","<p>In my Angular application I need to make a http call in regular intervals of time (say every y mins) as long as the page is active and render the response on the screen.</p>

<p>Is it good to use <code>NodeJS.Timer</code> object to implement <code>setTimeout()</code></p>

<p>or use <code>Observable.timer()</code>.</p>
","8234311","","183704","","2020-06-17 12:07:07","2020-06-17 12:07:07","can we use node js timer object in angular 4?","<node.js><angular><rxjs><rxjs5>","2","5","","","","CC BY-SA 4.0"
"44836104","2","","44835982","2017-06-29 22:47:36","","1","","<p><code>Observable.timer()</code> is a lot more useful for Angular</p>

<p>for example:</p>

<pre><code> const tick3$ = Observable.timer(100, 60000);
</code></pre>
","6018581","","183704","","2020-06-17 12:04:57","2020-06-17 12:04:57","","","","0","","","","CC BY-SA 4.0"
"44858962","1","44914069","","2017-07-01 08:35:49","","2","83","<p>I am trying to get the last 3 values emitted, with the code bellow I am expecting that after populating uiOrder and calling cancelOrderItem() for few times I can get access to last 3 revisions of the order with getHistory(), but I am actually getting the last (current) value 3 times, i have tried replaySubject(3) with the same results.
this is my code:</p>

<pre><code>export class OrdersService {

  public readonly orders: Observable&lt;Order[]&gt;;
  public readonly uiOrder: Observable&lt;Order&gt;;

  private _orders: BehaviorSubject&lt;Order[]&gt;;
  private _uiOrder: BehaviorSubject&lt;Order&gt;;

  private dataStore: {
    uiOrder: Order,
    orders: Order[]
 };


  constructor() {

    this.dataStore = {
      uiOrder: null,
      orders: []
    };

    this._orders = &lt;BehaviorSubject&lt;Order[]&gt;&gt;new BehaviorSubject([]);
    this._uiOrder = &lt;BehaviorSubject&lt;Order&gt;&gt;new BehaviorSubject({});
    this.orders = this._orders.asObservable();
    this.uiOrder = this._uiOrder.asObservable();
  }

  getOrder(orderId: number | string) {
    for (let i = 0; i &lt; this.dataStore.orders.length; i++) {
      if (this.dataStore.orders[i].id == orderId) {
        this.dataStore.orders[i].lastAccess = moment().format().slice(0, 19) + 'Z';
        this.dataStore.uiOrder = this.dataStore.orders[i];
        this.updateUiOrder();
      }
    }
  }


  cancelOrderItem(action) {
    this.dataStore.uiOrder.sections[action.sectionIndex].orderDetails.splice(action.orderDetailsIndex, 1);
    this.updateUiOrder()
  }

  getHistory() {
    this.uiOrder.take(3).subscribe((res) =&gt; {
      console.log('uiOrder', res);
    }).unsubscribe()
  }

  updateUiOrder() {
    console.log('updating ui order');
    this._uiOrder.next(this.dataStore.uiOrder);
  }

}
</code></pre>

<p>what am I doing wrong?</p>
","7350291","","","","","2017-07-05 07:30:39","Rx.js can't get past values","<angular><typescript><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"44863248","1","44875060","","2017-07-01 16:40:25","","1","151","<p>I've read an <a href=""https://netbasal.com/angular-stop-using-observable-when-you-should-use-a-promise-8da0788a8d2"" rel=""nofollow noreferrer""><em>article</em></a> which shows an example of 3 async subscriptions  to an HTTP request.</p>

<pre><code>@Component({
  selector: 'my-app',
  template: `
    &lt;div&gt;
      &lt;p&gt;{{ (person | async)?.id   }}&lt;/p&gt;
      &lt;p&gt;{{ (person | async)?.title   }}&lt;/p&gt;
      &lt;p&gt;{{ (person | async)?.body   }}&lt;/p&gt;
    &lt;/div&gt;
  `,
})
export class App {
  constructor(public http: Http) {
    this.person = this.http.get('https://jsonplaceholder.typicode.com/posts/1')
     .map(res =&gt; res.json())
  }
}
</code></pre>

<p><em>I already know that there is no need for an async here and that ReplaySubject can be used and that there are many other solutions , but that's not what I'm after.</em></p>

<p>The author said that  : </p>

<blockquote>
  <p>The current solution that people suggest:</p>
  
  <p><code>this.http.get('https://jsonplaceholder.typicode.com/posts/1')
       .map(res =&gt; res.json()).share()</code> ( which is <code>publish().refCount().</code>)</p>
</blockquote>

<p><strong>Question:</strong></p>

<p>But re-thinking about <code>publish().refCount()</code> -  is it possible that (for some reason) :</p>

<ul>
<li><p>The first <code>(person | async)</code> has executed the request (refcount=1) and response came back <em>before(!)</em> the last two <code>(person | async)</code>'s  subscribed? - this will cause another http request(s) ?  I mean  - who guarantees that the 3 subscriptions will be available <em>concurrently</em> so that they will all share the same result? is there a possibility for race condition? <em>because i've heard that refcount() is subject to race condition.</em></p></li>
<li><p>Besides , When is it considered to be ""<code>refcount()&gt;0</code>"" ? it that value checked when http is <em>being invoked</em> or is it being checked when response arrives ?</p></li>
</ul>

<p>In other words -    </p>

<p><code>sub1</code> causes <code>refcount()=1</code> (invoking http). But meanwhile <code>sub2</code>( a second subscription) is made :</p>

<pre><code>  sub1 âââââââAâââââ&gt; http invoked    
   &lt;âââââââââBâââââââresponse
</code></pre>

<p>Looking at <code>A</code> &amp; <code>B</code> stages : </p>

<p>When will <code>refcount()</code> will be <code>2</code> ? is it on stage  <code>A</code>  ( before/while http executed) or will subscriptions at stage <code>B</code> will also be considered as <code>refcount()=2</code> ?</p>
","859154","","859154","","2017-07-01 16:58:15","2017-07-02 20:51:50","Angular - Possible Race Condition with - `publish().refCount()`?","<javascript><angular><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"44873641","1","44873723","","2017-07-02 17:52:44","","2","670","<p>I have a function with the following signature:</p>

<p><code>fetchUserCar(userId: string): Observable&lt;Car&gt;</code></p>

<p>But to get the <code>userId</code> parameter, I have to call a function that I cannot edit, which is the following:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>private user$ = new ReplaySubject &lt; User &gt; ();
public getUser(): Observable &lt; User &gt; {
  return this.user$.asObservable().share();
}</code></pre>
</div>
</div>
</p>

<p>How do I go about in doing this?</p>
","243302","","","","","2017-07-02 18:02:13","Providing a parameter from an Observable to a function that returns an Observable","<angular><rxjs><observable><rxjs5><behaviorsubject>","1","0","","","","CC BY-SA 3.0"
"44873723","2","","44873641","2017-07-02 18:02:13","","4","","<p>You need to call <code>getUser()</code> and then <code>flatMap</code> the call to <code>fetchUserCar</code> passing the user id obtained from <code>getUser()</code>.</p>

<pre><code>fetchCar(): Observable&lt;Car&gt; {
    this.userService.getUser()
        .flatMap(user =&gt; this.carService.fetchUserCar(user.id))
}
</code></pre>
","71245","","","","","2017-07-02 18:02:13","","","","0","","","","CC BY-SA 3.0"
"44875060","2","","44863248","2017-07-02 20:45:50","","1","","<p>That's an interesting question indeed. But I think there are no race condition involved in this piece of code. </p>

<p>The thing is, all the subscription are done <strong>synchronously</strong> in the template with the <code>async</code> function. 
Which means, the request will be fired when the first subscription is done indeed, but in the case the server respond before all the other subscriptions are done (if it is even possible), then the main thread will be occupied thus not firing another request when the next <code>subscribe</code> arrives.</p>

<p>Here is a little example I made that tries to reproduce that use case. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const timer = Rx.Observable.of(""value"")
  .do(() =&gt; console.log(""start request""))
  .delay(1)
  .do(() =&gt; console.log(""end request""))
  .publish().refCount()

console.time(""sub"");
for (var i=0; i &lt; 10; i++) {
  console.log(""subscribe"" + i)
  timer.subscribe()
}
console.timeEnd(""sub"")</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Here I simulate a request that is responded in <code>1ms</code> by the server but all the subscriptions take (on my computer at least) around <code>10ms</code> to complete. So you could say that the response arrives before the subscriptions are all done.</p>

<p>As you can see in the log, the request is fired only once :)</p>
","2745879","","2745879","","2017-07-02 20:51:50","2017-07-02 20:51:50","","","","4","","","","CC BY-SA 3.0"
"44887844","1","44893077","","2017-07-03 14:15:12","","11","1343","<p>I have a use case where I need an Observable to skip its next emission whenever another notifier Observable emits.</p>

<pre><code>source:    |---X---X---X---X---X---X---X---X---X---X--|&gt;
notifier:  |-------------X---------X----------X-------|&gt;
result:    |---X---X---X-------X---X-------X-------X--|&gt;
</code></pre>

<p>Basically, I want an operator called <code>skipNextWhen</code> that takes in the notifier observable and skips the next emission from the source.</p>

<p>I tried using an implementation that uses the <code>pausable</code> operator (re-implemented using <code>switchMap</code>), but couldn't get it to work.</p>

<p><strong>pausable.ts</strong></p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/observable/never';
import 'rxjs/add/operator/startWith';

declare module 'rxjs/Observable' {
    interface Observable&lt;T&gt; {
        pausable: typeof pausable;
    }
}

function pausable&lt;T&gt;(notifier: Observable&lt;boolean&gt;): Observable&lt;T&gt; {
    return notifier.startWith(false).switchMap((paused) =&gt; {
        if (paused) {
            return Observable.never();
        } else {
            const source = new Subject();
            this.subscribe(source);
            return source;
        }
    });
}

Observable.prototype.pausable = pausable;
</code></pre>

<p><strong>skipNextWhen.ts</strong></p>

<pre><code>import { Observable } from 'rxjs/Observable';
import './pausable';

declare module 'rxjs/Observable' {
    interface Observable&lt;T&gt; {
        skipNextWhen: typeof skipNextWhen;
    }
}

function skipNextWhen&lt;T, R&gt;(other: Observable&lt;T&gt;): Observable&lt;R&gt; {
    const notifier = Observable.merge(this.map(() =&gt; false), 
                                      other.map(() =&gt; true));
    return this.pausable(notifier);
}

Observable.prototype.skipNextWhen = skipNextWhen;
</code></pre>

<p>Is there a more suitable operator that I should consider using instead? The behavior I'm seeing with my current implementation is that the result Observable emits once, and then never again - even if the notifier Observable never emits.</p>
","1789939","","310726","","2017-07-03 19:57:14","2019-03-17 18:56:01","Operator that skips the next emission from the source whenever another Observable emits","<rxjs><reactive-programming><rxjs5>","2","2","","","","CC BY-SA 3.0"
"44893077","2","","44887844","2017-07-03 19:56:56","","6","","<p>I can think of two solutions to this:</p>

<ol>
<li><p>Using <code>.filter()</code>, <code>.do()</code> and a few side-effects.</p>

<p>This is mayne easier to understand solution even though it's not that ""Rx"" way:</p>

<pre><code>function skipNextWhen(other) {
    let skipNext = false;

    return this.merge(other.do(() =&gt; skipNext = true).filter(() =&gt; false))
        .filter(val =&gt; {
            const doSkip = skipNext;
            skipNext = false;
            return !doSkip;
        });
}
</code></pre>

<p>I'm using <code>merge()</code> just to update <code>skipNext</code>, <code>other</code>'s value is always ignored.</p></li>
<li><p>Using <code>.scan()</code>:</p>

<p>This solution is without any state variables and side-effects.</p>

<pre><code>function skipNextWhen(other) {
    const SKIP = 'skip';

    return this.merge(other.mapTo(SKIP))
        .scan((acc, val) =&gt; {
            if (acc === SKIP) {
                return null;
            } else if (val === SKIP) {
                return SKIP;
            } else {
                return val;
            }
        }, [])
        .filter(val =&gt; Boolean(val) &amp;&amp; val !== SKIP);
}
</code></pre>

<p>Basically, when <code>SKIP</code> arrives I return it right away because it's going to be passed again in <code>acc</code> parameter by the <code>scan()</code> operator and later ignored by <code>filter()</code>.</p>

<p>If I receive a normal value but the previous value was <code>SKIP</code> I ignore it and return just <code>null</code> which is later filter away.</p></li>
</ol>

<p>Both solutions give the same result:</p>

<pre><code>Observable.prototype.skipNextWhen = skipNextWhen;

const source = Observable.range(1, 10)
    .concatMap(val =&gt; Observable.of(val).delay(100));

source
    .skipNextWhen(Observable.interval(350))
    .subscribe(console.log);
</code></pre>

<p>This prints the following:</p>

<pre><code>1
2
3
5
6
8
9
10
</code></pre>

<p>Just be aware that you're not in fact creating new operator. You just have a shortcut for an operator chain. This for example doesn't let you unsubscribe from <code>other</code> when the source completes.</p>
","310726","","","","","2017-07-03 19:56:56","","","","0","","","","CC BY-SA 3.0"
"44900744","1","44968913","","2017-07-04 08:25:27","","7","3940","<p>I have a complex object having child objects and arrays and so on.</p>

<p>I can easily create a Subject/BehaviourSubject or Observable from this object so that I can ""next"" (emit) the new state to the subscribers.</p>

<p>[ex: <code>let appEnv$ = new Rx.BehaviorSubject&lt;IWebSocketAppEnv&gt;(appEnv);</code>]</p>

<p>However I don't want all my subscribers to be notified every time the object changes. For instance for one of my subscriber, I only want to be notified when a change occurs on an elements of an array of that object.</p>

<p>Actually what I want is something redux is already doing. In redux, I can subscribe to the store but selecting only a child element.</p>

<p>I want to implement the same infrastructure for my back-end websocket server application.</p>

<p>How can I achieve that with RxJS?</p>
","5043925","","6599814","","2017-07-11 14:38:28","2017-07-11 14:38:28","RxJS Observable: Emit when specific part of the object changes","<rxjs><rxjs5>","2","5","3","","","CC BY-SA 3.0"
"44914069","2","","44858962","2017-07-04 21:13:44","","3","","<p>The operator you are looking for is <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-bufferCount"" rel=""nofollow noreferrer""><code>bufferCount(3,1)</code></a> which creates a sliding window of the last 3 values emitted. Downside: it will only start emitting after 3 values have been accumulated. If you want to have the first value you can do something like this:</p>

<pre><code>Rx.Observable.from([null,null])
  .concat(this.uiOrder)
  .bufferCount(3,1)
  .subscribe(uiOrderHistory =&gt; ... );
</code></pre>

<p>That way your marble diagram will look as follows:</p>

<pre><code>---Order1-----------------Order2--------------------Order3
bufferCount(3,1)
---[null,null,Order1]-----[null,Order1,Order2]------[Order1,Order2,Order3]
</code></pre>
","106909","","106909","","2017-07-05 07:30:39","2017-07-05 07:30:39","","","","0","","","","CC BY-SA 3.0"
"44950351","1","44951756","","2017-07-06 13:28:14","","2","6106","<p>I'm trying to detect when all my observables have completed. I have the following Observables:</p>

<pre class=""lang-js prettyprint-override""><code>let observables:any[] = [];
if(valid){
    observables.push(new Observable((observer:any) =&gt; {
        async(()=&gt;{
            observer.next();
            observer.complete();
        })
    }))
}
if(confirmed){
    observables.push(new Observable((observer:any) =&gt; {
        async(()=&gt;{
            observer.next();
            observer.complete();
        })
    }))
}

Observable.forkJoin(observables).subscribe(
    data =&gt; {
        console.log('all completed');
    },
    error =&gt; {
        console.log(error);
    }
);
</code></pre>

<p>I need to do something whenever all my functions are completed. Forkjoin seems to work when the <code>observables</code> array is not empty. But when the array is empty, it never gets called. How can I solve this?</p>
","276439","","106909","","2017-07-10 05:40:24","2019-11-28 07:19:13","Forkjoin with empty (or not) array of observables","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"44951756","2","","44950351","2017-07-06 14:27:44","","11","","<p>you are missing the 3rd callback in subscribe. try this:</p>

<pre class=""lang-js prettyprint-override""><code>Rx.Observable.forkJoin([]).subscribe(
    val =&gt; {
        console.log('next');
    },
    err =&gt; {
        console.log('err');
    },
    () =&gt; {
        console.log('complete')
    }
);
</code></pre>

<p>forkJoin on empty array completes immediately.</p>

<p><strong>Updated for RxJS 6:</strong></p>

<pre><code>  let rep: Observable&lt;any&gt;[] = [];

  for (let i = 0; i &lt; areas.length; i++) { // undetermined array length
      rep.push(this.httpService.GET('/areas/' + areas[i].name)); // example observable's being pushed to array
  }
  if (rep !== []) {
    forkJoin(rep).subscribe(({
      next: value =&gt; {
        console.log(value)
      }
    }));
  }
</code></pre>
","3794100","","8413584","","2019-11-28 07:19:13","2019-11-28 07:19:13","","","","2","","","","CC BY-SA 4.0"
"44968913","2","","44900744","2017-07-07 10:48:23","","12","","<p>Use <strong>distinctUntilChanged</strong> operator. <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-distinctUntilChanged"" rel=""noreferrer"">(docs)</a></p>

<p>Let's assume that the object's structure is:</p>

<pre><code>{
  articleId: 0,
  comments: [ 'lorem', 'ipsum' ]
}
</code></pre>

<p>We want to be as cool as firebase guys so we'll update comments in real-time when the updated object has a different array.</p>

<p>I'm using <code>RxJS5</code> for observables and <code>lodash</code> to compare arrays because operator's default behavior won't compare them in the way we want them to be compared.</p>

<pre><code>// Our BehaviorSubject which emits new object.
// For those who don't know: it'll emit the latest emitted value when subscribing to it.
const object$ = new Rx.BehaviorSubject({
  articleId: 0,
  comments: [],
}); 

// If you want specific parts of your application 
// to react only when a specific part of the object has changed, you 
// have to create another observable using 'map' and 
// 'distinctUntilChanged' operator and subscribe to it.
const comments$ = object$
  .map(object =&gt; object.comments) // we want to emit comments only
  .distinctUntilChanged((a, b) =&gt; _.isEqual(a, b)); // emit only when currently emitted value is different than previous one.

comments$.subscribe(v =&gt; console.log(v)); // log fresh comments

object$.next({
  articleId: 1,
  comments: [],
});

object$.next({
  articleId: 1,
  comments: ['lorem', 'ipsum'],
});

object$.next({
  articleId: 2,
  comments: ['lorem', 'ipsum'],
});

object$.next({
  articleId: 2,
  comments: ['lorem', 'ipsum', 'dolor', 'sit', 'amet'],
});
</code></pre>

<p>effect:</p>

<pre><code>[]
[""lorem"", ""ipsum""]
[""lorem"", ""ipsum"", ""dolor"", ""sit"", ""amet""]
</code></pre>

<p>effect without <code>distinctUntilChanged</code> operator:</p>

<pre><code>[]
[]
[""lorem"", ""ipsum""]
[""lorem"", ""ipsum""]
[""lorem"", ""ipsum"", ""dolor"", ""sit"", ""amet""]
</code></pre>

<p><a href=""https://jsfiddle.net/MichalCafe/rkgkewpt/1/"" rel=""noreferrer""><strong><em>JSFiddle</em></strong></a></p>
","6599814","","6599814","","2017-07-10 18:25:57","2017-07-10 18:25:57","","","","3","","","","CC BY-SA 3.0"
"44984327","1","","","2017-07-08 08:49:22","","0","205","<p>I'm learning Observables and trying to implement a service for login validation.
Dummy data is like this</p>

<pre class=""lang-js prettyprint-override""><code>export class Users {
  public users: IUser[] = [];

  constructor() {
    this.users = [
      new IUser({ username: ""protagonist"", password: ""hello123"" }),
      new IUser({ username: ""rono67"", password: ""!@vioped"" }),
      new IUser({ username: ""donaldtrump"", password: ""melenia@34"" })          
    ];
  }
</code></pre>

<p>and structure of IUser is like this.</p>

<pre class=""lang-js prettyprint-override""><code>export class IUser {
    usename:string;
    password:string;
}
</code></pre>

<p>I'm passing the entered username and password to the service class and I want to have an observable call which traverse through the dummy data and if it finds the matching credentials, it shall return it. I do not want to make any HTTP call. Method is something like this-</p>

<pre><code> validLogin(accountInfo: IUser): Observable&lt;IUser&gt; {
        return ---------
          .map((user:IUser) =&gt; user.filter((user:IUser) =&gt; user.usernanme == accountInfo.username &amp;&amp; user.password == accountInfo.password);
      }
</code></pre>

<p>I'm not sure what piece of code needs to be written in the place of return ------. All of the results which I got in the web are implementing ""return this.http.post""</p>

<p>Is it possible to apply RxJs on mock data? Kindly suggest.</p>
","5327791","","106909","","2017-07-10 08:01:34","2017-07-10 08:01:34","Observables: Validate dummy data from a mock class without http","<angular><rxjs><observable><rxjs5>","2","2","","","","CC BY-SA 3.0"
"45001179","1","45001399","","2017-07-09 21:26:02","","2","1043","<p>My Angular 4 / TypeScript 2.3 service has a function <code>build()</code> that errors if a class property isn't initialized. I'm trying to build a safer version -- <code>safeBuild()</code> -- that will return an Observable that will wait and listen for the property to be initialized before trying to call <code>build()</code></p>
<pre><code>export class BuildService {
  
  renderer:Renderer2; // must be set for build() below to work
  
  // emits the new Renderer2 when renderer is set
  private rendererSet$:BehaviorSubject&lt;Renderer2&gt; = new BehaviorSubject(null);

  /** Set renderer, and notify any listener */
  setRenderer(renderer:Renderer2){
    this.renderer = renderer;
    this.rendererSet$.next(renderer);
  }

  /** Returns a new DOM element. Requires renderer to be set */
  build(elemTag:string){
    // if renderer is not set, we can't proceed
    // why is this error thrown when safeBuild() is called?
    if (!this.renderer) 
      throw new Error('Renderer must be set before build() is run');

    return this.renderer.createElement(elemTag);
  }

  /**
   * A safe version of build(). Will wait until renderer is set
   * before attempting to call build (Asynchronous)
   */
  safeBuild(elemTag:string):Observable&lt;any&gt; {
    // inform user that renderer should be set
    // this warning is printed to the console as expected
    if (!this.renderer) 
      console.warn('The build will be delayed until setRenderer() is called');

    // Listen to rendererSet$, filter out the null output, and call build()
    // only once the renderer is set. Why does the error still get thrown?
    return Observable.concat(
      this.rendererSet$.filter(e=&gt;!!e).take(1),
      Observable.of(this.build(elemTag))
    )
  }
}
</code></pre>
<p>I try to build like this (from another service):</p>
<pre><code>this.buildService.safeBuild(elemTag).subscribe(...)
</code></pre>
<p>In the console I see:</p>
<blockquote>
<p>Warn: The build will be delayed until setRenderer() is called</p>
<p>Error: Renderer must be set before build() is run</p>
</blockquote>
<p>I expected the warning, but then nothing to happen until another part of my app calls <code>setRenderer()</code>. At that point, the code in <code>subscribe()</code> would run.</p>
<p>Why do I see the error?</p>
","3977061","","-1","","2020-06-20 09:12:55","2017-07-09 22:00:55","Angular 4 and RxJS 5: Observable.concat() behaving unexpectedly","<angular><typescript><rxjs5>","2","9","1","","","CC BY-SA 3.0"
"45001399","2","","45001179","2017-07-09 21:54:57","","3","","

<p>The problem is that <code>this.build(elemTag)</code> is called when composing the <code>concat</code> observable - not when the concatenation is performed.</p>

<p>You could solve the problem using <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-defer"" rel=""nofollow noreferrer""><code>defer</code></a>:</p>

<pre><code>import 'rxjs/add/observable/defer';

...
return Observable.concat(
  this.rendererSet$.filter(e =&gt; !!e).take(1),
  Observable.defer(() =&gt; Observable.of(this.build(elemTag)))
);
</code></pre>

<p>Or, as pointed out in the comments, using <code>map</code>:</p>

<pre><code>return this.rendererSet$
  .filter(e =&gt; !!e)
  .take(1)
  .map(() =&gt; this.build(elemTag));
</code></pre>
","6680611","","6680611","","2017-07-09 22:00:55","2017-07-09 22:00:55","","","","3","","","","CC BY-SA 3.0"
"45020250","1","45020854","","2017-07-10 19:34:58","","2","903","<p>In our angular 4.2.4 application, we use RxJS's <code>Observable.forkJoin</code> in a number of places to return heterogeneous types.</p>

<p>For example:</p>

<pre><code>private fleet: Aircraft[];
private contractList: string[];

Observable.forkJoin([
  this.fleetService.getFleet(),
  this.fleetService.getContractList()
]).subscribe(
  next =&gt; {
    this.fleet = results[0];
    this.contractList = results[1];
  },
  error =&gt; console.error
);
</code></pre>

<p>with the following service signatures:</p>

<pre><code>getFleet(): Observable&lt;Aircraft[]&gt; { ... }
getContractList(): Observable&lt;string[]&gt; { ... }
</code></pre>

<p><strong>After updating to TypeScript 2.4.1</strong>, <code>tsc</code> now complains with the following errors for <code>this.contractList</code>:</p>

<blockquote>
  <p>ERROR in ./app/fleet/fleetComponent.ts (xx,xx):
  error TS2322: Type 'Aircraft[]' is not assignable to type 'string[]'.</p>
</blockquote>

<p>But I'm not trying to assign an <code>Aircraft[]</code> to a <code>string[]</code>.</p>

<p>The same is true for <em>all</em> the other <code>Observable.forkJoin</code> we implement: all elements in <code>result[]</code> are treated as though they were the same type as <code>result[0]</code>.</p>

<p>It seems very similar to the problem in <a href=""https://stackoverflow.com/questions/44938803/error-with-actions-observable-in-ngrx-effects-using-typescript-2-4-1"">Error with Actions observable in @ngrx/effects using TypeScript 2.4.1</a> but adding <code>""noStrictGenericChecks"": true,</code> to tsconfig.js' <code>""compilerOptions""</code> did not solve the problem.</p>

<p>Why is this happening? How can I fix this?</p>
","114900","","114900","","2017-07-10 20:09:17","2017-11-29 18:14:45","Observable.forkJoin() TS2322 error after updating to TypeScript 2.4.1 and Rxjs 5.4.2","<typescript><rxjs5><typescript2.4>","2","0","","","","CC BY-SA 3.0"
"45020854","2","","45020250","2017-07-10 20:16:16","","7","","<p>You are probably seeing the increased enforcement from the Typescript compiler on generics, the side-effect being that forkJoin doesn't have a <code>tuple</code> overloads.</p>

<p>Removing the array notation from the parameter list to <code>forkJoin</code> should work, however:</p>

<pre><code>Observable.forkJoin(
  this.fleetService.getFleet(),
  this.fleetService.getContractList()
).subscribe(
  next =&gt; {
    this.fleet = results[0];
    this.contractList = results[1];
  },
  error =&gt; console.error
);
</code></pre>
","400771","","114900","","2017-07-10 20:27:13","2017-07-10 20:27:13","","","","1","","","","CC BY-SA 3.0"
"45033791","1","45041838","","2017-07-11 11:51:08","","4","1805","<p>For example let's say I want to make some api calls.  The api I'm dealing with is prone to race conditions so if I make 3 api calls at the same time updating the same piece of data on the server, it could lose some of the data.</p>

<p>Therefore I want to queue up my requests and then fire one off wait for the response to come back before firing the next request.</p>

<p>Basically I need something like concatMap but the problem with concatMap is that it fires all the requests at the same time.  I need concatMap to just wait before firing off the next request.  I'm using rxjs 5.</p>

<p>Here's a plunker using angular2 where you can click buttons.  When you click 1 sec button an observable will get created that returns after 1 second.  There's 2 sec and 3 sec buttons.  </p>

<p><a href=""https://plnkr.co/edit/6F4JrVueQX8PjPinZqIk?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/6F4JrVueQX8PjPinZqIk?p=preview</a></p>

<pre><code>@Component({
  selector: 'my-app',
  template: `
    &lt;div&gt;
      &lt;h2&gt;Wait:&lt;/h2&gt;

      &lt;button (click)=""start(1)""&gt;1 sec&lt;/button&gt;
      &lt;button (click)=""start(2)""&gt;2 sec&lt;/button&gt;
      &lt;button (click)=""start(3)""&gt;3 sec&lt;/button&gt;
    &lt;/div&gt;
  `,
})
export class App {


  constructor() {
  }

  start(wait) {

    const waitSecs = parseInt(wait) * 1000;

    of('clicked').delay(waitSecs).subscribe(
      val =&gt; console.log(wait)  
    )

    // Expected behavior:
    // I click 3 sec, 2 sec, and 1 sec right after another.  Then 
    // the console log should output 3, 2, 1.  Right now it's 
    // outputting 1, 2, 3.

  }
}
</code></pre>

<p>My ideal behavior with this app would be after I click 3 sec, 2 sec, and 1 sec right after another.  Then the console should output 3, 2, 1.  Right now it's 
outputting 1, 2, 3.</p>
","4872449","","4872449","","2017-07-11 15:01:49","2017-07-11 20:17:01","What rxjs operator is like concatmap but waits for each request before firing the next?","<angular><rxjs><rxjs5>","2","1","2","","","CC BY-SA 3.0"
"45041838","2","","45033791","2017-07-11 18:13:54","","5","","<p>Since you want to have only request executing you can use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer""><code>mergeMap()</code></a> operator with the <code>concurrency</code> set to 1. Note that this will mean that to-be-send items will queue up inside your mergeMap operator which can lead to memory issues.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Rx.Observable.from([3,5,2,1])
  .mergeMap(
    i =&gt; {
      return Rx.Observable.of(i)
        .do(i =&gt; console.log(`starting request for ${i}`))
        .delay(1000)
        .do(null,null, () =&gt; console.log(`finished request for ${i}`));
    },
    null,
    1 /* concurrency limited to 1 */
  )
  .subscribe(val =&gt; console.log(`received value: ${val}`));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","106909","","106909","","2017-07-11 20:17:01","2017-07-11 20:17:01","","","","1","","","","CC BY-SA 3.0"
"45079535","1","","","2017-07-13 11:39:18","","2","360","<p>I am trying to do unit testing in RxJS 5 and I am completely unable to do so from what is explained in the documentation. I also tried to fallback on RxJS 4 which didn't work either since the <code>defer</code> operator doesn't take a scheduler.</p>

<p>How would I go about testing the following case:</p>

<pre><code>// a.js

module.exports = Rx.Observable.defer(() =&gt; Promise.resolve('test'))

// b.js

const a = require('a')

module.exports = a().repeatWhen(notifications =&gt; notifications.delay(5000))
</code></pre>

<p>I am trying to test both files.</p>

<p>Note: the real implementation of <code>a</code> doesn't always return the same value</p>
","5477963","","","","","2017-07-13 11:39:18","How to actually do unit testing in RxJS 5?","<unit-testing><rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"45089976","1","45090069","","2017-07-13 20:02:48","","1","3149","<p>Experts, please tell me how to make sure that asynchronous initialization in the service constructor is complete when calling other functions in the class?</p>

<pre><code>  constructor() {
    var sock = new SockJS(this._chatUrl);
    this.stompClient = Stomp.over(sock);
    this.stompClient.connect({}, function () {
    });
  }

  public subscribe(topicName: string, messageReceived) {
    this.stompClient.subscribe('/topic/' + topicName, function (message) {
      messageReceived(message);
    })
  }

  public sendMessage(msgDestId: string, message) {
    this.stompClient.send(""/app/"" + msgDestId, {}, JSON.stringify(message));
  }
</code></pre>

<p>As you can see, the connection to the stomp-server is established in the constructor. After that, customers (components) of this service are invited to subscribe to topics of interest. Naturally, the call to the subscribe function does not make sense until the connection is fully established.</p>

<p><strong>Update:</strong>
It is also important to keep .connect method called only once. Otherwise it creates two connections.</p>
","6569662","","6569662","","2017-07-14 05:38:07","2017-07-14 05:38:07","How can I ensure that async initialization in the Angular service constructor is completed?","<javascript><angular><typescript><asynchronous><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"45090069","2","","45089976","2017-07-13 20:09:48","","6","","<p>Make every interaction with the stomp client through a promise, e.g.:</p>

<pre><code>constructor() {
    ...
    this.stomp = new Promise(resolve =&gt; {
        stompClient.connect({}, () =&gt; resolve(stompClient));
    });
}

subscribe(...) {
    this.stomp.then(stompClient =&gt; stompClient.subscribe(...));
}
</code></pre>
","476","","","","","2017-07-13 20:09:48","","","","5","","","","CC BY-SA 3.0"
"45121280","1","45171586","","2017-07-15 18:06:54","","3","784","<p>I have a problem with redux-observables. In my situation one epic wait for ending of another epic. The second epic can make a request or return data from the cache. 
When second makes the request all work as expected, but when it returns cache the first one doesn't continue.</p>

<pre><code>const { Observable } = Rx;

const FETCH_USER = 'FETCH_USER';
const FETCH_USER_FULFILLED = 'FETCH_USER_FULFILLED';
const FETCH_USER2 = 'FETCH_USER2';
const FETCH_USER_FULFILLED2 = 'FETCH_USER_FULFILLED2';
const FETCH_USER_REJECTED = 'FETCH_USER_REJECTED';
const FETCH_USER_CANCELLED = 'FETCH_USER_CANCELLED';

const fetchUser = id =&gt; ({ type: FETCH_USER, payload: id });
const fetchUserFulfilled = payload =&gt; ({ type: FETCH_USER_FULFILLED, payload });
const fetchUser2 = id =&gt; ({ type: FETCH_USER2, payload: id });
const fetchUserFulfilled2 = payload =&gt; ({ type: FETCH_USER_FULFILLED2, payload });
const cancelFetchUser = () =&gt; ({ type: FETCH_USER_CANCELLED });

let isFetchced = false;

const fakeAjax = url =&gt;
  Observable.of({
    id: url.substring(url.lastIndexOf('/') + 1),
    firstName: 'Bilbo',
    lastName: 'Baggins'
  }).delay(1000);

const fakeAjax2 = url =&gt;
  Observable.of({
    id: url.substring(url.lastIndexOf('/2') + 1),
    firstName: 'Bilbo2',
    lastName: 'Baggins2'
  }).delay(1000);

const fetchUserEpic = (action$, store) =&gt;
  action$.ofType(FETCH_USER)
    .mergeMap(action =&gt; {
      const observable = isFetchced ? Observable.of({
        id: 2,
        firstName: 'Bilbo',
        lastName: 'Baggins'
      }) : fakeAjax(`/api/users/${action.payload}`);
      isFetchced = true;
      console.log(action);
      return observable
        .map(response =&gt; fetchUserFulfilled(response))
        .takeUntil(action$.ofType(FETCH_USER_CANCELLED))
    });

const fetchUserEpic2 = action$ =&gt;
  action$.ofType(FETCH_USER2)
    .switchMap(() =&gt; action$.ofType(FETCH_USER_FULFILLED)
               .take(1)
    .mergeMap(() =&gt; {
        console.log(""First epic"");
        return fakeAjax2(`/api/users/${1}`)
            .map(response =&gt; fetchUserFulfilled2(response))
    }).startWith(fetchUser('redux-observable')));

const users = (state = {}, action) =&gt; {
  switch (action.type) {
    case FETCH_USER_FULFILLED:
      return {
        ...state,
        [action.payload.id]: action.payload
      };

    default:
      return state;
  }
};

const isFetchingUser = (state = false, action) =&gt; {
  switch (action.type) {
    case FETCH_USER:
      return true;

    case FETCH_USER_FULFILLED:
    case FETCH_USER_CANCELLED:
      return false;

    default:
      return state;
  }
};
</code></pre>

<p>Here is emulation <a href=""https://jsbin.com/qitutixuqu/1/edit?html,css,js,console,output"" rel=""nofollow noreferrer"">https://jsbin.com/qitutixuqu/1/edit?html,css,js,console,output</a>. After clicking on the button ""Fetch user info"" in the console you can see ""First epic"", after the second click on the button there is no message in console. If you add delay to </p>

<pre><code>Observable.of({
  id: 2,
  firstName: 'Bilbo',
  lastName: 'Baggins'
}).delay(10)
</code></pre>

<p>it starts work as expected.</p>
","3374958","","3374958","","2017-07-18 05:59:40","2017-07-18 15:46:45","Epic doesn't react on action from another epic","<redux><rxjs><react-redux><rxjs5><redux-observable>","1","1","","","","CC BY-SA 3.0"
"45144815","1","","","2017-07-17 12:52:01","","0","69","<p>Is observable.while available in the main rxjs npm package?</p>

<p>I can't seem to find it included.</p>

<p>Is there another way to do asynchronous while loops?</p>
","936503","","","","","2017-07-17 13:33:20","Rxjs.Observable.while not found in npm package","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45156683","1","","","2017-07-18 02:52:55","","2","88","<p>The official doc just give a short example for it.</p>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/master/spec/observables/interval-spec.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/spec/observables/interval-spec.ts</a></p>

<p>This official testing setup to much thing.</p>

<p>I need a simple example so that I can start to write the unit test for my <code>rxjs</code> app.</p>
","6463558","","","","","2017-07-18 02:52:55","How to setup testing environment for rxjs-v5?","<rxjs><rxjs5>","0","1","","","","CC BY-SA 3.0"
"45171586","2","","45121280","2017-07-18 15:46:45","","3","","<p>Short answer: The first click is asynchronous by returning a delay of 1000 ms in <code>fetchUserEpic</code>. The second click is a fully synchronous execution of <code>fetchUserEpic</code> which results in the inner <code>actions$.ofType(FETCH_USER_FULFILLED)</code> missing the action in <code>fetchUserEpic2</code>.</p>

<p>Explanation:</p>

<p>Tracing fetchUserEpic in the first click we get this:</p>

<pre><code>fetchUserEpic src: FETCH_USER2
fetchUserEpic2 src: FETCH_USER2
fetchUserEpic2 in: FETCH_USER2
fetchUserEpic2 out: FETCH_USER
fetchUserEpic src: FETCH_USER
fetchUserEpic in: FETCH_USER
fetchUserEpic2 src: FETCH_USER &lt;- Notice location
fetchUserEpic out: FETCH_USER_FULFILLED
fetchUserEpic src: FETCH_USER_FULFILLED
fetchUserEpic2 src: FETCH_USER_FULFILLED
fetchUserEpic2-inner src: FETCH_USER_FULFILLED &lt;- now subscribed
fetchUserEpic2-inner in: FETCH_USER_FULFILLED
First epic
fetchUserEpic2 out: FETCH_USER_FULFILLED2
fetchUserEpic src: FETCH_USER_FULFILLED2
fetchUserEpic2 src: FETCH_USER_FULFILLED2
</code></pre>

<p>Tracing the second time we get:</p>

<pre><code>fetchUserEpic src: FETCH_USER2
fetchUserEpic2 src: FETCH_USER2
fetchUserEpic2 in: FETCH_USER2
fetchUserEpic2 out: FETCH_USER
fetchUserEpic src: FETCH_USER
fetchUserEpic in: FETCH_USER
fetchUserEpic out: FETCH_USER_FULFILLED
fetchUserEpic src: FETCH_USER_FULFILLED
fetchUserEpic2 src: FETCH_USER_FULFILLED
fetchUserEpic2 src: FETCH_USER &lt;- Notice location
</code></pre>

<p>Since <code>fetchUserEpic2</code> subscribes to to <code>actions$</code> in the switchMap statement, it does not receive actions that were already dispatched. redux-observable uses a regular <code>Subject</code>, not a <code>ReplaySubject</code> or similar so if the action is dispatched before the subscription, that actions$ subscription will miss the action. For this reason you need to be careful to guarantee that actions are dispatched asynchronously when you are depending on inner subscriptions like <code>fetchUserEpic2</code> is using.</p>

<p>Here is the modified source with the tracing logging statements:</p>

<pre><code>const fetchUserEpic = (action$, store) =&gt;
  action$
    .do(a =&gt; console.log(`fetchUserEpic src: ${a.type}`))
    .ofType(FETCH_USER)
    .do(a =&gt; console.log(`fetchUserEpic in: ${a.type}`))
    .mergeMap(action =&gt; {
      const observable = isFetchced ? Observable.of({
        id: 2,
        firstName: 'Bilbo',
        lastName: 'Baggins'
      }) : fakeAjax(`/api/users/${action.payload}`);
      return observable
        .map(response =&gt; (isFetchced = true,fetchUserFulfilled(response)))
        .takeUntil(action$.ofType(FETCH_USER_CANCELLED))
    })
    .do(a =&gt; console.log(`fetchUserEpic out: ${a.type}`));

const fetchUserEpic2 = action$ =&gt;
  action$
    .do(a =&gt; console.log(`fetchUserEpic2 src: ${a.type}`))
    .ofType(FETCH_USER2)
    .do(a =&gt; console.log(`fetchUserEpic2 in: ${a.type}`))
    .switchMap(() =&gt;
      action$
        .do(a =&gt; console.log(`fetchUserEpic2-inner src: ${a.type}`))
        .ofType(FETCH_USER_FULFILLED)
        .do(a =&gt; console.log(`fetchUserEpic2-inner in: ${a.type}`))
        .take(1)
        .do(() =&gt; console.log(""First epic""))
        .mergeMap(() =&gt;
          fakeAjax2(`/api/users/${1}`)
            .map(response =&gt; fetchUserFulfilled2(response))
        ).startWith(fetchUser('redux-observable')))
    .do(a =&gt; console.log(`fetchUserEpic2 out: ${a.type}`));
</code></pre>
","1800748","","","","","2017-07-18 15:46:45","","","","0","","","","CC BY-SA 3.0"
"45174328","1","45175366","","2017-07-18 18:19:20","","1","233","<p>According to the RxJS 5 manual's section on <a href=""http://reactivex.io/rxjs/manual/overview.html#multicasted-observables"" rel=""nofollow noreferrer"">Multicasting</a></p>

<blockquote>
  <p>...we can use ConnectableObservable's refCount() method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from 0 to 1, it will call connect() for us, which starts the shared execution. Only when the number of subscribers decreases from 1 to 0 will it be fully unsubscribed, stopping further execution.</p>
</blockquote>

<p>I'd like to understand whether it's possible to hook into each of these events and execute some logic, ideally before the source observable's <code>connect()</code> or <code>unsubscribe()</code> occurs, but even after the fact would be acceptable. </p>

<p>If there's no way to do this when using the <code>refCount()</code> operator, it'd be much appreciated if you could provide an example how one could achieve this with a custom operator.</p>

<p>I thought maybe I could somehow use the completeFn from <code>do(nextFn,errFn,completeFn)</code> to hook into this, but doesn't seem to work as shown by the below snippet.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var source = Rx.Observable.interval(500)
  .do(
    (x) =&gt; console.log('SOURCE emitted ' + x),
    (err) =&gt; console.log('SOURCE erred ' + err),
    () =&gt; console.log('SOURCE completed ')
  );
var subject = new Rx.Subject();
var refCounted = source.multicast(subject).refCount();
var subscription1, subscription2, subscriptionConnect;

// This calls `connect()`, because
// it is the first subscriber to `refCounted`
console.log('observerA subscribed');
subscription1 = refCounted.subscribe({
  next: (v) =&gt; console.log('observerA: ' + v)
});

setTimeout(() =&gt; {
  console.log('observerB subscribed');
  subscription2 = refCounted.subscribe({
    next: (v) =&gt; console.log('observerB: ' + v)
  });
}, 600);

setTimeout(() =&gt; {
  console.log('observerA unsubscribed');
  subscription1.unsubscribe();
}, 1200);

// This is when the shared Observable execution will stop, because
// `refCounted` would have no more subscribers after this
setTimeout(() =&gt; {
  console.log('observerB unsubscribed');
  subscription2.unsubscribe();
}, 2000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","57089","","","","","2017-07-18 19:20:32","Execute logic when RxJS 5 refCount() connects to or unsubscribes from source","<javascript><functional-programming><rxjs><observable><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"45175366","2","","45174328","2017-07-18 19:20:32","","4","","<p>You can use a combination of <code>.do(null,null, onComplete)</code> before your actual stream and <code>.finally()</code> after completion/unsubscribe to have events before subscription and after completion/unsubscribe:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const source = Rx.Observable.empty()
  .do(null,null, () =&gt; console.log('subscribed'))
  .concat(Rx.Observable.interval(500))
  .finally(() =&gt; console.log('unsubscribed'))
  .publish().refCount();

const sub1 = source
  .take(5)
   .subscribe(
     val =&gt; console.log('sub1 ' + val),
     null, 
     () =&gt; console.log('sub1 completed')
   );
const sub2 = source
  .take(3)
  .subscribe(
    val =&gt; console.log('sub2 ' + val), 
    null, 
    () =&gt; console.log('sub2 completed')
  );

// simulate late subscription setting refCount() from 0 to 1 again                      
setTimeout(() =&gt; {
  source
    .take(1)
    .subscribe(
      val =&gt; console.log('late sub3 val: ' + val),
      null, 
      () =&gt; console.log('sub3 completed')
    );
 
}, 4000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","106909","","","","","2017-07-18 19:20:32","","","","0","","","","CC BY-SA 3.0"
"45177587","1","45185606","","2017-07-18 21:41:45","","3","439","<p>Suppose I'm developing a chat app. I have observable <code>threads$</code> that emits array of threads every <em>n</em> seconds, observable <code>offline$</code> that notifies when a thread became offline, observable <code>online$</code> that notifies when a thread became online:</p>

<pre><code>enum ConnectionStatus { Offline = 0, Online }

interface Thread {
    id: string;
    status: ConnectionStatus
}

const threads$ = Observable
    .interval(n)
    .switchMap(() =&gt; Observable.create((observer: Observer&lt;Array&lt;Thread&gt;&gt;) =&gt;
        getThreads((threads: Array&lt;Thread&gt;) =&gt; observer.next(threads))));

const online$ = Observable.create((observer: Observer&lt;Thread&gt;) =&gt;
    onOnline((threadId: string) =&gt; observer.next({
        id: threadId,
        status: ConnectionStatus.Online
    })));

const offline$ = Observable.create((observer: Observer&lt;Thread&gt;) =&gt;
    onOffline((threadId: string) =&gt; observer.next({
        id: threadId,
        status: ConnectionStatus.Offline
    })));
</code></pre>

<p>I want to combine these streams following this <em>rule</em>: <code>threads$</code> should emit array every n seconds, but whenever <code>online$</code> or <code>offline$</code> emits, I want to grab latest value(<code>Array&lt;Threads&gt;</code>) of <code>threads$</code> and map it by changing status of one thread and emit mapped collection immediately.</p>

<p>I've lost track with Rx's <code>combineLatest</code>, <code>mergeMap</code>, <code>zip</code> and similar, so I would appreciate if someone could help me to implement combining in this case(in more of a Rx-way)</p>
","6036154","","6036154","","2017-07-18 21:48:09","2017-07-20 10:25:22","Combining/merging observables","<javascript><typescript><rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"45185606","2","","45177587","2017-07-19 08:55:38","","0","","<p>This should emit an <code>Array&lt;Thread&gt;</code> every time <code>threads$</code> emits <strong>and</strong> immediately when <code>online$</code> and <code>offline$</code> emits.</p>

<pre><code>const threadUpdate$ = Observable.merge(
    threads$,
    Observable.merge(online$, offline$)
        .withLatestFrom(threads$,
            (thread, threads) =&gt; threads.map(t =&gt; {
                if(t.id === thread.id) {
                    t.status = thread.status
                }
            })));
</code></pre>

<p>Note that <code>threads$</code> will continue to emit and might even emit at, potentially, the same time as the combined <code>online$</code>/<code>offline$</code> stream.</p>
","1339804","","","","","2017-07-19 08:55:38","","","","0","","","","CC BY-SA 3.0"
"45189083","1","","","2017-07-19 11:22:52","","4","2551","<p>I am using RxJS in an angular 4 project.</p>

<p>I am trying to initiate a Websocket, and especially to know when this one is opened.</p>

<p>I am currently using WebSocket from RxJS (v5).
<a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/dom/WebSocketSubject.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/observable/dom/WebSocketSubject.ts</a></p>

<p>I noticed there is an openObserver in WebSocketSubjectConfig but I cannot find how to create the Observer. I have been locked on it from several hours.</p>

<p>Here is an excerpt of my code so far:</p>

<pre><code>import { Injectable } from '@angular/core';
import { webSocket} from 'rxjs/observable/dom/webSocket';
import { WebSocketSubject, WebSocketSubjectConfig} from 'rxjs/observable/dom/WebSocketSubject';

@Injectable()
export class MzkWebsocketJsonRpcService {
    subject: WebSocketSubject&lt;any&gt;;
    jsonRpcId: number;

    constructor() {

        this.subject = webSocket('ws://localhost:12345');
        this.subject.openObserver =
            /// Find a way to create the openObserver


        this.subject.subscribe(
            this.onMessage,
            this.onError,
            this.onClose,
        );
        console.log('Socket connected');
        this.jsonRpcId = 1;
    }

    public send(method: string, params: any[]) {

        let jsonFrame: any = {id: this.jsonRpcId, 'json-rpc': '2.0', method: method};

        if (params) {
            jsonFrame['params'] = params;
        }
        this.subject.next(JSON.stringify(jsonFrame));
        this.jsonRpcId ++;
    }

    onMessage(data: string) {
        console.log('Websocket message: ', data);
    }

    onError(data: string) {
        console.log('Websocket error:', data);
    }

    onClose() {
        console.log('Websocket closing');
    }
}
</code></pre>
","785555","","","","","2017-07-19 11:32:22","Is there a way to know if rxjs websocket is opened","<angular><websocket><rxjs><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"45203240","1","45203447","","2017-07-20 00:35:56","","0","382","<p>Working on a scheduler with RxJS that every second checks the array of jobs. When job is finished it is removed from array. I would like to run that with the <strong>.mergeAll(concurrency)</strong> parameter so for example there are only two jobs running at the same time.
Currently I have an workaround which can be seen <a href=""https://github.com/bleenco/abstruse/blob/master/src/api/process-manager.ts#L54-L83"" rel=""nofollow noreferrer"">here</a>.</p>

<p>What I am trying is something like</p>

<pre><code>Observable
  .interval(1000)
  .timeInterval()
  .merge(...jobProcesses.map(job =&gt; Observable.fromPromise(startJob(job.id))))
  .mergeAll(config.concurrency || 10)
  .subscribe();
</code></pre>

<p>which obviously doesn't work. Any help would be appreciated.</p>
","2221804","","","","","2017-07-20 01:25:18","RxJS - check array of observables with concurrency in interval","<node.js><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"45203447","2","","45203240","2017-07-20 01:02:45","","1","","<p>From the comments, it seems you are simply trying to limit concurrency, and this interval stuff is just a detour. You should be able to get what you need with:</p>

<pre><code>const Rx = require('rxjs/Rx')

let startTime = 0
const time = () =&gt; {
    if (!startTime)
        startTime = new Date().getTime()
    return Math.round((new Date().getTime() - startTime) / 1000)
}

const jobs = new Rx.Subject() // You may additionally rate-limit this with bufferTime(x).concatAll()
const startJob = j =&gt; Rx.Observable.of(undefined).delay(j * 1000).map(() =&gt; time())
const concurrency = 2

time()
jobs
    .bufferCount(concurrency)
    .concatMap(buf =&gt; Rx.Observable.from(buf).flatMap(startJob))
    .subscribe(x =&gt; console.log(x))

Rx.Observable.from([3, 1, 3]).subscribe(jobs)

// The last job is only processed after the first two are completed, so you see:
// 1
// 3
// 6
</code></pre>

<p>Note that this technically isn't squeezing out the maximum amount of concurrency possible, since it breaks the jobs up into constant batches. If your jobs have significantly uneven processing times, the longest job in the batch will delay pulling work from the next batch.</p>
","1726343","","1726343","","2017-07-20 01:25:18","2017-07-20 01:25:18","","","","6","","","","CC BY-SA 3.0"
"45203858","1","45207372","","2017-07-20 02:00:40","","1","1184","<p>I'm using websocket to receive data frame from hardware.
The data frame is defined like this:</p>

<p><code>0xbb(head) ---data--- 0xee(tail)</code></p>

<p>the received data is store in Uint8Array, there maybe multiple frame:</p>

<pre><code>var buffer = new Uint8Array([0xbb,0,0,0,0xee,0xbb,1,1,1,0xee,0xbb,3,3,3,0xee]);
</code></pre>

<p>and I can convert the array to observable:</p>

<p><code>var obs= Rx.Observable.from(buffer);</code></p>

<p>RxMarbles:</p>

<pre><code>--0xbb--0--0--0--0xee--0xbb--1--1--1--0xee--0xbb--2--2--2--0xee------
------------------000------------------111------------------222------
</code></pre>

<p>How to use RxJS to split the observable? 
Which operators to use?
Is RxJS the best practice for this situation?</p>
","4813747","","4813747","","2017-07-20 02:24:03","2017-07-20 10:16:49","How to split a data frame from an arrayBuffer with RxJS?","<javascript><websocket><rxjs><observable><rxjs5>","2","5","","","","CC BY-SA 3.0"
"45207372","2","","45203858","2017-07-20 06:55:25","","2","","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const source = Rx.Observable
  .from(['0xbb','0','0','0','0xee','0xbb','1','1','1','0xee','0xbb','3','3','3','0xee'])
  .concatMap(i =&gt; Rx.Observable.of(i).delay(1));

source
  .filter(i =&gt; i != '0xee' &amp;&amp; i != '0xbb')
  .buffer(source.filter(i =&gt; i === '0xee'))
  .subscribe(val =&gt; console.log(val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>We need to convert the values to async by using <code>concatMap(.. delay(1))</code> because otherwise the <code>closingNotifier</code> of buffer is running faster then the ingestion of values and you end up with three empty array's. But since you receive these packets from a websocket you are already async.</p>

<p>This code is not 100% foolproof, for instance what should happen when the external device does not emit <code>0xee</code>? We end up with the next message being concatenated to the previous message.</p>
","106909","","","","","2017-07-20 06:55:25","","","","2","","","","CC BY-SA 3.0"
"45207778","1","","","2017-07-20 07:13:03","","0","82","<p>I want to get a stream which emits numbers and each number is distinct from the previous one or the all previous numbers.</p>

<p>The stream below outputs may be [0, 1, 1, 1, 2, 1, 0, ...], I expect some modifications to get [0, 2, 1, 2, 0, 1, ...], no two or more adjacent numbers are same in the sequence:</p>

<pre><code>const number$ = Rx.Observable.interval(500)
  .map(() =&gt; Math.floor(Math.random() * 3))

number$.subscribe(console.log)
</code></pre>

<p>The stream below outputs may be [3, 3, 1, 4, 3], I expect some modifications to get [2, 0, 3, 1, 4], all numbers are distinct:</p>

<pre><code>const number$ = Rx.Observable.interval(500)
  .map(() =&gt; Math.floor(Math.random() * 5))
  .take(5)

number$.subscribe(console.log)
</code></pre>

<p>Simply using <code>distinct</code> and <code>distinctUntilChanged</code> will make some 'holes', it isn't desired. Pre-generate the determinated sequence(ex: using lodash.shuffle) is also not the desired solution, the output number is may generated by a remote rand generator service, means that we cloud retry number fetching while get duplicated numbers.</p>

<p>I think if there are some ways to get the comparison result of <code>distinct</code> and <code>distinctUntilChanged</code> and using it to conditionally rollback/replay the last (one or some) operation(s) can solve my problem.</p>
","4494083","","4494083","","2017-08-03 08:17:19","2017-08-03 08:17:19","How to rollback/replay some operations conditionally?","<javascript><rxjs><reactive-programming><rxjs5>","0","4","","","","CC BY-SA 3.0"
"45209100","1","45213091","","2017-07-20 08:14:41","","0","787","<p>I'm wondering any methods can convert one stream to another. I have already got two streams number$ and color$, they output numbers and colors like [1, 1, 1, ...] and ['red', 'red', 'red', ...].</p>

<p>I want to get outputs like [1, 1, 1, 'red', 'red', 'red', 'red', 'red', 'red', 1, 1, 1, ...], this output stream will randomly jump number$ to color$ or reversely.</p>

<p>I'm a newbie to RxJS and didn't find an appropriate method to solve my problem. So I assumed a method <code>jumpWhen(condition, streamJumpTo)</code>, once the condition is true, the processing stream will be deprecated and it will be converted to a new stream and start to work.</p>

<pre><code>let number$, color$

number$ = Rx.Observable.interval(300)
  .jumpWhen(Math.random() &gt; 0.9, color$)
  .mapTo(1)

color$ = Rx.Observable.interval(500)
  .jumpWhen(Math.random() &lt; 0.3, number$)
  .mapTo('red')

number$.subscribe(console.log)
</code></pre>

<p>The question is, how can I simulate this procedure by using Rx.js v5? Note: $number and $color may have totally different operators appended(not a simple <code>mapTo</code>), so I don't think we should try to merge the two streams together.</p>

<p><strong>Description about this stream:</strong></p>

<p>At first, stream outputs <code>1</code> per 300ms, there is 10% chance to (Math.random() > 0.9) switching number$ to $color. If the switching happens, stream stops outputting <code>1</code>, it starts to outputting <code>red</code> per 500ms. The overall output may seems like:</p>

<pre><code>       1 - - 1 - - 'red' - - - - 'red' - - - - 'red' - - - - 1 - - 1 - ...
cond   f     f       t             f             f           t     f
time  300   600     900           1400         1900        2400   2700
rand  0.5   0.2     0.95          0.99          0.4        0.08   0.1
</code></pre>
","4494083","","4494083","","2017-07-21 07:09:27","2017-07-21 07:22:25","How do I conditionally emit two observables stream?","<javascript><rxjs><reactive-programming><rxjs5>","1","2","0","","","CC BY-SA 3.0"
"45209524","1","45212053","","2017-07-20 08:35:54","","0","207","<p>I have a need in my code to perform an AJAX request and send the resulting data to two different places, so I figured using a multicast observable was the easiest way of achieving this.  My code looks like this:</p>

<p>In the constructor for my 'app' object:</p>

<pre><code>this.getEpisodeDescription = (id) =&gt; jsonLoader(""http://www.randomtext.me/api/lorem/p-2/8-24"", ""text_out"");

function jsonLoader (url, field)
{
    let stream = Rx.Observable.ajax ({ url: url, crossDomain: true })
                                .retry (1)
                                .pluck (""response"");
    if (field !== undefined)
        return stream.pluck(field);
    else
        return stream;
}
</code></pre>

<p>I've successfully used this method before to retrieve data for a single receiver, so I'm sure this is working OK.  The caller is new, however:</p>

<pre><code>loadSummary (id)
{
    let cachedValue = this.summaries.get(id);
    if (cachedValue !== undefined) return Rx.Observable.of(cachedValue);

    let observable = this.app.getEpisodeDescription(id);
    let multicast = observable.multicast ().refCount ();
    multicast.subscribe(result =&gt; this.summaries.put(id, result));
    return multicast;
}
</code></pre>

<p>When I try executing this method, I get the following stack trace:</p>

<pre><code>Uncaught TypeError: Cannot read property 'subscribe' of undefined
    at Observable.ConnectableObservable._subscribe (app.js:44193)
    at Observable._trySubscribe (app.js:10253)
    at Observable.subscribe (app.js:10241)
    at RefCountOperator.call (app.js:44275)
    at Observable.subscribe (app.js:10238)
    at AsyncAction.SubscribeOnObservable.dispatch (app.js:71532)
    at AsyncAction._execute (app.js:21083)
    at AsyncAction.execute (app.js:21058)
    at AsyncScheduler.flush (app.js:21156)
</code></pre>

<p>(Ignore file name and line numbers -- I'm using webpack and it doesn't seem to be producing a working line number map at the moment)</p>

<p>Any ideas what's going on?  Specifically, how does it happen that I get an object out of the call to <code>multicast</code> that has appropriate <code>subscribe</code> etc methods, but when you try to subscribe to it it apparently can't subscribe to the parent?</p>
","441899","","","","","2017-07-20 10:24:05","Multicast observable: attempting to subscribe results in ""cannot read property 'subscribe' of undefined"" error","<ecmascript-6><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45212053","2","","45209524","2017-07-20 10:24:05","","1","","<p>The first parameter to the <code>multicast()</code> operator is either Subject factory function or a Subject instance.</p>

<p>This means you should be using it like this if you want to have one shared Subject instance:</p>

<pre><code>let multicast = observable.multicast(new Subject()).refCount();
</code></pre>

<p>... or like this to make a new Subject for every observer:</p>

<pre><code>let multicast = observable.multicast(() =&gt; new Subject()).refCount();
</code></pre>
","310726","","","","","2017-07-20 10:24:05","","","","0","","","","CC BY-SA 3.0"
"45213091","2","","45209100","2017-07-20 11:14:35","","0","","<p>You can use <code>Observable.if()</code>.</p>

<p><code>Observable.if(condition, thenSource, [elseSource])</code> takes in 3 arguments: </p>

<ol>
<li>First argument takes in a function that returns a boolean,</li>
<li>Second argument is an <code>observable</code> to be emitted if condition is true</li>
<li>and the last one being an array of else source, that is to be emitted if condition is false.</li>
</ol>

<p>Since you have two observables <code>numbers$</code> and <code>colors$</code>, you can write a the conditional function and decide which observables to be emitted.</p>

<pre><code>Observable.if(
    () =&gt; Math.random() &gt; 0.5, //function that determines your condition
    number$, //this observable will be emitted if the above function returns true 
    color$ //this will be emitted if false
    )
.subscribe(x =&gt; console.log(x));
</code></pre>

<p>A working <a href=""https://jsbin.com/tayanil/4/edit?js,console"" rel=""nofollow noreferrer"">JSBin</a>.</p>

<p><strong>Edit:</strong></p>

<p>From the comments, I realized I understood your requirement wrongly. For your case, you can use <code>.expand()</code> operator to repetitively returns an Observable of your choice, and delay accordingly:</p>

<pre><code>let test = Observable
.of(1)
.expand((prevData) =&gt; {
  let rand = Math.random();
  let number$ = Observable.of(1).delay(300);
  let color$ = Observable.of('red').delay(500);

  if (prevData === 1) {
    return rand &gt; 0.9 ? color$ : number$;
  }
  else {
    return rand &lt; 0.3 ? number$ : color$;
  }

})
.subscribe(x =&gt; console.log(x))
</code></pre>

<p>Edited working <a href=""https://jsbin.com/wevomog/edit?js,console"" rel=""nofollow noreferrer"">JSBin</a></p>
","2829204","","2829204","","2017-07-21 07:22:25","2017-07-21 07:22:25","","","","5","","","","CC BY-SA 3.0"
"45232028","1","","","2017-07-21 07:50:13","","0","315","<p>I'm writing my own version of <a href=""http://jsfiddle.net/staltz/8jFJH/48/"" rel=""nofollow noreferrer""><code>who to follow?</code></a>. Clicking <code>refreshButton</code> will fetching suggestions list and refresh <code>&lt;Suggestion-List /&gt;</code>, and <code>closeButton</code> will resue the data from suggestions list and refresh <code>&lt;Suggestion-List-Item /&gt;</code>.</p>

<p>I want to let the closeClick$ and suggestions$ combine together to driving subscribers.
Demo code here:</p>

<pre><code>var refreshClick$ = Rx.Observable
  .fromEvent(document.querySelector('.refresh'), 'click')

var closeClick$ = Rx.Observable.merge(
  Rx.Observable.fromEvent(document.querySelector('.close1'), 'click').mapTo(1),
  Rx.Observable.fromEvent(document.querySelector('.close2'), 'click').mapTo(2),
  Rx.Observable.fromEvent(document.querySelector('.close3'), 'click').mapTo(3)
)

var suggestions$ = refreshClick$
  .debounceTime(250)
  .map(() =&gt; `https://api.github.com/users?since=${Math.floor(Math.random()*500)}`)
  .startWith('https://api.github.com/users')
  .switchMap(requestUrl =&gt; Rx.Observable.fromPromise($.getJSON(requestUrl)))

Rx.Observable.combineLatest(closeClick$, suggestions$, (closeTarget, suggestions) =&gt; {
  if (/* the latest stream is closeClick$ */) {
    return [{
      target: clickTarget,
      suggestion: suggestions[Math.floor(Math.random() * suggestions.length)]
    }]
  }
  if (/* the latest stream is suggestions$ */) {
    return [1, 2, 3].map(clickTarget =&gt; ({
      target: clickTarget,
      suggestion: suggestions[Math.floor(Math.random() * suggestions.length)]
    }))
  }
})

Rx.Observable.merge(renderDataCollectionFromSuggestions$, renderDataCollectionFromCloseClick$)
  .subscribe(renderDataCollection =&gt; {
    renderDataCollection.forEach(renderData =&gt; {
      var suggestionEl = document.querySelector('.suggestion' + renderData.target)
      if (renderData.suggestion === null) {
        suggestionEl.style.visibility = 'hidden'
      } else {
        suggestionEl.style.visibility = 'visible'
        var usernameEl = suggestionEl.querySelector('.username')
        usernameEl.href = renderData.suggestion.html_url
        usernameEl.textContent = renderData.suggestion.login
        var imgEl = suggestionEl.querySelector('img')
        imgEl.src = """";
        imgEl.src = renderData.suggestion.avatar_url
      }
    })
  })
</code></pre>

<p>You can find it in <a href=""http://jsfiddle.net/Zheeeng/vf3mu57x/"" rel=""nofollow noreferrer"">JsFiddle</a>.</p>

<p>You should note the comments in condition judgment, closeClick$ emits <code>[{ target: x, suggestion: randomSuggestionX }]</code>, suggestions$ emits <code>[{ target: 1, suggestion: randomSuggestion1 }, { target: 2, suggestion: randomSuggestion2 }, { target: 3, suggestion: randomSuggestion3 }]</code>. Subsriber render interface according to the emitted data.</p>

<p>May there are some ways/hacks to distinguish the latest stream in <code>combineLatest</code> or elegant modifications?</p>
","4494083","","4494083","","2017-07-22 08:02:18","2017-07-22 08:02:18","In Rx.js, how can I distinguish which stream triggers the combineLatest method?","<javascript><rxjs><reactive-programming><rxjs5>","1","1","","","","CC BY-SA 3.0"
"45240487","1","45246070","","2017-07-21 14:41:49","","2","381","<h1>Scenario</h1>

<p>I have a web component where the DOM manipulation is handled internally and not exposed to the outside world. The outside world has access to a stream that the web component provides.</p>

<p>Every time the web component emits a valid value, internally it should clear the value from the input component. However, this appears to have side effect on the stream.</p>

<h2>Questions</h2>

<ul>
<li>Why does this happen?</li>
<li>How can clear subscription be defined without side effect on other subscribers?</li>
</ul>

<h2>Code</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const logExternally = createFakeComponentStream()
  .subscribe(logValue);

function createFakeComponentStream() {
  const inputStream = Rx.Observable.fromEvent(
      document.querySelector(""[name='input']""),
      'keyup')
    .filter(event =&gt; /enter/i.test(event.key));

  const valueStream = inputStream
    .pluck('srcElement', 'value');
    
  const logInternally = valueStream.subscribe(logValue);

  const clearOnInput = inputStream
    .pluck('srcElement')
    .subscribe(clearInput);

  return valueStream;
}


function clearInput(input) {
  input.value = '';
}

function logValue(value) {
  if (value) {
    console.log('Success:', value);
  } else {
    console.log('Failed:', value);
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.js""&gt;&lt;/script&gt;
&lt;input type=""text"" name=""input"" value="""" /&gt;</code></pre>
</div>
</div>
</p>

<h2>Expected Output</h2>

<pre><code>Success: asdf
Success: asdf
</code></pre>

<h2>Actual Output</h2>

<pre><code>Success: asdf
Failed:
</code></pre>
","2708395","","2708395","","2017-07-21 15:14:16","2017-07-21 20:16:37","How to execute dom manipulation from a subscriber without side effect RxJS?","<javascript><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45246070","2","","45240487","2017-07-21 20:16:37","","2","","<p>You are passing the DOM element through the observable streams and one of your subscribers is <em>mutating</em> the DOM element, so when the 2nd observer receives the notification and checks the value of the DOM element, it has already been modified.</p>

<p>To avoid this, you need to capture the value before you clear the input.  something like this:</p>

<pre><code>const inputStream = Rx.Observable.fromEvent(
      document.querySelector(""[name='input']""),
      'keyup')
    .filter(event =&gt; /enter/i.test(event.key))
    .map(event =&gt; ({ srcElement: event.srcElement, value: event.srcElement.value }))
    .share();

const valueStream = inputStream.pluck(""value"");
const logInternally = valueStream.subscribe(logValue);
const clearOnInput = inputStream.pluck(""srcElement"").subscribe(clearInput);
return valueStream;
</code></pre>

<p>I made 2 changes:</p>

<ol>
<li>I use <code>map</code> to capture the value of the DOM Element early in the stream</li>
<li>I use <code>share</code> so that this captured value is shared with all subsequent subscriptions to the input stream</li>
</ol>

<p>These two changes will shield the <code>valueStream</code> subscribers from the clearInput mutation.</p>
","674326","","","","","2017-07-21 20:16:37","","","","2","","","","CC BY-SA 3.0"
"45259623","2","","42793905","2017-07-22 22:02:15","","0","","<p>I've added this code to clarify how subscriptions and error handling actually works.</p>

<p>The subscription (or pipeline) would remain intact waiting (listening) for your next http request by default, even if there was an error.</p>

<p>If you assign the subscription to a variable, you can unsubscribe to it..
It's <a href=""https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87"" rel=""nofollow noreferrer"">NOT a recommended practice</a>...</p>

<p>This use case is entirely hypothetical, but shows how you can stop subscribing via code.</p>

<p>The default <a href=""https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93"" rel=""nofollow noreferrer"">RxJS Subject</a> is another way to stop on error..</p>

<blockquote>
  <p><strong>Subjects Are Not Reusable</strong>: In RxJS, Subjects cannot be reused. That is
  to say, when a Subject completes or errors, it can no longer be used.
  If you try to next on a Subject that is closed due to itâs complete or
  error method being called, it will silently ignore the notification.
  If you want the Subject to loudly and angrily error when you next to
  it after itâs done being useful, you can call unsubscribe directly on
  the subject instance itself.</p>
</blockquote>

<pre><code>import { Subscription } from ""rxjs/Subscription"";
...
export myComponent implements ngOnInit {
  sub: Subscription;
  records : DomainClz[];


  constructor(private domainService:DomainService) {}

  onInit() {
     // assumes getRecords returns Observable&lt;DomainClz[]&gt;
     // ie it chains map((resp:Response )to resp.json()) to http.get()
     this.sub = this.domainService.getRecords().
       subscribe(records =&gt; { this.records = records) },
                 error =&gt;   { console.error(error)    }
       );
  }

  cancel() {
    this.sub.unsubscribe()
  }
}
</code></pre>
","495157","","495157","","2017-07-22 22:33:44","2017-07-22 22:33:44","","","","0","","","","CC BY-SA 3.0"
"45273084","1","45273851","","2017-07-24 05:17:03","","0","176","<pre><code>    public get&lt;T&gt;(url: string, httpParams: Array&lt;Map&lt;string, string&gt;&gt;): Observable&lt;T&gt; {
    return this.httpClient
        .get&lt;T&gt;(url, { params: this.appendHttpParams(httpParams), headers: this.httpHeaders })
        .catch((error, some): any =&gt; {
            console.log(error);
        });

}
</code></pre>

<p>I have this wrapper function around my http service in Angular 4. It works fine without the return type specified. However, if I provide the same return type of the 'httpClient.get()' which is Observable, it throws an error</p>

<blockquote>
  <p>[ts] Type 'Observable&lt;{} | T>' is not assignable to type
  'Observable'. Type '{} | T' is not assignable to type 'T'.     Type
  '{}' is not assignable to type 'T'.</p>
</blockquote>

<p>What am I missing?</p>
","1773900","","","","","2017-07-24 06:21:41","rxjs - [ts] Type 'Observable<{} | T>' is not assignable to type 'Observable<T>'","<rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45273851","2","","45273084","2017-07-24 06:21:41","","1","","<p>You probably want to use <code>do</code> and not <code>catch</code>.  <code>catch</code> is intended for scenarios where you want to handle the error and continue the observable chain.  In a <code>catch</code> method you are supposed to return a different observable that the chain can switch to.  For example:</p>

<pre><code>this.httpClient
    .get&lt;T&gt;(...)
    .catch(err =&gt; {
        return this.cachedVersion;
    );
</code></pre>

<p>Anyways, since you don't have any return statement in your <code>catch</code> method it is returning void.  That is why your observable changes to <code>Observable&lt;T|{}&gt;</code> because it will be a chain that emits <code>T</code> if there is no error and <code>{}</code> if there is an error.</p>
","202694","","","","","2017-07-24 06:21:41","","","","0","","","","CC BY-SA 3.0"
"45288118","1","","","2017-07-24 19:00:29","","3","398","<p>I worked on Ionic 2 project 2 months ago. Now I reinstalled my machine and tried to start my project again.
I pulled my code but I get the following error when I try to ""ionic serve"" my project.</p>

<p>I am pretty shire that this is some library version problem. But I am unable to resolve it.</p>

<p>The errors I get are:</p>

<hr>

<pre><code>[21:52:08]  typescript: node_modules/ionic-angular/navigation/nav-controller-base.d.ts, line: 20 
        Class 'NavControllerBase' incorrectly implements interface 'NavController'. Types of property 'popTo' are 
        incompatible. Type '(indexOrViewCtrl: any, opts?: NavOptions, done?: Function) =&gt; Promise&lt;any&gt;' is not 
        assignable to type '(page: any, params?: any, opts?: NavOptions, done?: Function) =&gt; Promise&lt;any&gt;'. Types of 
        parameters 'done' and 'opts' are incompatible. Type 'NavOptions' is not assignable to type 'Function'. 
        Property 'apply' is missing in type 'NavOptions'. 

  L20:  export declare class NavControllerBase extends Ion implements NavController {
  L21:      parent: any;
</code></pre>

<p>[21:52:08]  typescript: node_modules/rxjs/Subject.d.ts, line: 16 
            Class 'Subject' incorrectly extends base class 'Observable'. Types of property 'lift' are 
            incompatible. Type '(operator: Operator) => Observable' is not assignable to type 
            '(operator: Operator) => Observable'. Type 'Observable' is not assignable to type 
            'Observable'. Type 'T' is not assignable to type 'R'. </p>

<pre><code>  L16:  export declare class Subject&lt;T&gt; extends Observable&lt;T&gt; implements ISubscription {
  L17:      observers: Observer&lt;T&gt;[];
</code></pre>

<p>[21:52:08]  typescript: node_modules/rxjs/observable/dom/WebSocketSubject.d.ts, line: 23 
            Class 'WebSocketSubject' incorrectly extends base class 'AnonymousSubject'. Types of property 'lift' 
            are incompatible. Type '(operator: Operator) => WebSocketSubject' is not assignable to type '(operator: Operator) => Observable'. Type 'WebSocketSubject' is not assignable to type 
            'Observable'. Types of property 'operator' are incompatible. Type 'Operator' is not assignable to 
            type 'Operator'. Type 'R' is not assignable to type 'T'. </p>

<pre><code>  L23:  export declare class WebSocketSubject&lt;T&gt; extends AnonymousSubject&lt;T&gt; {
  L24:      url: string;
</code></pre>

<p>[21:52:08]  dev server running: <a href=""http://localhost:8100/"" rel=""nofollow noreferrer"">http://localhost:8100/</a> </p>
","6095376","","","","","2017-07-24 19:00:29","Ionic 2 project. Deps unconsultancies","<angular><ionic-framework><rxjs5>","0","0","","","","CC BY-SA 3.0"
"45294082","2","","41349033","2017-07-25 04:41:46","","26","","<p>Observables push changes, and hence the observable, not the function reacting to it, is in control. Generators on the other hand require you to pull values out of them. So the function that will react to the new value determines when it is ready for a new value.</p>
<p>I had trouble with backpressure using observables, but with generators, you can let values out as slowly as you want.</p>
<p>Edit: the last question. Promises are just observables that only emit once, so I don't think they will compete with each other. I think the real battle will be async/await vs observables, and async/await has a head start, and is already in C# (and now Node.js). But observables have that sweet FRP feel, and functional programing is super cool, so I think they will both end up with a good chunk of mindshare.</p>
<p>Edit2: AndrÃ© Staltz, author of Cycle.js and xstream, and contributor to Rx.js, wrote a <em>great</em> article on how generators and Observables relate (on 2018-01-31). In particular, he shows how they both inherit from a common base class.</p>
<blockquote>
<p>And now a consumer can be a Listener (âobserverâ) or a Puller, itâs up to the consumer whether it will pull the producer or not. And the producer can be a Listenable (âobservableâ) or a Pullable (âiterableâ), itâs up to the producer whether it sends data proactively or only on demand. As you can see, both consumer and producer are simple functions of the same type:</p>
<p>(num, payload) =&gt; void</p>
<p>So any operator that we build will work for both reactive programming or iterable programming, simply because the line between those two modes gets blurred and itâs not anymore about observables versus iterables, itâs just about transformations of data between producer and consumer.</p>
</blockquote>
<p>I recommend reading it [<a href=""https://staltz.com/why-we-need-callbags.html"" rel=""noreferrer"">link</a>]. The article introduces &quot;<a href=""https://github.com/callbag/callbag"" rel=""noreferrer"">Callbags</a>&quot;, a spec for callbacks used for reactive and iterable programming. He implements that spec to make <a href=""https://github.com/staltz/callbag-basics"" rel=""noreferrer"">a tiny library</a> for both iterable and reactive programming. To entice you to read the article and check out the library, here are some examples from the 7kb lib based on the spec he introduces:</p>
<p><strong>Reactive programming example</strong></p>
<p>Pick the first 5 odd numbers from a clock that ticks every second, then start observing them:</p>
<pre><code>const {forEach, interval, map, filter, take, pipe} = require('callbag-basics');

pipe(
  interval(1000),
  map(x =&gt; x + 1),
  filter(x =&gt; x % 2),
  take(5),
  forEach(x =&gt; console.log(x))
);

// 1
// 3
// 5
// 7
// 9
</code></pre>
<p><strong>Iterable programming example</strong></p>
<p>From a range of numbers, pick 5 of them and divide them by 4, then start pulling those one by one:</p>
<pre><code>const {forEach, fromIter, take, map, pipe} = require('callbag-basics');

function* range(from, to) {
  let i = from;
  while (i &lt;= to) {
    yield i;
    i++;
  }
}

pipe(
  fromIter(range(40, 99)), // 40, 41, 42, 43, 44, 45, 46, ...
  take(5), // 40, 41, 42, 43, 44
  map(x =&gt; x / 4), // 10, 10.25, 10.5, 10.75, 11
  forEach(x =&gt; console.log(x))
);

// 10
// 10.25
// 10.5
// 10.75
// 11
</code></pre>
","3518108","","-1","","2020-06-20 09:12:55","2018-02-03 21:58:43","","","","1","","","","CC BY-SA 3.0"
"45301483","1","45303776","","2017-07-25 11:07:34","","0","578","<p>This piece of code parses triples (not that important) and should return one parking at a time. The problem is that calling observer.next() breaks the loop as it just runs once. The console.log also doesn't get called. I'm probably missing something but is it possible that observer.next() breaks the loop? Is there an error or is it a feature or am I just plain wrong? </p>

<pre><code> return Observable.create(observer =&gt; {
  this.fetch.get(datasetUrl).then(response =&gt; {
    // Get all subjects that are parkings
    const parkingTriples = [],
      parkings = [],
      totalspacesParking = [],
      labels = [];
    for (let index = 0; index &lt; response.triples.length; index++) {
      if (response.triples[index].object === 'http://vocab.datex.org/terms#UrbanParkingSite') {
        parkingTriples.push(response.triples[index]);
      }
      if (response.triples[index].predicate === 'http://vocab.datex.org/terms#parkingNumberOfSpaces') {
        totalspacesParking.push(response.triples[index]);
      }
      if (response.triples[index].predicate === 'http://www.w3.org/2000/01/rdf-schema#label') {
        labels.push(response.triples[index]);
      }
    }
    const _parkings = [];
    for (let index = 0; index &lt; parkingTriples.length; index++) {
      const totalspacesresult = find(totalspacesParking, (o) =&gt; {
        return o.subject === parkingTriples[index].subject
      });
      const totalspaces = parseInt(n3.Util.getLiteralValue(totalspacesresult.object), 10);
      const labelresult = find(labels, (o) =&gt; {
        return o.subject === parkingTriples[index].subject
      });
      const rdfslabel = n3.Util.getLiteralValue(labelresult.object);
      const id = rdfslabel.replace(' ', '-').toLowerCase();
      observer.next(new Parking(rdfslabel, parkingTriples[index].subject, id, totalspaces, datasetUrl));
      console.log(observer);
    }

  })
})
</code></pre>
","5833446","","5833446","","2017-07-25 12:19:27","2017-07-25 12:46:52","Observable.next() breaks loop","<angular><typescript><rxjs><rxjs5>","2","4","","","","CC BY-SA 3.0"
"45303776","2","","45301483","2017-07-25 12:46:52","","1","","<p>Given your updated code I would suggest debugging it. Most likely the bug is not in the Rx bits. I have refactored your code to split between the Rx logic and the response parsing:</p>

<pre><code>function getParkings(datasetUrl){
  return Rx.Observable.defer(() =&gt; this.fetch.get(datasetUrl))
    .mergeMap(response =&gt; parseParkingResponse(response));
}

function parseParkingResponse(response) {
  const parkingTriples = [],
    parkings = [],
    totalspacesParking = [],
    labels = [];
  for (let index = 0; index &lt; response.triples.length; index++) {
    if (response.triples[index].object === 'http://vocab.datex.org/terms#UrbanParkingSite') {
      parkingTriples.push(response.triples[index]);
    }
    if (response.triples[index].predicate === 'http://vocab.datex.org/terms#parkingNumberOfSpaces') {
      totalspacesParking.push(response.triples[index]);
    }
    if (response.triples[index].predicate === 'http://www.w3.org/2000/01/rdf-schema#label') {
      labels.push(response.triples[index]);
    }
  }

  const _parkings = [];
  for (let index = 0; index &lt; parkingTriples.length; index++) {
    const totalspacesresult = find(totalspacesParking, (o) =&gt; {
      return o.subject === parkingTriples[index].subject
    });
    const totalspaces = parseInt(n3.Util.getLiteralValue(totalspacesresult.object), 10);
    const labelresult = find(labels, (o) =&gt; {
      return o.subject === parkingTriples[index].subject
    });
    const rdfslabel = n3.Util.getLiteralValue(labelresult.object);
    const id = rdfslabel.replace(' ', '-').toLowerCase();
    _parkings.push(new Parking(rdfslabel, parkingTriples[index].subject, id, totalspaces, datasetUrl));
  }

  return _parkings;
}
</code></pre>

<p>This will make it easier to debug what is going on.</p>
","106909","","","","","2017-07-25 12:46:52","","","","2","","","","CC BY-SA 3.0"
"45314666","1","45315041","","2017-07-25 22:43:18","","1","37","<p>I'm trying to learn RxJS and I was attempting to build what I thought would be a simple and straightforward example. Create an observable of random numbers generated on an interval, then use two other observables based on that observable to track the lowest and highest values that had been seen.</p>

<p>The rngStream seems to behave as expected, minStream and maxStream both appear to track correctly as well. The problem I'm having is that when this executes it seems like rngStream, minStream, and maxStream all have different random numbers on each interval. I'm trying to understand if that's expected or if I've just set something up incorrectly.</p>

<p>My goal would be an output something like:</p>

<pre><code>[27, 27, 27]
[13, 13, 27]
[90, 13, 90]
[42, 13, 90]
...
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let rngStream = Rx.Observable
  .interval(1000)
  .map(() =&gt; Math.ceil(Math.random()*100))
  .take(5);

// Track the lowest number we've seen.
let minStream = rngStream
  .startWith(100)
  .scan((x, y) =&gt; Math.min(x, y))

// Track the highest number we've seen.
let maxStream = rngStream
  .startWith(0)
  .scan((x, y) =&gt; Math.max(x, y))

Rx.Observable.zip(rngStream, minStream, maxStream)
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","8360922","","106909","","2017-07-26 06:30:19","2017-07-26 06:30:19","RxJS: Chained Observables Not Using the Same Root Observable Values","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45315041","2","","45314666","2017-07-25 23:29:41","","2","","<p><a href=""https://www.youtube.com/watch?v=3LKMwkuK0ZE"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=3LKMwkuK0ZE</a></p>

<p>This video actually clarified a lot of things for me. Specifically at the 32:00 mark he mentions <code>.share</code> which makes an observable multicast. By default every subscriber does get its own copy. So the fix looks like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let rngStream = Rx.Observable
  .interval(1000)
  .map(() =&gt; Math.ceil(Math.random()*100))
  .take(5)
  .share();

// Track the lowest number we've seen.
let minStream = rngStream
  .startWith(100)
  .scan((x, y) =&gt; Math.min(x, y))

// Track the highest number we've seen.
let maxStream = rngStream
  .startWith(0)
  .scan((x, y) =&gt; Math.max(x, y))

Rx.Observable.zip(rngStream, minStream, maxStream)
  .subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","8360922","","","","","2017-07-25 23:29:41","","","","0","","","","CC BY-SA 3.0"
"45320579","1","45321090","","2017-07-26 07:47:45","","1","1012","<p>Consider the following code:</p>

<pre class=""lang-js prettyprint-override""><code>this.msgService.getUserChatList()
    .do( (list) =&gt; { 
      this.unread = false;
      console.log(list);
     } )
    .mergeMap( chats =&gt; Observable.from(chats) )
    .mergeMap( chat =&gt; this.msgService.getLastMessage(chat['id']).map( lastMessage =&gt; this.containsUnreadMessages(lastMessage, chat['lastPresence']) ) )
    .filter( state =&gt; state === true )
    .subscribe( (unread) =&gt; {
      this.unread = true;
      console.log('result ', res);
    } );
</code></pre>

<p>getUserChatList():
 - emits an element each time one of the chat changes
 - an element is a raw array containing all chats meta-data
 - never completes</p>

<p>getLastMessage():
 - is an Observable that never completes</p>

<p>In the second mergeMap I am calling the function getLastMessage().
I need to be observe this observable <strong>only until</strong> a new item is emitted by the getUserChatList() otherwise I would multiple observations on last message of the same chat.</p>

<p>Illustration :</p>

<ol>
<li><code>getUserChatList</code> emits : [chatMetaA:{}, chatMetaB:{}] </li>
<li>code go through <code>getLastMessage</code> and start to observe lastMessage of chatA and chatB</li>
<li>one of the chat change so a new item is emitted by <code>getUserChatList</code> containing the new version of the meta-data of the chats: [chatMetaA:{}, chatMetaB:{}]</li>
<li>code go through <code>getLastMessage</code> and start to observe lastMessage of chatA and chatB. So we now observe twice last message of chatA and chatB</li>
</ol>

<p>And it will go on and on...</p>

<p>My question is, <strong>how could I cancel observation on getLastMessage() once a new item is emitted by getUserChatList()</strong>? I tried using switch but couldn't manage to make it work</p>
","6650388","","106909","","2017-07-27 06:56:13","2017-07-27 06:56:13","Cancel previous inner Observables when a new higher-order Observable is emitted","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"45321090","2","","45320579","2017-07-26 08:13:13","","2","","<p>Solution was indeed to use switchMap:</p>

<pre><code>this.msgService.getUserChatList()
    .do( () =&gt; { this.unread = false } )
    .switchMap(
      chats =&gt; Observable.from(chats)
        .mergeMap( chat =&gt; this.msgService.getLastMessage(chat['id'])
        .map( lastMessage =&gt; this.containsUnreadMessages(lastMessage, chat['lastPresence']) ) )
    )
    .filter( state =&gt; state === true )
    .subscribe( (unread) =&gt; {
      this.unread = true;
      console.log('result ', res);
    } );
</code></pre>
","6650388","","","","","2017-07-26 08:13:13","","","","0","","","","CC BY-SA 3.0"
"45330340","1","","","2017-07-26 14:45:39","","1","180","<p>I'm facing some issues with <code>ajax.delete</code>. I'm running the code below where a <strong>DELETE</strong> request from <code>ajax</code> is being done and if the first fails, it keeps retrying until the request is successful.</p>

<pre><code>let RetryStrategy = attempts =&gt; attempts
    .zip(Observable.range(1, 4))
    .flatMap(([error, i]) =&gt; {
        if (i &gt; 3) {
            return Observable.throw('Network error occured')
        }
        return Observable.timer(i * 1000)
    })

export const deleteSurveyQuestionEpic = (action$, {getState, dispatch}) =&gt;
    action$.ofType('MY_ACTION')
        .switchMap(
            action =&gt; ajax.delete(`myURL`)
                .map(res =&gt; res.response)
                .flatMap(response =&gt; {
                    console.log(response) // &lt;-- returns null
                    return arrayRemove('formName', 'questions', 1) // &lt;-- redux-form action-creator
                })
                .retryWhen(RetryStrategy)
                .takeUntil(action$.ofType('MY_CANCEL_ACTION'))
                .catch((e) =&gt; {
                    return Observable.of(
                        errorSurvey((e.xhr &amp;&amp; `Error ${e.xhr.statusText}: ${e.xhr.statusText}`) || 'Network error occured')
                    )
                })
        )
</code></pre>

<p>The problem is that in the network tab I see that the DELETE request returns <strong>200 - OK</strong> but the ajax.delete understands it as an error.</p>

<p>While looking for this issue i found <a href=""https://stackoverflow.com/questions/40708264/proper-use-of-redux-ovservable-ajax-http-methods-put-delete-post#comment68644560_40708264"">this comment</a> where @jayphelps is wondering if the browser makes a CORS request.</p>

<p>This is the case for me, while browser before each network request it makes a CORS request and after that it makes the regular request.</p>

<p>I'm confused and I'm not sure if this is an issue that is caused by the CORS process or I'm missing something in my implementation, once the PUT and GET requests work fine.</p>

<p>NOTE:
I tried to add play with <code>ajax.delete</code>'s <code>crossDomain</code> option, but I didn't manage to solve my issue.</p>

<hr>

<p><strong>Solved</strong></p>

<p>The problem was pretty easy to solve.
I didn't return an Observable from <code>flatMap</code>. RxJS operators <strong>must</strong> return an observable.</p>

<pre><code>.flatMap(response =&gt; {
    console.log(response) // &lt;-- returns null
    // An Observable needs to be returned instead of redux action creator
    return arrayRemove('formName', 'questions', 1) 
})
</code></pre>

<p>I also made <a href=""https://codepen.io/stelioschar/pen/zdqmRM"" rel=""nofollow noreferrer"">this test</a> where I implemented a simple RxJS process without the redux-observable implementation. This example contains the case where multiple redux actions-creators are being called. </p>
","1055160","","1033581","","2018-05-03 02:32:32","2018-05-03 02:32:32","RxJS - ajax.delete keeps retrying until the observable fails while DELETE request was 200 OK","<redux><rxjs><rxjs5><redux-observable><rxjs-dom>","0","3","0","","","CC BY-SA 4.0"
"45333939","1","45336975","","2017-07-26 17:37:50","","8","1997","<p>From my understanding of Angular and RxJs there are two ways to terminate Observables. You can <code>unsubscribe()</code> from them or use <code>takeUntil()</code> and <code>complete()</code>. Below are examples of each approach (in pseudocode).</p>

<p><strong>The unsubscribe() approach</strong></p>

<pre><code>private _id: number;
private _subscriptions: Subscription[] = [];

constructor(private _route: ActivatedRoute) {
    this._getId();
}

public ngOnDestroy(): void {
    this._subscriptions.forEach(
        subscription =&gt; subscription.unsubscribe()
    );
}

private _getId(): void {
    this._subscriptions.push(
        this._route.params.subscribe(params =&gt; this._id = +params['id'])
    );
}
</code></pre>

<p><strong>The takeUntil() and complete() approach</strong></p>

<pre><code>private _id: number;
private _ngUnsubscribe: Subject&lt;void&gt; = new Subject&lt;void&gt;();

constructor(private _route: ActivatedRoute) {
    this._getId();
}

public ngOnDestroy(): void {
    this._ngUnsubscribe.next();
    this._ngUnsubscribe.complete();
}

private _getId(): void {
    this._route.params.takeUntil(this._ngUnsubscribe).subscribe(
        params =&gt; this._id = +params['id']
    );
}
</code></pre>

<p>In Angular, is there a preferred way to terminate Observables?</p>
","3357958","","310726","","2017-07-26 20:40:29","2017-07-26 20:49:38","Angular - what is the preferred way to terminate Observables?","<angular><rxjs><rxjs5><angular2-observables><unsubscribe>","2","3","2","","","CC BY-SA 3.0"
"45336975","2","","45333939","2017-07-26 20:39:00","","7","","<p>Both approaches are correct even though they aren't equivalent.</p>

<p>In my opinion (and experience) using <code>unsubscribe()</code> make usually more sense and is more obvious to other developers that don't have extensive experience with RxJS.</p>

<p>Using <code>takeUntil()</code> is recommended by the lead developer of RxJS 5 (<a href=""https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87"" rel=""noreferrer"">https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87</a>) and is sometimes easier to use than handling multiple subscription objects. For example if you use the <code>partition()</code> operator to split one stream into two it's easier to use just <code>takeUntil(...).partition(...)</code>.</p>

<p>However there are two important things:</p>

<ol>
<li><p>These two aren't the same. If you use <code>takeUntil()</code> you're completing the Observable chain which means that all complete handles are called followed by tear down functions. On the other hand when you call <code>unsubscribe()</code> only tear down functions are called (including operators such as <code>finally()</code>).</p>

<p>This is why I think it makes more sense to use <code>unsubscribe()</code>. With <code>takeUntil()</code> you might have a <code>complete</code> handler that is invoked even though you just wanted to unsubscribe (not mentioning that this triggers operators that work with the <code>complete</code> signal such as <code>repeat()</code> that might resubscribe again). The fact you want to unsubscribe doesn't mean that the source Observable completed. You just don't care any more about its values so it's probably better to use <code>unsubscribe()</code> in this case. </p>

<p>However, in practise it usually doesn't matter whether you complete the chain or just unsubscribe.</p></li>
<li><p>You can compose <code>Subscription</code>s into a single one and unsubscribe all of them at once:</p>

<pre><code>const subscription = new Subscription();

const sub1 = Observable...subscribe(...);
const sub2 = Observable...subscribe(...);
const sub3 = Observable...subscribe(...);

subscription.add(sub1).add(sub2).add(sub3);

...

subscription.unsubscribe(); // unsubscribes all of them
</code></pre></li>
</ol>
","310726","","310726","","2017-07-26 20:49:38","2017-07-26 20:49:38","","","","1","","","","CC BY-SA 3.0"
"45362083","1","45362292","","2017-07-27 22:33:55","","4","471","<p>I'm trying to write a sample unit test with <code>Observable.interval</code> in RxJs version 5. I'm running the following code, but my observable only fires once, not 20 times, as anticipated.</p>

<pre><code>it('does its interval thing synchonously', ()=&gt; {

        let x = [];
        let scheduler = new Rx.TestScheduler();
        let interval$ = Rx.Observable.interval(500, scheduler).take(20);

        interval$.subscribe(
            value =&gt; {
                x.push(value);
                console.log(value)
            },
        );

        for(let i = 0; i &lt; 20; i++) {
            scheduler.flush();
        }

        expect(x.length).toBe(20);

    });
</code></pre>

<p>How do I make my <code>TestScheduler</code> move the Observable forward by 10000 milliseconds?</p>
","4098983","","","","","2018-04-26 00:21:46","How do I get TestScheduler to tick in RxJs5?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45362292","2","","45362083","2017-07-27 22:55:57","","3","","<p>My understanding is that the <code>TestScheduler</code> is intended to be used with <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md"" rel=""nofollow noreferrer"">marble testing</a> and works with observables composed from those returned by its <a href=""https://github.com/ReactiveX/rxjs/blob/5.4.2/src/testing/TestScheduler.ts#L38"" rel=""nofollow noreferrer""><code>createColdObservable</code></a> and <a href=""https://github.com/ReactiveX/rxjs/blob/5.4.2/src/testing/TestScheduler.ts#L51"" rel=""nofollow noreferrer""><code>createHotObservable</code></a> methods.</p>

<p>Instead, you could use the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/scheduler/VirtualTimeScheduler.ts"" rel=""nofollow noreferrer""><code>VirtualTimeScheduler</code></a> - upon which the <code>TestScheduler</code> is based:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let scheduler = new Rx.VirtualTimeScheduler();
let interval$ = Rx.Observable.interval(500, scheduler).take(20);

let values = [];
interval$.subscribe(value =&gt; values.push(value));

scheduler.flush();
console.log(values);</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Note that only a single <code>flush</code> call is required.</p>
","6680611","","6680611","","2018-04-26 00:21:46","2018-04-26 00:21:46","","","","0","","","","CC BY-SA 3.0"
"45368394","1","45404428","","2017-07-28 08:20:41","","0","571","<p>I am using <a href=""https://github.com/mspanc/phoenix_socket"" rel=""nofollow noreferrer"">elixir phoenix websocket</a> in an application I'm building and I have an epic that looks like this:</p>

<pre><code>const socketObservable = Observable.create((observer: Object) =&gt; {
  const socket = new Socket(`${getWebSocketUrl()}/socket`, { params: {
    token: readSession(),
  } });

  socket.connect();

  socket.onOpen(() =&gt;
      observer.next({ type: SOCKET_CONNECTED, socket }),
  );

  socket.onError((error) =&gt;
      observer.error({ type: WEBSOCKET_ERROR, error }),
  );

  return () =&gt; {
    // socket.disconnect();
  };
});

const connectToSocket = (
  action$: Object,
) =&gt; action$.ofType(CONNECT_TO_SOCKET)
.switchMap(() =&gt;
  socketObservable
    .catch((error) =&gt; Observable.of(error)),
)
.retry();

export default connectToSocket;
</code></pre>

<p>What I would like to happen is that user be notified when network connection goes away by emitting <code>{ type: WEBSOCKET_ERROR, error }</code> and have the notification removed when connection is reestablished by emitting <code>{ type: SOCKET_CONNECTED, socket }</code>. Well I got the first part working, but when re-connection happens, <code>{ type: SOCKET_CONNECTED, socket }</code> never dispatches. Using redux-saga, I was able to make this work using the following code:</p>

<pre><code>const connectToSocket = (): Object =&gt;
  eventChannel((emitter: (Object) =&gt; mixed) =&gt; {
    const socket = new Socket(`${getWebSocketUrl()}/socket`, { params: {
      token: readSession(),
    } });

    socket.connect();

    socket.onOpen(() =&gt; emitter({ socket }));

    socket.onError((error) =&gt; {
      emitter({ error });
    });

    return () =&gt; {
      // socket.disconnect();
    };
  });

export function* callConnectToSocket(): Generator&lt;IOEffect, *, *&gt; {
  const chan = yield call(connectToSocket);
  while (true) {
    const { socket, error } = yield take(chan);
    if (socket) {
      yield put({ type: SOCKET_CONNECTED, socket });
    } else {
      yield put({ error, type: WEBSOCKET_ERROR });
    }
  }
}

export function* watchConnectToSocket(): Generator&lt;IOEffect, *, *&gt; {
  yield takeLatest(CONNECT_TO_SOCKET, callConnectToSocket);
}
</code></pre>

<p>For the rxjs code, I thought tacking <code>.retry()</code> at the end of the chain was supposed to trigger a retry of my source observable if en error is emitted as per <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-retry"" rel=""nofollow noreferrer"" title=""documentation for Observable.retry"">documentation for rxjs Observable.retry</a>, but may be I don't really understand what <code>retry</code> was supposed to do or how to use it properly. May be someone can help to achieve what I want.</p>
","1437611","","","","","2017-08-02 07:29:33","rxjs/redux-observer: observable.retry to re-establish connection","<javascript><rxjs5><jestjs><redux-observable>","2","0","","","","CC BY-SA 3.0"
"45374423","2","","41551280","2017-07-28 13:09:39","","4","","<p>You can subscribe to the Observable multiple times, so if all you want to do is save the second network request for data shared between two Components, you can cache it in your Service like this:</p>

<pre><code>@Injectable()
export class NameService {

    const nameURL = ""http://www.example.com/name"";
    private cache: Observable&lt;any&gt;;

    getName() {
        return this.cache || this.cache = this.http.get(nameURL);
    }
}
</code></pre>
","8380968","","","","","2017-07-28 13:09:39","","","","0","","","","CC BY-SA 3.0"
"45382912","1","","","2017-07-28 21:51:10","","0","184","<h2>Problem</h2>

<p>I have a service that looks like this: </p>

<pre><code>DogService { 
    public getSelectedDog(): Observable&lt;Uuid&gt; {...}
    public getDog(dogUuid: Uuid): Observable&lt;Dog&gt; {...}
}
</code></pre>

<p>I would like to create an Observable that always contains my selected dog, ie <code>Observable&lt;Dog&gt;</code>.  </p>

<hr>

<h2>What I have tried so far</h2>

<p>Currently what I am doing is this: </p>

<pre><code>let selectedDog: Observable&lt;Dog&gt; =  dogService.getSelectedDog().flatMap( selectedDog =&gt; {
    return dogService.getDog( selectedDog );
});
</code></pre>

<p>Then you can subscribe to changes in the selected dog like this: </p>

<pre><code>selectedDog.subscribe( dog =&gt; console.log( 'dog: "", dog.name, dog.mood );
</code></pre>

<p>Unfortunatly, this doesn't seem to work the way I expected it to.  The selectedDog observable only 
fires when the selectedDog has changed by not when the dog itself changes.  </p>

<p>So for example lets say that we do the following: </p>

<pre><code>const dog1: Dog = new Dog( '1',      // uuid
                           'Shadow', // name
                           'happy'   // mood
);

const dog2: Dog = new Dog( '2',      // uuid
                           'Barky',  // name
                           'Angry'   // mood
);


// Fires the getDog observable
dogService.addDog( dog1 );  

// Fires the getDog observable
dogService.addDog( dog2 );

// Fires the getSelectedDogObservable
dogService.selectDog( dog1.uuid )

// --- Now in console.log we will see: 'dog: Shadow happy'
</code></pre>

<p>Unfortunatly, if I update the dog, the console doesn't get logged to: </p>

<pre><code>const updatedDog1: Dog = new Dog( '1',      // uuid
                                  'Shadow', // name
                                  'SAD'   // mood
                                   );
// Fires the getDog observable
dogService.updateDog( updatedDog1 );

// --- the console.log doesn't get invoked.  Crap.
</code></pre>

<p><strong>Question: How can I create <code>Observable&lt;Dog&gt;</code> that will fire whenever the selection or selected dog changes?</strong></p>
","251589","","","","","2017-07-29 10:18:23","How to get an observable that changes whenever another observable changes","<typescript><observable><rxjs5>","1","3","","","","CC BY-SA 3.0"
"45383297","1","","","2017-07-28 22:33:59","","1","90","<p>I have an AngularJS service that uses <code>Rx.Observable.Interval</code> in RxJs version 5 to poll an API every 30 seconds and I would like to write a unit test for it using an <code>VirtualTimeScheduler</code>. </p>

<p>However, the service does not specify a scheduler and I'd prefer not to change the original code (which is far more complex than the example below) to inject a default scheduler:</p>

<pre><code>function checkStatus(){
   // The scheduler could be provided as a 2nd arg to interval
   return Rx.Observable.interval(1000*30).switchMap(()=&gt; {
      return Rx.Observable.fromPromise(
         StatusApiService.get()
      )
   })
}
</code></pre>

<p>Is there an easy way I can tell RxJs to use a different scheduler for the <code>interval</code> factory in the unit test, without changing the original code to make the scheduler configurable?</p>

<pre><code>const scheduler = new Rx.VirtualTimeScheduler();
const subscriber = jasmine.createSpy('subscriber');
// TODO: swap out scheduler with VirtualTimeScheduler
checkStatus().subscribe(subscriber)
scheduler.flush();  // fake 10 minutes of time passing
expect(StatusApiService.get).toHaveBeenCalledTimes(20);
</code></pre>
","4098983","","4098983","","2017-07-28 22:40:38","2017-07-28 22:40:38","How do I swap out the default scheduler for testing in RxJs5?","<javascript><angularjs><unit-testing><rxjs5>","0","1","","","","CC BY-SA 3.0"
"45383857","1","45405933","","2017-07-28 23:49:53","","7","1998","<p>I am trying to build an infinitely scrolling list using TypeScript and rxjs.  That is, I want the application to fetch few pages of results from the backend, then fetch more results whenever the user scrolls near the bottom.</p>

<p>I have an Observable, built with <code>Observable.prototype.expand()</code>, which will give me all results, eventually fetching all pages from the server.  However due to the nature of Observable, I cannot pause this process. Once I subscribe it will inevitably fetch all results as fast as possible.  I need a different solution, where I can pull from the stream of results at the speed I need.</p>

<p>Things are made more complicated by the fact, that I cannot fetch the second page from the API directly, every page contains the info I need to fetch the next one. A reply looks like this:</p>

<pre><code>interface GraphApiResponse {
    data?: any[];
    paging?: {
        cursors: {
            before: string,
            after: string
        },
        next?: string,
        previous?: string
    };
}
</code></pre>

<p>The presence of the <code>paging.next</code> indicates there is another page and <code>paging.cursors.after</code> is used to actually retrieve it.</p>

<p>I cannot seem to figure out how to implement this, without making it messy.  However, an infinite list seems like such a common problem, that it is unlikely there would not be a good solution for it.  How should I go about implementing this, without turning the thing into a mess?</p>

<h1>Things I have tried</h1>

<h2>Iterable of Promises</h2>

<p>My first thought was using an Iterable of Promises, however I do not know how many results I will get, forcing me to build an infinite <code>Iterable&lt;Promise&lt;Response?&gt;&gt;</code> whose Promises will all resolve to <code>undefined</code> after a certain point.  However since it is infinite I can't iterate over that normally (it would fill the entire available memory with Promises), actually using the results when they are in that form means getting every Promise in the resolve function of the previous one.</p>

<p>This solution seems like it might work, but with every line I write it gets less readable and more complex.</p>

<h2>Merging it in with a behavior subject</h2>

<p>While googling on the issue I found <a href=""https://stackoverflow.com/questions/35343183/rxjs-control-observable-invocation"">a related SO question</a> as well as <a href=""https://github.com/ReactiveX/rxjs/issues/71"" rel=""noreferrer"">a GitHub issue on rxjs backpressure</a>, both contain code snippets by Ben Lesh, that can apparently be used to add backpressure to an Observable, sadly, no matter what I try, I cannot get the source Observable to emit it's values slower than it generates them, they always just get buffered somewhere, which means, that the network requests will happen no matter what.</p>

<p><strong>From GitHub:</strong></p>

<pre><code>// this behavior subject is basically your ""give me the next batch"" mechanism.
// in this example, we're going to make 5 async requests back to back before requesting more.
const BATCH_SIZE = 5;
const requests = new BehaviorSubject(BATCH_SIZE); // start by requesting five items

// for every request, pump out a stream of events that represent how many you have left to fulfill
requests.flatMap((count) =&gt; Observable.range(0, count).map(n =&gt; count - n - 1))
  // then concat map that into an observable of what you want to control with backpressure
  // you might have some parameterization here you need to handle, this example is simplified
  // handle side effects with a `do` block
  .concatMap(() =&gt; getSomeObservableOfDataHere().do(stuffWithIt), (remaining) =&gt; remaining)
  // narrow it down to when there are no more left to request,
  // and pump another batch request into the BehaviorSubject
  .filter(remaining =&gt; remaining === 0)
  .mapTo(BATCH_SIZE)
  .subscribe(requests);
</code></pre>

<p><strong>From StackOverflow:</strong></p>

<pre><code>// start with 5 values
const controller = new Rx.BehaviorSubject(5);

// some observable source, in this case, an interval.
const source = Rx.Observable.interval(100)

const controlled = controller.flatMap(
      // map your count into a set of values
      (count) =&gt; source.take(count), 
      // additional mapping for metadata about when the block is done
      (count, value, _, index) =&gt; {
        return { value: value, done: count - index === 1 }; 
      })
      // when the block is done, request 5 more.
      .do(({done}) =&gt; done &amp;&amp; controller.next(5))
      // we only care about the value for output
      .map(({value}) =&gt; value);


// start our subscription
controlled.subscribe(x =&gt; {
  console.log(x)
});
</code></pre>

<p>I might be wrong about this, but it seems to me, that once I subscribe to an Observable it produces its values as fast as possible, with no way to slow it down, so this is probably not a solution.</p>

<h2>Using ixjs</h2>

<p>It seems that <a href=""https://github.com/Reactive-Extensions/IxJS"" rel=""noreferrer"">ixjs</a> is meant to be a solution to my problem, however that repository has not been updated in a long time.  There apparently is <a href=""https://github.com/ReactiveX/IxJS"" rel=""noreferrer"">a reimplementation in TypeScript</a>, however that seems to be early in development and not well documented jet.</p>

<p>I would rather not depend on a framework used by so few people for what is actually a very simple problem.</p>

<h2>Refactoring the app</h2>

<p>I have searched online for implementations of an infinite scrolling list in TypeScript (with Angular).  My current approach is having a Service, that provides an Object, that can be used to get all the results. Then I have a Component showing them.  Alternatives seem to be <a href=""http://blog.brecht.io/infinite-scroll-with-rxjs-and-angular2/"" rel=""noreferrer"">doing the checking for scroll position right in the service that queries the backend</a>, or <a href=""https://codeburst.io/angular-2-simple-infinite-scroller-directive-with-rxjs-observables-a989b12d4fb1"" rel=""noreferrer"">having the component fetch a new Observable from the backend service when the user scrolls</a>.</p>

<p>Both solutions would force me to mix code, that is currently neatly separated.  I would prefer having the Service return something, that I can just feed into the Component, without the Component having to know about network requests, or the Service having to know about scroll position.</p>
","8380968","","8380968","","2017-07-30 14:41:32","2017-07-31 00:10:08","Building an infinite scrolling list in typescript with rxjs5","<typescript><rxjs><rxjs5>","2","2","4","","","CC BY-SA 3.0"
"45388853","1","","","2017-07-29 11:41:14","","4","3774","<p>Trying to execute the following code that is supposed to :</p>

<ul>
<li>Retrieve a list of all the chats of a user</li>
<li>retrieve last message for all these chats</li>
<li>Retrieve recipients info for all these chats</li>
<li><p>Merge all together as an array in which each item is a combination of a chat, last message and recipient info</p>

<pre><code> this.msgService.getUserChatList(this.uid).do((chats) =&gt; {
    this.chats = [];
    if (!(chats.length &gt; 0))
      this.loading = false;
    this.getLastMessages$ = this.getLastMessagesForChats(chats);
    this.getRecipients$ = this.getRecipientsForChats(chats);
}).switchMap( chats =&gt; Observable.from(chats) ).withLatestFrom(
   this.getLastMessages$,
   this.getRecipients$,
   (chat, lastMessages, recipients) =&gt; ({
     chat: chat,
     last: lastMessages[chat['id']],
     recipient: recipients[chat['id']]
    })
).subscribe( chats =&gt; {
  console.log('chats ', chats);
  this.chats.push(chats);
  this.loading = false;
});
</code></pre></li>
</ul>

<p>Additional functions</p>

<pre><code>getLastMessagesForChats(chats: any): Observable&lt;any[]&gt; {
    let lastMessages$ = [];
    for (let chat of chats) {
      let obs = this.msgService.getLastMessage(chat.id)
        .map( last =&gt; ({chat: chat.id, last: last}) );
      lastMessages$[chat.id] = obs;
    }
    return Observable.from(lastMessages$).merge().toArray();
  }

  getRecipientsForChats(chats: any): Observable&lt;any[]&gt; {
    let recipients$ = [];
    for (let chat of chats) {
      let obs = this.userService.getUserPublicInfo(chat.recipient)
        .map( recipient =&gt; ({chat: chat.id, recipient: recipient}) );
      recipients$[chat.id] = obs;
    }
    return Observable.from(recipients$).merge().toArray();
  }
</code></pre>

<p>I am getting the following error</p>

<pre><code>Uncaught (in promise): TypeError: Cannot read property 'subscribe' of undefined
    TypeError: Cannot read property 'subscribe' of undefined
</code></pre>

<p>I cannot find what is going wrong... I tried to reproduce in the following <a href=""http://jsbin.com/qeqidodivu/10/edit?js,console"" rel=""nofollow noreferrer"">JSBIN</a></p>

<p>Any idea?</p>
","6650388","","4826457","","2017-07-29 11:46:35","2017-07-29 12:43:57","Use of rxjs withLatestFrom function","<rxjs><observable><rxjs5>","1","0","0","","","CC BY-SA 3.0"
"45394118","1","45397867","","2017-07-29 21:14:43","","2","128","<p>I'm new to RxJS so my terminology may not be concise, sorry. I created derived Observable with <strong>map()</strong> and want it to keep passing it's source values through itself along with additional events on top of that. For example:</p>

<pre><code>//receiving values from server:
const $source = new Rx.Subject;

//map from network representation to client one:
const $client = $source.map( server =&gt; server.x + server.y );
//display on screen:
$client.subscribe( client =&gt; console.log( ""client:"", client ) )

//have input to update client-side representation:
const $button = new Rx.Subject;
$button.subscribe( $client );

$button.next( { x : 1, y : 2 } );
</code></pre>

<p>Sadly, it prints ""3"" instead of Object as if <strong>$button</strong> sends events directly to <strong>$source</strong> instead of <strong>$client</strong>. Why does <strong>$button.next(...)</strong> emits to <strong>$source</strong> instead of emitting to <strong>$client</strong>? I expected an operator (<strong>map()</strong> in this case) to spawn new stream. How can I implement a local cycle still making it dependent on original stream, but without modifying that original stream? Thanks in advance.</p>
","322513","","","","","2017-07-30 10:08:35","next() to intermediate Observable","<javascript><rxjs><reactive-programming><rxjs5>","2","0","","","","CC BY-SA 3.0"
"45397028","1","","","2017-07-30 06:28:09","","1","1783","<p>I am new to angular and started leaning angular 4. Data not binding with <code>ngfor</code> directive on a component using the async pipe. Please help</p>

<p>user service uses HTTP request to get data from API:</p>

<p>user.service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http, Response, Headers, RequestOptions } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/catch';
import { User } from ""../Models/user"";

@Injectable()
export class UserService {
    constructor(private http: Http) { }

    get(url: string): Observable&lt;User[]&gt; {
        return this.http.get(url)
            .map(response =&gt; response.json() as User[])
            // .do(data =&gt; console.log(""All: "" + JSON.stringify(data)))
            .catch(this.handleError);
    }
    private handleError(error: Response) {
        console.error(error);
        return Observable.throw(error.json().error || 'Server error');
    }
}
</code></pre>

<p>Here i am using observable User[] interface for user list:</p>

<p>user.component.ts</p>

<pre><code>import { Component, OnInit, ViewChild } from '@angular/core';
import { UserService } from '../Services/user.service';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ModalComponent } from 'ng2-bs3-modal/ng2-bs3-modal';
import { User } from '../Models/user';
import { DBOperation } from '../Shared/enum';
import { Observable } from 'rxjs/Observable';
import { Global } from '../Shared/global';

@Component({
    templateUrl: 'app/Components/user.component.html'
})

export class UserComponent implements OnInit {
    @ViewChild('modal') modal: ModalComponent;
    users$: Observable&lt;User[]&gt;;
    user: User;
    msg: string;
    indLoading: boolean = false;
    userForm: FormGroup;
    dbops: DBOperation;
    modalTitle: string;
    modalBtnTitle: string

    constructor(private fb: FormBuilder, private userService: UserService) 
   { }

   ngOnInit(): void {
    this.userForm = this.fb.group({
        Id: [''],
        UserName: ['', Validators.required],
        Password: ['', Validators.required],
        FirstName: ['', Validators.required],
        LastName: ['', Validators.required],
        Gender: ['', Validators.required]
    });
    this.LoadUsers();
    }
    LoadUsers(): void {
        this.indLoading = true;
        this.users$ = this.userService.get('http://localhost:29712/api/userapi/');
        this.indLoading = false;
    }   
}
</code></pre>

<p>Template for the async pipe to subscribe observable users variable:</p>

<p>user.component.html</p>

<pre><code>&lt;div class='panel panel-primary'&gt;
    &lt;div class='panel-heading'&gt;
        User Management
     &lt;/div&gt;
     &lt;div class='panel-body'&gt;
         &lt;div class='table-responsive'&gt;
        &lt;div class=""alert alert-info"" role=""alert"" *ngIf=""indLoading""&gt;&lt;img src=""../../images/loading.gif"" width=""32"" height=""32"" /&gt; Loading...&lt;/div&gt;
        &lt;div *ngIf='users &amp;&amp; users.length==0' class=""alert alert-info"" role=""alert""&gt;No record found!&lt;/div&gt;
        &lt;table class='table table-striped' *ngIf='users &amp;&amp; users.length'&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;First Name&lt;/th&gt;
                    &lt;th&gt;Last Name&lt;/th&gt;
                    &lt;th&gt;Gender&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;tr *ngFor=""let user of users$ | async""&gt;
                    &lt;td&gt;{{user.FirstName}}&lt;/td&gt;
                    &lt;td&gt;{{user.LastName}}&lt;/td&gt;
                    &lt;td&gt;{{user.Gender}}&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div *ngIf=""msg"" role=""alert"" class=""alert alert-info alert-dismissible""&gt;
        &lt;button type=""button"" class=""close"" data-dismiss=""alert"" aria-label=""Close""&gt;&lt;span aria-hidden=""true""&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
        &lt;span class=""glyphicon glyphicon-exclamation-sign"" aria-hidden=""true""&gt;&lt;/span&gt;
        &lt;span class=""sr-only""&gt;Error:&lt;/span&gt;
        {{msg}}
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p></p>
","4578578","","598203","","2018-03-18 22:48:25","2018-03-18 22:48:25","async pipe with observable in angular 4","<angular><observable><rxjs5>","2","11","1","","","CC BY-SA 3.0"
"45397867","2","","45394118","2017-07-30 08:27:09","","2","","<p>The result you are seeing is expected, and what you are trying to achieve is not possible.</p>

<blockquote>
  <p>I expected an operator (map() in this case) to spawn new stream.</p>
</blockquote>

<p>This is correct, <strong>however</strong> the newly spawned stream is an extension to <code>source$</code>, so:</p>

<pre><code>$client = $source + map
// this means any data injected into client$
// will walk through an instance of source$ and then through the map-function
</code></pre>

<p>I know, this only explains the behavior, and does not provide a ""solution"" - however, to properly provide a good answer that <em>solves</em> your issue, you should write something about what you are trying to achieve - unless all you wanted was to understand why it was this way.</p>

<p>Also: The way it is currently structured looks really overly complicated and i'm sure this could be simplified if you provided some information on the usecase.</p>
","1518765","","","","","2017-07-30 08:27:09","","","","4","","","","CC BY-SA 3.0"
"45400444","1","45408560","","2017-07-30 13:42:36","","3","4697","<p>I've created a authentication service which components can subscribe to permission changes (login/logout/role change ,etc).
In isAuthenticated function, I'm returning a subject.
The problem is that I want to return the subject with a value (like Observable.of. For now, I'm using setTimeout.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>@Injectable()
export class AuthenticationService {
  constructor(private credentials: CredantialsStorageService,
    private oauthService:OAuth2Service,
    private secureHttp: SecureHttpService) {}
  
  private isAuthenticatedSubject: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();

  login(email:string, password: string, remember?:boolean ): Observable&lt;boolean&gt; {
      return this.oauthService.login(email, password)
        .flatMap(() =&gt; this.getAndStoreUserCredantials())
        .map((userCredantials: any) =&gt;  {
          this.isAuthenticatedSubject.next(true);
          return true;
        })
 
  }

  logout(): Observable&lt;void&gt; {
    return this.secureHttp.post('/logout', null)
      .finally(() =&gt; {
        this.credentials.clear();
        this.oauthService.clear();
        this.isAuthenticatedSubject.next(false);
      })
      .map(() =&gt;  null);
  }

  isAuthenticated(): Observable&lt;boolean&gt; {
    setTimeout(() =&gt; { //Hack - find a way to change this
      this.isAuthenticatedSubject.next(this.oauthService.isAuthenticated());
    })
    return this.isAuthenticatedSubject;
  }

  private getAndStoreUserCredantials() {
    return this.secureHttp.get('/user/info')
      .map((res:Response) =&gt; {
        let userCredantials = res.json();
        this.credentials.set(userCredantials);
        return userCredantials;
      })
  }
}</code></pre>
</div>
</div>
</p>
","3554268","","","","","2017-07-31 06:10:07","RxJS - Return subject with value","<angular><rxjs><rxjs5>","3","1","","","","CC BY-SA 3.0"
"45401304","1","","","2017-07-30 15:12:03","","5","1355","<p>Trying to make a DataSource for angular2 material table using ngrx store. <a href=""https://material.angular.io/components/table/examples"" rel=""nofollow noreferrer"">https://material.angular.io/components/table/examples</a> In the sort example they access the _exampleDatabase data directly when either the sort or data changes. Using ngrx the data cannot be accessed directly so I am trying to use rxjs operators to sort the data.  </p>

<pre><code>export class ExampleDataSource extends DataSource&lt;any&gt; {
    constructor(private _sort: MdSort, private _storeData$: Observable&lt;UserData[]&gt;) {}

    connect(): Observable&lt;UserData[]&gt; {
        return Observable.combineLatest(this._storeData$, this._sort.mdSortChanage, 
            (data, sort) =&gt; {
                 // sorting logic here
                 return data;
            })
    }
</code></pre>

<p>This works fine once I change the sort order or dispatch a new event to change the user data in the store. I need to get the initial data from each to display. Is there an rxjs operator I am missing to make this happen? Or is there another better approach for this scenario.  </p>

<p>I have tried using withLatestFrom and startWith but both were unsuccessful.  </p>

<p>Thanks!  </p>

<p>Edit: Added a plunkr that shows the issue <a href=""http://plnkr.co/edit/5HOJSKKmdCuns2kvSirS?p=preview"" rel=""nofollow noreferrer"">http://plnkr.co/edit/5HOJSKKmdCuns2kvSirS?p=preview</a> on main.ts. When removing the eventEmitter from the combineLatest call then the expected message prints. Since mdSort doesn't emit an event until clicked this is probably causing my issue. </p>

<p>Edit2: See Sergey comment below for solution. Working plunkr is also in comments since my reputation isn't high enough to post 2 links. Since the event emitter did not output at least one value, I needed to add startWith on the event emitter and it worked. </p>
","3746327","","3746327","","2017-07-31 14:41:56","2017-07-31 14:41:56","Angular event emitter with combineLatest initial value","<angular><rxjs5><angular-material2>","0","5","","","","CC BY-SA 3.0"
"45404428","2","","45368394","2017-07-30 20:34:02","","0","","<p>For <code>retry</code> operator to take effect, its source observable has to produce an error. And it seems that in your example the error notification never reaches <code>retry</code> as it gets swallowed by the <code>catch</code> operator which recovers from the error.</p>

<p>To make it work, you may try to make the <code>catch</code> operator return an observable that first emits an action and then produces an error:</p>

<pre><code>const connectToSocket = action$ =&gt;
    actions$.ofType(CONNECT_TO_SOCKET)
        .switchMap(() =&gt; socketObservable
            .catch(error =&gt; Observable.of(error).concat(Observable.throw(error)))
        )
        .retry();
</code></pre>

<p><strong>Update:</strong></p>

<p>I think it is worth mentioning that <code>Rx</code> follows the grammar <code>next* (complete|error)?</code>, meaning that <code>next()</code> calls that come after the <code>error()</code> on the same observer will have no effect. So, if the <code>socket</code> recovers from the error and executes <code>onOpen</code> callback after it has executed <code>onError</code>, the <code>SOCKET_CONNECTED</code> notification will not reach the consumer.</p>

<p>This could be possibly handled by either replacing <code>error</code> with <code>next</code> notifications or restarting the <code>socketObservable</code> each time an error occurs, meaning that a new <code>socket</code> instance would be created (but this is probably not what you want).</p>

<p>Here's a runnable code sample demonstrating how <code>retry</code> might work:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { createStore, applyMiddleware } = Redux;
const { createEpicMiddleware } = ReduxObservable;

const socketObservable = Rx.Observable.create(observer =&gt; {
    const t1 = setTimeout(() =&gt; observer.next({ type: ""SOCKET_CONNECTED"" }), 200);
    const t2 = setTimeout(() =&gt; observer.error({ type: ""SOCKET_ERROR"" }), 400);

    return () =&gt; {
        clearTimeout(t1);
        clearTimeout(t2);
    };
})

const connectToSocket = action$ =&gt; action$
    .do(action =&gt; console.log(action))
    .ofType(""CONNECT_TO_SOCKET"")
    .switchMap(() =&gt; socketObservable
        .catch(error =&gt; Rx.Observable.of(error).concat(Rx.Observable.throw(error)))
        // make 2 attempts to re-connect, i.e. restart socketObservable
        .retry(2)
    )
    // recover in case if both attempts to reconnect have failed
    .retry();

const store = createStore(
    (state, action) =&gt; state,
    applyMiddleware(createEpicMiddleware(connectToSocket)));

// dispatch CONNECT_TO_SOCKET two times
Rx.Observable.interval(2000)
    .take(2)
    .subscribe(x =&gt; store.dispatch({ type: ""CONNECT_TO_SOCKET"" }));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.4.2/bundles/Rx.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://unpkg.com/redux@3.7.2/dist/redux.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://unpkg.com/redux-observable@0.14.1/dist/redux-observable.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1463575","","1463575","","2017-08-02 07:29:33","2017-08-02 07:29:33","","","","4","","","","CC BY-SA 3.0"
"45405933","2","","45383857","2017-07-31 00:10:08","","8","","<p>I would suggest that you use look at the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeScan"" rel=""noreferrer""><code>mergeScan</code></a> operator instead. It seems like it might be a good fit here. </p>

<p><code>MergeScan</code> is similar to the <code>expand</code> operator in that it feed the data from the previous request back in as an accumulator but unlike <code>expand</code> it doesn't continue running until the end of time.</p>

<p>Basically assuming that you have a function <code>makeRequest(params)</code> which takes a request and returns an <code>Observable</code> that eventually resolves to a response and a stream represent scroll events which we will call <code>fetchMore$</code>, you can create a fetch-on-demand service like so:</p>

<pre><code>// This is abstracted as a simple ""fetch"" concept but in reality should
// be hooked up to your scroll handler, properly debounced etc.
this.fetchMore$
  .mergeScan(
    // Make the request
    (acc, _) =&gt; makeRequest(acc.paging.next ? acc.paging.cursors.after : ''),
    {paging: {}}, // Initial request body
    1 // Maximum concurrency, i.e. how many requests can be in flight at once 
  )
  .pluck('data')
  .subscribe(data =&gt; {/*Do something with the data*/});
</code></pre>

<p>I set the concurrency to 1 because while you could have multiple requests in flight, there is currently no guarantee of order, so the result could be that the acc gets out of sync if the user is scrolling really fast, whereas with a concurrency of 1 the data will always be ordered.</p>
","2521865","","","","","2017-07-31 00:10:08","","","","1","","","","CC BY-SA 3.0"
"45408560","2","","45400444","2017-07-31 06:10:07","","2","","<p>I think the easiest way to do this is using the <code>startWith()</code> operator:</p>

<pre><code>isAuthenticated(): Observable&lt;boolean&gt; {
    return this.isAuthenticatedSubject.startWith(this.oauthService.isAuthenticated());
}
</code></pre>

<p>You could also use <code>BehaviorSubject</code> or <code>ReplaySubject</code> but these only repeat a value that went through them already. Maybe also have a look at this answer for more detailed description what's the difference: <a href=""https://stackoverflow.com/questions/45302580/does-startwith-operator-turns-observable-into-replaysubject1/45302786#45302786"">Does startWith() operator turns Observable into ReplaySubject(1)?</a>.</p>
","310726","","","","","2017-07-31 06:10:07","","","","0","","","","CC BY-SA 3.0"
"45439522","1","","","2017-08-01 13:40:10","","1","455","<p>I have a angular 4 app. In this app I have a paypal service, which does some server work and navigates (from client) to paypal.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code> 
@Injectable()
export class PaypalService {
  private readonly http: HttpApi;

  constructor(private readonly httpFactory: HttpFactoryService) { 
    this.http = httpFactory.get(HttpRequestType.Secured);
  }

  checkout(transactionId: string):
   Observable&lt;Response&gt; {
    let subscriber = this.http.post(environment.paymentServer + '/pay', {transactionId: transactionId})
    subscriber.subscribe((response:Response) =&gt; {
        let result = response.json();
        window.location.href = result.paymentUrl;
    });
    return subscriber;
  }
}</code></pre>
</div>
</div>
</p>

<p>I want the window.location.href will be called only after all subscribers was notified.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>paypal.checkout(""1234"").subscribe(() =&gt;
//This code should be called before the navigation will start
doSomeCleaning())</code></pre>
</div>
</div>
</p>

<p>I know I can use delay, but I was wondering if there is a better option.</p>
","3554268","","","","","2017-08-01 14:51:46","RxJs - Subscribe to observable at last place","<angular><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"45457078","1","","","2017-08-02 09:37:22","","8","13383","<p>Just as the title says, in Angular 2, is there any way to check if source is already subscribed? Because I have to check it before using </p>

<pre><code>this.subscription.unsubscribe();
</code></pre>

<p>This is my code:</p>

<pre><code>this.Source = Rx.Observable.timer(startTime, 60000).timeInterval().pluck('interval');

this.Subscription = this.Source
  .subscribe(data =&gt; { something }
</code></pre>

<p>and then I want to be sure that it is subscribed before calling <code>unsubscribe()</code></p>
","","user8090896","","user8090896","2017-08-02 09:58:44","2020-01-26 16:00:30","Is there any way to check if source is subscribed?","<javascript><angular><typescript><rxjs5>","4","3","1","","","CC BY-SA 3.0"
"45470789","1","45470931","","2017-08-02 20:52:23","","1","7011","<p>I'm newbie in RxJS world and I have a problem with unit-test for one of my method. </p>

<p>In my Angular componen I have a <code>login</code> method - inside I just call method from service. Method inside service returns Observable to component. Here you can see piece of code:</p>

<pre><code>public login(username: string, password: string): void{
    this.authService.login(username, password) //this return Observable in real world
            .catch(() =&gt; {
                this.formErrors['general.error'] = true;
                return Observable.throw('error! :&lt;');
            })
            .subscribe(() =&gt; {
                this.router.navigate(['/someRoute']);
            });
}
</code></pre>

<p>As you can see it is very simple method (in real app it'll be a little more comlicated but is isn't important now) and now I'm trying to write a unit test (in Jasmine):</p>

<pre><code>    it('', () =&gt; {
        authService.login.and.returnValue(Observable.throw('')); //authService is my mock
        component.login('u', 'p');
        expect(component.formErrors['general.error']).toBeTruthy();
    });
</code></pre>

<p>But I get error becauseI thrown error from <code>catch</code> section:
<code>login.component login  FAILED (error! :&lt; thrown)</code></p>

<p>What I'm doing wrong? </p>

<p>P.S.
I've tried to add <code>expect(component.login).toThrow();</code> but without success...</p>
","3117812","","","","","2017-08-02 21:01:35","Angular - test method with observable .catch block","<angular><unit-testing><rxjs><rxjs5>","1","5","","","","CC BY-SA 3.0"
"45470931","2","","45470789","2017-08-02 21:01:35","","2","","<p>Instead of calling <code>component.login('u', 'p')</code> directly, try to have the test runner do it.</p>

<pre><code>it('', () =&gt; {
    authService.login.and.returnValue(Observable.throw('')); //authService is my mock

    expect(component.login.bind(component, 'u', 'p')).toThrow(...);
    expect(component.formErrors['general.error']).toBeTruthy();
});
</code></pre>
","5854178","","","","","2017-08-02 21:01:35","","","","5","","","","CC BY-SA 3.0"
"45476902","1","45478765","","2017-08-03 06:52:50","","7","7645","<p>In short:
How to proceed listening after an error in stream without putting a <code>.catch</code> before every <code>.subscribe</code>?</p>

<p>If you need more details they are here:</p>

<p>Lets assume I have a Subject of current user or null. I get the data from API sometimes and send to the Subject. It updates the view accordingly.
  But at some point error occurs on my server and I want my application to continue working as before but notify some places about the error and KEEP listening to my Subject.</p>

<p>Initially I thought that if I just do <code>userSubject.error(...)</code> it will only trigger <code>.catch</code> callback and <code>error</code> handlers on subscribes and skip all success handlers and chains.
  And if after I call <code>userSubject.next(...)</code> all my chains and subscribers will work as before</p>

<p>BUT unluckily it is not the case. After the first uncaught <code>.error</code> it unsubscribes subscribers from the stream and they do not operate any more.</p>

<p>So my question: Why???
And what to do instead if I want to handle <code>null</code> value normally but also handle errors only in some places?</p>

<p>Here is the link to RxJs source code where Subscriber unsubscribes on error
<a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L140"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Subscriber.ts#L140</a></p>
","2772394","","","","","2017-09-23 16:52:42","Why does Rxjs unsubscribe on error?","<rxjs><rxjs5>","2","0","3","","","CC BY-SA 3.0"
"45478765","2","","45476902","2017-08-03 08:26:46","","15","","<p><code>Rx</code> observables <a href=""http://reactivex.io/rxjs/manual/overview.html#executing-observables"" rel=""noreferrer"">follow the grammar</a> <code>next*(error|complete)?</code>, meaning that they can produce nothing after <code>error</code> or <code>complete</code> notification has been delivered.</p>
<p>An explanation of why this matters can be found from <a href=""https://github.com/Reactive-Extensions/RxJS/tree/master/doc/designguidelines#31-the-rxjs-grammar"" rel=""noreferrer"">Rx design guidelines</a>:</p>
<blockquote>
<p>The single message indicating that an observable sequence has finished ensures that consumers of the observable sequence can deterministically establish that it is safe to perform cleanup operations.</p>
<p>A single failure further ensures that abort semantics can be maintained for operators that work on multiple observable sequences.</p>
</blockquote>
<p>In short, if you want your observers to keep listening to the subject after a server error has occurred, do not deliver that error to the subject, but rather handle it in some other way (e.g. use <code>catch</code>, <code>retry</code> or deliver the error to a dedicated subject).</p>
","1463575","","-1","","2020-06-20 09:12:55","2017-08-03 08:26:46","","","","1","","","","CC BY-SA 3.0"
"45478830","1","45478982","","2017-08-03 08:29:14","","1","426","<p>I am trying to use <code>Observable.if</code> in redux-observable to determine which action to dispatch.</p>

<p>In the case below, I expected it dispatch <code>SIGN_OUT</code>. However, it does not dispatch any action. </p>

<p>How can I use it correctly? Thanks</p>

<pre><code>export const initEpic = (action$, store) =&gt;
  action$
    .ofType(INIT)
    .mergeMap(() =&gt;
      Observable.if(
        () =&gt; true,
        { type: SIGN_OUT },
        { type: START_SOMETHING }
      ));
</code></pre>
","2000548","","2000548","","2017-08-03 09:02:15","2017-08-03 09:02:15","How to use Observable.if correctly in redux-observable?","<reactjs><rxjs><react-redux><rxjs5><redux-observable>","1","0","0","","","CC BY-SA 3.0"
"45478982","2","","45478830","2017-08-03 08:36:01","","1","","<p>The two parameters to <code>Observable.if</code> should be Observables so you should be using it like:</p>

<pre><code>Observable.if(
  () =&gt; true,
  Observable.of({ type: SIGN_OUT }),
  Observable.of({ type: START_SOMETHING })
));
</code></pre>
","310726","","","","","2017-08-03 08:36:01","","","","0","","","","CC BY-SA 3.0"
"45479619","1","","","2017-08-03 09:04:33","","2","16","<p>I have a subject</p>

<pre><code>const subj$$ = new Rx.Subject();
</code></pre>

<p>and late subscriber </p>

<pre><code>subj$$.next('value');

setTimeout(() =&gt; {
  subj$$.subscribe(console.log, console.error);
}, 500);
</code></pre>

<p>as expected nothing happens after 500ms</p>

<p>BUT...</p>

<p>if I throw error </p>

<pre><code>subj$$.error('error');

setTimeout(() =&gt; {
  subj$$.subscribe(console.log, console.error);
}, 500);
</code></pre>

<p>late observer handles this error!!!</p>

<p>Why?
I think it is logical to have consistent behaviour for late observers.
And do not notify them but it is not the case</p>
","2772394","","","","","2017-08-03 09:04:33","Why does subscriber hear old error on a Subject?","<rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"45488809","1","","","2017-08-03 15:38:14","","0","128","<p>I've got an otherwise fairly standard SPA built on Angular 4 interfacing with a REST API. </p>

<p>Whenever the app performs a write operation to the API (put/post/delete), I want to abort all read operations (get).</p>

<p>I know I can achieve this via the takeUntil operator. </p>

<pre><code>const write$ = new Subject&lt;Date&gt;();
public get(): Observable&lt;Response&gt; {
   return http.get().takeUntil(write$);
}

public update(): Observable&lt;Response&gt; {
   write$.next(new Date());
   return http.post();
}
</code></pre>

<p>What I want to do (and I'm struggling with) is expanding on this so that: </p>

<ol>
<li>Aborted read operations are re-executed once there are no active write operations.</li>
<li>Read operations submitted while a write operation is in progress are buffered (caused to wait) until there are no active write operations.</li>
</ol>

<p>The use case I think is pretty common.  Whenever the user modifies an entity, I update that entity's state immediately (as opposed to waiting for the write operation to complete). This makes the UI feel more responsive.  Read operations that are in-flight prior to the write, or that start after the write but complete before the write completes, result in the UI flipping the entity back to it's old state.</p>

<p>It is important that the mechanism for aborting/buffering/waiting on read operations be lossless.</p>

<p>***** <strong>UPDATE</strong> *****</p>

<p>I've come up with something that <em>appears</em> to be working, but it feels more complicated than I would like.  In addition to alternative solutions to the originally proposed problem, I would be interested in feedback on the following: </p>

<pre><code>class ApiService {
    private asyncDelay = 25;
    private wait$ = new BehaviorSubject&lt;Observable&lt;Date&gt;&gt;(new BehaviorSubject&lt;Date&gt;(new Date()));
    private read$ = new Subject&lt;Observable&lt;Response&gt;&gt;();
    private buffer$ = new ReplaySubject&lt;Observable&lt;Response&gt;&gt;(1);

    constructor() {    
        const flush$ = new Subject&lt;any&gt;();
        this.read$.bufferToggle(this.wait$, () =&gt; flush$)
            .do(x =&gt; console.warn('FLUSH: ' + x.length))
            .switchMap(items =&gt; Observable.from(items))
            .subscribe(this.buffer$);

        this.wait$.switchMap(resume$ =&gt; {
            console.warn('WAIT')
            return resume$.switchMap(() =&gt; {
                console.warn('RESUMED')
                flush$.next(new Date());
                return Observable.merge(this.buffer$, this.read$)
                    .mergeAll();
            });
        })
        .subscribe();
    }

    protected get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {         
        const abort$ = this.wait$
            .skip(1)
            .take(1)
            .publishReplay(1)
            .do(() =&gt; console.warn('ABORT'));        

        const source$ = this.http.get(url, options) 
            .takeUntil(abort$)           
            .publishReplay(1);

        const retry$ = abort$.switchMap(() =&gt; Observable.timer(this.asyncDelay)
            .switchMap(() =&gt; this.get(url, options)))
            .takeUntil(source$)
            .publishReplay(1);

        this.read$.next(new Observable((observer: Observer&lt;Response&gt;) =&gt; {
            source$.catch(err =&gt; Observable.of(err))
              .subscribe(observer);

            source$.connect();
        }));        

        return Observable.race(source$, retry$)
            .take(1);
  }

  protected put(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
        const resume$ = new ReplaySubject&lt;Date&gt;(1);
        this.wait$.next(resume$.delay(this.asyncDelay).take(1));
        return this.http.put(url, body, options)
            .finally(() =&gt; resume$.next(new Date()));
  }

}
</code></pre>

<p>The idea is that read operations [<code>get()</code>] are returned in a published/disconnected state until it is confirmed they are eligible to execute (there is no pending write operation).</p>

<p>The subscriptions in the constructor run for the life of the application. </p>

<p>Any write operation [<code>put()</code>] results in an emission by the wait$ stream.  The emission is a resume$ stream that will emit exactly once when the write operation that originated the wait$ emission completes. </p>

<p>Anytime the wait$ stream emits, the innermost subscription responsible for connecting read$ operations is halted - additionally the bufferToggled read$ subscription is opened.</p>

<p>switchMap from the wait$ stream to it's resume$ emission insures that the innermost subscription responsible for connecting read$ operations is not re-started until the write operation that halted the previous subscription is completed. </p>

<p>if a subsequent write operation occurs prior to the completion of the previous, the wait$ stream simply re-starts, ultimately waiting for the new resume$ signal.  As I type this I realize that one assumption being made is that write operations will behave in a somewhat LILO fashion when it comes to completion timings.  I think this is OK in my particular use case. </p>

<p>Once the last emitted resume$ stream emits, the buffer$ is flushed, closed and merged with a real-time stream of new read$ operations.</p>

<p>The source$ stream returned by a call to <code>get()</code> is wired up to terminate in the event a write operation begins during it's execution.  Additionally, I construct a retry$ stream that ultimately begins with an emission from the wait$ stream.  I race() the source$ and retry$ stream... they are mutually exclusive in this case - it's only possible for one of them to emit.  If the source$ is terminated, the same signal responsible for terminating it starts the retry$ sequence which recurses back into <code>get()</code> and ultimately results in the retry response being buffered until all write operations complete. </p>

<p>... and the cycle repeats. </p>

<p>I don't know much about the underpinnings of RXJS, or the overhead involved in gorilla taping all of these operators and streams together as a means to an end.  My biggest concern at this point is leaking memory somewhere, and obviously readability for poor soul who needs to modify it 12+ months from now. </p>
","2069563","","2069563","","2017-08-05 18:03:20","2017-08-05 18:03:20","Managing Stale HTTP Read Operations with RxJS 5 (Angular 4)","<angular><rxjs5><angular2-http>","0","5","","","","CC BY-SA 3.0"
"45495188","1","45520322","","2017-08-03 21:58:06","","18","20074","<p>What is the best way to handle multiple events on the same DOM node in rxjs 5.1?</p>

<p><code>fromEvent($element, 'event_name')</code> but I can specify only one event at a time.</p>

<p>I want handle <code>scroll wheel touchmove touchend</code> events.</p>
","3130446","","","","","2021-05-25 07:11:10","Rxjs, fromEvent to handle multiple events","<angular><rxjs5><rxjs-dom>","4","0","5","","","CC BY-SA 3.0"
"45520322","2","","45495188","2017-08-05 09:24:27","","50","","<p><em>Note: This is for RxJS v5. See bottom of this answer for the v6 and v7 equivalent.</em></p>
<hr />
<p>You can use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js%7EObservable.html#static-method-merge"" rel=""nofollow noreferrer""><code>Rx.Observable.merge</code></a> function to merge multiple observable streams into a single stream:</p>
<pre class=""lang-javascript prettyprint-override""><code>// First, create a separate observable for each event:
const scrollEvents$    = Observable.fromEvent($element, 'scroll');
const wheelEvents$     = Observable.fromEvent($element, 'wheel');
const touchMoveEvents$ = Observable.fromEvent($element, 'touchmove');
const touchEndEvents$  = Observable.fromEvent($element, 'touchend');

// Then, merge all observables into one single stream:
const allEvents$ = Observable.merge(
    scrollEvents$,
    wheelEvents$,
    touchMoveEvents$,
    touchEndEvents$
);
</code></pre>
<p>If that seems a little bloated, we might clean up a little by creating an array for the events, and then map that array to Observable objects. This works best <em>if</em> you do not need to reference the events their associated observables separately at some point:</p>
<pre class=""lang-javascript prettyprint-override""><code>const events = [
    'scroll',
    'wheel',
    'touchmove',
    'touchend',
];

const eventStreams = events.map((ev) =&gt; Observable.fromEvent($element, ev));
const allEvents$ = Observable.merge(...eventStreams);
</code></pre>
<p>You are now able to handle all events with one single subscription:</p>
<pre class=""lang-javascript prettyprint-override""><code>const subscription = allEvents$.subscribe((event) =&gt; {
    // do something with event...
    // event may be of any type present in the events array.
});
</code></pre>
<hr />
<p><strong>Update for RxJS v6 and v7</strong></p>
<p>Starting from RxJS 6 you can import the standalone <a href=""https://rxjs-dev.firebaseapp.com/api/index/function/merge"" rel=""nofollow noreferrer""><code>merge</code></a> and <a href=""https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent"" rel=""nofollow noreferrer""><code>fromEvent</code></a> functions equivalent to the static methods in v5, and use them the same way:</p>
<pre class=""lang-javascript prettyprint-override""><code>import { fromEvent, merge } from 'rxjs';

const scrollEvents = fromEvent($element, 'scroll');
// creating other input observables...

const allEvents$ = merge(
    scrollEvents$,
    wheelEvents$,
    touchMoveEvents$,
    touchEndEvents$
);
</code></pre>
","6361314","","6361314","","2021-05-25 07:11:10","2021-05-25 07:11:10","","","","1","","","","CC BY-SA 4.0"
"45531548","1","45531657","","2017-08-06 11:27:19","","2","2402","<p>I'm trying to return an Observable with a do statment.
for some reason the do statment is not invoked.
Any help will be appreicated:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code> public addTarget(video: VideoFile, language?: Language): Observable&lt;Language&gt; {
    if (!this.isTargetCollectionDeclared(video)) {
      video.metadata = video.metadata || &lt;BaseVideoData&gt;{};
      video.metadata.to = [];
    }

    let wasLanguageProvided = language != null;
    if (wasLanguageProvided) {
      video.metadata.to.push(language);
      return Observable.of(language);
    }

    return this._getDefaultFromAvilableLanguages(video)
        .do(languageOrNull =&gt; {
          // code is not reaching her
          if (languageOrNull != null) {
            video.metadata.to.push(languageOrNull)
          }
        })
  }</code></pre>
</div>
</div>
</p>
","3554268","","","","","2017-08-06 21:16:20","RXJS - Observable.do is not working","<angular><rxjs><rxjs5>","2","5","","","","CC BY-SA 3.0"
"45531657","2","","45531548","2017-08-06 11:40:45","","3","","<p>Observables are lazy, like functions. They won't run unless you subscribe to them, similarly to how functions won't execute until you call them.</p>

<p>Callback passed to <code>.do</code> will be executed once the observable is fired, which can happen only once you've subscribed to it.</p>
","2131286","","","","","2017-08-06 11:40:45","","","","7","","","","CC BY-SA 3.0"
"45546750","1","","","2017-08-07 12:20:11","","3","740","<p>I'm struggling on how to test the <code>retryWhen</code> operator in a <code>redux-observable epic</code>. Based on <a href=""http://jsbin.com/pufima/edit?js,output"" rel=""nofollow noreferrer"">this example</a> taken from <a href=""https://redux-observable.js.org/docs/recipes/WritingTests.html"" rel=""nofollow noreferrer"">docs</a>, I forked <a href=""http://jsbin.com/hekener/17/edit?js,console,output"" rel=""nofollow noreferrer"">this jsbin</a> where I'm trying to test the case where the response fails 2 times and after that it returns a valid response.</p>

<p>Below are some part of the code. For the whole implementation please use <a href=""http://jsbin.com/hekener/17/edit?js,console,output"" rel=""nofollow noreferrer"">this jsbin</a></p>

<pre><code>let RetryStrategy = attempts =&gt; attempts
    .zip(Observable.range(1, 4))
    .flatMap(([error, i]) =&gt; {
        if (i &gt; 3) {
            return Observable.throw('Network error occured')
        }
        return Observable.timer(i * 1000)
    })


const fetchFooEpic = (action$, store, call = indirect.call) =&gt;
    action$.ofType('FETCH_FOO')
        .mergeMap(action =&gt;
            call(api.fetchFoo, action.payload.id)
                .map(payload =&gt; ({ type: 'FETCH_FOO_FULFILLED', payload }))
                .retryWhen(RetryStrategy)
                .takeUntil(action$.ofType('FETCH_FOO_CANCELLED'))
                .catch(error =&gt; of({
                    type: 'FETCH_FOO_REJECTED',
                    payload: error.xhr.response,
                    error: true
                }))
        );

describe('fetchFooEpic', () =&gt; {
    ...
    it.only('handles errors correctly', () =&gt; {
        const badResponse = { message: 'BAD STUFF' };
        const response = { id: 123, name: 'Bilbo' };

        expectEpic(fetchFooEpic, {
            expected: ['-----a|', {
                a: { type: 'FETCH_FOO_FULFILLED', payload: response }
            }],
            action: ['(a|)', {
                a: { type: 'FETCH_FOO', payload: { id: 123 } }
            }],
            response: ['-#-#-a|', {
                a: response
            }, { xhr: { badResponse } }],
            callArgs: [api.fetchFoo, 123]
        });
    });
    ...

});
</code></pre>

<p>If you check the response in jsbin the actual action in always an <code>empty</code> array.</p>
","1055160","","","","","2018-03-09 21:23:44","RxJS Redux-Observables Test retryWhen inside an epic","<unit-testing><rxjs><rxjs5><redux-observable>","1","2","1","","","CC BY-SA 3.0"
"45573414","1","","","2017-08-08 16:21:19","","2","56","<p>I am creating a stream that will achieve this: </p>

<ul>
<li>get http data</li>
<li>get socket event and update initial http data every time socket event received</li>
<li>convert data to array for Angular's <code>ngFor</code></li>
</ul>

<p>This is what I have:</p>

<pre><code>this.subscription = this.http.get('httpService')
.switchMap(httpResult =&gt; this.socket.get('socketEvent')
        .scan((data, deltas) =&gt; {
            _.each(deltas, function (item) {
                switch (item.type) {
                    case 'a':
                        data.a_list[item.id].value = item.val;
                        break;
                    case 'b':
                        data.b_cells[item.id].value = item.val;
                        break;
                }
            });
            return data;
        }, httpResult)
        .startWith(httpResult)
)
//manipulates same object as scan operator?  
.map(data =&gt; Object.keys(data.a_list).map(k =&gt; data[k]))
.subscribe(data =&gt; {
    this.data = data;
});
</code></pre>

<p>Template:</p>

<pre><code>&lt;div *ngFor='let item of data'&gt;{{ item }}&lt;/div&gt;
</code></pre>

<p>All works fine the first time around, but on the second socket event inside the <code>scan</code> operator, the data has been converted to an array. It appears that the .<code>map</code> operator is manipulating the same object that the <code>scan</code> operator is. Is this right? </p>

<p>I was always under the impression that <code>scan</code> returned a new object and not the reference, which I assume is what's happening here. </p>

<p>If that is the case how can I convert a nested object inside the output of my stream into an array and still use <code>scan</code>?</p>
","2275792","","","","","2017-08-08 16:21:19","RxJS5: scan operator converting to array for ngFor","<angular><rxjs5>","0","0","","","","CC BY-SA 3.0"
"45579377","1","45579446","","2017-08-08 23:17:58","","1","70","<p>I need to call two http services and one socket. The first http call is to get meta data and set locally one of its values. Then, I need to call the second http service that returns initial values which are updated via a socket afterwards.</p>

<p>This is what I have so far:</p>

<pre><code>export class MyComponent implements OnInit {
    subscription: Subscription;
    title: string;
    prop1: number;
    prop2: number;

    constructor(private http: HttpService,
                private socket: SocketService,
                private route: ActivatedRoute) {
    }

ngOnInit() {
    this.prop1 = this.route.snapshot.parent.params['prop1'];
    this.subscription = this.http.get('/metaData')
        .do(data =&gt; {
            this.title = data.title;
            this.prop2 = data.prop2;
        })
        //this.prop2 is undefined in combineLatest...
        .combineLatest(
            this.http.get('initialData', { prop1: this.prop1, prop2: this.prop2 }),
            this.socket.get('updateEvents', { prop1: this.prop1, prop2: this.prop2 }),
            this.updateList)
        .subscribe(data =&gt; {
            this.data = data
        })

}       
</code></pre>

<p>I believe I am close, but it appears that the <code>combineLatest</code> operator is not accessing local vars as the <code>prop2</code> is <code>undefined</code>. Is this because I am doing a <code>side effect</code> in the <code>do</code> operator that prop2 is not seen by the <code>combineLatest</code> on time?</p>

<p>Note: If I were to use <code>switchMap</code>, prop2 works, like this:</p>

<pre><code>.switchMap(data =&gt; this.http.get('initialData', { prop1: this.prop1, prop2: this.prop2 }))
</code></pre>

<p>Why is prop2 <code>undefined</code> when using <code>combineLatest</code>?</p>
","2275792","","","","","2017-08-08 23:25:49","RxJS5 - combineLatest not accessing Angular's local properties","<angular><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"45579446","2","","45579377","2017-08-08 23:25:49","","1","","

<p>It's because the arguments passed to <code>combineLatest</code> are evaluated before <code>combineLatest</code> is called - and, therefore, before the <code>do</code> receives a next notification, etc.</p>

<p>You can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-defer"" rel=""nofollow noreferrer""><code>defer</code></a> to solve the problem:</p>

<pre class=""lang-ts prettyprint-override""><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/defer';

// ...

.combineLatest(
    Observable.defer(() =&gt; this.http.get('initialData', { prop1: this.prop1, prop2: this.prop2 })),
    Observable.defer(() =&gt; this.socket.get('updateEvents', { prop1: this.prop1, prop2: this.prop2 })),
    this.updateList
)

// ...
</code></pre>
","6680611","","","","","2017-08-08 23:25:49","","","","0","","","","CC BY-SA 3.0"
"45605333","1","45609256","","2017-08-10 05:43:26","","1","1045","<p>I am using Rxjs Observables to handle nested ajax request like the following way: </p>

<pre><code>Rx.Observable.fromPromise($.getJSON('list1.json'))
   .switchMap(function responseA(aResponse){
       /* processing aResponse*/
       if(aResponse.fileName){
          return Rx.Observable.fromPromise($.getJSON(aResponse.fileName));
       } 
       return Rx.Observable.fromPromise($.getJSON('list2.json'));
   })
   .subscribe(function(finalResponse){
      /* processing finalResponse */
   });
</code></pre>

<p>But, as you know, it can also be done without using  Observables and  with only promises:</p>

<pre><code>   $.getJSON('list1.json')
       .then(function responseA(aResponse){
           /* processing aResponse*/
           if(aResponse.fileName){
              return $.getJSON(aResponse.fileName);
           } 
           return $.getJSON('list2.json');
       })
       .then(function(finalResponse){
          /* processing finalResponse */
       });
</code></pre>

<p>Both code works, but it seems to me that it is more clean in terms of code to use promises.  </p>

<p>Am I missing something here as I've heart that Rx Observable is more standard and efficient to handle asynchronous requests.  </p>

<p>Which one (promise or Observable) will be the best in terms of code organization, convention and performances to handle ajax request ?</p>

<p>If I prefer to use Observable then which operators (switchMap/MergeMap) will be preferable in these kind of situation ?</p>
","1576255","","1576255","","2017-08-10 05:48:38","2017-08-12 07:23:46","Handling ajax request - Promise vs RxJs observable - rxjs operator preferences","<javascript><ajax><promise><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"45609256","2","","45605333","2017-08-10 09:10:21","","4","","<blockquote>
  <p>Am I missing something here as I've heart that Rx Observable is more standard and efficient to handle asynchronous requests.</p>
</blockquote>

<p>No, you're not missing anything. Rx is really useful but in that particular case promise based code is simpler. </p>

<p><strong>In general, if you need a singular value - prefer a promise</strong>. If you need multiple values in/out - use observables (or the further ahead in spec async iterators).</p>

<p>Rx would be nice if you want to quickly need to add:</p>

<ul>
<li>Retrying the requests if they failed (with Observable.defer).</li>
<li>Only caring about the last request.</li>
<li>If you need built in cancellation.</li>
</ul>

<p>It's worth mentioning - promises can do all that if you use a library. It's not a fundamental property of observables.</p>

<p>Rx really shines <em>if your input is more than a single call</em>. If you needed to make these calls whenever the user clicks something, ignore clicks on some condition, debounce it to 100ms and then only care about the last call - Rx would be really useful.</p>

<p>In this particular case - promises are simpler and fine. Your promise code can be simplified further:</p>

<pre><code>$.getJSON('list1.json').then(x =&gt; $.getJSON(x.fileName || 'list2.json'))
</code></pre>
","1348195","","","","","2017-08-10 09:10:21","","","","0","","","","CC BY-SA 3.0"
"45613936","2","","42333187","2017-08-10 12:36:19","","1","","<p>Thanks to Damian Hercun for informing that this was a now-fixed bug in RxJS 5.4.2.</p>
<blockquote>
<p>Info:</p>
<p><a href=""https://github.com/ReactiveX/rxjs/pull/1935"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/1935</a></p>
<p><a href=""https://github.com/ReactiveX/rxjs/issues/1921"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/1921</a></p>
</blockquote>
","536485","","-1","","2020-06-20 09:12:55","2017-08-10 12:36:19","","","","0","","","","CC BY-SA 3.0"
"45618451","1","45623396","","2017-08-10 15:59:49","","4","477","<p>Hellow, I'm trying to create function of observable (OBS) and subject(SUB) that stores last item from OBS, while SUB has F value,
and emit it (and only it) when SUN becomes T</p>

<pre><code>   OBS ---a----b----c----d----e----f----g----h-----
   SUB ------F----------T------------F-------T-----
   OUT -----------------c--------------------h-----
</code></pre>

<p>I tried to solve this with</p>

<pre><code>OBS.window(SUB)
        .withLatestFrom(SUB)
        .switchMap(([window, status]) =&gt; {

            if(status === F) {
                return window.combineLatest(SUB, (cmd, status) =&gt; {
                    if(status === T) {
                        return null;
                    };

                    return cmd;
                }).last((e) =&gt; {
                    return !!e;
                })
            }

            return Observable.empty&lt;Command&gt;();
        }).filter((cmd) =&gt; {
            return !!cmd;
        })
</code></pre>

<p>but it doesn't work</p>
","1801212","","","","","2017-08-11 12:39:47","RxJS function that emit last value from one observable then other emit true","<javascript><typescript><rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"45618872","1","45670904","","2017-08-10 16:20:03","","1","852","<p>I'm currently beggining with RxJs and trying to define modules returning observables. (each module works as a blackbox and only exposes its observables).
my main problem is due to the third party library I'm using : UWA :
All my dom elements are generated from UWA objects and trigger UWA ""events"".
BTW I want to map those custom events to observables.
here is a part of the event data structure :</p>

<pre><code>tabBar = *somecode*...{
....
  onEndEditTab: function (callback) {
    return this.modelEvent.subscribe({
      event: endEditTabEvent
    }, callback);
  },....
}
</code></pre>

<p>Here is my current code : </p>

<pre><code>const tabBar = new tabBar();
tabBar.inject(domContainer);
const observer={
  next: (t) =&gt;{
    const oldValue=t.target.textContent;
    const cbObservable = Rx.Observable.bindCallback(tabBar.onEndEditTab);
    //a new cbObservable is created at each dblclick event
    // (due to bindCallBack property which is to retern only one time.
    cbObservable .call(tabBar).subscribe(
      (v) =&gt; {
         console.log({oldLabel:oldValue,newLabel:v[0].button.label});
      }
    );          
Rx.Observable.fromEvent(tabBar, 'dblclick').subscribe(observer);
</code></pre>

<p>This code works and log the old and new value each time a tab label is edited.
But currently what I want instead of just printing this is to aggregate all those results into a new Observable stream.
using marble diagram : </p>

<pre><code>dblclick : ----(1)----(2)---....(n)-&gt;
</code></pre>

<p>(where there is an unknown number n of dblclick...)
is mapped to :</p>

<pre><code>cbObservable : ----(1:{old,new})--|
               ----(2:{old,new})--| 
               ....
               ----(n:{old,new})--|
</code></pre>

<p>And what I currently want is : </p>

<pre><code>outputStream : ----(1:{old,new})---(2:{old,new})--...(n:{old,new})---&gt;
</code></pre>

<p>where outputStream is an hot observable; 
is there a way of doing that with all constraints described above ?
thank you !</p>
","5664697","","5664697","","2017-08-16 08:34:55","2017-08-16 09:54:10","map multiple callback returns into observable using RxJs","<javascript><rxjs5>","2","0","","","","CC BY-SA 3.0"
"45623396","2","","45618451","2017-08-10 21:00:38","","2","","<p>So it seems like you want something like:</p>

<pre><code>SUB
  // Only emit changes in the status
  .distinctUntilChanged()
  // Only forward true values down stream
  .filter(t =&gt; t === T)
  // Only emit the latest from OBS when you get a T from SUB
  // Remap it so only cmd is forwarded
  .withLatestFrom(OBS, (_, cmd) =&gt; cmd)
</code></pre>
","2521865","","","","","2017-08-10 21:00:38","","","","0","","","","CC BY-SA 3.0"
"45631952","1","45634892","","2017-08-11 09:43:31","","0","1207","<p>I have an Observable variable :</p>

<pre><code>messages: Observable&lt;Message[]&gt;;
</code></pre>

<p>I would like to add variables to this Observable variable. Since this is a collection of Message: Message [], I would like to add Message variable to it :</p>

<pre><code>const newMessage = new Message(objMessage);
</code></pre>

<p>I do not see how to do this, I tried this but it dosen't work because it's for no-Observable variable: </p>

<pre><code>newThread.messages = [newMessage];
</code></pre>

<p>Or this : </p>

<pre><code>newThread.messages.subscribe((message: Message) =&gt; {
  newThread.messages = message;
});
</code></pre>

<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EDIT</p>

<p>I initialize my variable messages in my thread.model.ts : </p>

<pre><code>messages: Observable&lt;Message[]&gt; = new Observable&lt;Message[]&gt;();
</code></pre>

<p>And I initialize my variable newThread.messages in an other service chat.service.ts : </p>

<pre><code>newThread.messages.next(newMessage);
</code></pre>

<p>But it puts me this error : </p>

<pre><code>Property 'next' does not exist on type 'Observable&lt;Message[]&gt;'
</code></pre>

<p>Plunker Link : </p>

<pre><code>https://plnkr.co/edit/aNzWu2ShO55bk3fRJ5ya?p=catalogue
</code></pre>

<p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EDIT</p>

<p>I just realized that it does not work as I would like.
This does not work when there is more than one message. With what I had done, the second message deletes the first message. While I want the variable <em>thread.messages</em> to contain a stack of messages.</p>

<p>So I tried using the .next method, but that puts me in error.</p>

<pre><code>export class Thread {
  id: string;
  messages: BehaviorSubject&lt;Message[]&gt;;
}

const newThread: Thread = new Thread(objMessage.id, [newUser],objMessage.title);
const newMessage = new Message(objMessage);
newThread.messages.next([newMessage]);


Cannot read property 'next' of undefined ; Zone: &lt;root&gt; ; Task: Promise.then ; Value: TypeError: Cannot read property 'next' of undefined
</code></pre>

<p>Or this : </p>

<pre><code>private subject = new Subject&lt;Message[]&gt;();

this.subject.next([newMessage]);

thread.messages.subscribe((messages: Message[]) =&gt; {
   messages = this.subject.asObservable();
});
</code></pre>

<p>Do you know why ?</p>
","8435097","","8435097","","2017-08-17 19:49:53","2017-08-17 19:49:53","Add variables to a variable Observable <>","<angular><typescript><rxjs><rxjs5>","1","20","","","","CC BY-SA 3.0"
"45634892","2","","45631952","2017-08-11 12:08:41","","0","","<p>Use .next() method add data in observable stream data by adding a new behaviour subject</p>
","5861238","","","","","2017-08-11 12:08:41","","","","1","","","","CC BY-SA 3.0"
"45644662","1","","","2017-08-11 22:33:26","","2","89","<p>I'm trying to learn RxJS v5, and I saw <code>and</code> <code>when</code> and <code>thenDo</code> operators in the manual. I'm struggling to understand how they work.
<a href=""http://reactivex.io/documentation/operators/and-then-when.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators/and-then-when.html</a></p>

<p>I tried the following code to combine my 2 observables:</p>

<pre><code>this.ob1 = Rx.Observable.interval(500);
this.ob2 = Rx.Observable.interval(750);

this.combined = Rx.Observable.when(
    this.ob1.and(this.ob2).thenDo((first, second) =&gt; {
        return {first, second}
    })
);

this.combined.subscribe(e =&gt; console.log('observable ' + e));
</code></pre>

<p>However, I get the following error:
<code>TypeError: this.ob1.and is not a function</code></p>

<p>What am I doing wrong here? How are these operators supposed to be used? And what's the specific use case they would solve.</p>
","4098983","","","","","2017-08-11 22:33:26","How to use and, when & thenDo operators in RxJS","<javascript><rxjs5>","0","0","","","","CC BY-SA 3.0"
"45657881","1","45657932","","2017-08-13 06:50:43","","3","313","<p>When I was looking through the rxjs library I stumbled across this function:</p>

<pre><code>export function map&lt;T, R&gt;(this: Observable&lt;T&gt;, project: (value: T, index: number) =&gt; R, thisArg?: any): Observable&lt;R&gt; {
   if (typeof project !== 'function') {
     throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
   }
   return this.lift(new MapOperator(project, thisArg));
}
</code></pre>

<p>source: <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operator/map.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/operator/map.ts</a></p>

<p>I'm wondering what really happens when passing an argument named <code>this</code>.
Is it just treated like any other parameter or does typescript some special actions when you do this?</p>
","6938528","","","","","2017-08-13 07:14:17","typescript this as parameter","<typescript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45657932","2","","45657881","2017-08-13 06:56:19","","4","","<p>You cannot directly pass <code>map</code> an argument that corresponds to the <code>this</code> parameter in the signature. The <code>this</code> parameter is used by TypeScript to indicate the type for the context and there is no corresponding argument at runtime.</p>

<p>However, the <code>map</code> function can be called using <code>Function.prototype.call</code> or <code>Function.prototype.apply</code>, and the context can be passed to <code>call</code> or <code>apply</code>.</p>

<p>For example:</p>

<pre><code>import { of } from ""rxjs/observable/of"";
import { map } from ""rxjs/operator/map"";

const source = of(1);
const mapped = map.call(source, value =&gt; value + 1);
</code></pre>

<p>In this example, <code>source</code> would correspond to <code>this</code> in the implementation of <code>map</code>, and it would have the type <code>Observable&lt;number&gt;</code>.</p>

<p>For more information, see the ""<code>this</code> parameters"" section in the <a href=""https://www.typescriptlang.org/docs/handbook/functions.html"" rel=""nofollow noreferrer"">documentation</a>.</p>
","6680611","","6680611","","2017-08-13 07:14:17","2017-08-13 07:14:17","","","","0","","","","CC BY-SA 3.0"
"45668855","1","45669080","","2017-08-14 06:48:10","","2","182","<p>I'm relatively new to RxJs and am unable to chain a single operation after processing multiple items emitted using switchMap operator. </p>

<p>Scenario: use backend data to generate an object array for a dropdownlist, then chain a single operation to set the dropdown's selected value. </p>

<p>Here's the non-working code that helps illustrate the problem. </p>

<pre><code>this.sub = this.dataService.getUserData()
    .switchMap((data) =&gt; Observable.from(data)) // create new data stream from inner data set
    .map((data: any) =&gt; {
        return { value: data._id, viewValue: data.firstName + ' ' + data.lastName };
    }) // create data structure for drop down
    .subscribe( (data) =&gt; {
        this.userDropDown.push(data); // this operation needs to run once per item emitted, and is working
        this.patchFormData(); // &lt;-- However, this only needs to run once
    },
    (error) =&gt; console.log(""error"", error)
    );
</code></pre>

<p>I've tried various operators that morph the problem but am unable to solve the entirety of the issue i.e. a) get new object array based off the source data and b) run a single operation after completion.</p>

<p>Any help greatly appreciated. </p>

<p>Thank you,</p>

<ul>
<li>S. Arora</li>
</ul>

<p>--  UPDATE: working final version is here based on answer below with minor syntax fix:</p>

<pre><code>this.sub = this.dataService.getUserData()
    .map((data: any[]) =&gt; {
        return data.map((x: any) =&gt; {
            return { value: x._id, viewValue: x.firstName + ' ' + x.lastName };
        });
    })
    .subscribe((data: any) =&gt; {
        this.userDropDown = data;
        this.patchFormData();
    },
    (error) =&gt; console.log(""error"", error)
    );
</code></pre>
","6697664","","6697664","","2017-08-14 17:33:06","2017-08-14 17:33:06","run single operation in RxJS after mutliple items are processed","<javascript><arrays><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"45669080","2","","45668855","2017-08-14 07:05:02","","1","","<p>Actually, you do not need the <code>.switchMap()</code> at all. You are just creating multiple emissions using <code>Observable.from()</code>,which is completely unnecessary unless you really want to update your dropdown values one by one.</p>

<p>What you could do is just returning the array, use <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"" rel=""nofollow noreferrer""><code>.map()</code></a> to transform the array, and then assign it to your dropdown value list.</p>

<pre><code>this.sub = this.dataService.getUserData()
//this map is a function of Observable
    .map((data: any[]) =&gt; {
        //this map is a function of array, not observable.
        //use this to transform the data
        return data.map(x =&gt; ({value: x._id, viewValue: x.firstName + ' ' + x.lastName}))
    })
    .subscribe((data) =&gt; {
            //assign your values to your dropdown list, and not pushing it one by one.
            this.userDropDown = data;
            this.patchFormData();
        },
        (error) =&gt; console.log(""error"", error)
    );
</code></pre>

<p>Now, you only have one emission in your Observable (which is the api call), and then in your <code>.subscribe()</code> function, your <code>this.userDropDown</code> and <code>this.patchFormData()</code> will both only run once.</p>
","2829204","","2829204","","2017-08-14 07:25:55","2017-08-14 07:25:55","","","","3","","","","CC BY-SA 3.0"
"45670904","2","","45618872","2017-08-14 09:00:33","","0","","<p>try to use switchMap </p>

<pre><code>Rx.Observable.fromEvent(tabBar, 'dblclick').switchMap(() =&gt; {
    const oldValue=t.target.textContent;
    return Rx.Observable.bindCallback(tabBar.onEndEditTab).map((v) =&gt; {
       return {old: oldValue, new: v[0]}
    });
})
</code></pre>

<p>or something like this, then make single subscribtion to resulting observable</p>
","1801212","","","","","2017-08-14 09:00:33","","","","1","","","","CC BY-SA 3.0"
"45698656","1","45701710","","2017-08-15 17:55:26","","3","3937","<p>I would like to understand the .distinct operator in my use-case:</p>

<p>I do a search for a country via user input and want to show only one object with a specific content in a property called country.</p>

<p>Explanation:</p>

<p>I have a BehaviorSubject with the content of various objects:</p>

<pre><code>[
 {id:1, country: ""United Kingdom"", city:""London""},
 {id:2, country: ""United Kingdom"", city:""Manchester""},
 {id:3, country: ""Germany"", city:""Berlin""},
 ...
]
</code></pre>

<p>The type of the array is for example <code>loc[]</code>:</p>

<pre><code>interface loc {
  id: number;
  country: string;
  city: string;
}
</code></pre>

<p>This is the filtering via user input (called 'query' in the code below):</p>

<pre><code>BehaviorSubject
   .map(x =&gt; x.filter((l) =&gt; 
     l.country.toLowerCase().indexOf(query.toLowerCase()) &gt; -1))
</code></pre>

<p>If the user input is 'United' I get a result array with two objects.</p>

<p>To get only one object I used another <code>.map</code> to handle the duplicates (Standard js code to remove duplicates from an array) and return an array with only one object.</p>

<ol>
<li>How do I remove the duplicates in the array with <code>.distinct</code>?</li>
<li>If you look at the first <code>.map</code> the type of <code>x</code> is <code>loc[]</code>. How do I get the items of the array in the <code>.map</code> operator and not the array type?</li>
</ol>

<p>Thanks in advance</p>
","553862","","","","","2019-04-08 20:30:32","How to use .distinct to remove objects from an array via the content of a object property","<angular><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"45699137","1","","","2017-08-15 18:25:33","","0","95","<p>answering my own question:</p>

<p>it makes sense that the epic (at the end) should return a stream of its own</p>

<p>but what about the chained function calls in between? Can I return plan objects and then return a stream at the end?</p>

<p>do I need to return the observable itself or the subscription object?</p>

<p>for example:</p>

<p>is this idiomatic ""rxjs"" or redux-observable?</p>

<pre><code>const epic = ($action, store) =&gt;
    action$
        .filter(filterFunction)
        .map(action =&gt; processAction(action, store))
        .map(processResult)
        .flatMap(apiCall)
        .map(res =&gt; ({ type: 'DONE', payload: res }))


const processAction = (action, store) =&gt;
    Observable.create(
        obs =&gt; {
            const result = // do something with store and action

            return obs.next(result)
        })

const processResult = result =&gt;
    result.subscribe(res =&gt; {
        const newRes = // do some other stuff
        return Observable.from({ newRes })
    })
</code></pre>

<p>epic: takes actionStream, filters for X type, maps each type to a diff operation, packages and sends request body to server, informs reducer that server call was successful</p>

<p>processAction: receives actions of X type, map each action to a process that compares snapshots (from the store) and outputs the cumulative DIFF between state trees.</p>

<p>processResult: receives DIFF and creates payload request body</p>
","4857526","","4857526","","2017-08-15 19:03:58","2017-08-15 19:03:58","what should each chained function return in redux-observable?","<redux><rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"45701710","2","","45698656","2017-08-15 21:18:30","","3","","<p>Like with everything in rxjs: There are tons of ways, how to do this - this is how I would do it:</p>

<p>About the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-distinct"" rel=""nofollow noreferrer""><code>distinct</code></a>: As described in the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-distinct"" rel=""nofollow noreferrer"">docs</a>, it takes an optional keySelector-function as the first parameter, where you can return the country:</p>

<pre><code>.distinct(entry =&gt; entry.country)
</code></pre>

<p>Here is the full example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const allEntries$ = Rx.Observable.from([
 {id:1, country: ""United Kingdom"", city:""London""},
 {id:2, country: ""United Kingdom"", city:""Manchester""},
 {id:3, country: ""Germany"", city:""Berlin""}
])
  .publishReplay()
  .refCount();

const userInput$ = new Rx.ReplaySubject("""");
// just for demonstration-purposes
userInput$.subscribe(input =&gt; console.log(""&gt;&gt; Userinput: "" + input));

// this is the important block
const result$ = userInput$
  .switchMap(input =&gt; allEntries$
    .filter(forCountry(input))
    .distinct(byCountry)
  );

// some helper for the filter, you could also do this inline, but it reads better this way
function forCountry(country) {
  country = country || """";
  coutnry = country.toLowerCase();
  return entry =&gt; entry.country.toLowerCase().indexOf(country) &gt;= 0;
}

// some helper for the distinct, you could also do this inline, but it reads better this way
function byCountry(entry) {
  return entry.country;
}

// --- Simulation start
result$.subscribe(result =&gt; console.log(""&gt;&gt;&gt;&gt; Result: "" + result.city)); // activate the stream

userInput$.next(""united"");
userInput$.next(""germ"");
userInput$.next(""e"");</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1518765","","","","","2017-08-15 21:18:30","","","","2","","","","CC BY-SA 3.0"
"45709609","1","45709805","","2017-08-16 09:15:53","","3","328","<p>My angular 4 application has a rest service that is being injected into various components and returns observables.  In one specific component I'd like to have a count of pending requests.  I currently do this by incrementing a counter when a request is being made and decrementing it when the request has completed (successfully or not).  Somewhat like this:</p>

<pre><code>export class MyComponent {
    nRunningRequests = 0;

    constructor(private restService: RestService) {
    }

    loadData(type: string): Observable&lt;any&gt; {
        // this line is wrongly executed too soon, since the request
        // is not actually done yet
        this.nRunningRequests++;
        return this.restService.fetchData(type)
            .finally(() =&gt; this.nRunningOperations--);
    }

    loadNames(): Observable&lt;any&gt; {
        this.loadData('names');
        // oops, didn't subscribe, so no request is actually being done
        // but nRunningRequests is now wrong
    }
}
</code></pre>

<p>The problem I have is that if I don't actually <code>subscribe()</code> to the observable, no request is being triggered and therefore the counter shouldn't have been incremented.  Is there a way to attach a callback to be called at subscription time?  Something along the lines of:</p>

<pre><code>    loadData(type: string): Observable&lt;any&gt; {
        return this.restService.fetchData(type)
            .initially(() =&gt; this.nRunningRequests++)
            .finally(() =&gt; this.nRunningRequests--);
    }
</code></pre>

<p>I could also move the counting logic into the rest service, but that doesn't make sense, because I only want to count the requests from this one component.</p>
","424381","","","","","2017-08-16 09:25:22","Attach 'on subscribe' callback to observable","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45709805","2","","45709609","2017-08-16 09:25:22","","2","","<p>In some Rx variants there is what you need (maybe also in RxJS 4, I'm not sure now) but it's not available as an operator in RxJS 5.</p>

<p>The easiest way to do what you want is to use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-defer"" rel=""nofollow noreferrer""><code>Observable.defer</code></a> to create the source Observable:</p>

<pre><code>Observable.defer(() =&gt; {
    this.nRunningRequests++
    return this.restService.fetchData(type)
  })
  .finally(() =&gt; this.nRunningRequests--);
</code></pre>
","310726","","","","","2017-08-16 09:25:22","","","","3","","","","CC BY-SA 3.0"
"45722919","1","45724222","","2017-08-16 21:00:13","","0","46","<p>I'm looking to upgrade an Angular application from 2 to 4, and I'm getting the following error:</p>

<pre><code> Type 'Promise&lt;void | Store&gt;' is not assignable to type 'Promise&lt;Store&gt;'.
</code></pre>

<p>Type 'void | Store' is not assignable to type 'Store'.
    Type 'void' is not assignable to type 'Store'.</p>

<p>The line in question is this:</p>

<pre><code>return this.http.get(url, { headers: this.headers })
            .toPromise()
            .then(response =&gt; response.json().data as Store)
            .catch((err) =&gt; { console.log('An error occurred under StoreService.StoreGetById', err); });
</code></pre>

<p>This worked before I upgraded, and I'm fairly new to RxJS.</p>
","122011","","472495","","2018-01-13 13:21:40","2018-01-13 13:21:40","Error in Angular and RXJS promise","<angular><promise><observable><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"45724222","2","","45722919","2017-08-16 23:03:08","","2","","<p>Promise rejections are logged automatically - like the comment by cartant explains - by <code>.catch</code>ing an error you're causing the <code>| Void</code>.</p>

<p>When a JavaScript function doesn't return anything it returns <code>undefined</code> by default - so your promise is either for the store (from the <code>then</code>) or void (from the <code>catch</code>).</p>

<p>The correct solution IMO would be to completely remove the <code>.catch</code> clause and rely on promise rejections being logged to your console automatically anyway.</p>
","1348195","","","","","2017-08-16 23:03:08","","","","0","","","","CC BY-SA 3.0"
"45738571","1","45738650","","2017-08-17 14:57:37","","5","2903","<p>I would like to combine/merge multiple <em>Observables</em> and when each of them is completed execute a <em>finally</em> function. The <code>merge</code> operator seems to execute each subscription in parallel, which is what I need, but if any of them throws an error the execution is halted.</p>

<p>RxJS <em>version 4</em> has an operator <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/mergedelayerror.md"" rel=""noreferrer"" title=""mergeDelayError"">mergeDelayError</a> that should keep the all subscriptions executing till all of them are completed, but this operator isn't implemented in <em>version 5</em>.</p>

<p>Should I revert to a different operator? </p>

<pre><code>var source1 = Rx.Observable.of(1,2,3).delay(3000);
var source2 = Rx.Observable.throw(new Error('woops'));
var source3 = Rx.Observable.of(4,5,6).delay(1000);

// Combine the 3 sources into 1 

var source = Rx.Observable
  .merge(source1, source2, source3)
  .finally(() =&gt; {

    // finally is executed before all 
    // subscriptions are completed.

    console.log('finally');

  }); 

var subscription = source.subscribe(
  x =&gt; console.log('next:', x),
  e =&gt; console.log('error:', e),
  () =&gt; console.log('completed'));
</code></pre>

<p>JSBin</p>
","248055","","","","","2018-02-28 23:13:42","rxjs5 merge and error handling","<rxjs><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"45738650","2","","45738571","2017-08-17 15:01:26","","3","","<p>I think you can simulate the same behavior by using <code>catch()</code>. You'll just need to append it to every source Observable:</p>

<pre><code>const sources = [source1, source2, source3].map(obs =&gt; 
  obs.catch(() =&gt; Observable.empty())
);

Rx.Observable
  .merge(sources)
  .finally(...)
  ...
</code></pre>
","310726","","","","","2017-08-17 15:01:26","","","","1","","","","CC BY-SA 3.0"
"45738810","1","45743592","","2017-08-17 15:09:01","","3","1761","<p>I'm experiencing a TypeScript type check failure when using the forkJoin operator form RxJS.
This is the code in question:  </p>

<pre><code>let products = this.http.get(productUrl, { headers: this.headers })
            .map(response =&gt; response.json().data as Product[]);
        let loans = Observable.of(loan);

        return Observable.forkJoin([products, loans])
            .map(data =&gt; {
                let resultProducts = data[0] as Product[];
                if (resultProducts.length &gt; 0) {
                    lead.Product = resultProducts.find(i =&gt; i.ID == productId);
            }
            lead.Loan = data[1];
            return lead;
        });
</code></pre>

<p>The error tsc is emitting is:</p>

<pre><code> Type 'Loan' cannot be converted to type 'Product[]'.
</code></pre>

<p>My understanding of forkJoin is that data[0] should be a Product[] and data[1] should be a Loan, but tsc seems to disagree. Is my understanding incorrect? Am I missing some typing that would tell tsc hat I want?</p>
","122011","","","","","2017-08-18 00:48:28","Typescript typing error with forkJoin","<angular><typescript><observable><rxjs5><fork-join>","2","1","","","","CC BY-SA 3.0"
"45743592","2","","45738810","2017-08-17 19:32:25","","2","","<p>Try using Observable.forkJoin without passing in an array.</p>

<pre><code>// forkJoin with array
return Observable.forkJoin([products, loans])
// forkJoin without array
return Observable.forkJoin(products, loans)
  .map(data =&gt; {
    let resultProducts = data[0] as Product[];
    // ...
    lead.Loan = data[1];
  })
</code></pre>
","2759965","","","","","2017-08-17 19:32:25","","","","0","","","","CC BY-SA 3.0"
"45752616","1","","","2017-08-18 08:58:56","","3","3397","<p>I have three <code>subject</code>. like this:</p>
<pre class=""lang-js prettyprint-override""><code>const s1$ = new Subject()
const s2$ = new Subject()
const s3$ = new Subject()
</code></pre>
<p>these three subjects call <code>next()</code> emit same value: <code>const fruit = {id: 1, name: apple}</code>;</p>
<p>and, I have three methods to handle the logic <strong>one to one correspondence</strong> of the <code>subjects</code> call <code>next(fruit)</code> method.</p>
<pre class=""lang-js prettyprint-override""><code>method1() {
  //called when s1$.next(fruit)
}

method2() {
  //called when s2$.next(fruit)
}

method3() {
  //called when s3$.next(fruit)
}
</code></pre>
<p>I want to implement this:</p>
<pre class=""lang-js prettyprint-override""><code>// here maybe not Observable.merge, it's just a thinking.
Observable.merge(
  s1$,
  s2$,
  s3$
)
.doSomeOperator()
.subscribe(val =&gt; {
  //val could be s1$ emit, s2$ emit or s3$ emit
  //but the val is same, the fruit.

  //do some map like s1-&gt;method1, s2-&gt;method2, s3-&gt;method3, so I can omit if...else statement.
  const method = this.method1 | this.method2 | this.method3. 
  method();
})
</code></pre>
<p>How can I implement this, thanks.</p>
","6463558","","12138651","","2020-09-12 06:25:48","2020-09-12 11:21:51","rxjs, How can I merge multiple subjects in to one Observable, but process them with different method","<rxjs><rxjs5>","2","1","","","","CC BY-SA 4.0"
"45765362","1","","","2017-08-18 21:38:08","","4","1202","<p>I have a query regarding RxJS combineLatest operator. I have modified the example given in</p>

<p><a href=""https://www.learnrxjs.io/operators/combination/combinelatest.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/combination/combinelatest.html</a></p>

<p>as follows:</p>

<pre><code>//timerOne emits first value at 1s, then once every 4s
const timerOne = Rx.Observable.timer(1000, 4000);
//timerTwo emits first value at 2s, then once every 4s
const timerTwo = Rx.Observable.timer(2000, 4000)
//timerThree emits first value at 3s, then once every 4s
const timerThree = Rx.Observable.of(false);

//when one timer emits, emit the latest values from each timer as an array
const combined = Rx.Observable
.combineLatest(
    timerOne,
    timerTwo,
    timerThree
);

const subscribe = combined.subscribe(latestValues =&gt; {
    //grab latest emitted values for timers one, two, and three
    const [timerValOne, timerValTwo, timerValThree] = latestValues;


  if(latestValues[0] === 3) {    
    this.timerThree = Rx.Observable.of(true);
  }

  console.log(
    `Timer One Latest: ${timerValOne}, 
     Timer Two Latest: ${timerValTwo}, 
     Timer Three Latest: ${timerValThree}`
   );
});
</code></pre>

<p>I expect the value of timerThree to change to <strong>true</strong> bit it always keep on printing <strong>false</strong> as shown in the output snippet:</p>

<pre><code>""Timer One Latest: 3, 
 Timer Two Latest: 2, 
 Timer Three Latest: false""
""Timer One Latest: 3, 
 Timer Two Latest: 3, 
 Timer Three Latest: false""
""Timer One Latest: 4, 
 Timer Two Latest: 3, 
 Timer Three Latest: false""
</code></pre>

<p>Any idea why this is happening? Is there any way to fix this? Thanks</p>
","6094565","","6094565","","2017-08-18 22:02:25","2017-08-18 22:35:12","RxJS combineLatest operator weird behaviour","<javascript><angular><rx-java><rxjs5>","2","0","","","","CC BY-SA 3.0"
"45772776","1","","","2017-08-19 14:36:38","","1","833","<p>I want to subscribe to two different streams, A and B.</p>

<p>However, though both events might be buffered, all of A must complete before any async tasks with B are processed.</p>

<p>input stream</p>

<p>---A1----B1----B2----A2----></p>

<p>desired output</p>

<p>------ResponseA1-------------ResponseA2-------ResponseB1----ResponseB2---></p>

<p>I initially attempted</p>

<pre><code>outputStream = Observable.concat(A,B)
</code></pre>

<p>I noticed that B would not fire. Is this a use case for forkJoin?</p>

<hr>

<p>Edits:</p>

<ul>
<li><p>Stream A doesn't complete in the Rx sense since we want to stay subscribed to the same set of events (in this case redux actions)</p></li>
<li><p>What I'm really trying to specify around Stream A is that its ""completion"" event looks to fulfill two conditions:</p>

<ol>
<li>Are all buffered async tasks from A complete?</li>
<li>Is the buffer empty?</li>
</ol></li>
</ul>

<p>This is extremely imperative because I'm refactoring our codebase from sagas.</p>

<p>If I could say this in ""Rx-speak""</p>

<pre><code>StreamA = actionStream.concatMap(action =&gt; longAsyncTask())
StreamB = actionStream.switchMap(action =&gt; shortAsyncTask())

MasterStream = Observable.forkJoin(StreamA, StreamB)
</code></pre>

<p>I would expect MasterStream to have both streams subscribed to their requisite actionTypes, have StreamA tasks emit values first, and only emit a val from StreamB once StreamA is no longer emitting values</p>
","4857526","","4857526","","2017-08-20 17:08:21","2017-08-20 17:08:21","concat/forkJoin to ensure one observable completes before another","<redux><rxjs><rxjs5><redux-observable>","0","4","","","","CC BY-SA 3.0"
"45774847","1","45776245","","2017-08-19 18:08:24","","4","19179","<p>I have an array of objects from which I need to pass each object separately into async method (process behind is handled with Promise and then converted back to Observable via <code>Observable.fromPromise(...)</code> - this way is needed because the same method is used in case just single object is passed anytime; the process is saving objects into database). For example, this is an array of objects:</p>

<pre><code>[
  {
    ""name"": ""John"",
    ...
  },
  {
    ""name"": ""Anna"",
    ...
  },
  {
    ""name"": ""Joe"",,
    ...
  },
  {
    ""name"": ""Alexandra"",
    ...
  },
  ...
]
</code></pre>

<p>Now I have the method called insert <code>which</code> which inserts object into database. The <code>store</code> method from database instance returns newly created id. At the end the initial object is copied and mapped with its new id:</p>

<pre><code>insert(user: User): Observable&lt;User&gt; {
  return Observable.fromPromise(this.database.store(user)).map(
    id =&gt; {
      let storedUser = Object.assign({}, user);
      storedUser.id = id;
      return storedUser;
    }
  );
}
</code></pre>

<p>This works well in case I insert single object. However, I would like to add support for inserting multiple objects which just call the method for single insert. Currently this is what I have, but it doesn't work:</p>

<pre><code>insertAll(users: User[]): Observable&lt;User[]&gt; {
  return Observable.forkJoin(
    users.map(user =&gt; this.insert(user))
  );
}
</code></pre>

<p>The <code>insertAll</code> method is inserting users as expected (or something else filled up the database with that users), but I don't get any response back from it. I was debugging what is happening and seems that <code>forkJoin</code> is getting response just from first mapped user, but others are ignored. Subscription to <code>insertAll</code> does not do anything, also there is no any error either via catch on <code>insertAll</code> or via second parameter in subscribe to <code>insertAll</code>.</p>

<p>So I'm looking for a solution where the Observable (in <code>insertAll</code>) would emit back an array of new objects with users in that form:</p>

<pre><code>[
  {
    ""id"": 1,
    ""name"": ""John"",
    ...
  },
  {
    ""id"": 2,
    ""name"": ""Anna"",
    ...
  },
  {
    ""id"": 3,
    ""name"": ""Joe"",,
    ...
  },
  {
    ""id"": 4,
    ""name"": ""Alexandra"",
    ...
  },
  ...
]
</code></pre>

<p>I would be very happy for any suggestion pointing in the right direction. Thanks in advance!</p>
","1257255","","1257255","","2017-08-20 18:58:54","2020-05-10 10:36:31","RxJS Map array to observable and back to plain object in array","<rxjs><observable><rxjs5><angular2-observables><fork-join>","1","2","1","","","CC BY-SA 3.0"
"45775974","1","45777576","","2017-08-19 20:24:37","","1","250","<p>I'm trying to execute multiple XHR request (inside <code>getImages</code> function), each wrapped in an observable (inside <code>getImage</code> function), using <code>forkJoin</code>. However, none of the requests are executed i.e. <code>observer.next()</code> is never executed. I have tried using <code>zip</code> instead of <code>forkJoin</code> but that doesn't work either. I'm making sure that I can <code>complete</code> on all the observables that I'm creating. </p>

<pre><code>getImages(urls: string[]) {
    Observable.forkJoin(...urls.map(url =&gt; {return this.getImage(url)}))
           .subscribe(
               (result) =&gt; {console.log(result)}, 
               (err) =&gt; {console.log(err)},
               () =&gt; {});
}

private getImage(url: string): Observable&lt;string&gt; {
    let xhr = new XMLHttpRequest();
    return Observable.create((observer =&gt; {
        xhr.onreadystatechange = () =&gt; {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    observer.next(xhr.response);
                } else {
                    observer.error(xhr.response);
                }
                observer.complete();
            }
        }
        xhr.responseType = ""blob"";
        xhr.open(""GET"", url, true);
    }))
}
</code></pre>
","1473218","","","","","2017-08-20 01:01:22","observable forkjoin never executes the observable angular2","<angular><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45776245","2","","45774847","2017-08-19 21:00:52","","8","","<p>To convert from array to observable you can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-from"" rel=""nofollow noreferrer""><code>Rx.Observable.from(array)</code></a>.</p>

<p>To convert from observable to array, use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-toArray"" rel=""nofollow noreferrer""><code>obs.toArray()</code></a>. Notice this does return an observable of an array, so you still need to <code>.subscribe(arr =&gt; ...)</code> to get it out.</p>

<p>That said, your code with <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin"" rel=""nofollow noreferrer""><code>forkJoin</code></a> <em>does</em> look correct. But if you do want to try <code>from</code>, write the code like this:</p>

<pre><code>insertAll(users: User[]): Observable&lt;User[]&gt; {
  return Observable.from(users)
    .mergeMap(user =&gt; this.insert(user))
    .toArray();
}
</code></pre>

<p>Another more rx like way to do this would be to emit values as they complete, and not wait for all of them like <code>forkJoin</code> or <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-toArray"" rel=""nofollow noreferrer""><code>toArray</code></a> does. We can just omit the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-toArray"" rel=""nofollow noreferrer""><code>toArray</code></a> from the previous example and we got it:</p>

<pre><code>insertAll(users: User[]): Observable&lt;User&gt; {
  return Observable.from(users)
    .mergeMap(user =&gt; this.insert(user));
}
</code></pre>

<p>As @cartant mentioned, the problem might not be in Rx, it might be your database does not support multiple connections. In that case, you can replace the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer""><code>mergeMap</code></a> with <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concatMap"" rel=""nofollow noreferrer""><code>concatMap</code></a> to make Rx send only 1 concurrent request:</p>

<pre><code>insertAll(users: User[]): Observable&lt;User[]&gt; {
  return Observable.from(users)
    .concatMap(user =&gt; this.insert(user))
    .toArray(); // still optional
}
</code></pre>
","402027","","8382469","","2020-05-10 10:36:31","2020-05-10 10:36:31","","","","1","","","","CC BY-SA 4.0"
"45777576","2","","45775974","2017-08-20 01:01:22","","1","","<p>Not familiar enough with XMLHttpRequest, but from your diagnosis and the samples i've seen of its usage, i imagine that your not reaching readyState of 4 (DONE) because you haven't called xhr.send().</p>

<p>From the example listed @ <a href=""https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange"" rel=""nofollow noreferrer"">https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange</a></p>

<pre><code>var xhr = new XMLHttpRequest(),
    method = ""GET"",
    url = ""https://developer.mozilla.org/"";

xhr.open(method, url, true);
xhr.onreadystatechange = function () {
  if(xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
</code></pre>

<p>So I imagine you might want to amend your code to:</p>

<pre><code>return Observable.create((observer =&gt; {
    xhr.onreadystatechange = () =&gt; {
        if (xhr.readyState === 4) {
            if (xhr.status === 200) {
                observer.next(xhr.response);
            } else {
                observer.error(xhr.response);
            }
            observer.complete();
        }
    }
    xhr.responseType = ""blob"";
    xhr.open(""GET"", url, true);
    xhr.send();
}))
</code></pre>
","1279787","","","","","2017-08-20 01:01:22","","","","0","","","","CC BY-SA 3.0"
"45791906","1","45792145","","2017-08-21 07:55:31","","0","23","<p>I am using <code>Observable.if</code> to determine which action should be dispatched.</p>

<p>The code below, since it is <code>true</code>, so only <code>ACTION1</code> is dispatched, which is correct.</p>

<p>However, I found that <code>myFunction()</code> is also running which I didn't expect.</p>

<p>Any explanation will be great. Thanks</p>

<pre><code>myFunction() {
  console.log('I did not expect this run');
  return 1;
}

export const myEpic = (action$, store) =&gt;
  action$
    .ofType('ACTION')
    .mergeMap(() =&gt;
      Observable.if(
        () =&gt; true,
        Observable.of({ type: 'ACTION1' }),
        Observable.of({ type: 'ACTION2', payload: myFunction() })
      ));
</code></pre>
","2000548","","2000548","","2017-08-21 07:59:46","2017-08-21 08:09:42","Function in one branch always runs when use Observable.if","<javascript><rxjs5><redux-observable>","1","2","","","","CC BY-SA 3.0"
"45792145","2","","45791906","2017-08-21 08:09:42","","1","","

<p>The problem is that <code>myFunction</code> needs to be evaluated when the argument is passed to <code>Observable.of</code> and the result of <code>Observable.of</code> is passed to <code>Observable.if</code> as an argument, so it's evaluated when <code>Observable.if</code> is called - not when <code>Observable.if</code> receives a <code>next</code> notification.</p>

<p>To solve the problem, wrap it in an <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-defer"" rel=""nofollow noreferrer""><code>Observable.defer</code></a> call:</p>

<pre class=""lang-js prettyprint-override""><code>import 'rxjs/add/observable/defer';
// ...
export const myEpic = (action$, store) =&gt;
  action$
    .ofType('ACTION')
    .mergeMap(() =&gt;
      Observable.if(
        () =&gt; true,
        Observable.of({ type: 'ACTION1' }),
        Observable.defer(() =&gt; Observable.of({ type: 'ACTION2', payload: myFunction() }))
      ));
</code></pre>

<p>The call to <code>Observable.of</code> (and thus the call to <code>myFunction</code>) will then be deferred until <code>Observable.if</code> receives a <code>next</code> notification.</p>
","6680611","","","","","2017-08-21 08:09:42","","","","0","","","","CC BY-SA 3.0"
"45803987","1","","","2017-08-21 19:02:21","","0","133","<p>I have a function to read image from disk. This function returns an observable with the image data.</p>

<pre><code>readImage(inputValue: any, maxSize: number) : Observable&lt;any&gt; {
    var file:File = inputValue.files[0]; 
    var myReader:FileReader = new FileReader();
    var observable = this.ng2ImgToolsService.resize([file], maxSize, maxSize).flatMap( 
        (result) =&gt; {
          return Observable.create((observer) =&gt; {
              myReader.onloadend = (e) =&gt; {
                observer.next({imageUrl: myReader.result});
                observer.complete();
              }
              myReader.readAsDataURL(result);
           }) 
        }
    )
    return observable
}
</code></pre>

<p>I want to read two images from the disk in parallel (same file but with different resizing ratio). So, I call this function twice, forkJoin the two observable, and subscribe to it. This executes the <code>readImage</code> function twice. However, I don't get any result emitted to the subscriber (<code>console.log(results)</code> is not executed). Although, the <code>next</code> function is being called by the observable. If I don't use forkJoin and I subscribe to each observable individually, then they do return the value. </p>

<pre><code>var obs = [this.readImage(event.target, 1400), this.readImage(event.target, 800)];
Observable.forkJoin(...obs).subscribe(
    (results) =&gt; {
        console.log(results);
    },
    (err) =&gt; {
        console.log(""error loading thumbnail file"", err);
        this.showMainSpinner = false;
    }
);
</code></pre>
","1473218","","1473218","","2017-08-21 20:40:42","2017-08-21 20:40:42","forkJoin doesn't return any value angular2","<angular><rxjs><observable><rxjs5><fork-join>","0","3","","","","CC BY-SA 3.0"
"45815075","1","45815185","","2017-08-22 10:23:17","","4","939","<p>I wonder how can i get the response, if the <code>WebSocketSubject</code> is connected? </p>

<p>In the source code (<a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/dom/WebSocketSubject.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/observable/dom/WebSocketSubject.ts</a>) they have a <code>openObserver</code> member of type <code>NextObserver&lt;Event&gt;</code></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code> socket.onopen = (e: Event) =&gt; {
      const openObserver = this.openObserver;
      if (openObserver) {
        openObserver.next(e);
      }
      .....</code></pre>
</div>
</div>
</p>

<p>How can i connect to it, to get the event, that the socket was opened?</p>
","830428","","310726","","2017-08-22 10:31:09","2017-08-22 10:31:09","Getting event if connected in RxJs WebSocketSubject","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"45815185","2","","45815075","2017-08-22 10:28:53","","4","","<p>The <code>openObserver</code> parameter accepts <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Observer.ts#L1"" rel=""nofollow noreferrer""><code>NextObserver</code></a> interface so you can use:</p>

<pre><code>let socket = new WebSocketSubject({
  url: 'ws://localhost:8081',
  openObserver: {
    next: value =&gt; {
      console.log(value);
    }
  }
});
</code></pre>

<p>Or you can create your own class that extends <code>NextObserver</code> and pass its instance in parameters as <code>{ ..., openObserver: new MyObserver() }</code> .</p>
","310726","","","","","2017-08-22 10:28:53","","","","1","","","","CC BY-SA 3.0"
"45844063","1","45859145","","2017-08-23 15:38:30","","1","721","<p>Based on the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-from"" rel=""nofollow noreferrer"">docs</a> for RxJS's <code>Observable.from()</code>, it sounds like you should be able to pass it an object that implements the observable interface.  However, the following</p>

<pre><code>const observable = {
  subscribe(observer) {
    const subscription = someAsyncProcess(res =&gt; observer.next(res));

    return {
      unsubscribe() {
        subscription.unsubscribe();
      }
    }
  }
};


Rx.Observable.from(observable)
  .subscribe({
    next(res) {
      console.log(res);
    }
  });
</code></pre>

<p>throws the error</p>

<blockquote>
  <p>Uncaught TypeError: object is not observable</p>
</blockquote>

<p>Is my observable implementation incorrect?  Or am I misunderstanding <code>from</code>?</p>

<p><strong>Note</strong>: this is more of an academic question about the Observable interface--I realize <code>Observable.create()</code> would work in the above situation.</p>
","2287885","","310726","","2017-08-24 10:26:03","2017-08-24 10:26:03","Using RxJS Observable.from with an object that implements the observable interface","<rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"45859145","2","","45844063","2017-08-24 10:25:34","","1","","<p>You can ""trick"" RxJS into thinking that the object you're passing it is a real Observable by implementing a ""symbol function"" (I don't know what is the proper name for this). However, you probably never need to do this in practise and it's better to use <code>Observable.create</code>.</p>

<pre><code>const Rx = require('rxjs/Rx');
const Symbol_observable = Rx.Symbol.observable;
const Observable = Rx.Observable;

const observable = {
    [Symbol_observable]: function() {
        return this;
    },

    subscribe: function(observer) {
        // const subscription = someAsyncProcess(res =&gt; observer.next(res));
        observer.next(42);

        return {
            unsubscribe() {
                subscription.unsubscribe();
            }
        }
    }
};

Observable.from(observable)
    .subscribe({
        next(res) {
            console.log('Next:', res);
        }
    });
</code></pre>

<p>This prints:</p>

<pre><code>Next: 42
</code></pre>
","310726","","","","","2017-08-24 10:25:34","","","","0","","","","CC BY-SA 3.0"
"45900863","1","","","2017-08-27 00:55:58","","0","230","<p>I need help to group items on infinite stream without data loss. </p>

<p>Groups' size must be not bigger than n elements. If during some period of time no items came, then current group's size maybe less than n.</p>

<p>Trying this code:</p>

<pre><code>Observable.create(observer =&gt; {
    setTimeout(() =&gt; observer.next([1]),            90)
    setTimeout(() =&gt; observer.next([2, 3]),        120)
    setTimeout(() =&gt; observer.next([4, 5, 6]),     160)
    setTimeout(() =&gt; observer.next([7, 8, 9, 10]), 310)
    setTimeout(() =&gt; observer.next([11]),          360)
})
.flatMap(xs =&gt; xs)
.bufferTime(100, 100, 3) // group every 100 ms or by 3, whatever comes first
.takeUntil(Observable.timer(590))
.subscribe(x =&gt; console.log(x))
</code></pre>

<p>it gives following result:</p>

<pre><code>[ 1 ]
[ 2, 3, 4 ]
[]
[ 7, 8, 9 ]
[ 11 ]
[]
</code></pre>

<p>But I need:</p>

<pre><code>[ 1 ]
[ 2, 3, 4 ]
[ 5, 6 ]
[]
[ 7, 8, 9 ]
[ 10, 11 ]
[]
</code></pre>

<p>Any help appreciated</p>
","4594225","","4594225","","2017-08-27 01:20:50","2017-08-27 01:26:00","How to group items into groups of size n in RxJs 5?","<javascript><stream><buffer><rxjs5><reactivex>","1","0","","","","CC BY-SA 3.0"
"45928451","1","45933816","","2017-08-28 23:00:01","","2","2091","<p>I am using WebSockets to communicate with backend WebApi. Everything is working fine, EXCEPT I cannot return my custom object from my service.</p>

<p>I am using Angular 4.3.4 and rxjs 5.4.3. </p>

<pre><code>//ngInit from my component
ngOnInit() {
    this.modelsSubscription = this.mainService.getModels().subscribe(models =&gt; {
      this.models = models;
    });

//here's code from my service
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Rx';
import { Subject } from 'rxjs/Subject';
import { environment } from '../../environments/environment';

import { WebsocketService } from './websocket.service';
import { MyModel} from '../models/my-Model';
import { ApplicationError } from '../globals/application-error';


@Injectable()
export class MainService {
  messages$: Observable&lt;MyModel[]&gt;;

  private messages: Subject&lt;MyModel[]&gt;;
  private webApiUrl: string;
  private wsApiUrl: string;

  constructor(private http: HttpClient, private wsService: WebsocketService) {
    this.webApiUrl = environment.webApiUrl + '/api/mainscreen/';
    this.wsApiUrl = this.webApiUrl.replace('http:', 'ws:');
  }

  disconnect() {
    this.wsService.disconnect();
  }

  getModels() {
    this.messages = &lt;Subject&lt;MyModel[]&gt;&gt;this.wsService
      .connect(`${this.wsApiUrl}GetModels`)
      .map((response: MessageEvent): Observable&lt;MyModel[]&gt; =&gt; {
        const data = JSON.parse(response.data);
        const myModels = MyModel.fromArray(data);
        // return Observable.from(myModels) // &lt;-- throws error Type 'Observable&lt;MyModel&gt;' is not assignable to type 'Observable&lt;MyModel[]&gt;'
         // return myModels; // &lt;-- throws error myModels[] is not assignable to Observable&lt;myModels[]&gt;
        return new Observable&lt;MyModels[]&gt;(observer =&gt; {
          observer.next(myModels); // &lt;-- never gets called
          observer.complete();
        });
      })
      .catch((error: any) =&gt;
        Observable.throw(new ApplicationError(error))
      );

    this.messages$ = this.messages.asObservable();
    return this.messages$;
  }    
}
</code></pre>

<p>How can I return Observable from service?</p>
","1505047","","2849613","","2017-08-29 10:35:47","2017-08-29 10:35:47","Return Observable of arrays from rxjs/Subject (Observable.from vs. Observable.of)","<angular><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"45933816","2","","45928451","2017-08-29 08:05:47","","2","","<p>It would be easier if you would provide a plunker. So far I think that you are confusing <code>Observable.from</code> and <code>Observable.of</code>:</p>

<p><strong>Observable.from</strong></p>

<p>This operator is iterating over your array elements and push those to the Observable. That's why you got type compatibility issue:
<a href=""http://reactivex.io/documentation/operators/from.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators/from.html</a></p>

<p><strong>Observable.of</strong></p>

<p>This operator creates Observable from params passed to it: 
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-of"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-of</a></p>

<p><strong>Summarizing. You should change:</strong></p>

<pre><code>return Observable.from(myModels)
</code></pre>

<p>to:</p>

<pre><code>return Observable.of(myModels)
</code></pre>

<p><strong>Example:</strong></p>

<pre><code>var myModels = [""a"", ""b"", ""c"", ""d""]
Observable.from(myModels).subscribe(value =&gt; console.log(""value is: "" + value));
Observable.of(myModels).subscribe(value =&gt; console.log(""value is: "" + value));
</code></pre>

<p>Output will be:</p>

<pre><code>value is: a
value is: b
value is: c
value is: d
value is: [a, b, c, d]
</code></pre>
","2849613","","","","","2017-08-29 08:05:47","","","","1","","","","CC BY-SA 3.0"
"45940842","1","","","2017-08-29 13:47:16","","0","2203","<p>I have a service that uses angular's http service</p>

<pre><code>@Injectable()
export class MyService {

  constructor(private http: Http) { }

  getThings() {
    return this.http.get('url').map((res) =&gt; {
      // massage data here and return massaged data
    });
  }
}
</code></pre>

<p>I use the service like this </p>

<pre><code>this.myService.getThings.subscribe(
  things =&gt; {},
  err =&gt; {},
  () =&gt; {
    // never completes...
  });
</code></pre>

<p>How come <code>myService.getThings()</code> never completes although <code>http.get('url')</code> completes ?</p>

<p>How can I make <code>myService.getThings()</code> complete ?</p>
","6797267","","5394220","","2017-08-29 22:49:20","2017-08-29 22:49:20","Observable returned by service won't complete","<angular><rxjs><rxjs5><angular2-http>","4","4","","","","CC BY-SA 3.0"
"45956042","1","","","2017-08-30 08:55:30","","1","761","<p>How can i chain a list of promises in RXJS? Every promise needs to be executed when the previous is resolved (work todo is stateful).</p>

<p>The way i'm doing it now feels primitive:</p>

<pre><code>const workTodo = []; // an array of work
const allWork = Observable.create(observer =&gt; {
  const next= () =&gt; {
    const currentTodo = workTodo.shift();
    if (currentTodo ) {
      doTodoAsync(currentTodo)
        .then(result =&gt; observer.onNext(result))
        .then(next);
    } else {
      observer.onCompleted();
    }
  };
  next();
});
</code></pre>

<p>I was thinking something like this:</p>

<pre><code>const workTodo = []; // an array of work
const allWork = Observable
                  .fromArray(workTodo)
                  .flatMap(doTodoAsync);
</code></pre>

<p>But that basically executes all promises at once.</p>
","99225","","99225","","2017-08-31 08:14:28","2017-09-01 11:26:50","How to chain a list of promises in RXJS?","<javascript><asynchronous><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"45957089","1","","","2017-08-30 09:46:21","","2","1129","<p>My requirements are that I have two endpoints one to listing of HondaCars and one to listing of PeugoetCars When I use the <code>combineLatest</code> operator it doesn't wait for the other stream to complete;</p>

<p>here my requirements => first time wait until both source streams receive a value then after that refresh after one of both receives a value</p>

<p><strong>EDIT</strong></p>

<p>So after some time of searching, I just sticked with <code>combineLatest</code> but the trick was here: </p>

<pre><code>this.loading = Observable.combineLatest(
  myFirstObservableIndicatingIfFirstHttpReqEnded,
  mySecondObservableIndicatingIfSecondHttpReqEnded
).map(d =&gt; d.some(t =&gt; t === true));
</code></pre>

<p>so now, the user just sees the spinner until all requests have been completed even if one of both observables already emited some value.</p>

<p>Just to clarify I have two loadingReducers that that handle the loading logic for each observable, so in my case I did this to know when both http calls completed</p>
","1543885","","1543885","","2017-08-30 21:51:32","2017-09-05 10:31:41","rxjs fire parallel requests and wait until both complete and update after one of them emits","<redux><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"45963350","1","","","2017-08-30 14:40:05","","1","413","<p>I'm having a lot of pain understanding why my observable never completes.</p>

<p>My code is supposed to work like this : </p>

<ol>
<li>A subject <code>isTimerEnabled$</code> initialized to false</li>
<li>It is <code>switchMap</code>'d to a function that either returns <code>Rx.Observable.never()</code> when <code>isTimerEnabled$</code> emits false, otherwise it maps to a <code>Rx.Observable.timer</code> observable</li>
<li>From the timer I <code>take</code> everything for 1 second.</li>
<li>After 1 second, the observable completes</li>
</ol>

<p>The issue is that when I subscribe to all of this, my observer's <code>complete</code> method is never called.</p>

<p>Here is the code, maybe more helpful :</p>

<pre class=""lang-js prettyprint-override""><code>const isTimerEnabled$ = new Rx.Subject(false).switchMap(
  isTimerEnabled =&gt;
    isTimerEnabled
      ? Rx.Observable
        .timer(0, 100)
        .timeInterval()
        .pluck('interval')
        .takeUntil(Rx.Observable.timer(1000))
      : Rx.Observable.never()
)

isTimerEnabled$.subscribe(
   console.log, 
   console.error, 
   () =&gt; console.log('complete !')
)
</code></pre>

<p>So when I do :</p>

<pre><code>isTimerEnabled$.next(true)
</code></pre>

<p>It logs 10 times to the console, then .. well that's it (I simplified my code snippet for the purpose of .. well simplicity)</p>

<p>Thank you for your time :)</p>
","707930","","707930","","2017-08-30 16:13:34","2017-08-30 17:58:54","Observable of a timer never completes despite takeUntil","<javascript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"45972874","1","","","2017-08-31 03:42:01","","-1","55","<p>I need to invoke a web service for each of the item in the list [""A"", ""B"", ""C""]. The service will return data in pages (default page size 100). The first invocation of service(with page = 1 as parameter) will have total number of records set as a header in response and based on that I need to invoke the service multiple times. And I need to wait for response of all the invocations,  to proceed with further logic. Any pointers to implement the above using Rxjs will be of great help</p>
","5271238","","","","","2017-08-31 07:18:25","Rxjs Invoke service which return data in pages","<rxjs><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"46007706","1","46042615","","2017-09-01 20:40:20","","0","23","<p>Trying to make an observable that pushes to all subscribers, but I've ran into a problem for multiple subscriptions. It was my understanding that subscriber management was automatically handled for me. In the following example, it's my goal to have both 'a' and 'b' be logged.</p>

<pre><code>let observer = null as any;
let ob$ = new Observable&lt;any&gt;(ob =&gt; {
     //this piece of code will be called twice, over-writing the original 
     observer = ob;
});

ob$.do(() =&gt; console.log(""a"")).subscribe();
ob$.do(() =&gt; console.log(""b"")).subscribe(); //only 'b' is called

observer.next();
observer.complete();
</code></pre>
","158958","","310726","","2017-09-04 18:43:56","2017-09-04 18:43:56","How do I properly invoke/manage subsequent subscriptions for my observable?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46010999","1","","","2017-09-02 06:09:03","","2","136","<p>I'm trying to figure out how to implement reconnect to observable after a transient failure, to continue from a last emitted value.</p>

<p>Assume I have the following method:</p>

<pre><code>interface MyQuery {
  fromId: number;
  toId: number;
}

interface MyItem {
  id: number;
  val: string;
}

function observeUnstable(query: MyQuery): Observable&lt;MyItem&gt;;
</code></pre>

<p>The method <code>observableUnstable</code> lets to subscribe to a stream which emits values and may emit the following error in case of intermittent connection failure:</p>

<pre><code>class DisconnectedError extends Error;
</code></pre>

<p>I want to compose a new observable which would wrap the original observable above and have transparent resubscribe from the position at which the previous subscription has failed.</p>

<p>The data types are going to be opaque, so I would want to make the reconnection logic generic, probably as an operator which would accept a high order selector function:</p>

<pre><code>let startQuery = { fromId: 1, toId: 10 };

let reconnectable = observeUnstable(startQuery)
       .lift(new ReconnectOperator&lt;MyItem&gt;((err, lastValue?) =&gt; {

  if (err instanceof DisconnectedError) {

    // This error indicates that we've been disconnected,
    // resubscribing from the place we have stopped
    let continueQuery = {
      fromId: lastValue ? lastValue.id + 1 : startQuery.fromId,
      toId: startQuery.toId
    };

    return observeUnstable(continueQuery);

  } else {
    // Rethrowing error we don't expect
    throw err;
  }

}));
</code></pre>

<p>Here are my <strong>ReconnectOperator</strong> and <strong>ReconnectSubscriber</strong>:</p>

<pre><code>class ReconnectOperator&lt;T&gt; implements Operator&lt;T, T&gt; {

  constructor(private handler: (err: any, lastValue?: T) =&gt; Observable&lt;T&gt;) {
  }

  call(subscriber: Subscriber&lt;T&gt;, source: any): any {
    return source.subscribe(new ReconnectSubscriber(subscriber, this.handler));
  }
}

class ReconnectSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {

  private lastValue?: T;

  constructor(destination: Subscriber&lt;T&gt;, private handler: (err: any, lastValue?: T) =&gt; Observable&lt;T&gt;) {
    super(destination);
  }

  protected _next(value: T) {
    this.lastValue = value;
    super._next(value);
  }

  error(err: any) {
    if (!this.isStopped) {
      let result: Observable&lt;T&gt;;
      try {
        result = this.handler(err, this.lastValue);
      } catch (err2) {
        super.error(err2);
        return;
      }

      // TODO: ???
      result.subscribe(this._unsubscribeAndRecycle());
      // this._unsubscribeAndRecycle();
      //this.source.subscribe(result);
      //this.add(subscribeToResult(this, result));
    }
  }
}
</code></pre>

<p>This subscriber is very similar to <strong>CatchSubscriber</strong> with only one difference is that CatchSubscriber returns original observable in selector method, in my case I want to return last value so the selector could use it to compose a brand new observable rather than reusing the original one.</p>

<p>But I messed with resubscribe logic somehow so the resulting observable never returns complete for small amount of test values, and crashes with stack overflow for bigger amount of test values.</p>

<p>Also, my idea here is to implement a new operator but if it's possible to implement it in a single method just using composition of existing operators, in a generic way, that would be even better :)</p>

<p>Example of an alternative method but without operator:</p>

<pre><code>function observeStable&lt;T, Q&gt;(
    query: Q,
    continueQueryFunc: (query: Q, lastValue?: T) =&gt; Observable&lt;T&gt;
): Observable&lt;T&gt; {

  return observeUnstable&lt;T&gt;(query).catch((err, ???) =&gt;
    if (err instanceof DisconnectedError) {
      let lastValue = ???
      let continueQuery = continueQueryFunc(query, lastValue);
      return observeUnstable(continueQuery);
    } else {
      throw err;
    }
  );
}
</code></pre>
","191683","","191683","","2017-09-02 06:14:22","2017-09-02 06:14:22","Reconnect to source and continue from last emitted value","<rxjs><rxjs5>","0","0","","","","CC BY-SA 3.0"
"46042615","2","","46007706","2017-09-04 18:43:19","","0","","<p>The problem is how you're using <code>new Observable()</code> (this is equivalent to using <code>Observable.create()</code>).</p>

<p>Every time you subscribe to <code>ob$</code> the callback to <code>new Observable()</code> is called where you override <code>observer</code>. Then when you call <code>observer.next()</code> you're calling <code>next</code> only on the second Observer.</p>

<p>In other words <code>""a""</code> is never printed because you never call <code>next</code> on the Observer that was created inside <code>new Observable()</code> when you subscribed to <code>ob$</code>.</p>

<p>In general this is not a good way to use  <code>new Observable()</code> and for what you're trying to do is better <code>Subject</code>.</p>

<pre><code>let observer = null as any;
let subject = new Subject();
let ob$ = subject.asObservable();

ob$.do(() =&gt; console.log(""a"")).subscribe();
ob$.do(() =&gt; console.log(""b"")).subscribe(); //only 'b' is called

subject.next();
subject.complete();
</code></pre>

<p>See live demo: <a href=""http://jsbin.com/hocagar/4/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/hocagar/4/edit?js,console</a></p>

<p>This prints:</p>

<pre><code>a
b
</code></pre>
","310726","","","","","2017-09-04 18:43:19","","","","0","","","","CC BY-SA 3.0"
"46059073","1","46074051","","2017-09-05 15:54:52","","1","70","<p>I'm stuck with switching observables. Here's a condition: first observable should always emit and will be handled as main value stream, second observable should produce <code>void</code> value and then it will be handled as a side-effect.
I'm very confused in different combining operators. Now I'm staying on concatMap but it also works incorrectly.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>window.onload = function() {
  const { Observable } = Rx;
  const one = document.getElementById('one');
  const two = document.getElementById('two');
  const one$ = Observable
        .fromEvent(one, 'click')
        .map(() =&gt; [1,2,3,4]);
  const two$ = Observable
        .fromEvent(two, 'click')
        .map(() =&gt; void 0);

  const sideEffect = values =&gt; console.log('Doing something with data', values);

  one$
        .concatMap(initialValues =&gt; two$
          .do(() =&gt; sideEffect(initialValues))
          .map(() =&gt; initialValues))
        .subscribe(x =&gt; alert(JSON.stringify(x, null, 2)))
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;
&lt;button id=""one""&gt;One&lt;/button&gt;
&lt;button id=""two""&gt;Two&lt;/button&gt;</code></pre>
</div>
</div>
</p>
","6036154","","6036154","","2017-09-06 08:45:11","2017-09-06 11:29:34","Combining two parallel observables","<javascript><rxjs><observable><rxjs5>","1","4","","","","CC BY-SA 3.0"
"46059868","1","","","2017-09-05 16:50:45","","1","698","<p>In an angular project, I have a service which needs to async load a library. To ensure that methods, which use this library, don't call it before it's loaded, I created an isLoaded ReplaySubject, which doesn't emit until the library has loaded. To initially test the setup, a method looks similar to this:</p>

<pre><code>  myMethod = (a: string): Observable&lt;IPromise&lt;Building[]&gt;&gt; =&gt; { //IPromise&lt;any[]&gt; |
return this.isLoaded.asObservable().map(() =&gt; {

    //do stuff to setup query parameters etc.

    //QT.execute returns a Promise, or rather, an object which can be cast to a promise
    return QT.execute(buildingsQuery).then(result =&gt; result);
});
</code></pre>

<p>};</p>

<p>Then, to use the results, I have to do</p>

<pre><code>myMethod.subscribe(res =&gt; {res.then(...)});
</code></pre>

<p>Ugly.</p>

<p>My next step is to return just an observable, so I wrap the promise in Observable.fromPromise(), but then I'm not sure how to to just subscribe to this new inner observable. I've tried this:</p>

<pre><code>myMethod = (a: string): Observable&lt;Building[]&gt; =&gt; {
    let bldgObs: Observable&lt;Building[]&gt;;
    return this.isLoaded.asObservable().map(() =&gt; {

        //do stuff to setup query parameters etc.

        bldgObs = Observable.fromPromise(QT.execute(buildingsQuery).then(result =&gt; {
            return result;
        }) as any); //have to cast as any b/c return value's .then method is not always compatible with regular promises. This has worked fine elsewhere.
    })
        .combineLatest(bldgObs, (data1, data2) =&gt; {
            return data2;
        });
};
</code></pre>

<p>but I never get a value. My understanding is that combineLatest, will use the calling observable (this.isLoaded.asObservable(), in this case) as the first item in the list of observables to watch.</p>
","5071023","","","","","2017-09-05 16:50:45","return inner observable, from inside an observable","<angular><rxjs><rxjs5><esri-javascript-api>","0","4","","","","CC BY-SA 3.0"
"46063189","1","46064505","","2017-09-05 20:52:04","","1","4386","<p>I'm trying to create 2 observables, that basically do inverse operations. It's a service discovery endpoint, so when starting an application it has to try registering to the service discovery until success. So I thought of creating an observable like this:</p>

<pre><code>const create$ = Rx.Observable.create((observer) =&gt; {
    observer.next('Trying to create observation');
    sp.put(endpoint, { json: true }, (err, res, payload) =&gt; {
      err ? observer.error(err) : observer.complete();
    });
  });
</code></pre>

<p>And when the application is doing graceful shutdown, I want to do the inverse operation. Like this:</p>

<pre><code>const delete$ = Rx.Observable.create((observer) =&gt; {
    console.log('deleted subscribed');
    observer.next('Trying to delete observation');
    sp.delete(endpoint, { json: true }, (err, res, payload) =&gt; {
      err ? observer.error(err) : observer.complete();
    });
  });
</code></pre>

<p>So I decided to create a function that returns an object that has a <code>.create()</code> and <code>.delete()</code>. The problem I want to solve is that when the application is up and trying to register, but unable to reach the service discovery endpoint and later the application initiates it's graceful shutdown process and invokes the <code>.delete()</code> operation then the <code>.create()</code> operation should not run anymore.</p>

<pre><code>function observe({ url, version, serviceName }) {
  const endpoint = `/endpoint/${serviceName}/${version}/${encodeURIComponent(url)}`;

  const create$ = Rx.Observable.create((observer) =&gt; {
    observer.next('Trying to create observation');
    sp.put(endpoint, { json: true }, (err, res, payload) =&gt; {
      err ? observer.error(err) : observer.complete();
    });
  });

  const delete$ = Rx.Observable.create((observer) =&gt; {
    console.log('deleted subscribed');
    observer.next('Trying to delete observation');
    sp.delete(endpoint, { json: true }, (err, res, payload) =&gt; {
      err ? observer.error(err) : observer.complete();
    });
  });

  return {
    create() {
      return create$.retry(Number.POSITIVE_INFINITY).takeUntil(delete$); // This is where I would want to takeUntil()
    },
    delete({ interval = 5000, times = 0 } = {}) {
      return delete$.retry(times);
    },
  }
}
</code></pre>

<p>The problem I have is that when using <code>.takeUntil()</code> it subscribes to the <code>delete$</code> which starts doing the delete operation which has the effect of stopping the <code>create$</code> observable instantly.</p>

<p>I tried doing <code>takeUntil(Observable.merge(Observable.never(), delete$))</code> but it subscribes to both so doesn't work. I also tried doing <code>takeUntil(Observable.concat(Observable.never(), delete$))</code> the first one never ends (:P) and the second one is never subscribed. </p>
","367927","","367927","","2017-09-05 22:13:17","2017-09-06 23:04:59","Correctly use takeUntil() for stopping observable","<rxjs><observable><observer-pattern><rxjs5>","2","2","","","","CC BY-SA 3.0"
"46064505","2","","46063189","2017-09-05 23:07:39","","6","","<p>Most Observables are <strong>cold</strong> and <strong>unicast</strong>. This is a bit of a lengthy topic, so I'll defer to the great article <a href=""https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339"" rel=""nofollow noreferrer"">Hot vs Cold Observables</a> for the most part, but to sum it up:</p>

<blockquote>
  <h3>COLD is when your observable creates the producer</h3>

<pre><code>// COLD
var cold = new Observable((observer) =&gt; {
  var producer = new Producer();
  // have observer listen to producer here
});
</code></pre>
  
  <h3>HOT is when your observable closes over the producer</h3>

<pre><code>// HOT
var producer = new Producer();
var hot = new Observable((observer) =&gt; {
  // have observer listen to producer here
});
</code></pre>
</blockquote>

<p>In your example this is a critical distinction because both <code>create$</code> and <code>delete$</code> are cold. So as you found, providing <code>delete$</code> to the <code>takeUntil</code> causes <code>delete$</code> to be subscribed to, kicking off the request.</p>

<p>If you want to keep the structure/API of your code as-is, one way to accomplish this is by using a Subject that is treated as a sort of ""notifier"". Subjects are multicast and ""hot"" (even though they don't do anything by themselves).</p>

<pre><code>function observe({ url, version, serviceName }) {
  // etc...

  const shutdown$ = new Subject(); // &lt;---------------- create our notifier

  return {
    create() {
      return create$
        .retry(Number.POSITIVE_INFINITY)
        .takeUntil(shutdown$); // &lt;-------------------- take our notifier
    },
    delete({ interval = 5000, times = 0 } = {}) {
      return Observable.defer(() =&gt; {
        shutdown$.next(); // &lt;------------------------- notify
        return delete$.retry(times);
      });
    }
  };
}
</code></pre>

<p>We used <code>Observable.defer()</code> so that we can perform that <code>shutdown$.next()</code> side effect whenever someone actually subscribes to the Observable we return.</p>
","1770633","","1770633","","2017-09-06 23:04:59","2017-09-06 23:04:59","","","","0","","","","CC BY-SA 3.0"
"46065639","1","46073698","","2017-09-06 01:50:30","","3","554","<p>There is potentially asynchronous observable, i.e. something like:</p>

<pre><code>const potentiallyButNotNecessarilyAsyncObservable = [
  Observable.of('sync'),
  Observable.of('async').delay(100)
][Math.round(Math.random())];

potentiallyButNotNecessarilyAsyncObservable.subscribe(console.log);
</code></pre>

<p>It should be made asynchronous observable. It's desirable to not delay it any further if it's already asynchronous, so I can't do <code>potentiallyButNotNecessarilyAsyncObservable.delay(0)</code>.</p>

<p>How can this be done?</p>
","3731501","","3731501","","2017-09-06 09:56:37","2018-10-12 13:08:22","Make potentially asynchronous RxJS observable certainly asynchronous","<javascript><rxjs><rxjs5>","1","4","1","","","CC BY-SA 3.0"
"46072608","1","46082990","","2017-09-06 10:14:38","","2","1030","<p>I have a variable amount of promises and I want to execute them in sequence with the result of the previous promise as the parameter of the next one. Currently I managed to concat them in order to execute them in sequence:</p>

<pre><code>const promises = [p1, p2, p3, p4, ....];
const source$ = promises.map(p =&gt; Rx.Observable.defer(p));
const combination$ = Rx.Observable.concat(...source$);
combination.subscribe((x) =&gt; console.log(x));
</code></pre>

<p>But how can I now manage to pipe the parameters into each promise? I read that I could use concatMap. something like that:</p>

<pre><code>Observable.from(p1).concatMap(res =&gt; p2(res)).concatMap(res =&gt; p3(res))
</code></pre>

<p>I think I need to somehow always return a new Observable inside concatMap. And also how to chain concatMaps if a number of promises should be variable?</p>

<p>Can someone please point me in the right direction? I am new to the whole reactive programming thing, but for the parts I already understand, it is quite awesome!</p>

<p>Thank you</p>
","1308461","","7018546","","2017-09-06 10:39:03","2017-09-07 09:55:06","concatMap variable amount of promises and pipe results as parameter for the next promise","<javascript><promise><rxjs><reactive-programming><rxjs5>","2","0","","","","CC BY-SA 3.0"
"46073698","2","","46065639","2017-09-06 11:10:05","","4","","<p>You can control the way how work will be scheduled and executed by using Schedulers. For example, you can write <code>.observeOn(Rx.Scheduler.async)</code> and work will be scheduled using <code>setTimeout</code> or <code>setInterval</code> instead of synchronous recursive calls. This is advanced topic and if you would like to know it better I recomend you to read <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/scheduler.md"" rel=""nofollow noreferrer"">this great documentation on Schedulers</a></p>

<p>Here are the two examples, first is executed in one tick and the second in several:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { of, asapScheduler } = rxjs; // = require(""rxjs"")
const { observeOn } = rxjs.operators; // = require(""rxjs/operators"")

const sync$ = of('sync');

// by default RxJS will pick a default scheduler by using the principle of least concurrency
// in this case it is a null or undefined Schedulr which means notifications are delivered synchronously and recursively
console.log('--------- default(null) Scheduler ---------------');
console.log('just before subscribe');
sync$.subscribe({
  next: x =&gt; console.log('got value ' + x),
  error: err =&gt; console.error('something wrong occurred: ' + err),
  complete: () =&gt; console.log('done'),
});
console.log('just after subscribe');


const async$ = sync$.pipe(
  observeOn(asapScheduler)
);

// ""got value sync"" is printed after ""just after subscribe""
console.log('--------- Rx.Scheduler.async Scheduler ----------');
console.log('just before subscribe');
async$.subscribe({
  next: x =&gt; console.log('got value ' + x),
  error: err =&gt; console.error('something wrong occurred: ' + err),
  complete: () =&gt; console.log('done'),
});
console.log('just after subscribe');</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@6.2.2/bundles/rxjs.umd.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3772379","","3772379","","2018-10-12 13:08:22","2018-10-12 13:08:22","","","","1","","","","CC BY-SA 4.0"
"46074051","2","","46059073","2017-09-06 11:29:34","","2","","<p>If <code>$two</code> needs to modify the last value from <code>$one</code> and then emit that modified value you could create a behavior subject.</p>

<pre><code>  const values$ = new BehaviorSubject();
  const one$ = Observable
        .fromEvent(one, 'click')
        .map(() =&gt; [1,2,3,4]);
  const two$ = Observable
        .fromEvent(two, 'click')
        .map(() =&gt; void 0);

  const sideEffect = values =&gt; console.log('Doing something with data', values);

  one$.subscribe(values =&gt; {
    values$.next(values);
  });
  two$.subscribe(() =&gt; {
    let currentValue = values$.value;
    let modifiedValue = sideEffect(currentValue);
    values$.next(modifiedValue);
  });

  values$.subscribe(x =&gt; alert(JSON.stringify(x, null, 2)))
</code></pre>
","202694","","","","","2017-09-06 11:29:34","","","","1","","","","CC BY-SA 3.0"
"46074172","1","46075207","","2017-09-06 11:35:45","","1","440","<p>As far as I know in older <a href=""https://github.com/Reactive-Extensions/RxJS"" rel=""nofollow noreferrer"">RxJS 4</a> I could change default scheduler by monkey patching <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/src/core/concurrency/defaultscheduler.js"" rel=""nofollow noreferrer""><code>DefaultScheduler.prototype</code></a>. Is that correct or maybe there is a better way to do this?</p>

<p>Is this possible to achieve in newer <a href=""https://github.com/ReactiveX/rxjs"" rel=""nofollow noreferrer"">RxJS 5</a>. Because as I have seen in the sources, they use <code>null</code> as a default scheduler wich can not be monkey patched. For example <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/ArrayObservable.ts#L63"" rel=""nofollow noreferrer"">here</a></p>

<p>So how can I change the default scheduler used by RxJS?
(for testing, debugging or just for fun)</p>
","3772379","","","","","2017-09-06 12:26:17","How can I change default scheduler used by RxJS?","<javascript><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"46075207","2","","46074172","2017-09-06 12:26:17","","3","","<p>I don't think there's a way to set a default Scheduler in RxJS 5.</p>

<p>One reason could be that this might lead to unexpected behavior. For example have a look at <code>Observable.range()</code>. In RxJS 5 it doesn't use any scheduler unless you specifically set one, see <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/RangeObservable.ts#L89"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/observable/RangeObservable.ts#L89</a></p>

<p>So if you could use some default scheduler what behavior you'd expect from <code>Observable.range()</code>? To always use this default scheduler? And what about other operators that need to use some async scheduling? Should these pass the scheduler along to other operators that work similarly to <code>Observable.range()</code> which might behave differently than you expect?</p>
","310726","","","","","2017-09-06 12:26:17","","","","1","","","","CC BY-SA 3.0"
"46081614","1","46455512","","2017-09-06 17:59:45","","0","723","<p>The Following Service and its Observable was working fine up until I upgraded Angular 2 and RxJs to the latest versions.</p>

<p>The error says ""<strong><em>Cannot read property 'of' of undefined</em></strong>"" when trying to execute the following line of code:</p>

<pre><code>   if (this.loggedContact) {
            return Observable.of(this.loggedContact);
        }
</code></pre>

<p>I see that the this.loggedContact already has value. Looks like it considers Observable as undefined. Has something changed the way we used to return an object as an Observable? </p>

<pre><code> ""@angular/common"": ""^4.0.0"",
    ""@angular/compiler"": ""^4.0.0"",
    ""@angular/core"": ""^4.0.0"",
    ""@angular/forms"": ""^4.0.0"",
    ""@angular/http"": ""^4.0.0"",
    ""@angular/platform-browser"": ""^4.0.0"",
    ""@angular/platform-browser-dynamic"": ""^4.0.0"",
    ""@angular/router"": ""^4.0.0"",
    ""angular2-busy"": ""2.0.4"",
    ""bootstrap"": ""3.3.7"",
    ""core-js"": ""2.5.1"",
    ""jquery"": ""3.2.1"",
    ""ng2-completer"": ""^1.3.1"",
    ""ng2-toasty"": ""^4.0.3"",
    ""reflect-metadata"": ""0.1.10"",
    ""rxjs"": ""^5.4.3"",
    ""systemjs"": ""^0.20.18"",
    ""zone.js"": ""^0.8.17""
</code></pre>

<p>Following is the service:</p>

<pre><code>import 'rxjs/add/operator/toPromise';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';


loggedContact: CostarContactVM;
observable: Observable&lt;any&gt;;

getLoggedContact(): Observable&lt;Contact&gt; {
        if (this.loggedContact) {
            return Observable.of(this.loggedContact);
        }
        else if (this.observable)
            return this.observable;
        else {
            this.observable = this.http.get(this.contactUrl)
                .map(res =&gt; {
                    this.observable = null;
                    if (res.status == 400) {
                        return ""FAILURE"";
                    }
                    else if (res.status === 200) {
                        this.loggedContact = res.json() as Contact;
                        return this.loggedContact;
                    }
                })
                .share();
            return this.observable; 
        }
    }
</code></pre>

<p>Following is the System.Config for the same:</p>

<pre><code>(function (global) {
    System.config({
        meta: {
            '*': { authorization: true }
        },
        paths: {
            // paths serve as alias
            'npm:': 'node_modules/'
        },
        map: {
            app: 'app',
            '@angular/core': 'npm:@angular/core/bundles/core.umd.js',
            '@angular/common': 'npm:@angular/common/bundles/common.umd.js',
            '@angular/compiler': npm:@angular/compiler/bundles/compiler.umd.js',
            '@angular/platform-browser': 'npm:@angular/platform-browser/bundles/platform-browser.umd.js',
            '@angular/platform-browser-dynamic': 'npm:@angular/platform-browser-dynamic/bundles/platform-browser-dynamic.umd.js',
            '@angular/http': 'npm:@angular/http/bundles/http.umd.js',
            '@angular/router': 'npm:@angular/router/bundles/router.umd.js',
            '@angular/forms': 'npm:@angular/forms/bundles/forms.umd.js',
            'rxjs': 'npm:rxjs'
            },
        packages: {
            app: {
                main: './main.js',
                defaultExtension: 'js'
            },
            rxjs: {
                defaultExtension: 'js'
            }
        }
    });
})(this);
</code></pre>
","372450","","372450","","2017-09-06 20:23:23","2017-09-27 19:09:04","Cannot read property 'of' of undefined for Observable after upgrading from Angular 2 to Angular 4","<angular><angular2-services><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"46082685","1","46083430","","2017-09-06 19:10:04","","1","1261","<p>I have a variety of methods which I recently converted from returning promises to returning observables. Currently, these methods usually only return a single value. So, where I used to call <code>myMethod.then()</code>, I switched to <code>myMethod.first().subscribe()</code>. I did this instead of just <code>subscribe()</code>, because I'm hoping to have the observable and subscription automatically complete and clean up. Is my understanding of this correct, and is this a reasonable approach?</p>
","5071023","","","","","2017-09-06 20:00:35","Observable.first().subscribe() in place of Promise.then()","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46082990","2","","46072608","2017-09-06 19:30:23","","1","","<p>Ok guys I finally have the result I intended to have    </p>

<pre><code>const promises = [
  (i=0) =&gt; Promise.resolve(i+2), 
  (i=2) =&gt; Promise.resolve(i+4), 
  (i=2) =&gt; Promise.resolve(i+8)
];

const initial$ = Rx.Observable.from(promises[0]());

promises.reduce((o, p) =&gt; o.concatMap(p), initial$)
.subscribe(console.log);
</code></pre>
","1308461","","1308461","","2017-09-07 09:55:06","2017-09-07 09:55:06","","","","0","","","","CC BY-SA 3.0"
"46083430","2","","46082685","2017-09-06 20:00:35","","6","","<p>If your former promise now is an observable which completes after emitting its value you should not have to add the <code>.first()</code> for lifecycle cleanup. That is merely a modifier of your observable to signal intent to future you (or a coworker) that you expect exactly one value from the invoked observable and the code will error otherwise.</p>
","106909","","","","","2017-09-06 20:00:35","","","","4","","","","CC BY-SA 3.0"
"46146895","1","","","2017-09-11 00:54:51","","0","244","<p>I have the following JSON string being returned from a http request.</p>

<pre><code>{
  ""RootID"": ""85cac01a90fe4203aae78523dc6cda41"",
  ""SubNode"": {
    ""Key1"": [{
        ""InternalData1"": ""1"",
        ""InternalData2"": ""2""
      },
      {
        ""InternalData1"": ""3"",
        ""InternalData2"": ""4""
      }
    ],
    ""Key2"": [{
        ""InternalData1"": ""5"",
        ""InternalData2"": ""6""
      },
      {
        ""InternalData1"": ""7"",
        ""InternalData2"": ""8""
      }
    ]
  }
}
</code></pre>

<p>I am using Rxjs 5 and I want to flatten the dataset and return values as follows</p>

<pre><code>{
  ""InternalData1"": ""1"",
  ""InternalData2"": ""2""
}, {
  ""InternalData1"": ""3"",
  ""InternalData2"": ""4""
}, {
  ""InternalData1"": ""5"",
  ""InternalData2"": ""6""
}, {
  ""InternalData1"": ""7"",
  ""InternalData2"": ""8""
}
</code></pre>

<p>What operator could help me do it?</p>
","1773900","","1773900","","2017-09-11 01:22:41","2017-09-11 01:22:41","Flatten a key value pair in Rxjs 5","<javascript><typescript><rxjs><rxjs5>","0","5","","","","CC BY-SA 3.0"
"46151876","1","46151955","","2017-09-11 09:04:10","","12","10976","<p>Can someone help to convert this promise to an RxJs observable?
I want to get token from local storage and if error,it should be catched with observer that subscribed to observable. Below is existing solution with Promise:</p>



<pre class=""lang-js prettyprint-override""><code>  getToken(): Promise&lt;any&gt; {
    return new Promise&lt;any&gt;((resolve, reject) =&gt; {
      resolve(JSON.parse(localStorage.getItem('currentUser')).token);
      reject();
    });
  }
</code></pre>

<p>and subscriber is :</p>

<pre class=""lang-js prettyprint-override""><code> this.authService.getToken().then(token =&gt; {
      this.token = token;
    }).catch(() =&gt; console.log('Error! cannot get token'));
</code></pre>

<p>I tried to convert it to Observable with below method :</p>

<pre class=""lang-js prettyprint-override""><code> getToken2(): Rx.Observable&lt;number&gt; {
    return Rx.Observable.create(obs =&gt; {
      obs.next(JSON.parse(localStorage.getItem('currentUser')).token);
       obs.error('Error! cannot get token');
    });
  }
</code></pre>

<p>and </p>

<pre class=""lang-js prettyprint-override""><code>  this.authService.getToken2()
  .subscribe((token) =&gt; console.log(token), (er) =&gt; console.log(er));
</code></pre>

<p>But the problem is that when error occurs while getting token from localstorage ,the RxJs observable does not catch it via obs.next().It is like it is resolved successfully.Whereas Promise catches it successfully via reject method.Can someone give an idea what is wrong? Thanks</p>
","7943893","","7943893","","2017-09-11 09:25:30","2019-05-03 07:17:19","Convert Promise to RxJs Observable","<angular><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"46151955","2","","46151876","2017-09-11 09:08:43","","14","","<p>You don't need to do all this, just use <a href=""https://rxjs.dev/api/index/function/from"" rel=""noreferrer""><code>from()</code></a>:</p>

<pre><code>import { from } from 'rxjs';

from(this.authService.getToken())
  ...
  .subscribe(...)
</code></pre>

<p>If you want to use a Promise anywhere in an Observable chain you don't even need to convert it to Observable as it happens automatically.</p>

<p><a href=""https://medium.com/@benlesh/rxjs-observable-interop-with-promises-and-async-await-bebb05306875"" rel=""noreferrer"">https://medium.com/@benlesh/rxjs-observable-interop-with-promises-and-async-await-bebb05306875</a></p>

<p>Apr 2019: Updated for RxJS 6</p>
","310726","","310726","","2019-04-11 20:25:51","2019-04-11 20:25:51","","","","7","","","","CC BY-SA 4.0"
"46163501","1","46165077","","2017-09-11 19:59:18","","3","91","<p>While I'm pretty used to using RxJS, and reactive programming, there is one thing that's been bothering me, that I can't get my head around.</p>

<p>Let's say that we have a simple function that will be run every time some one clicks button SCAN</p>

<pre><code>function scan() {
   this.startScaning(10).subscribe(scannedItem =&gt; console.log(scannedItem))
}
</code></pre>

<p>Inside our scan function, we use a startScanning method which starts scanning (i.e. for Bluetooth devices) for 10 seconds, and it returns an observable to which we subscribe and we log all the discovered devices/items.</p>

<p>OK, so far so good, but what bothers me is what happens if user clicks the button 10 times in a row. What happens to the previous subscriptions? And how am I supposed to handle this? Do I need to unsubscribe every time, do I need to unsubscribe at all?</p>

<p>A nice explanation would be appreciated, with possible further readings/examples, thanks</p>
","7667264","","","","","2017-09-11 22:24:06","What happens to previous Subscriptions in RxJS?","<javascript><rxjs><rxjs5><reactive>","2","0","1","","","CC BY-SA 3.0"
"46165077","2","","46163501","2017-09-11 22:16:50","","0","","<p>The way I would handle this would be to flip a boolean while the process is running and bind the button's <code>[disabled]</code> property to that value, e.g.</p>

<pre><code>isScanning: boolean
function scan() {
    this.isScanning = true
    this.startScaning(10).subscribe({
        next: scannedItem =&gt; console.log(scannedItem),
        complete: () =&gt; this.isScanning = false
    })
}

&lt;button (click)=""scan()"" [disabled]=""isScanning""&gt;Click me!&lt;/button&gt;
</code></pre>

<p>(you might also want to add some sort of indicator that it's processing while the button is disabled - I like to use Font Awesome's <a href=""http://fontawesome.io/examples/#animated"" rel=""nofollow noreferrer"">spinner icons</a> with <code>*ngIf=""isScanning""</code> for that)</p>

<p>As for the rest, it depends on how exactly the <code>startScaning</code> method is implemented.  Most likely you'd have ten separate observables each of which would automatically complete ten seconds after its respective click, so there wouldn't be any need to worry about manually unsubscribing or anything unless it was a really heavy process (but IMO you should still disable the button anyway for UX reasons).</p>

<p>Looking at your question again, I assumed you're using Angular but you didn't actually say that.  If you're not, the general principle is the same, the only difference is you'll need to use a different way of setting the button's <code>disabled</code> state.</p>
","7496073","","7496073","","2017-09-11 22:24:06","2017-09-11 22:24:06","","","","1","","","","CC BY-SA 3.0"
"46207592","1","46207761","","2017-09-13 22:14:20","","21","8792","<p>I have a parent observable that, once it has a subscriber, will do a lookup and emit a single value, then complete.</p>

<p>I'd like to convert that into an observable (or behavior subject or whatever works) that does the following: once it has at least one subscriber, it gets the result from the parent observable (once). Then it emits that value to all of its subscribers, and also emits that single value to all future subscribers, when they subscribe. It should continue with this behavior even if its subscriber count drops to zero.</p>

<p>It seems like this should be easy. Here is what didn't work:</p>

<pre><code>theValue$: Observable&lt;boolean&gt; = parent$
.take(1)
.share()
</code></pre>

<p>Other things that didn't work: <code>publishReplay()</code>, <code>publish()</code>. Something that worked better:</p>

<pre><code>theValue$ = new BehaviorSubject&lt;boolean&gt;(false);

parent$
.take(1)
.subscribe( value =&gt; theValue$.next(value));
</code></pre>

<p>There is a problem with this approach, though: <code>parent$</code> is subscribed to before <code>theValue$</code> gets its first subscriber.</p>

<p>Is there a better way to handle this?</p>
","53537","","","","","2020-01-05 03:01:32","RxJS 5, converting an observable to a BehaviorSubject(?)","<rxjs><rxjs5>","3","0","4","","","CC BY-SA 3.0"
"46207761","2","","46207592","2017-09-13 22:31:10","","17","","

<p><code>shareReplay</code> should do what you want:</p>

<pre class=""lang-ts prettyprint-override""><code>import 'rxjs/add/operator/shareReplay';
...
theValue$: Observable&lt;boolean&gt; = parent$.shareReplay(1);
</code></pre>

<p><code>shareReplay</code> was added in RxJS version 5.4.0. It returns a reference counted observable that will subscribe to the source - <code>parent$</code> - upon the first subscription being made. And subscriptions that are made after the source completes will receive replayed notifications.</p>

<p><code>shareReplay</code> - and <code>refCount</code> in general - is explained in more detail in an article I wrote recently: <a href=""https://ncjamieson.com/how-to-use-refcount/"" rel=""nofollow noreferrer"">RxJS: How to Use refCount</a>.</p>
","6680611","","6680611","","2019-12-12 23:34:12","2019-12-12 23:34:12","","","","5","","","","CC BY-SA 4.0"
"46219719","1","46220008","","2017-09-14 12:52:22","","1","40","<p>I am in reference to the <strong><em>RxJS in action</em></strong> book by Manning publisher which gives the following sample code to demonstrate the RxJS way of handling errors: </p>

<pre><code>const computeHalf = x =&gt; Math.floor(x / 2);

Rx.Observable.of(2,4,5,8,10)
   .map(num =&gt; {
      if(num % 2 !== 0) {
        throw new Error(`Unexpected odd number: ${num}`); //#A
      }
      return num;
   })
   .map(computeHalf)
   .subscribe(
       function next(val) {
          console.log(val);
       },
       function error(err) {
          console.log(`Caught: ${err}`); //#B
       },
       function complete() {
          console.log('All done!');
       }
    );
</code></pre>

<p>The book goes on to say about RxJS:</p>

<blockquote>
  <p>errors don't escape the observable pipeline.</p>
</blockquote>

<p>and also puts it differently:</p>

<blockquote>
  <p>The observable data type disallows the exception from leaking from the stream's context.</p>
</blockquote>

<p>Can someone please explain how this differs (as far as side-effects are concerned) from handling errors with a traditional <code>try/catch</code> as follows?</p>

<pre><code>try {
 someDangerousFunction();
}
catch(error){
 console.log(error.message);
}
</code></pre>

<p>How the latter sample causes a side-effect compared to the former?</p>

<p>What is meant by the two quotes above?</p>
","536299","","","","","2017-09-14 13:06:34","Clarification about RxJS way of handling errors: ""The observable data type disallows the exception from leaking from the stream's context""","<functional-programming><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"46220008","2","","46219719","2017-09-14 13:06:22","","2","","<p>This means that when you set an error handler when calling <code>subscribe(.., error =&gt; ...)</code> the exception is only passed to the error handler and nothing else (you threw an exception but it was caught by RxJS).</p>

<p>That's what is meant by <em>""errors don't escape the observable pipeline.""</em> and by <em>""leaking""</em> I think they mean the same.</p>

<p>In the example you posted you're throwing an error inside <code>map()</code> which is caught by <code>map()</code> automatically and sent as an error notification.</p>

<p>So you don't typically wrap Observable chains with <code>try/catch</code>. One important thing to notice is that if your <code>subscribe</code> call doesn't set and error handler than the error is rethrown which might break your application. In such case you might want to use <code>try/catch</code> but it's always easier to use the error handler instead.</p>
","310726","","","","","2017-09-14 13:06:22","","","","2","","","","CC BY-SA 3.0"
"46297478","1","46300211","","2017-09-19 09:59:37","","1","48","<p>I am working on converting <a href=""https://github.com/Reactive-Extensions/RxJS/tree/master/examples/backpressure"" rel=""nofollow noreferrer"">this</a> application to support RxJS version 5. But I am not sure how to convert below code.</p>

<pre><code>losslessClick.subscribe(function (checked) {
  if (checked) {
    mousemove.resume();
  } else {
    mousemove.pause();
  }
})
</code></pre>

<p>I tried suggestion from <a href=""https://github.com/ReactiveX/rxjs/issues/1542"" rel=""nofollow noreferrer"">here</a> but did not work for me. </p>

<pre><code>var pauser = new Subject();
var pausable = pauser.switchMap(paused =&gt; paused ? Observable.never() : mousemove);
pausable.subscription(x =&gt; console.log(x));
pauser.next(true);
</code></pre>

<p>Any help would be appreciated. Thanks in advance.</p>
","5042339","","","","","2017-09-19 12:15:06","How to convert RxJS v4 application to RxJS v5 version","<javascript><rxjs><rxjs5>","1","0","0","","","CC BY-SA 3.0"
"46300211","2","","46297478","2017-09-19 12:15:06","","1","","<p>This might help you. </p>

<pre><code>var losslessResults = document.getElementById('losslessResults');
var losslessToggle = document.getElementById('losslessToggle');

function logInput(text) {
    var li = document.createElement('li');
    li.innerHTML = text;
    losslessResults.appendChild(li);
}

var mousemove = Rx.Observable.fromEvent(document, 'mousemove')
    .map(function (e) {
        return 'clientX: ' + e.clientX + ', clientY: ' + e.clientY;
    });

// Lossless
var losslessClick = Rx.Observable.fromEvent(losslessToggle, 'click')
    .map(function (e) {
        return e.target.checked;
    })

var pauser = new Rx.Subject();
var pausable = pauser.switchMap(function (paused) {
    return paused ? mousemove : Rx.Observable.never();
});
pausable.subscribe(function (x) {
    return logInput(x);
});
pauser.next(true);
losslessClick.subscribe(pausable)
</code></pre>

<p>Working example can be found <a href=""https://jsfiddle.net/tnnk6hv3/"" rel=""nofollow noreferrer"">here</a>.</p>
","2334849","","","","","2017-09-19 12:15:06","","","","0","","","","CC BY-SA 3.0"
"46311703","1","","","2017-09-20 00:57:37","","2","709","<p>With the <code>pausable</code> operator not implemented in RxJS v5, is there a better way to create a pausable interval? The code below works, but does so by keeping track of the last emitted value as an offset. It seems like there should be a better way... </p>

<pre><code>const source = Rx.Observable.interval(100).share()
const offset = new Rx.BehaviorSubject(0)
let subscription;
let currentValue;

function start() {    
    subscription = source
        .subscribe(i =&gt; {
            currentValue = i + offset.value
      })
}



function pause() {
    source.take(1).subscribe(i =&gt; offset.next(i + offset.value))
    subscription.unsubscribe()
}
</code></pre>
","3808414","","","","","2017-09-20 22:49:36","RxJS v5 Pausable Observable Interval","<rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"46315326","1","","","2017-09-20 07:03:15","","0","220","<p>Context: I have a logging library for an app and I want to use Rx Subject to write logs to database.
Problem: Logs are generated before the connection to database is established and the connection can become unavailable at any time, but I have and observable that either contains an object with methods for working with the database or an undefined. What I want to do is to keep the logs in the stream while database persistence is undefined and resume when it's available.</p>

<p>I think the code should look something like this:</p>

<pre><code>logsSubject
           .takeWhen(/* test for database persistence */) // made up name because I don't know a Rx method that does what I want
           .subscribe(/* write data to database */);
</code></pre>

<p>I'm not sure however if this is actually possible for I've been using RxJS for a very short time</p>
","6213806","","6213806","","2017-09-20 08:06:39","2017-09-21 08:03:39","RxJS extract data from stream on external condition","<javascript><rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"46332873","1","46333021","","2017-09-20 22:51:30","","1","1364","<p>Ok, I am new to RxJs, got introduced today.. so this is a totally newbie question. </p>

<p>My use case is to extract XML RSS feed and convert them to JSON feed. </p>

<p>I have a FeedService which has the following </p>

<pre><code>getFeedContent(url: string) : Observable&lt;Feed&gt; {
    return this.http.get(url)
        .map(this.extractFeeds)
        .catch(this.handleError);
}

private extractFeeds(res: Response) {
    let content = res.text;
    let feed = this.extractItems(content);
    return feed ;
}
</code></pre>

<p>The extract Items is a regular function which takens in a content and does XML parsing to build the json object. There are multiple other methods </p>

<p>Here is the code</p>

<pre><code>private extractItems(content) : Feed {
    console.log(content);
    let f = this.getFeedInfo(content);
    return {
        status: ""ok"",
        feed : f ,
        items: this.getItems(content.toString(), 'item')
                   .concat(this.getItems(content.toString(), 'entry'))
    }
}
</code></pre>

<p>I am getting this error when I run this code : </p>

<blockquote>
  <p>feed.service.ts:144 this.extractItems is not a function</p>
</blockquote>

<p>I might be mixing Observables with regular function calls and I need help. 
How to call extractItems with the XML content as an input. </p>

<p>Thanks, </p>
","1241876","","3931192","","2017-09-20 23:01:26","2017-09-21 16:28:04","Angular2 Observable Rxjs how to call private function","<angular><rxjs><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"46333021","2","","46332873","2017-09-20 23:08:09","","0","","<p>The issue stems from the 'this' context. When trying to use this.extractItems() the context of 'this' is within the observable not the class.</p>

<p>Try something like this:</p>

<pre><code>let extractFeeds = (res: Response) =&gt; {
    let content = res.text;
    let feed = this.extractItems(content);
    return feed;
}
</code></pre>

<p>You may need to import of from rxjs as well.</p>

<p>By using the arrow notation you will not have a 'this' context for the observable and calling methods within the class will work.</p>
","8599991","","8599991","","2017-09-21 16:28:04","2017-09-21 16:28:04","","","","6","","","","CC BY-SA 3.0"
"46337247","1","","","2017-09-21 06:50:39","","0","1094","<p>In my Angular app I'm working on notifications and I have an REST API to call for latest user's notifications. I need to call this API on few minutes since it's not really important that user gets notifications in real time (they probably won't even appear that fast). However the idea to refresh notifications on the client side is next:</p>

<ul>
<li>When user logs in start refreshing notifications - here is the first manual call to start refreshing the API on few minutes

<ul>
<li>If user leaves app opened or is just navigating through the app then don't change timer and wait for the rest of the time</li>
<li>If user opens subpage where it can perform actions related to notifications and does it, then refresh notifications and reset timer</li>
</ul></li>
<li>Refresh notifications until logout</li>
</ul>

<p>I already have working code for the described procedure, but I'm somehow unsure that it's correct for what I need. Here is the code for performing calls (for manual check there is just a Subject and for stop checking there is a subscription to observable - code below is actually separated, but here is in one place because of readability):</p>

<pre><code>// Subject for manual triggering
this.checkFeed = new Subject&lt;void&gt;();

// Call for refresh in own method
this.checkFeed.next();

// Waiting for manual refresh or triggering it on some interval after it was last triggered
this.feedSub = this.checkFeed.asObservable()
      .switchMap(() =&gt; Observable.timer(0, this.interval))
      .mergeMap(() =&gt; this.fetchChanges())
      .distinctUntilChanged(this.compareFeed)
      .subscribe(res =&gt; this.notify(res));

// Unsubscription when logging out
if (this.feedSub) this.feedSub.unsubscribe();
</code></pre>

<p>The part which I'm most unsure about is <code>.switchMap(() =&gt; Observable.timer(0, this.interval))</code> since it needs <code>0</code> to start right away (which is ok, but still doesn't look correct at all?). So is there any better way to achieve what I described?</p>

<p>I also have another question how to start check for notifications from another observable - which operator should I use. As I mentioned I have call to the Subject's next in own method like this:</p>

<pre><code>refreshFeed(): void {
  this.checkFeed.next();
}
</code></pre>

<p>So when there is some other observable performing (the action when notifications should be refreshed) I need to call this one. What's the correct way to call <code>void</code> method when other observable has response from API? I was thinking of something like this:</p>

<pre><code>someActionThatCanChangeNotifications(): Observable&lt;any&gt; {
  return this.api.get('path/to/endpoint')
    .do(() =&gt; this.feedService.refreshFeed());
}
</code></pre>

<p>Is this ok, or is there also any better way?</p>

<p>Thanks in advance for help!</p>
","1257255","","","","","2017-09-27 07:10:03","RxJS polling by interval and when manually called","<notifications><rxjs><observable><rxjs5><subject>","2","0","","","","CC BY-SA 3.0"
"46350396","1","46350942","","2017-09-21 17:58:29","","5","2322","<p>I have an issue with Observable.forkJoin inferring the wrong return type and then causing errors when I pass more than 6 arguments.</p>

<pre><code>Observable.forkJoin(service.getType1, service.getType2, service.getType3 ...)
        .subscribe(x =&gt; {
            this.type1Arr = x[0];
            this.type2Arr = x[1];
            this.type3Arr = x[2];
</code></pre>

<p>Each function call from the service returns an <code>Observable&lt;Array&lt;type&gt;&gt;</code>. The compiler is determining that the return should be <code>Type1[][]</code> when I have more than 6 calls from the service passed in. It works fine up to 6 though, it will have the correct return and I can assign strongly typed results. </p>

<p>I'm using rxjs 5.4.3 and Typescript 2.4.0 (Typescript Tools for Visual Studio is 2.5.2). </p>

<p>Is there a workaround for this without casting it?</p>
","7897794","","310726","","2017-09-27 08:46:16","2017-09-27 08:46:16","Observable.forkJoin wrong return type when more than 6 arguments","<angular><rxjs><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"46350942","2","","46350396","2017-09-21 18:31:53","","5","","<p>The typings for <code>forkJoin</code> define max <code>forkJoin</code> with 6 parameters as you can see here: <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/ForkJoinObservable.ts#L27"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/observable/ForkJoinObservable.ts#L27</a></p>

<p>Note that there are different ways to call <code>forkJoin</code> with more than 6 parameters:</p>

<pre><code>Observable.forkJoin(observables)
</code></pre>

<p>or</p>

<pre><code>Observable.forkJoin(...observables)
</code></pre>

<p>You can also force return types (<a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/ForkJoinObservable.ts#L35"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/observable/ForkJoinObservable.ts#L35</a>):</p>

<pre><code>Observable.forkJoin&lt;Whatever[]&gt;(observables)
</code></pre>
","310726","","","","","2017-09-21 18:31:53","","","","1","","","","CC BY-SA 3.0"
"46354052","2","","38940123","2017-09-21 22:25:35","","1","","<p>You can use <code>.skipUntil(Rx.Observable.timer(0))</code> because the replayed elements will be replayed synchronously, and <code>skipUntil</code> will take the rest of the <code>Observable</code> out of synchronous execution for exactly that moment when it would receive the replay values.</p>

<p>This code would produce the result you want:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const observable = Rx.Observable
    .interval(100)
    .take(4)
    .publishReplay(3);

observable.subscribe(x =&gt; console.log('observed', x));

setTimeout(() =&gt; 
    observable
        .skipUntil(Rx.Observable.timer(0))
        .subscribe(y =&gt; console.log('delayed observed', y)), 
    400
);

observable.connect();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.3/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1252155","","","","","2017-09-21 22:25:35","","","","0","","","","CC BY-SA 3.0"
"46365408","1","46367493","","2017-09-22 12:57:59","","1","940","<p>I am using rxjs BehaviorSubject to create a service, upon sending values from Component1 and on subscribing in Component3, I get the values in Component3, this is achieved</p>

<h1>Service file</h1>

<pre><code>`import { Injectable } from '@angular/core';
 import { Observable } from 'rxjs';
 import { BehaviorSubject } from 'rxjs/BehaviorSubject';

   @Injectable()
   export class UserService {

     constructor() { }

     // Observable navItem source
     public _navItemSource = new BehaviorSubject(undefined);

     // Observable navItem stream
     navItem$ = this._navItemSource.asObservable();

     // service command
     changeNav(nu) {
       this._navItemSource.next([...nu]);
     }
  }`
</code></pre>

<h1>Component1</h1>

<pre><code>  `this._userService.changeNav(self.notificationslist);`
</code></pre>

<h1>Component3</h1>

<pre><code>  `this.subscription = this._userService.navItem$.subscribe(item =&gt;   
   this.item1 = item);`
</code></pre>

<p>Now I want to use the same service in one more component(Component2) to send some different values to the same component Component3</p>

<h1>Component2</h1>

<pre><code> `this._userService.changeNav(this.updatedFlag);`
</code></pre>

<h1>Component3</h1>

<pre><code>  `this.subscription = this._userService.navItem$.subscribe(item =&gt;   
   this.item1 = item);`
</code></pre>

<p>And then upon subscribing it on Component3 I should get all the values from Component1 and Component2.
So I have updated my service file but I get the following error</p>

<p><code>caused by: this._navItemSource.asObservable(...).scan is not a function</code></p>

<p>Please correct me where I am going wrong as I am new to rxjs.</p>

<h1>Updated Service file</h1>

<pre><code>`import { Injectable } from '@angular/core';
 import { Observable } from 'rxjs';
 import { BehaviorSubject } from 'rxjs/BehaviorSubject';

 @Injectable()
 export class UserService {

 constructor() {
 }

  // Observable navItem source
  public _navItemSource = new BehaviorSubject(undefined);

  // Observable navItem stream
  navItem$ = this._navItemSource.asObservable().scan((acc, one) =&gt;(acc + 
  one));

  // service command
  changeNav(nu) {
    this._navItemSource.next([...nu]);
  }

}`
</code></pre>
","7468279","","","","","2017-09-22 14:46:45","To merge values from different sources in my rxjs BehaviorSubject","<angular><rxjs><rxjs5>","1","7","","","","CC BY-SA 3.0"
"46367493","2","","46365408","2017-09-22 14:46:45","","1","","<p>make sure you import scan operator. and in the scan function to merge your results you can return a JSON with the previous and new value emitted</p>

<p><a href=""https://plnkr.co/edit/fXFZwAPxzBcdCOgf1Rsy?p=preview"" rel=""nofollow noreferrer"">Working Plunker</a></p>

<pre><code>import { Injectable } from '@angular/core';
 import { Observable } from 'rxjs';
 import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import ""rxjs/add/operator/scan"";
 @Injectable()
 export class UserService {

 constructor() {
 }

  // Observable navItem source
  public _navItemSource = new BehaviorSubject(Object([]));

  // Observable navItem stream
  navItem$ = this._navItemSource.asObservable().scan((acc, one) =&gt; {
                    return {
                        'previous': acc, 'new': one
                    }
                });

  // service command
  changeNav(nu) {
    this._navItemSource.next([...nu]);
  }

}
</code></pre>
","3485837","","","","","2017-09-22 14:46:45","","","","0","","","","CC BY-SA 3.0"
"46377021","1","46377202","","2017-09-23 07:09:18","","2","852","<p>I'd like to split an Rx.js observable into two other observables when filtering such that one observable contains the filtered results and the other contains everything else.</p>

<p>Is it possible to split them without creating two separate filters?</p>

<p>Instead of this:</p>

<pre><code>const observable$ = Rx.Observable.of(1, 2, 3, 4)

observable$.filter(isOdd)
observable$.filter(isEven)
</code></pre>

<p>I'm looking for something like this:</p>

<pre><code>const [isOdd$, isNotOdd$] = observable$.split(isOdd)
</code></pre>
","1624862","","","","","2017-09-23 08:15:01","How to split an observable into 2 when filtering in Rx.js?","<javascript><filter><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46377202","2","","46377021","2017-09-23 07:31:47","","3","","<p>I believe what you need is <code>partition</code>.</p>

<pre><code>const source = Rx.Observable.from([1,2,3,4,5,6]);

//first value is true, second false
const [evens, odds] = source.partition(val =&gt; val % 2 === 0);

evens.subscribe(n =&gt; console.log(n));
// 2, 4
</code></pre>

<p>More information can be found at <a href=""https://www.learnrxjs.io/operators/transformation/partition.html"" rel=""nofollow noreferrer"">learnrxjs.io</a>.</p>
","7512733","","1624862","","2017-09-23 08:15:01","2017-09-23 08:15:01","","","","1","","","","CC BY-SA 3.0"
"46411508","1","49958809","","2017-09-25 18:05:35","","2","466","<p>I'm using RxJS's <code>.auditTime(500)</code> operation (<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-auditTime"" rel=""nofollow noreferrer"">docs</a>) as a trailing throttle: I want to emit a server call at most once every 500 ms.</p>

<p>Downstream when the server call completes I need to inquire whether there are more pending server calls or if the buffer is clear for now so that I can communicate this information to users in the form of status messages like ""Savingâ¦"" and ""Saved"".</p>

<p>Here's roughly what that looks like.</p>

<pre><code>saveToServerObservable
  .do(() =&gt; {
    // gets called every time
    setStatus(Status.SAVING);
  })
  .auditTime(500) // wait 500 ms and emit no more than once per 500 ms
  .flatMap(data =&gt; axios({
    method: ""post"",
    url: ""/saveurl"",
    data: data,
  }))
  .map(response =&gt; response.data)
  .do(data =&gt; {
    // here I want to know whether there are pending values from the
    // auditTime() operation above or if the buffer is currently clear
    const pendingSaves = ???;
    if (!pendingSaves) {
     setStatus(Status.SAVED);
    }
  })
  .subscribe();
</code></pre>

<p>As you can see in the final <code>.do()</code> operation, I want to know whether there are pending values from the <code>.auditTime(500)</code> operation. How can I achieve something like this?</p>

<p>Cheers! ð</p>
","101869","","101869","","2017-09-26 13:02:11","2018-04-21 18:11:45","In RxJS is it possible to test for pending values in an auditTime() operation?","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"46414487","1","46414890","","2017-09-25 21:31:55","","0","2248","<p>use angular4 with rxjs 5.4.0</p>

<p>I am trying to group list by 'type' and get their count. can some one help ? following is my code</p>

<pre><code>export class Sample{
  type:string;
  data:any ...
  ...
}
</code></pre>

<p>I have array of Sample Class </p>

<pre><code>list:Sample[] = // number of elements

Observable.from(this.list).groupBy(x=&gt; x.type)
  .flatMap( group =&gt; {
    return group.reduce; // how can i use reduce function to count numbers and return map of type and their count
  }
})
</code></pre>
","216431","","114900","","2017-09-25 22:38:33","2017-09-25 22:42:20","angular2 rxjs groupby with count","<angular><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"46414890","2","","46414487","2017-09-25 22:05:28","","4","","<p>You're close, I think you just need a few more operators on the grouped observable.</p>

<pre><code>const list = [{ type: 'foo' }, { type: 'bar' }, { type: 'bar' }];

Observable.from( list ).groupBy( x =&gt; x.type )
  .mergeMap( list$ =&gt; { // each emission is a stream

    /* A stream of ""aggregated"" data. */
    const count$ = list$.count();

    /* Format the result. */
    return count$.map( count =&gt; ({ type: list$.key, count }));
  });
</code></pre>

<p>This emits:</p>

<pre><code>{ type: 'foo', total: 1 }
{ type: 'bar', total: 2 }
</code></pre>

<p>It sounds like you might have more complicated use cases for calculating ""aggregates"", maybe you need to sum <code>Sample.data</code>. If so, you just need to change my <code>count$</code> implementation with your own. Let's say <code>data</code> is a list of numbers:</p>

<pre><code>const list = [{
  type: 'foo',
  data: [1,2,3]
}, {
  type: 'bar',
  data: [4,5,6]
}, {
  type: 'bar',
  data: [7,8,9]
}];

Observable.from( list ).groupBy( x =&gt; x.type )
  .mergeMap( list$ =&gt; { // each emission is a stream

    /* A stream of ""aggregated"" data. */
    const count$ = list$.reduce( ( accumulator, sample ) =&gt; { // reduce the stream
      return accumulator + sample.data.reduce( ( acc, datum ) =&gt; { // reduce the array
        return acc + datum;
      }, 0);
    }, 0);

    /* Format the result. */
    return count$.map( count =&gt; ({ type: list$.key, count }));
  });
</code></pre>

<p>This produces:</p>

<pre><code>{ type: 'foo', total: 6 }
{ type: 'bar', total: 39 }
</code></pre>
","7806537","","7806537","","2017-09-25 22:42:20","2017-09-25 22:42:20","","","","1","","","","CC BY-SA 3.0"
"46415606","1","46430120","","2017-09-25 23:28:09","","2","899","<p>I'm currently learning RxJS and I'm trying to figure out how to test <code>Observable.ajax()</code> using <code>nock</code>.</p>

<p>Here's my simplified example without any assertions... I just want to see if <code>nock</code> can intercept that API call or not.</p>

<pre><code>import { afterEach, describe, it } from 'mocha';
import nock from 'nock';
import { ajax } from 'rxjs/observable/dom/ajax';

// had to use `crossDomain: true` for it to work in production code
const api = ajax({
  url: 'https://server.com/abc',
  crossDomain: true,
});

describe('ajax', () =&gt; {
  afterEach(() =&gt; {
    nock.cleanAll();
  });

  it('given valid call, should return value', (done) =&gt; {
    nock('https://server.com', {
      // needed to prevent ""cross origin null forbidden"" error
      reqheaders: {
        'Access-Control-Allow-Origin': '*',
      },
    }).get('/abc').reply(200, 'YAY!');

    api
      .map(e =&gt; e.json())
      .subscribe(
        value =&gt; console.log('SUCCESS', value),
        error =&gt; console.log('ERROR', error),
        () =&gt; done(),
      );
  });
});
</code></pre>

<p>When executing the above code, I'm not able to get the intended value (""YAY!""). </p>

<p>Instead I got this error:-</p>

<pre><code>Error: Error: Nock: No match for request {
  ""method"": ""GET"",
  ""url"": ""https://server.com/abc"",
  ""headers"": {
    ""referer"": ""about:blank"",
    ""user-agent"": ""Mozilla/5.0 (darwin) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/11.2.0"",
    ""accept-language"": ""en"",
    ""accept"": ""*/*"",
    ""origin"": ""null"",
    ""host"": ""server.com"",
    ""accept-encoding"": ""gzip, deflate""
  }
}
</code></pre>

<p>The <code>console.log(..)</code> on <code>subscribe(..)</code> displays this:-</p>

<pre><code>ERROR { [Error: ajax error]
  message: 'ajax error',
  xhr: 
   XMLHttpRequest {
     upload: XMLHttpRequestUpload { _ownerDocument: [Object] },
     _eventHandlers: { readystatechange: [Object] },
     [Symbol(flag)]: 
      { synchronous: false,
        withCredentials: false,
        mimeType: null,
        auth: null,
        method: 'GET',
        responseType: 'json',
        requestHeaders: {},
        referrer: 'about:blank',
        uri: 'https://server.com/abc',
        timeout: 0,
        body: undefined,
        formData: false,
        preflight: false,
        requestManager: [Object],
        pool: undefined,
        agentOptions: undefined,
        strictSSL: undefined,
        proxy: undefined,
        cookieJar: [Object],
        encoding: 'UTF-8',
        origin: 'null',
        userAgent: 'Mozilla/5.0 (darwin) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/11.2.0' },
     [Symbol(properties)]: 
      { beforeSend: false,
        send: false,
        timeoutStart: 0,
        timeoutId: 0,
        timeoutFn: null,
        client: [Object],
        responseHeaders: {},
        filteredResponseHeaders: [],
        responseBuffer: null,
        responseCache: null,
        responseTextCache: null,
        responseXMLCache: null,
        responseURL: '',
        readyState: 4,
        status: 0,
        statusText: '',
        error: [Object],
        uploadComplete: true,
        uploadListener: false,
        abortError: false,
        cookieJar: [Object],
        bufferStepSize: 1048576,
        totalReceivedChunkSize: 0,
        requestBuffer: null,
        requestCache: null,
        origin: 'null' } },
  request: 
   { async: true,
     createXHR: [Function: createXHR],
     crossDomain: true,
     withCredentials: false,
     headers: {},
     method: 'GET',
     responseType: 'json',
     timeout: 0,
     url: 'https://server.com/abc',
     body: undefined },
  status: 0 }
</code></pre>

<p>My question is how do I configure <code>nock</code> to properly intercept that API call?</p>

<p>Is there a better way to test that API call without using <code>nock</code>?</p>

<p>Thank you.</p>
","341508","","","","","2017-09-26 15:09:47","RxJS: How to test Observable.ajax() with nock?","<javascript><ajax><rxjs><rxjs5><nock>","1","0","","","","CC BY-SA 3.0"
"46420952","1","46432673","","2017-09-26 08:04:09","","4","2065","<p>I have been playing with rxjs and redux-observable for the last few days and have been struggle to find a way to a test for <em>Observable.ajax</em>. I have the following epic which create a request to <a href=""https://jsonplaceholder.typicode.com/"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/</a>,</p>

<pre><code>export function testApiEpic (action$) {
  return action$.ofType(REQUEST)
    .switchMap(action =&gt;
      Observable.ajax({ url, method })
        .map(data =&gt; successTestApi(data.response))
        .catch(error =&gt; failureTestApi(error))
        .takeUntil(action$.ofType(CLEAR))
    )
}
</code></pre>

<p>where,</p>

<pre><code>export const REQUEST = 'my-app/testApi/REQUEST'
export const SUCCESS = 'my-app/testApi/SUCCESS'
export const FAILURE = 'my-app/testApi/FAILURE'
export const CLEAR = 'my-app/testApi/CLEAR'

export function requestTestApi () {
  return { type: REQUEST }
}
export function successTestApi (response) {
  return { type: SUCCESS, response }
}
export function failureTestApi (error) {
  return { type: FAILURE, error }
}
export function clearTestApi () {
  return { type: CLEAR }
}
</code></pre>

<p>The code works fine when runs in browser but not when testing with Jest.</p>

<p>I have try,</p>

<p>1) Create a test based on <a href=""https://redux-observable.js.org/docs/recipes/WritingTests.html"" rel=""nofollow noreferrer"">https://redux-observable.js.org/docs/recipes/WritingTests.html</a>. The store.getActions() returns only { type: REQUEST }.</p>

<pre><code>const epicMiddleware = createEpicMiddleware(testApiEpic)
const mockStore = configureMockStore([epicMiddleware])

describe.only('fetchUserEpic', () =&gt; {
  let store

  beforeEach(() =&gt; {
    store = mockStore()
  })

  afterEach(() =&gt; {
    epicMiddleware.replaceEpic(testApiEpic)
  })

  it('returns a response, () =&gt; {
    store.dispatch({ type: REQUEST })
    expect(store.getActions()).toEqual([
      { type: REQUEST },
      { type: SUCCESS, response }
    ])
  })
})
</code></pre>

<p>2) Create a test based on <a href=""https://stackoverflow.com/questions/43188196/redux-observable-failed-jest-test-for-epic/43188527#43188527"">Redux-observable: failed jest test for epic</a>. It returns with </p>

<blockquote>
  <p>Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.</p>
</blockquote>

<pre><code>  it('returns a response', (done) =&gt; {
    const action$ = ActionsObservable.of({ type: REQUEST })
    const store = { getState: () =&gt; {} }
    testApiEpic(action$, store)
      .toArray()
      .subscribe(actions =&gt; {
        expect(actions).to.deep.equal([
          { type: SUCCESS, response }
        ])
        done()
      })
  })
</code></pre>

<p>Can someone point me out what is the correct way to test Observable.ajax ?</p>
","6549731","","","","","2018-05-10 08:14:39","How can I test Observable.ajax (redux-observable)?","<rxjs5><redux-observable>","2","0","1","","","CC BY-SA 3.0"
"46422574","1","","","2017-09-26 09:24:16","","2","375","<p>Ive recently start using late ngrx (4) and angular 4 versions.
I recently noticed a weird case that always happens.
No matter where in my code., when ever I do something like:</p>

<pre><code>const subscription = 
this.store.select(*someselector*).subscribe(() =&gt;{
console.log(subscription) ;
}
</code></pre>

<p>In previous ngrx version (not 4) and also older type script version (was 2.0.10) the subscription variable would just be undefined in the first time (which is my first question) </p>

<p>Now that I have upgraded to ngrx 4 and typescript 2.4.1, if I try to do a check like (inside the subscribe callback) 
    if (subscription) subscription.unsubscribe();
Im getting a reference error telling me subscription is undefined. </p>

<p>I don't understand both why in the first time its undefined nor why after I upgraded I can't check if its defined with the if statement without getting an exception. </p>
","1245668","","1245668","","2017-09-26 09:57:09","2017-09-26 09:57:09","Ngrx state observable first subscription is always undefined","<angular><typescript><rxjs><rxjs5><ngrx>","0","1","","","","CC BY-SA 3.0"
"46427015","1","46427666","","2017-09-26 12:47:38","","2","1236","<p>I'd like to have confirmation that my use of observables vs. service initialisation is correct or isn't bested by a standard pattern. I'm new to observables.</p>

<p>Say that I have multiple services (e.g. profileService) depending on the readiness of an authService: Some data should only be loaded once a users is known.</p>

<p>The example <code>profileService</code> should only ""obtain the connected user's profile"" when the <code>authentication service</code> emits (<code>observer.next('userConnected')</code>) the signal that a user successfully authenticated to the app.</p>

<p>My <code>profileService</code> looks as follows:</p>



<pre class=""lang-js prettyprint-override""><code>constructor(@Inject(AuthenticationService) private authSvc: AuthenticationService){
        this.authSvc.getAuthChangeObservable().subscribe(data =&gt; this.onAuthenticationChanged(data) );
  }
</code></pre>

<p>While the <code>authenticationService</code> is written as follows:</p>

<pre class=""lang-js prettyprint-override""><code>private authChange: Observable&lt;any&gt;;
private _authObserver: Observer&lt;any&gt;;

constructor(@Inject(FirebaseService) firebaseService: FirebaseService){

    // Cookies or whatever allow .auth() to identify the user after a page refresh
    // This causes a slight delay, see my question below
    firebase.auth().onAuthStateChanged(user =&gt; {
      if(user) this.onAuthenticationSuccessfull(user);
      else this.onLogoutSuccessfull();
    });

    // Create an observable for auth status
    this.authChange = new Observable(observer =&gt; {
      this._authObserver = observer;
    }).share();
  }

  getAuthChangeObservable(){
    return this.authChange;
  }

...

onAuthenticationSuccessfull(user){
    this.authenticatedUser = user;

    // This is mainly the way I found to warn other services they are clear to load the
    // user-related data
    this._authObserver.next('auth');
}
...
</code></pre>

<p>What bothers me: What if there was no delay for authentication? Or in case of a more generic service, how to make sure that all the services depending on it are ready and subscribed to the observable?</p>

<p>I understand there is a race condition with observable.share(). Unless mistaken, whenever share() is called at least once, the first ""pending"" event is fired. And I need to call .share() as I need a ""hot"" observable (i.e. to not re-run the observable's observer <code>.next()</code> routine).</p>

<p>Thanks in advance for sharing advices and tips.</p>
","987818","","3633742","","2017-09-26 12:50:14","2017-09-26 13:17:21","Angular 4 & RxJS: race conditions, service initialisation order and readiness","<angular><rxjs><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"46427666","2","","46427015","2017-09-26 13:17:21","","2","","<p>You can use Subject to simplify the code and it is a hot observable and by default it doesn't cache past event (the share behaviour you described is more like BehaviorSubject)</p>

<p>in your authenticationService</p>

<pre><code>public onAuth=new Subject()
constructor(@Inject(FirebaseService) firebaseService: FirebaseService){

firebase.auth().onAuthStateChanged(user =&gt; {
  if(user) this.onAuth.next(user);
  else this.onLogoutSuccessfull();
})
</code></pre>

<p>in your profile service </p>

<pre><code>constructor(@Inject(AuthenticationService) private authSvc: 
AuthenticationService){
// onlogin
    this.authSvc.onAuth.filter(user=&gt;user&amp;&amp;user.id).map(data=&gt;
// you can perform other operation here e.g chain, combine 
).subscribe()

// onlogout
    this.authSvc.onAuth.filter(user=&gt;!user).map(data=&gt;
// you can perform other operation here e.g chain, combine 
).subscribe()

}
</code></pre>
","8618350","","","","","2017-09-26 13:17:21","","","","1","","","","CC BY-SA 3.0"
"46430120","2","","46415606","2017-09-26 15:09:47","","2","","<p>I figured it out. The key is to define <code>url</code> that matches API under test when initializing <code>JSDOM</code>.</p>

<p>Here's the working version with assertions:-</p>

<pre><code>import { afterEach, describe, it } from 'mocha';
import nock from 'nock';
import { expect } from 'chai';
import { ajax } from 'rxjs/observable/dom/ajax';
import { JSDOM } from 'jsdom';

// defining `url` is important!!
const { window } = new JSDOM('', { url: 'https://server.com' });

const apiUnderTest = ajax({
  url: 'https://server.com/abc',
  crossDomain: true,
  createXHR: () =&gt; new window.XMLHttpRequest(),
});

describe('ajax', () =&gt; {
  const expectedValue = 'YAY!';

  afterEach(() =&gt; {
    nock.cleanAll();
  });

  it('given successful call, should return value', (done) =&gt; {
    nock('https://server.com').get('/abc').reply(200, { value: expectedValue });

    apiUnderTest
      .map(e =&gt; e.response.value)
      .subscribe(
        (actualValue) =&gt; {
          expect(actualValue).to.deep.equal(expectedValue);
          done();
        },
        (error) =&gt; {
          expect(error).to.be.an('undefined');
          done();
        },
      );
  });

  it('given failed call, should not return value', (done) =&gt; {
    nock('https://server.com').get('/abc').reply(400, { value: expectedValue });

    apiUnderTest
      .map(e =&gt; e.response.value)
      .subscribe(
        (actualValue) =&gt; {
          expect.fail(actualValue, undefined, 'Should not have value');
          done();
        },
        (error) =&gt; {
          expect(error).to.not.be.an('undefined');
          done();
        },
      );
  });
});
</code></pre>
","341508","","","","","2017-09-26 15:09:47","","","","0","","","","CC BY-SA 3.0"
"46432673","2","","46420952","2017-09-26 17:37:00","","7","","<p>I would follow the second example, from StackOverflow. To make it work you'll need to make some minor adjustments. Instead of importing <code>Observable.ajax</code> in your epic file and using that reference directly, you need to use some form of dependency injection. One way is to provide it to the middleware when you create it.</p>

<pre><code>import { ajax } from 'rxjs/observable/dom/ajax';

const epicMiddleware = createEpicMiddleware(rootEpic, {
  dependencies: { ajax }
});
</code></pre>

<p>The object we passed as <code>dependencies</code> will be give to all epics as the third argument</p>

<pre><code>export function testApiEpic (action$, store, { ajax }) {
  return action$.ofType(REQUEST)
    .switchMap(action =&gt;
      ajax({ url, method })
        .map(data =&gt; successTestApi(data.response))
        .catch(error =&gt; failureTestApi(error))
        .takeUntil(action$.ofType(CLEAR))
    );
}
</code></pre>

<p>Alternatively, you could not use the <code>dependencies</code> option of the middleware and instead just use default parameters:</p>

<pre><code>export function testApiEpic (action$, store, ajax = Observable.ajax) {
  return action$.ofType(REQUEST)
    .switchMap(action =&gt;
      ajax({ url, method })
        .map(data =&gt; successTestApi(data.response))
        .catch(error =&gt; failureTestApi(error))
        .takeUntil(action$.ofType(CLEAR))
    );
}
</code></pre>

<p>Either one you choose, when we test the epic we can now call it directly and provide our own mock for it. Here are examples for success/error/cancel paths <strong>These are untested and might have issues, but should give you the general idea</strong></p>

<pre><code>it('handles success path', (done) =&gt; {
  const action$ = ActionsObservable.of(requestTestApi())
  const store = null; // not used by epic
  const dependencies = {
    ajax: (url, method) =&gt; Observable.of({ url, method })
  };

  testApiEpic(action$, store, dependencies)
    .toArray()
    .subscribe(actions =&gt; {
      expect(actions).to.deep.equal([
        successTestApi({ url: '/whatever-it-is', method: 'WHATEVERITIS' })
      ])

      done();
    });
});

it('handles error path', (done) =&gt; {
  const action$ = ActionsObservable.of(requestTestApi())
  const store = null; // not used by epic
  const dependencies = {
    ajax: (url, method) =&gt; Observable.throw({ url, method })
  };

  testApiEpic(action$, store, dependencies)
    .toArray()
    .subscribe(actions =&gt; {
      expect(actions).to.deep.equal([
        failureTestApi({ url: '/whatever-it-is', method: 'WHATEVERITIS' })
      ])

      done();
    });
});

it('supports cancellation', (done) =&gt; {
  const action$ = ActionsObservable.of(requestTestApi(), clearTestApi())
  const store = null; // not used by epic
  const dependencies = {
    ajax: (url, method) =&gt; Observable.of({ url, method }).delay(100)
  };
  const onNext = chai.spy();

  testApiEpic(action$, store, dependencies)
    .toArray()
    .subscribe({
      next: onNext,
      complete: () =&gt; {
        onNext.should.not.have.been.called();        
        done();
      }
    });
});
</code></pre>
","1770633","","1770633","","2017-09-27 01:23:20","2017-09-27 01:23:20","","","","0","","","","CC BY-SA 3.0"
"46450262","1","46455271","","2017-09-27 14:16:32","","2","2315","<p>I've set up an epic that waits for another epic to complete, much like @jayphelps' answer here: <a href=""https://stackoverflow.com/questions/42276419/invoking-epics-from-within-other-epics"">Invoking epics from within other epics</a></p>

<p>However I've found that it only seems to run once. After that I can see the <code>CART_CONFIG_READY</code> action in the console but the <code>DO_THE_NEXT_THING</code> action is not triggered.</p>

<p>I've tried various combinations of <code>mergeMap</code> and <code>switchMap</code>, with and without <code>take</code> but nothing seems to help.</p>

<p>This is (kind of) what my code looks like.</p>

<pre class=""lang-js prettyprint-override""><code>import { NgRedux } from '@angular-redux/store';
import { Observable } from 'rxjs/Observable';
import { ActionsObservable } from 'redux-observable';

export class CartEpicsService {

checkCart = (action$: ActionsObservable&lt;any&gt;, store: NgRedux&lt;any&gt;) =&gt; {

    return action$.ofType('CHECK_CART')
        .switchMap(() =&gt; {

            console.log('___LISTENING___');

            return action$.ofType('CART_CONFIG_READY')
                .take(1) // removing this doesn't help
                .mergeMap(() =&gt; {

                    console.log('___RECEIVED___');

                    // do stuff here

                    return Observable.of({
                        type: 'DO_THE_NEXT_THING'
                    });

                })
                .startWith({
                    type: 'GET_CART_CONFIG'
                });

        });

}

getCartConfig = (action$: ActionsObservable&lt;any&gt;, store: NgRedux&lt;any&gt;) =&gt; {

    return action$.ofType('GET_CART_CONFIG')
        .switchMap(() =&gt; {

            const config = store.getState().config;

            // we already have the config
            if (config) {
                return Observable.of({
                    type: 'CART_CONFIG_READY'
                });
            }

            // otherwise load it from the server using out HTTP service
            return this.http.get('/cart/config')
                .switchMap((response) =&gt; {
                    return Observable.concat(
                        Observable.of({
                            type: 'CART_CONFIG_SUCCESS'
                        }),
                        Observable.of({
                            type: 'CART_CONFIG_READY'
                        })
                    );
                })
                .catch(error =&gt; Observable.of({
                    type: 'CART_CONFIG_ERROR',
                    error
                }));


        });

    }

}
</code></pre>

<p>For context I need the response from the /cart/config endpoint to check the validity of the cart. I only need to download the config once.</p>

<p>Here is a runnable example on JS Bin:</p>

<p><a href=""https://jsbin.com/vovejibuwi/1/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/vovejibuwi/1/edit?js,console</a></p>
","3191425","","3191425","","2017-09-27 14:47:36","2017-09-28 19:14:50","Chained redux-observable epic only fires correctly once","<rxjs><rxjs5><redux-observable>","1","0","1","","","CC BY-SA 3.0"
"46452145","1","46452208","","2017-09-27 15:47:15","","0","2541","<p>Angular4 Rxjs trying simple operation as count filter results but following code returns me <code>Observable</code> instead of number</p>

<p>any help is appreciated</p>

<pre><code>Observable.from(myList).bla().filter(..).count(); 
</code></pre>

<p>returns be observable</p>
","216431","","","","","2017-09-27 15:57:20","angular Rxjs filter and count returns of Observable instead of number","<angular><rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"46452208","2","","46452145","2017-09-27 15:51:08","","3","","<p>All operator in RxJS returns <code>Observable</code>, including <code>count</code> operator as well. Count does count number of emission until source completes, then emit its number to observer. To get values you need to subscribes like <code>...count().subscribe(c =&gt; { /*c is counted value*/ });</code>.</p>
","2742189","","","","","2017-09-27 15:51:08","","","","0","","","","CC BY-SA 3.0"
"46452549","1","46452663","","2017-09-27 16:08:43","","-1","531","<p>I have following code which group and count items by type. i want to make a change and make <code>groupBy</code> <code>return</code> single object.</p>

<p>for example after mergeMap complete its operation, i want to attach another operator which will analyze following result and return single value 'true' or 'false' for whole result set.</p>

<pre><code>{ type: 'foo', total: 1 }
{ type: 'bar', total: 2 }

const list = [{ type: 'foo' }, { type: 'bar' }, { type: 'bar' }];

Observable.from( list ).groupBy( x =&gt; x.type )
  .mergeMap( list$ =&gt; { // each emission is a stream

    /* A stream of ""aggregated"" data. */
    const count$ = list$.count();

    /* Format the result. */
    return count$.map( count =&gt; ({ type: list$.key, count }));
  }).subscribe(r =&gt; console.log(r));
</code></pre>

<p>This emits:</p>

<pre><code>{ type: 'foo', total: 1 }
{ type: 'bar', total: 2 }
</code></pre>
","216431","","","","","2017-09-27 16:15:06","angular rxjs groupby mergemap return single value","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46452663","2","","46452549","2017-09-27 16:15:06","","1","","<p>I guess you can use the reduce() method (<a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/reduce.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/reduce.md</a>)</p>

<p>""Applies an accumulator function over an observable sequence, <strong>returning the result of the aggregation as a single element</strong> in the result sequence""</p>
","640053","","","","","2017-09-27 16:15:06","","","","0","","","","CC BY-SA 3.0"
"46454458","1","46456915","","2017-09-27 18:04:50","","0","438","<p>angular4 typescript rxjs 5</p>

<p>I have complex type passed in reduce method but i want return type to be different boolean .</p>

<p>Rite now with following code i am getting return type error not match</p>

<pre><code>Observable.from(myList).reduce((complex1, complex2) =&gt; {
return complex1.flag &amp;&amp; complex2.flag; // gives me error
})
</code></pre>
","216431","","","","","2017-09-27 20:43:49","angular4 rxjs Observable reduce returns type different then original passed in","<angular><rxjs><rxjs5>","1","4","1","","","CC BY-SA 3.0"
"46455271","2","","46450262","2017-09-27 18:54:22","","5","","<p>Dang this is definitely a tricky one!</p>

<h1>Cause</h1>

<p>When <code>state.config === true</code> you return an Observable of <code>CART_CONFIG_READY</code> that emits synchronously, whereas during the first time the http request (or delay, in the jsbin) means it is always going to be async.</p>

<p>Why this makes a difference is in the <code>checkCart</code> epic you return an observable chain that listens for <code>CART_CONFIG_READY</code> with <code>action$.ofType('CART_CONFIG_READY')</code> but also applies a <code>.startWith({ type: 'GET_CART_CONFIG' })</code>. That means that <code>GET_CART_CONFIG</code> is going to be emitted synconously <strong>before</strong> <code>action$.ofType('CART_CONFIG_READY')</code> is subscribed because <code>startWith</code> is <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/operators/startWith.ts#L44-L49"" rel=""nofollow noreferrer"">basically shorthand for a concat</a>, which might would make the issue more clear if you're familiar with it. It's nearly exactly the same as doing this:</p>

<pre><code>Observable.concat(
  Observable.of({
    type: 'GET_CART_CONFIG'
  }),
  action$.ofType('CART_CONFIG_READY') // not subscribed until prior complete()s
    .take(1)
    .mergeMap(() =&gt; {
      // stuff
    })
);
</code></pre>

<p>So to summarize, what is happening the second time around <code>GET_CART_CONFIG</code> is dispatched synchronously, <code>getCartConfig</code> receives it and sees the config is already in the store so it synchronously dispatches <code>CART_CONFIG_READY</code>. But we are not yet listening for it in <code>checkCart</code> so it goes unanswered. Then that callstack returns and the next Observable in the concat, our <code>action$.ofType('CART_CONFIG_READY')</code> chain, gets subscribed to. But too late, the action it listens for has already been emitted!</p>

<h1>Solutions</h1>

<p>One way to fix this is to make either the emitting of <code>CART_CONFIG_READY</code> always async, or to start listening for it in the other epic <em>before</em> we dispatch <code>GET_CART_CONFIG</code>.</p>

<h3>1. emit CART_CONFIG_READY async</h3>

<p><code>Observable.of</code> accepts a scheduler as its last argument, and <a href=""http://reactivex.io/rxjs/manual/overview.html#scheduler"" rel=""nofollow noreferrer"">RxJS supports several of them</a>. </p>

<p>In this case you could use the <code>AsyncScheduler</code> (macrotask) or the <code>AsapScheduler</code> (microtask). Both will work in this case, but they schedule on different times in the JavaScript event loop. If you're not familiar with event loop tasks, <a href=""https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/"" rel=""nofollow noreferrer"">check this out</a>.</p>

<p>I would personally recommend using the <code>AsyncSheduler</code> in this case because it will provide the closest async behavior to making an http request.</p>

<pre><code>import { async } from 'rxjs/scheduler/async';

// later inside your epic...

return Observable.of({
  type: 'CART_CONFIG_READY'
}, async);
</code></pre>

<h3>2. Listen for <code>CART_CONFIG_READY</code> before emitting <code>GET_CART_CONFIG</code></h3>

<p>Because <code>startWith</code> is shorthand for a <code>concat</code> (which we don't want to do) we instead need to use some form of <code>merge</code>, with our <code>ofType</code> chain first so that we listen before emitting.</p>

<pre><code>action$.ofType('CART_CONFIG_READY')
  .take(1)
  .mergeMap(() =&gt; {
    // stuff
  })
  .merge(
    Observable.of({ type: 'GET_CART_CONFIG' })
  )

// or

Observable.merge(
  action$.ofType('CART_CONFIG_READY')
    .take(1)
    .mergeMap(() =&gt; {
      // stuff
    }),
  Observable.of({ type: 'GET_CART_CONFIG' })
)

// both are exactly the same, pick personal preference on appearance
</code></pre>

<p>You only need to do one of these solutions, but it wouldn't hurt to do both of them. Offhand I would probably recommend using both just so that things are consistent and expected, even if they are a bit more verbose.</p>

<hr>

<p>You might also be happy to know that <code>Observable.of</code> accepts any number of items, which will be emitted in order. So you don't need to use <code>concat</code>:</p>

<pre><code>// before

Observable.concat(
  Observable.of({
    type: 'CART_CONFIG_SUCCESS'
  }),
  Observable.of({
    type: 'CART_CONFIG_READY'
  })
)

// after

Observable.of({
  type: 'CART_CONFIG_SUCCESS'
}, {
  type: 'CART_CONFIG_READY'
})
</code></pre>

<p>Thanks so much for the jsbin btw, it made it <strong>much</strong> easier to debug.</p>

<hr>

<p>Edit based on your comment:</p>

<blockquote>
  <p>Out of curiosity did you figure this out through experience or debugging?</p>
</blockquote>

<p>A combination of both. I've dealt with a ton of async/scheduled code and ordering is very commonly the source of issues. I scanned the code, mentally picturing execution, noticed the difference in async vs sync depending on codepath, then I made a quick operator to make it easy for me to confirm the order in which any Observable chain is subscribed to.</p>

<pre><code>Observable.prototype.logOnSubscribe = function (msg) {
  // defer is a pretty useful Observable to learn if you haven't yet
  return Observable.defer(() =&gt; {
    console.log(msg);
    return this; // the original source
  });
};
</code></pre>

<p>I applied it to several places, but the most important are these two:</p>

<pre><code>action$.ofType('CART_CONFIG_READY')
  .take(1)
  .mergeMap(() =&gt; {
    // stuff
  })
  .logOnSubscribe('listening for CART_CONFIG_READY') // &lt;--- here
  .startWith({
    type: 'GET_CART_CONFIG'
  });

  //  and in the other epic...

  if (hasConfig) {
    return Observable.of({
      type: 'CART_CONFIG_READY'
    })
    .logOnSubscribe('emitting CART_CONFIG_READY');  // &lt;--- and here
  }
</code></pre>

<p>It confirmed that in the second code path <code>CART_CONFIG_READY</code> was getting emitted before the other epic was listening for it.</p>
","1770633","","1770633","","2017-09-28 19:14:50","2017-09-28 19:14:50","","","","3","","","","CC BY-SA 3.0"
"46455512","2","","46081614","2017-09-27 19:09:04","","0","","<p>I found the solution to the issue with my upgrade to Angular 4.0. Basically, I upgraded my RxJs from 5.0.1 to 5.4.3 and it now supports HttpClient module from location @angular/common/http rather than Http from @angular/http.</p>

<p>I upgraded all refrences to HttpClient and updated my code like the following and it fixed the issue. I hope it helps someone. 
The point is during upgade to Angular 4, remember to upgrade your http to httpClient.</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';

@Injectable()
export class ContactService {


loggedContact: CostarContactVM;

  getLoggedContact(): Observable&lt;ContactVM&gt; {
     return this.httpClient.get&lt;ContactVM&gt;(this.contactUrl)
        .catch(this.handleError)
        .do((data) =&gt; {
            this.assignPermissions(data);
        });
}
</code></pre>
","372450","","","","","2017-09-27 19:09:04","","","","0","","","","CC BY-SA 3.0"
"46456915","2","","46454458","2017-09-27 20:43:49","","1","","<p>Guessing that <code>myList</code> is <code>Array&lt;{ flag: bool }&gt;</code> and you want to check if all flags are true, you probably want:</p>

<pre><code>Observable.from(myList)
          .reduce((accumulated, complex) =&gt; accumulated &amp;&amp; complex.flag, true);
</code></pre>

<p>Your reducing function is responsible for combining the previous iteration value (or second argument, initially) with the newly-emitted value from your <code>Observable</code>, in order to reduce your stream to a scalar value. This way, your reducing function has the same return type <em>and</em> first-argument type as the final value.</p>
","3925507","","","","","2017-09-27 20:43:49","","","","0","","","","CC BY-SA 3.0"
"46494918","1","46497718","","2017-09-29 18:27:44","","1","389","<p>I just started using Redux-Observable. I want to make a generic epic that requests data from the server. I want multiple requests with same action and id to be debounced. However, I'm not sure how to do this without creating multiple epics.</p>

<pre><code>const TYPE_IFEXISTS_REQUEST = 'IFEXISTS_REQUEST';
export const IFEXISTS_REQUEST = (id, value) =&gt;
  ({ type: TYPE_IFEXISTS_REQUEST, id, value });
export const IFEXISTS_EPIC = action$ =&gt;
  action$
    .ofType(TYPE_IFEXISTS_REQUEST)
    .debounceTime(5000) // ERROR: debounces based on action type and not id
    .mergeMap(action =&gt;
      fromPromise(api.get(`/api/exists/${action.id}/${action.value}`))
        .map(({ data }) =&gt; IFEXISTS_SUCCESS(action.id, data))
        .catch(() =&gt; of(IFEXISTS_FAILURE(action.id, 'Server error'))));
</code></pre>

<p>How is it possible to create a generic epic that debounces based on both action and id?</p>

<hr>

<p>Update: Never knew about GroupBy. It worked well with switchMap. The following is was I used.</p>

<pre><code>action$
    .ofType(TYPE_IFEXISTS_REQUEST)
    .groupBy(action =&gt; action.id)
    .mergeMap(actionByIdGroup$ =&gt; 
        actionByIdGroup$
            .debounceTime(5000) // debounces based on action id
            .switchMap(action =&gt;
                fromPromise(api.get(`/api/exists/${action.id}/${action.value}`))
                    .map(({ data }) =&gt; IFEXISTS_SUCCESS(action.id, data))
                    .catch(() =&gt; of(IFEXISTS_FAILURE(action.id, 'Server error')))
            );
    )
</code></pre>
","1370984","","1370984","","2017-10-01 06:51:23","2017-10-01 06:51:23","Generic Epic using Redux-Observable","<javascript><redux><rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"46497718","2","","46494918","2017-09-29 22:30:29","","3","","<p>You can use the <a href=""https://gist.github.com/btroncone/d6cf141d6f2c00dc6b35#groupby"" rel=""nofollow noreferrer"">groupBy</a> operator:</p>

<pre><code>  action$
    .ofType(TYPE_IFEXISTS_REQUEST)
    .groupBy(action =&gt; action.id)
    .mergeMap(actionByIdGroup$ =&gt; 
        actionByIdGroup$
            .debounceTime(5000) // debounces based on action id
            .mergeMap(action =&gt;
                fromPromise(api.get(`/api/exists/${action.id}/${action.value}`))
                    .map(({ data }) =&gt; IFEXISTS_SUCCESS(action.id, data))
                    .catch(() =&gt; of(IFEXISTS_FAILURE(action.id, 'Server error')))
            );
    )
</code></pre>

<p>The <em>actionByIdGroup$</em> is a Grouped Observable of the same action ids. Meaning, only actions with the same id will be part of the same stream. In this case, the <em>debounceTime</em> will be applied for actions with the same id.</p>
","3306656","","","","","2017-09-29 22:30:29","","","","1","","","","CC BY-SA 3.0"
"46509419","1","","","2017-10-01 05:10:15","","0","184","<pre><code>export class AppComponent implements OnInit {

  movieList: Observable&lt;any&gt;;
  constructor(private AppService:AppService){

  }
  ngOnInit() {
      this.getMovies();
  }

  getMovies() {

    this.movieList = this.AppService.getMovies().map(movie =&gt; {
      return {
        name: movie.name
      }
    });


  this.movieList.subscribe(data =&gt; {
    debugger;
  })
  }
}
</code></pre>

<p>I want to perform Rxjs operations on observable this.movieList but Data in debugger returns undefined when i subscribe to this.movieList</p>
","1979282","","","","","2017-10-01 08:39:26","how to map rxjs operators on observable returned from service in component","<angular><rxjs5><angular2-observables>","1","2","","","","CC BY-SA 3.0"
"46510923","1","46513445","","2017-10-01 09:14:41","","0","600","<p>I'm weirdly stuck with the following:</p>

<ul>
<li>I have an Observable that emits either an array with some items or an empty array, and this Observable emits only once - let's call it <code>startingArray$</code></li>
<li>Then I have a hot Observable that emits individual items that I would like to push to <code>startingArray</code> once <code>startingArray</code> has been emitted - let's call it <code>additions$</code></li>
<li>What code gives me the resulting observable <code>startingArrayPlusAdditions$</code> that continuosly grows as more items are emitted? </li>
<li><code>startingArrayPlusAdditions$</code> should emit every time <code>additions$</code> emits, but it should not emit when <code>startingArray$</code> emits initially</li>
</ul>
","742084","","","","","2017-10-01 14:38:39","Start with observable of an array and then push items on it from an item observable","<rxjs><observable><reactive-programming><rxjs5>","1","2","","","","CC BY-SA 3.0"
"46513445","2","","46510923","2017-10-01 14:38:39","","2","","<p>Not sure that I understood all your problem but here's a proposal:</p>

<pre><code>const { Observable }  = Rx;

const startingArray$ = Observable.of([1, 2, 3]);

const additions$ = Observable.from([4, 5, 6, 7, 8]);

const startingArrayPlusAdditions$ = startingArray$
  .combineLatest(additions$)
  .scan((acc, current) =&gt; {
    const [startingArray, addition] = current;

    if (acc === null) {
      return [...startingArray, addition];
    } else {
      acc.push(addition);
      return acc;
    }
  }, null)
  .do(console.log)
  .subscribe();
</code></pre>

<p>The output is:</p>

<pre><code>[1, 2, 3, 4]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>

<p>So just as you asked:</p>

<blockquote>
  <p>startingArrayPlusAdditions$ should emit every time additions$ emits, but it should not emit when startingArray$ emits initially</p>
</blockquote>

<p>Here's a working Plunkr: <a href=""https://plnkr.co/edit/rKXLJrmA7mSzpQgoemlD?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/rKXLJrmA7mSzpQgoemlD?p=preview</a></p>
","2398593","","","","","2017-10-01 14:38:39","","","","0","","","","CC BY-SA 3.0"
"46522814","1","46522913","","2017-10-02 09:24:43","","1","272","<p>I have the following lines of code:</p>

<pre><code>this.initializer.initialize()
    .catch((e) =&gt; { console.log('catch'); return Observable.empty() })
    .flatMap(() =&gt; { console.log('flatmap'); return this.route.params })
    .subscribe(() =&gt; { console.log('subscribe'); })
</code></pre>

<p>The logged output is</p>

<pre><code>catch
</code></pre>

<p>What could be causing the <code>flatMap</code>, and consequently the subscribe to not be called? Not sure what other code could be relevant here, if anything else is needed, I will supply it.</p>
","1001966","","310726","","2018-02-04 09:08:28","2018-02-04 09:08:28","Rxjs subscribe after catch is not called","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46522913","2","","46522814","2017-10-02 09:30:08","","2","","<p>This is obviously caused by <code>this.initializer.initialize()</code> emitting an <code>error</code> notification (is this intended?).</p>

<p>The <code>catch</code> operator reacts only to <code>error</code> notifications, not <code>next</code> neither <code>complete</code>.</p>

<p>The <code>flatMap()</code> operator reacts only to <code>next</code> notifications, not <code>error</code> neither <code>complete</code>.</p>

<p>The <code>subscribe</code> call as you have it right now only handles <code>next</code> notifications. You could rewrite it to handle also <code>error</code>s:</p>

<pre><code>.subscribe(
  () =&gt; console.log('subscribe'),
  err =&gt; console.log('error:', err), 
)
</code></pre>

<p>However you're using <code>catch</code> and you basically replace the error with <code>Observable.empty()</code> so it never reaches the subscriber so the error handler won't be called anyway.</p>
","310726","","","","","2017-10-02 09:30:08","","","","9","","","","CC BY-SA 3.0"
"46559138","1","","","2017-10-04 07:19:14","","0","216","<p>I have 2 sibling component having a service which has HTTP call to render a json. 
OnInit, the Component B fetches the HTTP response calling the service and loads the screen.
The click event on the Component A, should make the component B to refresh its data.</p>

<p>I followed the answer posted by ObjectiveTC from -> <a href=""https://stackoverflow.com/questions/36271899/what-is-the-correct-way-to-share-the-result-of-an-angular-2-http-network-call-in/46558833#46558833"">What is the correct way to share the result of an Angular 2 Http network call in RxJs 5?</a> </p>

<pre><code>    _docdata: BehaviorSubject&lt;DetailSection[]&gt; = new BehaviorSubject&lt;DetailSection[]&gt;([]);

service.getData(){return  this.http.get(this.url)
        .map((res) =&gt;{this._docdata = (res.json()); console.log(""1st return""); return this._docdata; })     
        .catch((error:any) =&gt; Observable.throw(error|| 'Server error'));  }
</code></pre>

<p>This worked fine.</p>

<pre><code>refresh(){
this.http.get(""../../assets/reqd-detail.json"")
        .map(res =&gt; res.json())
        .subscribe((data:Array&lt;DetailSection&gt;) =&gt; this._docdata.next(data));
}
</code></pre>

<blockquote>
  <p>getting error --> ERROR TypeError: _this._docdata.next is not a
  function
      at SafeSubscriber._next (detail.service.ts:156)
      at SafeSubscriber.webpackJsonp.../../../../rxjs/Subscriber.js.SafeSubscriber.__tryOrUnsub
  (Subscriber.js:238)
      at SafeSubscriber.webpackJsonp.../../../../rxjs/Subscriber.js.SafeSubscriber.next
  (Subscriber.js:185)
      at Subscriber.webpackJsonp.../../../../rxjs/Subscriber.js.Subscriber._next
  (Subscriber.js:125)
      at Subscriber.webpackJsonp.../../../../rxjs/Subscriber.js.Subscriber.next
  (</p>
</blockquote>
","8537141","","5475289","","2017-10-04 08:00:05","2017-10-05 05:42:55","HTTP response caching and nexting in BehaviourSubject in AngularJS 2/4","<angular><http><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"46577634","1","","","2017-10-05 03:59:23","","0","494","<p>Is it possible to create observables similar to how Bluebird's <code>promisify</code> works?</p>

<p>Reference: <a href=""http://bluebirdjs.com/docs/api/promise.promisify.html"" rel=""nofollow noreferrer"">http://bluebirdjs.com/docs/api/promise.promisify.html</a></p>

<h3>Regular way to handle callbacks</h3>

<pre><code>someFunc = callback =&gt; handleCallback(callback)
</code></pre>

<h3>Handling callbacks with a Promise</h3>

<pre><code>someFunc = callback =&gt; (
    new Promise(resolve =&gt; handleCallback(resolve))
    .then(callback)
)
</code></pre>

<h3>Fancy Bluebird wrapper around manually handling callbacks with a Promise</h3>

<pre><code>someFunc = callback =&gt; (
    Promise.promisify(handleCallback)()
    .then(callback)
)
</code></pre>

<p>In the same vein, a similar requirement is required for observables:</p>

<h3>Observable Creation</h3>

<pre><code>someFunc = callback =&gt; (
    Rx.Observable
    .create(observer =&gt; (
        handleCallback(() =&gt; observer.next())
    ))
    .subscribe(callback)
)
</code></pre>

<h3>Callback Observable Wrapper</h3>

<pre><code>someFunc = callback =&gt; (
    Rx.Observable
    .fromCallback(handleCallback)
    .subscribe(callback)
)
</code></pre>
","1624862","","1624862","","2017-10-05 04:13:18","2017-10-05 04:43:30","Promisify for Observables in RxJS5","<javascript><callback><rxjs><bluebird><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46591111","1","","","2017-10-05 16:59:37","","1","469","<p>I have a scenario where 1 observable listens for events, which should then fire another asynchrounous event, and wait before it runs the next item in the source Observable. </p>

<p>The first observable can be triggered much faster than the the async event, and it must wait for the async event to complete before it takes another item from the 1st observable.</p>

<p>So.. essentially I  need to set up a 'queue' from the first observable (as I cant lose the data from source 1)</p>

<p>Source 2 should take 1 item at a time from the queue, run it, remove the item from the queue, and go onto the next item in the queue .</p>

<pre><code>src1-  --ev1---ev2---ev3----ev4---ev5--ev6---
src2-  --ev1------------ev2-------------ev3--------ev4-------ev5------ev6
--------------async-----------async---------async------async------asyc
</code></pre>

<p>I was looking at the RX docs and it seems that pausibleBuffered could be a solution but I noticed it has been removed in RX5, which is what I am using.  Can someone give advice as the right way to accomplish this ?
Thanks!</p>
","130560","","","","","2017-10-10 05:48:57","RxJS - pausing an Observable until second Observable completes,","<rxjs><observable><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"46602541","1","46630940","","2017-10-06 09:25:18","","8","3705","<p>Consider using the <a href=""https://www.learnrxjs.io/operators/combination/zip.html"" rel=""noreferrer"">zip</a> operator to zip together two infinite Observables, one of which emits items twice as frequently as the other.<br>
The current implementation is loss-less, i.e. if I keep these Observables emitting for an hour and then I switch between their emitting rates, the first Observable will eventually catch up with the other.<br>
This will cause memory explosion at some point as the buffer grows larger and larger.<br>
The same will happen if first observable will emit items for several hours and the second will emit one item at the end.  </p>

<p>How do I achieve lossy behavior for this operator?  I just want to emit anytime I get emissions from both streams and I don't care how many emissions from the faster stream I miss.</p>

<p><strong>Clarifications:</strong>  </p>

<ul>
<li>Main problem I'm trying to solve here is memory explosion due to the loss-less nature of <code>zip</code> operator.</li>
<li>I want to emit anytime I get emissions from <strong>both</strong> streams even if both streams emit the same value every time</li>
</ul>

<p><strong>Example:</strong>  </p>

<pre><code>Stream1: 1 2    3 4    5 6 7                
Stream2:     10     20       30 40 50 60 70
</code></pre>

<p>Regular <code>zip</code> will produce the following output: </p>

<pre><code>[1, 10]
[2, 20]
[3, 30]
[4, 40]
[5, 50]
[6, 60]
[7, 70]
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const Observable = Rx.Observable;
const Subject = Rx.Subject;


const s1 = new Subject();
const s2 = new Subject();

Observable.zip(s1,s2).subscribe(console.log);

s1.next(1); s1.next(2); s2.next(10); s1.next(3); s1.next(4); s2.next(20); s1.next(5); s1.next(6); s1.next(7); s2.next(30); 
 
s2.next(40); s2.next(50); s2.next(60); s2.next(70); </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>The output I'd like it to produce:</p>

<pre><code>[1, 10]
[3, 20]
[5, 30]
</code></pre>

<p><strong><em>Explanation:</strong><br>
Lossy <code>zip</code> operator is <code>zip</code> with buffer size <code>1</code>. That means it will only keep the first item from the stream that emitted first and will loose all the rest (items that arrive between first item and first emission from the second stream). So what happens in the example is the following: <code>stream1</code> emits <code>1</code>, lossy zip ""remembers"" it and ignores all the items on <code>stream1</code> until <code>stream2</code> emits. First emission of <code>stream2</code> is <code>10</code> so <code>stream1</code> looses <code>2</code>. After mutual emission (the first emission of lossy <code>zip</code>) it starts over: ""remember"" <code>3</code>, ""loose"" <code>4</code>, emit <code>[3,20]</code>. Then start over: ""remember"" <code>5</code>, ""loose"" <code>6</code> and <code>7</code>, emit <code>[5,30]</code>. Then start over: ""remember"" <code>40</code>, ""loose"" <code>50</code>,<code>60</code>,<code>70</code> and wait for the next item on <code>stream1</code>.</em></p>

<p><strong>Example 2:</strong>  </p>

<pre><code>Stream1: 1 2 3 ... 100000000000
Stream2:                        a
</code></pre>

<p>Regular <code>zip</code> operator will explode the memory in this case.<br>
I don't want it to.</p>

<p><strong>Summary:</strong><br>
Essentially I expect the lossy <code>zip</code> operator to remember only the first value emitted by <code>stream 1</code> <em>after previous mutual emission</em> and emit when <code>stream 2</code> catches up with <code>stream 1</code>. And repeat.</p>
","1544364","","1544364","","2017-10-09 07:21:45","2019-12-17 12:51:50","RxJs: lossy form of zip operator","<javascript><rxjs><reactive-programming><rxjs5><backpressure>","5","2","3","","","CC BY-SA 3.0"
"46612520","1","","","2017-10-06 19:16:29","","1","147","<p>I am having trouble creating a reproducible example so bear with me.</p>

<p>I have a library I created that wraps async API responses in an Observable. Simplifying greatly, the library has functions like <code>lib.ask(""end-point"")</code> that return an Observable with the response of the API call to that end point.</p>

<p>I want to run that API call every time another event happens. I'm attempting to model that with some version of mergeMap/switchMap/concatMap, depending on the situation. Let's use mergeMap as an example.</p>

<p>If I use map + mergeAll, it works just fine. I am writing it like so:</p>

<pre><code>var responses$ = event$.pipe(
    map(()=&gt;lib.ask(""end-point"")),
    mergeAll()
);
</code></pre>

<p>When I subscribe to responses$, I get my response!</p>

<p>However, if I rewrite the same chain with mergeMap instead, it does not work:</p>

<pre><code>var responses$ = event$.pipe(
    mergeMap(()=&gt;lib.ask(""end-point""))
);
</code></pre>

<p>In this case, when I subscribe I do not get any results. It almost appears as if the inner subscription never gets made.</p>

<p>Like I said, I am struggling to create a reproducible example. I have attempted to debug what RxJS does to try to find where this thing is failing, but have not been able to figure it out. If anyone can think of why or in what situations mergeMap would behave differently than map + mergeAll, that might help me figure out where my problem is.</p>
","5880623","","","","","2017-10-06 19:16:29","RxJS 5.5.0-beta : mergeMap behavior differing from map + mergeAll","<rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"46630940","2","","46602541","2017-10-08 12:07:53","","10","","<p>The following will give you the desired behavior:</p>

<pre><code>Observable.zip(s1.take(1), s2.take(1)).repeat()
</code></pre>

<p>In <code>RxJs 5.5+</code> pipe syntax:</p>

<pre><code>zip(s1.pipe(take(1)), s2.pipe(take(1))).pipe(repeat());
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const s1 = new Rx.Subject();
const s2 = new Rx.Subject();

Rx.Observable.zip(s1.take(1), s2.take(1)).repeat()
    .subscribe(console.log);

s1.next(1); s1.next(2); s2.next(10); s1.next(3); s1.next(4); s2.next(20); s1.next(5); s1.next(6); s1.next(7); s2.next(30);  
s2.next(40); s2.next(50); s2.next(60); s2.next(70); </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Explanation:</strong></p>

<ul>
<li><code>repeat</code> operator (in its current implementation) resubscribes to the source observable upon the latter's completion, i.e. in this particular case it resubscribes to <code>zip</code> upon every mutual emission.</li>
<li><code>zip</code> combines two observables and waits for both of them to emit. <code>combineLatest</code> will do as well, it doesn't really matter because of <code>take(1)</code></li>
<li><code>take(1)</code> actually takes care of memory explosion and defines lossy behavior</li>
</ul>

<p>If you want to take the last instead of the first value from each stream upon mutual emission use this:</p>

<pre><code>Observable.combineLatest(s1, s2).take(1).repeat()
</code></pre>

<p>In <code>RxJs 5.5+</code> pipe syntax:</p>

<pre><code>combineLatest(s1.pipe(take(1)), s2.pipe(take(1))).pipe(repeat());
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const s1 = new Rx.Subject();
const s2 = new Rx.Subject();

Rx.Observable.combineLatest(s1,s2).take(1).repeat()
    .subscribe(console.log);

s1.next(1); s1.next(2); s2.next(10); s1.next(3); s1.next(4); s2.next(20); s1.next(5); s1.next(6); s1.next(7); s2.next(30);  
s2.next(40); s2.next(50); s2.next(60); s2.next(70); </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1544364","","1544364","","2019-12-17 12:51:50","2019-12-17 12:51:50","","","","7","","","","CC BY-SA 4.0"
"46649999","1","","","2017-10-09 15:28:54","","0","324","<p>Consider following stream:</p>

<pre><code> const oEmailValid$ = oEmailInput$
      .map(_catchInputCtrlValue)
      .map(_isStringNotEmpty) 
      .map(...)
      .map(...)
      .map(...)
      .map(...)
      .subscribe((predicate) =&gt; console.log(predicate))
</code></pre>

<p>Suppose <code>_isStringNotEmpty</code> returns <code>false</code>, so I wan't to continue the stream but still want to receive on the subscribe function the returned value of <code>_isStringNotEmpty</code>, in this case is <code>false</code>.   </p>

<p>How to get it? </p>

<p>To clarify, what I mean, consider the following <code>Haskell</code> code:</p>

<pre><code>(Just 3) &gt;&gt;= (\_ -&gt; Just 4) &gt;&gt;= (\_ -&gt; Just 7) &gt;&gt;= (\_ -&gt; Nothing) &gt;&gt;= (\_ -&gt; Just 10)
</code></pre>

<p>As the result I've got <code>Nothing</code>, because the 4th computation returns <code>Nothing</code>.</p>
","1743843","","","","","2017-10-10 20:13:25","Handle stream like maybe monad","<javascript><haskell><rxjs5>","5","1","","","","CC BY-SA 3.0"
"46679701","1","46680433","","2017-10-11 04:12:01","","6","2511","<p>I am new to Rxjs and am trying to learn how to integrate it with a simple React component without any external wrapper/library. I got this working here:</p>

<pre><code>const counter = new Subject()

class App extends Component {

  state = {
    number: 0
  }

  componentDidMount() {
    counter.subscribe(
      val =&gt; {
        this.setState({ number: this.state.number + val })
      }
    )
  }

  increment = () =&gt; {
    counter.next(+1)
  }

  decrement = () =&gt; {
    counter.next(-1)

  }


  render() {
    return (
      &lt;div style={styles}&gt;
        Current number {this.state.number} 
        &lt;br /&gt; &lt;br /&gt;
        &lt;button onClick={this.increment}&gt;Plus&lt;/button&gt;
        &lt;button onClick={this.decrement}&gt;Minus&lt;/button&gt;
      &lt;/div&gt;
    )
  }
</code></pre>

<p><a href=""https://codesandbox.io/s/02j7qm2xw"" rel=""noreferrer"">https://codesandbox.io/s/02j7qm2xw</a></p>

<p>I trouble is that this uses Subjects which is a known anti-pattern according to experts like Ben Lesh:
<a href=""https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93"" rel=""noreferrer"">https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93</a></p>

<p>I tried doing this:</p>

<pre><code>var counter = Observable.create(function (observer) {
  // Yield a single value and complete
  observer.next(0);

  // Any cleanup logic might go here
  return function () {
    console.log('disposed');
  }
});

class App extends Component {

  state = {
    number: 0
  }

  componentDidMount() {
    counter.subscribe(
      val =&gt; {
        this.setState({ number: this.state.number + val })
      }
    )
  }

  increment = () =&gt; {
    counter.next(+1)
  }

  decrement = () =&gt; {
    counter.next(-1)

  }


  // - render

}
</code></pre>

<p>But this fails with the error: <code>counter.next is not a function</code></p>

<p>So How would I use <code>new Observable()</code> or <code>Observable.create()</code>and use it to <code>setState</code> with a plain React component?</p>
","228521","","228521","","2017-10-11 05:13:01","2019-09-10 08:59:23","How do I integrate rxjs observables with a plain React Component?","<reactjs><rxjs><observable><rxjs5>","1","2","3","","","CC BY-SA 3.0"
"46680433","2","","46679701","2017-10-11 05:23:08","","7","","<p>Because <code>.next()</code> is an <code>Observer</code>'s method, <strong>NOT</strong> <code>Observables</code>. </p>

<p>The reason why <code>Subject</code> works simply because <code>Subject</code> itself is both an <code>observer</code> and an <code>observable</code>. When you call <code>subject.next()</code>, you are simply just updating the <code>observable</code> part, and notify all the <code>observers</code> about the change.</p>

<p>It can be quite confusing sometimes when comes to <code>Observable</code> and <code>Observers</code>. To make it simple, think of this way:  <code>Observable</code> is someone who produces the data, a.k.a. <em>data producers</em>; while <code>Observer</code> is someone who consume the data, a.k.a. <em>data consumer</em>. In a simple analogy, consumer eats what is produced. For the same token, Observer(consumer) observes(eats) the observable (produced).</p>

<p>In your context (or at least React/Redux paradigm), <code>Subject</code> works better. That is because <code>Subject</code> has state. It keep tracks of the value over the production of data (job of the <code>Observable</code>). Every time the observable (the one inside Subject) changes, or update, any <code>observers</code> that subscribes to the <code>Subject</code> will get notified. See the pattern similar to redux here? Every time your redux store is updated, your view gets notified (and hence updated). In fact, if you are very used to reactive programming, you can eliminate the use of redux store completely, and fully replace them by <code>Subject</code>s and/or <code>BehaviourSubject</code>s. </p>

<p>For the post from Ben Lesh, he is merely stating this: Always use an <code>Observable</code> if possible, only use <code>Subject</code> when it is really needed. In that particular post, he is stating that a click event can just be an <code>Observable</code>; using <code>Subject</code> will be inappropriate. However, in your context, which is react/redux, using <code>Subject</code> is fine - because the <code>Subject</code> is used to keep track of the state of the store, and <strong>NOT</strong> the click event handler.</p>

<p><strong>TLDR:</strong></p>

<ol>
<li>Use <code>Subject</code> if you want to keep track of a state of a variable</li>
<li><code>.next()</code> is <code>Observer</code>'s method, not <code>Observable</code>.</li>
</ol>
","2829204","","2829204","","2019-09-10 08:59:23","2019-09-10 08:59:23","","","","2","","","","CC BY-SA 4.0"
"46683611","1","46802012","","2017-10-11 08:39:15","","0","1094","<p>here is what iam trying to achieve, i want to groupBy product_category in Array JSON but my array JSON is nested, which looks like this :</p>

<pre><code>[
    {
        ""result"": ""success"",
        ""data"": [
            {
                ""product_id"": 17,
                ""product_name"": ""KLO-101"",
                ""parent_category"": ""Juicer""
            },
            {
                ""product_id"": 42,
                ""product_name"": ""CRO-528"",
                ""parent_category"": ""Vacuum Cleaner""
            },
            {
                ""product_id"": 15,
                ""product_name"": ""KLC-127"",
                ""parent_category"": ""Juicer""
            },
            {
                ""product_id"": 41,
                ""product_name"": ""CRO-3120-WD"",
                ""parent_category"": ""Vacuum Cleaner""
            }
        ]
    }
]
</code></pre>

<p>what the json i want to build is, below is JSON illustration that i made write manually :</p>

<pre><code>[{
    'Vacuum Cleaner' : 
           [{
                ""product_id"": 41,
                ""product_name"": ""CRO-3120-WD"",
                ""parent_category"": ""Vacuum Cleaner""
            },
            {
                ""product_id"": 42,
                ""product_name"": ""CRO-528"",
                ""parent_category"": ""Vacuum Cleaner""
            }],
   'Juicer' : 
            [{
                ""product_id"": 17,
                ""product_name"": ""KLO-101"",
                ""parent_category"": ""Juicer""
                 },
            {
                ""product_id"": 15,
                ""product_name"": ""KLC-127"",
                ""parent_category"": ""Juicer""
            }]
}]
</code></pre>

<p>from what i read, in stackoverflow somewhere its written that JSON data can be grouped with using map().groupBy() which is in my code and it looks like this :</p>

<p>app.service.ts :</p>

<pre><code>getProductService(): Observable&lt;any&gt; {
    return this.http
        .post(global.server + ""/product"", this.options)
        .map(a=&gt; a.json().data)
        .groupBy(
            a=&gt;a.parent_category,
            a=&gt;a
        )
        .catch(this.handleError);
}
</code></pre>

<p>and here is my app.component.ts :</p>

<pre><code>  getProduct() {
    this.appService.getProductService().subscribe(
      result =&gt; {
        console.log(result);
        this.dataProduct = result[0].data;
      },
      error =&gt; this.errorMessage = &lt;any&gt;error
    );
  }
</code></pre>

<p>but i get an error, 'a is undefined' how to use <code>.groupBy()</code>   properly? angular version that i use is angular 4</p>

<p>UPDATE!!!</p>

<p>here is my code after i updated with martin answer, but still i can't figure it out, since i have to pull the JSON data from REST API, the code won't detect the 'parent_category', below is my code</p>

<p>app.component.ts</p>

<pre><code>dataProduct : any;

      getProduct() {
        this.appService.getProductService().subscribe(
          result =&gt; {
            this.dataProduct = result[0].data;
          },
          error =&gt; this.errorMessage = &lt;any&gt;error
        );

        Observable.of(this.dataProduct)
          .mergeMap(array =&gt; array) // unpack into single emissionns (or mergeAll() but it's broken in RxJS 5.4)
          .groupBy(item =&gt; item.parent_category)
          .mergeMap(observable =&gt; observable
            .toArray()
            .map(results =&gt; (this.dataProduct = { [results[0].parent_category]: results }))
          )
          .toArray()
          .subscribe(console.log);

          console.log(JSON.stringify(this.dataProduct));
      }
</code></pre>

<p>i got error </p>

<blockquote>
  <p>[ts] Property 'parent_category' does not exist on type '{}'</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/MpaGp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MpaGp.png"" alt=""enter image description here""></a></p>
","2666368","","2666368","","2017-10-12 07:44:32","2017-10-18 02:43:29","How to groupBy data properly when using HTTP response?","<json><angular><rxjs><observable><rxjs5>","3","0","","","","CC BY-SA 3.0"
"46708968","1","46751497","","2017-10-12 11:55:18","","0","605","<p>I have a situation with observable like this:</p>

<pre><code>//pseudo code
var agreement:Observable&lt;agreement[]&gt; = Observable.ajax({...})
    .flatMap(agreements:[] =&gt; {
        agreements.forEach(agreement =&gt;{
           //server request for each agreement
           //If request fail throw exception
        });
        return agreements;
    })
    .map(agreements =&gt; agreements);
</code></pre>

<p>Here, I need to check each agreement if it`s exist in other server and throw exception if not. Main question is how wait while all all agreements are checked adn only then get result.</p>
","5743476","","","","","2017-10-15 03:52:09","How to execute function for each observable in RXJS","<javascript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46716906","1","","","2017-10-12 18:51:32","","2","374","<p>I have multiple parent objects, each with multiple children, with each child with multiple links. I want to check all the children links, remove children that have no live links, and remove parents that have all their children removed.</p>

<p>I'm trying to do understand how to write the following code using Rx in angular 4:</p>

<pre><code>parents.reduce((updatedParents, parent) =&gt; {
 parent.children = parent.children.reduce((updatedChildern, child) =&gt; {
   child.links = child.links.reduce((updatedLinks, link) =&gt; {  
     if (link is live) updatedLinks.push(link) // asnyc operation
     return updatedLinks;
   },[]);
   if (child.links.length) updatedChildren.push(child);
 },[]);
 if (parent.children.length) updatedParents.push(parent); 
},[])
</code></pre>

<p>I can imagine how to do this using promises, and promise all / promise.reduce etc with bluebird, but How would I go about implementing this using Observable and reduce etc? I am really confused by that and I don't know how to do it. I tried a few ways and couldn't get it to work. I want a single event to return to me the filtered results, just like a promise.</p>

<p>Any suggestions would be welcome.</p>

<p>This is the structure:</p>

<pre><code>const parents = [
  {
    children: [
      {
        links: [
          'http://www.onelink.com', 'http://www.secondlink'
        ]
      },
      {
        links: [
          'http://www.threelink.com', 'http://www.fourlink'
        ]
      }
    ]
  },
  {
    children: [
      {
        links: [
          'http://www.fivelink.com', 'http://www.sixlink'
        ]
      },
      {
        links: [
          'http://www.sevenlink.com', 'http://www.egihtlink'
        ]
      }
    ]
  }
</code></pre>

<p>This is how far I go.</p>

<pre><code>return Observable.from(parents)
      .flatMap(parent =&gt; Observable.from(parent.children)
        .flatMap(child =&gt; Observable.from(child.images)
          .reduce((updatedImages, imgSrc, idx) =&gt; {
            return this.http.get(imgSrc)
              .map(res =&gt; {
                if (res.status === 200) {
                  updatesImages.push(base64Ecode(imgSrc));
                }
                console.log(res);
                console.log(updatedImages);
                return updatedImages;
              });
          })
        .filter(p =&gt; p.length !== 0)
      )
      .filter(c =&gt; c.length !== 0)
</code></pre>
","1059549","","1059549","","2017-10-13 17:47:06","2017-10-14 00:06:54","how to chain multiple observable reduce in angular 4 to generate base64 images","<angular><rxjs><observable><rxjs5>","2","4","1","","","CC BY-SA 3.0"
"46729057","1","46729154","","2017-10-13 11:37:43","","0","710","<p>I am trying to build an autocomplete and I am using Observable and Subject. But the service method is not being called whenever the value of the Subject object changes. Below is my component code where I have defined the Subject.</p>

<p>detailsPersist.component.ts</p>

<pre><code>import { Component, OnInit } from ""@angular/core"";
import { Subject } from 'rxjs/Subject';
import { DataService } from './data.service';

export class DetailsPersistComponent implements OnInit{
products;
term = new Subject();
constructor(private _dataService: DataService){

  }
ngOnInit(){
        this._dataService.getSwiftProducts(this.term)
          .subscribe(products =&gt; this.products = products)
  }

  search($event) {
        let q = $event.target.value
        console.log(q)
        this.term.next(q)
    }
}
</code></pre>

<p>Below is the code for my data service </p>

<p>data.service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http, Response, Headers, RequestOptions, URLSearchParams } from '@angular/http';
import 'rxjs/add/operator/map';
import {Observable} from 'rxjs';


@Injectable()
export class DataService{
 getSwiftProducts(term): Observable&lt;any&gt;{
    return this._http.get(""/api/getSwiftProduct/:""+term)
      .map(result =&gt; this.result = result.json().data)
  }
}
</code></pre>
","4681491","","310726","","2017-10-13 15:47:37","2017-10-13 15:47:37","Observable not being called on value change in Subject.next()","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"46729154","2","","46729057","2017-10-13 11:42:37","","2","","<p>You probably want to do something like this:</p>

<pre><code>ngOnInit() {
  this.subscription = this.term
    .switchMap(term =&gt; this._dataService.getSwiftProducts(term))
    .subscribe(products =&gt; this.products = products)
}

ngOnDestroy() {
  this.subscription.unsubscribe();
}
</code></pre>
","310726","","","","","2017-10-13 11:42:37","","","","1","","","","CC BY-SA 3.0"
"46749709","2","","38386832","2017-10-14 21:55:07","","1","","<p>The latest RXJS distributions offer broken up modules to mitigate the gigantic filesize, Ã  la Lodash. Importing <code>rxjs/Rx</code> (as another answer suggests) will get you the entirety of the library and isn't suggested.</p>

<p>Instead, import methods and operators individually:</p>

<ul>
<li>for core classes, import the class from its scoped module: <code>import { Observable } from 'rxjs/Observable'</code></li>
<li>for instance methods, use the instance scope in the ""add"" scope: <code>import 'rxjs/add/observable/fromEvent'</code> (note there is no destructured object to import â the method is added automatically by the import)</li>
<li>for operators, import from the <code>add/operator</code> scope: <code>import 'rxjs/add/operator/switchMap'</code></li>
</ul>

<p>Importing an operator once makes it available to all instances, so it's recommended to gather all the parts you use in a single file and import that file wherever needed, I.E. by re-exporting the instances you use.</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/flatMap';
import 'rxjs/add/operator/switchMap';

export { Observable, BehaviorSubject };
</code></pre>
","6100103","","","","","2017-10-14 21:55:07","","","","0","","","","CC BY-SA 3.0"
"46751497","2","","46708968","2017-10-15 03:52:09","","0","","<p>The answer to this depends on what's happening inside the <code>forEach</code> loop â if <code>agreements</code> (the one going into the <code>flatMap</code>) is an Observable that you're using <code>forEach</code> to emit, the strategy is a bit different altogether because you don't necessarily know how many <code>agreement</code> objects will be emitted.</p>

<p>Assuming though the <code>forEach</code> is just running some other basic http calling, say, one that returns promises... The answer is then going to involve collecting the promises and allowing them all to complete the <em>Promise-way</em>, so that the completion can then be converted into an Observable for the next operator in the chain.</p>

<p>Some pseudo code:</p>

<pre><code>var agreement: Observable&lt;agreement[]&gt; = Observable.ajax({...})
    .flatMap(agreements:[] =&gt; {
        const promises = agreements.map(agreement =&gt; doHttpThing()
            .then(...)
            .catch(err =&gt; Observable.throw(err))
        );
        return Observable.fromPromise(Promise.all(promises));
    })
    .map(agreements =&gt; agreements);
</code></pre>
","6100103","","","","","2017-10-15 03:52:09","","","","0","","","","CC BY-SA 3.0"
"46759743","1","46767691","","2017-10-15 20:37:06","","1","686","<p>I want to buffer events sent to my server. The trigger to flush the buffer is either the buffer size has been reached, buffer period has been reached or the window has been unloaded.</p>

<p>I buffer events sent to my server by creating a Subject and using <code>buffer</code> with a closing notifier. I use <code>race</code> for the closing notifier and race the buffer period with with <code>window.beforeunload</code> event.</p>

<pre><code>this.event$ = new Subject();
this.bufferedEvent$ = this.event$
    .buffer(
        Observable.race(
            Observable.interval(bufferPeriodMs),
            Observable.fromEvent(window, 'beforeunload')
        )
    )
    .filter(events =&gt; events.length &gt; 0)
    .switchMap(events =&gt;
        ajax.post(
            this.baseUrl + RESOURCE_URL,
            {
                entries: events,
            },
            {
                'Content-Type': 'application/json',
            }
       )
    );
</code></pre>

<p>The question is, how do I now also limit the size of the buffer. ie, I never want the buffer to be flushed when it has 10 items.</p>
","1226744","","1226744","","2017-10-15 20:53:19","2017-10-26 22:38:54","Reactive Extensions Buffer on count, interval and event","<javascript><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"46760480","1","46829404","","2017-10-15 22:04:40","","1","93","<p>I have a stream like this</p>

<pre><code>---ab---ab---a---ba---bab---ab---ab---ab---&gt;
</code></pre>

<p>And I want this.</p>

<pre><code>---ab---ab------ab----ab-ab-ab---ab---ab---&gt;
</code></pre>

<p>The point is, that I have data with beginning and end (JSON) and sometimes the data is cut in the half in the stream, and I want to join them again. How can I do that?</p>
","598280","","","","","2017-10-19 12:02:43","How to join two half in RxJs","<javascript><rxjs><rxjs5>","3","1","1","","","CC BY-SA 3.0"
"46760805","1","","","2017-10-15 22:52:55","","0","1912","<p>I want to buffer the stream, until the stream is true of a predicate:</p>

<p>For example, the number can be divided by five:</p>

<pre><code>//emit value every 1 second
const oneSecondInterval = Rx.Observable.interval(1000);
//return an observable that checks if the number is divided by zero
const fiveSecondInterval = () =&gt; oneSecondInterval.filter(number =&gt; number % 5 === 0);

const bufferWhenExample = oneSecondInterval.bufferWhen(fiveSecondInterval);
//log values
const subscribe = bufferWhenExample.subscribe(val =&gt; console.log('Emitted Buffer: ', val));
</code></pre>

<p><strong>Output</strong></p>

<pre><code>""Emitted Buffer: ""
[]
""Emitted Buffer: ""
[0, 1]
""Emitted Buffer: ""
[2]
""Emitted Buffer: ""
[3]
""Emitted Buffer: ""
[4]
""Emitted Buffer: ""
[5]
""Emitted Buffer: ""
[6]
""Emitted Buffer: ""
[7]
""Emitted Buffer: ""
[8]
""Emitted Buffer: ""
[9]
""Emitted Buffer: ""
[10]
</code></pre>

<p><strong>What I want:</strong></p>

<pre><code>""Emitted Buffer: ""
[0]
""Emitted Buffer: ""
[1,2,3,4,5]
""Emitted Buffer: ""
[6,7,8,9,10]
</code></pre>

<p>But this is not working. Why?</p>

<p>DEMO: <a href=""http://jsbin.com/durerimiju/1/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/durerimiju/1/edit?js,console</a></p>

<hr>

<h2>Update</h2>

<p>This is almost good</p>

<pre><code>const oneSecondInterval = Rx.Observable.interval(1000);
const fiveSecondInterval = oneSecondInterval.filter(time =&gt; time % 5 === 0);
const bufferWhenExample = oneSecondInterval.buffer(fiveSecondInterval);

bufferWhenExample.subscribe(console.log)
</code></pre>

<p>The only problem is that it emits</p>

<pre><code>[]
[0,1,2,3,4]
[5,6,7,8,9]
</code></pre>

<p>Instead I would like to have</p>

<pre><code>[0]
[1,2,3,4,5]
[6,7,8,9,10]
</code></pre>
","598280","","598280","","2017-10-17 22:05:30","2020-03-04 02:34:05","RxJS Buffer until stream is true","<javascript><rxjs><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"46766792","1","46766926","","2017-10-16 09:16:23","","0","800","<p>How can I delay an http request only if it completes under 1second.</p>

<p>first scenario:
- http request completes in 300ms, then we wait until 1 second ends.</p>

<p>second scenario:
- http request completes in 1 second and 300ms, then we DO NOT delay.</p>

<p>how to accomplish this with observables ?</p>
","1543885","","","","","2017-10-16 09:23:47","Angular delay fast http requests","<angular><rxjs><rxjs5>","1","3","2","","","CC BY-SA 3.0"
"46766926","2","","46766792","2017-10-16 09:23:47","","6","","<p>You can use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin"" rel=""noreferrer""><code>forkJoin</code></a> to wait until both Observables complete:</p>

<pre><code>Observable.forkJoin(
  this.http.get(...),
  Observable.of(null).delay(1000),
  r =&gt; r // Use only the HTTP response
))
.subscribe();
</code></pre>
","310726","","","","","2017-10-16 09:23:47","","","","1","","","","CC BY-SA 3.0"
"46767691","2","","46759743","2017-10-16 10:03:59","","1","","<p>This is the working solution I have. Extra console.log()'s are added to show the sequence of events.  </p>

<p>The only thing that's a bit bothersome is the <code>.skip(1)</code> in fullBufferTrigger, but it's needed as it will trigger when it's buffer is full (natch), but the buffer in <code>bufferedEvent$</code> does not seem to have the latest event before it's triggered.  </p>

<p>Luckily, with the <code>timeoutTrigger</code> in place, the last event gets emitted. Without timeout, fullBufferTrigger by itself will not emit the final event.</p>

<p>Also, changed <code>buffer</code> to <code>bufferWhen</code>, as the former did not seem to trigger with two triggers, <s>although you'd expect it to from the documentation.</s><br>
<strong>footnote</strong> with <code>buffer(race())</code> the race only completes once, so whichever trigger got there first will thereafter be used and the other triggers dis-regarded. In contrast, <code>bufferWhen(x =&gt; race())</code> evaluates every time an event occurs.</p>

<pre><code>const bufferPeriodMs = 1000

const event$ = new Subject()
event$.subscribe(event =&gt; console.log('event$ emit', event))

// Define triggers here for testing individually
const beforeunloadTrigger = Observable.fromEvent(window, 'beforeunload')
const fullBufferTrigger = event$.skip(1).bufferCount(2)
const timeoutTrigger = Observable.interval(bufferPeriodMs).take(10)

const bufferedEvent$ = event$
  .bufferWhen( x =&gt; 
    Observable.race(
      fullBufferTrigger,
      timeoutTrigger
    )
  )
  .filter(events =&gt; events.length &gt; 0)

// output
fullBufferTrigger.subscribe(x =&gt; console.log('fullBufferTrigger', x))
timeoutTrigger.subscribe(x =&gt; console.log('timeoutTrigger', x))
bufferedEvent$.subscribe(events =&gt; {
  console.log('subscription', events)
})

// Test sequence
const delayBy = n =&gt; (bufferPeriodMs * n) + 500 
event$.next('event1')
event$.next('event2')
event$.next('event3')

setTimeout( () =&gt; {
  event$.next('event4')
}, delayBy(1))

setTimeout( () =&gt; {
  event$.next('event5')
}, delayBy(2))

setTimeout( () =&gt; {
  event$.next('event6')
  event$.next('event7')
}, delayBy(3))
</code></pre>

<p>Working example: <a href=""https://codepen.io/RMatsen/pen/veQJvL"" rel=""nofollow noreferrer"">CodePen</a>  </p>

<h2><strong>Edit: Alternative way to trigger the buffer</strong></h2>

<p>Since the combination of <code>bufferWhen</code> and <code>race</code> might be a bit inefficient (the race is restarted each event emission), an alternative is to merge the triggers into one stream and use a simple <code>buffer</code></p>

<pre><code>const bufferTrigger$ = timeoutTrigger
  .merge(fullBufferTrigger)
  .merge(beforeunloadTrigger)

const bufferedEvent$ = event$
  .buffer(bufferTrigger$)
  .filter(events =&gt; events.length &gt; 0)
</code></pre>
","4716245","","4716245","","2017-10-25 23:58:17","2017-10-25 23:58:17","","","","9","","","","CC BY-SA 3.0"
"46767880","1","46769019","","2017-10-16 10:15:04","","2","4969","<p>I'm new to Angular and the tutorial I followed has the term ""<code>Observable</code>"". The tutor explained it, but I didn't completely understand.</p>

<p>What is an <code>Observable</code>, and why do we always have to call  <code>observable.subscribe()</code>?</p>

<p>What does <code>subscribe()</code> actually do?</p>
","5775871","","366904","","2017-10-17 09:07:50","2018-10-18 13:51:04","What does subscribe do, and how it is related to Observable?","<angular><rxjs><observable><rxjs5>","2","3","3","","","CC BY-SA 3.0"
"46769019","2","","46767880","2017-10-16 11:14:55","","14","","<h2>What is an <code>Observable</code>?</h2>
<p>An Observable can be seen as a data source. That data might exist (or not) and might change over time (or not).</p>
<p>An Observable emits data, until it has nothing to emit anymore and then completes (there are some Observable that will never complete) or throws an exception (error handling is a big part of <code>Observable</code> combination).</p>
<p>You can combine these data-sources or alter the emitted data using operators like <code>map</code>, <code>merge</code>, <code>switchMap</code>, etc. So, a data-source can be an alteration of another data-source or the combination of many others.</p>
<p>As I said, an <code>Observable</code> is a source, If you want to use the data from that source, you need to <code>subscribe()</code> to the <code>Observable</code> and then you get notified of any data emitted.</p>
<h2>Hot vs. Cold <code>Observable</code></h2>
<p>There are two kind of Observables: cold and hot ones.</p>
<ul>
<li><strong>Cold Observables</strong>: Those are Observables that do not emit data until you subscribe to them, basically, data does not exists until you ask for it (e.g. Ajax requests).</li>
<li><strong>Hot Observables</strong> : These ones start emitting without caring if there is or not a subscriber waiting for data.</li>
</ul>
<p>Most of the time, you have to deal with cold Observables (AJAX requests), <strong>that's why you need to subscribe to them</strong>, without this subscription you only define a data source, and then never trigger the request.</p>
<p>So let's think about <code>Observable</code> with a video metaphor:</p>
<ul>
<li>A cold <code>Observable</code> is like a VOD service : Videos are broadcasted when you ask for it (<code>subscribe()</code>).</li>
<li>A hot <code>Observable</code> is like regular TV : Video are broadcasted without any regard to the fact that anyone asks for it or not.</li>
</ul>
<h2><code>ConnectableObservable</code>: warming cold <code>Observable</code>s</h2>
<p>What? <code>ConnectableObservable</code>? You said there was only two kind of Observable. You're a liar!</p>
<p>Not really; <code>ConnectableObservable</code>s are <code>Observable</code>s that emit data as soon as you call their <code>connect()</code> method. In other words, this Observable becomes hot as soon as you call the <code>connect()</code> method.</p>
<p>You can turn a cold <code>Observable</code> into a <code>ConnectableObservable</code> using some operators (like <code>publish()</code>).</p>
","3633742","","-1","","2020-06-20 09:12:55","2018-10-18 13:51:04","","","","3","","","","CC BY-SA 4.0"
"46787734","1","","","2017-10-17 10:14:26","","1","397","<p>I am trying to run a simple typescript project using webpack 3 and rxjs5 but I am getting an error.</p>

<p>app.ts :</p>

<pre><code> import { Observable } from 'rxjs/Observable';

    import 'rxjs/add/observable/of';

        const myObservable: any = Observable.of(1, 2, 3)
            .subscribe(
                (value: any) =&gt; console.log(value),
                (err: any) =&gt; console.log(err),
                () =&gt; console.log(""Streaming is over"")
        );
</code></pre>

<p>index.html :</p>

<pre><code>   &lt;html lang=""en""&gt;
    &lt;head&gt;
        &lt;meta charset=""UTF-8""&gt;
        &lt;meta name=""viewport""
              content=""width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0""&gt;
        &lt;meta http-equiv=""X-UA-Compatible"" content=""ie=edge""&gt;
        &lt;title&gt;Webpack 3 with Typescript&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

    &lt;h1&gt;Let's learn Webpack 3&lt;/h1&gt;

    &lt;script src=""dist/bundle.js""&gt;&lt;/script&gt;

    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>

<p>package.json :</p>

<pre><code>{
  ""name"": ""ObservablesProject2"",
  ""version"": ""1.0.0"",
  ""description"": """",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1"",
    ""build"": ""webpack-dev-server"",
    ""build:prod"": ""webpack -p""
  },
  ""keywords"": [],
  ""author"": """",
  ""license"": ""ISC"",
  ""devDependencies"": {
    ""ts-loader"": ""^3.0.2"",
    ""tslint"": ""^5.7.0"",
    ""tslint-loader"": ""^3.5.3"",
    ""typescript"": ""^2.5.3"",
    ""webpack"": ""^3.7.1"",
    ""webpack-dev-server"": ""^2.9.2""
  },
  ""dependencies"": {
    ""rxjs"": ""^5.4.3""
  }
}
</code></pre>

<p>tsconfig.json :</p>

<pre><code>{
  ""compilerOptions"": {
    /* Basic Options */
    ""target"": ""es5"",                          /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. */
    ""module"": ""commonjs"",                     /* Specify module code generation: 'none', commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */
    ""lib"": [""es6"", ""dom""],                             /* Specify library files to be included in the compilation:  */
    ""allowJs"": true,                       /* Allow javascript files to be compiled. */
    // ""checkJs"": true,                       /* Report errors in .js files. */
    // ""jsx"": ""preserve"",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    // ""declaration"": true,                   /* Generates corresponding '.d.ts' file. */
    ""sourceMap"": true,                     /* Generates corresponding '.map' file. */
    // ""outFile"": ""./"",                       /* Concatenate and emit output to single file. */
    // ""outDir"": ""./"",                        /* Redirect output structure to the directory. */
    // ""rootDir"": ""./"",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // ""removeComments"": true,                /* Do not emit comments to output. */
    // ""noEmit"": true,                        /* Do not emit outputs. */
    // ""importHelpers"": true,                 /* Import emit helpers from 'tslib'. */
    // ""downlevelIteration"": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // ""isolatedModules"": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options */
    ""strict"": true,                            /* Enable all strict type-checking options. */
    ""noImplicitAny"": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    ""strictNullChecks"": true             /* Enable strict null checks. */
    // ""noImplicitThis"": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // ""alwaysStrict"": true,                  /* Parse in strict mode and emit ""use strict"" for each source file. */

    /* Additional Checks */
    // ""noUnusedLocals"": true,                /* Report errors on unused locals. */
    // ""noUnusedParameters"": true,            /* Report errors on unused parameters. */
    // ""noImplicitReturns"": true,             /* Report error when not all code paths in function return a value. */
    // ""noFallthroughCasesInSwitch"": true,    /* Report errors for fallthrough cases in switch statement. */

    /* Module Resolution Options */
    // ""moduleResolution"": ""node"",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // ""baseUrl"": ""./"",                       /* Base directory to resolve non-absolute module names. */
    // ""paths"": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // ""rootDirs"": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // ""typeRoots"": [],                       /* List of folders to include type definitions from. */
    // ""types"": [],                           /* Type declaration files to be included in compilation. */
    // ""allowSyntheticDefaultImports"": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    // ""preserveSymlinks"": true,              /* Do not resolve the real path of symlinks. */

    /* Source Map Options */
    // ""sourceRoot"": ""./"",                    /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // ""mapRoot"": ""./"",                       /* Specify the location where debugger should locate map files instead of generated locations. */
    // ""inlineSourceMap"": true,               /* Emit a single file with source maps instead of having a separate file. */
    // ""inlineSources"": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
    // ""experimentalDecorators"": true,        /* Enables experimental support for ES7 decorators. */
    // ""emitDecoratorMetadata"": true,         /* Enables experimental support for emitting type metadata for decorators. */
  },
  ""exclude"": [
    ""node_modules""
  ]
}
</code></pre>

<p>webpack.config.js :</p>

<pre><code>var path = require('path');
var webpack = require('webpack');

module.exports = {

    entry: './src/js/app.ts',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
        publicPath: '/dist'
    },
    module: {
        rules: [
            {
                enforce: 'pre',
                test: /\.tsx?$/,
                loader: 'tslint-loader',
                exclude: /node_modules/,
                options: {
                    failOnHint: true,
                    configuration: require('./tslint.json')
                }
            },

            {
                test: /\.tsx?$/,
                use: 'ts-loader',
                exclude: /node_modules/
            }
        ]
    },
    resolve: {
        extensions: ["".tsx"", "".ts"", "".js""]
    },
    plugins: [
        new webpack.optimize.UglifyJsPlugin({
            // ...
        })
    ]

};
</code></pre>

<p>The error I am getting when I try to compile the above code is the following:</p>

<pre><code>ERROR in ./src/js/app.ts
[tsl] ERROR in /Users/administrator/WebstormProjects/ObservablesProject2/src/js/app.ts(1,28)
      TS7016: Could not find a declaration file for module 'rxjs/Observable'. '/Users/administrator/WebstormProjects/ObservablesProject2/node_modules/rxjs/Observable.js' implicitly has an 'any' type.
  Try `npm install @types/rxjs/Observable` if it exists or add a new declaration (.d.ts) file containing `declare module 'rxjs/Observable';`
</code></pre>
","881739","","","","","2017-10-17 12:28:32","How to properly use RxJS 5 in a typescript project using webpack 3?","<javascript><typescript><rxjs><webstorm><rxjs5>","1","7","","","","CC BY-SA 3.0"
"46800504","1","","","2017-10-17 23:06:30","","1","324","<p>I want to implement a kind of multiple producers multiple consumers queue with RxJs. Basically I have some producers of jobs and some consumers (workers). I want to take one job and send it to the next available worker in a round robin fashion. Until now I got this</p>

<pre><code>let src = Rx.Observable.from(this.producers).mergeMap(
  (producer) =&gt; Rx.Observable.fromPromise(producer.getJobs).mergeMap((jobs) =&gt; Rx.Observable.from(jobs))
);


let tgt = Rx.Observable.from(this.workers).repeatWhen(complete =&gt; complete.delay(2000));
</code></pre>

<p>I want to connect both. I think with something like takeuntil. Workers executeJobs by calling worker.executeJob(job).</p>
","2112047","","","","","2017-10-17 23:06:30","Round robin of producers/consumers with RxJs","<rxjs><rxjs5>","0","2","1","","","CC BY-SA 3.0"
"46802012","2","","46683611","2017-10-18 02:43:29","","0","","<p>i think i have to implement lodash since i really confuse about observeable way, i really can't understand it, so i decided to use lodash way, it's so simple, so here is my code how to group the JSON data properly. i have to import lodash which is already include in my project, if you dont have lodash in your node_modules, you have to npm install it</p>

<pre><code>import * as _ from 'lodash';

  getProduct() {
    this.appService.getProductService().subscribe(
      result =&gt; {
        this.dataTest = result;

        let datas = this.dataTest;

        this.dataProduct = _(datas)
        .groupBy(data =&gt; data.parent_category)
        .map((datas, category) =&gt; ({ category, datas }))
        .value();

      },
      error =&gt; this.errorMessage = &lt;any&gt;error
    );
</code></pre>

<p>and i just need to loop the JSON data inside ""datas"" with *ngFor in HTML</p>
","2666368","","","","","2017-10-18 02:43:29","","","","1","","","","CC BY-SA 3.0"
"46808166","1","46809090","","2017-10-18 10:34:13","","0","581","<p>I have an xhr request that is getting an array with which I execute subsequent xhr requests like so:</p>

<pre><code>const Rx = require('rxjs/Rx');
const fetch = require('node-fetch');

const url = `url`;

// Get array of tables
const tables$ = Rx.Observable
  .from(fetch(url).then((r) =&gt; r.json()));

// Get array of columns
const columns$ = (table) =&gt; {
  return Rx.Observable
    .from(fetch(`${url}/${table.TableName}/columns`).then(r =&gt; r.json()));
};

tables$
  .mergeMap(tables =&gt; Rx.Observable.forkJoin(...tables.map(columns$)))    
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p>I would like to execute the column requests in chuncks so that the requests are not being sent to the server at once.</p>

<p>This SO question is somewhat in the same direction but not completely: <a href=""https://stackoverflow.com/questions/41403500/rxjs-chunk-and-delay-stream"">Rxjs: Chunk and delay stream?</a></p>

<p>Now I'm trying something like this:</p>

<pre><code>tables$
  .mergeMap(tables =&gt; Rx.Observable.forkJoin(...tables.map(columns$)))
  .flatMap(e =&gt; e)
  .bufferCount(4)
  .executeTheChunksSerial(magic)
  .flatMap(e =&gt; e)
  .subscribe(val =&gt; console.log(val));
</code></pre>

<p>But I cannot wrap my head around how to execute the chunks in series...</p>
","2077128","","","","","2017-10-18 11:26:56","How to buffer observables in pairs and execute them by the pair?","<rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"46809090","2","","46808166","2017-10-18 11:26:56","","3","","<p>You can utilize the <code>concurrency</code> argument of <code>mergeMap</code> to get max <em>x</em> requests concurrently to your server:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const getTables = Promise.resolve([{ tableName: 'foo' },{ tableName: 'bar' },{ tableName: 'baz' }]);
const getColumns = (table) =&gt; Rx.Observable.of('a,b,c')
  .do(_ =&gt; console.log('getting columns for table: ' + table))
  .delay(250);
      
Rx.Observable.from(getTables)
  .mergeAll()
  .mergeMap(
    table =&gt; getColumns(table.tableName),
    (table, columns) =&gt; ({ table, columns }),
    2)
  .subscribe(console.log)</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.3/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","106909","","","","","2017-10-18 11:26:56","","","","0","","","","CC BY-SA 3.0"
"46813486","1","46815668","","2017-10-18 15:08:36","","1","227","<p>I have an observable named ""workcentersFiltered"" of type <code>Observable&lt;Workcenter[]&gt;</code></p>

<p>When I select a plant, I can successfully filter down my workcenters with the following code - no problem:</p>



<pre class=""lang-js prettyprint-override""><code>this.workcentersFiltered = this.newLineForm.get('plant').valueChanges
      .flatMap(selectedPlant =&gt; {
        return this.dataStore.Workcenters.map(workcenters =&gt; {
          return workcenters.filter(x =&gt; x.PlantNumber === selectedPlant.PlantNumber);
        });
      });
</code></pre>

<p>The problem is, I would like to narrow that array down furtherly, when an entirely different, independent observable ""<code>'workcenter'.valuechanges</code>"" emits a string (it is an input field - I am trying to implement autocompletion).</p>

<p>So the question is, how can I subscribe to <code>this.newLineForm.get('workcenter').valueChanges</code>, so that the string-values it emits can be used to furtherly narrow down the data ""hidden"" within <code>workcentersFiltered</code> (which is already tied to <code>this.newLineForm.get('plant').valueChanges</code>.</p>

<p>Does my dilemma make sense? Must I instead redo <code>workcenteresFiltered</code> as aBehaviorSubject instead, or what is the proper solution here?</p>

<p><strong><em>editing in more explanation</em></strong></p>

<p>Currently workcentersFiltered gets data from dataStore.Workcenters, when  <code>plant-forminput.valuechanges</code> emits a change, because a plant was selected. So I can narrow down all workcenters to only ones matching the chosen plant. It works fine with the code I have above.</p>

<p>However I would like to introduce a new operation on the sequence between plant-forminput.valuechanges and workcentersFiltered. I would like to narrow the options even further, based on the emission from workcenter-forminput.valuechanges.</p>

<p>So Step 1 on my UI, the user can select a plant from a dropdown and all workcenters from other plants are filtered out - this works.</p>

<p>Then, Step 2 is for the user to chose a specific workcenter. This is a text-input field. I want every letter typed here (which emits on workcenter-forminput.valuechanges), to further narrow down the options (for autocompletion).</p>

<p>I have a difficult time imagining the solution, because the newly introduced observable from step 2 (workcenter-forminput.valuechanges), is only relevant when it emits.</p>
","865744","","674326","","2017-10-18 17:16:39","2017-10-18 17:16:39","RxJs: Have observable triggered by 2 independent observables","<javascript><angular><rxjs><reactive-programming><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"46815668","2","","46813486","2017-10-18 17:11:45","","3","","<p>You can use <a href=""https://www.learnrxjs.io/operators/combination/combinelatest.html"" rel=""nofollow noreferrer"">combineLatest</a> for this.</p>

<p>I couldn't follow your full description, so I'll just present an approximate example, which you can hopefully adapt to your specific use case:</p>

<pre><code>workcentersForPlant = this.newLineForm.get('plant').valueChanges
      .flatMap(selectedPlant =&gt; {
        return this.dataStore.Workcenters.map(workcenters =&gt; {
          return workcenters.filter(x =&gt; x.PlantNumber === selectedPlant.PlantNumber);
        });
      });

const workCenterNameChanges = this.newLineForm.get('workCenterName').valueChanges;

// combine the 2 observables, this will trigger when either observable
// changes.  Use the combined values to do the filtering by name
this.workcentersFiltered = Observable
  .combineLatest(workcentersForPlant, workCenterNameChanges$)
  .map(([workCenters, workCenterName]) =&gt; workCenters.filter(w =&gt; w.name.startsWith(workCenterName)));
</code></pre>
","674326","","","","","2017-10-18 17:11:45","","","","1","","","","CC BY-SA 3.0"
"46828884","1","46834401","","2017-10-19 11:30:32","","2","216","<p>I have a data stream, with rapidly incoming data. I want to insert them into a database by keeping order. I have a database, which returns a promise, which is resolved when an insert is successful.</p>

<p>I would like to make an Rx stream, which buffers the new data, until the buffered data is inserted. </p>

<p>How can I do that?</p>
","598280","","598280","","2017-10-19 11:37:58","2017-10-19 16:13:03","RxJs buffer until database insert (promise)","<promise><rxjs><buffer><rxjs5>","1","4","1","","","CC BY-SA 3.0"
"46829404","2","","46760480","2017-10-19 12:02:43","","0","","<p>This is how I solved:</p>

<pre><code>import Rx from 'rxjs/Rx';
import {last} from 'lodash';

const data$ = Rx.Observable.of('ab','ab','a','ba','bab','aba','b','ab');
const line$ = data$.flatMap(data =&gt; {
    const lines = data.match(/[^b]+b?|b/g); // https://stackoverflow.com/a/36465144/598280 https://stackoverflow.com/a/25221523/598280
    return Rx.Observable.from(lines);
});

const isComplete$ = line$.scan((acc, value) =&gt; {
    const isLineEndingLast = last(acc.value) === 'b';
    const id = isLineEndingLast ? acc.id + 1 : acc.id;
    const complete = last(value) === 'b';
    return {value, id, complete};
}, {value: 'b', id: 0, complete: true});

const grouped$ = isComplete$
    .groupBy(data =&gt; data.id, data =&gt; data, group =&gt; group.first(data =&gt; data.complete))
    .flatMap(group =&gt; group.reduce((acc, data) =&gt; acc + data.value, ''));

grouped$.subscribe(console.log);
</code></pre>
","598280","","","","","2017-10-19 12:02:43","","","","0","","","","CC BY-SA 3.0"
"46834401","2","","46828884","2017-10-19 16:13:03","","2","","<p>I believe to get exactly what you desire you would need to create your own operator.  Breaking from RxJS slightly you can get something like (warning, have not tested)...</p>

<pre><code>export class BusyBuffer&lt;T&gt; {
  private itemQueue = new Subject&lt;T&gt;();
  private bufferTrigger = new Subject&lt;{}&gt;();
  private busy = false;

  constructor(consumerCallback: (items: T[]) =&gt; Promise&lt;void&gt;) {
    this.itemQueue.buffer(this.bufferTrigger).subscribe(items =&gt; {
      this.busy = true;
      consumerCallback(items).then(() =&gt; {
        this.busy = false;
        this.bufferTrigger.next(null);
      });
    });
  }

  submitItem(item: T) {
    this.itemQueue.next(item);
    if(!busy) {
      this.bufferTrigger.next(null);
    }
  }

}
</code></pre>

<p>Which can then be used as</p>

<pre><code>let busyBuffer = new BusyBuffer&lt;T&gt;(items =&gt; {
  return database.insertRecords(items);
});
items.subscribe(item =&gt; busyBuffer.submitItem(item));
</code></pre>

<p>It isn't exactly purely reactive though and someone may be able to come up with something better.</p>
","202694","","","","","2017-10-19 16:13:03","","","","3","","","","CC BY-SA 3.0"
"46838745","1","46851525","","2017-10-19 20:54:48","","2","985","<p>I have two observables:</p>

<pre><code>-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-|
-13--14--15--16--17--18--19-----20---------21--------------22------23--24--&gt;
</code></pre>

<p>The first contains some increasing number, but stops after a while (these are the cursor result from the database)
The second are continuously emitting increasing number. Contains some number from the first, but don't stop emitting. (These are the newly inserted data to the database)</p>

<p>I want this two observable to look one continuous observable like this:</p>

<pre><code>-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-----22------23--24--&gt;
</code></pre>

<p>This observable contains every number only once, keeping the emission order.</p>

<p>How can it be solved with using as less memory as possible?</p>
","598280","","","","","2017-10-20 14:39:40","RxJs how to merge two overlapping observable into one","<merge><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"46850852","1","46852187","","2017-10-20 14:05:02","","3","747","<p>ok, so now I'm really puzzled. Executing the following code</p>

<pre><code>const created = Rx.Observable.create(observer =&gt; {
  observer.next(42)
})
const ofd = Rx.Observable.of(42)

const createSub = name =&gt; [
  val =&gt; console.log(`${name} received ${val}`),
  error =&gt; console.log(`${name} threw ${error.constructor.name}`)
]

created
  .timeout(100)
  .subscribe(
    ...createSub('created')
  )

ofd
  .timeout(100)
  .subscribe(
    ...createSub('ofd')
  )
</code></pre>

<p>Prints</p>

<pre><code>""created received 42""
""ofd received 42""
""created threw TimeoutError""
</code></pre>

<p>I don't understand this at all, why does the <code>created</code> Observable error even though it emits a value but the <code>ofd</code> Observable does not??</p>

<p>Using RxJS 5, problem occurs with 5.0.3 in jsbin.com and 5.4.3 in my app.</p>

<p>(Note: This happens with subjects too, which led me to create this example)</p>
","7058748","","","","","2017-10-20 15:15:46","rxjs created observable timeout always errors","<timeout><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"46851525","2","","46838745","2017-10-20 14:39:40","","3","","<p>I think the best approach here is to buffer b$ until a$ stream reaches b$, then emit all the buffered items of b$ and switch to b$. Something like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const a = '-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15';
const b = '-13--14--15--16--17--18--19-----20---------21--------------22------23--24';

const fromMarble = str =&gt; Rx.Observable.from(str.split('-')).concatMap(x =&gt; Rx.Observable.of(x).delay(1)).filter(v =&gt; v.length).map(x =&gt; parseInt(x));

const a$ = fromMarble(a).share();
const b$ = fromMarble(b).share();

const switchingSignal$ = Rx.Observable.combineLatest(a$, b$.take(1), (a, b) =&gt; a &gt;= b).filter(x =&gt; x).take(1).share();

const distinct$ = Rx.Observable.merge(
	a$.takeUntil(switchingSignal$).map(x =&gt; x + '(from a)'), 
	b$.buffer(switchingSignal$).take(1).mergeMap(buffered =&gt; Rx.Observable.from(buffered)).map(x =&gt; x + '(from b$ buffer)'),
	b$.skipUntil(switchingSignal$).map(x =&gt; x + '(from b$)')
);

distinct$.subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.0/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3306656","","","","","2017-10-20 14:39:40","","","","0","","","","CC BY-SA 3.0"
"46852187","2","","46850852","2017-10-20 15:15:46","","4","","<p><code>Observable.of</code> is completing the stream right after the value has been emitted. </p>

<p><code>Observable.create</code> keeps the observable opened. And that's why the <code>timeout</code> is throwing an error.</p>

<p>Replace </p>

<pre><code>const created = Rx.Observable.create(observer =&gt; {
  observer.next(42)
})
</code></pre>

<p>By</p>

<pre><code>const created = Rx.Observable.create(observer =&gt; {
  observer.next(42);
  observer.complete();
})
</code></pre>

<p>and there's no error anymore.</p>
","2398593","","","","","2017-10-20 15:15:46","","","","6","","","","CC BY-SA 3.0"
"46866202","1","46873566","","2017-10-21 17:46:02","","11","30379","<p>I'm trying to setup a simple way to compare the current username with a profile's username within an Angular service.</p>

<p>Obviously the profile username and the user's username must resolve before I can compare them so how do I return a boolean observable so that I can subscribe to this comparison within components?</p>

<p>This is where I'm at:</p>

<pre><code>public profileId = new Subject&lt;string&gt;; // Observable string source updated from a profile.component (when the URL displays the profile's username)
public profileId$ = this.profileId.asObservable();
public currentUser = this.principal.asObservable().distinctUntilChanged();

public isProfileOwner(): Observable&lt;boolean&gt; { // A function whose declared type is neither 'void' nor 'any' must return a value.
    this.currentUser.subscribe(user =&gt; {
            this.profileId$.subscribe(
                profile =&gt; {
                    console.log(profile + ' ' + user.username); // match!
                    if (profile === user.username) {
                        return Observable.of(true);
                    } else {
                        return Observable.of(false);
                    }
                }
            )
        })
}
</code></pre>

<p>This seems to be the way other SO answers explain to do it but I'm getting <code>[ts] A function whose declared type is neither 'void' nor 'any' must return a value.</code></p>

<p>I'd like to subscribe to test within components.</p>

<pre><code>this.authService.isProfileOwner().subscribe(
    data =&gt; {
        console.log(data); // should be boolean
    }
)
</code></pre>
","1440240","","1440240","","2017-10-23 00:34:29","2017-10-23 00:34:29","Return Observable<boolean> from service method after two subscriptions resolve","<angular><typescript><rxjs><rxjs5>","3","0","3","","","CC BY-SA 3.0"
"46873566","2","","46866202","2017-10-22 11:33:11","","8","","<p>As noticed from other answer by @user184994, <code>forkJoin</code> won't work in this case. Instead you can use <code>combineLatest</code>, and then very similarily like @user184994 have otherwise implemented the service code:</p>

<pre><code>isProfileOwner(): Observable&lt;boolean&gt; {
  return Observable.combineLatest(this.currentUser, this.profileId$)
    .map(results =&gt; {
       let user = results[0];
       let profile = results[1];
       return (user.username === profile)
    });
}
</code></pre>

<h2><a href=""https://stackblitz.com/edit/angular-om2uco?file=app%2Fapp.component.html"" rel=""noreferrer""><strong>DEMO</strong></a></h2>
","6294072","","6294072","","2017-10-22 11:45:38","2017-10-22 11:45:38","","","","4","","","","CC BY-SA 3.0"
"46875113","1","","","2017-10-22 14:17:42","","0","327","<p>I am referring Rxjs libraries to Angular 4 application. When I updated package.json references to latest version, thereafter application stop working with runtime application.</p>

<p>I made following major changes and update packages.</p>

<ol>
<li>Angular: 4.4.6 </li>
<li>rxjs: 5.5.0 </li>
<li>typescript: 2.5.3</li>
</ol>

<p>An error that I can see at browser console is as below.
<a href=""https://i.stack.imgur.com/MEHlw.png"" rel=""nofollow noreferrer"">Rxjs error</a></p>

<p>For reference please find package.json contents as below.</p>

<pre><code>{
  ""name"": ""DX101"",
  ""version"": ""1.0.0"",
  ""scripts"": {
    ""start"": ""tsc &amp;&amp; concurrently \""npm run tsc:w\"" \""npm run lite\"" "",
    ""lite"": ""lite-server"",
    ""postinstall"": ""typings install"",
    ""tsc"": ""tsc"",
    ""tsc:w"": ""tsc -w"",
    ""typings"": ""typings""
  },
  ""license"": ""ISC"",
  ""dependencies"": {
    ""@angular/animations"": ""^4.4.6"",
    ""@angular/common"": ""^4.4.6"",
    ""@angular/compiler"": ""^4.4.6"",
    ""@angular/compiler-cli"": ""^4.4.6"",
    ""@angular/core"": ""^4.4.6"",
    ""@angular/forms"": ""^4.4.6"",
    ""@angular/http"": ""^4.4.6"",
    ""@angular/platform-browser"": ""^4.4.6"",
    ""@angular/platform-browser-dynamic"": ""^4.4.6"",
    ""@angular/router"": ""^4.4.6"",
    ""@angular/upgrade"": ""^4.4.6"",
    ""angular-in-memory-web-api"": ""^0.3.2"",
    ""angular2-notifications"": ""^0.7.8"",
    ""bootstrap"": ""^3.3.7"",
    ""core-js"": ""^2.5.1"",
    ""del"": ""^3.0.0"",
    ""font-awesome"": ""^4.7.0"",
    ""gulp"": ""^3.9.1"",
    ""gulp-clean-css"": ""^3.9.0"",
    ""gulp-concat"": ""^2.6.1"",
    ""gulp-live-server"": ""^0.0.30"",
    ""gulp-plumber"": ""^1.1.0"",
    ""gulp-sass"": ""^3.1.0"",
    ""gulp-sass-lint"": ""^1.3.4"",
    ""gulp-sourcemaps"": ""^2.6.1"",
    ""gulp-tslint"": ""^8.1.2"",
    ""gulp-typescript"": ""^3.2.2"",
    ""gulp-uglify"": ""^3.0.0"",
    ""moment"": ""^2.19.1"",
    ""popsicle"": ""^9.1.0"",
    ""reflect-metadata"": ""^0.1.10"",
    ""run-sequence"": ""^1.2.2"",
    ""rxjs"": ""^5.5.0"",
    ""systemjs"": ""^0.20.19"",
    ""systemjs-builder"": ""^0.16.12"",
    ""zone.js"": ""^0.8.18""
  },
  ""devDependencies"": {
    ""@angular/compiler-cli"": ""^4.4.6"",
    ""@types/core-js"": ""^0.9.43"",
    ""@types/node"": ""^8.0.46"",
    ""concurrently"": ""^3.0.0"",
    ""lite-server"": ""^2.3.0"",
    ""typescript"": ""^2.5.3"",
    ""typings"": ""^2.1.1""
  }
}
</code></pre>

<p>I am not sure what wrong has been done but error occurred after updating packages only.</p>

<p>Please help me understand and resolve this issue.</p>

<p>Thanks in advance,</p>
","3134313","","","","","2017-10-22 14:17:42","Failed to load RxJs after updating Typescript to 2.5.3 and Rxjs to 5.5.0","<angular><typescript><rxjs5><package.json>","0","5","","","","CC BY-SA 3.0"
"46879555","1","","","2017-10-22 21:59:39","","0","547","<p>In ReactiveX I can take the latest value out of each of a number of observables, which each may or may not be emitting at different frequencies, as follows (using RxPY):</p>
<pre class=""lang-py prettyprint-override""><code>from __future__ import print_function

from rx import Observable
import time
import IPython
import random

random.seed(123)

x1 = Observable.interval(random.randint(50, 500))
x2 = Observable.interval(random.randint(50, 500))
x3 = Observable.interval(random.randint(50, 500))

xc = Observable.combine_latest(x1, x2, x3, lambda a1, a2, a3: [a1, a2, a3])

xc.subscribe(lambda s: print(s))

input(&quot;Press Enter to end&quot;)
</code></pre>
<p>However, how would I do the same thing, that is, print the latest value from each of a set of observables, whenever any of the observables emits a value, when said observables were created using a group_by?</p>
<pre class=""lang-py prettyprint-override""><code>from __future__ import print_function

from rx import Observable
import time
import IPython
import random

random.seed(123)

n = 5
xx = Observable.interval(random.randint(50, 500)).group_by(lambda x: x % 5) # create n observables
print(xx)
</code></pre>
<p>Thing is this returns an observable group object:</p>
<pre><code>&lt;rx.core.anonymousobservable.AnonymousObservable object at 0xb631bb10&gt;
</code></pre>
<p>So for <em>any given n</em> how would I perform the same combine_latest operation on this object?</p>
<p>I understand that in this stylized example the observables will emit at the same rate, but I need the solution to generalize to different emission frequencies as per the explicit example at the top.</p>
<p>Given that the structure of RxPY and RxJS are so similar, I am happy to consider analogous RxJS answers.</p>
","122792","","4621513","","2020-12-25 17:00:32","2020-12-25 17:00:32","How to use RxPY (or RxJS) combine_latest with a group_by observable","<rxjs><rxjs5><reactivex><rx-py>","1","0","","","","CC BY-SA 4.0"
"46923612","1","","","2017-10-25 03:44:47","","0","412","<p>I have a current problem I'd like to solve in an angular application. I could probably get it working without RXJS but I'd like to get better at streams.</p>

<p>So I have a list of checkboxes. These are defined by an interface of options {id: number, label: string}.</p>

<p>Now I want to pass in an Observable of {id: number, label: string} and then record what is selected and emit the selection every time a selection change has been made on a checkbox.</p>

<p>So I already have my options stream of {id: number, label: string}. My idea was to map that to another stream of type {id: number, label: string, selected: boolean}, then I would have a selectedOptions$ stream that filters off of the transformed stream, but I am stuck and not sure this is even the right approach.</p>

<pre><code>options$: {id: number, label: string};
transformedOptions$: {id: number, label: string, selected: false}
selectedOptions$ = options$.map(options =&gt; options.filter((option) =&gt; option.selected));
</code></pre>
","6833286","","","","","2017-10-25 13:37:49","RXJS list selection stream","<angular><typescript><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"46940927","1","46947968","","2017-10-25 19:47:30","","0","49","<p>I'm new to rxjs and using redux-observable.  The short of it is that I need to make a couple promise requests when i get a connection then output the results.  I'm wondering if there is a way to join this into a single map at the end and not have to call store.dispatch multiple times and have the retry work for each individual read.  Thanks ahead of time for your comments.</p>

<pre><code>export const handleBleConnectionSuccess = (action$,store,{bleCommunicator}) =&gt;
  action$.ofType(c.BLE_CONNECTION_SUCCESS)
    .do((a)=&gt;{
      Observable.fromPromise(bleCommunicator.readCharacteristic(a.device.id,gattInfo.uuid,gattInfo.firmwareRevision.uuid))
        .do((value)=&gt;store.dispatch({type:c.DEVICE_FIRMWARE_VERSION,device:{...a.device,firmwareVersion:value}}))
        .retry(3);

      Observable.fromPromise(bleCommunicator.readCharacteristic(a.device.id,gattInfo.uuid,gattInfo.modelNumber.uuid))
        .do(value=&gt;store.dispatch({type:c.DEVICE_MODEL_NUMBER,device:{...a.device,modelNumber:value}}))
        .retry(3);
    })
    .mapTo({type:'DEVICE_INFORMATION_REQUESTED'});
</code></pre>
","591115","","","","","2017-10-26 07:15:22","Is there a better way to form this code example?","<promise><rxjs><rxjs5><redux-observable>","1","3","","","","CC BY-SA 3.0"
"46943766","1","46944668","","2017-10-25 23:55:19","","3","4592","<p>I think I've found a bug in the RxJS library or just can't understand it's behavior. Take a look at the following code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { Observable, Subject } = Rx;

const source$ = new Subject();

const handle = v =&gt; {
  if (v === 0) {
    source$.next(1);
    return Observable.empty();
  }  
  return Observable.interval(1000).startWith(-1).take(3);
}

source$
  .do(e =&gt; console.log('source:', e))
  // .delay(1)
  // .switchMap(v =&gt; Observable.of(null).switchMap(() =&gt; handle(v)))
  .switchMap(v =&gt; handle(v))
  .subscribe(e =&gt; console.log('handle:', e))

source$.next(0); // &lt;- initial value</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Working scenario:</strong> When I run it with <code>source$.next(1)</code>, I see the following result(which is correct):</p>

<pre><code>source: 1
handle: -1
handle: 0
handle: 1
</code></pre>

<p><strong>Broken scenario:</strong> When I run it with <code>source$.next(0)</code>, I expect to see:</p>

<pre><code>source: 0
... (exactly the same output as for the previous example)
</code></pre>

<p>But instead I see only 3 values:</p>

<pre><code>source: 0
source: 1
handle: -1
</code></pre>

<p><strong>Workaround 1:</strong> When I put <code>.delay(1)</code> as you can see in the comments - it works fine, just as I have expected. I think this is because default Scheduler executed synchronously in the same tick vs using async Scheduler when using delay. </p>

<p><strong>Question</strong>
When I use <code>Observable.of(null)</code> (see comments in the code) it gives me the same(""correct"" or expected) result too. Why is that? Shouldn't it be the same synchronous as before?</p>
","3772379","","","","","2017-10-26 02:58:18","Returning .empty Observable inside .switchMap operator","<rxjs><rxjs5>","1","1","0","","","CC BY-SA 3.0"
"46944668","2","","46943766","2017-10-26 01:58:32","","4","","<p>The behaviour is correct. It's the synchronous emission from the <code>source</code> that makes it a little weird.</p>

<p>Emitting <code>1</code> from within the <code>handle</code> method effects a re-enterant call that sees the <code>startWith</code> value of <code>-1</code> emitted <em>before</em> the <code>Observable.empty</code> is returned - as the <code>startWith</code> value is emitted synchronously.</p>

<p>That means that the <code>switchMap</code> sees the <code>startWith</code>/<code>interval</code> observable first and the <code>empty</code> observable second. It then switches to the <code>empty</code> observable, effecting the output that you see.</p>

<p>Adding a <code>delay</code> prevents the re-enterant call.</p>
","6680611","","6680611","","2017-10-26 02:58:18","2017-10-26 02:58:18","","","","4","","","","CC BY-SA 3.0"
"46947968","2","","46940927","2017-10-26 07:15:22","","1","","<blockquote>
  <p>I'm wondering if there is a way to join this into a single map at the end and not have to call store.dispatch multiple times and have the retry work for each individual read</p>
</blockquote>

<p>Yes, there is a better way, and it's possible to do what you want.<br>
From the syntax, I'm guessing that you use ngrx (effects) (and not redux-observable).</p>

<p>So with ngrx/effects you could do it like that:</p>

<pre><code>export const handleBleConnectionSuccess = (
  action$,
  store,
  { bleCommunicator }
) =&gt;
  action$.ofType(c.BLE_CONNECTION_SUCCESS).switchMap(a =&gt; {
    const readCharacteristic = deviceOrFirmwareUuid =&gt;
      bleCommunicator.readCharacteristic(a.device.id, gattInfo.uuid, deviceOrFirmwareUuid);

    return Observable.merge(
      readCharacteristic(gattInfo.firmwareRevision.uuid)
        .map(value =&gt; ({
          type: c.DEVICE_FIRMWARE_VERSION,
          device: { ...a.device, firmwareVersion: value },
        }))
        .retry(3),

      readCharacteristic(gattInfo.modelNumber.uuid)
        .map(value =&gt; ({
          type: c.DEVICE_MODEL_NUMBER,
          device: { ...a.device, modelNumber: value },
        }))
        .retry(3),

      { type: 'DEVICE_INFORMATION_REQUESTED' }
    );
  });
</code></pre>
","2398593","","","","","2017-10-26 07:15:22","","","","3","","","","CC BY-SA 3.0"
"46963486","1","","","2017-10-26 20:44:15","","33","28037","<p>I have a specific situation where I'm using an RxJS interval, but at any given moment I may need to stop that interval. I assumed there was something easy like a cancel() or stop(). Similar to clearTimeout. This is possible to stop an interval once it's going? If not, what would be another approach.</p>

<p>Basically I have a large array that I'm stepping through. But there are external things that could happen that make it necessary to stop that step through and continue on to a new task. I'm hoping it's something simple that I'm just missing in the docs. Thanks </p>
","1429463","","","","","2019-07-24 13:39:52","How to stop an interval on an Observable in RxJS","<javascript><rxjs><observable><rxjs5>","2","1","5","","","CC BY-SA 3.0"
"46990242","1","46990640","","2017-10-28 13:27:47","","0","383","<p>Say we have a big array and processing of each element in that array takes a long time (5s). We want to add some delay (2s) before processing of next element.</p>

<p>I've somewhat managed to achieve that behavior like that:</p>

<pre><code>let arr = [1, 2, 3]
let i = 0

Rx.Observable.of(null)
.map(val =&gt; arr[i++])
.do(val =&gt; {
  console.log(val + ' preloop')
  let time = +new Date() + 5000; while (+new Date() &lt; time) {}
  console.log(val + ' afterloop')
})
.delay(2000)
.flatMap(val =&gt; (i &lt; arr.length) ? Rx.Observable.throw(null) : Rx.Observable.empty())
.retry()
.subscribe(console.log, console.log, () =&gt; console.log('completed'))
</code></pre>

<p>The output is as expected:</p>

<pre><code>1 preloop
delay 5s
1 afterloop
delay 2s
2 preloop
...
completed
</code></pre>

<p>But this code is ugly, not reusable and buggy and doesn't comply with the philosophy of rx. What is the better way?</p>

<p>Note that the array (or it might even be not an array at all) is big and <a href=""https://stackoverflow.com/a/21663671/2277240"">https://stackoverflow.com/a/21663671/2277240</a> won't work here.</p>

<p>The question is hypothetycal though I can think of some use cases.</p>
","2277240","","","","","2017-10-29 11:54:48","Observable delay after long processing of each element of large array","<javascript><rxjs><observable><rxjs5>","2","1","","","","CC BY-SA 3.0"
"46990640","2","","46990242","2017-10-28 14:11:18","","0","","<p>I'm not sure why the fact that the array is big important here, and you can solve your issue using the same method from the link you provided. </p>

<p>For your long operation a better practice would probably be a promise. I used an async sleep function to simulate a 5 second operation, you can replace it with your promise.</p>

<p>The trick for the extra delay, is to concat a dummy element, delay it and then ignore it.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

Rx.Observable.from([1, 2, 3])
  .concatMap(item =&gt; 
    Rx.Observable.defer(() =&gt; sleep(5000))
      .mapTo(item)
      .concat(Rx.Observable.of(null).delay(2000).ignoreElements()) 
  )
  .subscribe(console.log, console.log, () =&gt; console.log('completed'))</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.2/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3306656","","3306656","","2017-10-29 11:54:48","2017-10-29 11:54:48","","","","5","","","","CC BY-SA 3.0"
"47060190","1","47060295","","2017-11-01 17:11:28","","0","26","<p>I have a slider. I want to change color depending on percentage. Apart from this i want to show tooltip if user does not move mouse N seconds.
I can think about possible solution, but this doesn't seems like correct way, is there any better way to accomplish this task?</p>

<pre><code>Rx.Observable.fromEvent(container,""mousemove"")
.debounceTime(30)
.switchMap(
   () =&gt; Rx.Observable.race(
       Rx.Observable.fromEvent(container,""mousemove"").map(
           (v) =&gt; ""Continue changing color""
       ),
       Rx.Observable.interval(2000).map(
           (v) =&gt; ""Show tooltip!""
       )
   )
)
.subscribe(
  v =&gt; console.log(v)
) 
</code></pre>

<p>Thank you.</p>
","5715298","","","","","2017-11-01 17:17:31","RxJs5 emit on absence of movement","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47060295","2","","47060190","2017-11-01 17:17:31","","3","","<p>Start with the event source, then switch the sequence to timer that emits after the specified time. When the event source emits, it will create another timer, delaying whatever should happen after it.</p>

<pre><code>fromEvent(container,""mousemove"")
  .switchMap(() =&gt; timer(IDLE_TIME))
  .do(() =&gt; { /* show tooltip */ })
  .subscribe()
</code></pre>
","575527","","","","","2017-11-01 17:17:31","","","","0","","","","CC BY-SA 3.0"
"47061272","1","","","2017-11-01 18:18:47","","1","478","<p>I'm getting my feet wet with redux-observable and OAuth2 authentication. I'm stuck at the point where I have to POST adding Authorization header to my HTTP request. The header is has not been added. Instead, I see any custom-set header names as values of Access-Control-Request-Headers, and that's it.</p>

<p>This is a redux-observable 'epic':</p>

<pre><code>const epicAuth = function(action$){
  return action$.ofType(DO_AUTHENTICATE)
    .mergeMap(
      action =&gt; Rx.Observable.ajax( authRequest(action.username, action.password))
        .map( response =&gt; renewTokens(response))
        .catch(error =&gt; Rx.Observable.of({
          type: AJAX_ERROR,
          payload: error,
          error: true,
        }))
    )
}
</code></pre>

<p>This is my request object:</p>

<pre><code>const authRequest = function(username, password){
  return {
    url: TOKEN_PROVIDER + '?grant_type=password&amp;username=' + username + '&amp;password=' + password,
    method: 'POST',
    responseType: 'json',
    crossDomain: true,
    withCredentials: true,
    headers: {
      'Authorization': 'Basic &lt;base64-encoded-user@password&gt;',
    }
  }
}
</code></pre>

<p>The HTTP headers captured:</p>

<pre><code>http://localhost:8082/api/oauth/token?grant_type=password&amp;username=xxx&amp;password=yyy

OPTIONS /api/oauth/token?grant_type=password&amp;username=xxx&amp;password=yyy HTTP/1.1
Host: localhost:8082
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:56.0) Gecko/20100101 Firefox/56.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Access-Control-Request-Method: POST
Access-Control-Request-Headers: authorization
Origin: http://localhost:3000
DNT: 1
Connection: keep-alive

HTTP/1.1 401 
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
WWW-Authenticate: Basic realm=""MY_REALM/client""
Content-Type: text/html;charset=utf-8
Content-Language: en
Content-Length: 1098
Date: Wed, 01 Nov 2017 17:57:38 GMT
</code></pre>

<p>It all ends up with 401 response, since the Authorization header was not sent. I have tested the Oauth2 endpoint manually with Postman tool, and all went well: I've got a valid access token, could renew it, etc. CORS is enabled on server side.</p>

<p>What am I missing here?</p>
","975639","","7154607","","2017-11-01 19:56:27","2017-11-01 20:48:13","rxjs5 Observable.ajax ignores explicitly set HTTP headers","<ajax><oauth-2.0><rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"47065221","1","47066516","","2017-11-01 23:26:49","","3","101","<p>I have the following code</p>

<pre><code>x = new Rx.Subject()
z = new Rx.Subject()
loop = 900000000;

x
  .do(() =&gt; console.log('x start'))
  .do(() =&gt; { let i = loop; while(i--) continue })
  .subscribe(() =&gt; console.log('x end'))

z
  .do(() =&gt; console.log('z start'))
  .do(() =&gt; { let i = loop; while(i--) continue })
  .subscribe(() =&gt; console.log('z end'))

x.subscribe(z)
</code></pre>

<p>If I send a new event to <code>x</code>, this will be the output:</p>

<pre><code>z start
z end
x start
x end
</code></pre>

<p>But I need the subscriptions to occur in parallel, and log it as</p>

<pre><code>x start
z start
x end
z end
</code></pre>

<p>I don't mind about the order.</p>

<p>I've tried adding <code>.subscribeOn(Rx.Scheduler.async)</code> but the result is the same.</p>

<p>Check out an example <a href=""http://plnkr.co/edit/FMlMO4OF8CSP1qz47Jyi?p=preview"" rel=""nofollow noreferrer"">here</a></p>
","1450411","","1450411","","2017-11-02 00:02:36","2017-11-02 02:14:39","Rxjs parallel subscribers","<javascript><rxjs><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"47066516","2","","47065221","2017-11-02 02:14:39","","4","","<p>Looks like you need <code>.observeOn()</code></p>

<pre><code>console.clear()
const x = new Rx.Subject();
const z = new Rx.Subject();
const loop = 900000000;

x
  .do(() =&gt; log('x start'))
  .do(() =&gt; { let i = loop; while(i--) continue })
  .observeOn(Rx.Scheduler.async)
  .subscribe(() =&gt; log('x end'));

z
  .do(() =&gt; log('z start'))
  .do(() =&gt; { let i = loop; while(i--) continue })
  .observeOn(Rx.Scheduler.async)
  .subscribe(() =&gt; log('z end'));

x.subscribe(z);

document
  .querySelector('#next')
  .addEventListener('click', () =&gt; x.next());

function log(data) {
  const logs = document.querySelector('#logs');
  const log = document.createElement('p');
  log.innerText = data;
  logs.appendChild(log);
}
</code></pre>
","4716245","","","","","2017-11-02 02:14:39","","","","0","","","","CC BY-SA 3.0"
"47076103","1","","","2017-11-02 13:04:38","","0","274","<p>I'm trying to use <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md"" rel=""nofollow noreferrer"">Lettable Operators</a> in my import statement after upgrading to Angular 5.0.0 and I get this error.</p>

<pre><code>ERROR in src/app/components/hero-detail/hero-detail.component.ts(32,8): error TS2339: Property 'switchMap' does not exist on type 'Observable&lt;ParamMap&gt;'.
</code></pre>

<p>I changing from <code>import ""rxjs/add/operator/switchMap""</code> to <code>import { switchMap } from ""rxjs/operators""</code></p>

<p>If fails on this code block:</p>

<pre><code>  ngOnInit(): void {
    this.route.paramMap
      .switchMap((params: ParamMap) =&gt;
        this.heroService.getHero(+params.get(""id"")),
      )
      .subscribe(hero =&gt; (this.hero = hero));
  }
</code></pre>

<p>Any ideas?</p>
","4275509","","5394220","","2017-11-02 13:30:41","2017-11-02 13:34:07","Rxjs: Missing property error with lettable operators","<angular><observable><rxjs5>","1","1","","","","CC BY-SA 3.0"
"47081100","1","47085207","","2017-11-02 17:17:33","","2","379","<p>I want to create a function to make a HTTP PUT request in the server but only once every 500ms with the last call parameters if the function is called multiple times within that interval and cancel the last request if it is still in progress.</p>

<p>I researched and came up with this solution:</p>

<pre><code>const { Observable } = require('rxjs/Observable')
const { Subject } = require('rxjs/Subject')
const { switchMap, auditTime } = require('rxjs/operators')

// Simulate HTTP request
function makeRequest (val) {
  return Observable.create(observer =&gt; {
    console.log('Request:', val);
    observer.next(val);
    observer.complete();
  });
}

const toUpdateStream = new Subject();
const notifier$ = toUpdateStream.pipe(
  auditTime(500),
  switchMap(val =&gt; makeRequest(val))
);


function updateThrottle (val) {
  return Observable.create(observer =&gt; {
    const lastUpdate$ = notifier$.subscribe(res =&gt; {
      observer.next(res);
      observer.complete();
      lastUpdate$.unsubscribe();
    });
    toUpdateStream.next(val);
  });
}

// Try to update 3 times with different parameters
updateThrottle(10).subscribe(val =&gt; { console.log('1:', val); });
updateThrottle(20).subscribe(val =&gt; { console.log('2:', val); });
updateThrottle(30).subscribe(val =&gt; { console.log('3:', val); });
</code></pre>

<p>The output is:</p>

<pre><code>Request: 30
1: 30
Request: 30
2: 30
Request: 30
3: 30
</code></pre>

<p>The problem is that I need the Request only being called once with 30, not every time.</p>

<p>What can I do?</p>
","1908941","","3399504","","2017-11-03 01:57:29","2017-11-03 01:57:29","How to throttle a server request with Rxjs 5?","<javascript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"47085207","2","","47081100","2017-11-02 21:53:32","","0","","<p>After trying some stuff I end up with this final solution:</p>

<pre><code>const { Observable } = require('rxjs/Observable')
const { Subject } = require('rxjs/Subject')
const { auditTime, switchMap } = require('rxjs/operators')

// Simulate log with timestamp
const log = msg =&gt; {
  const d = new Date();
  console.log(d.getSeconds() +'.'+ d.getMilliseconds() +' - '+ msg);
}

// Simulate HTTP request that takes 750ms
function makeRequest (val) {
  return Observable.create(observer =&gt; {
    const timeout = setTimeout(() =&gt; {
      log('Request: '+ val);
      observer.next('R'+ val);  // Mock the HTTP response
      observer.complete();
    }, 750);
    return () =&gt; clearTimeout(timeout);
  });
}

const toUpdateStream$ = new Subject();
const updatedStream$ = new Subject();
const filter$ = toUpdateStream$.pipe(
  auditTime(500),
  switchMap(val =&gt; makeRequest(val))
);
filter$.subscribe(val =&gt; updatedStream$.next(val));

function updateThrottle (val) {
  return Observable.create(observer =&gt; {
    const lastUpdate = updatedStream$.subscribe(res =&gt; {
      observer.next(res);
      observer.complete();
      lastUpdate.unsubscribe();
    });
    toUpdateStream$.next(val);
  });
}

log('Start');

// Try 3 requests and the last one (the 30) gets processed
updateThrottle(10).subscribe(val =&gt; log('1: '+ val));
updateThrottle(20).subscribe(val =&gt; log('2: '+ val));
updateThrottle(30).subscribe(val =&gt; log('3: '+ val));

// Try to make more requests when the current one isn't finished
setTimeout(() =&gt; {
  // This one cancels the last one
  updateThrottle(40).subscribe(val =&gt; log('4: '+ val));
  updateThrottle(50).subscribe(val =&gt; log('5: '+ val));
  updateThrottle(60).subscribe(val =&gt; log('6: '+ val)); // This gets processed
}, 600);
</code></pre>

<p>And the logs:</p>

<pre><code>43.394 - Start
45.275 - Request: 60
45.277 - 1: R60
45.277 - 2: R60
45.278 - 3: R60
45.278 - 4: R60
45.278 - 5: R60
45.278 - 6: R60
</code></pre>

<p>Which should only make one request with the last parameters and return that to the listeners.</p>
","1908941","","","","","2017-11-02 21:53:32","","","","0","","","","CC BY-SA 3.0"
"47108485","1","47109204","","2017-11-04 07:24:18","","1","135","<p>The documentation for the Observable operator <code>withLatestFrom</code> in RxJS 5 seems unclear on exactly how interdependent observables (i.e. a diamond pattern of observables) behave.</p>

<p>My question is very similar to <a href=""https://stackoverflow.com/questions/41318193/rxjs-subscribing-to-interdependent-observables"">Rxjs - Subscribing to interdependent observables</a>. A short description follows:</p>

<p>I have three observables A, X and Y. They are configured such that:</p>

<ul>
<li>X depends on A.</li>
<li>Y depends on A and X via the <code>withLatestFrom</code> method.</li>
</ul>

<p>In code, this looks like:</p>

<pre><code>let a$ = Rx.Observable.interval(...)

let x$ = a$.map(...)

let y$ = a$.withLatestFrom(x$).subscribe((a, x) =&gt; {
    console.log(""a = "" + a)
    console.log(""x = "" + x)
})
</code></pre>

<p>My question is, if I were to subscribe to <code>y$</code>, would I be guaranteed to have the latest value of <code>x$</code>?</p>

<p>It is my understanding from the question linked above that this is a hard guarantee: Whenever there is an event on <code>a$</code>, <code>x$</code> will be evaluated first, and then <code>y$</code> will be evaluated using the new value of <code>x$</code>. However, I feel the RxJS documentation is unclear on this matter.</p>

<p>Does <code>withLatestFrom</code> do what I expect?</p>
","8884371","","","","","2017-11-04 09:33:47","In a diamond pattern of Observables, what does `withLatestFrom` guarantee?","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"47109204","2","","47108485","2017-11-04 09:14:29","","0","","<p>With the default (immediate) scheduler, it works just as you would expect:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const a$ = Rx.Observable.interval(1000)

const x$ = a$.map(x =&gt; x + 1)

const sub = a$.withLatestFrom(x$).take(3).subscribe(([a, x]) =&gt; {
  console.log(""a = "" + a)
  console.log(""x = "" + x)
})</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.5.2/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>However, if <code>x$</code> is on a different scheduler, you run into ""strange"" behavior (notice how it takes 2 seconds for the first value to appear, 0 is skipped). </p>

<p>EDIT: Interestingly enough, rxjs ""forgives"" the small discrepancy and combines the correct values from <code>a = 2</code> onward (but I wouldn't rely on that effect)</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const a$ = Rx.Observable.interval(1000)

const x$ = a$.map(x =&gt; x + 1).delay(1)

const sub = a$.withLatestFrom(x$).take(3).subscribe(([a, x]) =&gt; {
  console.log(""a = "" + a)
  console.log(""x = "" + x)
})</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5.5.2/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","870615","","870615","","2017-11-04 09:33:47","2017-11-04 09:33:47","","","","0","","","","CC BY-SA 3.0"
"47140939","1","","","2017-11-06 15:58:42","","1","4354","<p>I am attempting to update some Angular 4 /rxjs code to use the new version 5 syntax and am running into some trouble.</p>

<p>Original Import Statements:</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http, Response, Headers, RequestOptions } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import Properties from './properties';
import ErrorHandler from './error-handler';

//From vendor.ts
import 'rxjs/Subject'
import 'rxjs/BehaviorSubject';
import 'rxjs/Observable';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/timeoutWith';
import 'rxjs/add/operator/retryWhen';
import 'rxjs/add/operator/delay';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/publishReplay';
import 'rxjs/Subscription';
</code></pre>

<p>Original Code:</p>

<pre><code>downloadStatus(job : DownloadJob) : Observable&lt;DownloadJob&gt; {
    let params = {""jobId"": job.id};
    return this.http.post(Properties.URLS.core.downloadStatus.href, params, this.getOptions())
                .retryWhen((errors) =&gt; {
                    return errors.mergeMap((error) =&gt; (error.status === 404) ? Observable.of(error) : Observable.throw(error))
                                    .delay(Properties.SETTINGS.download.pollInterval);
                })
                .timeoutWith(Properties.SETTINGS.download.timeout, Observable.of&lt;DownloadJob&gt;(job))
                .map(this.extractData).catch(ErrorHandler.handleError);
}
</code></pre>

<p>Updated Import Statements:</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http, Response, Headers, RequestOptions } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import { map, catchError, retryWhen, timeoutWith, flatMap, mergeMap, delay } from 'rxjs/operators';
import { of } from 'rxjs/observable/of';
import Properties from './properties';
import ErrorHandler from './error-handler';
//From vendor.ts
import 'rxjs/Subject'
import 'rxjs/BehaviorSubject';
import 'rxjs/Observable';
import 'rxjs/operators/catchError';
import 'rxjs/operators/filter';
import 'rxjs/operators/map';
import 'rxjs/operators/switchMap';
import 'rxjs/operators/mergeMap';
import 'rxjs/operators/debounceTime';
import 'rxjs/operators/timeoutWith';
import 'rxjs/operators/retryWhen';
import 'rxjs/operators/delay';
import 'rxjs/operators/distinctUntilChanged';
import 'rxjs/operators/publishReplay';
import 'rxjs/observable/of';
import 'rxjs/Subscription';
</code></pre>

<p>Updated Code:</p>

<pre><code>downloadStatus(job : DownloadJob) : Observable&lt;DownloadJob&gt; {
    let params = {""jobId"": job.id};
    return this.http.post(Properties.URLS.core.downloadStatus.href, params, this.getOptions()).pipe(
                retryWhen((errors) =&gt; {
                    return errors.pipe(
                                mergeMap((error) =&gt; (error.status === 404) ? of(error) : Observable.throw(error)),
                                delay(Properties.SETTINGS.download.pollInterval)
                    );
                }),
                timeoutWith(Properties.SETTINGS.download.timeout, of(job)),
                map(this.extractData),
                catchError(ErrorHandler.handleError)
    );
}
</code></pre>

<p>Error Message: </p>

<pre><code>TS2345: Argument of type 'UnaryFunction&lt;Observable&lt;DownloadJob&gt;, Observable&lt;DownloadJob&gt;&gt;' is not assignable to parameter of type 'UnaryFunction&lt;Observable&lt;Response&gt;, Observable&lt;DownloadJob&gt;&gt;'.
  Types of parameters 'source' and 'source' are incompatible.
    Type 'Observable&lt;Response&gt;' is not assignable to type 'Observable&lt;DownloadJob&gt;'.
      Type 'Response' is not assignable to type 'DownloadJob'.
        Property 'id' is missing in type 'Response'.
</code></pre>

<p>The problem I am having is with the conversion from Observable.of(job) in the timeoutWith function to of(job).  The TypeScript compiler is now (understandably) complaining about being able to assign the object type.  </p>

<p>With this new syntax how to I fix that?</p>

<p>Thanks in advance!</p>
","8895134","","8895134","","2017-11-06 17:45:26","2017-11-07 01:06:32","Angular 4 to 5 Upgrade - Observable.of","<angular><rxjs><rxjs5>","2","3","1","","","CC BY-SA 3.0"
"47146454","1","","","2017-11-06 21:51:44","","4","1606","<p>Say I have the following epic:</p>

<pre class=""lang-js prettyprint-override""><code>const getPostsEpic = (action$, store) =&gt; {
    return action$.ofType(actionTypes.REQUEST_POSTS)
        .switchMap(action =&gt;
            ajax.getJSON(`api/posts?key=${action.key}`)
            .map(response =&gt;
                receivePosts({type: RECEIVE_POSTS, posts: response})
            ).takeUntil(
                action$.ofType(actionTypes.ABORT_GET_POSTS)
            )
};
</code></pre>

<p>and say my reducer is something like</p>

<pre><code>function reducer(
  state = {
    isFetching: false,
    didInvalidate: true,
    items: []
  },
  action
) {
  switch (action.type) {
    case INVALIDATE_POSTS:
      return Object.assign({}, state, {
        didInvalidate: true
      })
    case REQUEST_POSTS:
      return Object.assign({}, state, {
        isFetching: true,
        didInvalidate: false
      })
    case RECEIVE_POSTS:
      return Object.assign({}, state, {
        isFetching: false,
        didInvalidate: false,
        items: action.posts,
      })
    default:
      return state
  }
}
</code></pre>

<p>I want to make sure that posts are only fetched if my state's <code>didInvalidate === true</code>, is there a good way to make this work with my epic? Could do something like this, but it's not that pretty IMO: </p>

<pre><code>const getPostsEpic = (action$, store) =&gt; {
    return action$.ofType(actionTypes.REQUEST_POSTS)
        .switchMap(action =&gt; {
            const state = store.getState();
            if (state.didInvalidate) {
                return ajax.getJSON(`api/posts?key=${action.key}`)
                    .map(response =&gt;
                        receivePosts({type: RECEIVE_POSTS, posts: response})
                    ).takeUntil(
                        action$.ofType(actionTypes.ABORT_GET_POSTS)
                )
            else {
                return Observable.of({type: RECEIVE_POSTS, posts: state.items});
            }
        }
};
</code></pre>

<p>Btw, I'm using this with React. I'm sure this is a pretty common problem, so maybe there's a better way of handling this outside my epics?</p>
","2713641","","","","","2017-11-16 21:36:08","Conditionally fetching data in epic","<redux><rxjs5><redux-observable>","1","2","1","","","CC BY-SA 3.0"
"47157657","1","47181329","","2017-11-07 12:10:24","","8","8039","<p>I am trying to write a (generic) function <code>run&lt;ID, ENTITY&gt;(â¦): Observable&lt;ENTITY&gt;</code> which takes the following arguments:</p>

<ul>
<li>A function <code>init: () =&gt; Observable&lt;ID&gt;</code> which is an initializing request to start a backend process.</li>
<li>A function <code>status: (id: ID) =&gt; Observable&lt;ENTITY&gt;</code> which takes the generated ID and queries the status for it in the backend.</li>
<li>A function <code>repeat: (status: ENTITY) =&gt; boolean</code> which determines whether the <code>status</code> request must be repeated.</li>
<li>Two integer values <code>initialDelay</code> and <code>repeatDelay</code>.</li>
</ul>

<p>So <code>run</code> should execute <code>init</code>, then wait for <code>initialDelay</code> seconds. From now on it should run <code>status</code> every <code>repeatDelay</code> seconds until <code>repeat()</code> returns <code>false</code>.</p>

<p>However, there are two important things that need to work:</p>

<ul>
<li><code>repeatDelay</code> should only be counted starting when <code>status</code> has emitted its value as to avoid race conditions if <code>status</code> takes longer than <code>repeatDelay</code></li>
<li>The intermediate values emitted by the calls to <code>status</code> must also be emitted to the caller.</li>
</ul>

<hr>

<p>The following (not very pretty) version does everything except for the last thing I mentioned: it doesn't wait for the network response before retrying <code>status</code>.</p>

<pre><code>run&lt;ID, ENTITY&gt;(â¦): Observable&lt;ENTITY&gt; {
    let finished = false;
    return init().mergeMap(id =&gt; {
        return Observable.timer(initialDelay, repeatDelay)
            .switchMap(() =&gt; {
                if (finished) return Observable.of(null);
                return status(id);
            })
            .takeWhile(response =&gt; {
                if (repeat(response)) return true;
                if (finished) return false;

                finished = true;
                return true;
            });
    });
}
</code></pre>

<p>My second version is this, which again works for all but one detail: the intermediate values of the <code>status</code> calls aren't emitted, but I do need them in the caller to show the progress:</p>

<pre><code>run&lt;ID, ENTITY&gt;(â¦): Observable&lt;ENTITY&gt; {
    const loop = id =&gt; {
        return status(id).switchMap(response =&gt; {
            return repeat(response)
                ? Observable.timer(repeatDelay).switchMap(() =&gt; loop(id))
                : Observable.of(response);
        });
    };

    return init()
        .mergeMap(id =&gt; Observable.timer(initialDelay).switchMap(() =&gt; loop(id)));
}
</code></pre>

<p>Admittedly, the latter one also is a bit of a kludge. I'm sure rxjs can solve this problem in a much neater way (and, more importantly, solve it at all), but I can't seem to figure out how.</p>
","1675492","","","","","2017-11-09 21:33:02","Repeat request until condition is met and return intermediate values","<rxjs><rxjs5>","3","2","2","","","CC BY-SA 3.0"
"47181329","2","","47157657","2017-11-08 13:45:35","","2","","<p><strong>Update</strong>: Observable supports recursion natively with <a href=""https://www.learnrxjs.io/operators/transformation/expand.html"" rel=""nofollow noreferrer""><code>expand</code></a>, also shown in @IngoBÃ¼rk's answer. This lets us write the recursion even more concisely:</p>

<pre><code>function run&lt;ENTITY&gt;(/* ... */): Observable&lt;ENTITY&gt; {
  return init().delay(initialDelay).flatMap(id =&gt;
    status(id).expand(s =&gt; 
      repeat(s) ? Observable.of(null).delay(repeatDelay).flatMap(_ =&gt; status(id)) : Observable.empty()
    )
  )
}
</code></pre>

<p><a href=""https://jsfiddle.net/7y8jvp59/"" rel=""nofollow noreferrer"">Fiddle.</a></p>

<hr>

<p>If recursion is acceptable, then you can do things more concisely still:</p>

<pre><code>function run(/* ... */): Observable&lt;ENTITY&gt; {
  function recurse(id: number): Observable&lt;ENTITY&gt; {
    const status$ = status(id).share();
    const tail$ = status$.delay(repeatDelay)
                         .flatMap(status =&gt; repeat(status) ? recurse(id, repeatDelay) : Observable.empty());
    return status$.merge(tail$);
  }
  return init().delay(initialDelay).flatMap(id =&gt; recurse(id));
}
</code></pre>

<p>Try <a href=""https://jsfiddle.net/sLd5smrq/1/"" rel=""nofollow noreferrer"">the fiddle</a>.</p>
","3925507","","3925507","","2017-11-09 21:33:02","2017-11-09 21:33:02","","","","3","","","","CC BY-SA 3.0"
"47200483","1","47203943","","2017-11-09 11:18:25","","5","6583","<p>As staten in the ionic-angular 3.9.0 release notes (<a href=""https://github.com/ionic-team/ionic/blob/master/CHANGELOG.md"" rel=""noreferrer"">https://github.com/ionic-team/ionic/blob/master/CHANGELOG.md</a>), using the advantages of updating to RXJS 5.5.2 could reduce the bundle size and therefore lead to a faster boot time</p>

<p>Cool, cool, cool :)</p>

<p>The example provided by Ionic, to migrate for example <code>debounceTime</code> is pretty clear, I get it.</p>

<p>But it's pretty unclear to me how I should update my following code to take the full advantage of this RXJS update. </p>

<p>Anyone could help me to convert it or how to better write it with the goal to save bundle size?</p>

<pre><code> import {Observable} from 'rxjs/Observable';
 import 'rxjs/add/observable/empty';
 import 'rxjs/add/operator/do';
 import 'rxjs/add/operator/catch';

 intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    return next.handle(req).do((event: HttpEvent&lt;any&gt;) =&gt; {
        if (event instanceof HttpResponse) {
            // do stuff with response if you want
        }
    }).catch((err: HttpErrorResponse) =&gt; {
        if ((err.status == 400) || (err.status == 401)) {
            this.interceptorRedirectService.getInterceptedSource().next(err.status);
            return Observable.empty();
        } else {
            return Observable.throw(err);
        }
    })
}
</code></pre>

<p>P.S.: Linked post <a href=""https://forum.ionicframework.com/t/how-to-better-catch-do-empty-with-rxjs-5-5-2-updates/111559"" rel=""noreferrer"">https://forum.ionicframework.com/t/how-to-better-catch-do-empty-with-rxjs-5-5-2-updates/111559</a></p>
","5404186","","5404186","","2017-11-09 14:06:56","2018-03-16 10:53:30","How to better catch/do/empty with RXJS 5.5.2 Updates","<angular><ionic-framework><rxjs><rxjs5>","2","0","3","","","CC BY-SA 3.0"
"47203943","2","","47200483","2017-11-09 14:09:19","","9","","<p>I came up with the following updated code which still works (tested it).</p>

<pre><code>import {Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/empty';
import {tap} from 'rxjs/operators/tap';
import {catchError} from 'rxjs/operators/catchError';

intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler):   Observable&lt;HttpEvent&lt;any&gt;&gt; {

       return next.handle(req).pipe(
        tap((event: HttpEvent&lt;any&gt;) =&gt; {
            if (event instanceof HttpResponse) {
                // do stuff with response if you want
            }
        }),
        catchError((err: HttpErrorResponse) =&gt; {
            if ((err.status == 400) || (err.status == 401)) {
                this.interceptorRedirectService.getInterceptedSource().next(err.status);
                return Observable.empty();
            } else {
                return Observable.throw(err);
            }
        })
    );
}
</code></pre>

<p>Note:</p>

<ul>
<li><p>Lettable operators have to be imported with a full import path to reduce the bundle size</p>

<p>Good: import {catchError} from 'rxjs/operators/catchError';
Bad:  import {catchError} from 'rxjs/operators';</p></li>
<li><p>Static doesn't change respectively they are not lettable (see <a href=""https://github.com/ReactiveX/rxjs/issues/3059"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/issues/3059</a>)</p></li>
<li><p>Static could be only imported once in app.component.ts for the all app (this won't reduce the bundle size but the code will be cleaner)</p></li>
</ul>
","5404186","","5404186","","2017-11-09 19:06:59","2017-11-09 19:06:59","","","","1","","","","CC BY-SA 3.0"
"47219287","1","47219333","","2017-11-10 09:15:47","","0","223","<p>I'm struggling importing the <code>last</code> operator in my Angular 5 app. We're using Rxjs 5.5.2.</p>

<p>What I do is:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/last';

/* ... */
getData() {
  return Observable.last(/* ... */);
}
</code></pre>

<p>And I get a <code>Property 'last' does not exist on type 'typeof Observable'.</code> error...</p>

<p>What am I doing wrong ?</p>
","6408940","","","","","2017-11-10 10:50:41","Importing operator last in Angular/Rxjs app","<angular><import><rxjs5>","3","0","","","","CC BY-SA 3.0"
"47219333","2","","47219287","2017-11-10 09:18:53","","0","","<p>You are using it as a constuctor. So the import would be: <code>'rxjs/add/observable/last'</code></p>
","2564847","","","","","2017-11-10 09:18:53","","","","2","","","","CC BY-SA 3.0"
"47220718","1","47221055","","2017-11-10 10:31:21","","0","135","<p>i want to return token from localStorage and catch error. </p>

<pre><code>Observable.of(JSON.parse(localStorage.getItem('currentUser')).token)
.catch((er) =&gt; Observable.of(console.log(er))
</code></pre>

<p>But it does not catch it. Interesting is when I use try catch method ,I can catch error</p>

<pre><code>  try {
      return Observable.of(JSON.parse(localStorage.getItem('currentUser')).token);
    } catch (er) {
      console.log(er);
    }
</code></pre>

<p>What is the reason of that? Hope someone give advice.<a href=""https://i.stack.imgur.com/wtZaL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wtZaL.png"" alt=""enter image description here""></a>
Thanks</p>
","7943893","","7943893","","2017-11-10 10:47:54","2017-11-10 10:49:49","Rx.Observable.Of error is not catched","<angular><rxjs><observable><rxjs5><rxjs-dom>","1","6","1","","","CC BY-SA 3.0"
"47221055","2","","47220718","2017-11-10 10:49:49","","1","","<p>Because the error is thrown before it's result is passed into <code>Observable.of</code>. This is unrelated to RxJS, that's how the order of statements is executed by the JS interpreter.</p>

<p>You can do for example:</p>

<pre><code>Observable.defer(() =&gt; Observable.of(JSON.parse(localStorage.getItem('currentUser')).token))
  .catch(???) // returning Observable.of(console.log(er) is probably useless
</code></pre>
","310726","","","","","2017-11-10 10:49:49","","","","1","","","","CC BY-SA 3.0"
"47226685","1","47227234","","2017-11-10 15:57:14","","2","800","<p><strong>The problem</strong>: My app might receive querystring params and depending on which param is in the querystring different actions need to be done:</p>

<p>1) Here I look for <strong>advertiser</strong> in querystring, if it is there I need to subscribe to a service that will validate the advertiser:</p>

<pre><code>this.activatedRoute.queryParams
  .filter(data =&gt; data.hasOwnProperty('advertiser'))
  .mergeMap(v =&gt; {
    advertiserId = v.advertiser;
    return this.myService.advertiserCheck(v.advertiser);
  })
  .subscribe(data =&gt; {
    if (true === data.valid) {
      // some processing takes place
    }
  });
</code></pre>

<p>2) Here I look for <strong>orderKey</strong> param:</p>

<pre><code>this.activatedRoute.queryParams
  .filter(data =&gt; data.hasOwnProperty('orderKey'))
  .mergeMap(() =&gt; this.activatedRoute.firstChild.firstChild.url)
  .subscribe(segments =&gt; {
    // some processing takes place with the url segments
  });
</code></pre>

<p>As you can see I am subscribing to ActivatedRoute.queryParams twice. Is there a way I can combine the 2? I tried the following:</p>

<pre><code>this.activatedRoute.queryParams
  .filter(data =&gt; data.hasOwnProperty('advertiser') || data.hasOwnProperty('orderKey'))
  .mergeMap(v =&gt; {
    if (v.hasOwnProperty('advertiser')) {
      advertiserId = v.advertiser;
      return this.myService.advertiserCheck(v.advertiser);
    } else {
      return this.activatedRoute.firstChild.firstChild.url;
    }
  })
  .subscribe(data =&gt; {
    console.log('which one am I handling?');
});
</code></pre>

<p>These parameters are <strong>not</strong> going to be in the querystring at the same time but in the subscribe I do not know which one am I handling. I suppose I can create a variable and then check that inside the subscribe but it doesn't look very elegant. Is there a better way? Should I leave as it is so it is less confusing?</p>
","8579910","","","","","2017-11-10 16:29:27","how to filter activatedRoute.queryParams and subscribe to different observables according to the filter","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47227234","2","","47226685","2017-11-10 16:29:27","","2","","<p>I would leave them as 2 independent sequences since they have different end results. But I would also have them share the same underlying observable sequence with the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/sharereplay.md]"" rel=""nofollow noreferrer""><code>shareReplay</code></a>operator.</p>

<pre><code>ngOnInit(){
    this.obs$ = this.activatedRoute.queryParams
        .shareReplay();

    // sequence 1
    this.obs$
        .filter(data =&gt; data.hasOwnProperty('advertiser'))
        .mergeMap(v =&gt; {
            advertiserId = v.advertiser;
            return this.myService.advertiserCheck(v.advertiser);
        })
        .subscribe(data =&gt; {//process});

    // sequence 2
    this.obs$
        .filter(data =&gt; data.hasOwnProperty('orderKey'))
        .mergeMap(() =&gt; this.activatedRoute.firstChild.firstChild.url)
        .subscribe(segments =&gt; {//process});
}
</code></pre>
","7176268","","","","","2017-11-10 16:29:27","","","","0","","","","CC BY-SA 3.0"
"47230787","1","47237783","","2017-11-10 20:40:33","","10","7768","<p>I'm migrating an ionic 3.8 app to 3.9.2.
This migration includes an update to RXJS 5.5</p>

<p>I'm now experiencing this error:</p>

<p><code>TypeError: this._subscribe is not a function. (In 'this._subscribe(sink)', 'this._subscribe' is an instance of t)</code></p>

<p>After hours of debugging, I found out that this code portion is related to the error:</p>

<pre><code>protected observeConnectionState() {

    // rxjs/observable/of
    of(new Event('disconnect'))
        .pipe(
            // rxjs/operators/merge
            merge(connect$),
            merge(disconnect$),

            // Map eventname to string (rxjs/operators/map)
            map((e: IEvent) =&gt; {
                return e.eventName == 'connect' ? 'connected' : 'disconnected';
            })
        )
        // Apply to class context
        .subscribe((newConnectionState) =&gt; {
            // this.connectionState$ is a BehaviorSubject
            this.connectionState$.next(newConnectionState);
        });
}
</code></pre>

<p><strong>ADDITIONAL INFO</strong></p>

<ul>
<li>There are two places in the RXJS code, were I was able to find <code>this._subscribe</code>: <a href=""https://github.com/ReactiveX/rxjs/blob/ad143f15bfe4d2780448f3841d09ccf3db087122/src/Observable.ts#L218"" rel=""noreferrer"">Observable.ts Line 203</a> and <a href=""https://github.com/ReactiveX/rxjs/blob/ad143f15bfe4d2780448f3841d09ccf3db087122/src/Observable.ts#L218"" rel=""noreferrer"">Observable.ts Line 208</a>.</li>
</ul>
","1646019","","1646019","","2017-11-11 12:18:41","2020-01-30 22:33:12","RXJS: TypeError: this._subscribe is not a function","<angular><ionic3><rxjs5>","2","3","","","","CC BY-SA 3.0"
"47231906","1","47232248","","2017-11-10 22:11:53","","0","33","<p>I'm new to RxJS. I'm using RxJs 5.5.2</p>

<p>To keep it simple I want to return the reduced value every time I called next on a subject. Here is a sample code:</p>

<pre><code>const sub = new Subject&lt;number&gt;();
const obsesvable = sub.pipe(
  reduce((a, b) =&gt; {
    return a + b;
  }, 0)
);

obsesvable.subscribe(x =&gt; console.log(x));

sub.next(2);
sub.next(3);
// if I don't call this nothing happens
sub.complete();
</code></pre>

<p>Now if I don't call <code>sub.complete()</code> nothing happens. </p>

<p>If I call <code>sub.complete()</code> I can't send values any more with <code>sub.next()</code>;</p>
","714211","","209259","","2017-11-10 22:15:10","2017-11-10 22:43:12","Use reduce Subject without calling complete","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47232248","2","","47231906","2017-11-10 22:43:12","","1","","<p>Take a look to the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-reduce"" rel=""nofollow noreferrer"">marble diagram</a> of <code>reduce</code> method.</p>

<p><a href=""https://i.stack.imgur.com/USmDa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/USmDa.png"" alt=""enter image description here""></a></p>

<p>It'll only emit when the stream is ended, that's why you don't have anything until you call <code>complete</code>.</p>

<p>If you want to ""reduce"" and get the values over time you should rather use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-scan"" rel=""nofollow noreferrer"">scan</a>:
<a href=""https://i.stack.imgur.com/k3jrE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/k3jrE.png"" alt=""enter image description here""></a></p>

<p>So your code should rather be: </p>

<pre><code>const sub = new Subject&lt;number&gt;();
const obsesvable = sub.pipe(
  scan((a, b) =&gt; {
    return a + b;
  }, 0)
);

obsesvable.subscribe(x =&gt; console.log(x));

sub.next(2);
// output: 2
sub.next(3);
// output: 5
</code></pre>
","2398593","","","","","2017-11-10 22:43:12","","","","0","","","","CC BY-SA 3.0"
"47233377","1","47236829","","2017-11-11 01:22:17","","1","223","<p>RxJS version: 5.5.2</p>

<p>I have an array <code>const v = [1, 2, 3];</code></p>

<p>I want to be able to create a Subject from this array and act like an Observable until it consumes the 1, 2, 3 values. After that I want to act like a Subject.</p>

<p>Here is where I'm having trouble. I need to use <code>reduce</code> on initial values <code>v = [1, 2, 3]</code> then every time the Subject adds another value to use <code>scan</code></p>

<p>Here is the code:</p>

<pre><code>const v = [1, 2, 3];
const sub = new Subject&lt;number&gt;();
const observable = sub.pipe(
  startWith(0),
  concatMap(x =&gt; from(v)),
  scan((a, b) =&gt; { // or reduce
    return a + b;
  }, 0),
);
observable.subscribe(x =&gt; console.log(x));
</code></pre>

<p>If I'm using <code>scan</code> here this is printed on console</p>

<pre><code>1
3
6
</code></pre>

<p>What I want to be printed is just last value <code>6</code>. Replacing <code>scan</code> with <code>reduce</code> will do the job only if subject is completed(that way I can't send any more values in the future).</p>

<p>Then every time the subject sends a value <code>sub.next(4);</code> to print <code>10</code> and so on.</p>
","714211","","","","","2017-11-11 10:21:37","Combination of reduce and scan with a subject","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47236829","2","","47233377","2017-11-11 10:21:37","","1","","<p>You can use <code>skipWhile()</code> to skip the first N emissions from <code>scan</code> that you don't want:</p>

<pre><code>import { Subject } from ""rxjs/Subject"";
import { from } from ""rxjs/observable/from"";
import { of } from ""rxjs/observable/of"";
import { merge, concatMap, scan, skipWhile, tap } from ""rxjs/operators"";

const v = [1, 2, 3];
let skipFirst;

const sub = new Subject&lt;number&gt;();

const observable = of(v).pipe(
  tap(arr =&gt; skipFirst = arr.length),
  concatMap(arr =&gt; from(arr)),
  merge(sub),
  scan((a, b) =&gt; { // or reduce
    return a + b;
  }, 0),
  skipWhile(() =&gt; --skipFirst &gt; 0),
);
observable.subscribe(x =&gt; console.log(x));

sub.next(5);
</code></pre>

<p>This prints:</p>

<pre><code>6
11
</code></pre>
","310726","","","","","2017-11-11 10:21:37","","","","0","","","","CC BY-SA 3.0"
"47237041","1","47237048","","2017-11-11 10:46:14","","2","2320","<p>This is actually note to self but it could be useful for others.</p>

<p>So, here's 2 pieces of code and my question in gitter:</p>

<p>What's the difference between those two?:</p>

<pre><code>    @Effect()
    loadRegistrationsFailed$: Observable&lt;Action&gt; = this.actions$
        .ofType(registrations.LOAD_FAIL)
        .pipe(
            map(
                action =&gt;
                    new ShowErrorDialogAction({
                        correlationId: new Guid(),
                        title: ""Server is unreachable"",
                        message:
                            ""Can't load user registrations. Can't connect to the server""
                    })
            )
        );
```
and
```
    @Effect()
    loadRegistrationsFailed$: Observable&lt;Action&gt; = this.actions$
        .ofType(registrations.LOAD_FAIL)
        .pipe(action =&gt;
            of(
                new ShowErrorDialogAction({
                    correlationId: new Guid(),
                    title: ""Server is unreachable"",
                    message:
                        ""Can't load user registrations. Can't connect to the server""
                })
            )
        );
</code></pre>
","2896495","","","","","2017-11-11 14:20:26","How RxJS pipe works (lettable operators)","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"47237048","2","","47237041","2017-11-11 10:47:01","","1","","<p>Thanks to Brandt B., here's the answer:</p>

<blockquote>
  <p>its related to how the pipe function works. pipe reduces the array of functions passed to it. In the previous value it executes the map function which stores the function you passed to the map internally. In the second example it executes the action=> of immediatly and returns it as the result of the pipe. Therefore the result of the entire observable is of(action) which gets subscribed to by the effect library which produces the value immediately</p>
</blockquote>

<hr>

<p>The answer from Dorus on the same question:</p>

<p>The difference between those two samples is the the first one will map the values, where the second one will just replace the entire thing with of and ignore anything emitted by the source.</p>

<p>The correct way to write the second one would be</p>

<pre><code>@Effect()
loadRegistrationsFailed$: Observable&lt;Action&gt; = this.actions$
    .ofType(registrations.LOAD_FAIL)
    .pipe(ob =&gt; ob.mergeMap(action =&gt;
        of(
            new ShowErrorDialogAction({
                correlationId: new Guid(),
                title: ""Server is unreachable"",
                message:
                    ""Can't load user registrations. Can't connect to the server""
            })
        ))
    );
</code></pre>

<p>Since you dont use action, you could also use mergeMapTo or mepTo:</p>

<pre><code>@Effect()
loadRegistrationsFailed$: Observable&lt;Action&gt; = this.actions$
    .ofType(registrations.LOAD_FAIL)
    .pipe(ob =&gt; ob.mergeMapTo(of(
            new ShowErrorDialogAction({
                correlationId: new Guid(),
                title: ""Server is unreachable"",
                message:
                    ""Can't load user registrations. Can't connect to the server""
            })
        ))
    );
</code></pre>

<p>The only thing lettable operators add is that you can write .pipe(map()) instead of .pipe(ob => ob.map())</p>
","2896495","","2896495","","2017-11-11 14:20:26","2017-11-11 14:20:26","","","","0","","","","CC BY-SA 3.0"
"47237783","2","","47230787","2017-11-11 12:17:29","","10","","<p>Well, I found the problem. And it's not related to Cordova.</p>

<p>For other people encountering this problem:
Forget the stack trace - it's useless. In my case in a subscriber of <code>this.connectionState$</code> I tried to create an Observable from a promise. But I did it wrong.</p>

<p>This is what was wrong:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
//...
const myObservable$ = Observable.create(myPromise);
</code></pre>

<p>This is how it should be done:</p>

<pre><code>import { fromPromise } from 'rxjs/observable/fromPromise';
// ...
const myObservable$ = fromPromise(myPromise);
</code></pre>
","1646019","","","","","2017-11-11 12:17:29","","","","0","","","","CC BY-SA 3.0"
"47238274","1","47238826","","2017-11-11 13:13:55","","1","59","<p>RxJS 5.5.2</p>

<p>I'm having the following code who splits an array of numbers into an object with 2 properties <em>'small'</em> for numbers smaller then 4 and <em>'big'</em> for the rest.</p>

<pre><code>const o = from([1, 2, 3, 4, 5, 6]).pipe(
  scan&lt;number, {}&gt;((a, b) =&gt; {
    if (b &lt; 4) {
      a['small'].push(b);
    } else {
      a['big'].push(b);
    }
    return a;
  }, {
    'small': [],
    'big': []
  })
);
console.log('subscription 1');
o.subscribe(x =&gt; console.log(JSON.stringify(x)));
console.log('subscription 2');
o.subscribe(x =&gt; console.log(JSON.stringify(x)));
</code></pre>

<p>After subscription 1 console prints: </p>

<pre><code>{""small"":[1,2,3],""big"":[4,5,6]} // this is ok
</code></pre>

<p>After subscription 2 console prints: </p>

<pre><code>{""small"":[1,2,3,1,2,3],""big"":[4,5,6,4,5,6]} // this is not ok
</code></pre>

<p>Is there a way to start with a new seed object every time someone subscribes?</p>
","714211","","","","","2017-11-11 14:13:32","Create a new seed object on scan operator for every subscription","<javascript><typescript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"47238826","2","","47238274","2017-11-11 14:13:32","","2","","<p>Another option is to wrap the pipeline in a <code>defer</code> block which will rebuild the source stream at subscription.</p>

<pre><code>defer(() =&gt;
  from([1, 2, 3, 4, 5, 6]).pipe(
    scan&lt;number, {}&gt;((a, b) =&gt; {
      if (b &lt; 4) {
        a['small'].push(b);
      } else {
        a['big'].push(b);
      }
      return a;
    }, {
      'small': [],
      'big': []
    })
  )
);
</code></pre>

<p>Each subscription would call the method in the defer block and subscribe to the result. Though as @arturgrzesiak mentioned, mutating arrays is looked on as an anti pattern in functional programming and by extension functional reactive programming.</p>
","2521865","","","","","2017-11-11 14:13:32","","","","0","","","","CC BY-SA 3.0"
"47239675","1","","","2017-11-11 15:39:50","","0","232","<p>How can I achive something like the following using RxJS?</p>

<p>a-b-c-d-e-f-g-h</p>

<p>ab---cd---ef---gh </p>

<p>or </p>

<p>a-b-c-d-e-f-g-h</p>

<p>abc----def----gh</p>

<p>I have an array which I need to split by specified partitions and emit values with specified interval.</p>
","5283334","","","","","2017-11-11 20:34:33","RxJS - split by partitions and emit with iterval","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"47252009","1","47252843","","2017-11-12 17:52:13","","1","1112","<p>I have an epic like this:</p>

<pre><code>export const fetchCharacter = (id) =&gt;
  ajax({ url: `https://swapi.co/api/people/${id}` })
    .map(response =&gt; fetchCharacterSuccess(response.body))
    .catch(error =&gt; Observable.of(fetchCharacterFailure(error.response.body)));

export const startFetchingCharacters = () =&gt; ({ type: START_FETCHING_CHARACTERS });

export const fetchUserEpic = (action$, store) =&gt;
  action$.ofType(START_FETCHING_CHARACTERS)
    .delay(3000)
    .mergeMap(
      action =&gt; api.fetchCharacter(store.getState().nextCharacterId)
    );
</code></pre>

<p>Right now it only listens for <code>START_FETCHING_CHARACTERS</code> action and makes <strong>one</strong> request for the user.</p>

<p>Now I would like to keep fetching characters over and over(with delay) until some cancellation action. How can I achieve that?</p>
","4443323","","4443323","","2017-11-12 19:24:28","2017-11-13 22:44:04","Rxjs with redux-observable. Repeat action","<redux><rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"47252843","2","","47252009","2017-11-12 19:15:37","","5","","<p>Map an <code>.interval()</code> observable to the api fetch (or a <code>.timer()</code> depending on the exact pattern of delay you want).  </p>

<p>Stop it with a <code>takeUntil()</code>.</p>

<pre class=""lang-js prettyprint-override""><code>const delay = 3000
const fetchUserEpic = (action$, store) =&gt;
  action$.ofType(START_FETCHING_CHARACTERS)
    .mergeMap( action =&gt; 
      Observable.interval(delay)
        .mergeMap(x =&gt; api.fetchCharacter(store.getState().nextCharacterId) )
        .takeUntil(action$.ofType(STOP_FETCHING_CHARACTERS))
    );
</code></pre>

<hr>

<p><strong>Footnote</strong>  </p>

<p>Strictly speaking, the inner <code>mergeMap()</code> does not guarantee the order of character return. Since <code>api.fetchCharacter()</code> is asynchronous, it's possible for fetch's to return out of order (although a long delay of 3s helps avoid that).</p>

<p>Using <code>concatMap()</code> on the inner observable makes sure emits happen in strict <code>nextCharacterId()</code> order.</p>

<pre class=""lang-js prettyprint-override""><code>Observable.interval(delay)
  .concatMap(x =&gt; api.fetchCharacter(store.getState().nextCharacterId) )
</code></pre>
","4716245","","4716245","","2017-11-13 22:44:04","2017-11-13 22:44:04","","","","2","","","","CC BY-SA 3.0"
"47272147","1","47273593","","2017-11-13 19:34:40","","2","725","<p>I am using redux-observable for react app and webpack for bundling.</p>

<p>When I include a specific operator from rxjs like</p>

<pre><code>import 'rxjs/add/operator/mapTo';
</code></pre>

<p>it doesn't work and throws error </p>

<pre><code>TypeError: action$.ofType(...).mapTo is not a function. 
</code></pre>

<p>But when I include complete rxjs library, it works</p>

<pre><code>import 'rxjs';
</code></pre>

<p>When importing specific operator, my js bundle does contain mapTo code but the methods are not getting included in Observable prototype.  I am using webpack for bundling. Do we have to do anything special for importing specific operator in webpack?</p>

<p><strong>Code</strong>:</p>

<pre><code>import { combineEpics } from 'redux-observable';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/mapTo';

const PING = 'PING';
const PONG = 'PONG';

const pingEpic = action$ =&gt; {
  const obser = action$.ofType(PING);
  return obser.mapTo({ type: PONG });
}

export const epic$ = new BehaviorSubject(combineEpics(pingEpic));
export const createRootEpic = (action$, store) =&gt;
epic$.mergeMap(epic =&gt;
  epic(action$, store)
);
</code></pre>

<hr>

<p><strong>Update</strong>:</p>

<p><code>mapTo</code> method is available to <code>BehaviorSubject</code> object (<code>epic$.mapTo</code> is available) but not to <code>ActionsObservable</code> object (<code>action$.mapTo</code> is not a function).</p>
","1261106","","1261106","","2017-11-14 15:04:20","2017-11-14 15:04:20","Importing a single rxjs operator not working with react and webpack","<rxjs><rxjs5><redux-observable>","1","5","","","","CC BY-SA 3.0"
"47273593","2","","47272147","2017-11-13 21:10:11","","1","","<p>The issue is highly likely to be that you accidentally have two copies of RxJS. This can happen in several situations, but in your specific case it sounds highly likely to <a href=""https://github.com/ReactiveX/rxjs/issues/2984"" rel=""nofollow noreferrer"">a recently reported issue in rxjs</a>. That particular issue was fixed started in 5.5.1 (5.5.2 is now the latest).</p>

<p>Make sure you have RxJS 5.5.1 or above installed--you may need to remove your node_modules and reinstall to get a newer version locally if your semver range is broad. You can also triple check by looking at node_modules/rxjs/package.json the <code>""version""</code> field, usually at the bottom</p>
","1770633","","","","","2017-11-13 21:10:11","","","","5","","","","CC BY-SA 3.0"
"47295555","1","","","2017-11-14 21:30:47","","0","60","<p>Can someone please help me restructure the following observable stream so if an exception occurs during the getPreferences on the local provider the remote provider getPreferences will still occur?</p>

<p>thanks!</p>

<pre><code>    @Effect() load$: Observable&lt;Action&gt; = this._actions$
    .ofType&lt;Load&gt;(LOAD)
    .pipe(
        switchMap(() =&gt; {
            return this._localProvider.getPreferences()
                .pipe(
                    tap((preferences: Preferences) =&gt; {
                        this._store.dispatch(new LoadSuccess(preferences));
                    }),
                    switchMap((preferences: Preferences) =&gt; {
                        return this._remoteProvider.getPreferences()
                            .pipe(
                                filter((remotePref: Preferences) =&gt; {
                                    return remotePref.timestamp$ &gt; preferences.timestamp$;
                                }),
                                map((remotePref: Preferences) =&gt; {
                                    return new LoadSuccess(remotePref);
                                }),
                                catchError(error =&gt; {
                                    return of(new LoadError(error));
                                })
                            )
                    }),
                    catchError(error =&gt; {
                        return of(new LoadError(error));
                    })
                )
        }),
    );
</code></pre>
","8882641","","","","","2017-11-14 21:30:47","Stream operations not in correct order","<rxjs><rxjs5><ngrx><ngrx-effects>","0","3","","","","CC BY-SA 3.0"
"47297586","1","47297900","","2017-11-15 00:36:48","","2","610","<p>Now that we have ""lettable"" operators, how should we go about creating an <code>Observable</code> from another?</p>

<p>When I try to do:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {Observable} from 'rxjs/Observable'
const source = Observable.from(someOtherStream)</code></pre>
</div>
</div>
</p>

<p>I get the error <code>Observable.from is not a function</code>, which makes sense, because <code>from</code> is now something else that needs to be imported separately.</p>

<p>I don't want to do </p>

<p><code>import 'rxjs/add/observable/from'</code> anymore due to the prototypal problems there.</p>

<p>What I ended up doing was:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { Observable } from 'rxjs/Observable'
import { from } from 'rxjs/observable/from'

const myNewStream = from.call(
  Observable,
  someOtherStream
)</code></pre>
</div>
</div>
</p>

<p>But this really feels ""hacky"" for some reason to me.  Does anyone have any better ways of going about this?</p>
","282250","","","","","2017-11-16 15:31:36","Best way to create Observable, using from, in RxJS 5.x?","<javascript><rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"47297900","2","","47297586","2017-11-15 01:19:01","","4","","<p>The lettables are behind <code>rxjs/operators</code> <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md"" rel=""nofollow noreferrer"">here's the write up on it</a>.</p>

<p>For <code>from</code> you should be able to import it without importing Observable.</p>

<pre><code>import { from } from 'rxjs/observable/from';

const prom = new Promise(res =&gt; setTimeout(
  () =&gt; res('promise'), 3000
));

from(prom).subscribe(x =&gt; console.log(x));
</code></pre>

<p><a href=""https://www.webpackbin.com/bins/-KyxE7F4y0P9XCq4ZA21"" rel=""nofollow noreferrer"">webpackbin example</a></p>

<p>Using <code>from</code> this way allows you to <code>pipe()</code> to the lettable operators.</p>

<pre><code>import { from } from 'rxjs/observable/from';
import { map } from 'rxjs/operators/map';

const prom = new Promise(res =&gt; setTimeout(
  () =&gt; res('promise'), 3000
));

from(prom).pipe(
  map(x =&gt; x.split('').reverse().join(''))
).subscribe(x =&gt; console.log(x));
</code></pre>

<p><a href=""https://www.webpackbin.com/bins/-KyxZ7nKTBlSnkWyCDjG"" rel=""nofollow noreferrer"">webpackbin example</a></p>
","194252","","194252","","2017-11-16 15:31:36","2017-11-16 15:31:36","","","","3","","","","CC BY-SA 3.0"
"47306281","1","47357148","","2017-11-15 11:30:34","","2","753","<p>I have the following epic I use in my application to handle api requests:</p>

<pre><code>action$ =&gt; {
  return action$.ofType(actions.requestType)
    .do(() =&gt; console.log('handled epic ' + actions.requestType))
    .switchMap((action) =&gt; (
      Observable.create((obs) =&gt; {
        obs.next({ type: type, value: action.value, form: action.form });
      })
      .debounceTime(250)
      .switchMap((iea) =&gt; (
        Observable.ajax(ajaxPost(url(iea.value), body ? body(iea.value) : action.form))
          .mergeMap(payload =&gt; {
            return Observable.merge(
              Observable.of(actions.success(payload)),
              /* some other stuff */
            );
          })
          .catch(payload =&gt; {
            return [actions.failure(payload)];
          })
      ))
  ))
  .takeUntil(action$.filter((a) =&gt; (a.type === masterCancelAction))
  .repeat();
};
</code></pre>

<p>Basically, any time I perform an api request, I dispatch a request action. If I dispatch another request quickly, the previous one is ignored using debounceTime. Additionally, the request can be cancelled using the masterCancelAction and when cancelled repeat() restarts the epic. This epic works as intended in all cases expect one.</p>

<p>The failure case occurs when a user uses the browser back during a request. In this case I fire the masterCancelAction to the request. However, on the same execution context as a result from the masterCancelAction, another request action dispatches to perform a new request on the same epic, but the api request does not occur (the console.log does occur though) as if there was no repeat(). In other cases where cancels occur, the next request is not invoked from the same execution context and it works fine, so it seems in this case my code does not give repeat a chance to restart the epic?</p>

<p>A dirty workaround I found was to use setTimeout(dispatch(action), 0) on the request that dispatches after the cancellation. This seems to allow repeat() to execute. I tried passing different schedulers into repeat, but that didn't seem to help. Also, attaching takeUntil and repeat into my inner switchMap solves the problem, but then other cases where my next request does not execute in the same call stack fail.</p>

<p>Is there a way I can solve this problem without using setTimeout? Maybe it is not a repeat related problem, but it seems to be the case.</p>

<p>Using rxjs 5.0.3 and redux-observable 0.14.1.</p>
","2734447","","","","","2017-11-17 18:34:54","RXJS repeat does not have a chance to repeat?","<rxjs><rxjs5><redux-observable>","1","0","1","","","CC BY-SA 3.0"
"47318629","1","","","2017-11-15 22:47:08","","0","961","<p>I am new to RxJs and trying to use it in my node app. Following code expects to return array of objects and each object should have nested array in one of its property.</p>

<p>Now the problem is it returns expected array of Objects, except the inner observable (that is supposed to be an array) is still not flattened in the subscribe. </p>

<pre><code>createPlanOffers = (groupPlans) =&gt; {
    const groupPlan1 = groupPlans.filter(PREDICATE_1);
    return groupPlans
        .filter(PREDICATE_2)
        .reduce((offers, plan2) =&gt; {
            const plans_1 = groupPlan1.filter(PREDICATE_1_1);
            const plan1Details = plans_1.flatMap(plan1 =&gt; ({
                id: plan1.ID
            }));
            const offer = {
                groupKey: plan2.KEY,
                plan1Details: plan1Details
            };
            offers.push(offer);
            return offers;
        }, []);
};

const classPlans = query()
    .groupBy(group =&gt; group.KEY)
    .flatMap(groupPlans =&gt; createPlanOffers(groupPlans))
    .subscribe(group =&gt; console.log(group),
        err =&gt; console.log(err),
        () =&gt; console.log('complete'));
</code></pre>

<p>Expected Result:</p>

<pre><code>[
 { groupKey: 1111,
   plan1Details: [{id: xyz}]
 },
 { groupKey: 2222,
   plan1Details: [{id: xyz}]
 },
 { groupKey: 2222,
   plan1Details: [{id: abc}]
 } 
]
</code></pre>

<p>Actual Result :(</p>

<pre><code>[
 { groupKey: 1111,
   plan1Details: 
     Observable {
     _isScalar: false,
     source: [Observable],
     operator: [MergeMapOperator] } },
   { groupKey: 2222,
     plan1Details: 
       Observable {
       _isScalar: false,
       source: [Observable],
       operator: [MergeMapOperator] } },
   { groupKey: 2222,
     plan1Details: 
       Observable {
       _isScalar: false,
       source: [Observable],
       operator: [MergeMapOperator] } } 
]
</code></pre>

<p>This query will return something like:</p>

<pre><code>const query = () =&gt; Rx.Observable.from([
    { KEY: 1111,
        id: 'xyz',
        category: 'A', // predicates are using these categories for filters
    }
    { GRGR_CK: 2222,
        id: 'xyz',
        category: 'A',
    }
    { GRGR_CK: 2222,
        id: 'ABC',
        category: 'B',
    }
])
</code></pre>
","2578222","","2829204","","2017-11-16 01:44:31","2017-11-16 02:58:52","Flattening Nested Observable in object property","<node.js><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"47328638","1","47329463","","2017-11-16 11:35:28","","2","5431","<p>I will try use async pipe for show/hide some waiting message.</p>

<p><strong>app.component.html</strong></p>

<pre><code>&lt;ng-template #isWait&gt;
    &lt;h1&gt;Please wait&lt;/h1&gt;
&lt;/ng-template&gt;

&lt;div *ngIf=""wait | async; else isWait""&gt;
    &lt;hello name=""{{ name }}""&gt;&lt;/hello&gt;

    &lt;p&gt;
        Start editing to see some magic happen :)
    &lt;/p&gt;

&lt;/div&gt;

&lt;button (click)=""toggle()""&gt;Toggle&lt;/button&gt;

&lt;!-- Doesn't change --&gt;
&lt;div style=""margin:1rem;""&gt;
    Doesn't change here
    &lt;span style=""color:red;""&gt;Value is {{wait | async}}&lt;/span&gt;
  (AppComponent)
&lt;/div&gt;
</code></pre>

<p><strong>app.component.ts</strong></p>

<pre><code>@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  name: string = 'Angular 5';
  wait: Observable&lt;boolean&gt;;

  constructor(public waitService: WaitService) {
    this.wait = this.waitService.wait;
  }

  toggle() {
    this.waitService.toggle();
  }
}
</code></pre>

<p>wait.service.ts</p>

<pre><code>export class WaitService {
  wait: Observable&lt;boolean&gt;;
  private _wait: boolean = false;
  private _onChange: EventEmitter&lt;boolean&gt; = new EventEmitter();

  constructor() {
    this.wait = Observable.create((obs: any) =&gt; {
      obs.next(this._wait);
      this._onChange.subscribe((w: boolean) =&gt; {
        if (this._wait !== w) {
          this._wait = w;
          obs.next(this._wait);
        }
      });
    });
  }

  toggle() {
    this._onChange.emit(!this._wait);
  }
}
</code></pre>

<p>I have WaitService with <strong>wait</strong> property and method <strong>toggle</strong> for switching wait.
When I try toggle <strong>wait</strong>, it works in one case, but doesn't work for each others (as I expected).</p>

<p>So, It confused me.
I will try figure out, why it happens.</p>

<p>Example: <a href=""https://stackblitz.com/edit/angular-fwghfj"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-fwghfj</a></p>

<p>If you click on Toggle button nothing happen with wait message, but subscription in <a href=""https://stackblitz.com/edit/angular-fwghfj?file=app%2Fwait2.component.ts"" rel=""nofollow noreferrer"">Wait2Component</a> will be emitted and and will be write to console output each time when you clicked on toggle.</p>

<p>But after commented line with subscription, show and hide wait message will be work ok, but in other places <strong>wait</strong> still have no change.</p>

<p>Sure I can change <strong>wait</strong> to boolean and don't care about this situation with <strong>async</strong>, but this unexpected behavior for me.</p>
","6638945","","","","","2017-11-16 13:32:47","Confused behavior with async pipe (Angular)","<angular><typescript><rxjs><rxjs5><angular5>","3","0","1","","","CC BY-SA 3.0"
"47329463","2","","47328638","2017-11-16 12:17:04","","3","","<p>You can write WaitService like this instead:</p>

<pre class=""lang-ts prettyprint-override""><code>import { Injectable } from ""@angular/core"";
import { BehaviorSubject } from ""rxjs/BehaviorSubject"";

@Injectable()
export class WaitService
{
    private readonly isWaiting = new BehaviorSubject(false);
    public readonly wait$ = this.isWaiting.asObservable();
    public toggle()
    {
        this.isWaiting.next(!this.isWaiting.value);
    }
}
</code></pre>
","3449808","","","","","2017-11-16 12:17:04","","","","0","","","","CC BY-SA 3.0"
"47346125","1","","","2017-11-17 08:18:38","","0","1980","<p>Can someone tell me what's wrong with this code?</p>

<pre><code>const field = document.querySelector('.form-field');
const showHistoryButton = document.querySelector('#show-history');
const historyPanel = document.querySelector('#history');

const showHistory$ = Rx.Observable.fromEvent(showHistoryButton, 'click');

Rx.Observable.fromEvent(field, 'keyup')
    .debounceTime(200)
    .pluck('target', 'value')
    .filter(R.compose(R.not, R.isEmpty))
    .bufferWhen(() =&gt; showHistory$)
    .do(history =&gt; history.pop())
    .subscribe(history =&gt; {
        let contents = '';
        if(history.length &gt; 0) {
            for(let item of history) {
                contents += '&lt;li&gt;' + item + '&lt;/li&gt;';
            }
            historyPanel.innerHTML = contents;
        }
    });
</code></pre>

<p>The error I get is:</p>

<pre><code>rxjs.5.5.2.js:3895 Uncaught TypeError: Invalid event target
    at Function.FromEventObservable.setupSubscription (rxjs.5.5.2.js:3895)
    at FromEventObservable._subscribe (rxjs.5.5.2.js:3917)
    at FromEventObservable.Observable._trySubscribe (rxjs.5.5.2.js:825)
    at FromEventObservable.Observable.subscribe (rxjs.5.5.2.js:813)
    at subscribeToResult (rxjs.5.5.2.js:2065)
    at BufferWhenSubscriber.openBuffer (rxjs.5.5.2.js:7489)
    at new BufferWhenSubscriber (rxjs.5.5.2.js:7442)
    at BufferWhenOperator.call (rxjs.5.5.2.js:7427)
    at Observable.subscribe (rxjs.5.5.2.js:810)
    at DoOperator.call (rxjs.5.5.2.js:9862)
</code></pre>

<p>And when I uncommented pieces of code, it looks like the culprit is <code>subscribe</code> method even when it's empty. I am using RxJS 5.5.2 and the only dependency is Ramda.</p>
","2308847","","","","","2017-11-17 08:18:38","Uncaught TypeError: Invalid event target in RxJS subscribe block","<rxjs><rxjs5>","0","3","","","","CC BY-SA 3.0"
"47355666","1","47563617","","2017-11-17 16:54:44","","9","5323","<p>Before lettable operator, I did a helper to modify debounceTime method, so it uses a TestScheduler:</p>

<pre><code>export function mockDebounceTime(
    scheduler: TestScheduler,
    overrideTime: number,
): void {
    const originalDebounce = Observable.prototype.debounceTime;

    spyOn(Observable.prototype, 'debounceTime').and.callFake(function(
        time: number,
    ): void {
        return originalDebounce.call(
            this,
            overrideTime,
            scheduler,
        );
    });
}
</code></pre>

<p>So the test of the following Observable was easy:</p>

<pre><code>@Effect()
public filterUpdated$ = this.actions$
    .ofType(UPDATE_FILTERS)
    .debounceTime(DEFAULT_DEBOUNCE_TIME)
    .mergeMap(action =&gt; [...])
</code></pre>

<p>With lettable operators, the filterUpdated$ Observable is written like that:</p>

<pre><code>@Effect()
public filterUpdated$ = this.actions$
    .ofType(UPDATE_FILTERS)
    .pipe(
        debounceTime(DEFAULT_DEBOUNCE_TIME),
        mergeMap(action =&gt; [...])
    );
</code></pre>

<p>I cannot patch the debounceTime operator anymore ! How can I pass the testScheduler to the debounceTime operator ?</p>
","7391842","","431941","","2018-12-05 18:35:29","2018-12-05 18:35:29","Testing and mocking lettable operators in RxJS 5.5","<typescript><rxjs5><ngrx-effects>","5","5","2","","","CC BY-SA 3.0"
"47357148","2","","47306281","2017-11-17 18:34:54","","4","","<p>The issue is not 100% clear without something like a jsbin to see what you mean, but I do see some general issues that might help:</p>

<h3>Anonymous Observable never completes</h3>

<p>When creating a custom anonymous Observable it's important to call <code>observer.complete()</code> if you do indeed want it to complete. In most cases, not doing so will cause the subscription to be a memory leak and might also other strange behaviors</p>

<pre><code>Observable.create((observer) =&gt; {
  observer.next({ type: type, value: action.value, form: action.form });
  observer.complete();
})
</code></pre>

<p><code>Observable.of</code> would have been equivalent:</p>

<pre><code>Observable.of({ type: type, value: action.value, form: action.form })
</code></pre>

<p>However, it's not clear why this was done as the values it emits are in captured in scope.</p>

<h3><code>debounceTime</code> in this case does not debounce, it delays</h3>

<p>Since the anonymous observable it's applied to only ever emits a single item, <code>debounceTime</code> will act just as a regular <code>.delay(250)</code>. I'm betting you intended instead to debounce <code>actions.requestType</code> actions, in which case you'd need to apply your debouncing outside the <code>switchMap</code>, after the <code>action$.ofType(actions.requestType)</code>.</p>

<h3><code>Observable.of</code> accepts any number of arguments to emit</h3>

<p>This is more of a ""did you know?"" rather than an issue, but I noticed you're merging your <code>of</code> and <code>/* some other actions */</code> I assume would be other <code>of</code> observables merged in. Instead, you can just return a single <code>of</code> and pass the actions as arguments.</p>

<pre><code>Observable.of(
  actions.success(payload),
  /* some other actions */
  actions.someOtherOne(),
  actions.etc()
);
</code></pre>

<p>Also, when you find yourself emitting multiple actions synchronously like this, consider whether your reducers should be listening for the same, single action instead of having two or more. Sometimes this wouldn't make sense as you want them to have completely unrelated actions, just something to keep in mind that people often forget--that all reducers receive all actions and so multiple reducers can change their state from the same action.</p>

<h3><code>.takeUntil</code> will stop the epic from listening for future actions</h3>

<p>Placing the <code>takeUntil</code> on the top-level observable chain causes the epic to stop listening for <code>action$.ofType(actions.requestType)</code>, which is why you added the <code>.repeat()</code> after. This might work in some cases, but it's inefficient and can cause other hard to realize bugs. Epics should be thought of instead as sort of like sidecar processes that usually ""start up"" with the app and then continue listening for a particular action until the app ""shuts down"" aka the user leaves the app. They aren't <em>actually</em> processes, it's just helpful to conceptually think of them this way as an abstraction.</p>

<p>So each time it matches its particular action it then most often will <code>switchMap</code>, <code>mergeMap</code>, <code>concatMap</code>, or <code>exhaustMap</code> into some side effect, like an ajax call. That <em>inner observable chain</em> is what you want to make cancellable. So you'd place your <code>.takeUntil</code> on it, at the appropriate place in the chain.</p>

<hr>

<h2>Summary</h2>

<p>As mentioned, it's not clear what you intended to do and what the issue is, without a more complete example like a jsbin. But strictly based on the code provided, this is my guesstimate:</p>

<pre><code>const someRequestEpic = action$ =&gt; {
  return action$.ofType(actions.requestType)
    .debounceTime(250)
    .do(() =&gt; console.log('handled epic ' + actions.requestType))
    .switchMap((action) =&gt;
      Observable.ajax(ajaxPost(url(action.value), body ? body(action.value) : action.form))
        .takeUntil(action$.ofType(masterCancelAction))
        .mergeMap(payload =&gt; {
          return Observable.of(
            actions.success(payload),
            /* some other actions */
            ...etc
          );
        })
        .catch(payload =&gt; Observable.of(
          actions.failure(payload)
        ))
    );
};
</code></pre>

<p>Check out the <a href=""https://redux-observable.js.org/docs/recipes/Cancellation.html"" rel=""nofollow noreferrer"">Cancellation</a> page in the redux-observable docs.</p>

<hr>

<p>If this is a bit confusing, I'd recommend digging a bit deeper into what Observables are and what an ""operator"" is and does so that it doesn't feel magical and where you should place an operator makes more sense.</p>

<p>Ben's post on <a href=""https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87"" rel=""nofollow noreferrer"">Learning Observable by Building Observable</a> is a good start.</p>
","1770633","","","","","2017-11-17 18:34:54","","","","1","","","","CC BY-SA 3.0"
"47362525","1","","","2017-11-18 04:33:38","","0","43","<p>Given a list of inputs in an array I want to run a sync tasks that returns an observable. But I need these tasks to run consecutively not in parallel. As you can see below all the tasks are started at the same time. </p>

<p>My second question is how to accumulate the results of each iteration of fakeAsyncWork in a array to be returned at the end. Clearly my scan in at the wrong place at the moment. </p>

<p>Here is jsbin: <a href=""http://jsbin.com/kujilow/15/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/kujilow/15/edit?js,console</a></p>

<pre><code>const source$ = Rx.Observable.of(1,2,3,4)

const job$ = source$
  .do(x=&gt;console.log(""emitted from source "" + x))
   .switchMap(n =&gt; fakeAsyncWork(n))
  .do(x=&gt;console.log(""emitted from switch "" + x))
  .scan((a,c) =&gt; a.concat(c), [])


let fakeAsyncWork = (sec): Rx.Observable&lt;any&gt; =&gt; {
  return  new Rx.Observable(observer =&gt; {
          console.log(""start waiting for "" + sec);
          setTimeout(() =&gt; {
                console.log(""finish waiting "" + sec);
                observer.next(sec*10)
            }, sec*1000);

  });
}

job$.subscribe(x =&gt; console.log(x) );
</code></pre>

<p>Current results:</p>

<pre><code>""emitted from source 1""
""start waiting for 1""
""emitted from source 2""
""start waiting for 2""
""emitted from source 3""
""start waiting for 3""
""emitted from source 4""
""start waiting for 4""
""finish waiting 1""
""finish waiting 2""
""finish waiting 3""
""finish waiting 4""
""emitted from switch 40""
[40]
</code></pre>

<p>Desired results: (Each task is finished before the next one is started)</p>

<pre><code>""emitted from source 1""
""start waiting for 1""
""finish waiting 1""
""emitted from source 2""
""start waiting for 2""
""finish waiting 2""
""emitted from source 3""
""start waiting for 3""
""finish waiting 3""
""emitted from source 4""
""start waiting for 4""
""finish waiting 4""
""emitted from switch [10,20,30,40]""
[10,20,30,40]
</code></pre>

<p>Cheers :=)</p>
","705945","","705945","","2017-11-18 09:32:24","2017-11-18 09:32:24","How to run a number of Observables in series","<javascript><typescript><observable><rxjs5>","0","4","","","","CC BY-SA 3.0"
"47365114","1","47370993","","2017-11-18 10:40:20","","4","2352","<p>I am developing an app using Nodejs, RxJS and Typescript.</p>

<p>The app has a function which returns an Observable of a string</p>

<pre><code>myObsFunction() : Observable&lt;string&gt; {
... do stuff
}
</code></pre>

<p>I would like to be able to make a simple test to check that when I subscribe to this function I get the expected string. I am using <strong>chai</strong> and <strong>mocha</strong> and so I write the following test case</p>

<pre><code>import { expect } from 'chai';
import 'mocha';

import {myObsFunction} from './my-source-file';

describe('myObsFunction function', () =&gt; {

    it('check myObsFunction', () =&gt; {
        const expectedString = 'abc';
        let receivedString: string;
        myObsFunction().subscribe(
            data =&gt; receivedString = data,
            error =&gt; console.error(error),
            () =&gt; expect(receivedString).to.equal(expectedString)
        )
    });

});
</code></pre>

<p>Unfortunately this test case does not work as expected by me. It always behaves as it has been successfully passed even in case of errors. The <code>expect</code> check which I have written in the <code>onCompleted</code> function does not signal anything even when the expectedString is not equal the the receivedString. The <code>onCompleted</code> function is actually executed (I can see this just adding a <code>console.log</code> instruction in the <code>onCompleted</code> function) but the expect does not signal any error when there are errors</p>

<p>Is there any way to run such simple tests without having to start using Schedulers and more complex mechanisms?</p>
","5699993","","","","","2017-11-18 22:04:33","Simple tests of Observable results in nodejs with chai and mocha","<node.js><testing><mocha.js><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"47370993","2","","47365114","2017-11-18 21:00:24","","4","","<p>The test logic looks sound, here's a working example with mocha and chai.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>console.clear() 
const Observable = Rx.Observable
mocha.setup('bdd');
const assert = chai.assert;
const should = chai.should();
const expect = chai.expect;
const done = mocha.done;


const myObsFunction = () =&gt; Observable.of('xyz');
const myAsyncObsFunction = () =&gt; Observable.timer(500).mapTo('xyz');

describe('RxJs Observable Test Examples', function() {

  it('should test the observable succeeds', function () {
    const expectedString = 'xyz';
    let receivedString: string;
    myObsFunction().subscribe(
      data =&gt; receivedString = data,
      error =&gt; console.error(error),
      () =&gt; {
        expect(receivedString).to.equal(expectedString);
      }  
    )
  });

  it('should test the observable fails', function () {
    const expectedString = 'abc';
    let receivedString: string;
    myObsFunction().subscribe(
      data =&gt; receivedString = data,
      error =&gt; console.error(error),
      () =&gt; {
        expect(receivedString).to.equal(expectedString);
      }  
    )
  });

  it('should test the async observable succeeds', function (done) {
    const expectedString = 'xyz';
    let receivedString: string;
    myAsyncObsFunction().subscribe(
      data =&gt; receivedString = data,
      error =&gt; console.error(error),
      () =&gt; {
        //expect(receivedString).to.equal(expectedString);
        if (receivedString !== expectedString) {
          return done(new Error(""Failed match""));
        } else {
          return done();
        }
      }  
    )
  });

  it('should test the async observable fails', function (done) {
    const expectedString = 'abc';
    let receivedString: string;
    myAsyncObsFunction().subscribe(
      data =&gt; receivedString = data,
      error =&gt; console.error(error),
      () =&gt; {
        //expect(receivedString).to.equal(expectedString);
        if (receivedString !== expectedString) {
          return done(new Error(""Failed match""));
        } else {
          return done();
        }
      }  
    )
  });
});

mocha.run();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;link href=""https://cdnjs.cloudflare.com/ajax/libs/mocha/2.3.4/mocha.min.css"" rel=""stylesheet""/&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/mocha/2.3.4/mocha.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.2/Rx.js""&gt;&lt;/script&gt;
&lt;div id=""mocha""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p><br/>
<strong>False positives when the observable never fires</strong>  </p>

<p>One thing I came across was false positives if the observable never fires. Here's some helper functions I use to overcome that problem. Note that <code>take(1)</code> ensures the completed event is fired, even if the observable does not itself complete.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>console.clear() 
const Observable = Rx.Observable
mocha.setup('bdd');
const assert = chai.assert;
const should = chai.should();
const expect = chai.expect;

const subscribeAndTestValue = function (observable: Observable&lt;any&gt;, expected: any): string {
  let fail = '';
  let wasSubscribed = false;
  const sub = observable
    .take(1)
    .subscribe(
      (result) =&gt; {
        if (result !== expected) {
          fail = 'Subscription result does not match expected value';
        }
        wasSubscribed = true;
      },
      (error) =&gt; {
        fail = 'Subscription raised an error';
      },
      (/*completed*/) =&gt; {
        // When testing a single value,
        // need to check that the subscription was activated,
        // otherwise the expected value is never tested
        if (!wasSubscribed) {
          fail = 'Subscription produced no results';
        }
      }
    );
  sub.unsubscribe();
  return fail;
}

const subscribeAndTestNoDataEmitted = function (observable: Observable&lt;any&gt;): string {
  let fail;
  let wasSubscribed = false;
  const sub = observable
    .subscribe(
      (result) =&gt; {
        wasSubscribed = true;
      },
      (error) =&gt; {
        fail = 'Subscription raised an error';
      },
      (/*completed*/) =&gt; {
        if (wasSubscribed) {
          fail = 'Subscription produced values when none were expected';
        }
      }
    );
  sub.unsubscribe();
  return fail;
}

const emptyObservable = Observable.empty();
const nonCompletingObservable = Observable.interval(1000);
const emittingObservable = Observable.of('abc');

describe('RxJs Observable Test Examples', function() {

  it('should test the observable fires', function () {
    const expectedString = 'xyz';
    const failed = subscribeAndTestValue(emptyObservable, expectedString);
    expect(failed).to.equal('Subscription produced no results');
  });

  it('should test first observable value of a non-completing observable', function () {
    const expectedString = '0';
    const failed = subscribeAndTestValue(nonCompletingObservable, expectedString);
    expect(failed).to.equal('');
  });

  it('should test the observable does not fire', function () {
    const expectedString = 'xyz';
    const failed = subscribeAndTestNoDataEmitted(emittingObservable, expectedString);
    expect(failed).to.equal('Subscription produced values when none were expected');
  });
  
});

mocha.run();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;link href=""https://cdnjs.cloudflare.com/ajax/libs/mocha/2.3.4/mocha.min.css"" rel=""stylesheet""/&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/mocha/2.3.4/mocha.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.2/Rx.js""&gt;&lt;/script&gt;
&lt;div id=""mocha""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","4716245","","4716245","","2017-11-18 22:04:33","2017-11-18 22:04:33","","","","1","","","","CC BY-SA 3.0"
"47384776","1","47399571","","2017-11-20 03:42:12","","2","4400","<p>The following code works. It does an ajax request and then call 2 actions, on at a time:</p>

<pre><code>export const loadThingsEpic = action$ =&gt; {

  return action$.ofType(LOAD_THINGS)
    .mergeMap(({things}) =&gt; {
      const requestURL = `${AppConfig.serverUrl()}/data/things`;
      return ajax.getJSON(requestURL)).map(response =&gt; {
        return finishLoadingThings(response);
      }).map(() =&gt; {
        return sendNotification('success');
      });
    })
    .catch(e =&gt; {
      return concat(of(finishLoadingThings({ things: {} })),
                    of(sendNotification('error')));

    });   
}}
</code></pre>

<p>But this code does not:</p>

<pre><code>export const loadThingsEpic = action$ =&gt; {

  return action$.ofType(LOAD_THINGS)
    .mergeMap(({things}) =&gt; {
      const requestURL = `${AppConfig.serverUrl()}/data/things`;
      return ajax.getJSON(requestURL).switchMap(response =&gt; {
        return concat(of(finishLoadingThings(response)),
                      of(sendNotification('success')));
      });
    })
    .catch(e =&gt; {
      return concat(of(finishLoadingThings({ things: {} })),
                    of(sendNotification('error')));
    });   
}
</code></pre>

<p>I've replace the map by a switchMap to merge 2 actions together (as seen in many other post). It works in the catch if an exception is thrown. I'm wondering whats wrong with the code. I'm guessing it's because I can't seem to really grasp when to use: map, swicthMap and mergeMap.</p>

<p>sendNotification and finishLoadingthings returns action object:</p>

<pre><code>export function finishLoadingThings(data: any) {
  return {
    type: FINISH_LOADING_THINGS,
    data,
  };
}
</code></pre>

<p>Thanks!</p>
","978472","","1770633","","2017-11-20 19:11:53","2017-11-20 20:51:36","TypeError: You provided an invalid object where a stream was expected","<rxjs><rxjs5><redux-observable>","2","3","","","","CC BY-SA 3.0"
"47399571","2","","47384776","2017-11-20 19:24:15","","2","","<p>The code provided as-is appears to work as intended: <a href=""https://jsbin.com/becapin/edit?js,console"" rel=""nofollow noreferrer"">https://jsbin.com/becapin/edit?js,console</a> I do not receive a ""invalid object where stream expected"" error when the ajax succeeds or fails.</p>

<p>Are you sure the error is coming from this code?</p>

<hr>

<p>On a separate note, you might be happy to hear that <code>Observable.of</code> supports an arbitrary number of arguments, each one will be emitted after the other. So instead of this:</p>

<pre><code>.switchMap(response =&gt; {
  return concat(of(finishLoadingThings(response)),
                of(sendNotification('success')));
});
</code></pre>

<p>You can just do this:</p>

<pre><code>.switchMap(response =&gt; {
  return of(
    finishLoadingThings(response),
    sendNotification('success')
  );
});
</code></pre>

<p>This would not have caused a bug though, it's just cleaner.</p>
","1770633","","","","","2017-11-20 19:24:15","","","","1","","","","CC BY-SA 3.0"
"47411594","1","47411806","","2017-11-21 11:07:29","","10","11934","<p>I get this very annoying error when running my code from a unix environment. This works fine when I run the code locally through <code>ng serve</code>, But when I deploy the code to my server, this error halts all program execution:</p>

<blockquote>
  <p><code>ERROR TypeError: this.http.get(...).catch is not a function</code></p>
</blockquote>

<p>Google results state that I should import rxjs namespaces straight from their location, and not through the rxjs/Rx bundle, but I get this error regardless. Other results point out that I may have missed importing rxjs operators, but they are definitely included in my case. </p>

<p>I've even checked the included sourcemaps using DevTools, and the operators are included out to the browser.</p>

<p>Can anybody tell me why I'm getting this error? I'm using rxjs: ^5.5.2</p>

<p><strong>This is my code.</strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';

@Injectable()
export class MyService {
  constructor(private http: HttpClient) {}

  all(): Observable&lt;any&gt; {
    return this.http.get&lt;any&gt;('url')
      .catch(err =&gt; this.handleError(err));
  }
  handleError(error) {
    return Observable.throw(error);
  }
}
</code></pre>

<p><strong>EDIT</strong>
Based on @Jota.Toledo's comment below, I will provide the code using this method:</p>

<pre><code>this.myService.all().subscribe(
  result =&gt; {
    this.isLoading = false;
    if (result) {
      this.clients = result;
    }
  },
  error =&gt; this.isLoading = false
);
</code></pre>

<p>Is giving two callback functions in subscribe like this, the same as ""using the catch method somewhere before the operator is added""?</p>
","1119364","","1119364","","2017-11-21 17:00:56","2017-11-21 17:00:56","Observable .catch is not a function","<angular><rxjs><observable><rxjs5>","1","4","3","","","CC BY-SA 3.0"
"47411806","2","","47411594","2017-11-21 11:18:44","","14","","<p>In <code>rxjs 5.5.2</code> you can solve this problem using lettable operator, in this case, <code>catchError</code>. You have to import it from <code>operators</code> like: <code>import { catchError } from 'rxjs/operators/catchError';</code>. In general, all operators must be imported in this way, same thing goes for <code>observable</code> like <code>observable/of</code>.</p>

<pre><code>import { catchError } from 'rxjs/operators/catchError';
import { map } from 'rxjs/operators/map';

all(): Observable&lt;any&gt; {
  return this.http.get&lt;any&gt;('url')
    .pipe(
        map(() =&gt; //do stuff),
        catchError((error: Error) =&gt; {
         //
        })
    )
}
</code></pre>

<p>Read more about lettable operators <a href=""https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3?gi=2933859fdd18"" rel=""noreferrer"">here</a>.</p>
","4684539","","4684539","","2017-11-21 12:56:42","2017-11-21 12:56:42","","","","2","","","","CC BY-SA 3.0"
"47429079","1","","","2017-11-22 07:32:56","","0","353","<p>I have been struggling to get nested recursive observable chains right. The requirement is to right a utility that would fetch parent-child (master-detail) records based on a configuration similar to the following.</p>

<pre class=""lang-js prettyprint-override""><code>  ""ParentEntity"": {
    ""table"": ""table_master"",              
    ""details"": {
      ""detail1"": {
        ""table"": ""tbl_detail1""
      },
      ""detail2"": {
        ""table"": ""tbl_detail2""
            ""details"": {
                ""detail21"": { 
                ""table"": ""tbl_detail21""
              }
            }
      },
      ""detail3"": {
        ""table"": ""tbl_detail3""
      }
    }
  }
</code></pre>

<p>Here is the sample scenario code.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function trace(output) {
  var newDiv = document.createElement(""div"");
  var newContent = document.createTextNode(JSON.stringify(output));
  newDiv.appendChild(newContent);
  element = document.getElementById(""result"");
  element.appendChild(newDiv);
}

var propertiesWithDetails = {
  ""b"": ""b"",
  ""d"": ""d""
};

var firstLevelResultList = [{
  ""a"": ""a"",
  ""b"": ""b"",
  ""c"": ""c"",
  ""d"": ""d""
}, {
  ""a"": ""a1"",
  ""b"": ""b1"",
  ""c"": ""c1"",
  ""d"": ""d1""
}];


function getResultObservable(prop) { // just creating some dummy details record.

  return Rx.Observable.of({
    ""details"": prop
  }).delay(Math.floor((Math.random() * 1000) + 1));
}


function runCodeWithDo() {
  Rx.Observable.of(firstLevelResultList).do(result =&gt; {
    result.forEach(record =&gt; {
      Object.keys(propertiesWithDetails).map((prop) =&gt; {

        getResultObservable(prop).do(childData =&gt; {

          record[prop] = childData;
        })
      })

    });
  }).subscribe(output =&gt; {

    trace(output);
  });

}


function runCodeWithFlatMapAndForkJoin() { //this is recursive in actual code

  return Rx.Observable.of(firstLevelResultList).flatMap(result =&gt; {

    if (result != null &amp;&amp; result.length &gt; 0 &amp;&amp; propertiesWithDetails != null) {
      for (let i = 0; i &lt; result.length; i++) { //tried forkJoin around this, ended up in some error
        let record = result[i];
        return Rx.Observable.forkJoin(
          Object.keys(propertiesWithDetails).map((prop) =&gt; {
            return getResultObservable(prop).map(childData =&gt; {
              record[prop] = childData;
            })
          })
        ).map((res) =&gt; {
          return record
        })

      }
    } else return Rx.Observable.of(result);
  });

}

var expectedResult = [{
  ""a"": ""a"",
  ""b"": {
    ""details"": ""b""
  },
  ""c"": ""c"",
  ""d"": {
    ""details"": ""d""
  }
}, {
  ""a"": ""a1"",
  ""b"": {
    ""details"": ""b""
  },
  ""c"": ""c1"",
  ""d"": {
    ""details"": ""d""
  }
}];

trace(""expected result is: "" + JSON.stringify(expectedResult));
trace(""..........."");
runCodeWithDo();

trace("" only the first level records listed, detail data not fetched "");
trace(""................."");
runCodeWithFlatMapAndForkJoin().subscribe(result =&gt; {
  trace(""..............."");
  trace(result);
  trace("" only one of the parents records returned ! "");
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!doctype html&gt;

&lt;html lang=""en""&gt;

&lt;head&gt;
  &lt;meta charset=""utf-8""&gt;

  &lt;title&gt;Indeterminate recursive child observables (parent child) &lt;/title&gt;
  &lt;meta name=""description"" content=""recursive child observables""&gt;
  &lt;meta name=""author"" content=""SitePoint""&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p&gt; Indeterminate recursive child observables &lt;/p&gt;
  &lt;div id=""result""&gt;&lt;/div&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.js""&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>Basically the utility executes select * from  (sqlite) and constructs the output data structure based on the hierarchy in the configuration. The executeSql statements executions are wrapped in an observable (i.e. result is an observable containing an array).
I tried my best using Observable.flatMap, forkJoin, do, switchMap etc. But failed to get it right.</p>

<p>Appreciate any help to solve this.</p>

<p>RxJS version: 5.4.2
The  utility is being used in an ionic 3/Angular 4 mobile app.</p>
","8978659","","8978659","","2017-11-26 12:00:22","2017-11-26 12:30:25","RxJS indeterminate master details recursive observables","<javascript><rxjs><observable><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47438974","1","","","2017-11-22 15:56:49","","0","816","<p><strong>OVERVIEW</strong></p>

<p>Were following the container -> component pattern and using ngrx for centralizing our applications state.  </p>

<p>The app structure is something such as:</p>

<pre><code>Container
   Child_Comp_1
      Child_Comp_2
         Child_Comp_3
</code></pre>

<p>Originally, there was a single observable of the data subscribed to at the Container, then the relative data passed as inputs to child components.  such as</p>

<pre><code>Observable&lt;
 {
   data,
   collection: []
 }&gt; 
</code></pre>

<p>However, any update triggered the ngrx selector and caused a AngularJS re-rendering down the chain of components.</p>

<p>We moved to serving up observables of observables, </p>

<pre><code>Observable&lt; 
 {
  data: Observable&lt;data&gt;
  collection: Observable&lt;Observable&lt;Item&gt;[]&gt;
 }&gt;
</code></pre>

<p>We can now use RxJs functions such as DistinctUntilChanged(predicate) to specify when a subscription in a component is actually triggered.</p>

<p>And use ChangeDetection.markForCheck() which will limit where the re-rendering occurs</p>

<p><strong>PROBLEM &amp; QUESTION</strong></p>

<p>There are two problems</p>

<ol>
<li>Taking our array of Observable - Whats the best way to compare the values of two Observables to see if any changed </li>
</ol>

<p>example:<br>
<code>collection.distinctUntilChanged((a, b) =&gt; ?? compare values of a b ??)</code></p>

<ol start=""2"">
<li>Working with Observables of Observables so that different child components can define the criteria of when a subscription is triggered makes other areas more difficult. Is there a better approach?</li>
</ol>

<p><strong>Example:</strong></p>

<p>Child Comp</p>

<pre><code>  collection
   .distinctUntilChanged((a, b) =&gt; a.length === b.length)
   .subscribe(items =&gt; ....)  // only fired if length changed
</code></pre>
","4226980","","5535245","","2017-11-22 20:10:41","2017-11-22 20:10:41","How to compare Observables: NGRX and Working with Observables of Observables for efficient Angular 4 Rendering","<javascript><angular><rxjs><rxjs5><ngrx>","1","5","","","","CC BY-SA 3.0"
"47439414","1","","","2017-11-22 16:19:27","","3","1297","<p>RxJS how to get specific attribute values from nested array of objects</p>

<pre><code>const obj = {
      name: 'campus',
      buildings: [
        {
          name: 'building',
          floors: [
            {
              name: 'floor'
            }
          ]
        }
      ]
    };
</code></pre>

<p>Is there a way to get names in RxJS. Basically I need output as [campus, building, floor]</p>

<pre><code>Observable.of(obj).map((res) =&gt; res.name).subscribe((val) =&gt; console.log(val));
</code></pre>

<p>I know how to do this without using RxJS. But I would like to know how to do using RxJS.
Thanks in advance</p>

<p>Currently I'm doing something like below</p>

<pre><code>const names = [];
    names.push(obj.name);
    obj.buildings.forEach((building) =&gt; {
      names.push(building.name);
      building.floors.forEach((floor) =&gt; {
        names.push(floor.name);
      });
    });
    console.log(names);
</code></pre>
","2742156","","2742156","","2017-11-22 16:33:16","2017-11-22 17:52:35","Rxjs loop through nested object","<angular><typescript><rxjs><rxjs5>","1","6","","","","CC BY-SA 3.0"
"47450639","1","47451321","","2017-11-23 08:21:27","","7","4351","<p>When I subscribe to getAllSubModules forkJoin executes all those observables without error but does not complete. I know forkJoin completes only after all its observables completed but as a proof I see '-----' 3 times in console which confirm everything is successful so all its observables completed.</p>

<pre><code> getSubmodules(id): Observable&lt;any&gt; {
    return this.authService.getToken()
      .flatMap((token) =&gt; this.http.get(`${this.URL}/ROS/applications/modules/${id}/subModules?token=${token}`))
      .map((res: any) =&gt; res.data.map((subModule) =&gt; this.mapSubModules(subModule)));
  }
  getAllSubmodules(): Observable&lt;any&gt; {
    const tasks = [];
    this.modules.forEach((module: AppModule) =&gt; {
      const obs = this.getSubmodules(module.id).map((subModules) =&gt; {
        this.allSubModules[module.id] = subModules;
        console.log('--------------------');
      });
      tasks.push(obs);
    });
    return Observable.forkJoin(...tasks).retry(2);
  }
  mapSubModules(moduleData) {
    if (moduleData.id) {
      const subModule = &lt;SubModule&gt; {
        id: moduleData.id,
        parentId: moduleData.parentId,
        typeId: moduleData.typeId,
        name: moduleData.name.az,
        active: true
      };
      return subModule;
    }
  }
</code></pre>

<p>This code is not executed when using <strong>forkJoin</strong>:</p>

<pre><code> this.universityService.getAllSubmodules().subscribe(() =&gt; {             
        // --- Below is not executed!--
        console.log('subModules in Report Co');
        console.log(this.universityService.allSubModules);
        this.checkUrl();
        this.showChild = true;
      }, (er) =&gt; console.log(er));
</code></pre>

<p>but when I use <strong>combineLatest</strong> instead of forkJoin it works as expected.
 So what is problem?Hope someone give advice.</p>
","7943893","","7943893","","2017-11-23 08:26:45","2017-11-23 09:00:10","RxJS forkJoin does not complete","<angular><rxjs><rxjs5>","1","1","2","","","CC BY-SA 3.0"
"47451321","2","","47450639","2017-11-23 09:00:10","","6","","<p>Your expectation is incorrect. Having <code>console.log('--------------------')</code> emitted 3 times only means that you have received 3 <code>onNext</code> events. <code>forkJoin</code> waits for all observables to complete. </p>

<p>Try what happens if you look at the individual streams with <code>.do(next=&gt;{},err=&gt;{},complete =&gt; console.log('completed'))</code> or explicitly define when your streams should complete using <code>.take(1)</code> and/or <code>.timeout(1000)</code>.</p>

<p>Does <code>authService..getToken()</code> complete after emitting one value?</p>
","106909","","","","","2017-11-23 09:00:10","","","","1","","","","CC BY-SA 3.0"
"47482610","1","47482996","","2017-11-25 04:27:25","","2","1500","<p>I am trying to set up an observable that currently receives an array of location IDs and then makes a get request for all of these at once and waits for the response for them all. Here is a sample:</p>

<pre><code>const fetchPhotosEpic = action$ =&gt;
    action$.ofType(LOCATIONS_RECEIVED)
    .map(action =&gt; action.payload)
    .mergeMap((data) =&gt;  {
        let promiseArray = data.map(location =&gt; Observable.fromPromise(axios.get(photosUrl(location.id))))
        return Observable.forkJoin(
           promiseArray
        )
    })
    .map(responses =&gt; responses.map((response) =&gt; response.data.location))
</code></pre>

<p>Where data looks like:</p>

<pre><code>[
    {
        id: ""aoeuaeu"",
        name: ""Test""
    },
  ...
]
</code></pre>

<p>The issue I have right now is I get a 404 on one of the requests and it's messing everything up. I am probably doing something wrong as I am just learning RX. Any help would be great!</p>
","2433617","","","","","2017-11-25 05:58:00","RX.JS Redux Observable Multiple Get requests at same time","<javascript><rxjs><rxjs5><redux-observable>","1","2","","","","CC BY-SA 3.0"
"47482996","2","","47482610","2017-11-25 05:44:18","","4","","<p>You can try adding a catch to each call and returning a new observable with the error message, which should stop the forkJoin failing if one request fails. You can then either filter out the failures, or add logic to handle them in your final .map. eg.</p>

<pre><code>const fetchPhotosEpic = action$ =&gt;
    action$.ofType(LOCATIONS_RECEIVED)
    .map(action =&gt; action.payload)
    .mergeMap((data) =&gt; {
        let promiseArray = data.map(location =&gt; {
            return Observable.fromPromise(axios.get(photosUrl(location.id)))
                .catch(error =&gt; Observable.of({error}))
      })
      return Observable.forkJoin(
          promiseArray
      )
  })
 .filter(response =&gt; !Boolean(response.error))
 .map(responses =&gt; responses.map((response) =&gt; response.data.location))
</code></pre>
","2950969","","2950969","","2017-11-25 05:58:00","2017-11-25 05:58:00","","","","1","","","","CC BY-SA 3.0"
"47501522","1","47504566","","2017-11-26 22:08:04","","4","320","<p>Following <a href=""https://stackoverflow.com/questions/46602541/rxjs-lossy-form-of-zip-operator"">this</a> post I've decided to write a <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md"" rel=""nofollow noreferrer"">marble test</a> for this operator. </p>

<p>Here is a basic test:</p>

<pre><code>  it('Test lossy zip', () =&gt; {

    const a = hot('a---a--------a-');
    const b = hot('--b----b---b---');

    const observable = zip(
      a.pipe(take(1)),
      b.pipe(take(1))
    ).pipe(
      mergeMapTo(from(['1'])),
      repeat()
    );
    const expected = cold('--1----1-----1-');
    expect(observable).toBeObservable(expected);
  });
</code></pre>

<p>This test passes as expected. However, when I decide to fire two emissions, like this, it fails:</p>

<pre><code>const a = hot('a---a--------a-');
const b = hot('--b----b---b---');

const observable = zip(
  a.pipe(take(1)),
  b.pipe(take(1))
).pipe(
  mergeMapTo(from(['1', '2'])), //Here, emitting two items instead of one
  repeat()
);
</code></pre>

<p>I would expect the resulting observable to look like this:</p>

<pre><code>const expected = cold('--(12)----(12)-----(12)-');
</code></pre>

<p>Or at least like this:</p>

<pre><code>const expected = cold('--12---12----12-');
</code></pre>

<p>However both of them fail.</p>

<p>Is it a bug in <code>jasmine-marbles</code> or my expectations are wrong?</p>
","1544364","","","","","2017-11-27 05:40:10","RxJs - lossy zip marble testing","<javascript><jasmine><rxjs><rxjs5><jasmine-marbles>","1","4","","","","CC BY-SA 3.0"
"47503668","1","47521005","","2017-11-27 03:45:59","","1","749","<p>I am using RxJS and redux-observable.</p>

<p>I am trying to read file in epic. In my case, I have to do it in epic, because some other epic trigger this epic multiple ""unknown"" times by <code>expand</code> operator.</p>

<p>But since FileReader is async, the code below does not work.</p>

<p>What is the correct way especially RxJS way to handle this? Thanks</p>

<pre><code>export const uploadAttachmentEpic = (action$, store) =&gt;
  action$
    .ofType(UPLOAD_ATTACHMENT)
    .map(action =&gt; {
      const reader = new FileReader();

      reader.onload = () =&gt; {
        return {
          ...action,
          payload: {
            ...action.payload,
            base64: reader.result
          }
        }
      };

      reader.readAsDataURL(action.payload.file);
    })
    .mergeMap(action =&gt;
      ajax
        .post( /* use action.payload.base64 */ )
        .map(uploadAttachmentSucceed)
        .catch(uploadAttachmentFailed)
    );
</code></pre>
","2000548","","2000548","","2017-11-27 05:30:01","2017-11-27 22:41:12","How to handle async function in redux-observable?","<javascript><redux><rxjs><rxjs5><redux-observable>","2","2","","","","CC BY-SA 3.0"
"47504566","2","","47501522","2017-11-27 05:40:10","","2","","<p>Apparently, according to the official <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md"" rel=""nofollow noreferrer"">documentation</a> (which I haven't read thoroughly enough) parentheses as well as content of the group take up the relevant amount of frames:</p>

<blockquote>
  <p><code>'--(abc)-|'</code>: on frame 20, emit <code>a</code>, <code>b</code>, and <code>c</code>, then on frame 80
  <code>complete</code></p>
</blockquote>

<p>And this means a working test for group emission would look like this:</p>

<pre><code>  it('Should emit a grouped value', () =&gt; {

    const a = hot('a------a---------a---');
    const b = hot('--b-------b----b-----');

    const observable = zip(
      a.pipe(take(1)),
      b.pipe(take(1))
    ).pipe(
      mergeMapTo(from(['1', '2'])),
      repeat()
    );

    const expected = cold('--(12)----(12)---(12)');
    expect(observable).toBeObservable(expected);
  });
</code></pre>
","1544364","","","","","2017-11-27 05:40:10","","","","0","","","","CC BY-SA 3.0"
"47506376","1","47544744","","2017-11-27 08:13:30","","2","2089","<p>I am using redux-observable.</p>

<p>I am trying to send mail after all attachments be uploaded separately.</p>

<p>The process of this send mail API is</p>

<ol>
<li>Add mail content to the draft</li>
<li>Add attachments separately to the draft</li>
<li>Once all attachments are uploaded, send mail from draft</li>
</ol>

<p>Right now the code below can upload all attachments separately successfully. However, I don't know how to wait them all done.</p>

<p>After learning <a href=""https://www.learnrxjs.io/operators/combination/forkjoin.html"" rel=""nofollow noreferrer"">this doc</a>, I think I need use <code>forkJoin</code>, however I didn't figure out how to use it correctly in this case.</p>

<pre><code>export const addMailContentSucceedEpic = (action$, store) =&gt;
  action$
    .ofType(ADD_MAIL_CONTENT_SUCCEED)
    .expand(action =&gt; {     // expand here helps upload all attachments separately
      const restAttachments = removeFirstAttachment(action.payload.attachments);

      if (isEmpty(restAttachments)) return Observable.empty();

      return Observable.of({
        ...action,
        payload: {
          ...action.payload,
          attachments: restAttachments
        }
      });
    })
    .map(action =&gt; addAttachment({ mailId: action.payload.mailId, attachment: first(action.payload.attachments) }));

export const addAttachmentEpic = (action$, store) =&gt;
  action$
    .ofType(ADD_ATTACHMENT)
    .mergeMap(action =&gt; getBase64FromFile(action))
    .mergeMap(action =&gt;
      ajax
        .patch(url, { base64: action.payload.base64 })
        .map(() =&gt; addAttachmentSucceed({ mailId: action.payload.mailId }))
        .catch(addAttachmentFailed)
    );

export const addAttachmentSucceedEpic = (action$, store) =&gt;
  action$
    .ofType(ADD_ATTACHMENT_SUCCEED)
    // Here is wrong, I need wait all attachments be uploaded
    // I tried to add a global `let = tasks$[];` on the top, but I am not clear where and how I can push each task (add attachment) to it
    // Then add .mergeMap(action =&gt; Observable.forkJoin(tasks$)) here, but it probably wrong to be added after .ofType(ADD_ATTACHMENT_SUCCEED)
    // In my mind, it needs to be after something `ADD_ALL_ATTACHMENTS_SUCCEED`
    .map(action =&gt; sendMailFromDraft({ mailId: action.payload.mailId }));
</code></pre>

<p><strong>UPDATE</strong>:</p>

<p>I will try to change to the structure below.</p>

<p>Maybe I can pass <code>addAttachments$</code> as a payload(?) or create it as a global variable. I will give more update later.</p>

<pre><code>const addAttachments$ = [
  ajax.patch(url, { base64: getBase64(first(action.payload.attachments) })),
  ajax.patch(url, { base64: getBase64(second(action.payload.attachments) })),
  ajax.patch(url, { base64: getBase64(third(action.payload.attachments) })),
  // ...
];

export const addMailContentSucceedEpic = (action$, store) =&gt;
  action$
    .ofType(ADD_MAIL_CONTENT_SUCCEED)
    .mergeMap(action =&gt;
      Observable.forkJoin(addAttachments$)
      .map(() =&gt; sendMailFromDraft({ mailId: action.payload.mailId }))
    )
    .catch(/* ... */);
</code></pre>
","2000548","","2000548","","2017-11-28 19:14:09","2017-11-29 05:11:35","How to use forkJoin correctly in redux-observable?","<javascript><redux><rxjs><rxjs5><redux-observable>","1","2","","","","CC BY-SA 3.0"
"47521005","2","","47503668","2017-11-27 22:36:05","","3","","<p>Fan's answer (as of this writing) is good but has some caveats to it that are important:</p>

<ul>
<li><p>It starts reading the file immediately instead of lazily. So just calling <code>readFile(file)</code> starts it even before anyone has subscribed. This is error-prone because it's possible that someone might not synchronously subscribe to it right away and then the <code>reader.onload</code> will miss it. Observables are ideally made completely lazy and repeatable factories.</p></li>
<li><p>It never calls <code>obs.complete()</code> on the observer, so it's possible the subscription will be a memory leak because it never ends.</p></li>
<li><p>The methods on the observer are not bound, so <code>reader.onerror = obs.error</code> won't actually work. Instead you need to either <code>e =&gt; obs.error(e)</code> or <code>obs.error.bind(obs)</code> <a href=""https://github.com/ReactiveX/rxjs/issues/1981"" rel=""nofollow noreferrer"">See here for reference on why</a></p></li>
<li><p>It doesn't abort the reading on unsubscribe.</p></li>
</ul>

<p>Here's how I would do it:</p>

<pre><code>function readFile(file){
  // Could use Observable.create (same thing) but I
  // prefer this one because Observable.create is
  // not part of the TC39 proposal
  return new Observable(observer =&gt; {
    const reader = new FileReader();
    reader.onload = (e) =&gt; {
      observer.next(reader.result);
      // It's important to complete() otherwise this
      // subscription might get leaked because it
      // ""never ends""
      observer.complete();
    };
    reader.onerror = e =&gt; observer.error(e);
    reader.readAsDataURL(file);

    // unsubscribe handler aka cleanup
    return () =&gt; {
      // LOADING state.
      // Calling abort() any other time
      // will throw an exception.
      if (reader.readyState === 1) {
        reader.abort();
      }
    };
  });
}
</code></pre>

<p>This pattern can be applied to nearly any API, so it's pretty handy to understand exactly how it works.</p>

<hr>

<p>I hope Fan doesn't mind the critique! I don't mean to offend, just want to share knowledge.</p>
","1770633","","1770633","","2017-11-27 22:41:12","2017-11-27 22:41:12","","","","0","","","","CC BY-SA 3.0"
"47525975","1","","","2017-11-28 07:17:24","","0","104","<p>In service</p>

<pre class=""lang-js prettyprint-override""><code>this._ProductUrl ="".../api/products""

getProduct(): Observable &lt;IProduct[]&gt;{   
  return this._http.get(this._ProductUrl)
    .map((response:Response) =&gt;  &lt;IProduct[]&gt; response.json())
    .catch(this.handleError);
}  
</code></pre>

<p>app.component.ts</p>

<p>with interval not working</p>

<pre class=""lang-js prettyprint-override""><code>Observable
  .interval(2*60*1000)
  .timeInterval()
  .flatMap((this._productService.getProduct())
  .subscribe((response) =&gt; {

}),(err)=&gt; {this.errorMsg =&lt;any&gt;err};
</code></pre>

<p>while hover over the line some error displays.
Error in this line:</p>

<pre><code>    Argument of type '(err: TimeInterval&lt;number&gt;) =&gt; void' is not assignable to parameter of type '(value: TimeInterval&lt;number&gt;, index: number) =&gt; ObservableInput&lt;{}&gt;'.

  Type 'void' is not assignable to type 'ObservableInput&lt;{}&gt;'
</code></pre>

<p>when tried like this</p>

<pre class=""lang-js prettyprint-override""><code>  Observable
    .interval(2*60*1000)
    .timeInterval()
    .flatMap((this._productService.getProduct(response))).subscribe((response) =&gt; {

    }),(err)=&gt; {this.errorMsg =&lt;any&gt;err};
</code></pre>

<p>Error on this line:</p>

<pre><code>.flatMap((this._productService.getProduct(response)

 [ts] Expected 0 arguments, but got 1.
(property) AppComponent._productService: ProductServic
</code></pre>

<p>e</p>

<p><strong>without Interval working fine</strong></p>

<pre><code> this._productService.getProduct().subscribe((response) =&gt; {
console.log(error);

}),(err)=&gt; {this.errorMsg =&lt;any&gt;err};
</code></pre>

<p>There is some syntax issue with above codes, please provide better solution be appreciated</p>
","4031891","","106909","","2017-11-28 08:32:00","2017-11-28 09:33:06","How to call a service call in each 2 minutes in angular4 observable","<angular><rxjs><angular2-services><rxjs5><angular4-httpclient>","2","0","","","","CC BY-SA 3.0"
"47534935","1","47535077","","2017-11-28 15:16:32","","0","111","<p>i am just started to learn the rxjs programming and want to implement it in my angular 4 application. </p>

<p>i followed this <a href=""http://reactivex.io/rxjs/manual/installation.html"" rel=""nofollow noreferrer"">blog</a> and installed rxjs using the command </p>

<blockquote>
  <p>npm install rxjs-es</p>
</blockquote>

<p>but when i try to import it and use i am getting an error import Rx</p>

<blockquote>
  <p>from 'rxjs/Rx';</p>
</blockquote>

<p>i followed some blog where it has adviced me to make some changes in the systemjs.config file, but i dont have a systemjs.config file in my application. i created my application using the angular cli command</p>
","2711059","","","","","2017-11-28 15:23:53","Not able to import RX in anglar4","<javascript><angular><rxjs><reactive-programming><rxjs5>","1","4","","","","CC BY-SA 3.0"
"47535077","2","","47534935","2017-11-28 15:23:53","","1","","<p>Rxjs is already part of angular so there is no need to install it manually via npm. </p>

<p>Just import components you want to use like e.g. </p>

<pre><code>import { Subject, Subscription } from ""rxjs/Rx"";
</code></pre>
","6095028","","","","","2017-11-28 15:23:53","","","","0","","","","CC BY-SA 3.0"
"47538060","1","47629386","","2017-11-28 17:58:07","","3","7556","<p>I am using <code>Angular 5</code> along with RXJS 5.5</p>

<p>Before I could just do something like this </p>

<pre><code>getProjectInfo(id): Observable&lt;any&gt; {
    const URL = `${this.API}/${id}`;
    return this.http.get(URL)
      .pipe(map(res =&gt; res)),
      catchError(this.handleServerError);
}

handleServerError(error: any) {
    console.log(error.error || error.json() || error);
    return Observable.throw(error.error || error.json() || error || 'Server error');
}
</code></pre>

<p>But now I get this error</p>

<pre><code>Error:(21, 5) TS2322:Type 'UnaryFunction&lt;Observable&lt;{}&gt;, Observable&lt;any&gt;&gt;' is not assignable to type 'Observable&lt;any&gt;'.
  Property '_isScalar' is missing in type 'UnaryFunction&lt;Observable&lt;{}&gt;, Observable&lt;any&gt;&gt;'.
</code></pre>

<p>I've also tried this</p>

<pre><code>getProjectInfo(id): Observable&lt;any&gt; {
    const URL = `${this.API}/${id}`;
    return this.http.get(URL)
      .pipe(map(res =&gt; res)),
      catchError(err =&gt; this.handleError('getProjInfo', URL));
}
private handleError(method: String, URL: string): any {
  return (err: any) =&gt; {
    const errMsg = `error in ${method}() retrieving ${URL}`;
    console.log(`${errMsg}:`, err);
    if (err instanceof HttpErrorResponse) {
      console.log(`status: ${err.status}, ${err.statusText}`);
    }
    return Observable.throw(errMsg);
  };
}
</code></pre>

<p>What am I doing wrong?</p>
","6307745","","","","","2018-01-16 16:14:44","How to catch error in RxJS 5.5","<angular><rxjs><rxjs5>","3","2","2","","","CC BY-SA 3.0"
"47540991","1","","","2017-11-28 21:10:14","","1","41","<p>I have following code that takes 3 lists  of objects (Location, Machine, Sensor). They are then mapped based on parent ids (Location has machines and machine has sensors) to object with children 
The resulting observable return object that is Location (that has list of Machines, where each has list of Sensors).
It works fine. However I'd like to get a single list of Locations, but when I use toArray() on the observable, the original array that is returned is duplicated with each subscription.</p>

<pre><code>function getLocations() {
  return [
    {id: 'loc1', name: 'Some location'},
    {id: 'loc2', name: 'Other location'},
    {id: 'loc3', name: 'New location'},
  ];
}
function getMachines() {
  return [
    {id: '1', name: 'Machine 1', location: 'loc1'},
    {id: '2', name: 'Machine 2', location: 'loc1'},
    {id: '3', name: 'Machine 3', location: 'loc2'},
    {id: '4', name: 'Machine 4', location: 'loc3'},
  ];
}
function getSensors() {
  return [
    {id: 's1', name: 'Sensor 1', machine: '1'},
    {id: 's2', name: 'Sensor 2', machine: '3'},
    {id: 's3', name: 'Sensor 3', machine: '1'},
    {id: 's5', name: 'Sensor 5', machine: '4'},
    {id: 's4', name: 'Sensor 4', machine: '2'},
  ];
}

const sensors$ = Rx.Observable.from(getSensors());
const machinesWithSensors$ = Rx.Observable.from(getMachines())
                                             .flatMap(machine =&gt; sensors$.filter(sensor =&gt; sensor.machine === machine.id).toArray().map(sensors =&gt; {
                                               return {...machine, sensors: sensors}
  }));

const allData$ = Rx.Observable.from(getLocations())
                                  .flatMap(location =&gt; machinesWithSensors$
                                    .filter(machine =&gt; machine.location === location.id)
                                    .toArray().map(machines =&gt; {
  return {...location, machines: machines};
}));
const allDataArr$ = allData$.toArray();
allData$.subscribe(s =&gt; console.log('allData1', s))
allData$.subscribe(s =&gt; console.log('allData2', s))
allData$.subscribe(s =&gt; console.log('allData3', s))
allDataArr$.subscribe(s =&gt; console.log('allDataArr1', s))
allDataArr$.subscribe(s =&gt; console.log('allDataArr2', s))
allDataArr$.subscribe(s =&gt; console.log('allDataArr3', s))
</code></pre>

<p>Example on codepen:
<a href=""https://codepen.io/anon/pen/ooaBdj"" rel=""nofollow noreferrer"">https://codepen.io/anon/pen/ooaBdj</a></p>

<p>Why is that? How do I 'reset' the observable before each subscription?</p>
","193404","","193404","","2017-11-28 21:20:43","2017-11-28 21:20:43","Why does toArray() duplicate elements on subsequent subscribe?","<rxjs><rxjs5><reactivex>","0","2","","","","CC BY-SA 3.0"
"47544744","2","","47506376","2017-11-29 03:50:49","","4","","<p>This is my final solution.</p>

<p>Since read file is also async, so there are two <code>forkJoin</code> in this solution.</p>

<p>One <code>forkJoin</code> is used to wait all files are read. The other <code>forkJoin</code> is used for waiting all attachments are uploaded.</p>

<p>For <code>getBase64FromFile$</code> in the code, please check <a href=""https://stackoverflow.com/questions/47503668/how-to-handle-async-function-in-redux-observable"">How to handle async function in redux-observable?</a></p>

<pre><code>export const addMailContentSucceedEpic = (action$, store) =&gt;
  action$
    .ofType(ADD_MAIL_CONTENT_SUCCEED)
    .mergeMap(action =&gt; addTasks$(action))
    .mergeMap(action =&gt; Observable.forkJoin(action.payload.posts$)
      .map(() =&gt; sendMailFromDraft({ mail: action.payload.mail }))
    );


function getPosts(base64Array, action) {
  let posts$ = [];

  for (let i = 0; i &lt; base64Array.length; ++i) {
    posts$ = [...posts$, ajax.patch(url, { base64: base64Array[i] })];
  }

  return {
    ...action,
    payload: {
      ...action.payload,
      posts$
    }
  };
}

function addTasks$(action) {
  let readFiles$ = [];

  for (let i = 0, attachmentIds = Object.keys(action.payload.attachments); i &lt; attachmentIds.length; ++i) {
    const attachmentId = attachmentIds[i];
    const attachment = action.payload.attachments[attachmentId];

    readFiles$ = [...readFiles$, getBase64FromFile$(attachment)];
  }

  return Observable.forkJoin(readFiles$)
    .map(base64Array =&gt; getPosts(base64Array, action));
}
</code></pre>
","2000548","","2000548","","2017-11-29 05:11:35","2017-11-29 05:11:35","","","","2","","","","CC BY-SA 3.0"
"47550911","1","47551006","","2017-11-29 10:46:35","","8","7085","<p>I want to know when my application goes offline and comes back online. I have the following events registered in <code>rxjs</code>:</p>

<pre><code>const online = Rx.Observable.fromEvent(window, 'online');
const offline = Rx.Observable.fromEvent(window, 'offline');

const source = Rx.Observable.combineLatest(online, offline).map(() =&gt; navigator.onLine);

source.subscribe(result =&gt; {
  console.log('I\'m online: ' + (result ? 'jup' : 'nope'));
});
</code></pre>

<p>But, the first time I go offline the event isn't triggered allthough if I add the regular <code>addEventListener</code> events I see they're getting triggered fine: </p>

<pre><code>window.addEventListener('online', () =&gt; console.log('online triggered'));
window.addEventListener('offline', () =&gt; console.log('offline triggered'));
</code></pre>

<p>Take a look at <a href=""http://jsbin.com/zegidegiba/edit?js,console"" rel=""noreferrer"">this jsbin</a> as example, switch of your netwerk via devtools and you'll see the first time it won't log <code>I'm online: ...</code>. </p>
","3891533","","","","","2017-11-29 10:51:03","CombineLatest first event not firing","<javascript><rxjs><rxjs5>","1","0","2","","","CC BY-SA 3.0"
"47551006","2","","47550911","2017-11-29 10:51:03","","25","","<p>The <code>combineLatest</code> operator requires all source Observables to emit at least one value.</p>

<p>For you this means you should initialize each stream and then just listen to changes:</p>

<pre><code>const source = Rx.Observable.combineLatest(
    online.startWith(null),
    offline.startWith(null),
  )
  .skip(1)
  .map(() =&gt; navigator.onLine)
</code></pre>

<p>Maybe you don't even need to use the <code>skip(1)</code> if you want to know the initial state of <code>navigator.onLine</code>.</p>
","310726","","","","","2017-11-29 10:51:03","","","","2","","","","CC BY-SA 3.0"
"47552174","1","47571349","","2017-11-29 11:51:14","","2","1519","<pre><code>const ws = Observable.webSocket('ws://â¦');
ws.subscribe(
  message =&gt; console.log(message),
  error =&gt; console.log(error),
  () =&gt; {},
);
</code></pre>

<p>I want to observe my WebSocket connection with RxJS. Reacting to <code>onmessage</code> events by subscribing to the observable works like a charm. But how can I access the <code>onopen</code> event of the WebSocket? And is it possible to trigger the WebSocket <code>.close()</code> method? RxJS is pretty new to me and I did research for hours, but maybe I just don't know the right terms. Thanks in advance.</p>
","1634573","","1634573","","2017-11-30 07:26:37","2019-11-24 07:40:25","RxJS: Observable.webSocket() get access to onopen, oncloseâ¦","<javascript><websocket><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"47563617","2","","47355666","2017-11-29 23:34:41","","3","","<p>You can use the second argument that accepts a custom Scheduler.</p>

<pre><code>  debounceTime(DEFAULT_DEBOUNCE_TIME, rxTestScheduler),
</code></pre>

<p>All code</p>

<pre><code>import { Scheduler } from 'rxjs/scheduler/Scheduler';
import { asap } from 'rxjs/scheduler/asap';

@Injectable()
export class EffectsService {
  constructor(private scheduler: Scheduler = asap) { }

  @Effect()
  public filterUpdated$ = this.actions$
    .ofType(UPDATE_FILTERS)
    .pipe(
        debounceTime(DEFAULT_DEBOUNCE_TIME, this.scheduler),
        mergeMap(action =&gt; [...])
    );
}
</code></pre>

<p>Then on test</p>

<pre><code>describe('Service: EffectsService', () =&gt; {
  //setup
  beforeEach(() =&gt; TestBed.configureTestingModule({
    EffectsService, 
    { provide: Scheduler, useValue: rxTestScheduler} ]
  }));

  //specs
  it('should update filters using debounce', inject([EffectsService], service =&gt; {
    // your test
  });
});
</code></pre>
","4508433","","4508433","","2017-12-01 23:49:54","2017-12-01 23:49:54","","","","3","","","","CC BY-SA 3.0"
"47571349","2","","47552174","2017-11-30 10:38:06","","5","","<p>Looking at the <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/observable/dom/WebSocketSubject.ts#L181"" rel=""noreferrer"">sourcecode of the Websocket</a> there is a config object <code>WebSocketSubjectConfig</code> which contains observables which you can link to different events. You should be able to pass a <code>NextObserver</code> typed object to config value <code>openObserver</code> like so:</p>

<pre><code>const openEvents = new Subject&lt;Event&gt;();
const ws = Observable.webSocket({
  url: 'ws://â¦', 
  openObserver: openEvents 
});

openEvents
  .do(evt =&gt; console.log('got open event: ' + evt))
  .merge(ws.do(msg =&gt; console.log('got message: ' + msg))
  .subscribe();
</code></pre>
","106909","","","","","2017-11-30 10:38:06","","","","1","","","","CC BY-SA 3.0"
"47577533","1","","","2017-11-30 15:57:59","","1","139","<p>Is there a way to restructure the following Obersable chain, so that subscribe will handle the real data, and the error path does not take over the main path?</p>

<p>That means the processing in do() should go to subscribe, filter be removed, and starting with catch reorganized to do the same thing at the end.</p>

<pre><code>Rx.Observable.fromEvent(btnA, 'click')
  .switchMap(e =&gt; {
    let doThrow = doThrowInp.checked;
    output('Start some lengthy op' + (doThrow ? ' that fails' : ''));
    let o = Rx.Observable.of(0).delay(2000);
    if (doThrow)
      o = o.throw('Error');
    return o;
  })
  .do(data =&gt; {
    output('Got the data we are interested in: ' + data);
  })
  .filter(_ =&gt; {
    output('Stop any data propagating further down');
    return false;
  })
  .catch((err, caught) =&gt; {
    output('We catched the error, inform the user and retry click listening');
    return Rx.Observable.concat(Rx.Observable.of({}), caught);
  })
  .switchMap(x =&gt; Rx.Observable.of('hidden').delay(3000).startWith('visible'))
  .subscribe(x =&gt; {
    output('Change error message visibility: ' + x);
    errorDiv.style.visibility = x;
  }, err =&gt; {
    output(""Uups, we shouldn't get here"" + err);
  });
</code></pre>

<p>See all on Plunker: <a href=""https://plnkr.co/edit/wA2H3QfTmIagwWOlG77r?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/wA2H3QfTmIagwWOlG77r?p=preview</a></p>
","8779034","","","","","2017-11-30 22:13:04","Is there a way to restructure this Observable chain focus on the real data","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"47584230","1","","","2017-11-30 23:19:30","","-4","216","<p>Trying to understand if RxJs can be used safely in production. 
Anyone knows about Vulnerabilities in RxJS 5. 
Are the below issues known with RxJS5. Please help. </p>

<pre><code>**Vulnerabilities - Public Data**
CVE-2017-1000048 High Risk Prototype Override Protection Bypass qs 2.4.2
CVE-2015-8855 High Risk Regular Expression Denial Of Service (ReDoS) semver 2.3.2
CVE-2017-1000048 High Risk Prototype Override Protection Bypass qs 5.2.1
CVE-2017-1000048 High Risk Prototype Override Protection Bypass qs 2.3.3
CVE-2017-15010 Medium Risk Regular Expression Denial Of Service (ReDoS) Via Parsing Cookies tough-cookie 2.3.2
CVE-2017-15010 Medium Risk Regular Expression Denial Of Service (ReDoS) Via Parsing Cookies tough-cookie 2.2.2

**Vulnerabilities - Premium Data**
RESERVED (CVE-2016-1000023) High Risk Regular Expression Denial Of Service (ReDoS) minimatch 0.3.0
RESERVED (CVE-2016-1000023) High Risk Regular Expression Denial Of Service (ReDoS) minimatch 2.0.10
NO-CVE High Risk Remote Code Execution (RCE) growl 1.9.2
RESERVED (CVE-2016-1000023) High Risk Regular Expression Denial Of Service (ReDoS) minimatch 2.0.4
NO-CVE Medium Risk Insecure Cipher request 2.55.0
NO-CVE Medium Risk Remote Memory Disclosure request 2.55.0
NO-CVE Medium Risk Insecure Cipher request 2.67.0
NO-CVE Medium Risk Remote Memory Disclosure request 2.67.0
RESERVED (CVE-2016-2515) Medium Risk Regular Expression Denial Of Service (ReDoS) hawk 2.3.1
NO-CVE Medium Risk Insecure Cipher request 2.79.0
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) debug 2.6.8
NO-CVE Medium Risk Insecure Cipher request 2.81.0
NO-CVE Medium Risk Denial Of Service (DoS) ws 1.1.5
NO-CVE Medium Risk Timing Attacks http-signature 0.10.1
NO-CVE Medium Risk Arbitrary Command Injection shelljs 0.7.6
RESERVED (CVE-2016-1000013) Medium Risk Cross-site Scripting (XSS) Due To Sanitization Bypass Using HTML Entities marked 0.3.5
NO-CVE Medium Risk Cross-site Scripting (XSS) marked 0.3.5
NO-CVE Medium Risk Cross-Site Scripting (XSS) marked 0.3.5
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) marked 0.3.5
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) debug 2.2.0
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) ms 0.7.3
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) ms 0.7.1
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) debug 2.6.6
NO-CVE Medium Risk Information Disclosure tunnel-agent 0.4.3
NO-CVE Medium Risk Regular Expression Denial Of Service (ReDoS) Via Long String Of Semicolons tough-cookie 2.2.2
</code></pre>
","4061907","","","","","2017-12-04 06:37:20","Any known Vulnerabilities in RxJS 5","<rxjs><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"47629386","2","","47538060","2017-12-04 08:39:17","","13","","<p>Keep in mind your brackets. You return <code>pipe</code> result and <code>catchEror</code> result divided by <code>,</code>:</p>

<pre><code>return this.http.get(URL)
  .pipe(map(res =&gt; res)),
  catchError(this.handleServerError);
</code></pre>

<p>Place one bracket to own place:</p>

<pre><code>return this.http.get(URL)
  .pipe(
    map(res =&gt; res),
    catchError(this.handleServerError)
  );
</code></pre>
","1676509","","","","","2017-12-04 08:39:17","","","","2","","","","CC BY-SA 3.0"
"47634636","1","47636099","","2017-12-04 13:37:19","","1","3395","<p>So, I have a array of ""events"":</p>

<pre class=""lang-js prettyprint-override""><code>let events = Rx.Observable.from([1,2,3,4,5,6,7,8,9]);
</code></pre>

<p>I can add(push):</p>

<pre class=""lang-js prettyprint-override""><code>let add = function(number){
  events = events.concat([number]);
}
</code></pre>

<p>I can remove:</p>

<pre class=""lang-js prettyprint-override""><code>let remove = function(){
  events = events.filter(event =&gt; {
  return event != 3;
})
}
</code></pre>

<p>My first question:
How can I remove and add a element by index in ""RxJS"" way?</p>

<pre class=""lang-js prettyprint-override""><code>let removeByIndex = function(index){
  //remove by index
}

let addByIndex = function(index){
  //add by index
}
</code></pre>

<p>My second question:
I need ""reinvent the wheel"" for all basic methods of Array on RxJS from and of? </p>
","5173611","","106909","","2017-12-05 13:08:14","2017-12-05 16:25:29","How can I remove and add element on Array by index in RxJS way?","<rxjs><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"47636099","2","","47634636","2017-12-04 14:56:43","","3","","<p>What's your purpose? Your Observable is just a publisher which is listen somewhere in your application?</p>

<p>In this case, you can just have a method <code>publish</code> where push your new array:</p>

<pre><code>class EventStream {
   private numbers$: Subject&lt;number[]&gt; = new Subject() 
   //or BehaviorSubject if you want a default value

   publish(arrayNumberToPublish: number[]): void {
      this.numbers$.next(arrayNumberToPublish)
   }

   listen(): Observable&lt;number[]&gt; {
      return this.numbers$
   }
}
</code></pre>

<p>In your code you listen the stream: <code>new EventStream().listen().(...)</code></p>

<p>The second possibility is you want keep the array. I use it when I want stub a CRUD API:</p>

<pre><code>class EventManager {
   private events: number[] = []
   private events$: Subject&lt;number[]&gt; = new Subject()
   //or BehaviorSubject if you want a default value

   getAllEvents(): Observable&lt;number[]&gt; {
      return this.events$
   }

   addEvent(index: number): void {
      this.events = this.events.concat(index)
      this.events$.next(this.events)
   }

   removeEvent(index: number): void {
      this.events = this.events.filter(event =&gt; event !== index)
      this.events$.next(this.events)
   }
</code></pre>

<p>}</p>
","7152354","","7152354","","2017-12-05 16:25:29","2017-12-05 16:25:29","","","","2","","","","CC BY-SA 3.0"
"47658699","1","47659270","","2017-12-05 16:50:43","","4","180","<p>I'm fetching a list of items from a REST api. The user interacts with each one via a click, and when there are only, say, a couple left unused, I'd like to repeat the request to get more items. I'm trying to do this using a proper RxJs (5) stream-oriented approach.</p>

<p>So, something like:</p>

<pre><code>var userClick$ = Observable.fromEvent(button.nativeElement, 'click');

var needToExtend$ = new BehaviorSubject(1);

var list$ = needToExtend$
            .flatMap( () =&gt; this.http.get(""http://myserver/get-list"") )
            .flatMap( x =&gt; x['list'] );

var itemsUsed$ = userClick$.zip(list$, (click, item) =&gt; item);
itemsUsed$.subscribe( item =&gt; use(item) );
</code></pre>

<p>and then, to trigger a re-load when necessary:</p>

<pre><code>list$.subscribe(
    if (list$.isEmpty()) {
        needToExtend$.next(1);
    }
)
</code></pre>

<p>This last bit is wrong, and manually re-triggering doesn't seem very ""stream-oriented"" even if it did work as intended. Any ideas?</p>

<p>This is similar to <a href=""https://stackoverflow.com/questions/40348748/rxjs-consume-api-output-and-re-query-when-cache-is-empty"">Rxjs - Consume API output and re-query when cache is empty</a> but I can't make assumptions about the length of the list returned by the API, and I'd like to re-request before the list is completely consumed. And the solution there feels a bit too clever. There must be a more readable way, right?</p>
","4567590","","","","","2017-12-06 13:46:31","RxJs: request list from server, consume values, re-request when we're almost out of values","<rest><http><rxjs><observable><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"47659270","2","","47658699","2017-12-05 17:22:57","","2","","<p>How about something like this:</p>

<pre><code>const LIST_LIMIT = 3;
userClick$ = Observable.fromEvent(button.nativeElement, 'click');
list$ = this.http.get(""http://myserver/get-list"").map(r =&gt; r.list);

clickCounter$ = this.userClick$.scan((acc: number, val) =&gt; acc + 1, 0);

getList$ = new BehaviorSubject([]);

this.getList$
    .switchMap(previousList =&gt; this.list$)
    .switchMap(list =&gt; this.clickCounter$, (list, clickCount) =&gt; { return {list, clickCount}; })
    .filter(({list, clickCount}) =&gt; clickCount &gt;= list.length - LIST_LIMIT)
    .map(({list, clickCount}) =&gt; list)
    .subscribe(this.getList$);
</code></pre>

<p>The logic here if you define a list getter stream, and a signal to trigger it. </p>

<p>First, the signal causes switchMap to fetch a new list, which is then fed into another switchmap that resubscribes to a click counter.  You combine the result of both streams and feed that to filter, which only emits when the click count is greater than or equal to the list length minus 3 (or whatever you want).  Then the signal is subscribed to this whole stream so that it retriggers itself.</p>

<p>Edit: the biggest weakness of this is that you need to set the list value (for display) in a side effect rather than in subscription or with the async pipe.  You can rearrange it and multicast though:</p>

<pre><code>const LIST_LIMIT = 3;
userClick$ = Observable.fromEvent(button.nativeElement, 'click');
list$ = this.http.get(""http://myserver/get-list"").map(r =&gt; r.list);

clickCounter$: Observable&lt;number&gt; = this.userClick$.scan((acc: number, val) =&gt; acc + 1, 0).startWith(0);

getList$ = new BehaviorSubject([]);

refresh$ = this.getList$
        .switchMap(list =&gt; this.clickCounter$
                               .filter(clickCount =&gt; list.length &lt;= clickCount + LIST_LIMIT)
                               .first(), 
            (list, clickCount) =&gt; list)
        .switchMap(previousList =&gt; this.list$)
        .multicast(() =&gt; this.getList$);

this.refresh$.connect();
this.refresh$.subscribe(e =&gt; console.log(e));
</code></pre>

<p>This way has a few advantages, but may be a little less ""readable"".  The pieces are mostly the same, but instead you go to the counter first and let that lead into the switch to the list fetch.  and you multicast it to restart the counter.</p>
","4855306","","4855306","","2017-12-06 13:46:31","2017-12-06 13:46:31","","","","2","","","","CC BY-SA 3.0"
"47660328","1","47660470","","2017-12-05 18:25:11","","3","1272","<p>I have two observables which I would like to forkJoin:</p>

<pre><code>  var goodObservable = Rx.Observable.create( function(observer){
    observer.next('something');
    observer.complete();
  });

  var badObservable = Rx.Observable.create( function(observer){
    observer.complete();
  });


  var forkJoinedObservable = Rx.Observable.forkJoin([goodObservable, badObservable]);  

  forkJoinedObservable.subscribe(function(results){
    console.log(results);
  });
</code></pre>

<p>One of those observables only calls complete. Now I have found that the forkJoined observables never gets triggered. I will have to call observer.next() in the badObservable in order to make the subscription on forkJoin to be executed.</p>

<p>My expected behaviour would be that the forkJoin-subscribes would be executed with an array containing just one item: ['something']</p>

<p>Is this a bug, or did I not understand the concept correctly?</p>

<p>I have made a plunkr for this: <a href=""https://plnkr.co/edit/QaA9DwyWAmTGbthvguPK?p=preview"" rel=""nofollow noreferrer"">https://plnkr.co/edit/QaA9DwyWAmTGbthvguPK?p=preview</a></p>
","2767626","","","","","2017-12-05 18:46:42","rxjs: Does forkJoin need at least one call to next to complete?","<rxjs><rxjs5>","1","3","2","","","CC BY-SA 3.0"
"47660470","2","","47660328","2017-12-05 18:34:46","","3","","<p><code>forkJoin()</code> emits the last emitted item from each observable. There's no item to emit in this case, so the operator doesn't emit.</p>

<p>A pragmatic solution would be to call <code>.startsWith(defaultValue)</code> on each observable, so <code>forkJoin()</code> can complete as well.</p>

<pre><code>var goodObservable = Rx.Observable.create( function(observer){
  observer.next('something');
  observer.complete();
});

var badObservable = Rx.Observable.create( function(observer){
  observer.complete();
}).startWith(null);


var forkJoinedObservable = Rx.Observable.forkJoin([goodObservable, badObservable]);  

forkJoinedObservable.subscribe(function(results){
  console.log(results);
});
</code></pre>

<p>About emitting values just for the observables that have emitted, this wouldn't work, because then you wouldn't know which one didn't emit. Of course, it could have emitted <code>null</code>. But given this is achievable by combining operators, I don't think it's gonna change.</p>
","592792","","592792","","2017-12-05 18:46:42","2017-12-05 18:46:42","","","","0","","","","CC BY-SA 3.0"
"47669444","1","47669787","","2017-12-06 07:59:53","","0","321","<p>I have an Angular project and I need to use Observables from RxJS with a few selection of operators.</p>

<p>This is what the documentation says:</p>

<blockquote>
  <p>To import only what you need by patching (this is useful for size-sensitive bundling):</p>

<pre><code>import { Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';

Observable.of(1,2,3).map(x =&gt; x + '!!!'); // etc
</code></pre>
</blockquote>

<p>And this is what I'm doing in my app component:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {

  private testObservable: Observable&lt;string&gt; = Observable.of(1,2,3).map(x =&gt; x + '!!!');

  constructor() { }

  ngOnInit() {

    this.testObservable.subscribe((str: string) =&gt; {

      console.log(str);

    });

  }

}
</code></pre>

<p>This is where I get confused. When I delete the second and third import (<code>of</code> and <code>map</code>), the Observable's operators still work!</p>

<p>I was under the impression that using the <code>import 'rxjs/add/operator/*';</code> would only add the operators I need and skip importing the rest of them. However, I can see that all the operators (static and instance) are members of the Observable class and get imported through the first import statement.</p>

<p>My questions are:</p>

<ol>
<li>How can I properly import only the parts I need and exclude the rest?</li>
<li>What's the point of using <code>import 'rxjs/add/operator/*';</code> if all operators are already a member of the Observable class?</li>
</ol>
","4761178","","","","","2017-12-06 08:23:10","How to properly import RxJS by patching?","<angular><typescript><rxjs><rxjs5><angular2-observables>","1","2","1","","","CC BY-SA 3.0"
"47669787","2","","47669444","2017-12-06 08:23:10","","2","","<p>You're importing map somewhere else, too, not just in your component. Try not importing something exotic, say, bufferToggle. It will throw error. Map is imported and patched all over, perhaps even from Angular itself.</p>

<p>So, importing specific operators still makes sense. import * would suck, but import just map reduces your bundle size.</p>
","162070","","","","","2017-12-06 08:23:10","","","","3","","","","CC BY-SA 3.0"
"47671995","1","","","2017-12-06 10:26:02","","4","507","<p>I'm curious if there is any way to ensure order of actions in <code>@ngrx/effects</code> when returning multiple actions as response to some other one.</p>

<p><code>ActionA =&gt; emit ActionB (=&gt; emit async ActionB1, ActionB2) and then ActionC</code></p>

<p>I would like to achieve sequence of <code>ActionA</code>, <code>ActionB</code>, <code>ActionB1</code>, <code>ActionB2</code>, <code>ActionC</code>.</p>

<p>One can use <code>concatMap</code> but that doesn't seem to ensure, that actions B1 and B2 were being handled prior to emitting C.</p>

<p>Real world example:</p>

<pre><code>@Effect()
oauthLoginAsSomeoneElse$: Observable&lt;Action&gt; = this.actions$
    .ofType&lt;AuthActions.OAuthLoginAsSomeoneElse&gt;(AuthActions.OAUTH_LOGIN_AS_SOMEONE_ELSE)
    .pipe(
        concatMap(action =&gt; [
            // First logout
            new AuthActions.OAuthLogout(),
            // Then login again
            new AuthActions.OAuthLogin({redir: action.payload.redir})
        ])
    );

@Effect({dispatch: false})
oauthLogin$: Observable&lt;Action&gt; = this.actions$
    .ofType&lt;AuthActions.OAuthLogin&gt;(AuthActions.OAUTH_LOGIN)
    .pipe(
        map(action =&gt; oauthRedir.start(
            this.authEndpoint + '/oauth/authorize',
            this.authClientId,
            this.authRedirectUri,
            this.appBaseHref,
            action.payload.redir,
        ))
    );

@Effect()
oauthLogout$: Observable&lt;Action&gt; = this.actions$
    .ofType&lt;AuthActions.OAuthLogout&gt;(AuthActions.OAUTH_LOGOUT)
    .pipe(
        switchMap(action =&gt;
            this.http.post(`${this.authEndpoint}/logout`, null, {withCredentials: true}).pipe(
                map(responseData =&gt; new AuthActions.SessionTerminate()),
                catchError((err: HttpErrorResponse) =&gt; {
                    return of(new RouterActions.Go({path: ['/']}));
                }),
            )
        )
    );
</code></pre>

<p>You would expect, that when dispatching <code>OAuthLoginAsSomeoneElse</code> everything related to <code>OAuthLogout</code> action will be finished (including some async stuff in actions it's <code>@Effect()</code> emits) before emitting <code>OAuthLogin</code> again. I mean, first process first root action and it's children, then process next emitted root action.</p>

<p>Do you know how this scenario can be achieved? My current workaround is to supply next action to emit as parameter to <code>OAuthLogout</code>, but this doesn't really scale well and gets quickly quite complicated to reason about.</p>
","303184","","","","","2020-08-12 08:33:24","Dispatching multiple actions with @ngrx/effects while making sure they are executed in order","<angular><rxjs5><ngrx><ngrx-effects>","1","0","","","","CC BY-SA 3.0"
"47674645","1","","","2017-12-06 12:46:37","","1","2701","<p>I'm upgrading an application from Angular 4 to Angular 5, and have the following code in a service</p>

<pre><code>loadRefData(): Observable&lt;RefData&gt; {
    return this.participant$.switchMap((role) =&gt; {
      return this.http.get(`${this.API_URL}/${role}/participantGroups/refdata`)
        .map(refData =&gt; refData as RefData);
});
</code></pre>

<p>Since Angular 5 comes with the minimum requirement of RxJS 5.5.2, I'm converting it to use lettable operators with the <code>.pipe()</code> operator.</p>

<p>I thought I could do this</p>

<pre><code>loadRefData(): Observable&lt;RefData&gt; {
    return this.participant$.switchMap((role) =&gt; {
      return this.http.get(`${this.API_URL}/${role}/participantGroups/refdata`)
        .pipe(
            map(refData =&gt; refData as RefData);
        );
});
</code></pre>

<p>but I get the error <code>TypeError: this.participant$.switchMap is not a function</code>. I get no compilation errors from the typescript compiler though. </p>

<p><code>this.participant$</code> is of type <code>Observable&lt;string&gt;</code>, and unless I'm mistaken I should be able to perform a <code>switchMap</code> on it.</p>

<p>What am I missing?</p>

<p>This is with <code>typescript@^2.6.1</code>, <code>rxjs@^5.5.2</code>.</p>

<p>EDIT:
I just noticed that <code>this.participant$</code> which is populated from <code>ngrx\store.select</code> is of type <code>Store&lt;string&gt;</code>.</p>
","1447173","","1447173","","2017-12-06 13:01:32","2017-12-06 13:12:25","Observable<string>.switchMap is not function","<angular><typescript><rxjs><rxjs5>","1","6","2","","","CC BY-SA 3.0"
"47681201","1","47682165","","2017-12-06 18:34:27","","0","357","<p>I'm trying to use RxJS to replace the next piece of code(<a href=""https://jsbin.com/lixudax/1/edit?html,js,console,output"" rel=""nofollow noreferrer"">jsbin</a>):</p>

<pre><code>function parseRequestUrl(url) {
  var newUrl;
  if ((newUrl = testThatUrlIsOrigin1(url)) !== url) {
    return doSomething(newUrl);
  }
  if ((newUrl = testThatUrlIsOrigin2(url)) !== url) {
    return doSomething(newUrl);
  }
  if ((newUrl = testThatUrlIsOrigin3(url)) !== url) {
    return doSomething(newUrl);
  }
}
</code></pre>

<p>Something i was able to achieve using RxJS(<a href=""https://jsbin.com/kaganet/1/edit?html,js,console,output"" rel=""nofollow noreferrer"">jsbin</a>) but in that case i needed to call a function twice for which ""filter expression"" is true</p>

<pre><code>function parseRequestUrl(url) {
  var newUrl = url;
  var observer = Rx.Observable.of(testThatUrlIsOrigin1, testThatUrlIsOrigin2, testThatUrlIsOrigin3);
  observer.first(getUrlFunc =&gt; getUrlFunc(url) !== url).map(getUrlFunc =&gt; getUrlFunc(url)).subscribe(createdUrl =&gt; newUrl = createdUrl)

  return doSomething(newUrl);
  // And so on
}
</code></pre>

<p>Can RxJS suit my requirements ?</p>
","2861947","","","","","2017-12-06 20:35:37","How to avoid long if else statements using RxJS","<javascript><if-statement><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"47681267","1","","","2017-12-06 18:38:00","","2","57","<p>lets imagine I have an array of items <code>A=[1,2,3,4,5]</code> and <code>Observable.from(A)</code></p>

<p>I have a button, by pressing on which I want to pick 1 from my stream and put it on UI. So that A will look like <code>[2,3,4,5]</code>, then I click button again, and I pick one more item from pipe and bring it to UI. Repeat the above until pipe is empty, <code>A=[]</code>. </p>

<p>For event of button press I can use <code>Subject</code> and call <code>.next()</code> method. But how to pick items one by one from Rx stream? </p>

<p>Could you help me?</p>
","7109755","","","","","2017-12-06 18:38:00","Consume pipe one by one on event","<angular><rxjs><observable><reactive-programming><rxjs5>","0","5","","","","CC BY-SA 3.0"
"47682165","2","","47681201","2017-12-06 19:37:16","","4","","<p>I don't think that RxJs is the right tool for the job. It is best suited for processing asynchronous streams of data. I think that a better approach would be to just put all of your test functions in an array and loop over them. Something like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const tests = [testThatUrlIsOrigin1, testThatUrlIsOrigin2, testThatUrlIsOrigin3];
function parseRequestUrl(url) {
  for (const test of tests) {
    const newUrl = test(url);
    if (newUrl === url) continue;
    return newUrl;
  }
}
 
 
function testThatUrlIsOrigin1(url) {
	console.log(""try testThatUrlIsOrigin1"");
	if (url === 'origin1') {
      console.log(""Pass testThatUrlIsOrigin1"");
      return ""First If"";
  }
  return url;
}

function testThatUrlIsOrigin2(url) {
	console.log(""try testThatUrlIsOrigin2"");
	if (url === 'origin2') {
      console.log(""Pass testThatUrlIsOrigin2"");
  	  return ""Second If"";
    }
  return url;
}

function testThatUrlIsOrigin3(url) {
	console.log(""try testThatUrlIsOrigin3"");
	if (url === 'origin3') {
      console.log(""Pass testThatUrlIsOrigin3"");
      return ""Third If"";
    }
  return url;
}

parseRequestUrl('origin2')</code></pre>
</div>
</div>
</p>

<p>You could also implement the <a href=""https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern"" rel=""nofollow noreferrer"">Chain of Responsibility</a> design pattern if you wanted to get all OO on it.</p>

<p><strong>EDIT</strong>
Since you want to see how to do it in RxJs, here is a simplified version:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function test(a, b) {
  return a === b ? `${a} test` : b;
}

const tests = [
  test.bind(null, 1),
  test.bind(null, 2),
  test.bind(null, 3),
];

const value = 2;
Rx.Observable.from(tests)
    .map(x =&gt; x(value))
    .filter(x =&gt; x !== value)
    .take(1)
    .subscribe(
      x =&gt; { console.log(x); },
      null,
      () =&gt; { console.log('completed'); }
    );</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.5/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","959745","","959745","","2017-12-06 20:35:37","2017-12-06 20:35:37","","","","4","","","","CC BY-SA 3.0"
"47687819","1","47765868","","2017-12-07 04:51:09","","7","739","<p>Given the example of a download manager. There can be any number of active downloads. </p>

<p>Actions can be dispatched to start, stop, mark completion and mark the download progress of any particular download.</p>

<pre class=""lang-js prettyprint-override""><code>const START_DOWNLOAD = ""START_DOWNLOAD"";
const startDownload = payload =&gt; ({ type: START_DOWNLOAD, payload });

const DOWNLOAD_PROGRESS = ""DOWNLOAD_PROGRESS"";
const downloadProgress = payload =&gt; ({ type: DOWNLOAD_PROGRESS, payload });

const STOP_DOWNLOAD = ""STOP_DOWNLOAD"";
const stopDownload = payload =&gt; ({ type: STOP_DOWNLOAD, payload });

const COMPLETE_DOWNLOAD = ""COMPLETE_DOWNLOAD"";
const completeDownload = payload =&gt; ({ type: COMPLETE_DOWNLOAD payload });
</code></pre>

<p>These actions will contain an id to identify the download and can modify the redux state using the following reducer:</p>

<pre class=""lang-js prettyprint-override""><code>const downloadReducer = (state = initialState, action) =&gt; {
  switch (action.type) {
    case STOP_DOWNLOAD:
      return {
        ...state,
        [action.payload.id]: {
          state: ""IDLE"",
        },
      };

    case START_DOWNLOAD:
      return {
        ...state,
        [action.payload.id]: {
          state: ""IN_PROGRESS"",
          progress: 0,
        },
      };

    case DOWNLOAD_PROGRESS:
      return {
        ...state,
        [action.payload.id]: {
          state: ""IN_PROGRESS"",
          progress: action.payload.progress,
        },
      };

    case COMPLETE_DOWNLOAD:
      return {
        ...state,
        [action.payload.id]: {
          state: ""DONE"",
          progress: 100,
        },
      };

    default:
      return state;
  }
};
</code></pre>

<p>Now comes the issue on how to manage the async dispatch of these actions using redux observable.</p>

<p>For example we could do something like this:</p>

<pre class=""lang-js prettyprint-override""><code>const downloadEpic = action$ =&gt;
  action$.ofType(START_DOWNLOAD).mergeMap(action =&gt;
    downloader
    .takeUntil(
      action$.filter(
        stop =&gt;
        stop.type === STOP_DOWNLOAD &amp;&amp;
        stop.payload.id === action.payload.id,
      ),
    )
    .map(progress =&gt; {
      if (progress === 100) {
        return completeDownload({
          id: action.payload.id
        });
      } else {
        return downloadProgress({
          id: action.payload.id,
          progress
        });
      }
    }),
  );
</code></pre>

<p>This works. However, what if we want to limit the number of active downloads that are allowed. We can replace <code>mergeMap</code> with <code>concatMap</code> to only allow one active download at a time. Or we can supply the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer"">concurrent parameter</a> to <code>mergeMap</code> and specify exactly how many executions of the inner downloader observable we want to allow at once.</p>

<p>However, this comes with the problem that we now cannot stop queued downloads.</p>

<p><a href=""https://jsbin.com/cuwitul/edit?js,output"" rel=""nofollow noreferrer"">I have created a complete working example that you can try here.</a></p>

<p>How can you limit and queue downloads using rxjs and redux observable in the most idiomatic way possible?</p>
","716662","","106909","","2017-12-13 12:42:24","2017-12-13 12:42:24","Queue and cancel events using idiomatic redux observable","<redux><rxjs><rxjs5><redux-observable>","1","3","0","","","CC BY-SA 3.0"
"47702400","1","47702477","","2017-12-07 19:28:00","","2","1928","<p>I want to apply an asynchronous transformation function on the value emitted by an observable.</p>

<pre><code>@Injectable
export class ApiService{
    constructor(private http: HttpClient){}

    getSomething(url): Observable&lt;any&gt;{
        return this.http.get(url);
    }
}
</code></pre>

<p>In the code above, I want to apply a transformation function <code>myFunc</code>, which returns a promise, on the value emitted by <code>this.http.get(url)</code>. </p>

<p>Normally I would use the map operator of RxJS, but since the transformation function returns a promise, I could not find a way to handle it.</p>

<p>For example, let my function be:</p>

<pre><code>function myFunc(value){
    return new Promise((resolve, reject) =&gt; {
        // modify the value async

        resolve(modifiedValue);

        // ...
    });
}
</code></pre>

<p>Is there an appropriate way to handle this task? I think the following is not suitable, am I right?</p>

<p><code>return this.http.get(url).map(myFunc);</code></p>

<p>Any help will be much appreciated.</p>

<p><strong>Note:</strong> I'm using RxJS 5.5.2</p>
","1392664","","1392664","","2017-12-08 00:18:49","2017-12-08 00:18:49","RxJS & Angular HttpClient: How to transform value asynchronously?","<javascript><angular><rxjs><rxjs5>","1","8","2","","","CC BY-SA 3.0"
"47702477","2","","47702400","2017-12-07 19:33:23","","3","","<p>Use the <code>mergeMap</code> operator to take in the response value, perform some modification asynchronously via another Observable operation, and then return the modified value. This operator will merge the values emitted by HttpClient and your modifier Observable and return a single Observable that emits the mutated values.</p>

<p><strong>EDIT</strong>: Including the <code>Observable.fromPromise</code> bit from @bygrace's comment for a more complete answer.</p>

<p>i.e.</p>

<p><strong>EDIT</strong>: For RxJs v5.5+</p>

<pre><code>import { pipe } from 'rxjs/util/pipe';
import { mergeMap } from 'rxjs/operators';


    @Injectable
    export class ApiService{
        constructor(private http: HttpClient){}

        getSomething(url): Observable&lt;any&gt;{
            return this.http.get(url).pipe( 
                                        mergeMap(myFunc) 
                                      );
        }

        private myFunc(x): Observable&lt;any&gt; {
            // do some asynchronous modification that returns an Observable
            return Observable.fromPromise(x);
        }
    }
</code></pre>

<p>Pre RxJs v5.5</p>

<pre><code>@Injectable
export class ApiService{
    constructor(private http: HttpClient){}

    getSomething(url): Observable&lt;any&gt;{
        return this.http.get(url)
               .mergeMap(data =&gt; {
                   // do some asynchronous modification that returns an Observable
                   return Observable.fromPromise(data);
                });
    }
}
</code></pre>

<p>See: <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap</a></p>
","2432532","","2432532","","2017-12-07 20:28:25","2017-12-07 20:28:25","","","","6","","","","CC BY-SA 3.0"
"47708391","1","","","2017-12-08 05:41:36","","0","69","<ol>
<li><strong>If subscribe isn't exist, the stream does not work?</strong></li>
<li><strong>Is it necessary to kill subscribe in cold stream?</strong> For example: operator <code>.take(1)</code> or <code>.first()</code> or common <code>.unsubscribe</code>, so other. </li>
</ol>

<p><strong>or may is it necessary to kill himself stream?</strong> <code>.complete()</code>
Or does not it affect performance in the future?</p>

<p>A simple example: <strong>Create 100 cold stream</strong></p>

<pre><code>    function test() {
       let obs = Rx.Observable.create(observer =&gt; observer.next(Date.now()));       
       obs.subscribe(v =&gt; console.log(""1st subscriber: "" + v));
       obs.subscribe(v =&gt; console.log(""2nd subscriber: "" + v));
     }     
     for(var i = 0; i &lt; 100; i++){
       test();
     }
</code></pre>
","8797294","","8797294","","2017-12-08 06:08:06","2017-12-08 09:49:36","rxjs - Is it necessary to kill cold stream?","<javascript><stream><rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"47714818","1","47715596","","2017-12-08 12:51:27","","8","1849","<p>I have searched everywhere and cannot find an answer to the following... </p>

<p>In my addItemEpic I would like to dispatch a ""loading"" action before sending the ajax request - I DO NOT want the value of the action to be returned - I just want to DO the action then return the ajax response. 
This can be achieved easily with store.dispatch() as below:</p>

<pre><code>export const addItemsEpic = (action$, store) =&gt;
  action$.ofType(ADD_ITEM)
    .do(() =&gt; store.dispatch({
        type: 'layout/UPDATE_LAYOUT',
        payload: { loading: true } 
    }))
    .switchMap(action =&gt; api.addItem(action.payload))
    .map(item =&gt; loadItem(item))
    .do(() =&gt; store.dispatch({
       type: 'layout/UPDATE_LAYOUT',
       payload: { loading: false } 
    }))
    .catch(error =&gt; Observable.of({
       type: 'AJAX_ERROR',
       payload: error,
       error: true
   }));
</code></pre>

<p>However store.dispatch() is deprecated and discouraged in redux-observable.</p>

<p>I have attempted to use almost every plausible operator and still I cannot dispatch the action without disrupting the return value in the next chained function. I thought something like te following should do it:</p>

<pre><code>action$.ofType(ADD_ITEM)
   .concatMap(action =&gt; Observable.of(
      updateLayout({loading: true}),
      api.addItem(action.payload)).last())
   .map(item =&gt; loadItem(item))
</code></pre>

<p>But unfortunately 2 problems here:</p>

<ul>
<li>no loading-action is dispatched (the value IS returned as an observable)</li>
<li>api request now returns a wrapped promise instead of a mappable value</li>
</ul>

<p>I'd really appreciate some help or advice here as I can't find any way to get this working.</p>

<p>Thanks in advance</p>
","7047719","","7047719","","2017-12-08 13:06:43","2017-12-09 00:39:28","In redux-observable - How can I dispatch an action ""mid-stream"" without returning the value of that action?","<reactjs><redux><rxjs5><redux-observable>","2","0","1","","","CC BY-SA 3.0"
"47715596","2","","47714818","2017-12-08 13:43:07","","5","","<p>The second form is on the right path. The idea is to return an <code>Observable</code> that first emits the loading action, then after the service call, emits either the <code>loaded</code> action or <code>error</code> action, and finally emits the done loading action.</p>

<pre class=""lang-js prettyprint-override""><code>const addItemEpic = action$ =&gt; action$
  .ofType(ADD_ITEM)
  .switchMap(action =&gt; { // or use mergeMap/concatMap depending on your needs
    const apiCall$ = Observable.fromPromise(api.addItem(action.payload))
      .map(item =&gt; actions.loadItem(item))
      .catch(err =&gt; Observable.of(actions.ajaxError(err)));

    return Observable.concat(
      Observable.of(actions.updateLayout(true)),
      Observable.concat(apiCall$,
        Observable.of(actions.updateLayout(false))));
  });
</code></pre>

<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromPromise"" rel=""noreferrer""><code>Observable.fromPromise()</code></a> converts a <code>Promise</code> to an <code>Observable</code></p>
","8480088","","","","","2017-12-08 13:43:07","","","","1","","","","CC BY-SA 3.0"
"47718724","1","47719331","","2017-12-08 16:49:14","","0","329","<p>I would like to create an Observable which resolves after .75 seconds. I tried doing so like this, but the Observable is resolving immediately:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { delay } from 'rxjs/operators/delay';
...
refresh(): Observable&lt;any&gt; {
  // Return an observable that resolves after .75 seconds
  return Observable.create().pipe( delay(750) );
}
</code></pre>

<p>I am using <code>rxjs</code> version 5.5.2 and <code>typescript</code> version 2.4.2</p>
","8049180","","","","","2017-12-08 17:31:13","How do I create an RxJS Observable that resolves after .75 seconds?","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47719331","2","","47718724","2017-12-08 17:24:37","","1","","<p>If you want the timer to be the source then you could do the following:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>console.log('start');
Rx.Observable.timer(750)
  .subscribe(
    x =&gt; console.log('next:', x),
    null,
    () =&gt; console.log('complete')
  );</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.2/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Here are the docs: <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-timer"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-timer</a></p>

<p>You have to actually pass something into the create method btw. If you don't I think it throws the following error: <code>Cannot read property 'subscribe' of undefined</code></p>

<p>If you want to defer returning some observable then you could do something like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>console.log('start');
Rx.Observable.create(o =&gt; { o.next('test'); o.complete(); })
  .delay(750)
  .subscribe(
    x =&gt; console.log('next:', x),
    null,
    () =&gt; console.log('complete')
  );</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.2/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><em>Sorry I used old style syntax since I couldn't get the import for the operator to work in the editor.</em></p>
","959745","","959745","","2017-12-08 17:31:13","2017-12-08 17:31:13","","","","1","","","","CC BY-SA 3.0"
"47743024","1","","","2017-12-10 20:16:58","","0","748","<p>I'm using NGRX and I want to get some values from the store, merge them into one and push to BE. </p>

<pre><code>private enrichWith(event: TwoDimensionalCategory): Observable&lt;any&gt; {
    if (event.step || event.subCategory) {
      return Observable.merge(
        this.getCampaignId().first(),
        this.getCompanyIds().first(),
        this.getCampaignTitle().first(),
        this.getSectionCode().first(),
      );
    }
    return Observable.of({});
  }
</code></pre>

<p>I merge all streams from store </p>

<pre><code> private getCampaignId() {
    return this.store.select(getCampaignId).map(campaignId =&gt; {
      return { campaignId: campaignId };
    });
  }

  private getCampaignTitle() {
    return this.store.select(getCampaignTitle).map(campaignTitle =&gt; {
      return { campaignTitle: campaignTitle };
    });
  }
  private getSectionCode() {
    return this.store.select(getSectionCode).map(sectionCode =&gt; {
      return { sectionCode: sectionCode };
    });
  }

  private getCompanyIds() {
    return this.store.select(getCompanyIds).map(companyIds =&gt; {
      return { companyIds: companyIds };
    });
  }
</code></pre>

<p>Then I want to perform merge all over the returned value:</p>

<p><code>return this.enrichWith(event)</code> //do something to merge all the items into one object.</p>

<p>I tried </p>

<pre><code>this.enrichWith(event).mergeAll().flatMap(enrichedWithData =&gt; ...)
</code></pre>

<p>but get an error:</p>

<blockquote>
  <p>TypeError: You provided an invalid object where a stream was expected.</p>
</blockquote>
","7109755","","","","","2017-12-10 20:16:58","RxJS combine multiple streams into one","<javascript><angular><rxjs><reactive-programming><rxjs5>","0","4","","","","CC BY-SA 3.0"
"47743140","1","","","2017-12-10 20:29:54","","0","163","<p>I am trying to write a test using mocha and chai for my observable methods that makes a call to a server and returns some json data. However, when I run the test I get the following error:
<strong>Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure ""done()"" is called; if returning a Promise, ensure it resolves.</strong> 
Even when I overwrite the default timeout time, I still get the above error. What am I doing wrong ? </p>

<pre><code>describe(""some test"", () =&gt; {
    let someClass: SomeClass;

    before(() =&gt; {
        someClass = new SomeClass();
    });
    ;

    it(""should meet some condition"", done =&gt; {

        let getData = someClass.getData('query')

        getData.subscribe(json =&gt; {
            json.success.should.equal(true);
            done();
        },
            done
        );

    });
});
</code></pre>
","492251","","","","","2017-12-14 06:56:56","Unit Test Rxjs 5","<testing><mocha.js><chai><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47744148","1","47744237","","2017-12-10 22:28:04","","6","29218","<p>When trying to install the latest version of RxJS,</p>
<p>I used <code>npm install rxjs</code> as explained in this documentation: <a href=""https://github.com/reactivex/rxjs"" rel=""nofollow noreferrer"">https://github.com/reactivex/rxjs</a></p>
<p>But I got these warnings:</p>
<blockquote>
<p>npm warn @angular/common@5.1.0 requires a peer of rxjs@^5.5.0 but none is installed.</p>
<p>You must install peer dependencies yourself.</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/YE9gp.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YE9gp.jpg"" alt=""enter image description here"" /></a></p>
<p>So it looks like RxJS is upgraded but not to the latest version.</p>
<p>In the output we see that there is a latest one which is RxJS 5.5.0</p>
<p>Is there any better npm command line to upgrade to the latest version ?</p>
","5377805","","-1","","2020-06-20 09:12:55","2020-04-09 15:48:25","Right way to upgrade RxJS to latest version?","<angular><npm><rxjs><upgrade><rxjs5>","3","0","4","","","CC BY-SA 3.0"
"47744237","2","","47744148","2017-12-10 22:38:27","","18","","<p><strong>EDIT 2020</strong></p>

<p>The easiest way to force upgrade any package would be to do append an <code>@latest</code> to the required package.</p>

<p>In our use case it would be </p>

<pre><code>npm install rxjs@latest
</code></pre>

<p>This would force your current setup to install the latest stable version available.</p>

<p>Bear in mind that the latest version might not always be compatible with all the libraries in use. In case a specific range is needed due to compatibility issues you should install specific versions(e.g for the use case)</p>

<pre><code>npm install rxjs@5.5.0
</code></pre>

<p>In the previous answer it was also included the -g flag. This would (as for any npm package installation) install the specified package globally in your system and not only on the current project</p>

<p><strong>Previous Answer</strong> </p>

<p>You can always try to force the version by doing </p>

<pre><code>npm install -g rxjs@5.5.0
</code></pre>

<p>Or you can have a more modern approach and use yarn :)</p>

<p><strong>NOTE</strong></p>

<p>Since the release of npm 5.x the comment about yarn is no longer necessarily true :)</p>
","9019541","","9019541","","2020-04-09 15:48:25","2020-04-09 15:48:25","","","","4","","","","CC BY-SA 4.0"
"47746524","1","47758450","","2017-12-11 04:40:07","","1","66","<p>I'm looking for a way to process events from <code>ReplaySubject.subscribe()</code> in a synchronous fashion. </p>

<pre><code>let onSomeEvent = new ReplaySubject();

onSomeEvent.subscribe(async (event) =&gt; {      
  return await this.saveEventToDb(event);
});
</code></pre>

<p>In this example, <code>saveEventToDb()</code> first checks the database whether an event with the same ID was already stored. If not, it stores it.</p>

<p>The problem is I need to account for duplicate events firing from the subject.</p>

<p>In this example, when 2 duplicate event fire back-to-back, both get added to the database because <code>saveEventToDb()</code> gets called twice immediately without waiting for the previous call to finish.</p>

<p>How can I queue these up using Rxjs?</p>
","1267778","","1033581","","2019-02-10 04:52:47","2019-02-10 04:52:47","Process observable subscribe events synchronously","<javascript><rxjs5>","1","0","","","","CC BY-SA 4.0"
"47748995","1","","","2017-12-11 08:35:45","","0","2647","<p>I have two components in my Angular 4 application, say listComponent &amp; searchComponent which have no relations. I want to invoke a function in listComponent while a search criterion is selected from searchComponent. 
Which is the best and efficient way to do this considering the performance as well?</p>

<p>Either:</p>

<p>1) I can pass output events to root and do the data changes using a data service, i.e., switch the component displaying and get the data from a common service. Here I have to call ngAfterViewChecked() or ngOnChange() every time and use some flags to get to know new Search is selected from searchComponent .</p>

<p>2) Using a rxjs/behavioralSubject in data service and set it from searchComponent and subscribe it in listComponent.</p>
","5541094","","5458520","","2017-12-11 09:04:18","2017-12-11 15:33:03","Angular , What is the best way to communicate between independent components.?","<angular><components><rxjs5><behaviorsubject>","4","1","1","","","CC BY-SA 3.0"
"47758450","2","","47746524","2017-12-11 17:43:56","","1","","<p>The following worked to process the events synchronously:</p>

<pre><code>onSomeEvent
    .map(event =&gt; {
       return Observable.defer(() =&gt; {
          return this.saveEventToDb(event);
       });
    })
    .concatAll()
    .subscribe();
</code></pre>

<p><a href=""https://www.learnrxjs.io/operators/combination/concatall.html"" rel=""nofollow noreferrer"">ConcatAll()</a>: Collect observables and subscribe to next when previous completes.</p>
","1267778","","","","","2017-12-11 17:43:56","","","","0","","","","CC BY-SA 3.0"
"47764284","1","","","2017-12-12 02:02:17","","1","3897","<p>So, I'm new to RxJS and was playing around with Angular 5, wondering how to accomplish the following:</p>

<p>Let's asume we have a form. When the page loads, we need 3 select to be populated with data from the server, so we have 3 Observables to accomplish this.</p>

<p>Now, we also have an observable for when the route params change (in that case, we have to get the requested record and populate the form):</p>

<pre><code>// These 3 guys will get the required data for each select

this.countryService.getAll().subscribe(countries =&gt; {
  this.countries = countries;
});
this.categoryService.getAll().subscribe(categories =&gt; {
  this.categories = categories;
});
this.sectorService.getAll().subscribe(sectors =&gt; {
  this.sectors = sectors;
});


// And this is for the change in url

this.route.paramMap.subscribe(params =&gt; {
  this.formDisabled = true;
  const id = params.get('id');

  // We get the resource based on the id param
  this.service.get(id).subscribe(contact =&gt; {
    this.contact = contact;

    this.form.reset(this.contact);

    this.formDisabled = false;
  }
});
</code></pre>

<p>Now, I need the callback of <code>this.service.get(id).subscribe()</code> to execute only after the 3 selects have been populated, i.e. when their respective callbacks have completed, otherwise we may end up trying to do things with the form when it's not completely built. I would like it to remain requesting the resource in parallel to the other 3 requests, but execute the callback (reset the form with it) only after the other 3 are completely done.</p>
","1664064","","1664064","","2017-12-12 08:28:18","2017-12-12 08:28:18","Execute observable after another set of Observables have finished","<angular><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"47765354","1","47765789","","2017-12-12 04:26:43","","1","4261","<p>How do I search / filter observable of type string array ? </p>

<p>For example , I have following observable</p>

<pre><code>names$ = Observable.of(['Lenovo','Dell','Toshiba','Apple','Microsoft']);
</code></pre>

<p>Now I would like to filter this observable based on what user types in the input textbox.</p>

<p>So I have following code &amp; I would like to return filtered observable based on user's searchTerm typed in the input box.</p>

<p>Please note that I am looking for client side solution. I have the data already on the clientside &amp; for some reason I cannot send search term on server to filter the data. I also understand that in this example I can directly use filter on array itself but I want to do this through observable.</p>

<p>I also tried flatmap operator to flatten the array but still was not able to return the observable in the end which should be of type string array.</p>

<p>Any help will be greatly appreciated. Thanks in advance.</p>

<p><strong>App.component.html</strong></p>

<pre><code>&lt;!-- Textbox to receive user input --&gt;
Search:&lt;input type='text' [(ngModel)]='searchTerm' (keypress)='onkeypress($event.target.value)'&gt;
&lt;p&gt;Search Term: {{searchTerm}}&lt;/p&gt;
&lt;hr&gt;

&lt;!-- Show search results here as ordered list --&gt;
&lt;ng-container *ngIf='(names$|async)?.length&gt;0'&gt;
    &lt;ol&gt;
        &lt;li *ngFor='let name of names$|async'&gt;
            {{name}}
        &lt;/li&gt;
    &lt;/ol&gt;
&lt;/ng-container&gt;
</code></pre>

<p><strong>App.component.ts</strong></p>

<pre><code>import {Component, OnInit} from '@angular/core';
import {Observable} from 'rxjs';

@Component({
    selector: 'my-app',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
    names$: Observable&lt;string[]&gt;;
    filteredNames$: Observable&lt;string[]&gt;;
    searchTerm: string;

    ngOnInit() {
        this.names$ = Observable.of(['Lenovo', 'Dell', 'Toshiba', 'Apple', 'Microsoft']);
    }

    // HOW TO IMPLEMENT THIS FUNCTION ??
    onkeypress(value) {
        console.log(value);
        this.names$ = this.names$.map(names =&gt; names.indexOf(value) &gt; 0)
        // .filter(x=&gt;{console.log(x.indexOf(value));return x.indexOf(value)&gt;0})
        //     .subscribe(
        // (data)=&gt;console.log(data),      (error)=&gt;console.log('Error'+error),
        //       ()=&gt;console.log('complete'));
    }
}
</code></pre>
","8997326","","8997326","","2017-12-12 16:36:42","2017-12-13 16:41:28","How can I filter an Observable onKeyUp?","<angular><rxjs><observable><rxjs5><flatmap>","2","2","1","","","CC BY-SA 3.0"
"47765789","2","","47765354","2017-12-12 05:20:48","","1","","<p>There are a few mistakes that you make here.</p>

<ol>
<li><p>Why do you want to map the observable to <code>names.indexOf(value) &gt; 0</code>? <code>.map()</code> literally transforms the observable, and you have just casted an observable of type <code>string</code> to type <code>boolean</code>.</p></li>
<li><p>If you want the list of <code>names</code> to change when the user are keying (onkeyup), why do you want to reassign the <code>this.names$</code> back to <code>this.names$</code> again? That will make your code work once aka work on the first key stroke only. You should have two variables, one for holding the values, the other to be bind to your <code>ngModel</code>.</p></li>
<li><p>If you want to use <code>async</code> pipe, there is no need for you to subscribe the observable in your typescript file.</p></li>
</ol>

<p>In your <code>ngOnInit()</code>, create a variable to keep track of your names:</p>



<pre><code>ngOnInit() {
    this.data$ = Observable.of(['Lenovo', 'Dell', 'Toshiba', 'Apple', 'Microsoft']);
    this.names$ = this.data$;
}
</code></pre>

<p>Assuming you are using the <code>async</code> pipe, this should be your <code>onKeyUp</code> function:</p>



<pre><code>onKeyUp(value) {
    this.names$ = this.data$
        .map(x =&gt; {
             return x.filter(y=&gt;y.toLowerCase().indexOf(value.toLowerCase())&gt;-1);
        })
}
</code></pre>

<p>Working Stackblits: <a href=""https://stackblitz.com/edit/angular-yeaer6"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-yeaer6</a></p>
","2829204","","2829204","","2017-12-13 16:41:28","2017-12-13 16:41:28","","","","5","","","","CC BY-SA 3.0"
"47765868","2","","47687819","2017-12-12 05:28:23","","4","","<p>I've been eyeing this one for a couple days but haven't had the time to give you a solid answer with complete code because it's relatively involved. So instead I'll just give you the tl;dr version that's better than nothing I hope :)</p>

<hr>

<p>My gut tells me that I would have the UI dispatch an action that represents an attempt to download rather than a true guarantee. e.g. <code>ATTEMPT_DOWNLOAD</code>. An epic would listen for this action and check if the current number of active downloads exceeds is >= the max and if so, would emit an action to enqueue the download instead of starting it.</p>

<p>Your reducers would store the download IDs of those active and download IDs of those queued up. e.g.</p>

<pre><code>{ active: ['123', '456', ...etc], queued: ['789'] }
</code></pre>

<p>Which you would use for both keeping track of active/queued specifically but also to know the counts of them <code>active.length</code>, <code>queued.length</code></p>

<p>When a download completes an epic somewhere would check if there are any queued up downloads and if yes, dequeue one. Exactly how you do that is mostly personal preference. e.g. if the epic emits <code>DEQUEUE_DOWNLOAD</code> or whatever.</p>

<p>If a cancellation action is dispatched your reducers would need to look in both <code>active</code> and <code>queued</code> and remove the ID if it exists in there. If it was in fact active and not just queued then the epic which is handling the download would be listening for the cancellation action and it would stop it and do the same dequeue check as above.</p>

<hr>

<p>This is a bit hand-wavy, but the big takeaways are these:</p>

<ul>
<li>Your UI components shouldn't know how or when things will be queued before it attempts, though it can see after the fact by looking at the redux state (e.g. to show ""download queued"" or whatever)</li>
<li>Careful not to duplicate the status of a download in multiple places. e.g. if it's active, only have one single source of truth in your store that says it is</li>
<li>epics run after the reducers, use this to your advantage.</li>
<li>There will probably be an epic who's only job is to listen for <em>true</em> download requests and perform it, without knowing anything about queueing or stuff like that. This epic will then be reused by multiple other epics. Either by calling it directly as a function or by emitting an action like your real <code>START_DOWNLOAD</code></li>
</ul>

<p>It's not always clear where business logic should lie. e.g. should the reducers just be mostly getters/setters or should they have more opinionated logic and make decisions? There aren't a lot of rules in these cases. Just try to be consistent.</p>

<p>btw this is entirely from my gut. I might have found (or you might still find) that in practice this isn't a good solution. Just giving my initial thoughts!</p>
","1770633","","1770633","","2017-12-12 18:19:47","2017-12-12 18:19:47","","","","0","","","","CC BY-SA 3.0"
"47783843","1","47817995","","2017-12-13 00:40:58","","0","747","<p>I have a problem creating the following observable.<br>
I want it to receive a predefined array of values<br>
And I want to filter by different things, and be able to work with these as individual observables.<br>
And then when it comes time to merge these filtered observables, I want to preserve the order from the original one  </p>

<pre><code>//Not sure the share is necessary, just thought it would tie it all together
const input$ = Observable.from([0,1,0,1]).share();
const ones$ = input$.filter(n =&gt; n == 1);
const zeroes$ = input$.filter(n =&gt; n == 0);

const zeroesChanged$ = zeroes$.mapTo(2);
const onesChanged$ = ones$.mapTo(3);
const allValues$ = Observable.merge(onesChanged$,zeroesChanged$);

 allValues$.subscribe(n =&gt; console.log(n));
//Outputs 3,3,2,2
//Expected output 3,2,3,2
</code></pre>

<p>EDIT: I am sorry I was not specific enough in my question.
I am using a library called cycleJS, which separates sideeffects into drivers. 
So what I am doing in my cycle is this</p>

<pre><code>export function socketCycle({ SOCKETIO }) {
  const serverConnect$ = SOCKETIO.get('connect').map(serverDidConnect);
  const serverDisconnect$ = SOCKETIO.get('disconnect').map(serverDidDisconnect);
  const serverFailedToConnect$ = SOCKETIO.get('connect_failed').map(serverFailedToConnect);
  return { ACTION: Observable.merge(serverConnect$, serverDisconnect$, serverFailedToConnect$) };
}
</code></pre>

<p>Now my problem arose when I wanted to write a test for it. I tried with the following which worked in the wrong matter(using jest)</p>

<pre><code>const inputConnect$ = Observable.from(['connect', 'disconnect', 'connect', 'disconnect']).share();
const expectedOutput$ = Observable.from([
  serverDidConnect(),
  serverDidDisconnect(),
  serverDidConnect(),
  serverDidDisconnect(),
]);
const socketIOMock = {
  get: (evt) =&gt; {
    if (evt === 'connect') {
      return inputConnect$.filter(s =&gt; s === 'connect');
    } else if (evt === 'disconnect') {
      return inputConnect$.filter(s =&gt; s === 'disconnect');
    }
    return Observable.empty();
  },
};
const { ACTION } = socketCycle({ SOCKETIO: socketIOMock });
Observable.zip(ACTION, expectedOutput$).subscribe(
  ([output, expectedOutput]) =&gt; { expect(output).toEqual(expectedOutput); },
  (error) =&gt; { expect(true).toBe(false) },
  () =&gt; { done(); },
);
</code></pre>

<p>Maybe there is another way I can go about testing it?</p>
","1898027","","1898027","","2017-12-13 11:05:10","2017-12-14 16:25:40","ReactiveX filtering on observable multiple times and merging","<javascript><rxjs><rxjs5><reactivex>","2","7","","","","CC BY-SA 3.0"
"47789748","1","47902888","","2017-12-13 09:38:21","","4","833","<p>I have a <code>product</code> which has <code>comments</code>, <code>attachments</code>, <code>images</code> attached to it. All those items are taken from a <code>ngrx</code> store which means all those items are observables. My question is how do I combine those items ?</p>

<p>Usually what I do is use :</p>

<pre class=""lang-js prettyprint-override""><code>combineLatest(selectProducts, selectProductComments, (products, comments) =&gt; {
  // attach comments to products here
})
</code></pre>

<p>However <code>combineLatest</code> works with 2 sets of observable and I have 4 of them. So what's the simplest way to go about this ?</p>

<hr>

<p>Here is more context :</p>

<p>So we display a list of <code>products</code>, when each product is clicked more info on the product are loaded and displayed in a popup. Those info contain the <code>comments</code>, <code>attachments</code> and <code>images</code>. This step can be called the <code>DEEP_LOADING</code> phase where when the user clicks on a products, the comments, attachments and images are loaded via http. </p>

<p>The user can also add new images, comments or attachments. When he does so, a <code>comment</code> with its status <code>pending</code> set to true is added to the list of comments. When the http request resolves this <code>comment</code> pending property is set to false.</p>

<p>When the user close the popup and opens a new product then the new <code>comments</code>, <code>attachments</code> and <code>images</code> are loaded. When this time he closes the popup and opens the first one he opened, the <code>comments</code> that are displayed are the ones that are loaded from the backend ( same as before) but also the pending comments if any.</p>

<p>The comment reducer might look like this: ( I say might because I'm in the process of normalizing my store, the comments are part of the product at the moment and thus I don't need to care about the pending stuff..)</p>

<pre class=""lang-js prettyprint-override""><code>export function commentReducer(state, action) {
    switch (action.type) {
        case 'SET_COMMENT':
            // when we set we have to keep the pending comments,
            // so when we open another product, then switch back to the original one
            // if the pending comment is still pending it should display as pending
            const newState = state.filter((c: AppComment) =&gt; c.pending);
            newState.push(action.payload);
            return newState;
        case 'CLEAR':
            return initialState;
    }
}
</code></pre>
","4299560","","106909","","2017-12-13 12:40:02","2017-12-20 09:38:05","Combine multiple latest version of observable, ngrx","<angular><rxjs><rxjs5><ngrx>","1","7","1","","","CC BY-SA 3.0"
"47790135","1","","","2017-12-13 09:58:30","","8","1119","<p>Please help me to fix an issue I'm struggling.</p>

<p>I have an array of Firebase object keys</p>

<pre><code>const keys = ['-Kx9pqoMWlJLbKLQcAkP', '-Kx9pqoOYlDHTJ64Was5']
</code></pre>

<p>What I'm trying to do is to get all those Firebase objects in one stream using <code>forkJoin</code>. Here's what I have:</p>

<pre><code>const obj1 = this.fbService.getObj(keys[0]);
const obj2 = this.fbService.getObj(keys[1]);

forkJoin([obj1, obj2])
    .subscribe(res =&gt; {
        console.log(res);  // &lt;-- this never happens
    };
</code></pre>

<p>fbService method is:</p>

<pre><code>getObj(key): Observable&lt;MyObj&gt; {
  return this.fb.object(`/path/to/obj/${key}`).valueChanges();
}
</code></pre>

<p>I assume that this <code>getObj</code> method doesn't work well with <code>forkJoin</code>, maybe because of <code>valueChanges</code>, am I using it correctly?</p>

<p>However:</p>

<ul>
<li><p><code>getObj</code> works fine for getting single Firebase object, like:</p>

<pre><code>this.fbService.getObj(keys[0])
    .subsribe(res =&gt; console.log(res))// &lt;-- works
</code></pre></li>
<li><p><code>forkJoin</code> works fine with simple HTTP requests, like</p>

<pre><code>const r1 = this.http.get('https://swapi.co/api/people/1');
forkJoin([r1])
    .subscribe(res =&gt; {
        console.log(res);  // &lt;-- works
    };
</code></pre></li>
</ul>

<p>So, what am I doing wrong?
My goal is to get array of objects from array of keys:</p>

<pre><code>['-Kx9pqoMWlJLbKLQcAkP', '-Kx9pqoOYlDHTJ64Was5'] =&gt; [{prop:'val'},{prop:'val2'}]
</code></pre>
","3008300","","2829204","","2017-12-13 10:27:08","2020-05-09 16:03:54","forkJoin doesn't work with AngularFire2 valueChanges","<angular><firebase><rxjs><angularfire2><rxjs5>","3","2","1","","","CC BY-SA 3.0"
"47801904","1","47803980","","2017-12-13 20:50:25","","0","126","<p>I use AngularJS (1.5) at work and created now my first Angular2 application. Now I have a little problem with observable.</p>

<p>I have a service like this (TicketService):</p>

<pre><code>import { Injectable, EventEmitter } from '@angular/core';
import { Http } from '@angular/http';
import { Globals } from '../../globals';
import {Observable} from 'rxjs/Observable';

@Injectable()

export class TicketService {

private http;
private emitter: EventEmitter&lt;any&gt;;

constructor (http: Http) {
    this.http = http;
    this.emitter = new EventEmitter();
}

findAll () {
    return this.http.get(Globals.BASE_API_URL + '/ticket');
}

emitEvent(value) {
    this.emitter.emit(this.findAll());
}

getEmit() {
    return this.emitter;
}
</code></pre>

<p>And I have a component to list all tickets (app-order-page):</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { TicketService } from '../../ticket/ticket.service';


@Component({
    selector: 'app-order-page',
    templateUrl: './order-page.component.html',
    styleUrls: ['./order-page.component.css']
})
export class OrderPageComponent implements OnInit {

    private states;
    private ticketService: TicketService;
    private tickets;
    private isPreview;

    constructor (ticketService: TicketService) {
        this.ticketService = ticketService;
    }

    ngOnInit () {            
        this.ticketService.getEmit().subscribe(value =&gt; {
            value.subscribe(v =&gt; {
                this.tickets = v.json();
            })
        });

        this.ticketService.emitEvent(true);
    }

}
</code></pre>

<p>Now I want from another component reload the list of tickets in the app-order-page:</p>

<pre><code>this.ticketService.emitEvent(true);
</code></pre>

<p>So, this example works, but its crazy. I have to do a subscribe in a subscribe. Is that a problem? Do I have other possibilities? </p>
","9095860","","5535245","","2017-12-14 00:14:07","2017-12-14 00:14:07","Angular2 - emit http.get from other component","<angular><observable><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"47803980","2","","47801904","2017-12-14 00:05:49","","1","","<p>Your issue can be resolved using Subject(instead of Emitter), Observable and switchMap(function of Observable, you can google it on how to use).
See sample code snippet below.</p>

<pre><code>findAll (): Observable&lt;any&gt; {
    return this.sampeSubject.switchMap(e =&gt; this.http.get(Globals.BASE_API_URL + '/ticket').map(resp =&gt; resp.json())); //this would return an Observable
}
reload(){
   this.sampeSubject.next();
}
</code></pre>

<p>You can then call the <strong>reload</strong> function if you want to reload the list of tickets.</p>
","9066063","","","","","2017-12-14 00:05:49","","","","0","","","","CC BY-SA 3.0"
"47808623","1","","","2017-12-14 08:10:18","","2","1809","<p>I am trying to spy on RxJS operators with Jasmine. There are different use cases in my tests where I want to be in control on what a Observable returns. To illustrate what I am trying to do I have created the example above even thought it does not make to much sense as this observable always returns the same hard coded string. Anyway it is a good example to show what I am trying to achieve:</p>

<p>Imagine I have the following Class.</p>

<pre><code>import {Observable} from 'rxjs/Observable';
import {of} from 'rxjs/observable/of';

export class AwesomeTest {

   constructor() {
   }

   getHero(): Observable&lt;string&gt; {
      return of('Spiderman');
   }
}
</code></pre>

<p>And the following test:</p>

<pre><code>import {AwesomeTest} from './awesomTest';
import {of} from 'rxjs/observable/of';
import createSpyObj = jasmine.createSpyObj;
import createSpy = jasmine.createSpy;

describe('Awesome Test', () =&gt; {

  let sut;

  beforeEach(() =&gt; {
    sut = new AwesomeTest()
  })

  fit('must be true', () =&gt; {
    // given
    const expectedHero = 'Superman'
    const asserter = {
        next: hero =&gt; expect(hero).toBe(expectedHero),
        error: () =&gt; fail()
    }
    createSpy(of).and.returnValue(of('Superman'))
    // when
    const hero$ = sut.getHero()
    // then
    hero$.subscribe(asserter)
  });
});
</code></pre>

<p>I try to spy on the Observable of operator and return a Observable with a value that I specified inside my test instead of the actual value it will return. How can I achieve this?</p>

<p>Before the new Rx Import Syntax I was able to do something like this:</p>

<p><code>spyOn(Observable.prototype,'switchMap').and.returnValue(Observable.of(message))
</code></p>
","4382345","","1000551","","2017-12-14 08:19:52","2018-10-17 19:40:15","Jasmine spy on RxJS 5.5 operators","<javascript><jasmine><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"47817995","2","","47783843","2017-12-14 16:25:40","","1","","<p>When stream is partitioned, the timing guarantees between elements in different daughter streams is actually destroyed. In particular, even if <code>connect</code> events always come before <code>disconnect</code> events at the event source, the events of the <code>connect</code> Observable won't always come before their corresponding events items in the <code>disconnect</code> Observable. At normal timescales, this race condition probably quite rare but dangerous nonetheless, and this test shows the worst case.</p>

<p>The good news is that your function as shown is just a mapper, between events and results from handlers. If you can continue this model generally over event types, then you can even encode the mapping in a plain data structure, which benefits expressiveness:</p>

<pre><code>const event_handlers = new Map({
 'connect': serverDidConnect,
 'disconnect': serverDidDisconnect,
 'connect_failed': serverFailedToConnect
});
const ACTION = input$.map(event_handlers.get.bind(event_handlers));
</code></pre>

<p><strong>Caveat</strong>: if you were reducing over the daughter streams (or otherwise considering previous values, like with <code>debounceTime</code>), the refactor is not so straightforward, and would also depend on a new definition of ""preserve order"". Much of the time, it would still be feasible to reproduce with <code>reduce</code> + a more complicated accumulator.</p>
","3925507","","","","","2017-12-14 16:25:40","","","","0","","","","CC BY-SA 3.0"
"47842003","1","47843929","","2017-12-16 02:26:55","","1","1583","<p>At the moment, I'm just trying to achieve the following: 
- I have an text input field and a button. When the button is clicked get the value from the input (via rxjs).</p>

<p>Below is what I have setup. Currently have an Observable of the button click and I have the input text field currently updating a BehaviorSubject. What I'm struggling to execute or get my head around is, when a value is emitted to the click stream to then 'switch' to the Input stream so that is what is passed to a subscription is the input value.</p>

<p>Currently the value being passed to the subscription is always of BehaviorSubject type (originally Observable when I wasn't using a BS).</p>

<pre><code>@Component({
  selector: 'app-global-dashboard',
  template: `
     &lt;input type=""text"" name="""" id=""new-country-input"" 
     (keyup)=""countryInput$.next($event.target.value)""&gt;
     &lt;button (click)=""handleAddCountryClick()"" id=""add-country""&gt;Add 
     country&lt;/button&gt;

     &lt;ul&gt;
      &lt;li *ngFor=""let tile of tiles""&gt;
       {{tile.name}}
      &lt;/li&gt;
     &lt;/ul&gt;
  `,
  styleUrls: ['./global-dashboard.component.scss']
})
export class GlobalDashboardComponent implements OnInit, AfterViewInit 
{

   public countryInput = '';
   public countryInput$ = new BehaviorSubject&lt;string&gt;('');
   public tiles: object[];

   constructor(private http: Http) {
     this.tiles = [];
   }

   ngAfterViewInit() {

      const button = document.querySelector('#add-country');
      const addClick$ = Observable.fromEvent(button, 'click');

      const inputAfterClick$ = addClick$
         .map(() =&gt; this.countryInput$);

      inputAfterClick$.subscribe((country) =&gt; {
         console.log('country', country); // &lt; This is always BS type rather than the underlying string
         this.doRequest(country);
      });
  }
</code></pre>
","1900008","","1900008","","2017-12-16 08:21:29","2017-12-16 08:33:25","Rxjs: how to switch from one observable to another mid stream","<angular><rxjs><rxjs5>","2","1","1","","","CC BY-SA 3.0"
"47843929","2","","47842003","2017-12-16 08:33:25","","2","","<p>change map to flatMap </p>

<pre><code>  const inputAfterClick$ = addClick$
     .flatMap(() =&gt; this.countryInput$);
</code></pre>
","8618350","","","","","2017-12-16 08:33:25","","","","1","","","","CC BY-SA 3.0"
"47870632","1","47874011","","2017-12-18 14:33:18","","4","1063","<p>Warning: RxJS newb here.</p>

<p>Here is my challenge:</p>

<ol>
<li>When an <code>onUnlink$</code> observable emits...</li>
<li>Immediately start capturing values from an <code>onAdd$</code> observable, for a maximum of 1 second (I'll call this partition <code>onAddBuffer$</code>).</li>
<li>Query a database (creating a <code>doc$</code> observable) to fetch a model we'll use to match against one of the <code>onAdd$</code> values</li>
<li>If one of the values from the <code>onAddBuffer$</code> observable matches the <code>doc$</code> value, do not emit</li>
<li>If none of the values from the <code>onAddBuffer$</code> observable matches the <code>doc$</code> value, or if the <code>onAddBuffer$</code> observable never emits, emit the <code>doc$</code> value</li>
</ol>

<p>This was my best guess:</p>

<pre class=""lang-js prettyprint-override""><code>// for starters, concatMap doesn't seem right -- I want a whole new stream
const docsToRemove$ = onUnlink$.concatMap( unlinkValue =&gt; {

  const doc$ = Rx.Observable.fromPromise( db.File.findOne({ unlinkValue }) )

  const onAddBuffer$ = onAdd$
    .buffer( doc$ ) // capture events while fetching from db -- not sure about this
    .takeUntil( Rx.Observable.timer(1000) );

  // if there is a match, emit nothing. otherwise wait 1 second and emit doc
  return doc$.switchMap( doc =&gt;
    Rx.Observable.race( 
      onAddBuffer$.single( added =&gt; doc.attr === added.attr ).mapTo( Rx.Observable.empty() ),
      Rx.Observable.timer( 1000 ).mapTo( doc )
    )
  );
});

docsToRemove$.subscribe( doc =&gt; {
  // should only ever be invoked (with doc -- the doc$ value) 1 second
  // after `onUnlink$` emits, when there are no matching `onAdd$`
  // values within that 1 second window.
})
</code></pre>

<p>This always emits <code>EmptyObservable</code>. Maybe it's because <code>single</code> appears to emit <code>undefined</code> when there is no match, and I'm expecting it not to emit at all when there is no match? The same thing happens with <code>find</code>.</p>

<p>If I change <code>single</code> to <code>filter</code>, nothing ever emits.</p>

<p>FYI: This is a rename scenario with file system events -- if an <code>add</code> event follows within 1 second of an <code>unlink</code> event and the emitted file hashes match, do nothing because it's a <code>rename</code>. Otherwise it's a true <code>unlink</code> and it should emit the database doc to be removed.</p>
","368708","","368708","","2017-12-18 16:59:00","2017-12-18 18:02:34","RxJS: How to combine multiple nested observables with buffer","<javascript><rxjs><observable><rename><rxjs5>","1","2","","","","CC BY-SA 3.0"
"47872897","1","47873605","","2017-12-18 16:48:06","","0","641","<p>before posting this i went to many other similar questions and not able to find solutions. like  <a href=""https://stackoverflow.com/questions/39373645/angular-2-inject-authorization-token-before-each-http-request"">Angular 2 - Inject authorization token before each Http request</a></p>

<p>I am using AWS session which provides me Authorization token for makeing HTTP request. Now getting session can be asynchronous operation depending on need to refresh token. </p>

<p><strong>Problem:</strong>
I am not able to chain getting session and then making HTTP calls. </p>

<p><strong>Versions</strong> Angular 5, RxJs 5.5.2</p>

<p><strong>AuthService's get session function.</strong> </p>

<pre><code>    getSession(): Observable&lt;any&gt; {
        const sessionOb = new Subject&lt;CognitoUserSession&gt;();
        // AysnFn4session is a callback implementation
        AysnFn4session((err, session) =&gt; { 
                console.log('Found Session');
                sessionOb.next(session);
                sessionOb.complete();
            });
        return sessionOb;
    }
</code></pre>

<p><strong>API service's get function - Trail 1</strong></p>

<pre><code>get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
    return this._authService.getSession().switchMap((session) =&gt; {
      console.log('dasdasd');
      let token = '';
      if (session) {
        token = session.getIdToken().getJwtToken();
        options = options || {};
        options.headers = options.headers || new Headers();
        options.headers.append('Authorization', token);
      }
      return this._http.get(url, options);
    });
  }
</code></pre>

<p><strong>API service's get function - Trail 2</strong></p>

<pre><code>get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; {
return this._authService.getSession().pipe(mergeMap((session) =&gt; {
  console.log('So what??');
  let token = '';
  if (session) {
    token = session.getIdToken().getJwtToken();
    options = options || {};
    options.headers = options.headers || new Headers();
    options.headers.append('Authorization', token);
  }
  return this._http.get(url, options);
}));
}
</code></pre>

<p><strong>Here how I am calling this api.</strong></p>

<pre><code>getItemInfo(item) {
return this._apiHttp.get('/assets/data/item.json')
  .map(res =&gt; {
    console.log(res);
    return res.json();
  })
  .subscribe(data =&gt; console.log(data),
     err =&gt; console.log(err), 
     () =&gt; console.log('done'));
}
</code></pre>

<p>Now the problem is in both the cases console just prints.and not http call is being made.</p>

<pre><code>Found Session
done
</code></pre>

<p>I am not able understand where i am making mistake in using mergermap of switchmap in order to get the http request completed. </p>
","1495124","","1495124","","2017-12-18 17:17:05","2017-12-18 19:41:04","Angular getting Authorization token asynchronously before HTTP calls","<angular><http><rxjs><rxjs5><switchmap>","1","2","","","","CC BY-SA 3.0"
"47873605","2","","47872897","2017-12-18 17:34:47","","1","","<p>The error lies in <code>getSession()</code>. Your AsynFn4session callback is completing before the observer to the subject is listening. (An observer of a subject only receives values that are emitted after it has subscribed). This means the observer never receives the subject emit, so the observable sequence does not continue. I would use an observable instead of a subject</p>

<pre><code>getSession(): Observable&lt;any&gt; {
    return new Observable(observer =&gt; {
        AsynFn4session((err, session) =&gt; {
            observer.next(session);
            observer.complete();
        });
    });
}
</code></pre>
","7176268","","7176268","","2017-12-18 19:41:04","2017-12-18 19:41:04","","","","3","","","","CC BY-SA 3.0"
"47874011","2","","47870632","2017-12-18 18:02:34","","3","","<p>This is my guess how you could do this:</p>

<pre><code>onUnlink$.concatMap(unlinkValue =&gt; {
  const doc$ = Rx.Observable.fromPromise(db.File.findOne({ unlinkValue })).share();
  const bufferDuration$ = Rx.Observable.race(Rx.Observable.timer(1000), doc$);
  const onAddBuffer$ = onAdd$.buffer(bufferDuration$);

  return Observable.forkJoin(onAddBuffer$, doc$)
    .map(([buffer, docResponse]) =&gt; { /* whatever logic you need here */ });
});
</code></pre>

<p>The <code>single()</code> operator is a little tricky because it emits the item that matches the predicate function only <strong>after the source Observable completes</strong> (or emits an error when there're two items or no matching items).</p>

<p>The <code>race()</code> is tricky as well. If one of the source Observables completes and doesn't emit any value <code>race()</code> <strong>will just complete and not emit anything</strong>. I reported this some time ago and this is the correct behavior, see <a href=""https://github.com/ReactiveX/rxjs/issues/2641"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2641</a>.<br>
I guess this is what went wrong in your code.</p>

<p>Also note that <code>.mapTo(Rx.Observable.empty())</code> will map each value into an instance of Observable. If you wanted to ignore all values you can use <code>filter(() =&gt; false)</code> or the <code>ignoreElements()</code> operator.</p>
","310726","","","","","2017-12-18 18:02:34","","","","0","","","","CC BY-SA 3.0"
"47888113","1","","","2017-12-19 13:29:14","","0","406","<p>I'm using Angular 5 and RXJS 5.5.5 together with ngrx/store to load reference data for my application. I can successfully load the data through an ngrx effect that takes an action with an id as payload, <code>map</code> it and then make a call to my service function. My problem is that I need the id used in the service call, after it has been done. I can't figure out how to access it later in the chain. I've tried to use <code>mergeMap</code> as that felt logical to me, but with no success.</p>

<p>How can I access <code>id</code> where I indicated in the code below?</p>

<pre><code>@Effect()
loadReferences$ = this.actions$
  .ofType(LOAD_REFERENCES)
  .pipe(
    map((action: LoadReferences) =&gt; action.payload),
    switchMap((id) =&gt; this.service.loadReferences(id).pipe(
      map((references) =&gt; {
        // How can I access 'id' here?
        return new LoadReferencesSuccessful(references);
      }),
      catchError((err, caught) =&gt; {
        return LoadReferencesFailed(caught);
      })
    ))
  );
</code></pre>
","1447173","","","","","2017-12-19 13:29:14","Access previous arguments in RXJS operator chain","<angular><rxjs><rxjs5><ngrx><ngrx-store>","0","4","","","","CC BY-SA 3.0"
"47890516","1","","","2017-12-19 15:46:08","","0","98","<h2>1st example</h2>

<ul>
<li>there's a input#input in the dom and a div#field to present what typed in the inputElem</li>
<li><p>then subscribe</p>

<ol>
<li>when I typed {..v.a..b.l.e}, the div#field s display <code>value</code> after 5s as expect</li>
<li>then I stop for a while then type {.of..this.} in the input</li>
<li>IMO the delay already execute so the <code>valueofthis</code> should be present immediately, but actually not. what' s the problem?</li>
</ol></li>
</ul>

<h2>in the 2nd example</h2>

<p>what's the different between these two example?</p>

<pre><code>const Observable = Rx.Observable

const inputElem = document.getElementById('input')
const fieldElem = document.getElementById('field')
const inputTexts = Observable.fromEvent(inputElem, 'input')
                              .map(e =&gt; e.target.value)
                              .delay(5000)



inputTexts.subscribe(x=&gt; fieldElem.textContent=x , 
                           ()=&gt; {},
                           ()=&gt; {console.log('completed')})


//2.
   var values = Observable.of(1,2,4,8)
                          .map(v =&gt; 2*v)
                          .delay(4000)

   values.subscribe(x =&gt; console.log(x))
</code></pre>
","7576088","","7576088","","2017-12-20 00:43:09","2017-12-20 03:40:28","What does the delay mean in rxjs?","<javascript><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"47902843","1","47903465","","2017-12-20 09:36:26","","5","2050","<p>I am trying share data between sibling components and do this via a shared service. When the first component loads, it retrieves a list of Servers from my API and fills a select-box with all the retrieved servers. Now I want to notify my other component when the user selected a new Server so I can display it's details. </p>

<p>This is my service: </p>

<pre><code>@Injectable()
export class DashboardService {
    servers: Server[] = [];
    selectedServer = new BehaviorSubject&lt;Server&gt;(null);

    setServers(servers: Server[]) {
        this.servers = servers;
    }

}
</code></pre>

<p>Component with the select-box:</p>

<pre><code>@Component({
  selector: 'app-servers-select',
  template: `
    &lt;div class=""form-group""&gt;
      &lt;label&gt;Server&lt;/label&gt;
      &lt;select class=""form-control"" [(ngModel)]=""this.dashboardService.selectedServer"" (ngModelChange)=""change($event)""&gt;
        &lt;option disabled&gt;-- Select server --&lt;/option&gt;
        &lt;option *ngFor=""let server of servers"" [ngValue]=""server""&gt;{{server.Name}}&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;`,
  styleUrls: ['./servers-select.component.css'],
  providers: [ServerService]
})
export class ServersSelectComponent implements OnInit {
  servers: Server[] = [];

  constructor(private serverService: ServerService, private dashboardService: DashboardService) { }
  ngOnInit() {
    this.serverService
      .getServers()
      .subscribe(s =&gt; {
        this.servers = s;
        this.dashboardService.setServers(s);
        console.log(s);
      },
      e =&gt; console.log(e));

  }

  // todo: pass to dashboard component
  public change = (event: any) =&gt; {
    console.log(event);
    this.dashboardService.selectedServer.next(event);
  }

}
</code></pre>

<p>Detail component: </p>

<pre><code>@Component({
  selector: 'app-server-details',
  template: `
  &lt;section&gt;
  &lt;div class=""form-group""&gt;
    &lt;label&gt;Description&lt;/label&gt;
    &lt;input type=""text"" [(ngModel)]=""server""&gt;
  &lt;/div&gt;
&lt;/section&gt;
  `,
  styleUrls: ['./server-details.component.css']
})
export class ServerDetailsComponent implements OnInit {

  private server: Server = null;

  constructor(private dashboardService: DashboardService) { }

  ngOnInit() {
    this.dashboardService.selectedServer.subscribe((value: Server) =&gt; {
      console.log(value + 'lalalal');
      this.server = value;
    });
  }

}
</code></pre>

<p>When I select a new Server, the change() method gets called correctly, but throws the following error in the console:</p>

<blockquote>
  <p>ERROR TypeError: _this.dashboardService.selectedServer.next is not a function
      at ServersSelectComponent.change (servers-select.component.ts:39)</p>
</blockquote>

<p>The subscribe seems to work already since I get 'nulllalalal' in my console. What am I missing?</p>

<p>EDIT: 
- I am using angular 5 and rxjs 5.5.2
- In my DashboardService, I import BehaviorSubject as follows:</p>

<pre><code>import { BehaviorSubject } from 'rxjs/BehaviorSubject';
</code></pre>
","6023540","","310726","","2017-12-20 10:35:34","2017-12-20 10:35:34","BehaviorSubject: next is not a function","<javascript><angular><typescript><rxjs><rxjs5>","1","7","2","","","CC BY-SA 3.0"
"47902888","2","","47789748","2017-12-20 09:38:05","","2","","<p><code>combineLatest</code> can take X arguments. You can pass as many as you want.</p>

<p>For example:</p>

<pre><code>combineLatest(v1$, v2$, v3$, v4$, (v1, v2, v3, v4) =&gt; {
  console.log(v1, v2, v3, v4);
})
</code></pre>
","2398593","","","","","2017-12-20 09:38:05","","","","0","","","","CC BY-SA 3.0"
"47902958","1","","","2017-12-20 09:41:09","","0","862","<p>I have reducer whith action which can create new property in state. </p>

<p>app.module.ts</p>

<pre><code>import { appReducers } from './app.reducers';

NgModule( {
    imports: [
    //.... standart modules
    StoreModule.forRoot( appReducers ),
</code></pre>

<p>app.reducers.ts</p>

<pre><code>import * as fromGadgetReducer from './gadgets/gadget.reducer';

export interface State {
    gadgets:        fromGadgetReducer.State;
}

export const appReducers = {
    gadgets:        fromGadgetReducer.reducer,
};
</code></pre>

<p>gadget.reducer.ts</p>

<pre><code>import * as gadgetActions from './gadget.actions';

export interface State {
    dummy: any;
}

const initialState: State = {
    dummy: ''
};

export function reducer( state = initialState, action: gadgetActions.AllTypes ): State {
    switch ( action.type ) {

        case gadgetActions.SET_PROPERTY:
            const newState = { ...state };
            newState[ action.propertyName ] = action.value;
            return newState;
    }
}
</code></pre>

<p>gadget.actions.ts</p>

<pre><code>export const SET_PROPERTY       = '[ Gadget ] Set property';

export class SetProperty implements Action {
    readonly type = SET_PROPERTY;

    constructor( public propertyName: string, public value: any ) {
    }
}

export type AllTypes = SetProperty;
</code></pre>

<p>Now when i will call action from Angular5 component</p>

<pre><code>this.store.dispatch( new SetProperty( 'newProp', 'value' ) );
</code></pre>

<p>state will looks like { dummy:'', newProp:'value' }.</p>

<p>My next step - subscribing to changes for that property. But here i have problem. When i subscribing from Angular 5 component, that property not exists in state. </p>

<pre><code>@Component( {
     //standart stuff
} )
export class GadgetComponent implements OnInit{
    @Input() propName: string = ;

    constructor( private store: Store&lt;State&gt;) {
    }

    ngOnInit(){

        this.store.dispatch( new SetProperty( this.propName, '' ) );

        this.store.select( state =&gt; state.gadgets[this.propName]).subscribe( value =&gt; {
            // Problem: value === undefined
            //do some action 
       });
    }
}
</code></pre>

<p><strong>My Question:</strong> How i can check existing property in store, create if not exists and subscribe to that property? 
I try next, but it is not working: </p>

<pre><code>this.store.select( state =&gt; state.gadgets.newProp ).take( 1 )
    .subscribe( state =&gt; {
        if ( typeof state === 'undefined' ) {
            // create property in state
            this.store.dispatch( new SetProperty( 'newProp', '' ) );
        }
        this.store.select(state =&gt; state.gadgets.newProp).subscribe( value =&gt; {
            // Problem: value === undefined
            //do some action 
        });
     } );
</code></pre>
","4116156","","4116156","","2017-12-20 12:04:35","2017-12-20 12:04:35","@ngrx/store and Angular 5. How create property in store if not exist and subscribe to changes","<angular><rxjs><rxjs5><ngrx-store><ngrx-store-4.0>","0","8","","","","CC BY-SA 3.0"
"47903465","2","","47902843","2017-12-20 10:08:33","","6","","<p>In <code>ServersSelectComponent</code>'s template you have:</p>

<pre><code>[(ngModel)]=""this.dashboardService.selectedServer""
</code></pre>

<p>This overrides the <code>selectedServer</code> service property with a value of one of the options.</p>

<p>If you want to emit changes via a RxJS Subject you definitely don't want to be using <code>[(ngModel)]</code> and trigger the change manually with <code>(change)</code> event listener like <code>(change)=""change($event)""</code>.</p>
","310726","","310726","","2017-12-20 10:18:50","2017-12-20 10:18:50","","","","6","","","","CC BY-SA 3.0"
"47910894","1","47910980","","2017-12-20 16:54:36","","2","283","<p>For example, if you have an observable <code>from(['a', 'b'])</code>, how to get an observable that emits <code>[0, 'a']</code> and <code>[1, 'b']</code>?</p>

<p>I have tried <code>from('a', 'b').pipe(zip(range(0, Number.POSITIVE_INFINITY)))</code>, but this creates an infinite loop: if you try <code>Rx.Observable.from(['a', 'b']).zip(Rx.Observable.range(0, Number.POSITIVE_INFINITY)).do(console.log).subscribe()</code> in the console (tip: the page <a href=""http://reactivex.io/rxjs/manual/overview.html"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/manual/overview.html</a> has Rx already imported), this will cause the page to hang (the <code>range</code> is pushing values indefinitely). In my context (working with IndexedDB) I can't use an async scheduler, and anyway it won't make sense from the point of view of performance.</p>

<p>I worked around this by creating a custom operator</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { map } from 'rxjs/operators';

export const enumerate = &lt;T&gt;(source: Observable&lt;T&gt;) =&gt; {
  let index = 0;
  return source.pipe(map(source =&gt; ({ value: source, index: index++ })));
};
</code></pre>

<p>but am I missing a simpler solution? It's just strange that RxJS has this gotcha in it...</p>
","7612287","","310726","","2017-12-21 06:49:00","2017-12-21 06:49:00","How to enumerate a sync observable?","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47910968","1","","","2017-12-20 16:58:53","","0","55","<p>I'm interested in using rxjs5 in angular5 to debounce input, but using <code>$event</code> from, for example <code>keyup</code>, as opposed to using <code>valueChanged</code> and hard-assigning it to a component (as seems to be the case with so many examples).</p>

<p>In the example below, let's say I want to use <code>locsearchTerm</code> for further processing;</p>

<pre><code>querySearchTerm(event){
  let searchTerm : Observable&lt;string&gt; = event.target.value;
  let locsearchTerm  =  searchTerm
                          .distinctUntilChanged()
                          .debounceTime(4000)
                          //... etc, etc
}
</code></pre>

<p>Despite the fact I'm binding to <code>(keyup)=querySearchTerm(event)</code> in my templates input element, and assigning <code>searchTerm</code> as an Observable string, the error <code>searchTerm.distinctUntilChanged is not a function</code> is returned.</p>

<p>Could someone explain why something like this doesn't work, and if possible provide a solution?</p>
","1099053","","","","","2017-12-20 17:16:57","Debouncing based on $event","<rxjs5><angular5>","1","0","","","","CC BY-SA 3.0"
"47910980","2","","47910894","2017-12-20 16:59:29","","4","","<p>Many operators keep counting the <code>index</code> for you which is passed to the callback function as another parameter:</p>

<pre><code>from(['a', 'b']).pipe(
  map((value, index) =&gt; [ index, value ]))
);
</code></pre>

<p>Or if you want to emit objects:</p>

<pre><code>map((value, index) =&gt; ({ index, value }))
</code></pre>
","310726","","","","","2017-12-20 16:59:29","","","","0","","","","CC BY-SA 3.0"
"47928118","1","","","2017-12-21 15:31:46","","0","170","<p>I created two observables from a database: </p>

<pre><code>const roomData$ = estab
      .query()
      .where('estab.type', 'like', 'rooms')
      .then((rooms) =&gt; {
        rooms.forEach((room) =&gt; {
          observer.next(room.data);
        });
      });
  }).map(data =&gt; ({
    roomsData: [
      ...data.rooms,
    ],
  }));
const hotelData$ = Observable.create((observer) =&gt; {
        estab
          .query()
          .where('estab.type', 'like', 'hotels')
          .then((hotels) =&gt; {
            hotels.forEach((hotel) =&gt; {
              observer.next(hotel.data);
            });
          });
      }).map(data =&gt; ({
        hotelsData: [
          ...data.hotels,
        ],
      }));  
const hotelContentData$ = Observable.concat(roomData$, hotelData$);
hotelContentData$.subscribe((data) =&gt;  {
    fs.appendFile('data.json', (err) =&gt; { 
         if (err) throw err;
         console.log('file has been appended!);
   }      
})
</code></pre>

<p>In the <code>data.json</code> file I found only the data received from the <code>roomData$</code> observable. I change the order in <code>Observable.concat(hotelData$, roomData$)</code> and now I get the data of hotel observable. Why only one Observable is executed? How can I execute both of them and get data from <code>hotelData$</code> and <code>roomData$</code>?</p>
","6548980","","","","","2017-12-21 18:32:28","Unable to receive all data when concat two observables in rxjs","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"47947830","1","47948295","","2017-12-22 21:58:21","","1","555","<p>So I am trying to utilize rxjs's <strong>Observable.webSocket</strong> in a node.js environment. I saw from the docs and <a href=""https://stackoverflow.com/questions/36855367/rxjs5-no-websocket-constructor-can-be-found"">this</a> stack overflow post that it is required that I provide my own version of websocket. The problem I'm coming across is that both of the examples provided indicate a <strong>WebSocketSubject</strong>, but they do not mention where this comes from. </p>

<pre><code>const ws = require('nodejs-websocket');
const Rx = require('rxjs/Rx');
const WebSocketSubject = require('rxjs/observable/dom/WebSocketSubject');

socket = new WebSocketSubject({url: 'ws://....', WebSocketCtor: ws.w3cwebsocket});

const marketSocket$ = Rx.Observable.webSocket('ws://....');
</code></pre>

<p>This was my attempt at retrieving the necessary WebSocketSubject, but I just get an error telling me that ""WebSocketSubject is not a constructor"". Is there something painfully obvious I'm missing? If you could share a working solution providing a valid websocket constructor(with all needed references provided) along with an explanation as to what I'm doing wrong that would be wonderful!</p>
","3278243","","","","","2017-12-22 23:02:40","rxjs5 - WebSocketSubject is not a constructor","<javascript><node.js><websocket><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"47948295","2","","47947830","2017-12-22 23:02:40","","2","","

<p>The call to <code>require</code> will return the module that contains the <code>WebSocketSubject</code>, so your require call should look like this:</p>

<pre class=""lang-js prettyprint-override""><code>const WebSocketSubject = require('rxjs/observable/dom/WebSocketSubject').WebSocketSubject;
</code></pre>

<p>Or like this:</p>

<pre class=""lang-js prettyprint-override""><code>const { WebSocketSubject } = require('rxjs/observable/dom/WebSocketSubject');
</code></pre>
","6680611","","","","","2017-12-22 23:02:40","","","","3","","","","CC BY-SA 3.0"
"47956110","1","","","2017-12-23 21:19:50","","0","49","<p><strong>The idea</strong></p>

<p>I have a search bar which will search for text when either: </p>

<ol>
<li>Term longer than 2 characters is entered into search input</li>
<li>Search button is pressed</li>
</ol>

<p>My code right now is:</p>

<pre><code>const input = document.querySelector('input');
const button = document.querySelector('button');

const input$ = Observable.fromEvent(input, 'keyup')
  .map(e =&gt; e.target.value)
  .distinctUntilChanged()
  .debounceTime(200)
  .filter(val =&gt; val.length &gt; 2);

const button$ = Observable.fromEvent(button, 'click');

Observable.zip(button$, input$, (butt, inp) =&gt; false)
  .subscribe(console.log);
</code></pre>

<p>However this only console logs when I do both. How can I have each of the events fire off console.log independent of each other while the stream is combined? Is it event possible to have them as part of the same stream?</p>
","5716739","","","","","2017-12-23 21:19:50","Multi input independent rxjs stream","<rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"47961799","1","47997799","","2017-12-24 15:20:27","","-2","44","<p>I have a simple question as I see it, I just don't have enough experience with Rx. </p>

<pre><code>ngOnInit() {
this.agentService.getAllAgents().subscribe((agents: Agent[]) =&gt; {
  this.agents = agents.sort((x: Agent, y: Agent) =&gt;
    Number(new Date(x.date)) - Number(new Date(y.date)));

  for (const agent of this.agents) {
    forkJoin(this.geoLocator.find(agent.address)).subscribe(results =&gt; {
      for (const coordinates of results) {
        agent.distance = this.getDistance(&lt;Coordinates&gt;environment.google.COORDINATES, coordinates, Unit.km);
      }
    });
  }
  console.log(this.agents[0]);
  console.log(JSON.stringify(this.agents[0]); 
});
</code></pre>

<p>}</p>

<p><a href=""https://i.stack.imgur.com/xslUa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xslUa.png"" alt=""enter image description here""></a></p>

<p>This is the result I get. </p>

<p>The question is how and why?</p>
","586439","","","","","2017-12-27 19:45:04","Multiple Observables within Observable not resolved as expected","<angular><observable><rxjs5>","1","3","","","","CC BY-SA 3.0"
"47965245","1","47965405","","2017-12-25 02:20:05","","1","634","<p><a href=""https://i.stack.imgur.com/QgB8l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QgB8l.png"" alt=""enter image description here""></a></p>

<p>I have two API to get menu data on Angular5, but I don't know if I use nested subscribe that getSecondMenu function is the correct way of RxJs. Does anyone have any idea, below is expected result and sample code:</p>

<p><code>console.log:
1. get firstMenuList
2. all done
3. get secondMenu * 3
</code></p>

<p><a href=""https://jsfiddle.net/e8dn3ggp/16/"" rel=""nofollow noreferrer"">open on jsFiddle</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>getFirstMenu$()
  .do(firstMenuList =&gt; {
    console.log('get firstMenuList');
  })
  .do(firstMenuList =&gt; {
    firstMenuList.forEach(firstMenu =&gt; {
      // nested subscribe : bind to child property, let Angular auto-generate second Menu in HTML
      getSecondMenu$(firstMenu.ID).subscribe((secondMenu) =&gt; {
        firstMenu.child = secondMenu;
        console.log('get secondMenu');
      });
    })
  })
  .subscribe((menuList) =&gt; {
    console.log('all done' );
  });


function getFirstMenu$() {
  return Rx.Observable.of([{
    ID: 'menu1',
    child: null
  }, {
    ID: 'menu2',
    child: null
  }, {
    ID: 'menu3',
    child: null
  }, ]);
}

function getSecondMenu$(menuID) {
  let source = null;
  switch (menuID) {
    case 'menu1':
      source = [{
        ID: 'subMenu1-1',
      }];
      break;
    case 'menu2':
      source = [{
        ID: 'subMenu2-1',
      }];
      break;
    default:
      source = [];
      break;
  }
  const delayTime = ((Math.random() * 20) + 5) * 120;
  return Rx.Observable.of(source).delay(delayTime);
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.8/dist/global/Rx.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<hr>

<h1>Conclusion</h1>

<p>thanks, @Fan Cheung talk a lot about how to combine multiple observable, to summarize you have two way to do that</p>

<p><a href=""https://i.stack.imgur.com/E8SjA.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/E8SjA.jpg"" alt=""enter image description here""></a></p>

<h2>use callback</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// componnet
class myComponent {
  getMenu() {
    new sharedService().getMenu({
      getFirstMenuList: () =&gt; {
        console.log('render first menu to template...')
      }
    })
  }
}

// shared service
class sharedService {
  getMenu(callback) {
    this.getFirstMenu$()
      .mergeMap(firstMenuList =&gt; {
        console.log('get first menu');
        //
        if (callback.getFirstMenuList) {
          callback.getFirstMenuList(firstMenuList);
        }

        return Rx.Observable.from(firstMenuList);
      })
      .mergeMap(firstMenu =&gt; this.getSecondMenu$(firstMenu.ID), (firstMenu, secondMenu) =&gt; {
        //
        console.log('get second menu');
        //
        firstMenu.child = secondMenu
        return firstMenu;
      })
      .reduce((acc, curr) =&gt; acc.concat(curr), [])
      .subscribe((menuList) =&gt; {
        console.log('all done');
      });
  }

  getFirstMenu$() {
    return Rx.Observable.of([{
      ID: 'menu1',
      child: null
    }, {
      ID: 'menu2',
      child: null
    }, {
      ID: 'menu3',
      child: null
    }, ]);
  }

  getSecondMenu$(menuID) {
    let source = null;
    switch (menuID) {
      case 'menu1':
        source = [{
          ID: 'subMenu1-1',
        }];
        break;
      case 'menu2':
        source = [{
          ID: 'subMenu2-1',
        }];
        break;
      default:
        source = [];
        break;
    }
    const delayTime = ((Math.random() * 20) + 5) * 120;
    return Rx.Observable.of(source).delay(delayTime);
  }
}

// getTemplate
new myComponent().getMenu();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.8/dist/global/Rx.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<h2>return other function to subscribe</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// componnet
class myComponent {
  getMenu() {
    new sharedService().getMenu().subscribe(() =&gt; {
        console.log('render first menu to template...');      
    })
  }
}

// shared service
class sharedService {
  getMenu() {
    return this.getFirstMenu$()
      .mergeMap(firstMenuList =&gt; {
        console.log('get first menu');
        return Rx.Observable.from(firstMenuList);
      })
      .mergeMap(firstMenu =&gt; this.getSecondMenu$(firstMenu.ID), (firstMenu, secondMenu) =&gt; {
        //
        console.log('get second menu');
        //
        firstMenu.child = secondMenu
        return firstMenu;
      })
      .reduce((acc, curr) =&gt; acc.concat(curr), [])
      .do((menuList) =&gt; {
        console.log('all done');
      });
  }

  getFirstMenu$() {
    return Rx.Observable.of([{
      ID: 'menu1',
      child: null
    }, {
      ID: 'menu2',
      child: null
    }, {
      ID: 'menu3',
      child: null
    }, ]);
  }

  getSecondMenu$(menuID) {
    let source = null;
    switch (menuID) {
      case 'menu1':
        source = [{
          ID: 'subMenu1-1',
        }];
        break;
      case 'menu2':
        source = [{
          ID: 'subMenu2-1',
        }];
        break;
      default:
        source = [];
        break;
    }
    const delayTime = ((Math.random() * 20) + 5) * 120;
    return Rx.Observable.of(source).delay(delayTime);
  }
}

// getTemplate
new myComponent().getMenu();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://npmcdn.com/@reactivex/rxjs@5.0.0-beta.8/dist/global/Rx.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","7291379","","7291379","","2018-01-09 01:34:22","2018-01-09 01:34:22","*RxJs* How to combine multiple ajax to one observable that doesn't require sequence","<javascript><angular><rxjs><rxjs5>","1","2","1","","","CC BY-SA 3.0"
"47965405","2","","47965245","2017-12-25 03:06:24","","1","","<p>try this</p>

<pre><code>getFirstMenu$()
.map(firstMenuList =&gt; Observable.from(firstMenuList))
.flatMap(firstMenu=&gt; getSecondMenu$(firstMenu.ID))
.do(secondMenu =&gt; firstMenu.child = secondMenu)
.subcribe()
</code></pre>

<p>edit1 </p>

<pre><code>getFirstMenu$()
.mergeMap(firstMenuList =&gt; Rx.Observable.from(firstMenuList))
.mergeMap(firstMenu=&gt; getSecondMenu$(firstMenu.ID)
,(firstMenu, secondMenu) =&gt; {
 firstMenu.child=secondMenu
 return firstMenu
 })
.reduce((acc,curr)=&gt;  acc.concat(curr) ,[])
.subscribe((menuList) =&gt; {
 console.log(menuList)
 });
</code></pre>
","8618350","","8618350","","2017-12-25 06:06:11","2017-12-25 06:06:11","","","","12","","","","CC BY-SA 3.0"
"47967460","1","","","2017-12-25 09:42:18","","0","98","<p>While testing with jest, this code did not print a <code>console.log</code>:</p>

<pre><code>const observe = Rx.Observable.create(function (observer) {
  console.log('InnerFunction', observer);
}
</code></pre>
","1559386","","","","","2017-12-25 09:42:18","Rx.Observable.create is not invoking the passed function with jest","<rxjs><rxjs5><jestjs>","1","0","","","","CC BY-SA 3.0"
"47970255","1","47976789","","2017-12-25 16:16:33","","1","386","<p>The difference between <code>switchMap</code> and <code>switchMapTo</code> is that <code>switchMap</code> transforms each source emission into observable upon the emission and <code>switchMapTo</code> ignores emitted value and transforms each emission to an Observable that is built up during <em>stream creation</em>.  </p>

<p>The thumb rule here is use <code>switchMap</code> when your inner stream depends on the source stream values and use <code>switchMapTo</code> when it doesn't. </p>

<p>But what if I don't care for the emission value but I do care for the emission time?<br>
Meaning I'd like the inner Observable to be evaluated upon source Observable emission.  </p>

<p>The obvious thing here is to use <code>switchMap(() =&gt; Observable)</code> but it just doesn't feel right, because of the thumb rule I mentioned before. </p>

<hr>

<p><strong>Example with <code>switchMapTo</code> (<em>bad</em>):</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const predefinedKey = 'key';

//This need to be initialized
const obj = {};

function getObservable(key){
  return Rx.Observable.of(obj[key]);
}

//This is initialization stream
const initialize = new Rx.ReplaySubject();
initialize.next(1);

const onInit = initialize.do(val =&gt; obj[predefinedKey] = val);

//Would like to access the object only after initialization
const result = onInit.switchMapTo(getObservable(predefinedKey));
//Expect to see 1 in output but see 'undefined' because switchMapTo evaluated before the object is initialized
result.subscribe(val =&gt; console.log(val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Example with <code>switchMap</code> (<em>good</em>):</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const predefinedKey = 'key';

//This need to be initialized
const obj = {};

function getObservable(key){
  return Rx.Observable.of(obj[key]);
}

//This is initialization stream
const initialize = new Rx.ReplaySubject();
initialize.next(1);

const onInit = initialize.do(val =&gt; obj[predefinedKey] = val);

//Would like to access the object only after initialization
const result = onInit.switchMap(() =&gt; getObservable(predefinedKey));
//Expect to see 1 in output
result.subscribe(val =&gt; console.log(val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>The examples are very artificial but they describe the situation pretty well.  </p>

<p>What is the right approach here? Any other Observable function I can use for delayed execution? </p>
","1544364","","1544364","","2017-12-26 12:27:25","2017-12-26 12:27:25","switchMapTo upon source observable emission","<rxjs><rxjs5>","1","3","","","","CC BY-SA 3.0"
"47973157","1","","","2017-12-26 01:26:29","","0","607","<p>If I have an array of events that include a utc timestamp and event data like as follows:
[{utcts: , data: , ... ];</p>

<p>how would you use RxJS to ""replay"" those events with the correct time differentials between each item in the array?  Assume the array is ordered by the utcts field so the first item has the lowest value.</p>

<p>here is a very basic set of data to get started:</p>

<pre><code>var testdata = [
  {utcts: 1, data: 'a'},
  {utcts: 4, data: 'b'},
  {utcts: 6, data: 'c'},
  {utcts: 10, data: 'd'}
];
</code></pre>

<p>Assume the utcts is just the number of seconds from the start of replaying the event which starts at 0 seconds.  </p>
","3528149","","3528149","","2018-01-03 06:45:33","2018-10-01 13:39:13","Replay series of events with timestamps using RxJS","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"47976789","2","","47970255","2017-12-26 09:58:23","","4","","<p>Based on your example, you can use <code>switchMapTo</code> in combination with <code>Observable.defer</code>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const predefinedKey = 'key';
const obj = {};

function getObservable(key){
  return Rx.Observable.defer(() =&gt; Rx.Observable.of(obj[key]));
}

const initialize = new Rx.ReplaySubject();
initialize.next(1);

const onInit = initialize.do(val =&gt; obj[predefinedKey] = val);

const result = onInit.switchMapTo(getObservable(predefinedKey));
result.subscribe(val =&gt; console.log(val));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Instead of deferring in <code>getObservable</code>, you could also defer in the <code>switchMapTo</code> call:</p>

<pre><code>const result = onInit.switchMapTo(Rx.Observable.defer(() =&gt; getObservable(predefinedKey)));
</code></pre>

<p>This will just depend on the situation. That said, I also don't think there's anything wrong with using <code>switchMap</code> and personally, I'd probably do that instead of deferring (which is useful in other situations).</p>
","1675492","","","","","2017-12-26 09:58:23","","","","0","","","","CC BY-SA 3.0"
"47985351","1","","","2017-12-27 01:33:17","","0","96","<p>My app is sort of complicated and I can not figure out the exact problem
The observation is the stream derived from <code>combineLatest</code> do not emit at the first time, while individual stram DO emit because they are all transformed somehow and used by other streams, so I am pretty sure they have value</p>
","2670585","","","","","2017-12-27 02:22:22","combineLatest do not emit even individual stream have value","<rxjs5>","1","0","","","","CC BY-SA 3.0"
"47997799","2","","47961799","2017-12-27 19:45:04","","0","","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code> public find(agent: Agent): Observable&lt;Agent&gt; {
    return this.http.get&lt;Agent&gt;(`${environment.google.BASE_URL}${agent.address}`)
      .map(response =&gt; {
        const coordinates = &lt;Coordinates&gt; {
          latitude: response['results'][0].geometry.location.lat,
          longitude: response['results'][0].geometry.location.lng
        };
        agent.distance = this.getDistance(&lt;Coordinates&gt;environment.google.COORDINATES, coordinates, Unit.km);
        return agent;
      });
  }</code></pre>
</div>
</div>
</p>
","586439","","","","","2017-12-27 19:45:04","","","","0","","","","CC BY-SA 3.0"
"48000905","1","48000945","","2017-12-28 02:26:00","","0","496","<p>I'm trying to retrieve some data using rxjs. It returns 200, but response is null. Is there any extra step to retrieve response? </p>

<p>Test api; <a href=""https://reqres.in"" rel=""nofollow noreferrer"">https://reqres.in</a></p>

<p>Thanks.</p>

<pre><code>import {ajax} from 'rxjs/observable/dom/ajax';

import 'rxjs/add/operator/map';


ajax.get({
            url: ""https://reqres.in/api/users?page=2"",
            // crossDomain: true,
            method: ""GET"",
        })
            .subscribe(data =&gt; {
                console.log(data)
                debugger
            })
</code></pre>

<p><a href=""https://i.stack.imgur.com/PAgZX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PAgZX.png"" alt=""enter image description here""></a></p>
","2746389","","","","","2017-12-28 02:53:16","RxJS ajax returns null response","<javascript><rxjs><rxjs5><rxjs-dom>","1","1","","","","CC BY-SA 3.0"
"48000945","2","","48000905","2017-12-28 02:33:42","","-1","","<p>Never mind,</p>

<p>It should be <code>ajax()</code> not <code>ajax.get()</code></p>
","2746389","","2746389","","2017-12-28 02:53:16","2017-12-28 02:53:16","","","","0","","","","CC BY-SA 3.0"
"48010234","1","48012926","","2017-12-28 15:38:31","","3","1491","<p>I'm using publishReplay(1).refCount() to cache http requests in Angular5. This works fine - except in error-cases. </p>

<p>I'm swallowing and reporting exceptions from the http-source, that's why I pass Observable.of(undefined) in the code below. In that case, it caches undefined of course - but following subscribers shouldn't get that value, instead it should request against the http resource again, like there would be no cache.</p>

<p>My current code:</p>

<pre><code>result: Observable&lt;any&gt;;
list() {

  if (this.result === undefined) {
    this.result = this.http.get(`https://swapi.co/api/people`)
      .catch(error =&gt; {
        console.error(""Something really bad happened"", error);
        return Observable.of(undefined);
        // in that case, reset publishReplay
      })
      .publishReplay(1)
      .refCount();
  }

  return this.result;
}
</code></pre>

<p>I have a stackblitz (with shareReplay, but the same problem) to show the behaviour: <a href=""https://stackblitz.com/edit/angular-s5zuqa"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-s5zuqa</a>.
A click on ""Load"" should re-request the http-source instead of providing the cached object from the catch.</p>
","252092","","252092","","2017-12-28 16:31:37","2019-01-10 07:44:55","rxjs publishReplay: reset on Error","<angular><rxjs><rxjs5>","2","3","","","","CC BY-SA 3.0"
"48012926","2","","48010234","2017-12-28 19:00:23","","3","","<p>So if I understand correctly, you're looking for this, right? There are two important things to note here:</p>

<ol>
<li>We use <code>shareReplay(1)</code> instead of <code>publishReplay(1).refCount()</code>.</li>
<li>The <code>catch</code> has been moved to <em>behind</em> the multicast operator.</li>
</ol>

<p>You'll see that the (faked) HTTP call errors the first time around, emitting <code>undefined</code> (since we catch it). The next time around, we run the request again, this time getting a result (42) which is cached for the third run, not causing another request.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Just to keep track of how often we sent the request already
let counter = 1;

// A fake HTTP request which errors the first time, then succeeds
const request$ = Rx.Observable.of(null)
  .do(() =&gt; console.log('HTTP Request (#' + counter + ')!'))
  .delay(250)
  .switchMap(() =&gt; counter++ === 1 
    ? Rx.Observable.throw('Error!')
    : Rx.Observable.of(42)
  );

// =========

const result$ = request$
  .shareReplay(1)
  .catch(() =&gt; Rx.Observable.of(undefined))
;

Rx.Observable.timer(0, 1000)
  .take(3)
  .do(() =&gt; console.log('Subscribing to result$â¦'))
  .switchMap(() =&gt; result$)
  .subscribe(value =&gt; console.log('Received value: ', value));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1675492","","1675492","","2017-12-28 19:06:07","2017-12-28 19:06:07","","","","0","","","","CC BY-SA 3.0"
"48023075","1","","","2017-12-29 13:03:38","","1","1560","<p>I've been trying to get timeout working with my http Get calls but the Http calls are never timed out until no response is sent from server . What am i doing wrong ?       </p>

<pre><code>return Observable.interval(30000).startWith(0).flatMap(()=&gt;{
            return this.http.get(someUrl).timeout(3000)
                    .map(this.extractData)
                    .catch(this.handleError);
        });
</code></pre>

<p>I'm using rxjs-5.0.0-beta.12 in my application</p>

<p>Thanks in advance</p>
","6949235","","","","","2019-02-13 11:23:25","Angular 2 Rxjs Timeout","<angular><rxjs5>","1","4","1","","","CC BY-SA 3.0"
"48025965","1","48025970","","2017-12-29 17:08:56","","9","1007","<p>RxJS 5.5 allows grabbing lettable operators and piping them like so:</p>

<pre><code>import { ajax } from 'rxjs/observable/dom/ajax'
import { catchError, map, retry } from 'rxjs/operators'

ajax.getJSON('https://example.com/api/test')
.pipe(
    retry(3, 1000),
    map(fetchUserFulfilled),
    catchError(console.error)
)
</code></pre>

<p>How would I use the <code>do</code> operator between these commands?</p>
","1624862","","","","","2018-05-23 12:01:18","How would I use `do` as an RxJS lettable operator?","<javascript><rxjs><rxjs5><rxjs-lettable-operators>","1","0","","","","CC BY-SA 3.0"
"48025970","2","","48025965","2017-12-29 17:10:20","","11","","<p>The <code>do</code> operator was renamed in RxJS 5.5 to <code>tap</code> because it collided with the JavaScript <code>do</code> keyword.</p>

<p>For more info see: <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#pipeable-operators"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#pipeable-operators</a></p>
","310726","","310726","","2018-05-23 12:01:18","2018-05-23 12:01:18","","","","0","","","","CC BY-SA 4.0"
"48027179","1","48028732","","2017-12-29 19:00:33","","2","393","<p>I'm using RxJs 5 lettable operators in Angular 5.
Based on this code sample,  how will the retry work? will the error propagate to the first retry and then if it fails it will propagate to the second?</p>

<p>First observable:</p>

<pre><code>first() {
  return Observable.create(observer =&gt; {
     observer.error('Something went wrong!')})
  }).pipe(retry(3))
}
</code></pre>

<p>Second observable subscribe method call:</p>

<pre><code>first().pipe(retry(1)).subscribe()
</code></pre>

<p>Thank you!</p>
","4894091","","4894091","","2017-12-29 21:23:32","2021-04-01 16:49:21","How does nested RxJs retry operators work?","<angular><rxjs><rxjs5>","1","5","1","","","CC BY-SA 3.0"
"48028732","2","","48027179","2017-12-29 21:39:49","","2","","<p>The resulting stream effectively looks like this:</p>
<pre><code>Observable.create(...).pipe(retry(3), retry(1));
</code></pre>
<p>So the <code>subscribe</code> will perform first subscription, then <code>retry(3)</code> will perform 3 subscriptions to the source observable and after that will propagate the error to the next <code>retry(1)</code>, which in turn will run the preceding sequence <code>Observable.create(...).pipe(retry(3))</code> again so if you put <code>console.log('subscribed')</code> into producer function you'll have 8 log entries.</p>
<p>You can learn more about the <code>retry</code> operator and its variations <a href=""https://indepth.dev/reference/rxjs/operators/retry"" rel=""nofollow noreferrer"">here</a>.</p>
","2545680","","2545680","","2021-04-01 16:49:21","2021-04-01 16:49:21","","","","2","","","","CC BY-SA 4.0"
"48049618","1","48049707","","2018-01-01 12:22:40","","1","128","<p>I want to make requests with a service in my application.  I want to pass the subscription on to the caller as is the usual behaviour, but I want to be able to also intercept the result, act on it <strong>but not change it</strong>, and carry on.</p>

<p>For example:</p>

<pre><code>return this.http.get&lt;LicenseKeyAndUsageModel&gt;('api/license')
    .map(data =&gt; {
        this.hasValidLicenseKeyInternal.next(!data.isExpired);
        return data;
    })
    .catch((error: HttpErrorResponse) =&gt; {
        if (error.status === 404) {
            this.hasValidLicenseKeyInternal.next(false);
            return Observable.throw(new LicenseKeyMissingError());
        }
        else
            return Observable.throw(error);
    });
</code></pre>

<p>So in this case, I'm retriving the current license key, and updating a service level value as to whether the license key is valid, and still passing the result to the original subscriber.</p>

<p>Basically does this seem like the right approach? Or should I be doing something more 'Observable-y' like with multicast or something else?</p>
","751560","","310726","","2018-01-01 12:37:09","2018-01-01 12:39:18","Correct way to work with angular http calls and pass results to subscriber","<angular><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"48049707","2","","48049618","2018-01-01 12:36:30","","4","","<p>This is what the <code>do()</code> operator (or <code>tap()</code> in RxJS 5.5) is intended to do.</p>

<p>It's true you could use <code>map()</code> for this as well but you need to remember to always return the original value. Also what you want seems to be a ""side-effect"" (you want to perform actions that affect application state outside of the observable chain) and this is what <code>do()</code> is made for.</p>
","310726","","","","","2018-01-01 12:36:30","","","","0","","","","CC BY-SA 3.0"
"48069225","1","48073663","","2018-01-02 23:25:54","","0","677","<p>I am attempting to do some <code>string</code> manipulation in <code>rjxs</code>, and while I <strong>can</strong> accomplish it with the built in behaviors on the <code>string</code> class and the <code>array</code> class in <code>Javascript</code>, I'm wanting to use this as an exercise to learn even more about <code>rxjs</code> and understand a fluent code-flow better.</p>

<p>To that end, it's imperative to me that I discover a way to do it that can fit in a <code>fluent</code> solution, instead of a series of variable assignments like I see in most <code>rxjs</code> examples.</p>

<p>Essentially, here's the situation; I've got a string of text;</p>

<pre><code>const example = `
    key || value
    key || value
    key || value

    value
    value

    value
    key || key[key1] = value | key[key2] = value
    key || value
`;
</code></pre>

<p>The first thing that I need to do is use <code>string.split('\n')</code> to create an array of strings, so that I can through each line and perform further operation.</p>

<p><code>example.string.split('\n')</code> does give the desired results, but trying to send this into <code>rxjs</code> begins to get rather mixed yield. With the <code>pipe</code> method, I know that I send the results into <code>rxjs</code> as an <code>Observable</code>, but I'm having a really troubling time grasping how to truly treat it from there without excessive nesting into the <code>map</code> operator.</p>

<p>For example, if I do ...</p>

<pre><code>of(example.string.split('\n')).pipe(
   map(results =&gt; results.toString().split('||')),
   map(results =&gt; ... ),
   ...
).subscribe();
</code></pre>

<p>I <strong>can</strong> start to get a semblance of what I'm looking for, but what I'd really like to do is ...</p>

<pre><code>of(example).pipe(
   split('\n'),
   split('||'),
   concatMap(results =&gt; ...)
).subscribe();
</code></pre>

<p>Reading the <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md"" rel=""nofollow noreferrer"">documentation on <code>lettable operators</code>, seen here</a>, it looks like this should be a pretty easy thing to create. In theory, it should look like this in my mind;</p>

<pre><code>const split = (separator: string) =&gt; &lt;T&gt;(source: Observable&lt;T&gt;) =&gt;
    new Observable(observer =&gt; {
        source.subscribe({
            next(x) { observer.next(x.toString().split(separator)); },
            error(err) { observer.error(err); },
            complete() { observer.complete(); }
        })
    });
</code></pre>

<p>So that should make the whole code obvious enough;</p>

<pre><code>of(example).pipe(
    split('\n')
).subscribe(result =&gt; console.log(`[n]::${result}`));
</code></pre>

<p>But this doesn't give me what I really expect. I expected to get an <code>array</code> of the lines, but if I output it, I get ...</p>

<blockquote>
  <p>[n]::,    key || value,    key || value,    key || value,    ,<br>
  value,    value,    ,    value,    key || key[key1] = value |
  key[key2] = value,    key || value,</p>
</blockquote>

<p>I'm really unclear what I'm doing wrong, here. Since it's hard to demonstrate <code>rxjs</code> in most of the code playgrounds like <code>plunkr</code> or <code>jsfiddle</code>, at least to my knowledge, I've prepared a playground environment to demonstrate my work on <code>stackblitz</code>, if it helps.</p>

<p>You'll find all of the pertinent code in the <code>playground/index.ts</code> file. I've done the best I can to abstract away the need to have <strong>any</strong> knowledge of angular, as I've painstakingly earmarked the sections that should be left alone to make it continue showing output on the right side. If you do not know angular, but can help with <code>rxjs</code>, you should be able to work without ever disturbing that setup.</p>

<h2><a href=""https://stackblitz.com/edit/rxjs-lettable-experiments-3hjthq"" rel=""nofollow noreferrer"">STACKBLITZ PLAYGROUND</a></h2>
","2796614","","","","","2018-01-03 08:24:07","creating lettable rxjs ""string.split"" operator","<rxjs><rxjs5><rxjs-lettable-operators>","1","0","","","","CC BY-SA 3.0"
"48070968","1","","","2018-01-03 03:59:28","","0","588","<p>I am using rxjs takeWhile method in my typescript to run a poll(periodic requests) while a condition is true. But the problem is that the poll is running continuously even after the condition is False. I tried to debug it using the chrome developer tools by keeping the breakpoints, but unfortunately the breakpoint is not working for takeWhile method. How do I print statements inside a takeWhile method or to put a breakpoint inside takeWhile method.</p>

<pre><code>Observable.interval(10000)
  .switchMap(() =&gt; http.get('/route1'))
  .map((data) =&gt; data)
  .takeWhile(() =&gt; this.obj.var === 'show_files')
  .subscribe((data: any) =&gt; {})
</code></pre>

<p>I am setting this ""this.obj.var"" to something else when I load another page to stop the polling. I just want to poll if the user is in current page and stop polling when user navigated to any other page just to avoid overload on browser with conrinouos requests.</p>

<p>Could you help me on how to debug rxjs methods using chrome developer tools</p>
","9166394","","106909","","2018-01-03 09:55:43","2018-01-25 14:12:33","How to debug rxjs takeWhile command using angular 4?","<angular><typescript><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"48073663","2","","48069225","2018-01-03 08:24:07","","1","","<p>Your code is working fine, just the es6 template string  ${} flattened your array into a string. If you console.dir or log the result, you will see a correct array retrieved. </p>
","8618350","","","","","2018-01-03 08:24:07","","","","2","","","","CC BY-SA 3.0"
"48102269","1","","","2018-01-04 19:31:53","","1","140","<p>I would like to implement some kind of a polling mechanism using NgRX and RxJS. At some time during an application runtime user clicks a button, applications starts to poll data every 30 seconds. Each response from BE has a status. Once status has changed - polling should be stopped. I'm thinking about a better solution. Initial idea was to do something like described in this article: <a href=""https://blog.sstorie.com/building-an-angular-2-reactive-auto-logout-timer-with-the-redux-pattern/"" rel=""nofollow noreferrer"">https://blog.sstorie.com/building-an-angular-2-reactive-auto-logout-timer-with-the-redux-pattern/</a></p>

<p>But this solution is not so cancelable. Maybe you know a better way?</p>
","7109755","","","","","2018-01-04 19:31:53","Ngrx RxJS cancelable interval poling","<angular><rxjs><reactive-programming><rxjs5><ngrx>","0","1","","","","CC BY-SA 3.0"
"48132136","1","","","2018-01-06 21:34:35","","0","444","<p>I am undecided if this is the right place to ask this question, or StackOverflow might be best for this. So here i go.</p>

<p>My introductions to rxjs was through the excellent <a href=""https://angular.io"" rel=""nofollow noreferrer"">Angular</a> framework and throughout every tutorial and in practice has been ""import whatever you need from <code>add/operator</code> and then chain it. eg.</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { empty } from 'rxjs/observable/empty';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/map';
// Other rxjs import
import 'rxjs/add/observable/of';

Class SomeClass {
  @Effect
  search$ = this._action
    .ofType&lt;search.SearchCountry&gt;(search.SEARCH_COUNTRY)
    .map(action =&gt; {
      return action.payload;
    })
    .switchMap(query =&gt; {
      if (query === '') {
        return empty();
      }
      const nextSearch$ = this._action.ofType(search.SEARCH_COUNTRY).skip(1);

      return this._searchService
        .search(query)
        .do(query =&gt; console.log(query))
        .takeUntil(nextSearch$)
        .map((result: RestResponseInterface) =&gt; {
          return new search.SearchCountryComplete(result);
        });
    })
    .catch(error =&gt; {
      return Observable.of(new search.SearchError('Undocumented API Error'));
    });
}
</code></pre>

<p>As <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md#usage"" rel=""nofollow noreferrer"">explained</a> in lettable documentaion, and If I am reading this right, chaining is discouraged as way forward, and pipe is the recommended implementation. The same implementation should be written as follows</p>

<pre><code>import { tap, take, takeUntil, skip, map, switchMap } from 'rxjs/operators'; // Import statements have changed

search$ = this._action
    .pipe(
        ofType&lt;search.SearchCountry&gt;(search.SEARCH_COUNTRY),
        map(action =&gt; action.payload),
        switchMap(query =&gt; {
            if (query === '') {
                return empty();
            }

            const nextSearch$ = this._action.ofType(search.SEARCH_COUNTRY).skip(1);

            return this._searchService
                .search(query)
                .pipe(tap(qyery =&gt; console.log(query)), takeUntil(nextSearch$), map((result: RestResponseInterface) =&gt; new search.SearchCountryComplete(result)));
        })
    )
    .catch(error =&gt; {
        return Observable.of(new search.SearchError('Undocumented API Error'));
    });
</code></pre>

<p>Because when i read the source,  especially after <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/Rx.ts#L41"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/src/Rx.ts#L41</a> its seems that chaining is perfectly acceptable, however, there is a proposal <a href=""https://github.com/ReactiveX/rxjs/issues/2913"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2913</a>, which is discussing adding <code>rxjs/add/*</code> as a seperate package.</p>

<p>My question is, how will this effect chaining in future?</p>
","228697","","","","","2018-04-05 06:39:06","On chaining and lettable operators","<rxjs5><rxjs-lettable-operators>","1","3","","","","CC BY-SA 3.0"
"48136430","1","48136773","","2018-01-07 10:55:11","","3","4101","<p>Hello to every one i am new to RxJs and reactive programming i would like to filter an array like this:</p>

<pre><code>let subscription = Rx.Observable.from([{id: 1}, {id: 2}, {id: 3}],[{id: 4}, {id: 5}, {id: 6}]);
</code></pre>

<p>if i have one array a i can do this:</p>

<pre><code>let subscription = Rx.Observable.from([{id: 1}, {id: 2}, {id: 3}]);


subscription.filter(x =&gt; x.id === 1).subscribe(x =&gt; console.log(x));
</code></pre>

<p>But how i can to do with the second array?</p>
","7390405","","310726","","2018-01-07 14:28:01","2018-01-07 14:28:01","How to filter an array with RxJS operator","<javascript><arrays><rxjs><rxjs5>","2","2","2","","","CC BY-SA 3.0"
"48136773","2","","48136430","2018-01-07 11:43:30","","4","","<p>If you know you'll always have array of arrays you can flatten the array and then run <code>filter</code>:</p>

<pre><code>const o = Rx.Observable.of([{id: 1}, {id: 2}, {id: 3}],[{id: 1}, {id: 2}, {id: 3}])
  .concatMap(array =&gt; array) // flatten the array into single emissions
  .filter(x =&gt; x.id === 1)
  .subscribe(x =&gt; console.log(x));
</code></pre>

<p>I'm using <code>.of</code> that accepts multiple arguments. However it takes them as they are unlike the <code>from</code> method that iterates the array.</p>
","310726","","","","","2018-01-07 11:43:30","","","","0","","","","CC BY-SA 3.0"
"48143056","1","48143624","","2018-01-08 01:00:47","","1","47","<p>lodash CLI allows you to generate a package with specific functions like ""throttle"".  Can the same thing be done with RxJS?</p>

<p>Here is the lodash example command:</p>

<pre><code>lodash include=throttle
</code></pre>

<p>It generates a 2kb minimized JS file.  Hoping for something similar with RxJS.</p>
","3528149","","","","","2018-01-08 02:44:15","including specific RxJS operators","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48143275","1","48914661","","2018-01-08 01:43:23","","0","327","<p>I have this component listening for messages from a service. <em>Note that every console.log() statement shown below is hit at least once, everything gets logged.</em> That is, except ""adding message to array"" - that does not get logged, but it should get logged!</p>

<p>Here is the component:</p>

<pre><code>import {Component, OnInit, Inject} from '@angular/core';
import {ChromeDataService} from '../../../../shared/services/events';


@Component({
  providers: [ChromeDataService],
  selector: 'app-events-list',
  templateUrl: './events-list.component.html',
  styleUrls: ['./events-list.component.scss']
})

export class EventsListComponent implements OnInit {

  isShowEventsList = false;
  events = [];

  constructor(private data: ChromeDataService) {
       console.log('events list component is constructed.');
  }

  ngOnInit() {
    console.log('events list component ngOnInit called.');
    this.data.currentMessage.subscribe(message =&gt; {
      console.log('adding message to array: ', message);
      this.events.push(message);
    })
  }

  showEventsList() {
    this.isShowEventsList = true;
  }

  hideEventsList() {
    this.isShowEventsList = false;
  }

}
</code></pre>

<p>here is the data source (an Angular service):</p>

<pre><code>///&lt;reference types=""chrome""/&gt;

import {Injectable, Component, Inject} from '@angular/core';
import {ReplaySubject} from ""rxjs/ReplaySubject"";

@Injectable()
export class ChromeDataService {

  private messageSource = new ReplaySubject&lt;Object&gt;();
  public currentMessage = this.messageSource.asObservable();
  private isListening: boolean = false;
  private listener: any;

  constructor() {

    const self = this;
    this.listener = function (msg, sender, sendResponse) {
      const parsed = JSON.parse(msg);
      console.log('extension received a message:', parsed);
      self.changeMessage(parsed);
    };
  }

  changeMessage(message: Object) {
    this.messageSource.next(message);
  }

  stopListening() {
    this.isListening = false;
    chrome.runtime.onMessage.removeListener(this.listener);
  }

  startListening() {
    this.isListening = true;
    chrome.runtime.onMessage.addListener(this.listener);
  }


}
</code></pre>

<p>does anyone know why when <code>changeMessage()</code> is called, that the <code>subscribe()</code> callback does not get invoked?</p>

<p>One big hint is that when I use <code>new BehaviorSubject&lt;Object&gt;('initial');</code> instead of <code>new Subject&lt;Object&gt;()</code> - then <code>initial</code> does arrive and 'adding message to array' is logged.</p>
","","user5047085","","user5047085","2018-01-08 02:17:04","2018-02-21 20:13:49","Component cannot subscribe to data source","<angular><google-chrome-extension><rxjs><rxjs5><angular5>","3","4","","","","CC BY-SA 3.0"
"48143624","2","","48143056","2018-01-08 02:44:15","","2","","<p>There isn't specific CLI tools to generate those kind of set. RxJS instead recommends import specific operator and let build tools configure it. <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md#build-and-treeshaking"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md#build-and-treeshaking</a></p>
","2742189","","","","","2018-01-08 02:44:15","","","","0","","","","CC BY-SA 3.0"
"48144202","1","48145114","","2018-01-08 04:23:15","","0","892","<p>I'm able to create 2 observables to watch mouse move and click events as such:</p>

<pre><code>var mousemove$ = Rx.Observable.fromEvent(document, 'mousemove');
var click$ = Rx.Observable.fromEvent(document, 'click');
</code></pre>

<p>I'm also able to use merge() and debounceTime() to wait for either mousemove or click to not happen for 10 seconds like this:</p>

<pre><code>var allactivity$ = Rx.Observable.merge(
    mousemove$.mapTo('Mouse!'),
    click$.mapTo('Click!')
  );

var lastact$ = allactivity$.debounceTime(10000);
</code></pre>

<p>However, I would like to somehow construct an observable for when a user Re-starts either moving the mouse or clicking after this 10 second debounceTime() limit.  </p>

<p>Could someone help me construct this Observable?  I think I'm missing something simple.</p>
","3528149","","","","","2018-01-08 17:26:51","Example RxJS Observable when mouse or click activity Re-starts","<rxjs><rxjs5>","1","1","2","","","CC BY-SA 3.0"
"48145114","2","","48144202","2018-01-08 06:16:25","","2","","<p>You could use something like this:</p>

<pre><code>var restart$ = Rx.Observable.of('Kick off')
  .merge(lastact$)
  .mergeMap(() =&gt; allactivity$.skipUntil(lastact$).first());
</code></pre>

<h2>Explanation</h2>

<ul>
<li><code>Rx.Observable.of('Kick off')</code> - Once in the beginning, ...</li>
<li><code>.merge(lastact$)</code> - and for everytime <code>lastact$</code> emits, ...</li>
<li><code>.mergeMap(() =&gt; ...)</code> - create an observable ...</li>
<li><code>allactivity$</code> - that will observe on <code>allactivity$</code> for all items...</li>
<li><code>.skipUntil(lastact$)</code> - since the first<code>lastact$</code> emission (after the creation of this observable) ...</li>
<li><code>.first()</code> - and take only the first item (that is, the first activity happen after the <code>lastact$</code> emit)</li>
</ul>

<p><strong>Edit:</strong></p>

<p>The above observable will not trigger on the first mouse move, to handle that:</p>

<pre><code>var firstMoveAndRestart$ = restart$.merge(allactivity$.first());
</code></pre>
","2180651","","2180651","","2018-01-08 17:26:51","2018-01-08 17:26:51","","","","4","","","","CC BY-SA 3.0"
"48209089","1","48210707","","2018-01-11 14:14:17","","1","512","<p>I'm using redux-observable to handle an action:</p>



<pre><code>export const createPaymentMethod =
  (getBraintreeToken: (Object) =&gt; Promise&lt;*&gt;, cardholderName: string) =&gt; ({
    type: CREATE_PAYMENT_METHOD,
    getBraintreeToken: () =&gt; getBraintreeToken({ cardholderName }),
  });

const mapBraintreeError = err =&gt; Observable.of({
  type: CREATE_PAYMENT_METHOD + FAILURE,
  error: { response: err.message },
});

export const createPaymentMethodEpic = (action$: any, store: ReduxState) =&gt;
  action$.ofType(CREATE_PAYMENT_METHOD)
    .switchMap(({ getBraintreeToken }) =&gt; Observable.fromPromise(getBraintreeToken()))
    .switchMap(({ nonce }) =&gt;
      ajax(api.createPaymentMethod(store.billings.info.customer_id, nonce))
        .mapSuccess(CREATE_PAYMENT_METHOD)
        .mapFailure(CREATE_PAYMENT_METHOD),
    )
    .catch(mapBraintreeError);
</code></pre>

<p>What I do is I intentionally make <code>getBraintreeToken()</code> Promise fail. This results in epic execute <code>catch</code> function and returning <code>CREATE_PAYMENT_METHOD + FAILURE</code> action. Which is what I intended.</p>

<p>The problem is when I try to call epic the second time. It doesn't execute... </p>

<p><strong>EDIT:</strong>
I have converted the epic and it seems to work now, however, I still don't understand why the first example was broken (actually I like more the flat structure of the first epic).</p>



<pre><code>export const createPaymentMethodEpic = (action$: any, store: ReduxState) =&gt;
  action$.ofType(CREATE_PAYMENT_METHOD)
    .switchMap(({ getBraintreeToken }) =&gt;
      Observable.fromPromise(getBraintreeToken())
        .switchMap(({ nonce }) =&gt;
          ajax(api.createPaymentMethod(store.billings.info.customer_id, nonce))
            .mapSuccess(CREATE_PAYMENT_METHOD)
            .mapFailure(CREATE_PAYMENT_METHOD),
        )
        .catch(mapBraintreeError),
    );
</code></pre>
","4443323","","310726","","2018-01-11 15:38:39","2018-01-11 15:38:39","redux-observable and rxjs. Converting promise to Observable - epic gets called only once","<javascript><promise><rxjs><rxjs5><redux-observable>","1","2","","","","CC BY-SA 3.0"
"48210707","2","","48209089","2018-01-11 15:35:50","","1","","<p>The problem with the first version is that the <code>error</code> notification reaches the <code>switchMap</code> operator that invokes its error logic which causes the chain to dispose.</p>

<p>It needs to be like this because an Observable emits zero or one <code>error</code> notifications but never more.</p>

<p>For more detailed explanation see <a href=""http://reactivex.io/documentation/contract.html"" rel=""nofollow noreferrer"">The Observable Contract</a>.</p>

<blockquote>
  <p>An Observable may make zero or more OnNext notifications, each representing a single emitted item, and it may then follow those emission notifications by either an OnCompleted or an OnError notification, but not both. <strong>Upon issuing an OnCompleted or OnError notification, it may not thereafter issue any further notifications</strong>.</p>
</blockquote>

<p>In the second version of your code you put the <code>catch</code> operator inside a callback to <code>switchMap</code>. The one <code>error</code> notifications rule is applied here as well but the callback is called for every value so even when the inner Observable emits an error it's caught (and converted into <code>next</code>) and then it's replaced by a new inner Observable.</p>
","310726","","","","","2018-01-11 15:35:50","","","","1","","","","CC BY-SA 3.0"
"48212167","1","","","2018-01-11 16:51:30","","2","498","<p>In Angular apps, especially when NGRX is used, we have a lot of RxJS subscriptions. And yes, we (developers) may forget to unsubscribe. Is there any tooling that can help profile the issue?</p>
","2896495","","2896495","","2018-01-11 17:27:29","2018-01-12 07:34:51","Is there any tooling to profile ""hanging"" RxJS subscriptions in Angular 5 apps?","<angular><debugging><rxjs><rxjs5><tooling>","1","1","","","","CC BY-SA 3.0"
"48215486","1","48223506","","2018-01-11 20:42:30","","1","453","<p>I have the following epic:</p>



<pre><code>export const changeTeamSubscriptionPlan = (braintreePlanId: string) =&gt; ({
  type: CHANGE_TEAM_SUBSCRIPTION_PLAN,
  braintreePlanId,
});

export const changeTeamSubscriptionPlanEpic = (action$: any, store: Store&lt;ReduxState, *&gt;) =&gt;
  action$.ofType(CHANGE_TEAM_SUBSCRIPTION_PLAN)
    .mergeMap(({ braintreePlanId }) =&gt; {
      const state = store.getState();
      const { subscription_id } = state.payment.subscription;
      let request;
      if (subscription_id) {
        request = ajax(api.changeTeamSubscriptionPlan(subscription_id, braintreePlanId));
      } else {
        const [method] = state.payment.paymentMethods;
        request = ajax(api.createSubscription(braintreePlanId, method.token));
      }

      // I would like to emit another value ({ type: FETCH_TEAM }) no matter what happens 
      //(basically I try to invalidate the team data even if the request fails)
      return request
        .map(response =&gt; ({
          type: CHANGE_TEAM_SUBSCRIPTION_PLAN + SUCCESS,
          payload: {
            data: response.response,
            status: response.status,
          },
        }))
        .catch(error =&gt; Observable.of({
          type: CHANGE_TEAM_SUBSCRIPTION_PLAN + FAILURE,
          response: {
            data: error.xhr.response,
            status: error.xhr.status,
          },
        }));
    });
</code></pre>

<p>What I want to do is no matter if <code>ajax</code> call ends with <strong>catch</strong> or calls <strong>map</strong> I want to append another value.</p>

<p>I run out of ideas, so I'm hoping for help.</p>
","4443323","","4443323","","2018-01-12 07:47:28","2018-01-12 09:56:27","RxJs and redux-observable. Append value when ajax succeed or failed","<redux><rxjs><axios><rxjs5><redux-observable>","1","7","","","","CC BY-SA 3.0"
"48223506","2","","48215486","2018-01-12 09:47:02","","0","","<p>After switching to original operators it turned out that I can do this:</p>



<pre><code>  return request
    .map(response =&gt; ({
      type: CHANGE_TEAM_SUBSCRIPTION_PLAN + SUCCESS,
      payload: {
        data: response.response,
        status: response.status,
      },
    }))
    .catch(error =&gt; Observable.of({
      type: CHANGE_TEAM_SUBSCRIPTION_PLAN + FAILURE,
      error: mapToError(error),
    }))
    .concat(Observable.of({ type: 'CHUJ_TYPE' }));
</code></pre>

<p>and <code>concat</code> will append value <strong>even</strong> when the catch block fires.</p>

<p>I was originally using custom operator which I though will work just like <code>catch</code> does but will reduce boilerplate in my app:</p>



<pre><code>Observable.prototype.mapFailure = function catchAndMapError(ACTION_TYPE, optionalPayload = {}) {
  return Observable.create(subscriber =&gt;
    this.subscribe(
      value =&gt; subscriber.next(value),
      (error) =&gt; {
        try {
          const action = {
            type: ACTION_TYPE + FAILURE,
            error: {
              ...mapToError(error),
              ...optionalPayload,
            },
          };
          subscriber.next(action);
        } catch (e) { // catch mappings error
          subscriber.error(e);
        }
      },
      () =&gt; subscriber.complete(),
    ),
  );
};
</code></pre>

<p>It seems like it doesn't work the same as <code>catch</code>.....</p>
","4443323","","4443323","","2018-01-12 09:56:27","2018-01-12 09:56:27","","","","2","","","","CC BY-SA 3.0"
"48233498","1","48234630","","2018-01-12 20:23:10","","2","294","<p>When a subscriber modifies another subscriber's value, the second subscriber processes its results out of order.</p>

<p>Sample code:</p>

<pre><code>subject = new Rx.BehaviorSubject()
subject.next({value: 'Test1'})
v1 = subject.pluck('value').distinctUntilChanged()
v2 = subject.pluck('value2').distinctUntilChanged()
h1 = v1.subscribe(function(it) { if (it == 'Test2') subject.next({value: it, value2: true}) })
h2 = v2.subscribe(function(it) { console.log('v2', it) })
subject.next({value: 'Test2'})
</code></pre>

<p>Expected results:</p>

<pre><code>v2 undefined
v2 true
</code></pre>

<p>Actual results:</p>

<pre><code>v2 undefined
v2 true
v2 undefined
</code></pre>

<p>What did I do wrong?</p>
","166850","","166850","","2018-01-12 21:49:45","2018-01-12 22:03:37","Why do my RxJs state changes show up out of order?","<rxjs><rxjs5><reactivex><reactive>","1","0","","","","CC BY-SA 3.0"
"48234630","2","","48233498","2018-01-12 22:03:37","","3","","<p>from v5, rxjs does not gaurantee reentrancy (trying to update values of source in your subscribe) works in order. this is due to observable sources are not do specific scheduling by default, so most of synchronous sources's subscription runs synchronously, while some others don't. If you'd like to achieve certain execution order with reentrancy, you should scheduler observable accordingly for your desired behavior, either creating observable with scheduler (static creation method usually accept scheduler) or use <code>observeOn</code> / <code>subscribeOn</code>.</p>
","2742189","","","","","2018-01-12 22:03:37","","","","1","","","","CC BY-SA 3.0"
"48237222","1","48241876","","2018-01-13 05:34:23","","1","1348","<p>After upgrading to angular-cli@1.6.3 and converting all the RxJS imports, methods, and operators to the new >5.5 form, I get a type error at run-time saying that <code>Observable.of</code> is not a function. The same error happens with all the methods that are defined as a member of an extension of <code>Observable</code>, for example, <code>Observable.fromEvent</code>.</p>

<p>On the other hand, the methods that are defined as stand alone functions, like <code>Observable.combineLatest</code> run properly despite the compiler warns that them don't exists on type <code>Observable</code>.</p>

<p>Just to clarify, I had no problems with any operator (after converting them to the pipe form). Only with methods. </p>

<p>The solution I found was to replace:</p>

<pre><code>import { of } from 'rxjs/observable/of';
import { fromEvent } from 'rxjs/observable/fromEvent';
...
const x = Observable.of(true, false);
const y = Observable.fromEvent(target, 'click');
</code></pre>

<p>with</p>

<pre><code>import { ArrayObservable } from 'rxjs/observable/ArrayObservable';
import { FromEventObservable } from 'rxjs/observable/FromEventObservable';
...
const x = ArrayObservable.of(true, false);
const y = FromEventObservable.create(target, 'click');
</code></pre>

<p>But I think it should be a better way. Am I right?</p>

<hr>

<p>Notes:</p>

<ol>
<li>I am forced to use ""Ahead Of Time compilation"" feature to build and serve the app because otherwise the angular injector would fail (but that is another question).</li>
<li>I'm am aware of the existence of <a href=""https://stackoverflow.com/questions/36568388/observable-of-is-not-a-function"">this other similar question</a>. But that one applies to versions of RxJS less than &lt; 5.5 according to the answer.</li>
<li><p><code>ng --version</code> gives:</p>

<p>Angular CLI: 1.6.3,
Node: 8.9.1,
OS: win32 x64,
Angular: 5.1.3,</p>

<p>@angular/cli: 1.6.3,
@angular-devkit/build-optimizer: 0.0.36,
@angular-devkit/core: 0.0.22,
@angular-devkit/schematics: 0.0.42,
@ngtools/json-schema: 1.1.0,
@ngtools/webpack: 1.9.3,
@schematics/angular: 0.1.11,
@schematics/schematics: 0.0.11,
typescript: 2.5.3,
webpack: 3.10.0,</p></li>
</ol>
","1154271","","1154271","","2018-01-13 18:48:14","2018-01-13 18:48:14","Type Error: observable.of is not a function - angular-cli@1.6.3 - rxjs@5.5.x - angular5","<typescript><rxjs5><angular5>","1","0","","","","CC BY-SA 3.0"
"48241876","2","","48237222","2018-01-13 16:31:36","","5","","<p>When using lettable (now known as pipeable) operators and factory functions, those are just functions, not methods of Observables. So it should just be </p>

<pre><code>import { of } from 'rxjs/observable/of';
import { fromEvent } from 'rxjs/observable/fromEvent';

const x = of(true, false);
const y = fromEvent(target, 'click');
</code></pre>

<p>See how the <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""noreferrer"">documentation</a> uses the <code>range</code> factory function.</p>
","571407","","","","","2018-01-13 16:31:36","","","","0","","","","CC BY-SA 3.0"
"48242422","1","","","2018-01-13 17:29:40","","1","48","<p>Using Rxjs, I need to copy 10 next values evey 200ms from arr1 to arr2. I come up with below code, but there should be some Rxjs way to do.</p>

<pre><code>originalArr= [];

newArr = [];

Rx.Observable.interval(200)
        .scan((acc, val) =&gt; acc + 10)
        .takeWhile(v =&gt; v &lt; this.value.length)
        .subscribe(val =&gt; {
            const arr = this.value.slice(val, val+10);
            arr.forEach(v =&gt; this.newVal.push(v));
        });
</code></pre>
","236896","","","","","2018-01-13 17:29:40","How to copy list of values from one array to another array on some interval using Rxjs?","<rxjs5>","0","0","","","","CC BY-SA 3.0"
"48248775","1","48248806","","2018-01-14 10:45:04","","2","1269","<p>My api returns 20 results in one http call but I want 40 records for the same I am making nested http call as shown below.I am able to fetch 40 records but when I am subscribing to the getALl() method I am getting only 20 results;</p>

<pre><code>getAll() {
    return this._http.get(this.baseURL)
      .do((data: any) =&gt; {
        this.nextPage = data.next_page_token;
        var results = data.results;
        return this._http.get(`${this.baseURL}?next=${this.nextPage}`).delay(2000).do((d: any) =&gt; {
           return Observable.of(results.concat(d.results));
        });
  });
}
</code></pre>
","9031114","","310726","","2018-01-14 10:50:02","2018-01-14 11:11:33","Angular 4 nested http call and merge data","<angular><rxjs><rxjs5>","2","0","1","","","CC BY-SA 3.0"
"48248806","2","","48248775","2018-01-14 10:49:47","","6","","<p>The <code>do()</code> operator is intended to only do side-effects, it doesn't modify the values going through at all.</p>

<p>In your case you can use <code>concatMap()</code> to merge two Observables and <code>map()</code> to modify the emitted value from the inner one:</p>

<pre><code>return this._http.get(this.baseURL)
  .concatMap((data: any) =&gt; {
    this.nextPage = data.next_page_token;
    var results = data.results;

    return this._http.get(`${this.baseURL}?next=${this.nextPage}`)
      .delay(2000)
      .map((d: any) =&gt; results.concat(d.results));
  });
</code></pre>
","310726","","310726","","2018-01-14 10:53:25","2018-01-14 10:53:25","","","","3","","","","CC BY-SA 3.0"
"48250322","1","","","2018-01-14 14:00:52","","2","498","<p>I'm trying to understand the best practice for importing rxjs operators</p>

<p>It seems like I should import <code>share</code> this way, but, the following doesn't work because it says share expects 0 arguments.  I'm not quite sure how to call <code>share</code> correctly.</p>

<pre><code>import { share } from 'rxjs/operators';

...

public currentUser: Observable&lt;User&gt; = share(this.currentUser$.asObservable());
</code></pre>

<p>Doing it the old way causes no problems.  However I seemed to have read that's not the preferred way to import <a href=""https://www.learnrxjs.io/concepts/operator-imports.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/concepts/operator-imports.html</a></p>

<pre><code>import 'rxjs/add/operator/share';

...

public currentUser: Observable&lt;User&gt; = this.currentUser$.asObservable().share();
</code></pre>

<p>How should I call share if I'm using the recommended way of importing?</p>
","611750","","611750","","2018-01-14 14:08:07","2018-01-14 15:35:25","Having trouble calling RxJS share using the recommended operator import","<rxjs><rxjs5><rxjs-lettable-operators>","3","1","","","","CC BY-SA 3.0"
"48253686","1","48331354","","2018-01-14 20:05:45","","1","1054","<p><strong>Background</strong></p>

<p>Using Typescript and RxJS, I'm trying to extend a behavior subject so that it takes an observable as a construction parameter and then subscribes to it so that each value from the observable gets set as the value of the behavior subject.</p>

<p><strong>Question</strong></p>

<p>How do I make it so that the behavior subject is only subscribed to the inner observable when the behavior subject itself has at least one subscriber?</p>

<p><strong>Code</strong></p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

export class SubjectWithInnerObservable&lt;T&gt; extends BehaviorSubject&lt;T&gt; {

    constructor(
        initialState: any,
        someObservable: Observable&lt;T&gt;
    ) {
        super(initialState);

        // I only want this subscription to exist when there are one or more subscribers to the behavior subject
        someObservable.subscribe(this);
    }
}
</code></pre>
","5108909","","","","","2018-01-18 22:30:01","RxJS: How to subscribe to inner observable only when outer observable/subject is subscribed to?","<javascript><typescript><rxjs><reactive-programming><rxjs5>","1","9","1","","","CC BY-SA 3.0"
"48281457","1","","","2018-01-16 12:36:38","","1","2333","<p>I am creating an angular v4 app. I have the following data.</p>

<pre><code>currentCount={
name:'myName',
count:0
};
</code></pre>

<p>Here the user will change the above object with the relevant data. I want to create an observable out of this object so that whenever there is a change I can save(process) the data.
Also, I want to pass the default data when the observable is subscribed to.</p>

<p>As I am a starting out with RXjs I feel lost. </p>

<p>Any help is appreciated.</p>
","4412482","","310726","","2018-01-16 20:31:11","2020-06-22 13:33:49","Create an observable from an Object along with a starting value","<angular><rxjs><observable><rxjs5>","2","4","","","","CC BY-SA 3.0"
"48282928","1","","","2018-01-16 13:57:43","","3","174","<p>I'm using RxJS to communicate with Database and I'm trying to send complex composite object. Our API let us to inject one element at time (i.e. POST will not handle array in body)
Consider following object, where <code>mainField</code> &amp; <code>subFields</code> will be separate tables entities in DB:</p>

<pre><code>OBJ = {
      'mainField': 'Main content'
      'subFields': [ 'obj1','obj2','obj3' ]
    }
</code></pre>

<p>The requirements are: </p>

<ol>
<li><code>mainField</code> must be transmitted first, response object will be supplied with reference ID, that <code>subFields</code> will use</li>
<li>Each element of <code>subFields</code> must be transmitted as single, and when response will arrive, another can be requested</li>
</ol>

<p>Conceptually procedure for me looks something like this (<code>send</code> function is a simplification that accepts anything and return observable of this type):</p>

<pre><code>send(OBJ.mainField) /* This will return Observable of mainField */
.flatMap(res =&gt; {
   OBJ.subFields.forEach(sub =&gt; {
     sub.id = res.id
   })
   Obervable.of(OBJ.subFields)
})
.flatMap(subField =&gt; {
  send(subField )
})
</code></pre>

<p>I believe there is a better way to do this (i.e. brake apart array, emit series of observables and wait untill they complete in order, then move on). I'd be grateful for any suggestions</p>
","2759473","","310726","","2018-02-05 08:15:58","2018-02-05 08:15:58","RxJS sequential operations","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48286476","1","48286635","","2018-01-16 17:11:55","","5","6518","<p>I upgraded from Angular 4 to 5 and replaced <code>Http</code> with <code>HttpClient</code>.  I removed chained map from my <code>http.post</code> call which now returns an <code>Observable&lt;Object&gt;</code>, but in my component it is now complaining that <code>concatMap does not exist on type Observable&lt;Object&gt;</code>.  Here is an example of what I am doing:</p>

<pre><code>//service
import { HttpClient} from '@angular/common/http';

constructor(private _http: HttpClient) { }

registerDomain()
{

return this._http.post('/api/domain/domain/register', {});
}

//component
registerDomain(caseId,domain) {
    return this._domainService.registerDomain(caseId,domain)
      .concatMap(operation =&gt; this.getOperationDetail(operation.OperationId,this.caseId,domain))
      .concatMap(() =&gt; this.createRecordSets(domain));
  }
</code></pre>

<p>I can see map and mergeMap on <code>Observable&lt;Object&gt;</code> but not <code>concatMap</code></p>
","2665434","","2665434","","2018-01-16 17:17:20","2018-01-17 10:39:31","Property 'concatMap' does not exist on type 'Observable<Object>'?","<angular><rxjs5>","2","3","","","","CC BY-SA 3.0"
"48286635","2","","48286476","2018-01-16 17:20:46","","10","","<p>Try importing this: </p>

<p><code>import 'rxjs/add/operator/concatMap'</code></p>
","6687248","","","","","2018-01-16 17:20:46","","","","3","","","","CC BY-SA 3.0"
"48300456","1","48300488","","2018-01-17 11:48:51","","2","460","<p>I make this code for test forkJoin but it does not work!
Can you check what is the problem?</p>

<pre><code>const observables = [];

observables.push(new Observable(subscriber =&gt; subscriber.next('Hello')));
observables.push(new Observable(subscriber =&gt; subscriber.next(' ')));
observables.push(new Observable(subscriber =&gt; subscriber.next('World') ));
observables.push(new Observable(subscriber =&gt; subscriber.next('!')));

forkJoin(observables).subscribe(word =&gt; console.log(word.join('')));
</code></pre>
","9225397","","","","","2018-01-17 16:48:24","ForkJoin Issue on angular","<angular><rxjs><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"48300488","2","","48300456","2018-01-17 11:51:01","","3","","<p>Try this </p>

<pre><code>const observables = [];

observables.push(Observable.of('Hello'));
observables.push(Observable.of(' '));
observables.push(Observable.of('World'));
observables.push(Observable.of('!'));

Observable.forkJoin(observables).subscribe(word =&gt; console.log(word.join('')));
</code></pre>
","","user4676340","","","","2018-01-17 11:51:01","","","","4","","","","CC BY-SA 3.0"
"48303090","1","48304880","","2018-01-17 14:09:19","","1","372","<p>I have updated the imports for rxjs operators in my project so that they now conform to the new recommended syntax, such as:</p>

<pre><code>import { switchMap, debounceTime }          from 'rxjs/operators';
</code></pre>

<p>However when I try to follow the same pattern for the ""<strong><em>do</em></strong>"" operator, TypeScript complains when I build my code.  In order to get it to work, I need to use the older syntax pattern such as:</p>

<pre><code>import 'rxjs/add/operator/do';
</code></pre>

<p>Am I doing something wrong or is the older pattern still needed for the ""<strong><em>do</em></strong>"" operator?</p>

<p>Thank you!</p>
","8895134","","310726","","2018-01-17 15:44:17","2018-01-17 15:44:17","Confused about rxjs operator imports","<typescript><import><rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"48304880","2","","48303090","2018-01-17 15:43:48","","2","","<p>The <code>do</code> operator was renamed in RxJS 5.5 to <code>tap</code> (because <code>do</code> is a reserved keyword):</p>

<pre><code>import { tap } from 'rxjs/operators';
</code></pre>

<p>For more info see section ""Renamed Operators"" in <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#pipeable-operators"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#pipeable-operators</a></p>
","310726","","","","","2018-01-17 15:43:48","","","","0","","","","CC BY-SA 3.0"
"48312566","1","48330205","","2018-01-18 01:37:22","","1","1187","<p>Using RxJS with Angular5, I have a service that contains an array.
Some components will get created / destroyed / re-created, as the array is being populated.</p>

<p>So we have a service like so:</p>

<pre><code>@Injectable
export class MyService {
   public events = [];
}
</code></pre>

<p>then we have a component like so:</p>

<pre><code>@Inject(MyService)
@Component({})
export class MyComponent {

  mySub: Subscriber

  constructor(private ms: MyService){}

  ngOnInit(){

   this.mySub = Rx.Observable.from(this.ms.events).subscribe(v =&gt; {

   });

  }

}
</code></pre>

<p>my question is - if the events array aleady has elements in it, when the component is created, it will pick up all the existing elements, but what about elements that are added to the array after the subscription is created? How can I listen for when elements are added to the array after the fact?</p>

<p>If I use a <code>Subject</code>, the problem is I don't think it stores the historical items, just fires new ones.</p>
","1223975","","1223975","","2018-01-18 01:51:15","2018-01-18 21:27:50","Subscribe to all current and future items in array","<angular><rxjs5><angular5>","4","3","1","","","CC BY-SA 3.0"
"48330205","2","","48312566","2018-01-18 20:59:28","","1","","<p>I think @LLai has most of what you need, but I'd change <code>BehaviorSubject</code> to <code>ReplaySubject</code> and also change the emits to single events (given Alexander Mill's answer).  </p>

<p>This doesn't cover removing events, although I don't see mention of that requirement.</p>

<p><strong>myService</strong></p>

<pre class=""lang-js prettyprint-override""><code>@Injectable()
export class MyService {
  event$ = new ReplaySubject&lt;any&gt;();

  addEvent(event){
    this.event$.next(event);
  }
}
</code></pre>

<p><strong>myComponent</strong></p>

<pre class=""lang-js prettyprint-override""><code>ngOnInit(){
  this.mySub = this.ms.event$.subscribe(v =&gt; {
    ...
  });
}
</code></pre>

<p><strong>Demo</strong>  </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const replaySubject$ = new Rx.ReplaySubject(); 
// Also, pass in a buffer size to stop blow-out (if applicable)
// const replaySubject$ = new Rx.ReplaySubject(maxBufferSize); 


// Events before subscribe
replaySubject$.next('event1');
replaySubject$.next('event2');

replaySubject$.subscribe(console.log);

// Events after subscribe
replaySubject$.next('event3');
replaySubject$.next('event4');</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","4716245","","","","","2018-01-18 20:59:28","","","","0","","","","CC BY-SA 3.0"
"48331250","1","48362537","","2018-01-18 22:20:32","","1","1294","<p>I have an autocomplete form field which works fine when it is a simple autocomplete.  However, when I try to add a custom filter, it fails.</p>

<p>The data for the autocomplete is coming from a parent component. The parent component has:</p>

<pre class=""lang-js prettyprint-override""><code>alldwgrevdata: Observable&lt;DrawingRevisionIDsOnly[]&gt;;
...
ngOnInit() {
    this.alldwgrevdata = this.drawingRevisionService.getAllDrawingRevisions();
}
</code></pre>

<p>and passes the data to the child in the template by:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;child [alldwgrevdata]=""alldwgrevdata | async""&gt;&lt;/child&gt;
</code></pre>

<p>The service returns <code>Observable&lt;DrawingRevisionIDsOnly[]&gt;</code>.</p>

<p>The child is set up like this:</p>

<pre class=""lang-js prettyprint-override""><code>export class DrawingSelectorComponent implements OnInit {
    @Input(""drawingrevs"")
    drawingrevs: DrawingRevision[] = [];

    @Input(""alldwgrevdata"")
    alldwgrevdata: DrawingRevisionIDsOnly[] = [];

    filteredrevdata: Observable&lt;DrawingRevisionIDsOnly[]&gt;;

    @Input()
    public parentForm: FormGroup;

    @Output()
    onDwgChange = new EventEmitter();

    constructor(private fb: FormBuilder, private drawingRevisionService: DrawingRevisionService, private messagesService: MessagesService) { }

    ngOnInit() {
        console.log(this.alldwgrevdata);
        let dwgSelectControl = new FormControl(this.drawingrevs);
        this.parentForm.addControl('attachedDwgsControl', dwgSelectControl);

        this.filteredrevdata = dwgSelectControl.valueChanges
            .startWith([])
            .map(dwgrev =&gt; dwgrev &amp;&amp; typeof dwgrev === 'object' ? (dwgrev.drawingID+"" ""+dwgrev.revisionid) : dwgrev)
            .map(dwgIDrevID =&gt; dwgIDrevID ? this.filter(dwgIDrevID) : this.alldwgrevdata.slice());
    }

    filter(dwgIDrevID: string): DrawingRevisionIDsOnly[] {
        return this.alldwgrevdata.filter(option =&gt; (option.drawingID+"" ""+option.revisionid).toLowerCase().indexOf(dwgIDrevID.toLowerCase()) === 0);
    }

    displayFn(dwgRev: DrawingRevisionIDsOnly): string {
        return dwgRev ? (dwgRev.drawingID+"" ""+dwgRev.revisionid) : """";
    }
}
</code></pre>

<p>The error is <code>this.alldwgrevdata is null</code>.  In the ngOnInit() method, the console.log does indeed output <code>null</code>, so the error makes sense to some degree.  The problem comes when setting the <code>valueChanges</code> part of the form control.</p>

<p>I tried to change</p>

<pre class=""lang-js prettyprint-override""><code>this.alldwgrevdata.slice()
</code></pre>

<p>to</p>

<pre class=""lang-js prettyprint-override""><code>(this.alldwgrevdata==null ? [] : this.alldwgrevdata.slice())
</code></pre>

<p>but that had no effect.</p>

<p>How can I either set an initial value for the Observable to an empty array, or force the valueChanges to wait until the data service is complete before being evaluated?  Or is there a completely different way to go about this which I am missing?  Thanks!</p>
","1100847","","4716245","","2018-01-21 00:37:40","2018-01-21 00:37:40","Angular 5 Material autocomplete has null initial value","<angular><autocomplete><rxjs><angular-material2><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48331354","2","","48253686","2018-01-18 22:30:01","","1","","<p>You can use a <code>.publishBehavior()</code> operator on the websocket, which internally has a BehaviorSubject.  </p>

<p>The 'publish' bit means it won't emit until connected, like a tap on a hose.  </p>

<p>Add to that the <code>.refCount()</code> operator and you get auto-connect on subscription, i.e a tap that's controlled by subscription count.</p>

<p>Docs: <a href=""http://reactivex.io/documentation/operators/refcount.html"" rel=""nofollow noreferrer"">RefCount</a></p>

<p><strong>Demo</strong> </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// mock websocket
const ws = new Rx.Subject()

const autoConnected = ws
  .do(x =&gt; console.log('ws emits', x)) // just to show ws stream
  .publishBehavior(null)  // make connectable, i.e only emit when subscribed
  .refCount()             // auto-connect on subscribe
  .filter(x =&gt; x)         // filter out that pesky initial value

ws.next(1) // before subscription - never emits

const subscription = autoConnected.subscribe(x =&gt; console.log('1st subscription', x))
ws.next(2)
ws.next(3)

subscription.unsubscribe()
ws.next(4)  // after unsubscribe - never emits

autoConnected.subscribe(x =&gt; console.log('2nd subscription', x))
ws.next(5) // after re-subscription - emits last plus next</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","4716245","","","","","2018-01-18 22:30:01","","","","1","","","","CC BY-SA 3.0"
"48334133","1","","","2018-01-19 04:30:25","","0","229","<p>Basically if a observable is converted from 'cold' to 'hot' by calling <code>share</code>, the stream can not be unsubscribe. I never know the rule before! And It introduce some interesting behavior such as </p>

<pre><code>const shared = false;
const myObservable = Observable.create(observer =&gt; {
    let counter = 0;
    const intervel = setInterval(() =&gt; {
        console.log(`${++counter} passed`)
        observer.next(counter)
    }, 1000)

    return () =&gt; {
        console.log('myObservable is realised')
        clearInterval(intervel)
    }
})
const start$ = Observable.fromEvent(startButton, 'click');
let interval$
if (shared) {
    interval$ = myObservable.share()
} else {
    interval$ = myObservable
}

const startInterval$ = start$.switchMapTo(interval$)

startInterval$
    .subscribe((v) =&gt; {
        console.log('subscribe', v)
    })
</code></pre>

<p>When <code>shared</code> is set to <code>false</code>, every time clicking the start button, the counter will start over from 0. If set to <code>true</code>, the counter will keep adding on</p>

<p>I create a customized observable by <code>Observable.create</code> with <code>unsubscribe</code> implemented. And I can see clearly that if <code>share</code> is invoked on a stream. <code>unsubscribe</code> will never be called</p>

<p>I had followed up several tutorials and use rxjs for quite a while, but uncover the rule first time on my own. Can anyone point out more reference on such rule?</p>
","2670585","","","","","2018-01-19 04:55:50","How to unsubscribe a shared stream","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48335686","1","","","2018-01-19 06:59:33","","2","97","<p><a href=""https://www.learnrxjs.io/operators/transformation/mergemap.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/transformation/mergemap.html</a></p>

<p>I am learning RxJS and find the documentation in below format.</p>

<pre><code>mergeMap(project: function: Observable, resultSelector: function: any, concurrent: number): Observable
</code></pre>

<p>I understand <code>concurrent: number</code> which means the third argument and its of type number. However, I don't understand first argument <code>project: function: Observable</code>. Is there some naming convention on the usage of 2 colons?</p>
","2392596","","","","","2018-01-19 07:01:15","RxJS Function Signature","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48349389","1","48349608","","2018-01-19 20:53:11","","0","295","<p>I have an Angular ""Quiz"" application and use <strong>rxjs 5.5.2</strong> to implement a service with some business logic. I have an issue with my rxjs flow that causes unexpected execution of function multiple times.</p>

<p>The repro steps:</p>

<ol>
<li>call <em>startNewQuiz</em> to set new quiz as active</li>
<li>call <em>answerQuestion</em> several times to answer quiz questions. Each answer triggers flow defined in constructor</li>
<li>call <em>startNewQuiz</em> once again to start another quiz</li>
</ol>

<p>The problem is that on step 3 call to <em>startNewQuiz</em> triggers <em>doStuffWithQuiz</em> multiple times. Debugging shows that this is because <em>this.activeQuiz$</em> emits a value on step 3 and triggers <em>doStuffWithQuiz</em>. And since I have called <em>answerQuestion</em> multiple times before on step 2 - <em>doStuffWithQuiz</em> also called multiple times. The only reason of using <em>activeQuiz$</em> in the flow is to get current quiz and pass it futher to pipe.</p>

<p>I want my <em>answerQuestionSubject</em> flow to be executed only when I push something to <em>answerQuestionSubject</em> and avoid triggering of <em>doStuffWithQuiz</em> when something pushed to <em>activeQuiz$</em>.</p>

<p><strong>So how can I accomplish it?</strong></p>

<pre><code>export class QuizFlowService {

  // to keep current active quiz
  private activeQuiz$ = new ReplaySubject&lt;Quiz&gt;(1);

  private answerQuestionSubject = new Subject&lt;Answer&gt;();

  ....

  constructor() {
    // setup flow for answers
    this.answerQuestionSubject.pipe(
      flatMap(
          // this is just to get active quiz and pass it futher
          () =&gt; this.activeQuiz$
      ),
      flatMap((quiz) =&gt; {
        // it is called multiple time on step 3
        doStuffWithQuiz(quiz)
      })
    ).subscribe();
  }

  // starts new quiz
  startNewQuiz(quiz: Quiz) {
    this.activeQuiz$.next(quiz);
  }

  // triggers answer flow
  answerQuestion(answer: Answer) {
    this.answerQuestionSubject.next(answer);
  }
}
</code></pre>
","4470907","","","","","2018-01-19 21:12:15","Rxjs: proper of Subject inside flatMap to avoid unexpected triggering","<angular><typescript><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48349608","2","","48349389","2018-01-19 21:12:15","","1","","<p>You should use the <a href=""https://www.learnrxjs.io/operators/filtering/first.html"" rel=""nofollow noreferrer"">first</a> operator in your first flatMap</p>

<pre><code>flatMap(
    () =&gt; this.activeQuiz$.first()
)
</code></pre>

<p>Since activeQuiz is a subject it can emit multiple times. (what is happening in step 3), however you are only concerned with the getting the active quiz (1 value). With first you will only listen for 1 value/emission.</p>
","7176268","","","","","2018-01-19 21:12:15","","","","0","","","","CC BY-SA 3.0"
"48362537","2","","48331250","2018-01-21 00:33:52","","1","","<p>On this line</p>

<pre class=""lang-js prettyprint-override""><code>.map(dwgIDrevID =&gt; dwgIDrevID ? this.filter(dwgIDrevID) : this.alldwgrevdata.slice());
</code></pre>

<p>can branch either way. If branching to  <code>this.filter()</code> (which also uses <code>this.alldwgrevdata</code>) you will get the same error message.</p>

<p>The problem is, on this line</p>

<pre class=""lang-html prettyprint-override""><code>&lt;child [alldwgrevdata]=""alldwgrevdata | async""&gt;&lt;/child&gt;
</code></pre>

<p>the value passed in will initially be null, and the default empty array used here</p>

<pre class=""lang-js prettyprint-override""><code>@Input(""alldwgrevdata"")
alldwgrevdata: DrawingRevisionIDsOnly[] = [];
</code></pre>

<p>will be over-ridden by that null. (Defaults only happen if the parameter is not passed in).</p>

<p>Instead of testing for null in lots of places, you could use @Input in combination with <code>set/get</code> syntax, and default null value to <code>[]</code> inside the set.</p>

<pre class=""lang-js prettyprint-override""><code>private _alldwgrevdata = [];
@Input('alldwgrevdata')
set alldwgrevdata(value: string) {
  this._alldwgrevdata = value || [];
}
get alldwgrevdata() {
  return this._alldwgrevdata;
}
</code></pre>
","4716245","","","","","2018-01-21 00:33:52","","","","1","","","","CC BY-SA 3.0"
"48377005","1","48379491","","2018-01-22 08:02:30","","1","708","<p><strong>Using RxJS 5 i want to solve the following:</strong></p>

<p>Lets say that Im fetching a list of categories of sorts from a REST API. </p>

<p>Based on each and one of those categories, I want to fetch sub categories from another REST endpoint.</p>

<p>Then, based on each and one of those sub categories, I want to fetch products and for each and one of those products we need to fetch the detailed description.</p>

<p>This I have solved. The problem is that the ajax calls escalate and under just a minute over 30k calls are made which results in bringing the server to its knees.</p>

<p>Now, since this is a nightly job Im okay with it taking some time as long as it completes successfully.</p>

<p>This is what I have:</p>

<pre><code>getCategories() // Wraps ajax call and returns payload with array of categories
      .switchMap(categories =&gt; Observable.from(categories))
      .mergeMap(category =&gt; 
        getSubCategories(category) // Wraps ajax call and returns payload with array of sub categories
          .catch(err =&gt; {
            console.error('Error when fetching sub categories for category:', category);
            console.error(err);
            return Observable.empty();
          })
      )
      .mergeMap(subCategories =&gt; Observable.from(subCategories))
      .mergeMap(subCategory =&gt; 
        getProducts(subCategory) // Wraps ajax call and returns payload with array of products
        .catch(err =&gt; {
          console.error('Error when fetching products for sub category:', subCategory);
          console.error(err);
          return Observable.empty();
        })
      )
      .mergeMap(products =&gt; Observable.from(products))
      .mergeMap(product =&gt; 
        getProductDetails(product) // Wraps ajax call and returns payload with product details
        .catch(err =&gt; {
          console.error('Error when fetching product details for product:', product);
          console.error(err);
          return Observable.empty();
        })
      )
      .mergeMap(productDetails =&gt; saveToDb(productDetails))
      .catch(err =&gt; {
        console.error(err);
      })
      .subscribe();
</code></pre>

<p>After the initial request where i fetch the categories, I want to:</p>

<p>Every call made to fetch sub categories should wait until the previous one is done. Only 5 ajax calls should be made at once when fetching products and those products details. After those 5 calls are done we trigger the next 5 calls etc.</p>

<p>Alternatively it could be controlled with time as in waiting x seconds before we do the next ajax call etc.</p>

<p>How would I go about to solve this in a nice with using RxJS based on my example above?</p>
","1547996","","","","","2018-01-22 10:32:11","How to control pressure of multiple ajax calls with RxJS","<javascript><node.js><rxjs><rxjs5><rxjs-dom>","1","0","","","","CC BY-SA 3.0"
"48379491","2","","48377005","2018-01-22 10:32:11","","3","","<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap"" rel=""nofollow noreferrer""><code>mergeMap</code></a> has an overload which takes an optional concurrency parameter. This you can utilize to control how many requests are being sent concurrently to your server. </p>

<blockquote>
  <p><code>public mergeMap(project: function(value: T, ?index: number): ObservableInput, resultSelector: function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any, concurrent: number): Observable</code></p>
</blockquote>

<pre><code>  .mergeMap(category =&gt; 
    getSubCategories(category) // Wraps ajax call and returns payload with array of sub categories
      .catch(err =&gt; {
        console.error('Error when fetching sub categories for category:', category);
        console.error(err);
        return Observable.empty();
      }),
    null, 
    5 /* concurrency */
  )
</code></pre>

<p>Also; mergeMap will convert anything observableLike to an Observables so if your <code>getSubCategories()</code> returns an Array that will automatically be converted to an observable, no further <code>Observable.from()</code> is needed.</p>
","106909","","","","","2018-01-22 10:32:11","","","","2","","","","CC BY-SA 3.0"
"48413852","1","48415627","","2018-01-24 02:20:29","","4","2326","<p>I'm new to RxJs and having trouble to achieve this in ""RxJs way"":</p>

<p>An infinite stream <code>a$</code> emits a value <code>a</code> once a while.</p>

<p><code>async()</code> takes the <code>a</code> and performs an async operation.</p>

<p>If <code>a$</code> emits values while <code>async</code> is pending, only keep the latest one <code>al</code>.</p>

<p>After the previous <code>async</code> completes, if there is an <code>al</code>, run <code>async(al)</code>.</p>

<p>And so on.</p>

<pre><code>a$:----a1----------a2----a3-----------------------a4-----------
       async(a1):------------end                  async(a4):---
                             async(a3):-----end
</code></pre>

<p>Here is what I came up with, a bit nasty:</p>

<pre><code>var asyncIdle$ = new Rx.BehaviorSubject()
var asyncRunning$ = new Rx.Subject()
var async$ = asyncIdle$

function async (val) {
  async$ = asyncRunning$
  // do something with val
  console.log(val + ' handling')
  setTimeout(() =&gt; {
    console.log(val + ' complete')
    async$.next()
    async$ = asyncIdle$
  }, 2000)
}

// simulate a$
var a$ = Rx.Observable.fromEvent(document, 'click')
.mapTo(1)
.scan((acc, curr) =&gt; acc + curr)
.do(val =&gt; console.log('got ' + val))


a$.debounce(() =&gt; async$)
.subscribe(val =&gt; {
  async(val)
})
</code></pre>
","3432641","","3432641","","2018-01-24 05:43:35","2021-08-11 12:11:04","RxJs: How to only maintain the latest value until inner observable complete","<javascript><rxjs><observable><rxjs5><reactive>","3","2","1","","","CC BY-SA 3.0"
"48415627","2","","48413852","2018-01-24 05:50:11","","0","","<p>You can use the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-audit"" rel=""nofollow noreferrer""><code>audit</code> operator</a> to solve the problem, like this (the comments should explain how it works):</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Simulate the source.

const source = Rx.Observable.merge(
  Rx.Observable.of(1).delay(0),
  Rx.Observable.of(2).delay(10),
  Rx.Observable.of(3).delay(20),
  Rx.Observable.of(4).delay(150),
  Rx.Observable.of(5).delay(300)
).do(value =&gt; console.log(""source"", value));

// Simulate the async task.

function asyncTask(value) {
  return Rx.Observable
    .of(value)
    .do(value =&gt; console.log("" before async"", value))
    .delay(100)
    .do(value =&gt; console.log("" after async"", value));
}

// Compose an observable that's based on the source.
// Use audit to ensure a value is not emitted until
// the async task has been performed.
// Use share so that the signal does not effect a
// second subscription to the source.

let signal;

const audited = source
  .audit(() =&gt; signal)
  .mergeMap(value =&gt; asyncTask(value))
  .share();

// Compose a signal from the audited observable to
// which the async task is applied.
// Use startWith so that the first emitted value
// passes the audit.

signal = audited
  .mapTo(true)
  .startWith(true);

audited.subscribe(value =&gt; console.log(""output"", value));</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","6680611","","6680611","","2018-01-24 06:01:55","2018-01-24 06:01:55","","","","2","","","","CC BY-SA 3.0"
"48415804","1","","","2018-01-24 06:06:11","","0","50","<p>I intend to create a reactive ""value"" of generic type <code>T</code> with following properties:</p>

<ol>
<li>It can be used as observable by multiple subscribers.</li>
<li>The first subscriber triggers a value calculation.</li>
<li>Any new subscriber is dispatched the last cached value.</li>
<li>A new value can be externally set anytime and is published to all subscribers.</li>
<li>When last subscriber is removed, any ongoing calculation must stop.</li>
<li>When a new value is set externally, any triggered calculation result is ignored.</li>
</ol>

<p>Intended usage:</p>

<pre><code>// calculates value on demand
function getValue&lt;Number&gt;():Observable&lt;Number&gt;{
  // return an observable of some number, takes 1-2 seconds to calculate
}

// sticky observable of value
const value = new StickyValue&lt;Number&gt;(getValue);

// first subscriber triggers calculation
value.subscribe((n) =&gt; console.log(n));

// value can be set externally, the subscribers get this value ignoring any triggered calculation result
value.next(500);

// second subscriber gets value that was last set or last calculated
value.subscribe((n) =&gt; console.log(n));
</code></pre>

<p>Assumptions: <code>calculation()</code> is a simple function that returns Observable of the value</p>

<p>From comments, I find that <code>BehaviourSubject</code> comes close. But it still doesn't satisfy the conditions 2 and 6.</p>
","1531054","","1531054","","2018-01-29 10:28:59","2018-01-29 10:28:59","Creating a sticky reactive value (Subject)","<typescript><reactive-programming><rxjs5>","0","3","","","","CC BY-SA 3.0"
"48420900","1","64570545","","2018-01-24 11:03:27","","10","3477","<p>I have to test a function that uses the <strong>fromEvent</strong> observable function. 
Before the upgrade to 'lettable' operators, I was just doing this: </p>

<pre><code>spyOn(Observable, 'fromEvent').and.callFake(mockFromEventFunction)
</code></pre>

<p>But now, Rxjs have changed, and <strong>Observable.fromEvent</strong> is just a function named <strong>fromEvent</strong>, that is imported like this: (and used the same way)</p>

<pre><code>import { fromEvent } from 'rxjs/observable/fromEvent';
</code></pre>

<p>My question is, how I can mock that function with Jasmine spy utilities without knowing it's parent context?</p>

<p>I advise that this doesn't work:</p>

<pre><code>import * as FromEventContext from 'rxjs/observable/fromEvent';
...
spyOn(FromEventContext , 'fromEvent').and.callFake(mockFromEventFunction)
</code></pre>

<p>Now I have a workaround wrapping that fromEvent in one Object which I know the context. But I am wondering how I can solve this cleanly.</p>

<p>Thanks in advance.</p>
","6099651","","6099651","","2018-05-25 12:48:48","2020-10-28 10:04:44","How can I mock fromEvent function from RXJS 5.5.6?","<angular><unit-testing><jasmine><rxjs5><rxjs6>","3","3","3","","","CC BY-SA 3.0"
"48437228","1","48437538","","2018-01-25 06:57:09","","2","427","<p>I'm using Angular 5 and angularfire2 to work with Firebase.
I have an array of strings which represent <strong>paths</strong> into firebase.
What I'm currently doing is this:</p>

<pre><code>const pathList: string[] = ['path1', 'path2', 'path3'];
const observableList     = [];
pathList.map((location: string[]) =&gt; {
    observableList.push(this.db.object(`path_to_something/${location}).valueChanges());
});

const combined = zip(observableList);
combined.subscribe((values: any[]) =&gt; {
    console.log('DATA FROM ZIP', values);
}, err =&gt; {
    console.log('DATA FROM ZIP ERROR', err);
});
</code></pre>

<p>That's what I've been trying but, the Observables doesn't seem to trigger. Any result on the console is displayed. Any idea on how this could work.</p>

<p>I tried with forkJoin and nothing as well. But I tried with combineList and it works. The issue with that is, I have to use <code>zip</code></p>
","5195717","","310726","","2018-01-26 07:28:04","2018-01-26 07:28:04","How to use Observable.Zip with angularfire2?","<angular><rxjs><angularfire2><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48437538","2","","48437228","2018-01-25 07:19:31","","5","","<p>If the same Rx chain worked with <code>combineLatest</code> it should work with <code>zip</code> as well. If it doesn't emit anything try unwrapping the array of Observables:</p>

<pre><code>const combined = zip(...observableList);
</code></pre>

<p>You can try it with the following demo and see that if you pass the array as is it won't emit anything:</p>

<p><a href=""http://jsbin.com/davadol/3/edit?js,console"" rel=""noreferrer"">http://jsbin.com/davadol/3/edit?js,console</a></p>

<pre><code>const a = Observable.of(1);
const b = Observable.of(2);
const c = Observable.of(3);

Observable.zip([a, b, c]).subscribe(console.log);
</code></pre>

<p>But if you unwrap the array it works:</p>

<pre><code>Observable.zip(...[a, b, c]).subscribe(console.log);
</code></pre>

<p>To be honest I'm surprised it doesn't work with the array because by looking at the typings I think it should, see <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/zip.ts#L26"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/zip.ts#L26</a>.
This should be the same use-case like with <code>combineLatest</code> and <code>forkJoin</code> where it works. To my surprised I recently found out that it doesn't work with <code>Observable.concat</code> either.</p>
","310726","","","","","2018-01-25 07:19:31","","","","0","","","","CC BY-SA 3.0"
"48437612","1","48437642","","2018-01-25 07:24:32","","0","308","<p>I'm creating a form with some inputs I want to control, for example, I have an email input.</p>

<p>I'm creating an observable to check if users wrote has email format:</p>

<pre><code>//html:
&lt;input matInput type=""email"" ngModel (ngModelChange)=""emailChanged$.next($event)"" name=""email"" required placeholder=""EMAIL""/&gt;

//ts:
export class MyComponent implements OnInit {

   emailValid$: Observable&lt;boolean&gt;;
   emailChanged$: Subject&lt;string&gt;;
   subscription: Subscription;


   constructor() {


      this.emailChanged$ = new Subject&lt;string&gt;();

      this.subscription = this.emailChanged$
       .debounceTime(500)
       .map(this.isValidEmail)
       .subscribe(isValid =&gt; this.emailValid$ = isValid)

   }

   isValidEmail(email: string): Observable&lt;boolean&gt;{
       return Observable.of(/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(email));
   }
</code></pre>

<p>But it's not correct, I have this error when executing (and debounceTime expires)</p>

<pre><code>TypeError: Observable_1.Observable.of is not a function
  at MapSubscriber.MyComponent.isValidEmail [as project] (my-component.component.ts:73)
  at MapSubscriber._next (map.js:79)
</code></pre>

<p>How can I solve it?</p>
","5212118","","","","","2018-01-25 07:29:47","Suscription and subject for form changes","<angular><rxjs><rxjs5><angular5>","2","4","","","","CC BY-SA 3.0"
"48437642","2","","48437612","2018-01-25 07:26:29","","3","","<p>Import <code>of</code> from the </p>

<pre><code>import { of } 'rxjx/observables/of'
</code></pre>

<p>and use it without Observable, just <code>of</code>.</p>

<pre><code>isValidEmail(email: string): Observable&lt;boolean&gt;{
    return of(/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(email));
}
</code></pre>
","5496973","","","","","2018-01-25 07:26:29","","","","0","","","","CC BY-SA 3.0"
"48447351","1","48452283","","2018-01-25 16:12:43","","0","611","<p>I have React app which uses redux-observable with typescript. In this scenario, FetchAttribute Action gets triggered with a id and then make an ajax call. 
In certain case, I would want to cancel the ajax request if ""FETCH_ATTRIBUTE_CANCEL"" action was triggered with the same id as of ""FetchAttributeAction"" action.</p>

<pre><code>action$.ofType(FETCH_ATTRIBUTE)
    .switchMap((request: FetchAttributeAction) =&gt; {

      return ajax.getJSON(`/api/fetch-attribute?id=${request.id}`)
        .flatMap((fetchUrl) =&gt; {
            // return new action
        })
        .takeUntil(action$.ofType(FETCH_ATTRIBUTE_CANCEL));
    });

interface FetchAttributeAction{
  id: number;
}
</code></pre>

<p>Problem:
How do we cancel the execution based on action type + action data?
In my case, it would FETCH_ATTRIBUTE_CANCEL and id.</p>
","1451523","","","","","2018-01-25 23:11:34","ReduxObservable cancellation based on action type and its data","<rxjs><rxjs5><redux-observable>","2","0","","","","CC BY-SA 3.0"
"48448364","1","48451447","","2018-01-25 17:06:18","","13","1801","<p>Let's say I have two classes, where you can observe over some observables.</p>

<p>First example, with public subject:</p>

<pre><code>class EventsPub {
   public readonly onEnd = new Subject&lt;void&gt;();
}
</code></pre>

<p>Second example, with private subject and registering method:</p>

<pre><code>class EventsPriv {
   private readonly endEvent = new Subject&lt;void&gt;();

   public onEnd(cb: () =&gt; void): Subscription {
       return this.endEvent.subscribe(cb);
   }
}
</code></pre>

<p>The first example is somehow unsafe because anyone can call <code>eventsPub.endEvent.next()</code> from outside the class and introduce side effects, however, comparing to example 2 It allows for pipes, which is a big plus since developers can for ex. register only for the first event with <code>eventsPub.onEnd.pipe(first()).subscribe(cb)</code>.</p>

<p>The second example also allows for one-time subscription but requires more code and ugly unsubscribing.</p>

<pre><code>const subscription = eventsPriv.onEnd(() =&gt; {
    // logic..
    subscription.unsubscribe()
});
</code></pre>

<p>From your point of view, which is the best way to go? Or maybe there is a better solution?</p>
","3080954","","310726","","2018-01-26 08:02:19","2018-01-26 08:02:19","Should rxjs subjects be public in the class?","<javascript><angular><rxjs><reactive-programming><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"48451447","2","","48448364","2018-01-25 20:34:58","","21","","<p>This is based a lot on my personal preference but I'd do it like this:</p>

<pre><code>class EventsPriv {
   private readonly endEvent = new Subject&lt;void&gt;();

   get endEvent$(): Observable&lt;void&gt; {
      return this.endEvent;
   }
}
</code></pre>

<p>So inside the class I'll use <code>endEvent</code> while I can still use it eg. in a template with <code>obj.endEvent$ | async</code> and from the outside it behaves like an Observable.</p>

<p>Note, that in fact I'm returning the same instance of <code>Subject</code>. The only thing that restricts the outside world from misusing it with <code>obj.endEvent$.next()</code> are Typescript's type guards. If I was using just JavaScript or if I typecasted it to <code>any</code> I could call <code>next</code>.</p>

<p>This is actually the recommended way of exposing <code>Subject</code>s instead of using the <code>asObservable()</code> operator. You can notice that this is used everywhere internally in RxJS 5. For example if you look at <code>repeatWhen</code> synopsys:</p>

<pre><code>public repeatWhen(notifier: function(notifications: Observable): Observable): Observable
</code></pre>

<p>You can see that the <code>notifier</code> function receives an Observable as a parameter (you can see it in the code here as well <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/repeatWhen.ts#L29"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/repeatWhen.ts#L29</a>).</p>

<p>But if you look into the code where the function is called you'll see they are in fact passing a <code>Subject</code> and not an <code>Observable</code>: <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/repeatWhen.ts#L114-L115"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/repeatWhen.ts#L114-L115</a>.</p>

<p>This has been discussed on RxJS GitHub page and reasons for this are performance and that the Typescript type guards are sufficient. You can read more in these discussions:</p>

<ul>
<li><p><a href=""https://github.com/ReactiveX/rxjs/pull/2408"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/pull/2408</a></p></li>
<li><p><a href=""https://github.com/ReactiveX/rxjs/issues/2391"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/issues/2391</a></p></li>
</ul>
","310726","","","","","2018-01-25 20:34:58","","","","0","","","","CC BY-SA 3.0"
"48452283","2","","48447351","2018-01-25 21:36:31","","4","","<p>The key is to filter actions in the <code>takeUntil</code> notifier to only those which match the ID you care about.</p>

<p><code>action$.ofType(FETCH_ATTRIBUTE_CANCEL).filter(action =&gt; action.id === request.id)</code></p>

<p>So here's what it might look like:</p>

<p>Demo: <a href=""https://stackblitz.com/edit/redux-observable-playground-xztkoo?file=fetchAttribute.js"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/redux-observable-playground-xztkoo?file=fetchAttribute.js</a></p>

<pre><code>const fetchAttributeEpic = action$ =&gt;
  action$.ofType(FETCH_ATTRIBUTE)
    .mergeMap(request =&gt;
      ajax.getJSON(`/api/fetch-attribute?id=${request.id}`)
        .map(response =&gt; fetchAttributeFulfilled(response))
        .takeUntil(
          action$.ofType(FETCH_ATTRIBUTE_CANCEL).filter(action =&gt; action.id === request.id)
        )
    );
</code></pre>

<p>You can also take a look at previous questions: </p>

<ul>
<li><a href=""https://stackoverflow.com/questions/47528620/redux-observable-if-the-same-action-is-dispatched-multiple-times-how-do-i-canc"">Redux Observable: If the same action is dispatched multiple times, how do I cancel one of them?</a></li>
<li><a href=""https://stackoverflow.com/questions/41966806/independent-chain-cancellation-in-redux-observable"">Independent chain cancellation in redux-observable?</a></li>
<li><a href=""https://stackoverflow.com/questions/41032226/dispatch-an-action-in-response-to-cancellation"">Dispatch an action in response to cancellation</a></li>
</ul>

<hr>

<p>The OP also pointed out that they were using <code>switchMap</code> (as did I originally when I copied their code) which would have meant that the epic only ever had one getJSON at a time since <code>switchMap</code> will unsubscribe from previous inner Observables. So that also needed to be chained. Good catch!</p>
","1770633","","1770633","","2018-01-25 23:11:34","2018-01-25 23:11:34","","","","3","","","","CC BY-SA 3.0"
"48457648","1","","","2018-01-26 08:06:15","","0","572","<p>This code logs different result for RxJS 4 and RxJS 5</p>

<p><code>Rx.Observable.merge(
  Rx.Observable.from([1,2,3,4]),
  Rx.Observable.from([5,6,7])
).subscribe(i =&gt; console.log(i))</code></p>

<p>Result for RxJS 4: 1,5,2,6,3,7,4 - the result is correct according to the docs of merge:</p>

<blockquote>
  <p>Creates an output Observable which <strong>concurrently</strong> emits all values
  from every given input Observable</p>
</blockquote>

<p>RxJS5: 1,2,3,4,5,6,7 - result is the same as from concat operator that is not as described in docs</p>

<p>So how to get the values from two array observables concurrently in RxJS5?</p>
","7747647","","6680611","","2018-01-26 08:10:45","2018-01-26 09:18:56","RxJS 5 merge operator doesn't work for observables created from array","<rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"48459752","1","","","2018-01-26 10:40:39","","0","115","<p>Since rxjs 5.5's change with <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md"" rel=""nofollow noreferrer""><s>""lettable operators""</s></a> <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""nofollow noreferrer"">""pipeable operators""</a> it is recommended to stop importing from <code>rxjs/add/operator/*</code> to allow for proper tree shaking. Does this also apply for Observables like <code>rxjs/add/observable/of</code>? <code>rxjs/observable/of</code> exists but doesn't appear to provide the compatible typing.</p>
","557552","","","","","2018-01-26 10:40:39","New import of Observables since 5.5","<rxjs><rxjs5>","0","8","","","","CC BY-SA 3.0"
"48475506","1","48558054","","2018-01-27 11:52:14","","0","185","<p>(FYI. The context of this is an Angular 5 app, however the circumstance is not particular to Angular per se)</p>

<p>I have a few operators that use a lot in the same way in various places. To repeat less code, I stored them in a base class:</p>

<pre><code>export class ComponentBase {

  protected unSubscriber$: Subject&lt;any&gt; = new Subject();
  protected endWhenDestroyed = takeUntil(this.unSubscriber$);
  protected filterOutNulls = filter(x =&gt; notNullOrUndefined(x));

  ngOnDestroy() {
    this.unSubscriber$.next();
    this.unSubscriber$.complete();
  }
...
</code></pre>

<p>Later, other components inherit from the class above and simply reuse those operators:</p>

<pre><code>class SomeClass extends ComponentBase {
...
    someObservable$
      .pipe(this.filterOutNulls, this.endWhenDestroyed)
      .subscribe((y) =&gt; ...) // type of `y` is lost by typescript
...
</code></pre>

<p>If I use the operators normally like</p>

<pre><code>class SomeClass extends ComponentBase {
...
    someObservable$
      .pipe(filter(x =&gt; !!x), takeUntil(this.unSubscriber$))
      .subscribe((y) =&gt; ...)
...
</code></pre>

<p>then, TypeScript understands that the type of <code>y</code> (on the subscribe) is the one from the source observable. However, when I use my <em>cached</em> operators, the type is lost and I need to do <code>.subscribe((y: WhatEverType) =&gt; ...</code> for it to compile and the editor (IntelliJ, in my case) to stop complaining.</p>

<p>Now, this code below makes it all work...</p>

<pre><code>    const getOp = &lt;T&gt;(): MonoTypeOperatorFunction&lt;T&gt; =&gt; {
      return filter(x =&gt; !!x);
    };
...
    someObservable$
      .pipe(getOp&lt;TheType&gt;())
      .subscribe((y) =&gt; ...)
</code></pre>

<p>However, my question is if there's a way for the types to continue to flow as they do when the operator functions are declared inline without having to manually cast the type neither in the subscriber nor the cached operator as shown above.</p>

<p>In any case, I'd appreciate any other elegant alternatives of doing this.</p>

<p>Thanks indeed</p>
","2282801","","2282801","","2018-02-01 08:12:24","2018-02-01 08:12:24","How can I ""cache"" rxjs lettable operators and reuse them in multiple `.pipe()` calls without breaking TypeScript's type checking","<typescript><visual-studio-code><webstorm><rxjs5><angular5>","1","1","","","","CC BY-SA 3.0"
"48477095","1","48511425","","2018-01-27 15:05:07","","1","128","<p>I would like to have a observable that fires when a distinct change was made or an interval hits.</p>

<p>The use-case is I would like to load a http request whenever the selected entity is changed, but over a specified time it should be reloaded.</p>

<p>A: user select entity on each route change.</p>

<p>B: Interval.</p>

<p>C: Expected output.</p>

<pre><code>A: --2--2--2--2--2--2--2--3--3--3--2--2--2--2--2--
B: --------1--------2--------3--------4--------5--
C: --2-----2--------2-----3--3-----2--2--------2-- 
</code></pre>

<p>I tried many ways, but none of them working. All the combinations of throttleTime and distinct I could think of with external variables.</p>

<p>EDIT:</p>

<p>One another case that shows C does not have to be triggered, as being a http request.</p>

<pre><code>A: --2--2--------------2--3--3-----------2--------
B: --------1--------2--------3--------4--------5--
C: --2-----------------2--3--3-----------2-------- 
</code></pre>

<p>Output of C:</p>

<pre><code>2: triggered as A wants to run the http request.
-: not triggered as it is too close (in time) to request before.
-: just the timer ticks.
-: just the timer ticks.
2: triggered as being far away from (in time) the request before.
3: triggered as different id for the http request.
3: triggered as the timer ticked and http request can be sent.
-: just the timer ticks.
2: loaded
-: just the timer ticks.
</code></pre>
","1558028","","1558028","","2018-01-29 22:19:41","2018-01-29 23:01:38","RxJS distinct throttleTimer","<rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"48486542","1","48486766","","2018-01-28 12:50:40","","0","1862","<p>None of similar asked questions helped me, so here goes my problem
I am using rxjs subscribe method, but it is been fired twice and i would like it to be called once.
Here is my code:</p>

<pre><code>import { Component } from '@angular/core';
import { NavController, NavParams } from 'ionic-angular';
import { StatusBar } from '@ionic-native/status-bar';
import { Validators, FormBuilder, FormGroup } from '@angular/forms';
import { CadastrarUsuarioPage } from '../cadastrar-usuario/cadastrar-usuario';
import { FirebaseProvider} from '../../providers/firebase/firebase';
import { AngularFireOfflineDatabase, AfoListObservable, AfoObjectObservable } from 'angularfire2-offline/database';
import { HomePage } from '../home/home';
@Component({  
  selector: 'page-login',
  templateUrl: 'login.html',
})
export class LoginPage {
  private form: FormGroup;
  private usuario: string;
  private senha: string;
  public afoList: AfoListObservable&lt;any[]&gt;;  
  constructor(public navCtrl: NavController,
              public navParams: NavParams,
              private statusBar: StatusBar,
              private formBuilder: FormBuilder,
              private afoDatabase: AngularFireOfflineDatabase
            ) {
                this.form = this.formBuilder.group({
                  usuario: ['', Validators.required],
                  senha: ['', Validators.required]
                });
  }

  ionViewDidLoad()
  {
    this.statusBar.hide(); 
  }

  entrar()
  {
    let usuario_senha = this.usuario + ""_"" + this.senha;
    this.afoDatabase.list('usuarios/', {query: {
      orderByChild: 'usuario_senha',
      equalTo: usuario_senha
    }}).take(1).subscribe((x) =&gt; {
      if(x.length == 1)
      {
        console.log(""true"");
      }
      else
      {
        console.log(""false"");
    }},
    error =&gt;{
        console.error(""Error in subscribe: "", error.message);
    },
    () =&gt;{
      console.log(""done"");
      });
  }

  abrirCadastrarUsuario()
  {
    this.navCtrl.push(CadastrarUsuarioPage);
  }
}
</code></pre>

<p>and it prints âfalseâ/âtrueâ and âdoneâ 2x each time it is called.</p>

<p><strong>--UPDATE --</strong>
as ordered, the entire code, it is been called inside a button click</p>

<p><strong>-- UPDATE --</strong> 
The component from where it is been called from</p>

<pre><code>&lt;ion-content padding class=""content""&gt;
    &lt;ion-grid&gt;
      &lt;form [formGroup]=""form"" (ngSubmit)=""entrar()""&gt;
        &lt;ion-row style=""height:50px;margin-top:30px"" align-items-center&gt;
          &lt;ion-col col-12 text-center class=""login-title""&gt;
            Login Offline
          &lt;/ion-col&gt;
        &lt;/ion-row&gt;
        &lt;ion-row&gt;
          &lt;ion-col col-12&gt;
            &lt;ion-list&gt;
              &lt;ion-item class=""no-background border-top-transparent""&gt;
                &lt;ion-label color=""branco"" floating&gt;UsuÃ¡rio&lt;/ion-label&gt;
                &lt;ion-input type=""text"" [(ngModel)]=""usuario"" formControlName=""usuario""&gt;&lt;/ion-input&gt;
              &lt;/ion-item&gt;
            &lt;/ion-list&gt;
            &lt;ion-list&gt;
              &lt;ion-item class=""no-background border-top-transparent""&gt;
                &lt;ion-label color=""branco"" floating&gt;Senha&lt;/ion-label&gt;
                &lt;ion-input type=""password"" [(ngModel)]=""senha"" formControlName=""senha""&gt;&lt;/ion-input&gt;
              &lt;/ion-item&gt;
            &lt;/ion-list&gt;
          &lt;/ion-col&gt;
        &lt;/ion-row&gt;
        &lt;ion-row&gt;
          &lt;ion-col col-12&gt;
            &lt;button type=""submit"" color=""branco"" style=""height:50px"" (click)=""entrar()"" ion-button block outline round&gt;Entrar&lt;/button&gt;
          &lt;/ion-col&gt;
        &lt;/ion-row&gt;
      &lt;/form&gt;
    &lt;/ion-grid&gt;
    &lt;div class=""cadastrar""&gt;&lt;p class=""cadastrar-texto"" (click)=""abrirCadastrarUsuario()""&gt;Cadastre-se&lt;/p&gt;&lt;/div&gt;
&lt;/ion-content&gt;
</code></pre>
","6016825","","6016825","","2018-01-28 13:07:50","2018-01-28 13:17:45","Rxjs Subscribe been called twice","<angular><typescript><rxjs><rxjs5>","1","8","","","","CC BY-SA 3.0"
"48486766","2","","48486542","2018-01-28 13:17:45","","3","","<p>Your <code>entrar()</code> function is called twice because of <code>ngSubmit</code> here: </p>

<p><code>&lt;form [formGroup]=""form"" (ngSubmit)=""entrar()""&gt;</code></p>

<p>and button's type submit in here: </p>

<p><code>&lt;button type=""submit"" color=""branco"" style=""height:50px"" (click)=""entrar()"" ion-button block outline round&gt;Entrar&lt;/button&gt;</code></p>

<p>Basically on button's click event you are submitting the form which indirectly call the <code>entrat()</code> function from <code>(ngSubmit)</code> while on the other hand this function is also directly called from button's click <code>(click)=""entrar()""</code>   </p>
","1422333","","","","","2018-01-28 13:17:45","","","","0","","","","CC BY-SA 3.0"
"48487857","1","48488091","","2018-01-28 15:16:27","","2","8017","<p>There's time's where I want to subscribe to an observable only to have an emit trigger additional events. For example, subscribing to query parameters in the route so that another event is triggered from an emit - where the value emitted isn' actually important. Or for example if I have a BehaviorSubject and need to reload certain components based on changes to that subject. In these cases the observable isn't meant to be consumed by a template and the values they emit is for the most part disregarded. </p>

<p>Ideally I would write something like:</p>

<pre><code>ngOnInit() {
    this.service.behaviorSubject.subscribe(
        () =&gt; callLocalMethod()
    )
}
</code></pre>

<p>The problem is that angular doesn't unsubscribe from that subscription once the component is destroyed, meaning that every time the component is initialized and destroyed a new subscription is created in addition to the old one and emits from the observable are called for each of those redundant subscriptions. Unsubscribing in the OnDestroy lifecycle hook is not possible (from what I can tell) since the subscription isn't assigned to a property - but assigning it to a property seems unnecessary for this use case. </p>

<p>So what I end up having to do is create a property for every single subscription even if that property is never going to be used, assigning it to the subscription, and then calling <code>unsubscribe()</code> on it when the component is destroyed. </p>

<p>This seems really redundant - is there a better approach to this? Handling the subscription with an async pipe isn't an option, and using EventEmitter instead also isn't an option since often times want it to behave like a hot observable.  </p>
","4518577","","4518577","","2018-01-28 15:31:52","2018-01-28 15:49:00","Is there a way to unsubscribe to a BehaviorSubject without assignment?","<angular><rxjs><rxjs5><reactive><behaviorsubject>","2","6","","","","CC BY-SA 3.0"
"48488091","2","","48487857","2018-01-28 15:39:53","","8","","<p>You can use another subject:</p>

<pre><code>private destroy$ = new Subject();

constructor() {
  obs$
    // Ensures that we complete when the component is
    // destroyed. Completing will automatically unsubscribe. 
    .takeUntil(this.destroy$)
    .subscribe();
} 

ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}
</code></pre>

<p>The nice thing about this is that it scales nicely as the boilerplate is only needed once regardless of the number of subscriptions you manage. </p>

<p>Also note that ActivatedRouter actually completes <code>params</code> / <code>paramMap</code> when the component is destroyed, so parameter changes do not need to be unsubscribed from manually. </p>
","1675492","","","","","2018-01-28 15:39:53","","","","2","","","","CC BY-SA 3.0"
"48493924","1","48650590","","2018-01-29 03:23:15","","7","519","<p>Imagine I have the following code:</p>

<pre><code>let a = Rx.Observable.of(1, 2, 3)
let b = Observable.zip(a, a, (a, b) =&gt; a + b)
b.forEach(t =&gt; console.log(t))
</code></pre>

<p>This immediately outputs the results. Now, how do I put a timed delay between each message as a <strong>way of back-pressure</strong> (note that I don't want a buffer; instead, I want <code>a</code> and <code>b</code> to become <strong>Cold Observables</strong>), like:</p>

<pre><code>b.takeEvery(1000).forEach(t =&gt; console.log(t))
</code></pre>

<p>And have the exact same answer:</p>

<pre><code>&lt;wait 1s&gt;
2
&lt;wait 1s&gt;
4
&lt;wait 1s&gt;
6
</code></pre>

<hr>

<p><strong>Alternative:</strong> If backpressure (ou pull mechanisms for some observables) is something not supported in RxJS, then how could one create an infinite generator without running out of resources?</p>

<p><strong>Alternative 2:</strong> Other JS frameworks that support both pull and push mechanisms?</p>
","41652","","41652","","2018-01-29 12:54:47","2018-02-07 10:28:48","How can I apply timed back pressure in RxJS5?","<javascript><rxjs><observable><rxjs5><reactivex>","2","0","","","","CC BY-SA 3.0"
"48504929","1","","","2018-01-29 15:41:57","","2","233","<p>What is the solution for long stack traces in RxJS 5? I.e. stack traces that include asynchronous calls leading to the error being thrown.</p>

<p>I've seen all kinds of hacks for older versions, but nothing for this version except for promises that developers are working on it.</p>

<p>For example, I've encountered the following stack trace:</p>

<pre><code>TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at Object.subscribeToResult (MyProject\node_modules\src\util\subscribeToResult.ts:82:23)
    at MergeMapSubscriber._innerSub (MyProject\node_modules\src\operators\mergeMap.ts:138:14)
    at MergeMapSubscriber._tryNext (MyProject\node_modules\src\operators\mergeMap.ts:134:10)
    at MergeMapSubscriber._next (MyProject\node_modules\src\operators\mergeMap.ts:118:12)
    at MergeMapSubscriber.Subscriber.next (MyProject\node_modules\src\Subscriber.ts:96:12)
    at ArrayObservable._subscribe (MyProject\node_modules\src\observable\ArrayObservable.ts:124:20)
    at ArrayObservable.Observable._trySubscribe (MyProject\node_modules\src\Observable.ts:217:19)
    at ArrayObservable.Observable.subscribe (MyProject\node_modules\src\Observable.ts:202:87)
    at MergeMapOperator.call (MyProject\node_modules\src\operators\mergeMap.ts:92:19)
    at Observable.subscribe (MyProject\node_modules\src\Observable.ts:200:16)
    at Object.subscribeToResult (MyProject\node_modules\src\util\subscribeToResult.ts:34:21)
    at MergeMapSubscriber._innerSub (MyProject\node_modules\src\operators\mergeMap.ts:138:14)
    at MergeMapSubscriber._tryNext (MyProject\node_modules\src\operators\mergeMap.ts:134:10)
    at MergeMapSubscriber._next (MyProject\node_modules\src\operators\mergeMap.ts:118:12)
    at MergeMapSubscriber.Subscriber.next (MyProject\node_modules\src\Subscriber.ts:96:12)
    at ArrayObservable._subscribe (MyProject\node_modules\src\observable\ArrayObservable.ts:124:20)
    at ArrayObservable.Observable._trySubscribe (MyProject\node_modules\src\Observable.ts:217:19)
    at ArrayObservable.Observable.subscribe (MyProject\node_modules\src\Observable.ts:202:87)
    at MergeMapOperator.call (MyProject\node_modules\src\operators\mergeMap.ts:92:19)
    at Observable.subscribe (MyProject\node_modules\src\Observable.ts:200:16)
    at Observable._subscribe (MyProject\node_modules\src\Observable.ts:275:24)
    at Observable.subscribe (MyProject\node_modules\src\Observable.ts:202:63)
</code></pre>

<p>Now, this is definitely a 100% user error that can be linked to some part of my own code, but it's not really possible to tell where it came from.</p>
","1333004","","","","","2018-01-29 22:14:35","Long stack traces in rxjs","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48510274","1","48512442","","2018-01-29 21:27:08","","2","2217","<p>I'm using redux-thunk to manage async stuff in my react application and I want to use redux-observable to manage complex async flow more easily (concat multiple Ajax calls for example). Is there a way to do so without modify what's already done?</p>

<p>Here's an example of what I mean:</p>

<pre><code>const fetchSomeData = () =&gt; {
    return (dispatch, getState) =&gt; {
        doAnAjaxCall((err, response) =&gt; {
            if (err) return dispatch({type: 'ERROR', err})
            // do something
            return dispatch({type: 'SUCCESS', response})
        })
    }
}
</code></pre>

<p>Is it possible to use <code>fetchSomeData</code> inside an epic?<br>
Since redux-thunk is promise based redux-observable should allow that, am I missing something?</p>
","9285685","","","","","2018-01-30 01:11:59","use of redux-thunk with redux-observable","<javascript><reactjs><rxjs5><redux-thunk><redux-observable>","1","1","1","","","CC BY-SA 3.0"
"48511191","1","","","2018-01-29 22:38:13","","0","2691","<p>I have this:</p>

<pre><code>import {EventEmitter} from '@angular/core';
...
public dialogEmitter = new EventEmitter();
</code></pre>

<p>I tried this in a component:</p>

<pre><code>this.x.dialogEmitter.first().subscribe(cb);
</code></pre>

<p>But it says that subscribe is not a function. Same problem occurs when I try:</p>

<pre><code>this.x.dialogEmitter.take(1).subscribe(cb);
</code></pre>

<p>is there another pattern I can use to only listen for the first event?</p>
","1223975","","1223975","","2018-01-29 22:52:53","2018-03-29 20:08:02","Subscribe once using first() or take(1) from Angular EventEmitter","<angular><rxjs5>","1","6","","","","CC BY-SA 3.0"
"48511425","2","","48477095","2018-01-29 23:01:38","","0","","<p>The <a href=""https://www.learnrxjs.io/operators/combination/withlatestfrom.html"" rel=""nofollow noreferrer"">withLatestFrom</a> is the proper way to connect data from an obervavble without subscribing to its triggers.</p>

<p>The working piece of code:</p>

<pre><code>loadTimer = timer(0, 60000); //b$
c$ = a$.pipe(
  withLatestFrom(this.loadTimer, (action, timerValue) =&gt; ({ action, timerValue })),
  distinctUntilChanged((a, b) =&gt; a.action.payload === b.action.payload &amp;&amp; a.timerValue === b.timerValue),
  tap(a =&gt; console.log(a)),
  map(a =&gt; a.action),
  exhaustMap(action =&gt;
    this.businessLoaderService
      .load(action.payload)
      ...
  )
</code></pre>
","1558028","","","","","2018-01-29 23:01:38","","","","0","","","","CC BY-SA 3.0"
"48512442","2","","48510274","2018-01-30 01:11:59","","6","","<p>Yep! You totally can use them together. Just place the redux-thunk middleware <em>before</em> the redux-observable middleware.</p>

<pre><code>applyMiddleware(thunkMiddleware, epicMiddleware)
</code></pre>

<p><a href=""https://stackblitz.com/edit/redux-observable-playground-8c7pd9?file=ping-pong.js"" rel=""noreferrer"">https://stackblitz.com/edit/redux-observable-playground-8c7pd9?file=ping-pong.js</a></p>

<p>Redux applies middleware in the order they are provided as arguments, so in this case we want the thunk middleware to absorb any dispatched thunks so that the thunk functions themselves never reach redux-observable (only pure actions). But your epics can still dispatch thunks since the redux-observable middleware uses <code>store.dispatch</code> under the hood.</p>
","1770633","","","","","2018-01-30 01:11:59","","","","1","","","","CC BY-SA 3.0"
"48513029","1","48513436","","2018-01-30 02:35:31","","1","511","<p>Say I have this in my HTML:</p>

<pre><code>  &lt;div&gt;
    &lt;mat-label&gt;Matched events count: {{(getMatchedEventsCount() | async)?}}&lt;/mat-label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;mat-label&gt;Total events count: {{(getTotalEventsCount() | async)?}}&lt;/mat-label&gt;
  &lt;/div&gt;
</code></pre>

<p>my question is, what do I return (as far as an Observable) from these helper methods?</p>

<pre><code>  getMatchedEventsCount(){
    return Observable.of(3);
  }

  getTotalEventsCount(){
    return Observable.of(5);
  }
</code></pre>

<p>but my question is - how can we do something actually asynchronous?</p>

<p>At the moment, I am getting this HTML parse error though:</p>

<blockquote>
  <p>Uncaught Error: Template parse errors: Parser Error: Unexpected end of
  expression: Matched events count: {{(getMatchedEventsCount() |
  async)?}} at the end of the expression [Matched events count:
  {{(getMatchedEventsCount() | async)?}}] in
  ng:///AppModule/EventsListComponent.html@40:21 (""
          
          
            [ERROR ->]Matched events count: {{(getMatchedEventsCount() | async)?}}
          
          ""): ng:///AppModule/EventsListComponent.html@40:21 Parser Error: Conditional expression (getMatchedEventsCount() | async)?
  requires all 3 expressions at the end of the expression [Matched
  events count: {{(getMatchedEventsCount() | async)?}}] in
  ng:///AppModule/EventsListComponent.html@40:21 (""
          
          
            [ERROR ->]Matched events count: {{(getMatchedEventsCount() | async)?}}
          
          ""): ng:///AppModule/EventsListComponent.html@40:21</p>
</blockquote>
","1223975","","1223975","","2018-01-30 02:40:55","2018-01-30 03:33:16","""return"" asynchronous data using Observables","<angular><observable><rxjs5>","1","6","","","","CC BY-SA 3.0"
"48513288","1","48513343","","2018-01-30 03:08:43","","1","639","<p>I have a ReplaySubject like so:</p>

<pre><code>matchCount = new ReplaySubject&lt;number&gt;();
totalCount = new ReplaySubject&lt;number&gt;();
</code></pre>

<p>I use it like so:</p>

<pre><code>  getMatchedEventsCount(){
    return this.dcs.matchCount.asObservable();
  }

  getTotalEventsCount(){
    return this.dcs.totalCount.asObservable();
  }
</code></pre>

<p>I am just getting the counts - I only need the last (most recent) value from each replay subject, I don't need all the values.</p>

<p>Is there a way to do that?</p>
","1223975","","","","","2018-01-30 03:23:24","Use ReplaySubject, but only replay most recent observable item","<angular><rxjs5>","1","3","","","","CC BY-SA 3.0"
"48513343","2","","48513288","2018-01-30 03:16:21","","7","","<p>Specify a number of events to replay in the constructor:</p>

<pre><code> new ReplaySubject&lt;number&gt;(1);
</code></pre>
","3661630","","3661630","","2018-01-30 03:23:24","2018-01-30 03:23:24","","","","0","","","","CC BY-SA 3.0"
"48513436","2","","48513029","2018-01-30 03:28:11","","1","","<p>I notice that you have already troubleshooted the <code>?</code> in the comment thread. The reason the <code>?</code> (called the <a href=""https://angular.io/guide/template-syntax#the-safe-navigation-operator----and-null-property-paths"" rel=""nofollow noreferrer"">""save navigation operator""</a>) does not work there is that it is guarding against <code>null</code> and <code>undefined</code> values in <em>property</em> paths, meaning you need to attempt to access a property after using the <code>?</code>. Right now you are trying to use it retroactively to see if an object is <code>null</code> or <code>undefined</code>, but it can only look forward into the object, not backwards, and it needs a property to look for. </p>

<p>You are correct that you should return an <code>Observable</code> from the methods and give that to the <code>async</code> pipe. Here is some documentation on the <code>async</code> pipe just to be thorough: <a href=""https://angular.io/api/common/AsyncPipe"" rel=""nofollow noreferrer"">https://angular.io/api/common/AsyncPipe</a>.</p>

<p>As to your question in the comment thread about how to use a <code>Subscription</code> to load the data instead of an <code>Observable</code>...</p>

<p>You can do that using the <code>subscribe</code> method and assigning the data to a property on your component, like so:</p>

<pre><code>matchedEventsSub: Subscription;
matchedEventsCount: number;

getMatchedEventsCount() {
  this.matchedEventsSub = Observable.of(3).subscribe(value =&gt; {
    this.matchedEventsCount = value;
  });
}
</code></pre>

<p>Note that <code>subscribe</code>ing to an <code>Observable</code> returns a <code>Subscription</code>. Then you must remember to <code>unsubscribe</code> from that subscription in your <code>OnDestroy</code> lifecycle hook to prevent memory leaks:</p>

<pre><code>ngOnDestroy() {
  if (this.matchedEventsSub) { this.matchedEventsSub.unsubscribe(); }
}
</code></pre>

<p>As you can imagine, this becomes cumbersome when you have 2, 3, 10 subscriptions in one component. That's why the Angular team created the <code>async</code> pipe. </p>

<p>Finally, </p>

<blockquote>
  <p>how can we do something actually asynchronous?</p>
</blockquote>

<p>It's actually quite simple. Let's say you have an <code>EventsService</code> that you inject into your component: </p>

<pre><code>constructor(private eventsService: EventService) {}
</code></pre>

<p>That service may encapsulate an <code>Http</code> request or something -- Angular's <code>HttpClient</code> module uses <code>Observable</code>s to represent asynchronous data. You could use your <code>EventsService</code> to get your asynchronous stream of events like this: </p>

<pre><code>matchedEventsCount$: Observable&lt;number&gt;;

getMatchedEventsCount(): Observable&lt;number&gt; {
  const allEvents$ = this.eventsService.getEvents();
  return allEvents$.map(events =&gt; events.length);
}
</code></pre>

<p>Call the method in your <code>OnInit</code> lifecycle hook to populate your data:</p>

<pre><code>ngOnInit() {
  this.getMatchedEventsCount();
}
</code></pre>

<p>And then display it in your template:</p>

<pre><code>&lt;h1&gt;Events: {{ matchedEventsCount$ | async }}&lt;/h1&gt;
</code></pre>
","5932590","","5932590","","2018-01-30 03:33:16","2018-01-30 03:33:16","","","","0","","","","CC BY-SA 3.0"
"48519080","1","","","2018-01-30 10:23:54","","7","1562","<p>I want to trigger retrywhen() with increasing time interval, </p>

<pre><code>   socketResponse.retryWhen(attempts =&gt; {
    return attempts.zip(Observable.range(1, 4)).mergeMap(([error, i]) =&gt; {
        console.log(`[socket] Wait ${i} seconds, then retry!`);
        if (i === 4) {
            console.log(`[socket] maxReconnectAttempts ${i} reached!`);
        }
        return Observable.timer(i * 1000);
    });
});
</code></pre>

<p>above code works fine.
current implementation output :</p>

<p><strong>on connection error</strong> (1st time)</p>

<hr>

<ul>
<li>[socket] Wait 1 seconds, then retry! // wait for 1 second </li>
<li>[socket] Wait 2 seconds, then retry! // wait for 2 seconds</li>
</ul>

<p><strong>on connection successful</strong></p>

<hr>

<p>// successful connection. </p>

<p><strong>on connection error</strong> (2nd time) </p>

<hr>

<ul>
<li>[socket] <strong>Wait 3 seconds</strong>, then retry! // wait for 3 second </li>
<li>[socket] <strong>Wait 4 seconds</strong>, then retry! // wait for 4 seconds </li>
</ul>

<p>Now I want to reset waiting time when socket connection is successful. </p>

<p>desired output :</p>

<p><strong>on connection error</strong> (1st time)</p>

<hr>

<ul>
<li>[socket] Wait 1 seconds, then retry! // wait for 1 second </li>
<li>[socket] Wait 2 seconds, then retry! // wait for 2 seconds </li>
</ul>

<p><strong>on connection successful</strong> </p>

<hr>

<p>// successful connection. </p>

<p><strong>on connection error</strong> (2nd time) </p>

<hr>

<ul>
<li><p>[socket] <strong>Wait 1 seconds</strong>, then retry! // wait for 1 second </p></li>
<li><p>[socket] <strong>Wait 2 seconds</strong>, then retry! // wait for 2 seconds</p></li>
</ul>

<p>but I don't know how to reset retrywhen() time interval.</p>
","4305927","","4305927","","2018-01-31 06:51:29","2018-12-14 21:50:51","RXJS retryWhen reset waiting interval","<javascript><angular><rxjs><angular5><rxjs5>","3","0","2","","","CC BY-SA 3.0"
"48523844","1","","","2018-01-30 14:31:37","","1","1163","<p>Say I have an http call to put /cart api, but for some reason our backend doesn't return an updated cart, instead, it returns 'success' string. So for getting an updated cart, I need to get /cart again to see new cart. What's the best way to do that?</p>

<p>following nested subscribes work but not good, since I don't want to do this every component:    </p>

<pre><code>http.put('/cart', data).subscribe(()=&gt;{http.get('/cart').subscribe(()=&gt;{/**update local cart*/})})
</code></pre>

<p>and I tried concat but it emits value for each http call   </p>

<pre><code>http.put('/cart', data).concat(http.get('/cart')).subscribe(/**update local*/)   
</code></pre>

<p>this has a problem: if PUT success, but GET failed, the <code>/**update local*/</code> part still get invoked. That's not expected because I can't update local cart at that time.</p>

<p>I want the subscribe next section get called only when both previous observable completed, if error happens, go to error section</p>
","5231274","","310726","","2018-01-30 14:33:26","2018-01-30 14:41:39","rxjs operator informs me only if all concat observables complete","<angular><rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 3.0"
"48532242","1","","","2018-01-30 23:42:25","","0","62","<p>I have an observable representing an infinite data source and I want users to fetch pages of <code>n</code> items interactively (e.g. clicking <code>next</code> or using infinite scroll). </p>

<p>The problem is that when I use <code>take()</code>, it also unsubscribes to my source, so when I want to take more items, it starts all over again. I'm aware of <code>skip()</code> so I could fast forward, but since my <code>source</code> makes api calls, it might get expensive to do that (it uses <code>Observable.defer</code> under the hood to fetch pages when necessary).</p>

<p>I've also read about <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/pausable.md"" rel=""nofollow noreferrer"">pausable</a>, but it seems to me quite dirty (would need to disable the pause when we need more data, then count items and enable again after N items, I think).</p>

<pre><code>let source = someFunction(); // [1,2,3,4,5,6,7,8,9,...]

// On page load
source.take(3).subscribe(item =&gt; render(item)); // [1,2,3]

// When user clicks ""next page""
source.take(3).subscribe(item =&gt; render(item)); // [1,2,3], expected [4,5,6]
</code></pre>

<p>How can I keep my subscription open, while taking a few items at the time?</p>

<p>FWIW, I'm using RxJs 5.5.2 with Angular 5.0.0</p>
","575085","","","","","2018-01-30 23:53:52","How to use take() in RxJS without unsubscribing to observable","<javascript><rxjs><reactive-programming><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48558054","2","","48475506","2018-02-01 08:11:24","","1","","<p>I hadn't realized that by using the exact solution I posted at the end of the question, it works fine even without manually casting the type on the usage of the ""cached"" operator function.</p>

<p>So, instead of doing as a originally posted:</p>

<pre><code>const myFilter = filter(x =&gt; !!x);
const getOp = &lt;T&gt;(): MonoTypeOperatorFunction&lt;T&gt; =&gt; {
  return myFilter;
};

someObservable$
  .pipe(getOp&lt;TheType&gt;())
  .subscribe((y) =&gt; ...)
</code></pre>

<p>It is sufficient to do</p>

<pre><code>someObservable$
  .pipe(getOp()) // no need to specify &lt;TheType&gt; here
  .subscribe((y) =&gt; ...)
</code></pre>

<p>And the type flows well :)</p>
","2282801","","","","","2018-02-01 08:11:24","","","","0","","","","CC BY-SA 3.0"
"48559541","1","","","2018-02-01 09:40:21","","1","247","<p>I've recently upgraded my angular app to use HttpClient instead of Http. After some fixes around handling of headers and params most of my code work, but one specific request alludes me with it's weird behavior.</p>

<p>The request is a bit special as it's a polling request that bails when it gets a payload from the server (it will return a 204 response until it have something to deliver).</p>

<p>I'm using an interval Observable to poll the endpoint once a second for a specific span of time, and when I get a payload I use the .first() operator to handle the data. This worked fine when I used the old Http service. Here's how it looks:</p>

<pre><code>return Observable.interval(this.pollInterval)
  .mergeMap(() =&gt; this.http.get(this.apiUrl + '/poll'))
  .first(data =&gt; data) // This is where the error occurs in HttpClient
  .map(result =&gt; result)
  .timeout(20000)
  .catch(this.errorHandler);
</code></pre>

<p>The observable works as should when I use the deprecated Http service, but when I use the HttpClient service I get the following error:</p>

<pre><code>error TS2345: Argument of type '(data: Object) =&gt; Object' is not assignable to parameter of type '(value: Object, index: number, source: Observable&lt;Object&gt;) =&gt; boolean'. Type 'Object' is not assignable to type 'boolean'.
</code></pre>

<p>Now here's where it gets a bit weird, I decided to try to debug the observable stream by adding a .do(console.log) before the .first() operator like thus:</p>

<pre><code>return Observable.interval(this.pollInterval)
  .mergeMap(() =&gt; this.http.get(this.apiUrl + '/poll'))
  .do(console.log)
  .first(data =&gt; data)
  .map(result =&gt; result)
  .timeout(20000)
  .catch(this.errorHandler);
</code></pre>

<p>Doing this seemed to solve the problem, no more type assignment errors, and the wanted functionality works as before. I've resorted to use a dummy function that I call in the .do() operator, but I'm not happy with having to do this to resolve the issue, so I want to figure out why this behavior is appearing and what the .do() operator does to make the problem go away.</p>

<p>Looking forward to hear your input on this issue.</p>

<p><strong>Solution</strong>
I followed the advice of the first answer and used !! to cast the data type to boolean in the .first() return, this removed the type error and removed the need to use the .do() operation as described in the issue.</p>
","1959343","","1959343","","2018-02-01 12:23:20","2018-02-01 12:23:20","Angular - RxJS operator .first() throws type error after upgrade from Http to HttpClient","<angular><rxjs><rxjs5><angular-httpclient>","1","1","","","","CC BY-SA 3.0"
"48568861","1","48571046","","2018-02-01 17:49:09","","1","565","<p>I want to execute a function when a takeUntil operator is triggered (outside ajaxObservable). <a href=""https://i.stack.imgur.com/LV8NW.jpg"" rel=""nofollow noreferrer"">In this way</a> is fired immediately, because I call observer.complete(), but if I don't call it there will be memory leaks  right?<br>
What's a good way to achieve this?</p>

<pre><code>export const ajaxObservable = (url, method, data, params) =&gt; {
    let cancelToken = axios.CancelToke.source()
    return Observable
        .fromPromise(axios({/* axios params */}))
        .map(r =&gt; r.data)
        .catch(err =&gt; Observable.throw(err))
        .merge(
            new Observable(observer =&gt; {
                observer.complete()
                return () =&gt; cancelToke.cancel()
            })
        )
 }
</code></pre>
","9285685","","1770633","","2018-02-02 01:53:12","2018-02-02 01:53:12","execute function when takeUntil operation is triggered","<javascript><reactjs><rxjs><rxjs5><redux-observable>","1","4","","","","CC BY-SA 3.0"
"48571046","2","","48568861","2018-02-01 20:17:41","","2","","<p>One issue with your approach is that calling <code>ajaxObservable()</code> doesn't return a <strong>lazy</strong> Observable. Instead, the ajax require is immediately made by axios, even if no one subscribes to the returned Observable.</p>

<p>While there are exceptions, typically it's best practice to have custom Observables like this be lazy, so the same expectations hold for users.</p>

<p>To do that, you'll want to return a new anonymous Observable, very similar to how you might do this with Promises. Inside our custom Observable subscribe handler, there isn't much need to using <code>fromPromise</code> or any rxjs since we just need to call axios and <code>then</code>.</p>

<p>As a bonus, when we do it this way the solution to your original question becomes more apparent: if someone unsubscribes, we can call the <code>cancelToken.cancel()</code>.</p>

<pre><code>export const ajaxObservable = (url, method, data, params) =&gt; {
    return new Observable(observer =&gt; {
        let cancelTokenSource = axios.CancelToken.source();
        let options = {
          url,
          method,
          data,
          params,
          withCredentials: true,
          cancelToken: cancelTokenSource.token
        };

        axios(options)
            .then(response =&gt; {
                observer.next(response.data);
                observer.complete(); // commonly forgotten, but critical!
            }, error =&gt; {
                observer.error(error);
            });

        return () =&gt; cancelTokenSource.cancel();
    });
};
</code></pre>

<hr>

<p>btw <code>.catch(err =&gt; Observable.throw(err))</code> is effectively a noop, rethrowing the same error again.</p>

<hr>

<p>You might be interested to know that rxjs comes with an AjaxObservable, which makes something like axios unnecessary. The documentation for it unfortunately doesn't show up correctly in the rxjs v5 docs, but it can be found inline: <a href=""http://reactivex.io/rxjs/file/es6/observable/dom/AjaxObservable.js.html"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/file/es6/observable/dom/AjaxObservable.js.html</a> It has a pretty standard API that's similar to most ajax utilities.</p>

<pre><code>/**
 * Creates an observable for an Ajax request with either a request object with
 * url, headers, etc or a string for a URL.
 *
 * @example
 * source = Rx.Observable.ajax('/products');
 * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
 *
 * @param {string|Object} request Can be one of the following:
 *   A string of the URL to make the Ajax call.
 *   An object with the following properties
 *   - url: URL of the request
 *   - body: The body of the request
 *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
 *   - async: Whether the request is async
 *   - headers: Optional headers
 *   - crossDomain: true if a cross domain request, else false
 *   - createXHR: a function to override if you need to use an alternate
 *   XMLHttpRequest implementation.
 *   - resultSelector: a function to use to alter the output value type of
 *   the Observable. Gets {@link AjaxResponse} as an argument.
 */
</code></pre>

<p>It also has shorthands like <code>ajax.getJSON</code> etc.</p>
","1770633","","1770633","","2018-02-01 20:24:50","2018-02-01 20:24:50","","","","1","","","","CC BY-SA 3.0"
"48576629","1","48595961","","2018-02-02 06:06:48","","1","226","<p>I have a problem with the below method (<code>onTrySignin</code>) when I encounter an <code>HTTP</code> error response. The <code>catch</code> block right after my <code>HTTP</code> call prevents the <code>Side Effect</code> from throwing an <code>Action</code> error. if I do <code>console.log</code> I get this error.</p>

<blockquote>
  <p>TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p>how can I preserve the <code>Observable</code> stream and pass the response to the next block (<code>mergeMap</code>) where I can fire other <code>Actions</code>, (<code>FailedSignin()</code>) in this case?</p>

<pre><code>onTrySignin = this.actions$
    .ofType(AuthActions.TRY_SIGNIN)
    .map((action: AuthActions.TrySignin) =&gt; {
       return action.payload;
      })
    .switchMap((action: DispatchAction) =&gt; {
      const trySignInPayload: TrySignInPayload = action.payload;
      return this.httpService.postRequest('Account/Login', (trySignInPayload.loginData))
        .catch((error: any) =&gt; {
          console.log(error)
          return Observable.empty();
        })
        .mergeMap((response: HttpResponse&lt;any&gt;) =&gt; {
          switch (response.status) {
            case 200:
              if (trySignInPayload.returnUrl) {
                this.router.navigate([trySignInPayload.returnUrl]);
              } else {
                this.router.navigate(['/dbapp']);
              }
              return Observable.concat(
                Observable.of(new AuthActions.GenerateAntiforgeryToken()),
                Observable.of(new AuthActions.Signin(fromAuth.authId, this.fetchUserData()))
              );
              case 401:
              case 404:
              return Observable.concat(
                Observable.of(new AuthActions.FailedSignin()),
                Observable.empty()
              );
            default:
            return Observable.concat(
              Observable.of(new AuthActions.FailedSignin()),
              Observable.empty()
            );
          }
        })
    }).catch((error) =&gt; {
      return Observable.throw(error);
    });
</code></pre>

<p>This is my <code>httpService</code> </p>

<pre><code>public postRequest(apiUrl: string, jsonData: {} = {}): Observable&lt;any&gt; {
        return this.httpService.post(this.baseUrl + apiUrl, JSON.stringify(jsonData),
        {observe: 'response', reportProgress: true, withCredentials: true});
    }
</code></pre>
","2157801","","2157801","","2018-02-02 06:16:02","2018-02-03 09:43:17","How to guarantee the continuity of observable stream in case of http errors?","<angular><observable><rxjs5><ngrx><ngrx-effects>","1","0","","","","CC BY-SA 3.0"
"48582567","1","48595570","","2018-02-02 12:20:16","","1","51","<p>Let's say there are 2 observables, observable A and observable B.
When A emits a value, I want to wait 1 second, and then emit the latest value of B. If A emits another value while waiting 1 second, I want it to forget about the previous value and wait another 1 second (like switchMap does).
How could I achieve such behaviour?</p>
","8331303","","310726","","2018-02-03 08:45:36","2018-02-03 08:45:36","Emit the latest value of B, 1 second later after A has emmited a value","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48583031","1","","","2018-02-02 12:45:52","","0","868","<p>I'm designing an API (in NodeJS) which receives a list of user ids, for instance, and access Google Firebase's API to send a notification to those users.</p>

<p>Considering Firebase having a quota limit on how many requests you can concurrently send to, I buffered the Ids and send the requests one by one to Firebase with a delay of two seconds. Here's some simplified sample code for explanation: </p>

<pre><code>app.post('/send-request', (req, res, next) =&gt;{
  const userIds = req.body.userIds;
  âconst streams = userIds.map((userId) =&gt; {
â    return Observable
â      .fromPromise(fetch(`firebase url`, {
â          method: 'POST', 
â          headers: ..., 
          body: ... 
â        }))
â        .delay(2000) 
â        .retryWhen(attempts =&gt; { 
â          return attempts.zip(Rx.Observable.range(1, 4))
            .mergeMap(([error, i]) =&gt; { 
              if (i &gt; 3) { 
                return Rx.Observable.throw(error); 
            } 
              console.log(`Wait ${i} seconds, then retry!`); 
              return Rx.Observable.timer(i * 1000); 
            });
      â  });
  });


  const stream = Observable.merge(...streams);
â  stream.subscribe();
});
</code></pre>

<p>This can handle the case when a single request consists of a lot of users. However, if my API receives similar requests concurrently, it's bound to fail. </p>

<p>Therefore, I want to buffer all these user ids in a queue where this queue can keep receiving more and more user ids an buffer them, and at the same time 'top' the queue by sending requests to Firebase at a steady rate. However, I don't know how to do it with RxJS. Do I have to use an Scheduler? Or is there actually a better solution than using Rx? </p>

<p>Note: I understand Javascript is single-threaded so it's not exactly concurrency, I only used this word so you can get the idea better. </p>
","5836921","","","","","2018-02-02 17:56:13","How to implement a queue using RxJS?","<node.js><rxjs><rxjs5>","1","2","","","","CC BY-SA 3.0"
"48583940","1","48584157","","2018-02-02 13:41:06","","2","5626","<p>I would like to wait for all my http request to be completed before doing something.</p>

<p>Before Angular 5, I was using promises and <code>Promise.All</code>.</p>

<p>With Angular 5 and the new <code>HttpClient</code>, I transformed my promises into observables. If I understand correctly, I now have to use <code>forkJoin</code> to replace the <code>Promise.All</code>.</p>

<p>But this is a problem because <code>forkJoin</code> expect Observables as parameters, but I already subscribe to those in the code</p>

<pre><code>ngOnInit() {
    forkJoin([this.getTemplates(), this.getHistory()]).subscribe(
        results =&gt; {
            this.isLoading = false;
        }
    );
}

getTemplates(): Observable&lt;any&gt; {

    return this.notifService.getTemplateList()
        .subscribe(
            response =&gt; {
                if (response.code === 0) {
                    this.templateList = response.data;
                }
                else {
                    this.openSnackBar(response.formatError());
                }
            },
            error =&gt; {
                this.openSnackBar(error);
            });
}
</code></pre>

<p>I can't do the logic inside the subscription of the <code>forkJoin</code> because those method (<code>getTemplates()</code> &amp; <code>getHistory()</code>) need to be standalone and called seperatly in other processes.</p>

<p>So, what can I do to be sure that all the subscriptions are done ?</p>

<p>By the way, the code above doesn't compile because the method <code>getTemplates()</code> return a <code>Subscription</code> and not an <code>Observable</code></p>
","2156154","","","","","2018-02-02 13:55:32","Angular 5 & Rxjs: Wait for all subscription","<javascript><angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48584157","2","","48583940","2018-02-02 13:53:18","","2","","<p>Use <code>map</code> Instead of <code>subscribe</code> in <code>getTemplates</code>:</p>

<pre><code>getTemplates(): Observable&lt;any&gt; {
    return this.notifService.getTemplateList()
        .map(response =&gt; {
            /* ... */
            return reponse;
        });
}
</code></pre>
","7446273","","7446273","","2018-02-02 13:55:32","2018-02-02 13:55:32","","","","4","","","","CC BY-SA 3.0"
"48595570","2","","48582567","2018-02-03 08:45:04","","1","","<p>It looks like you could do this easily with the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-withLatestFrom"" rel=""nofollow noreferrer""><code>withLatestFrom</code></a> operator like the following:</p>

<pre><code>const a$ = ...;
const b$ = ...;

a$
  .switchMap(v =&gt; Observable.of(v).delay(1000))
  .withLatestFrom($b.startWith(null), (a, b) =&gt; b)
  .subscribe(...);
</code></pre>
","310726","","","","","2018-02-03 08:45:04","","","","0","","","","CC BY-SA 3.0"
"48595961","2","","48576629","2018-02-03 09:43:17","","1","","<p>You need to create a disposable stream, this is how we do it:</p>



<pre class=""lang-ts prettyprint-override""><code>@Effect()
  login$: Observable&lt;Action&gt; = this.actions$
   .ofType(authActions.LOGIN)
   .switchMap((action: any) =&gt; {
     // @Effect stream is completing when the error occurs, preventing any further 
     // actions. Therefore create a disposable stream to keep @Effect stream alive
     return Observable.of(action)
       .switchMap((action: any) =&gt; {
         return this.apiService.login(action.payload);
       })
       .map((x: any) =&gt; {
         return new authActions.SetTokensAction({ token: x.data.token });
       })
       .catch((error: any) =&gt; {
         return Observable.of(new authActions.LoginFailedAction(error));
       });
    });
</code></pre>
","6294072","","","","","2018-02-03 09:43:17","","","","0","","","","CC BY-SA 3.0"
"48596405","1","48596674","","2018-02-03 10:37:27","","4","3945","<p>I'm having an observable that passes me a json object on which I'm using the distinct operator. 
I don't want to have duplicates if the entire object is same as before. I can't just use a one comparator like id, as it's id might be same but it's content not.</p>

<p>So I'm currenty stringifying the object and then using distinct and it works fine</p>

<p>Is there a better way to do this?</p>

<pre><code>someObservable
  .startWith(cachedCopy)
  .map(item =&gt; JSON.stringify(item))
  .distinct()
  .subscribe(item =&gt; {
      //I do some stuff!
     })
</code></pre>
","6883002","","","","","2021-01-27 13:29:02","Using Rxjs distinct operator to compare whole object with nesting","<json><angular><object><rxjs><rxjs5>","3","0","1","","","CC BY-SA 3.0"
"48596674","2","","48596405","2018-02-03 11:07:45","","4","","<p>Actually I think using <code>JSON.stringify()</code> to compare whether two objects contain the same data is the easiest way to go. If you know the object identity must be different you could use <code>pairwise().filter(pair =&gt; pair[0] !== pair[1])</code> (these must be two different object instances) but this really depends on your use-case and if you can guarantee such condition (usually not in my personal experience and comparing JSONs is ""good enough"").</p>

<p>Be aware that <code>distinct()</code> passes only really distinct items since the chain was created but in your description you say <em>""duplicates if the entire object is same as before""</em> which seems like you should be using <code>distinctUntilChanged</code> instead.</p>

<p>The <code>distinctUntilChanged</code> operator takes as an optional parameter a comparator function that you can use to check if two objects are the same:</p>

<pre><code>.distinctUntilChanged((prev, curr) =&gt; JSON.stringify(prev) === JSON.stringify(curr))
</code></pre>
","310726","","310726","","2018-02-03 11:37:22","2018-02-03 11:37:22","","","","6","","","","CC BY-SA 3.0"
"48601357","1","48601425","","2018-02-03 19:50:42","","3","894","<p>RxJS 5.5.6. I'm trying to convert an <code>Observable&lt;string[]&gt;</code> into <code>Observable&lt;string&gt;</code></p>

<p>I'm  not sure if <code>mergeAll</code> operator is what I'm looking for</p>

<pre><code>const o1: Observable&lt;string[]&gt; = of(['a', 'b', 'c']);
const o2: Observable&lt;string&gt; = o1.pipe(
  mergeAll()
);
</code></pre>

<p>Typescript will return this error: </p>

<pre><code>Type 'Observable&lt;string | string[]&gt;' is not assignable to type 'Observable&lt;string&gt;'.
  Type 'string | string[]' is not assignable to type 'string'.
    Type 'string[]' is not assignable to type 'string'.
</code></pre>

<p>I receive Observable as parameter and I can change the way is constructed.</p>
","714211","","","","","2018-02-03 19:57:43","RxJS convert Observable<string[]> into Observable<string>","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48601425","2","","48601357","2018-02-03 19:57:43","","4","","<p>It looks like you've encountered an already reported RxJS issue, see <a href=""https://github.com/ReactiveX/rxjs/issues/2759"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2759</a> and even more recent <a href=""https://github.com/ReactiveX/rxjs/issues/3290"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/3290</a>.</p>

<p>From the comments it looks like it won't be fixed until RxJS 6.</p>

<p>However you can always use <code>mergeMap(o =&gt; o)</code>/<code>concatMap(o =&gt; o)</code> instead of <code>mergeAll()</code>/<code>concatAll()</code>.</p>

<p>For example:</p>

<pre><code>const o1: Observable&lt;string[]&gt; = of(['a', 'b', 'c']);
const o2: Observable&lt;string&gt; = o1.pipe(
  mergeMap(o =&gt; o)
);
</code></pre>
","310726","","","","","2018-02-03 19:57:43","","","","0","","","","CC BY-SA 3.0"
"48620574","1","48621000","","2018-02-05 10:34:22","","2","322","<p>I have two hot/warm observables one provides list of user roles definitions and the second list of users (under the hood these ReplaySubject(1) which works like BehaviorSubject without starting value). </p>

<p>To display users I need to ensure I have list of roles definitions. Also if list of roles changes or list of users changes I have to re-render list. </p>

<p>I'd like to user the power of rxjs and combine this two observables to get semantics I described. I experimented with number of operators like switchMap, mergeMap, faltMap, forkJoin and zip however I couldn't make it work. </p>

<p>The only way I could make it work is to use two subscription like this: </p>

<pre><code> this.userRoleStore.observable.subscribe((roles) =&gt; {
      this.roles = roles;
      if (this.users == null) {
        this.userStore.observable.subscribe(users =&gt; {
          this.users = users;
        })
      }
 });
</code></pre>

<p>This way I ensure I have roles before I try render users and it will update both users and roles whenever they change. </p>

<p>Most promising was zip operator however it won't fire when only one of observable changes. SwitchMap operator will fire only when first observables has new value (so I get updates only on user or user roles changes). </p>
","801254","","","","","2018-02-05 11:18:48","Combine two Oservables, ensure one, react to changes in second","<angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"48621000","2","","48620574","2018-02-05 10:56:22","","5","","<p>It looks like you're looking for <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest"" rel=""noreferrer""><code>combineLatest</code></a> that emits when any of the source Observables emit after each of them emitted at least one value (it has both static and operator variants).</p>

<p>So in your case it would look like this:</p>

<pre><code>Observable.combineLatest(
    this.userRoleStore.observable,
    this.userStore.observable
  )
  .subscribe(([role, user]) =&gt; ...);
</code></pre>

<p>Maybe also have a look at <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-withLatestFrom"" rel=""noreferrer""><code>withLatestFrom</code></a>.</p>
","310726","","","","","2018-02-05 10:56:22","","","","0","","","","CC BY-SA 3.0"
"48635666","1","48637539","","2018-02-06 04:47:38","","0","701","<p>Say I have this:</p>

<pre><code>  isMatchedCountLessThanTotalCountMessage(){
       // I want to implement this
       // ""returns"" a string asynchronously
  }

  getMatchedEventsCount() {
    return this.dcs.matchCount.asObservable();
  }

  getTotalEventsCount() {
    return this.dcs.totalCount.asObservable();
  }
</code></pre>

<p>matchedCount and totalCount are like so:</p>

<pre><code>  public matchCount = new BehaviorSubject&lt;number&gt;(0);
  public totalCount = new BehaviorSubject&lt;number&gt;(0);
</code></pre>

<p>these Observables fire integers as values change. Anytime a value is fired from either one, I want to compare the two most recent values from both, how do I do that?</p>

<p>What I want to do is return a boolean from the method</p>

<p>so I can display in the HTML:</p>

<pre><code> &lt;div&gt;{{(isMatchedCountLessThanTotalCountMessage() | async)}}&lt;/div&gt;
</code></pre>

<p>I think Observable.zip might do the trick:</p>

<pre><code>isMatchedCountLessThanTotalCountMessage(){
    return Observable.zip(
      this.getMatchedEventsCount(),
      this.getTotalEventsCount()
    )
    .subscribe(function(v){
      const intA = v[0];
      const intB = v[1];

        if(intA &gt; intB)
         // but I don't know how to send a message the HTML from here
    });
  }
</code></pre>
","1223975","","2829204","","2018-06-06 11:34:13","2018-06-06 11:34:13","Compare most recent values from multiple BehaviorSubjects","<rxjs><rxjs5><angular2-observables><behaviorsubject>","2","0","","","","CC BY-SA 3.0"
"48636114","1","48636382","","2018-02-06 05:35:24","","1","1516","<p>Say I have this:</p>

<pre><code>const a = new BehaviorSubject(0);
const b = new BehaviorSubject(0);

Observable.zip(
    a.asObservable(),
    b.asObservable()
)
.subscribe(v =&gt; {
    // this will fire with [0,0]
    // but I want it to also fire with [1,0]
});

a.next(1);
</code></pre>

<p>how can I achieve what's in the comment in the subscribe next function?
I believe I need to find a different operator than <code>Observable.zip()</code>, something like <code>Observable.first()</code>.</p>
","1223975","","1223975","","2018-02-06 05:41:24","2018-02-06 06:10:29","Observable.zip but get first value, don't wait for all values","<observable><rxjs5><angular2-observables>","1","3","1","","","CC BY-SA 3.0"
"48636382","2","","48636114","2018-02-06 05:58:49","","2","","<p><code>.zip()</code> will only work if the emissions from the <code>observables</code> are zippable. For your case, because <code>0,0</code> is already zipped, hence there will only be one such emission. If you want to have next emission, your <code>b</code> subject will have to emit a value too:</p>

<pre><code>const a = new BehaviorSubject(0);
const b = new BehaviorSubject(0);

Observable.zip(
    a.asObservable(),
    b.asObservable()
)
    .subscribe(v =&gt; {
        // this will fire with [0,0]
        // will fire only if both a and b has emisions. 
        // this also logs [1,1] because there is a b.next(1)
    });

a.next(1);
b.next(1); // this step is crucial
</code></pre>

<p>If you want to detect any changes of any number of <code>Observables</code> combined, you will have to use <a href=""http://reactivex.io/documentation/operators/combinelatest.html"" rel=""nofollow noreferrer""><code>Observable.combineLatest()</code></a>.</p>

<blockquote>
  <p>The CombineLatest operator behaves in a similar way to Zip, but while Zip emits items only when each of the zipped source Observables have emitted a previously unzipped item, CombineLatest emits an item whenever any of the source Observables emits an item (so long as each of the source Observables has emitted at least one item). When any of the source Observables emits an item, CombineLatest combines the most recently emitted items from each of the other source Observables, using a function you provide, and emits the return value from that function.</p>
</blockquote>
","2829204","","2829204","","2018-02-06 06:10:29","2018-02-06 06:10:29","","","","3","","","","CC BY-SA 3.0"
"48637539","2","","48635666","2018-02-06 07:22:37","","3","","<p>You can easily use <code>.map()</code> function to transform the data you want:</p>



<pre><code>isMatchedCountLessThanTotalCountMessage() {
    return Observable.combineLatest(
        this.getMatchedEventsCount(),
        this.getTotalEventsCount(),
    )
        .map(([intA, intB]) =&gt; {
            return intA &gt; intB ? '(results ARE filtered)' : '(results are not filtered)'
        })
}
</code></pre>
","2829204","","","","","2018-02-06 07:22:37","","","","1","","","","CC BY-SA 3.0"
"48643760","1","","","2018-02-06 13:05:14","","0","287","<p>I am developing an Angular 5 Web App that uploads some files to the server and i need to stop and buffer the upload once the internet connection is down.</p>

<p>Following this <a href=""https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine#Example"" rel=""nofollow noreferrer"">link</a>, you can find the Mozilla Firefox support for the navigator.online property that reflects the status of the internet connection.</p>

<p>Still, when i run the live <a href=""http://html5-demos.appspot.com/static/navigator.onLine.html"" rel=""nofollow noreferrer"">example</a> and i disable my network card, as recommended by the app <em>""Toggle your wifi on/off while viewing this page""</em>,  nothing happens. I changed to Chrome and it works perfectly. I am using Firefox 58 and Chrome 63.</p>

<p>I have seen some posts discussing the offline mode of Firefox that has to be manually set by the user following <strong>settings > more > offline mode</strong>. Per spec Firefox considers a Network Status as different from an Internet Connection Status. Still, it is confusing and unexpected behavior.</p>

<p><strong>My questions is: how can I implement a cross-browser light-weight mechanism that checks for internet connection ?</strong></p>
","6174341","","","","","2018-02-06 13:05:14","Online/Offline eventsâ work on Chrome but not in Firefox","<html><angular><google-chrome><firefox><rxjs5>","0","3","","","","CC BY-SA 3.0"
"48646302","1","","","2018-02-06 15:18:22","","1","785","<p>I have an Angular's HttpInterceptor looking like that:</p>

<pre><code>(...)

export class CacheInterceptor implements HttpInterceptor {

  constructor(private cache: CacheService) {}

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

   const cachedResponse = this.cache.restore(req); // Object with cached data

   return cachedResponse ?
     of(cachedResponse): this.sendRequest(req, next);

(...)
}
</code></pre>

<p>Generally speaking it seems to work in the end but Angular's compiler is complaining showing error about types not matching:</p>

<blockquote>
  <p>ERROR in cache.interceptor.ts(27,5): error TS2322: >Type 'Observable> | Observable' is not assignable to >type 'Observable>'.
   Type 'Observable' is not assignable to type >'Observable>'.
     Type 'string' is not assignable to type 'HttpEvent'.</p>
</blockquote>

<p>Almost the same example can be found in the Angular Docs.</p>

<p>The problem here is that <code>of(cachedResponse)</code> is not a type <code>Observable&lt;HttpEvent&lt;any&gt;&gt;</code> but <code>Observable&lt;string&gt;</code>.</p>

<p>I tried many ways but I can't think of what would be the best solution for this. Is it possible in any way to convert cached data to <code>Observable&lt;HttpEvent&lt;any&gt;&gt;</code> type or possibly there is another good way of fixing it? I know I could provide my own HttpInterceptor interface with proper types for my case or even simply remove HttpInterface reference but these might not be the best solutions, especially tha latter one. Anybody?</p>
","485919","","","","","2018-02-06 18:18:33","RXJS Observable.of() as a Observable<HttpEvent<any>> in HttpInterceptor","<angular><rxjs><angular5><rxjs5><angular-http-interceptors>","1","0","","","","CC BY-SA 3.0"
"48650590","2","","48493924","2018-02-06 19:32:23","","3","","<p>In case of RxJS 5.x back pressure is not support, but there is for example <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/pausable.md"" rel=""nofollow noreferrer""><code>pausable</code> operator</a> in 4.x version. It works only with hot observables. More info on back pressure in case of <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/backpressure.md"" rel=""nofollow noreferrer"">4.x</a> and <a href=""http://reactivex.io/documentation/operators/backpressure.html"" rel=""nofollow noreferrer"">here</a> (especially take a loot at the bottom and RxJS related description).</p>

<p>This Erik Meijer's tweet may be bit controversial but relevant: <a href=""https://twitter.com/headinthebox/status/774635475071934464"" rel=""nofollow noreferrer"">https://twitter.com/headinthebox/status/774635475071934464</a></p>

<p>For your own implementation of back pressure mechanism you need to have 2-way communication channel, which can be fairly easily created with 2 subjects - one for each end. Basically use <code>next</code> for sending messages and <code>.subscribe</code> for listing to the other end.</p>

<p>Creating a generator is doable as well - again using a subject to bridge between push- and pull-based worlds. Below an exemplary implementation for generating Fibonacci numbers.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const fib = () =&gt; {
  const n = new Rx.Subject()
  const f = n
    .scan(c =&gt; ({ a: c.b, b: c.b + c.a }), { a: 0, b: 1 })
    .map(c =&gt; c.a)
    
  return {
    $: f,
    next: () =&gt; n.next()
  }
}

const f = fib()

f.$.subscribe(n =&gt; document.querySelector('#r').innerHTML = n)
Rx.Observable.fromEvent(document.querySelector('#f'), 'click')
  .do(f.next)
  .subscribe()</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.js""&gt;&lt;/script&gt;

&lt;button id='f'&gt;NEXT FIBONACCI&lt;/button&gt;

&lt;div id='r'&gt;_?_&lt;div&gt;</code></pre>
</div>
</div>
</p>

<p>Another js library which may be of interest for you is <a href=""https://github.com/ubolonton/js-csp"" rel=""nofollow noreferrer"">https://github.com/ubolonton/js-csp</a> - did not use it, so not sure how it deals with back pressure.</p>
","2956115","","","","","2018-02-06 19:32:23","","","","0","","","","CC BY-SA 3.0"
"48668701","1","48668943","","2018-02-07 16:28:00","","139","102281","<p>I think I have the base concept, but there are some obscurities</p>
<p>So in general this is how I use an <code>Observable</code>:</p>
<pre class=""lang-js prettyprint-override""><code>observable.subscribe(x =&gt; {

})
</code></pre>
<p>If I want to filter data I can use this:</p>
<pre class=""lang-js prettyprint-override""><code>import { first, last, map, reduce, find, skipWhile } from 'rxjs/operators';
observable.pipe(
    map(x =&gt; {return x}),
    first()
    ).subscribe(x =&gt; {

})
</code></pre>
<p>I can also do this:</p>
<pre class=""lang-js prettyprint-override""><code>import 'rxjs/add/operator/map';
import 'rxjs/add/operator/first';

observable.map(x =&gt; {return x}).first().subscribe(x =&gt; {

})
</code></pre>
<p>So my questions are:</p>
<ol>
<li>What is the difference?</li>
<li>If there is no difference, why the function <code>pipe</code> exists?</li>
<li>Why those functions need different imports?</li>
</ol>
","7404235","","74089","","2021-01-08 19:22:21","2021-09-14 04:37:08","What is pipe for in RxJS?","<angular><rxjs><rxjs5>","5","1","19","","","CC BY-SA 4.0"
"48668943","2","","48668701","2018-02-07 16:39:37","","88","","<p>The &quot;pipeable&quot; (former &quot;lettable&quot;) operators is <strong>the current and recommended way</strong> of using operators since RxJS 5.5.</p>
<p>I strongly recommend you to read the <a href=""https://v6.rxjs.dev/guide/v6/pipeable-operators"" rel=""noreferrer"">official documentation on pipeable operators</a></p>
<p>The main difference is that it's easier to make custom operators and that it's better treeshakable while not altering some global <code>Observable</code> object that could possible make collisions if two different parties wanted to create an operator of the same name.</p>
<p>Using separate <code>import</code> statement for each operator <code>'rxjs/add/operator/first'</code> was a way to make smaller app bundles. By importing only operators you need instead of the entire RxJS library you can significantly reduce the total bundle size. However the compiler can't know if you imported <code>'rxjs/add/operator/first'</code> because you really need it in you code or you just forgot to remove it when refactoring your code. That's one of the advantages of using pipeable operators where unused imports are ignored automatically.</p>
","310726","","-1","","2021-07-11 04:22:00","2021-07-11 04:22:00","","","","10","","","","CC BY-SA 4.0"
"48670819","1","48671946","","2018-02-07 18:23:53","","1","509","<p>I've 4 different types of events, I used <code>Observable.fromEvent(object, 'type1')</code> to convert to observable. They events are triggered has following combinations.</p>

<blockquote>
  <ol>
  <li>only type1.</li>
  <li>type1, type2</li>
  <li>type1, type3</li>
  <li>type1, type4,</li>
  <li>type2, type1, type3</li>
  <li>type3, type4, type1</li>
  </ol>
</blockquote>

<p>Since there is no straight forward pattern. I used merge and bufferTime. to sample out events as shown below.</p>

<pre><code>const e1 = Observable.fromEvent(ob1, 'type1');
const e2 = Observable.fromEvent(ob1, 'type2');
const e3 = Observable.fromEvent(ob1, 'type3');
const e4 = Observable.fromEvent(ob1, 'type4');

const merged = merge(e1, e2, e3, e4);
const sampled = merged.bufferTime(500);
sampled.subscribe(e=&gt;console.log(e));
</code></pre>

<p>Though the above code works, However data are emitted every <code>.5s</code>, if there are no events, empty data is emitted. I tried to use <code>buffer</code>, but in RXJS 5+, the buffer has only <code>closingselector</code> function. </p>

<p>How can I use observables such that timer starts on empty buffer and ends x+.5s, rather that sampling out every .5s. </p>
","1279145","","","","","2018-02-07 19:37:56","How to efficiently group events by time in RXJS 5+","<typescript><rxjs><rxjs5>","1","1","1","","","CC BY-SA 3.0"
"48671946","2","","48670819","2018-02-07 19:37:56","","3","","<p>It seems like you might want to <code>buffer</code> using <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-debounceTime"" rel=""nofollow noreferrer""><code>debounceTime</code></a>. The <code>debounceTime</code> operator does the following:</p>

<blockquote>
  <p>Emits a value from the source Observable only after a particular time span has passed without another source emission.</p>
</blockquote>

<p>In other words, it will only emit <code>x</code> seconds <em>after</em> the most recent emission. So, you won't end up with any empty data emissions. </p>

<p>You can use this with <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-buffer"" rel=""nofollow noreferrer""><code>buffer</code></a> to collect ""chunks"" of emissions from your master stream, like so:</p>

<pre><code>const second = 1000;
const debounced = merged.debounceTime(.5 * second);
const sampled = merged.buffer(debounced);
</code></pre>

<p>I actually wrote a blog post about collecting clicks on a button, which uses this exact approach (and goes into more detail): <a href=""http://www.vincecampanale.com/blog/2017/05/24/learn-rxjs-with-a-button/"" rel=""nofollow noreferrer"">http://www.vincecampanale.com/blog/2017/05/24/learn-rxjs-with-a-button/</a>. </p>
","5932590","","","","","2018-02-07 19:37:56","","","","1","","","","CC BY-SA 3.0"
"48675371","1","48675933","","2018-02-08 00:06:43","","1","307","<p>I have this:</p>

<pre class=""lang-js prettyprint-override""><code>this.keydownSub = Observable.fromEvent(document, 'keyup').subscribe(v =&gt; {

  if(v){
    if(v.keyCode == '37'){
      this.goLeft();
    }
    if(v.keyCode == '39'){
      this.goRight();
    }
  }
});
</code></pre>

<p>the problem is that there is no type information for the variable <code>v</code>, and that's because the event type is dynamic ('keyup' is used).</p>

<p>Is there some way to use something like this:</p>

<pre class=""lang-js prettyprint-override""><code>this.keydownSub = Observable.fromEvent(document).keyUp().subscribe(v =&gt; {

  if(v){
    if(v.keyCode == '37'){
      this.goLeft();
    }
    if(v.keyCode == '39'){
      this.goRight();
    }
  }
});
</code></pre>

<p>so that static typing information is possible/available?</p>
","","user7898461","","user7898461","2018-02-10 02:20:42","2018-02-10 02:20:42","Get typed information from subscribe callback for Observable.fromEvent()","<rxjs><rxjs5><angular2-observables><angular-observable>","1","1","","","","CC BY-SA 3.0"
"48675933","2","","48675371","2018-02-08 01:10:31","","0","","

<p>The <code>fromEvent</code> observable creator is a generic function. If you know the type that corresponds to the event, you can specify that type as a type parameter. Like this:</p>

<pre class=""lang-ts prettyprint-override""><code>const event$ = Rx.Observable.fromEvent&lt;KeyboardEvent&gt;(document, ""keyup"");
</code></pre>
","6680611","","","","","2018-02-08 01:10:31","","","","2","","","","CC BY-SA 3.0"
"48676122","1","48676197","","2018-02-08 01:37:38","","1","1140","<p>I have setter and getter in my Angular service like below, what I want is if the <code>vizItemStream$</code> is not in 3 seconds, I want to throw timeout error. If item is set or already set then It shouldn't throw (if non-empty).</p>

<pre><code>vizItemStream$ = new ReplaySubject&lt;any&gt;(1);

set visualizeItem(item: VizItem) {
    this.vizItemStream$.next(item);
}

get visualizeItem$(): Observable&lt;VizItem&gt; {
    //Only throw timeout if there are no items emitted in 3 seconds
    // this.vizItemStream$.timeout(3000);
    let sub = Observable.empty().delay(3000).subscribe(e =&gt; {
        this.vizItemStream$.isEmpty().subscribe(e =&gt; {
            this.vizItemStream$.error(new Error('Timeout'));    
        });
        sub.unsubscribe();
    });        
    return this.vizItemStream$.asObservable();
}
</code></pre>

<p>I tried different options but none I could make it work. Any help how to achieve this?</p>
","3130446","","","","","2018-02-08 02:44:52","rxjs 5.2: ReplaySubject wait for 3 seconds and throw timeout if only empty","<angular><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48676197","2","","48676122","2018-02-08 01:47:28","","2","","

<p>You can use the <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators/race.ts#L13-L20"" rel=""nofollow noreferrer""><code>race</code></a> operator and a <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-timer"" rel=""nofollow noreferrer""><code>timer</code></a> to get the behaviour you are looking for:</p>

<pre class=""lang-ts prettyprint-override""><code>import 'rxjs/add/observable/throw';
import 'rxjs/add/observable/timer';
import 'rxjs/add/operator/concatMap';
import 'rxjs/add/operator/race';

get visualizeItem$(): Observable&lt;VizItem&gt; {
  return this.vizItemStream$
    .race(Observable
      .timer(3000)
      .concatMap(() =&gt; Observable.throw(new Error('Timeout'))))
    .asObservable();
}
</code></pre>

<p>The <code>race</code> operator:</p>

<blockquote>
  <p>Returns an Observable that mirrors the first source Observable to emit an item from the combination of this Observable and supplied Observables.</p>
</blockquote>
","6680611","","6680611","","2018-02-08 02:44:52","2018-02-08 02:44:52","","","","4","","","","CC BY-SA 3.0"
"48680071","1","","","2018-02-08 07:41:18","","0","1424","<p>I am trying to add a <a href=""https://material.angular.io/components/progress-bar/overview#indeterminate"" rel=""nofollow noreferrer"">material progress-bar</a> in my Angular 5 application using a HttpInterceptor. </p>

<p>Whenever there are any outstanding XHR requests, the progress bar should be visible and should be hidden/removed when there are no pending XHR requests.</p>

<p>Here is my <code>HttpInterceptor</code> implementation that keeps track of pending request count :-</p>

<pre><code>import {HttpEvent, HttpHandler, HttpInterceptor, HttpRequest} from '@angular/common/http';
import {Injectable} from '@angular/core';
import {Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/interval';
import 'rxjs/add/operator/publish';

@Injectable()
export class ProgressBatHttpInterceptorService implements HttpInterceptor {
  obs: Observable&lt;number&gt;; // PROBLEM: How to expose this as hot Obeservable ?
  private count = 0;

  constructor() {
    this.obs = Observable
      .create(observer =&gt; observer.next(this.count))
      .publish();
  }

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    this.count++;   // increment the count here
    const observable = next.handle(req);
    observable.subscribe(() =&gt; {
    }, () =&gt; {
    }, () =&gt; {
      --this.count; // decrements the count.
    });
    return observable;
  }
}
</code></pre>

<p><strong>AppComponent</strong> :-</p>

<pre><code>import {Component} from '@angular/core';
import {ProgressBatHttpInterceptorService} from './progress-bat-http-interceptor.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  constructor(progress: ProgressBatHttpInterceptorService) {
    const obs = progress.obs;
    obs.subscribe(function (n) { // This never gets invoked.
      console.log(n);
    });
  }
}
</code></pre>

<p>The <code>ProgressBatHttpInterceptorService</code> is injected into <code>AppComponent</code>. In <code>AppComponent</code> constructor I am trying to subscribe to the count observable created in <code>ProgressBatHttpInterceptorService</code>.</p>

<p>I am planning to use the count Observable to conditionally show hide the progress bar.</p>

<p><strong>PROBLEM</strong></p>

<p>The .subscribe doesn't prints anything to console.</p>

<p>What's the correct way to create a hot observable for keeping track of outstanding request count ?</p>
","945034","","","","","2018-02-13 03:52:04","Angular 5 | Rendering progress bar using HttpInterceptor","<angular><rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"48710814","1","","","2018-02-09 17:08:05","","3","565","<p>I'm using react native, redux, and redux-observables(with rxjs5), and making an ajax request. the problem is I can't return actions when an error happens.</p>

<p>here is my code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//action creators
export const loginSucceeded = token =&gt; {
	return {
		type: Types.LOGIN_SUCCEEDED,
		payload: {
			token
		}
	};
};

export const login = (username, password) =&gt; {
	return {
		type: Types.LOGIN,
		pauload: {
			username,
			password
		}
	};
};

export const loginFailed = () =&gt; {
	return {
		type: Types.LOGIN_FAILED
	};
};


//epic
const authEpic = (action$, store$) =&gt;
	action$.ofType(Types.LOGIN).mergeMap(action =&gt; {
		const authBody = {..};
		const headers = {..};
		return ajax
			.post(API.LOGIN, authBody, headers)
			.map(result =&gt; {
				return Actions.loginSucceeded(result.response.access_token);
			})
			.catch(err =&gt; {
				return Actions.loginFailed();
			});
	});</code></pre>
</div>
</div>
</p>

<p>apparently, the problem is with this line:</p>

<p><code>return Observable.of(Actions.loginFailed());</code></p>

<p>if I change it to return each of these sentences, I still get the same error</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>Observable.of(Actions.loginFailed);
Observable.of(Actions.loginFailed());
Actions.loginFailed;
Actions.loginFailed();</code></pre>
</div>
</div>
</p>

<p>and here  is the error:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>index.bundle?platform=ios&amp;dev=true&amp;minify=false:78220 Uncaught TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at Object.subscribeToResult (index.bundle?platform=ios&amp;dev=true&amp;minify=false:78220)
    at CatchSubscriber.error (Button.js:88)
    at MergeMapSubscriber.OuterSubscriber.notifyError (index.js:19)
    at InnerSubscriber._error (Button.js:15)
    at InnerSubscriber.Subscriber.error (observable.js:13)
    at MapSubscriber._next (Rx.js:55)
    at MapSubscriber.Subscriber.next (observable.js:5)
    at MapSubscriber._next (Rx.js:57)
    at MapSubscriber.Subscriber.next (observable.js:5)
    at AjaxSubscriber.next (ReplaySubject.js:82)</code></pre>
</div>
</div>
</p>

<p>and I read lots of StackOverflow questions about it, but almost all of them had the wrong functioncalls, and none applied to or worked on my problem.</p>
","3366437","","3366437","","2018-02-11 18:11:00","2018-02-11 18:11:00","redux-observable error: Uncaught TypeError: You provided an invalid object where a stream was expected","<javascript><react-native><redux><rxjs><rxjs5>","0","0","","","","CC BY-SA 3.0"
"48723337","1","48737476","","2018-02-10 17:05:08","","0","775","<p><strong>UPDATE</strong></p>

<p>I think I've figured out the solution. I explain it in this video. Basically, use timeoutWith, and some tricks with zip (within zip).</p>

<p><a href=""https://youtu.be/0A7C1oJSJDk"" rel=""nofollow noreferrer"">https://youtu.be/0A7C1oJSJDk</a></p>

<hr>

<p>If I have a single observable like this:</p>

<pre><code>A-1-2--B-3-4-5-C--D--6-7-E
</code></pre>

<p>I want to put the ""numbers"" as lower priority; it should wait until the ""letters"" is filled up (a group of 2 for example) OR a timeout is reached, and then it can emit. Maybe the following illustration (of the desired result) can help:</p>

<pre><code>A------B-1-----C--D-2----E-3-4-5-6-7
</code></pre>

<p>I've been experimenting with some ideas... one of them: first step is to split that stream (groupBy), one containing letters, and the other containing numbers..., then ""something in the middle"" happen..., and finally those two (sub)streams get merged.</p>

<p>It's that ""something in the middle"" what I'm trying to figure out.</p>

<p>How to achieve it? Is that even possible with RxJS (ver 5.5.6)? If not, what's the closest one? I mean, what I want to avoid is having the ""numbers"" flooding the stream, and not giving enough chance for the ""letters"" to be processed in timely manner.</p>

<p>Probably this video I made of my efforts so far can clarify as well:</p>

<ul>
<li>Original problem statement: <a href=""https://www.youtube.com/watch?v=mEmU4JK5Tic"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=mEmU4JK5Tic</a></li>
<li>So far: <a href=""https://www.youtube.com/watch?v=HWDI9wpVxJk&amp;feature=youtu.be"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=HWDI9wpVxJk&amp;feature=youtu.be</a></li>
</ul>

<p>The problem with my solution so far (delaying each emission in ""numbers"" substream using .delay) is suboptimal, because it keeps clocking at slow pace (10 seconds) even after the ""characters"" (sub)stream has ended (not completed -- no clear boundary here -- just not getting more value for indeterminate amount of time). What I really need is, to have the ""numbers"" substream raise its pace (to 2 seconds) once that happen.</p>
","3443096","","3443096","","2018-02-11 02:41:05","2018-02-11 23:11:55","RxJS interleaving merged observables (priority queue?)","<merge><observable><priority-queue><rxjs5><reactive>","2","0","0","","","CC BY-SA 3.0"
"48737476","2","","48723337","2018-02-11 23:11:55","","0","","<p>Unfortunately I don't know <code>RxJs5</code> that much and use <code>xstream</code> myself (authored by one of the contributor to RxJS5) which is a little bit simpler in terms of the number of operators. </p>

<p>With this I crafted the following example:
(Note: the operators are pretty much the same as in Rx5, the main difference is with flatten wich is more or less like <code>switch</code> but seems to handle synchronous streams differently).</p>

<pre><code>const xs = require(""xstream"").default;

const input$ = xs.of(""A"",1,2,""B"",3,4,5,""C"",""D"",6,7,""E"");

const initialState = { $: xs.never(), count: 0, buffer: [] };
const state$ = input$
    .fold((state, value) =&gt; {
        const t = typeof value;
        if (t === ""string"") {
            return {
                ...state,
                $: xs.of(value),
                count: state.count + 1
            };
        }
        if (state.count &gt;= 2) {
            const l = state.buffer.length;
            return {
                ...state,
                $: l &gt; 0 ? xs.of(state.buffer[0]) : xs.of(value) ,
                count: 0,
                buffer: state.buffer.slice(1).concat(value)
            };
        }
        return {
            ...state,
            $: xs.never(),
            buffer: state.buffer.concat(value),
        };
    }, initialState);


xs
    .merge(
        state$
        .map(s =&gt; s.$),
        state$
        .last()
        .map(s =&gt; xs.of.apply(xs, s.buffer))
    )
    .flatten()
    .subscribe({
        next: console.log
    });
</code></pre>

<p>Which gives me the result you are looking for.</p>

<p>It works by folding the stream on itself, looking at the type of values and emitting a new stream depending on it. When you need to wait because not enough letters were dispatched I emit an <code>empty</code>stream (emits no value, no errors, no complete) as a ""placeholder"".</p>

<p>You could instead of emitting this empty stream emit something like </p>

<pre><code>xs.empty().endsWith(xs.periodic(timeout)).last().mapTo(value):
// stream that will emit a value only after a specified timeout.
// Because the streams are **not** flattened concurrently you can
// use this as a ""pending"" stream that may or may not be eventually
// consumed
</code></pre>

<p>where value is the last received number in order to implement timeout related conditions however you would then need to introduce some kind of reflexivity with either a <code>Subject</code> in Rx or <code>xs.imitate</code> with xstream because you would need to notify your state that your ""pending"" stream has been consumed wich makes the communication bi-directionnal whereas streams / observables are unidirectionnal.</p>
","4374738","","","","","2018-02-11 23:11:55","","","","0","","","","CC BY-SA 3.0"
"48739451","1","48740280","","2018-02-12 04:14:29","","0","31","<p>I'm having difficulties to see why this code is dropping the first element?</p>

<pre><code>const Rx = require(""@reactivex/rxjs"")

const requestQueue = Rx.Observable.from([
  {type: ""show.json"", value: ""1""},
  {type: ""tweets.json"", value: ""A""},
  {type: ""show.json"", value: ""2""},
  {type: ""tweets.json"", value: ""B""}
])

requestQueue.groupBy(request =&gt; request.type).bufferCount(2).mergeMap(requestSubstreams =&gt; {
  return requestSubstreams[0].merge(requestSubstreams[1])
}).subscribe(x =&gt; console.log(x))
</code></pre>

<p>The output I'm getting is:</p>

<pre><code>{ type: 'tweets.json', value: 'A' }
{ type: 'show.json', value: '2' }
{ type: 'tweets.json', value: 'B' }
</code></pre>

<p>Been doing some experiments, it's always the first element that gets dropped.</p>

<p>This is the link to RxFiddle: <a href=""http://rxfiddle.net/#type=editor&amp;code=Y29uc3QgcmVxdWVzdFF1ZXVlID0gUnguT2JzZXJ2YWJsZS5mcm9tKFsKICB7dHlwZTogInNob3cuanNvbiIsIHZhbHVlOiAiMSJ9LAogIHt0eXBlOiAidHdlZXRzLmpzb24iLCB2YWx1ZTogIkEifSwKICB7dHlwZTogInNob3cuanNvbiIsIHZhbHVlOiAiMiJ9LAogIHt0eXBlOiAidHdlZXRzLmpzb24iLCB2YWx1ZTogIkIifQpdKQoKcmVxdWVzdFF1ZXVlLmdyb3VwQnkocmVxdWVzdCA9PiByZXF1ZXN0LnR5cGUpLmJ1ZmZlckNvdW50KDIpLm1lcmdlTWFwKHJlcXVlc3RTdWJzdHJlYW1zID0+IHsKICByZXR1cm4gcmVxdWVzdFN1YnN0cmVhbXNbMF0ubWVyZ2UocmVxdWVzdFN1YnN0cmVhbXNbMV0pCn0pLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKQ=="" rel=""nofollow noreferrer"">http://rxfiddle.net/#type=editor&amp;code=Y29uc3QgcmVxdWVzdFF1ZXVlID0gUnguT2JzZXJ2YWJsZS5mcm9tKFsKICB7dHlwZTogInNob3cuanNvbiIsIHZhbHVlOiAiMSJ9LAogIHt0eXBlOiAidHdlZXRzLmpzb24iLCB2YWx1ZTogIkEifSwKICB7dHlwZTogInNob3cuanNvbiIsIHZhbHVlOiAiMiJ9LAogIHt0eXBlOiAidHdlZXRzLmpzb24iLCB2YWx1ZTogIkIifQpdKQoKcmVxdWVzdFF1ZXVlLmdyb3VwQnkocmVxdWVzdCA9PiByZXF1ZXN0LnR5cGUpLmJ1ZmZlckNvdW50KDIpLm1lcmdlTWFwKHJlcXVlc3RTdWJzdHJlYW1zID0+IHsKICByZXR1cm4gcmVxdWVzdFN1YnN0cmVhbXNbMF0ubWVyZ2UocmVxdWVzdFN1YnN0cmVhbXNbMV0pCn0pLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKQ==</a> ... but I haven't figured out how to interpret it.</p>

<p>I have to resort to this code (using partition) in order to get the result I was expecting:</p>

<pre><code>const requestQueue = Rx.Observable.from([
  {type: ""show.json"", value: ""1""},
  {type: ""tweets.json"", value: ""A""},
  {type: ""show.json"", value: ""2""},
  {type: ""tweets.json"", value: ""B""}
])

const requestSubstreams = requestQueue.partition(request =&gt; request.type == ""show.json"")
const showJsonSubstream = requestSubstreams[0]
const tweetsJsonSubstream = requestSubstreams[1]

showJsonSubstream.merge(tweetsJsonSubstream).subscribe(x =&gt; console.log(x))
</code></pre>

<p>Can you help point out what's the issue / caveat with groupBy?</p>
","3443096","","","","","2018-02-12 05:53:28","RxJS5 groupBy dropping the first item from first group?","<reactive-programming><rxjs5>","1","5","","","","CC BY-SA 3.0"
"48740280","2","","48739451","2018-02-12 05:53:28","","0","","<p>To @cartant : it has to do with this code (in this code) the letters and numbers are from  separate observables. </p>

<pre><code>const letterArr = [""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I""]
const letterStream = Rx.Observable.zip(
  Rx.Observable.from(letterArr),
  Rx.Observable.range(0, letterArr.length - 1), 
  (letter, index) =&gt; Rx.Observable.of({letter, index}).delay(
    index == 0 ? 0 : index &lt; 5 ? (index == 2 ? 2000 : 5000) : 20000000
  )
).concatAll().multicast(new Rx.Subject())
//A emitted at 0s, B at 5s, C at 7s, D at 12s, E at 17s, F at ... never

const numberStream = Rx.Observable.zip(
  Rx.Observable.range(1, 20),
  Rx.Observable.interval(2000).startWith(-1).map(x =&gt; x +1),
  (number, index) =&gt; ({number, index})
).multicast(new Rx.Subject())
//1 emitted at 0s, 2 at 2s, 3 at 4s, ...

const slowedDownNumberStream = Rx.Observable.zip(
  numberStream,
  Rx.Observable.zip(
    letterStream,
    Rx.Observable.interval(10000).startWith(-1).map(x =&gt; x +1)
  ).timeoutWith(11000, Rx.Observable.interval(2000).startWith(-1)),
  (number, index) =&gt; ({number, index})
)

Rx.Observable.merge(letterStream, slowedDownNumberStream).subscribe(x =&gt; console.log(new Date(), "" &gt; "", x))
letterStream.connect()
numberStream.connect()
</code></pre>

<p>RxFiddle: <a href=""http://rxfiddle.net/#type=editor&amp;code=Y29uc3QgbGV0dGVyQXJyID0gWyJBIiwgIkIiLCAiQyIsICJEIiwgIkUiLCAiRiIsICJHIiwgIkgiLCAiSSJdCmNvbnN0IGxldHRlclN0cmVhbSA9IFJ4Lk9ic2VydmFibGUuemlwKAogIFJ4Lk9ic2VydmFibGUuZnJvbShsZXR0ZXJBcnIpLAogIFJ4Lk9ic2VydmFibGUucmFuZ2UoMCwgbGV0dGVyQXJyLmxlbmd0aCAtIDEpLCAKICAobGV0dGVyLCBpbmRleCkgPT4gUnguT2JzZXJ2YWJsZS5vZih7bGV0dGVyLCBpbmRleH0pLmRlbGF5KAogICAgaW5kZXggPT0gMCA/IDAgOiBpbmRleCA8IDUgPyAoaW5kZXggPT0gMiA/IDIwMDAgOiA1MDAwKSA6IDIwMDAwMDAwCiAgKQopLmNvbmNhdEFsbCgpLm11bHRpY2FzdChuZXcgUnguU3ViamVjdCgpKQovL0EgZW1pdHRlZCBhdCAwcywgQiBhdCA1cywgQyBhdCA3cywgRCBhdCAxMnMsIEUgYXQgMTdzLCBGIGF0IC4uLiBuZXZlcgoKY29uc3QgbnVtYmVyU3RyZWFtID0gUnguT2JzZXJ2YWJsZS56aXAoCiAgUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAyMCksCiAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS5zdGFydFdpdGgoLTEpLm1hcCh4ID0+IHggKzEpLAogIChudW1iZXIsIGluZGV4KSA9PiAoe251bWJlciwgaW5kZXh9KQopLm11bHRpY2FzdChuZXcgUnguU3ViamVjdCgpKQovLzEgZW1pdHRlZCBhdCAwcywgMiBhdCAycywgMyBhdCA0cywgLi4uCgpjb25zdCBzbG93ZWREb3duTnVtYmVyU3RyZWFtID0gUnguT2JzZXJ2YWJsZS56aXAoCiAgbnVtYmVyU3RyZWFtLAogIFJ4Lk9ic2VydmFibGUuemlwKAogICAgbGV0dGVyU3RyZWFtLAogICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwMCkuc3RhcnRXaXRoKC0xKS5tYXAoeCA9PiB4ICsxKQogICkudGltZW91dFdpdGgoMTEwMDAsIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkuc3RhcnRXaXRoKC0xKSksCiAgKG51bWJlciwgaW5kZXgpID0+ICh7bnVtYmVyLCBpbmRleH0pCikKClJ4Lk9ic2VydmFibGUubWVyZ2UobGV0dGVyU3RyZWFtLCBzbG93ZWREb3duTnVtYmVyU3RyZWFtKS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpLCAiID4gIiwgeCkpCmxldHRlclN0cmVhbS5jb25uZWN0KCkKbnVtYmVyU3RyZWFtLmNvbm5lY3QoKQ=="" rel=""nofollow noreferrer"">http://rxfiddle.net/#type=editor&amp;code=Y29uc3QgbGV0dGVyQXJyID0gWyJBIiwgIkIiLCAiQyIsICJEIiwgIkUiLCAiRiIsICJHIiwgIkgiLCAiSSJdCmNvbnN0IGxldHRlclN0cmVhbSA9IFJ4Lk9ic2VydmFibGUuemlwKAogIFJ4Lk9ic2VydmFibGUuZnJvbShsZXR0ZXJBcnIpLAogIFJ4Lk9ic2VydmFibGUucmFuZ2UoMCwgbGV0dGVyQXJyLmxlbmd0aCAtIDEpLCAKICAobGV0dGVyLCBpbmRleCkgPT4gUnguT2JzZXJ2YWJsZS5vZih7bGV0dGVyLCBpbmRleH0pLmRlbGF5KAogICAgaW5kZXggPT0gMCA/IDAgOiBpbmRleCA8IDUgPyAoaW5kZXggPT0gMiA/IDIwMDAgOiA1MDAwKSA6IDIwMDAwMDAwCiAgKQopLmNvbmNhdEFsbCgpLm11bHRpY2FzdChuZXcgUnguU3ViamVjdCgpKQovL0EgZW1pdHRlZCBhdCAwcywgQiBhdCA1cywgQyBhdCA3cywgRCBhdCAxMnMsIEUgYXQgMTdzLCBGIGF0IC4uLiBuZXZlcgoKY29uc3QgbnVtYmVyU3RyZWFtID0gUnguT2JzZXJ2YWJsZS56aXAoCiAgUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAyMCksCiAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS5zdGFydFdpdGgoLTEpLm1hcCh4ID0+IHggKzEpLAogIChudW1iZXIsIGluZGV4KSA9PiAoe251bWJlciwgaW5kZXh9KQopLm11bHRpY2FzdChuZXcgUnguU3ViamVjdCgpKQovLzEgZW1pdHRlZCBhdCAwcywgMiBhdCAycywgMyBhdCA0cywgLi4uCgpjb25zdCBzbG93ZWREb3duTnVtYmVyU3RyZWFtID0gUnguT2JzZXJ2YWJsZS56aXAoCiAgbnVtYmVyU3RyZWFtLAogIFJ4Lk9ic2VydmFibGUuemlwKAogICAgbGV0dGVyU3RyZWFtLAogICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwMCkuc3RhcnRXaXRoKC0xKS5tYXAoeCA9PiB4ICsxKQogICkudGltZW91dFdpdGgoMTEwMDAsIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkuc3RhcnRXaXRoKC0xKSksCiAgKG51bWJlciwgaW5kZXgpID0+ICh7bnVtYmVyLCBpbmRleH0pCikKClJ4Lk9ic2VydmFibGUubWVyZ2UobGV0dGVyU3RyZWFtLCBzbG93ZWREb3duTnVtYmVyU3RyZWFtKS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpLCAiID4gIiwgeCkpCmxldHRlclN0cmVhbS5jb25uZWN0KCkKbnVtYmVyU3RyZWFtLmNvbm5lY3QoKQ==</a></p>

<p>You see, I use the letterStream in the slowedDownNumberStream.</p>

<p>My situation now, I have one single stream as input (where letters and numbers are mixed), so I need to partition them, using groupBy..., and since I need both inside the mergeMap, so I put bufferCount between the groupBy and mergeMap.</p>
","3443096","","","","","2018-02-12 05:53:28","","","","0","","","","CC BY-SA 3.0"
"48742477","1","","","2018-02-12 08:47:51","","0","287","<p>I am working on the angular 4  application plus rxjs 5.x.</p>

<p>The json data structure like following.</p>

<p>Please anyone let me know how to get all the students list for class id NOT equal to 1 by rxjs operators.</p>

<p>Thanks </p>

<pre><code>[
  {
    ""id"": 1,
    ""class"": {
      ""id"": 1,
      ""name"": ""English""
    },
    ""students"": [
      {
        ""student"": {
          ""id"": 101,
          ""name"": ""hi101"",
          ""email"": ""hi101@marr.com.au""
        }
      },
      {
        ""student"": {
          ""id"": 102,
          ""name"": ""hi101"",
          ""email"": ""hi101@marr.com.au""
        }
      }
    ]
  },
  {
    ""id"": 2,
    ""class"": {
      ""id"": 2,
      ""name"": ""Physics""
    },
    ""students"": [
      {
        ""student"": {
          ""id"": 201,
          ""name"": ""ph201"",
          ""email"": ""ph201@marr.com.au""
        }
      },
      {
        ""student"": {
          ""id"": 202,
          ""name"": ""ph202"",
          ""email"": ""ph202@marr.com.au""
        }
      }
    ]
  },
  {
    ""id"": 3,
    ""class"": {
      ""id"": 3,
      ""name"": ""Maths""
    },
    ""students"": [
      {
        ""student"": {
          ""id"": 301,
          ""name"": ""m301"",
          ""email"": ""m301@marr.com.au""
        }
      },
      {
        ""student"": {
          ""id"": 302,
          ""name"": ""m302"",
          ""email"": ""m302@marr.com.au""
        }
      }
    ]
  }
]
</code></pre>
","1947350","","8495123","","2018-02-12 09:56:51","2018-02-12 09:56:51","how to get nested observable objects","<angular><rxjs5>","0","2","","","","CC BY-SA 3.0"
"48747488","1","48758440","","2018-02-12 13:20:13","","0","230","<p>I would like to make a HTTP call and get the output as observable (this is the easy part) and then, immediately make another HTTP call and ignore the output.</p>

<p>I can not use switchMap operator because the second HTTP call does not return something useful. it just returns 'Done!' and the first call returns complex JSON that i need. </p>

<p>what I did, and it works, is to subscribe to the inner http call and i would like to know if there is an rxjs operator that i can use instead: </p>

<pre><code>this.dataStorageBaseService.createIdentity(identity)
  .do(() =&gt; this.authService.JustSimpleHTTPCall().first().subscribe()).subscribe();       
</code></pre>

<p>Is there a RxJS operator that i can use instead of subscribe again to the ""JustSimpleHTTPCall""? map would be good but i do not need the data that JustSimpleHTTPCall returns and it will not work together with the output of ""createIdentity"" that I need to return as observable.</p>
","1246758","","310726","","2018-02-12 13:28:53","2018-02-13 02:10:38","rxjs operator that will make http call but will ignore the data and will not return an observable","<angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"48752530","1","","","2018-02-12 17:51:02","","0","552","<p>I want my service (angular, typeScript, rxjs5) to return an observable rather than a promise.</p>

<p>I need this observable:</p>

<ol>
<li>to start cold (if no one subscribed, donât hit the server)</li>
<li>to cache the last result forever (it never completes, but if you subscribe late you get the last answer, like replaySubject)</li>
<li>to be created/hold value of a promise (my api service returns a promise)</li>
</ol>

<p>got to this:</p>

<pre><code>const deferredObservable = Rx.Observable
  .defer(() =&gt; Rx.Observable.fromPromise(this.getFromServer()))
  .replay(true, 1);
</code></pre>

<p>but nothing happens when I subscribe. Any ideas?</p>
","4828505","","","","","2018-02-12 17:51:02","How do I create cold replay observable from a promise","<javascript><angularjs><typescript><rxjs><rxjs5>","0","2","","","","CC BY-SA 3.0"
"48756832","1","48775103","","2018-02-12 22:49:55","","0","815","<p>I am using Redux-Observable Epic in a React &amp; Redux project. I have multiple actions need to emit, originally this is what I have been doing,</p>

<p>1) Catch the START_ACTION in the Epic<br>
2) Fetch remote data<br>
3) Return a new Observanble<br></p>

<p>for example:</p>

<pre><code>import fetch from 'isomorphic-fetch';
import {Observable} from 'rxjs/Observable';
import {switchMap} from 'rxjs/operator/switchMap';
import {mergeMap} from 'rxjs/operator/mergeMap';


const fetchAsync = (arg) =&gt; {
   // return an observable of promise
   return Observable::from(fetch(url + arg));
} 

export function myEpic = (action$) =&gt; {
   action$.ofType(START_ACTION)
    ::switchMap(action =&gt; {
       return fetchAsync('/action.payload')
          ::mergeMap(result =&gt; {
             return Observable::of({type: ACTION_COMPLETE, payload: result})
          }) 
    })
 };
</code></pre>

<p>Now what if I have another action <code>SECOND_ACTION</code> need to be emitted after the <code>START_ACTION</code> and before the <code>ACTION_COMPLETE</code> ? In other word, without making sure the <code>SECOND_ACTION</code> hits the reducer, the <code>ACTION_COMPLETE</code> should not be emitted.</p>

<p>I could write another separate Epic function to do this, but is there any other easier way?</p>
","4597683","","","","","2018-02-15 17:59:30","Multiple actions with dependencies in Redux-Observable","<javascript><react-redux><rxjs5><redux-observable>","1","4","","","","CC BY-SA 3.0"
"48758440","2","","48747488","2018-02-13 02:10:38","","1","","<p>You just need your inner Observable to emit the outer result - this can be done with <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat"" rel=""nofollow noreferrer"">concat</a></p>

<pre><code>this.dataStorageBaseService.createIdentity(identity)
  .switchMap(result =&gt; this.authService.JustSimpleHTTPCall().concat(Observable.of(result)))
  .subscribe(...);
</code></pre>
","2431784","","","","","2018-02-13 02:10:38","","","","0","","","","CC BY-SA 3.0"
"48775103","2","","48756832","2018-02-13 20:29:52","","1","","<blockquote>
  <p>To simplify the question, I just want to emit the SECOND_ACTION before the async.</p>
</blockquote>

<p>To emit another action before performing the <code>fetchAsync</code>, you can either use <code>Observable.concat</code> or the <code>startWith</code> operator, which is basically sugar for the concat.</p>

<pre><code>export function myEpic = (action$) =&gt; {
   action$.ofType(START_ACTION)
    ::switchMap(action =&gt; {
       return fetchAsync('/action.payload')
          ::map(result =&gt; ({ type: ACTION_COMPLETE, payload: result })
          ::startWith({ type: SECOND_ACTION })
    })
 };
</code></pre>

<p>Since <code>SECOND_ACTION</code> synchronously follows <code>START_ACTION</code>, keep in mind that often you should just have your reducers listen for <code>START_ACTION</code> instead of emitting another action. Multiple reducers transitions state from the same action is normal and one of the primary benefits of redux.</p>

<p>That said, there are certainly some times where the separation of concerns is more ideal, so this is more of a general tip.</p>

<hr>

<h2>Previous answer</h2>

<p>If you want to emit two actions sequentially you can pass the additional actions as arguments to <code>Observable.of(...actions)</code> since it accepts any number of arguments and emits them sequentially.</p>

<pre><code>export function myEpic = (action$) =&gt; {
   action$.ofType(START_ACTION)
    ::switchMap(action =&gt; {
       return fetchAsync('/action.payload')
          ::mergeMap(result =&gt; {
             return Observable::of(
               { type: SECOND_ACTION },
               { type: ACTION_COMPLETE, payload: result }
             )
          }) 
    })
 };
</code></pre>

<p>If this isn't what you meant, I apologize. The question isn't clear.</p>
","1770633","","1770633","","2018-02-15 17:59:30","2018-02-15 17:59:30","","","","2","","","","CC BY-SA 3.0"
"48775806","1","49058307","","2018-02-13 21:18:50","","2","1363","<p>I have some code I'm migrating to RxJS 5.5, which already worked.</p>

<pre><code>public getMentor(id: number): Observable&lt;Employee&gt; {
    const url = `${this.employeeUrl}/${id}/mentor`;
    return this.http
        .get(url, this.authService.getOptionsWithToken())
        .retryWhen(errors =&gt; {
            return errors
                .mergeMap(error =&gt; (error.status === 404) ? Observable.throw(error) : Observable.of(error))
                .take(this.maxRetries);
        })
        .map(response =&gt; response.json() as Employee)
        .catch(ErrorHandlerService.handleError);
}
</code></pre>

<p>In any case, if this request fails with 404, it's OK according to the business logic. Now, this would be a near equivalent in 5.5:</p>

<pre><code>public getMentor(id: number): Observable&lt;Employee&gt; {
  const url = `${this.employeeUrl}/${id}/mentor`;
  return this.http.get&lt;Employee&gt;(url)
    .pipe(
      retryWhen(errors =&gt; {
        console.log('errorInService', errors);
        return errors.pipe(
          mergeMap(error =&gt; (error.status === 404) ? _throw(error) : of(error)),
          take(this.maxRetries)
        )
      }),
      catchError(ErrorHandlerService.handleError)
    );
}
</code></pre>

<p>Here, the flow gets interrupted because inside retryWhen, errors is now a Subject and I cannot extract the status as before.</p>

<pre><code>this.employeeService.getMentor(this.mentee.id).subscribe(
    mentor =&gt; {
      this.existingMentor = mentor;
      this.modalAddConfirmation(addConfirmation, mentee, form);
    },
    e =&gt; {
      console.log('errorInMentor', e);
      if (e.status === 404) {
        // console.log('No mentor');
        this.employeeService.putMentor(mentee.id, this.mentor)
          .subscribe(() =&gt; this.mentees.push(mentee));
      } else {
        return null;
      }
    }
  );
</code></pre>

<p>In the original caller, ""e"" is now a string which says <code>Http failure response for http://localhost:8888/employees/1/mentor: 404 OK</code> instead of an object. Obviously, the <code>putMentor()</code> call never gets made. I'm just learning so it's most likely I haven't understood fully the new pipeable operators.</p>

<h2>Update</h2>

<p>At least this code is throwing an ErrorObservable, but on the caller end (<code>errorInMentor</code>) it's still a string:</p>

<pre><code>public getMentor(id: number): Observable&lt;Employee&gt; {
  const url = `${this.employeeUrl}/${id}/mentor`;
  return this.http.get&lt;Employee&gt;(url)
    .pipe(
      retryWhen(errors =&gt; {
        return errors.pipe(
          mergeMap(error =&gt; {
            console.log('error MergeMap', error);
            return error.status === 404 ? _throw(error) : of(error);
          }),
          take(this.maxRetries)
        )
      }),
      catchError(ErrorHandlerService.handleError)
    );
}
</code></pre>
","1509100","","1509100","","2018-02-13 22:21:38","2018-03-01 20:36:42","Handling retryWhen status code in RxJS 5.5","<rxjs5><rxjs-lettable-operators>","1","0","1","","","CC BY-SA 3.0"
"48791905","1","48792862","","2018-02-14 16:28:30","","0","221","<p>I'm a beginner working through basic examples with RxJS and Angular. I am using:</p>

<p>rxjs 5.5.6
angular 5.2.0</p>

<p>I'm getting the following error:</p>

<pre><code>error TS2339: Property 'do' does not exist on type 'number[]'.
</code></pre>

<p>from the following code that converts back and forth between an array and a series of items. I am attempting to insert mergeAll in place of mergeMap, which compiles and works as expected in converting the array. I would expect an Observable returned from mergeAll according to the docs without having to cast, especially since mergeMap is based on mergeAll.</p>

<pre><code>this.notWorking().subscribe();

notWorking(): Observable&lt;any&gt; {
    return Observable.from([[1, 2, 3, 4]])
        .do(obj =&gt; console.log(obj))
        // .mergeMap(val =&gt; val)
        .mergeAll()
        .do(obj =&gt; console.log(obj))
        .toArray()
        .do(obj =&gt; console.log(obj))
}
</code></pre>

<p>In the documentation from ReactiveX RxJS, it shows only a return value of Observable for mergeAll. Am I looking at the right documentation? Am I not understanding something fundamental about RxJS?</p>

<blockquote>
  <p>public     mergeAll(concurrent: number): Observable</p>
  
  <p>Converts a higher-order Observable into a first-order Observable which
  concurrently delivers all values that are emitted on the inner
  Observables.</p>
</blockquote>

<p><a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeAll"" rel=""nofollow noreferrer"">Reactive RxJS mergeAll documentation</a></p>

<p>If the case is that it is returning an iterable and this is intended, what is the best practice to chain observable operators? Do I have to cast between each chain or create an Observable? This doesn't make sense to me, I hope I'm just doing something wrong.</p>
","733002","","310726","","2018-02-14 17:18:14","2018-02-14 17:18:14","Difficulty with RxJS return values and documentation, converting between array and series of items","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48792862","2","","48791905","2018-02-14 17:17:58","","2","","<p>This is a known issue in typings for <code>mergeAll</code> and <code>concatAll</code> in RxJS 5.5 that will be fixed in RxJS 6. </p>

<p>For more details see: <a href=""https://github.com/ReactiveX/rxjs/issues/2759"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2759</a></p>

<p>So the recommended way for now is really using what you did with <code>.mergeMap(val =&gt; val)</code>.</p>
","310726","","","","","2018-02-14 17:17:58","","","","0","","","","CC BY-SA 3.0"
"48799504","1","","","2018-02-15 03:23:09","","0","2447","<p>I am trying to figure out a good way to signal that a ReplaySubject is currently ""empty"".</p>

<pre><code>import {ReplaySubject} from 'rxjs/ReplaySubject';
const rs = new ReplaySubject&lt;Object&gt;();

 // ...
constructor(){
  this.sub =  rs.subscribe(...);
}
</code></pre>

<p>everytime the constructor is called, it will replay all the items from the subject. However my question is - is there some event we can listen for, that tells us when the subject becomes empty? </p>

<p>The only thing that I can think of is to fire a custom/different event when subject is done, something like this:</p>

<pre><code>rs.next({done:true});
</code></pre>

<p>is passing data to the next() method the best way to signal that ReplaySubject is (temporarily) empty/out of events?</p>
","","user7898461","","","","2018-02-22 16:09:35","Signal when a ReplaySubject has ""finished""","<rxjs><rxjs5><angular-observable>","2","2","","","","CC BY-SA 3.0"
"48807296","1","48807689","","2018-02-15 12:28:13","","1","64","<p>I'm running into a bug and I've determined it's due to the fact that Subjects when <code>next()</code>ed will fire their events synchronously. </p>

<p>The following code produces the following ouput:</p>

<pre><code>mySubject.subscribe(score =&gt; {
  if (score === 2) {
    mySubject.next(score + 10);
  }
})
mySubject.subscribe(score =&gt; console.log(score))

Ouput:
1
12
2
</code></pre>

<p>The only way Im able to get the proper output (<code>1,2,12</code>) is if I wrap my <code>next()</code> call in a <code>setTimeout</code> to make it async.  Is there a proper way to deal with this issue that I'm missing?</p>
","684869","","310726","","2018-02-19 06:30:28","2018-02-19 06:30:28","Maintaining Subject emission order when invoking next within subscription","<rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"48807689","2","","48807296","2018-02-15 12:47:35","","2","","<p>If you're using RxJS 5.5 I'd personally use <code>setTimeout</code> as well. There's <code>subscribeOn</code> operator that you could use with the <code>async</code> scheduler (<code>import { async } from 'rxjs/scheduler/async'</code>) to run every emission in a new frame but it's <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.6/src/operators.ts#L79-L85"" rel=""nofollow noreferrer"">not available in RxJS 5.5 right now</a>.</p>

<p>So probably the easiest way is using <code>delay(0)</code> which doesn't make any delay and passes everything asynchronously like you did with <code>setTimeout()</code>:</p>

<pre><code>import { Subject } from 'rxjs/Subject';
import { delay } from 'rxjs/operators';

const mySubject = new Subject();
const source = mySubject.pipe(delay(0));

source.subscribe(score =&gt; {
  if (score === 2) {
    mySubject.next(score + 10);
  }
})
source.subscribe(score =&gt; console.log(score));

mySubject.next(1);
mySubject.next(2);
</code></pre>

<p>See live demo (open console): <a href=""https://stackblitz.com/edit/typescript-fiwgrk?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-fiwgrk?file=index.ts</a></p>
","310726","","","","","2018-02-15 12:47:35","","","","2","","","","CC BY-SA 3.0"
"48812163","1","48892750","","2018-02-15 16:39:29","","0","403","<p>Was trying to reimplement main application of the company switching from Promises and imperative style to RxJS and functional style. And found myself in a specific situation.</p>

<p><strong>Problem:</strong> We have a list of posts in the system that can be filtered.
So, I have created a pretty straightforward filter component and a list component where I receive data like this:</p>

<pre><code>this.items = this.filterChange
    .startWith(this.filterComponent.initialValue);
    .debounceTime(400)
    .switchMap((data) =&gt; this.process(data))
    .share();
</code></pre>

<p>But then I need to plug in another event from sockets which updates individual elements in the list. Our <code>process</code> function can understand both events and react on them, but the issue is:</p>

<pre><code>merge(this.filterChange.debounceTime(400), this.socketUpdates)
    .startWith(this.filterComponent.initialValue);
    .switchMap((data) =&gt; this.process(data))
    .share();
</code></pre>

<p>if update happens right after search was changed we lose search changes result, what should I do in this situation?</p>

<p><em>PS:</em> I have considered as an option <code>combineLatest</code> + <code>pariwise</code> to have an ability what was changed and react on that. Isn't there more elegant solution?</p>
","5710861","","","","","2018-02-20 19:23:57","RxJS: How should I update elements in observable via socket.js event?","<javascript><angular><rxjs><rxjs5>","2","2","","","","CC BY-SA 3.0"
"48813002","1","48813394","","2018-02-15 17:26:10","","6","3758","<p>I have the following component Template:</p>

<pre><code>&lt;div *ngFor=""let ctrl of data; trackBy:ctrl?.Id""&gt;
   &lt;div *ngIf=""getNext(ctrl.nextDate) | async as next""&gt;
        &lt;span&gt;{{next | date: 'dd.MM.yyyy'}}&lt;/span&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>getNext() is a simple method returning an <code>Observable&lt;Date&gt;</code>:</p>

<pre><code>public getNext(deadline: string): Observable&lt;Date&gt; {
   return this.http.get&lt;Date&gt;(`${this.config.apiEndpoint}/api/meeting?deadline=${deadline}`);
}
</code></pre>

<p>My goal would be to invoke the method and subscribe to the observable with the async pipe in the template. However when I run the application endless GET and OPTIONS requests are generated.</p>

<p>Also if I place the method call outside the ngFor the same happen. The call would need to be executed inside the ngFor as the parameter is different for each collection item.</p>

<p>Why the method is simply called once and no more calls generated after the subscription?</p>
","706293","","706293","","2018-02-15 17:31:12","2018-02-18 11:54:34","Async Pipe in Template inside ngFor block triggers http GET calls loop","<angular><typescript><observable><rxjs5>","3","0","","","","CC BY-SA 3.0"
"48813394","2","","48813002","2018-02-15 17:49:08","","7","","<p>Calling functions in template is usually not a very good idea as it leads to unpredictable results. This is how you can restructure your code to avoid this:</p>

<pre><code>data: any = [....] // some data
data$: Observable[];

ngOnInit() {
    this.data$ = this.data.map(elem =&gt; this.getNext(elem));
} 

public getNext(deadline: string): Observable&lt;Date&gt; {
   return this.http.get&lt;Date&gt;(`${this.config.apiEndpoint}/api/meeting?deadline=${deadline}`);
}
</code></pre>

<p>And in your template:</p>

<pre><code>&lt;div *ngFor=""let ctrl of data$""&gt;
   &lt;div *ngIf=""ctrl | async as next""&gt;
        &lt;span&gt;{{next | date: 'dd.MM.yyyy'}}&lt;/span&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Here's a stackblitz I created where you can see how a similar mechanism works: <a href=""https://stackblitz.com/edit/angular-nyn4qz"" rel=""noreferrer"">https://stackblitz.com/edit/angular-nyn4qz</a></p>
","9321282","","","","","2018-02-15 17:49:08","","","","6","","","","CC BY-SA 3.0"
"48817171","1","","","2018-02-15 22:14:39","","0","145","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export function handleAction(action$) {
    return combineLatest(
                    action$.ofType(actions.LAYOUT_READY),
                action$.ofType(actions.LOADING))
        .mapTo(lastViewedPending())
        .mergeMap((action)=&gt; {
            return leadService.getLastPxls()
                .map(items =&gt; lastViewedSucceed(items))
                .startWith(action)
        });
}</code></pre>
</div>
</div>
</p>

<p>i am getting error: </p>

<pre><code>  TS2345: Argument of type 'LAST_VIEWED_PENDING' is not assignable to parameter of type 'IScheduler | LAST_VIEWED_SUCCESS'.
</code></pre>

<p>Type 'LAST_VIEWED_PENDING' is not assignable to type 'LAST_VIEWED_SUCCESS'.
    Property 'payload' is missing in type 'LAST_VIEWED_PENDING'.</p>

<p>i am using redux-observable</p>
","8987378","","","","","2018-02-15 22:14:39","get error on combineLatest to mapTo","<rxjs><reactive-programming><rxjs5><redux-observable>","0","2","0","","","CC BY-SA 3.0"
"48821954","1","49876510","","2018-02-16 07:27:10","","2","133","<p>I'm uploading a file by creating slices of file using <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice"" rel=""nofollow noreferrer"">Blob.slice()</a> in a <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"" rel=""nofollow noreferrer"">generator</a> function</p>

<pre class=""lang-ts prettyprint-override""><code>export function* chunkFile(file: File, chunkSize: number) {
    let chunkStart = 0;
    const _chunkEnd = chunkStart + chunkSize;
    let chunkEnd = _chunkEnd &gt; file.size ? file.size : _chunkEnd;
    while (chunkStart &lt; file.size) {
        yield &lt;ChunkType&gt;{
            chunk: file.slice(chunkStart, chunkEnd),
            start: chunkStart,
            end: chunkEnd
        };
        chunkStart = chunkEnd;
        const _chunkEndIn = chunkStart + chunkSize;
        chunkEnd = _chunkEndIn &gt; file.size ? file.size : _chunkEndIn;
    }
}
</code></pre>

<p>and I'm uploading file like this</p>

<pre class=""lang-ts prettyprint-override""><code>Observable.from(chunckFile(file,chunkSize)).concatMap(uploadRoutine).subscribe();
</code></pre>

<p>But all chunks are created at same time.</p>

<p>what I need is create new chunck (call <code>next</code> on generator) only when current chunk upload completes.</p>
","1859367","","1033581","","2018-03-18 14:57:43","2018-04-17 11:09:03","rxjs, call next on generator only after previous operation completes","<iterator><generator><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48823054","1","48824132","","2018-02-16 08:50:19","","1","1465","<p>I have an Observable where User has an array property Posts[] that I want to iterate through, invoke a method with the intermediate values and then return an Observable with the resulting objects as arrays.</p>

<p>At the moment I have the following code that works:</p>

<pre><code>    public ngOnInit() {
    const results: any[] = [];
    this.controlData$ = this.controlContent$
        .pipe(
            filter((input) =&gt; input !== null),
            flatMap((p: IControlContentSection) =&gt; p.controlPerformers),
            map((m: IControlPerformer) =&gt; {
                results.push({
                        ...m,
                        nextOccurrence: this.getNextControlDate(m.controlFrequency, m.firstOccurrence),
                    });
                return results;
                }),
            takeUntil(this.destroy$),
            );
}
</code></pre>

<p>I use an array variable <code>results: any[]</code>, but I do not like this solution as it relies on this external variable, making it working only when the component is initialized.</p>

<p>I tried to use <code>toArray()</code> or a <code>reduce((x, y) =&gt; x.concat(y), [])</code> after the map, but this then resolves into <em>null</em> in the template.</p>

<p>How can I return an Observable without the need of an external variable?</p>

<p>In template I subscribe via async pipe:</p>

<pre><code>&lt;div *ngIf=""controlData$ | async as controllers""&gt;
  ...
  &lt;div *ngFor=""let ctrl of controllers; trackBy:ctrl?.userId""&gt;
  ...
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
","706293","","706293","","2018-02-16 10:07:41","2018-02-16 12:08:11","Iterate through elements and return Observable of array","<arrays><angular><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48824132","2","","48823054","2018-02-16 09:55:23","","1","","<p>You are doing it correctly after the map, it should work. But to simulate your exact behavior you need a scan operator. The <strong>scan</strong> operator will emit intermediate values, as you do returning your results array. 
Have you tried it like this?:</p>

<pre><code> public ngOnInit() {
    this.controlData$ = this.controlContent$
    .pipe(
        filter((input) =&gt; input !== null),
        flatMap((p: IControlContentSection) =&gt; p.controlPerformers),
        map((m: IControlPerformer) =&gt; {
            return {...m,
                    nextOccurrence: this.getNextControlDate(m.controlFrequency, m.firstOccurrence),
                };
         }),
         scan((acc, cur) =&gt; [...acc, cur], [])
         takeUntil(this.destroy$),
        );
}
</code></pre>

<p>It should work, if not, I could provide you a plunker or so.</p>

<p>Hope this helps.</p>
","6099651","","706293","","2018-02-16 12:08:11","2018-02-16 12:08:11","","","","1","","","","CC BY-SA 3.0"
"48826799","1","48826894","","2018-02-16 12:28:32","","10","7288","<p>I would like to create a delayed observable in typescript by:</p>

<pre><code>import 'rxjs/add/observable/of';

...

const o = Observable.of(values).delay(10000);
o.subscribe((v) =&gt; { alert(v); });
</code></pre>

<p>but I got the following error: </p>

<pre><code>""Observable_1.Observable.of(...).delay is not a function""
</code></pre>
","5728926","","","","","2020-03-17 08:19:26","rxjs: Observable.of(...).delay is not a function","<typescript><angular-cli><rxjs5>","2","0","","","","CC BY-SA 3.0"
"48826894","2","","48826799","2018-02-16 12:33:16","","15","","<p>In rxjs6 operators can be found in the 'rxjs/operators/*' packages. </p>

<pre class=""lang-js prettyprint-override""><code>import { delay } from 'rxjs/operators/delay';

of(values).pipe(
    delay(1000)
).subscribe(console.log);
</code></pre>



<p>In older versions can import the <strong>delay</strong> operator separately.</p>

<pre><code>import 'rxjs/add/operator/delay';
</code></pre>
","5152732","","5152732","","2020-03-17 08:19:26","2020-03-17 08:19:26","","","","5","","","","CC BY-SA 4.0"
"48843141","1","48843291","","2018-02-17 15:59:31","","2","3248","<p>I want to unsubscribe from another Observable using takeUntil using a BehaviorSubject. When I subscribe to the Observable with the takeUntil, it seems to immediately unsubscribe. This code works fine with a Subject, but I want an initial value set.</p>

<p>I'm using rxjs 5.5.6</p>

<pre><code>//MyService1
class Observable1 {
  status1: BehaviorSubject&lt;boolean&gt; = new BehaviorSubject&lt;boolean&gt;(false);

  displayStatus1(val: boolean) {
    this.status1.next(val)
  }
}

//MyService2
class Observable2 {
  status2: BehaviorSubject&lt;boolean&gt; = new BehaviorSubject&lt;boolean&gt;(false);

  displayStatus2(val: boolean) {
    this.status2.next(val)
  }
}

//MyComponent
status: boolean;

constructor(private myService1: MyService1, private myService2: MyService2) {
   this.subscribeToObservable1();
   this.subscribeToObservable2();
}

subscribeToObservable1() {
  this.myService1.status1.subscribe((val: boolean) =&gt; {
    console.log('val: ', val);
  }
}

subscribeToObservable2() {
  this.myService2.status2
    .takeUntil(this.myService1.status1)
    .subscribe((val: boolean) =&gt; {
      this.status = val;
    }
}
</code></pre>
","5009022","","859154","","2018-02-17 16:15:36","2021-05-06 09:49:34","RxJs - Can I use a BehaviorSubject with takeUntil?","<javascript><rxjs5><behaviorsubject>","4","0","0","","","CC BY-SA 3.0"
"48843291","2","","48843141","2018-02-17 16:14:25","","1","","<p>You're after <code>takeWhile</code> :  (<em>since takeUntil doesn't take a predicate</em>).</p>

<pre><code>var bs = new Rx.BehaviorSubject&lt;boolean&gt;(false); //create beahviour subject
const source = Rx.Observable.interval(1000);     //create observable
// take from obs while , behaviour subject not emitting true
const example = source.takeWhile ((a)=&gt;bs.value!=true); 
const subscribe = example.subscribe(val =&gt; console.log(val));

setTimeout(()=&gt;bs.next(true),3000); //make the BehaviorSubject emit true and stop.
</code></pre>

<p><a href=""http://jsbin.com/yaditucija/1/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/yaditucija/1/edit?js,console</a></p>
","859154","","","","","2018-02-17 16:14:25","","","","0","","","","CC BY-SA 3.0"
"48843447","1","48843611","","2018-02-17 16:32:44","","6","672","<p>I have some trouble to understand this. When I use the switchMap operator with an Observable it emits all the values as expected:</p>

<pre><code>Observable.from([1, 2, 3, 4, 5])
    .do(console.log)
    .switchMap(i =&gt; Observable.of('*' + i))
    .do(console.log)
    .subscribe();
</code></pre>

<p>Results:</p>

<pre><code>1
*1
2
*2
3
*3
4
*4
5
*5
</code></pre>

<p>But when I replace the the Observable by a Promise I get a different behaviour:</p>

<pre><code>Observable.from([1, 2, 3, 4, 5])
    .do(console.log)
    .switchMap(i =&gt; new Promise((resolve) =&gt; resolve('*' + i)))
    .do(console.log)
    .subscribe();
</code></pre>

<p>Results:</p>

<pre><code>1
2
3
4
5
*5
</code></pre>
","1380926","","1380926","","2018-02-17 16:41:14","2018-02-17 16:48:47","Why does switchMap operator only emit the last value when used with a promise?","<promise><rxjs><observable><rxjs5><switchmap>","1","0","0","","","CC BY-SA 3.0"
"48843611","2","","48843447","2018-02-17 16:48:47","","3","","<p>This works as expected. The unexpected behaviors as you said is because <code>Observable.from</code> and <code>Observable.of</code> are always strictly synchronous while <code>new Promise</code> necessarily doesn't (I'm not sure about the specification so maybe that's what Promise has to do in all browsers).</p>

<p>Anyway you can force <code>Observable.from</code> emit asynchronously by passing the <code>async</code> Scheduler.</p>

<pre><code>import { Observable } from 'rxjs';
import { async } from 'rxjs/scheduler/async';

Observable.from([1, 2, 3, 4, 5], async)
    .do(console.log)
    .switchMap(i =&gt; new Promise((resolve) =&gt; resolve('*' + i)))
    .do(console.log)
    .subscribe();
</code></pre>

<p>Now every emission is in a new frame just like <code>Promise</code> and the output is as you expected.</p>

<p>See live demo (open console): <a href=""https://stackblitz.com/edit/rxjs5-gfeqsn?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs5-gfeqsn?file=index.ts</a></p>
","310726","","","","","2018-02-17 16:48:47","","","","2","","","","CC BY-SA 3.0"
"48851385","1","","","2018-02-18 11:58:15","","-1","124","<p>I have an observable and I need it to act like a promise, i.e. the chain should be executed <em>once</em> on creation and result in hot observable.</p>

<p>Here's an example:</p>

<pre><code>console.log('0 ms');

var foo$ = new Observable(obs =&gt; obs.next(1))
.map(v =&gt; {
  console.log('map, ' + v);
  return v + 1;
})
.share();

foo$.subscribe(); // would like to skip this

setTimeout(() =&gt; {
  console.log('100 ms');
  foo$.subscribe(v =&gt; { console.log('subscribe, ' + v); });
});
</code></pre>

<p>It results in desirable output:</p>

<blockquote>
  <p>0 ms</p>
  
  <p>map 1</p>
  
  <p>100 ms</p>
  
  <p>subscribe 2</p>
</blockquote>

<p>The observable needs to be subscribed with extra <code>subscribe()</code>, and I would like to avoid that.</p>

<p>But this won't work with completed observables:</p>

<pre><code>console.log('0 ms');

var bar$ = new Observable(1, 2)
.map(v =&gt; {
  console.log('map, ' + v);
  return v + 1;
})
.share();

bar$.subscribe(); // would like to skip this

setTimeout(() =&gt; {
  console.log('100 ms');
  bar$.subscribe(v =&gt; { console.log('subscribe, ' + v); });
});
</code></pre>

<p>Desired output:</p>

<blockquote>
  <p>0 ms</p>
  
  <p>map 1</p>
  
  <p>map 2</p>
  
  <p>100 ms</p>
  
  <p>subscribe 2</p>
  
  <p>subscribe 3</p>
</blockquote>

<p>Real output:</p>

<blockquote>
  <p>0 ms</p>
  
  <p>map, 1</p>
  
  <p>map, 2</p>
  
  <p>100 ms</p>
  
  <p>map, 1</p>
  
  <p>subscribe 2</p>
  
  <p>map, 2</p>
  
  <p>subscribe 3</p>
</blockquote>

<p>Observable chain is re-executed on every subscription.</p>

<p><code>Observable.of</code> and increment map are used as an example. Both observable and its chain can be costly, so the chain should be executed only once, similarly to a promise. But I can't just switch to promises because there can be more than one value in completed observable.</p>

<p>Another concern is that promises are susceptible to GC and won't result in memory leaks. I'm not sure if observable subscriptions can guarantee that.</p>

<p>How can an observable be pre-subscribed with operator to avoid dummy <code>subscribe()</code>?</p>

<p>How can can completed observable with multiple values be pre-subscribed and avoid multiple chain execution?</p>

<p>Can such observables be garbage collected, similarly to promises?</p>

<p><em>There are similar answered questions but I believe they don't address all the concerns</em>.</p>
","3731501","","3731501","","2018-02-18 20:25:24","2018-02-18 20:25:24","Shared pre-subscribed RxJS observables","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48857550","1","52707668","","2018-02-18 23:03:09","","1","343","<p>Trying to understand what is the best way to unit test RXjs 5 subscription.
So for example, if I have a complex observables chain and some business logic inside the subscribe block, how should I test it?
the options I see are:</p>

<ol>
<li>Use Test scheduler with advanceBy operators (similar to how you would do it in rxjs 4)</li>
<li>Marble testing, but as far as i understand marble testing only cover the observable so you can test what is going to be the output of the observable chain according to a specific input, but this test doesnt cover the subscription block...</li>
</ol>

<p>any advice or ideas will be very helpful</p>
","277796","","","","","2018-10-08 17:52:33","Rxjs marble testing","<testing><rxjs><rxjs5><marble>","1","0","1","","","CC BY-SA 3.0"
"48879805","1","48926441","","2018-02-20 07:22:08","","-1","1469","<p>I am trying to implement or operator with rxjs. is Race function is for OR operator. 
code exmaple:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export function saveComment(action$) {
   return race(
            action$.ofType(COMMENT.SAVE),
            action$.ofType(COMMENT.DELETE)
         )
       .map((action) =&gt; action.payload)
       .flatMap((data)=&gt; commentService.saveComment(data.leadId, data.comment))
       .map((resp)=&gt; SaveCommentSucceed(resp.leadId, resp.comments))
       .do((res)=&gt;new Comments().injectComments(res.payload.leadId, res.payload.comments));
}</code></pre>
</div>
</div>
</p>
","8987378","","","","","2018-02-22 11:35:34","Rxjs OR operator","<redux><rxjs><reactive-programming><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"48880671","1","48880705","","2018-02-20 08:24:12","","29","9417","<p>There is existing subject that is in use:</p>

<pre><code>const fooSubject = new BehaviorSubject(null);
</code></pre>

<p>And there is another observable (another subject in this example):</p>

<pre><code>const barSubject = new Subject();
barSubject.subscribe(
  value =&gt; fooSubject.next(),
  err =&gt; fooSubject.error(err),
  () =&gt; fooSubject.complete()
);

barSubject.next('bar');
</code></pre>

<p>The code works but looks clumsy.</p>

<p>Is there a better way to pipe (in broad sense, not necessarily using <code>pipe</code> operator) <code>barSubject</code> observable to <code>fooSubject</code>?  It looks like an operation that could be handled by the library itself.</p>
","3731501","","","","","2021-11-03 19:14:20","Pipe RxJS observable to existing subject","<javascript><rxjs><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"48880705","2","","48880671","2018-02-20 08:26:28","","40","","<p>Since Subject is already an observer with methods <code>next()</code>, <code>error()</code> and <code>complete()</code> you can just subscribe it to any Observable:</p>

<pre><code>const fooSubject = new BehaviorSubject(null);

const barSubject = new Subject();
barSubject.subscribe(fooSubject);

barSubject.next('bar');
</code></pre>
","310726","","","","","2018-02-20 08:26:28","","","","3","","","","CC BY-SA 3.0"
"48881263","1","48881879","","2018-02-20 08:59:19","","1","387","<p>I want to refresh the token if user gets unauthorized error. I am trying to handle this in interceptors. Below is the code:</p>

<pre><code>intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
      return next.handle(req).do((event: HttpEvent&lt;any&gt;) =&gt; {
      if (event instanceof HttpResponse) {
      }
    }, (err: any) =&gt; {
      if (err instanceof HttpErrorResponse) {
        if (err.status === 401) {
          fn.refreshToken(req, next);

        }
      }
    });
  }
</code></pre>

<p>And I have function refreshToken where I am trying to call an API to refresh token:</p>

<pre><code>refreshToken(req, next) {
    const headers = new HttpHeaders()
        .set('Content-Type', 'application/x-www-form-urlencoded');

    const body = new HttpParams()
      .set('refresh_token', localStorage.getItem('refreshToken'));
     this._http.post('/refreshtoken',  body.toString(), {headers}).subscribe(
       (data) =&gt; {
         const header = `Bearer ${(&lt;any&gt;data).accessToken}`;
        const newRequest = req.clone({ headers: req.headers.set('Authorization',  header)});
        return next.handle(newRequest);

       }),
        (err) =&gt; {
          console.log(err);
        }

  }
</code></pre>

<p>But the problem with above code is that I am not able to call the cloned request. The request is triggered only is I call subscribe method to it. As shown below:</p>

<pre><code> return next.handle(newRequest).subscribe();
</code></pre>

<p>I want if token is expired, call the service to refresh the token and resend the original request which is failed. Moreover call the subscribe method of original request that is failed.</p>

<p>Please let me know if my approach is correct. </p>

<p>And if yes, then what I am missing here.</p>
","3733026","","310726","","2018-02-20 09:43:30","2018-02-20 09:43:30","Issue while refreshing access token in angular 5","<angular><rxjs><rxjs5><angular-http-interceptors><angular-httpclient>","1","0","","","","CC BY-SA 3.0"
"48881879","2","","48881263","2018-02-20 09:30:55","","1","","<p>The interceptor has to return an Observable and can call <code>next.handle(req)</code> itself so I think you could call <code>next.handle(req)</code> twice but even better and more ""Rx"" solution would be to use the <code>catch</code> operator and merge the original source Observable. Also you'll need change <code>refreshToken</code> to return an Observable and you'll probably want to store the new token with <code>do()</code>.</p>

<pre><code>refreshToken(...): Observable&lt;any&gt; {
  return this._http.post('/refreshtoken', ...)
    .do(/* save token here */);
}

intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
  return next.handle(req)
    .catch((err, source) =&gt; {
      if (err instanceof HttpErrorResponse &amp;&amp; err.status === 401) {
        return this.refreshToken(...)
          .concatMap(() =&gt; next.handle(req /* ... or updated req */ ));
          // or you could use .concatMap(() =&gt; source) to trigger the same request again
      }
      throw err;
    })
}
</code></pre>
","310726","","","","","2018-02-20 09:30:55","","","","1","","","","CC BY-SA 3.0"
"48888460","1","48888653","","2018-02-20 15:16:41","","1","198","<p>Before lettable operators, the code looked like this: </p>

<pre><code>get someData$(): Observable&lt;Data&gt; {
  return this.dataService.higherOrderDataStream
    .mergeAll()
    .map(...);
}
</code></pre>

<p>Refactoring to use <code>pipe</code>, I get a type error essentially saying <code>Observable&lt;Observable&lt;Data&gt;&gt;</code> is not assignable to type <code>Observable&lt;Data&gt;</code>:</p>

<pre><code>get someData$(): Observable&lt;Data&gt; {
  return this.dataService.higherOrderDataStream
    .pipe(
      mergeAll(),
      map(...)
    );
}
</code></pre>

<p>But the following works just fine (I assume one shouldn't mix lettable and chained operators):</p>

<pre><code>get someData$(): Observable&lt;Data&gt; {
  return this.dataService.higherOrderDataStream
    .mergeAll()
    .pipe(
      map(...)
    );
}
</code></pre>

<p>Is there a different <code>mergeAll</code> I should be using? I'm using the one from <code>rxjs/operators</code> where I was using <code>rxjs/add/operator/mergeAll</code> previously. I thought these two implementations would be equivalent. </p>

<p><strong>Is this a bug or am I using the new <code>mergeAll</code> incorrectly?</strong></p>
","5932590","","310726","","2018-03-15 15:39:01","2018-03-15 15:39:01","mergeAll not working the same as a lettable operator (rxjs 5.5+)?","<rxjs><rxjs5><rxjs-lettable-operators>","1","0","","","","CC BY-SA 3.0"
"48888653","2","","48888460","2018-02-20 15:25:46","","2","","<p>This is a known bug in RxJS 5.5 with <code>mergeAll</code> and <code>concatAll</code>. It'll be fixed in RxJS 6.</p>

<p>For more details see: <a href=""https://github.com/ReactiveX/rxjs/issues/2759"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2759</a></p>

<p>Fix was merged few days ago: <a href=""https://github.com/ReactiveX/rxjs/pull/3321"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/3321</a></p>

<p>For now it's better to use <code>mergeMap(o =&gt; o)</code> or <code>concatMap(o =&gt; o)</code> instead.</p>
","310726","","310726","","2018-03-15 15:38:04","2018-03-15 15:38:04","","","","2","","","","CC BY-SA 3.0"
"48892750","2","","48812163","2018-02-20 19:23:57","","2","","<p>This is actually a common mistake with RxJS, you're using <code>switchMap</code> when you should be using <code>concatMap</code> (or maybe <code>mergeMap</code>).</p>

<p><code>switchMap</code> is only really safe with non-sideeffectful read-only requests/messages. If you're' trying to update record over the network, and you care about the order in which it's done and results are processed, you want to use <code>concatMap</code>. If you don't care about the ordering of results, you should use <code>mergeMap</code>.</p>

<ul>
<li><code>switchMap</code> - will unsubscribe from any pending Observable when it gets a new value, thus dropping its responses.</li>
<li><code>mergeMap</code> - will start and run all Observables it creates immediately and to completion, without any care for the order in which results come back as they're merged in.</li>
<li><code>concatMap</code> - only run one Observable at a time, in order, and drop nothing.</li>
</ul>

<pre class=""lang-js prettyprint-override""><code>merge(this.filterChange.debounceTime(400), this.socketUpdates)
    .startWith(this.filterComponent.initialValue);
    .concatMap((data) =&gt; this.process(data))
    .share();
</code></pre>
","135786","","","","","2018-02-20 19:23:57","","","","0","","","","CC BY-SA 3.0"
"48914661","2","","48143275","2018-02-21 20:13:49","","0","","<p>I monkey patched Chrome Messaging API with NgZone to update the view when app gets the response back from background page via <code>chrome.runtime.sendMessage</code> OR <code>chrome.runtime.onMessage</code>.<br>
Here is the service I used in my chrome extension.  </p>

<pre><code>import { Injectable, NgZone } from ""@angular/core"";
import { Subject } from ""rxjs/Subject"";
import { Observable } from ""rxjs/Observable"";

/*
NgZone monkey patched chrome messaging service.
*/
@Injectable()
export class ChromeMsgSrv {

   constructor(private _ngZone: NgZone) { }

   public send(msg: any, cb: (resp: any) =&gt; any) {
      chrome.runtime.sendMessage(msg, (resp: any) =&gt; {
         this._ngZone.run(() =&gt; cb(resp))
      })
   }

   public onMsg(cb: (msg: any) =&gt; any) {
      chrome.runtime.onMessage.addListener((msg: any) =&gt; {
         this._ngZone.run(() =&gt; cb(msg))
      })
   }

}
</code></pre>

<p>@Olegzandr, I got here on this thread from <code>DevKit.life</code>. I wanted to contact you for the solution to this problem but couldn't found any contact-us page on your website (assuming Devkit.life is yours). Also, the backlink to this post is in a plain text and not an anchor or clickable element. Hopefully, you would correct these issue present on your website.  </p>
","4850220","","","","","2018-02-21 20:13:49","","","","0","","","","CC BY-SA 3.0"
"48926441","2","","48879805","2018-02-22 11:35:34","","1","","<p>It's a little difficult to tell based on the question, but it <em>looks</em> like you are trying to emit values from each observable and continue receiving emissions, with no preference for the order either emissions occur? </p>

<p>I suggest looking at the <a href=""https://www.learnrxjs.io/operators/combination/merge.html"" rel=""nofollow noreferrer"">merge</a> operator. It will act similarly to logical OR, emitting whenever one OR the other observables passed to it emits.</p>

<p><a href=""https://www.learnrxjs.io/operators/combination/race.html"" rel=""nofollow noreferrer"">Race</a> will emit <strong>only the first</strong> emission it receives from the observables it was passed, and then it will complete.</p>

<p>If you want to keep listening for emitted values and don't care about the order, use merge. The code would look similar to this:</p>

<pre><code>export function saveComment(action$) {
    return Observable
        .merge(
            action$.ofType(COMMENT.SAVE),
            action$.ofType(COMMENT.DELETE)
        )
        .map((action) =&gt; action.payload)
        .flatMap((data) =&gt; commentService.saveComment(data.leadId, data.comment))
        .map((resp) =&gt; SaveCommentSucceed(resp.leadId, resp.comments))
        .do((res) =&gt; new Comments().injectComments(res.payload.leadId, res.payload.comments));
}
</code></pre>

<p>If you are using a version of Rxjs (>= 5.5) that contains <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""nofollow noreferrer"">pipeable operators</a>, the code would look like this:</p>

<pre><code>export function saveComment(action$) {
    return merge(
            action$.ofType(COMMENT.SAVE),
            action$.ofType(COMMENT.DELETE)
        )
        .pipe(
            map((action) =&gt; action.payload),
            flatMap((data) =&gt; commentService.saveComment(data.leadId, data.comment)),
            map((resp) =&gt; SaveCommentSucceed(resp.leadId, resp.comments)),
            tap((res) =&gt; new Comments().injectComments(res.payload.leadId, res.payload.comments))
        );
}
</code></pre>

<p>If you would like to <strong>stop</strong> listening after one of the observables emits, keep using race.</p>

<p>You can find out more about Rxjs Observables and Operators a <a href=""https://www.learnrxjs.io/operators/"" rel=""nofollow noreferrer"">learn-rxjs</a>.</p>
","5626385","","","","","2018-02-22 11:35:34","","","","0","","","","CC BY-SA 3.0"
"48928351","1","","","2018-02-22 13:13:54","","1","292","<p>I'm  trying to use Rx.js to handle the flow of Chrome extension webrequest API.</p>

<p>Each webrequest addListener() call takes a mandatory callback function as the first parameter. This sends request objects to the function. However, the callback can return a <a href=""https://developer.chrome.com/extensions/webRequest#type-BlockingResponse"" rel=""nofollow noreferrer"">webRequest.BlockingResponse</a> that determines the further life cycle of the request.</p>

<p>I'm struggling to handle the blocking response as part of the observable.</p>

<p>This code works well for examining all image requests, for example</p>

<pre><code>onBeforeRequestHandler = function() {

        var filteredURLs = [""http://*/*"", ""https://*/*""]; 
        var resourceTypes = [""image""]; 
        var filter = { urls: filteredURLs, types: resourceTypes };
        var options = [""blocking""];

        return Rx.Observable.create(observer =&gt; {
            var listener = chrome.webRequest.onBeforeRequest.addListener(
                function requestHandler(obj) {
                    observer.next(obj);
                },
                filter, options);
            return unsubscribe =&gt; {
                chrome.webRequest.onBeforeRequest.removeListener(listener);
            };
        });

};
</code></pre>

<p>I can then use all the Rx.js operators to manipulate the requests by doing this:</p>

<pre><code>var source = onBeforeRequestHandler();
source.subscribe();
</code></pre>

<p>etc.</p>

<p>However, if during the course of working the images, I wish to cancel the request, I somehow need to return a blocking response object, like this {cancel:true} to the observable that is wrapping the chrome.webRequest.onBeforeRequest.addListener callback function.</p>

<p>At the moment I have no clue how to do this.</p>

<p>Any help much appreciated.</p>
","5225435","","5225435","","2018-02-22 17:44:30","2018-02-22 17:44:30","Rx.js, handling Chrome Extension webrequest API callback functions","<google-chrome-extension><rxjs><observer-pattern><rxjs5><chrome-webrequest>","0","1","","","","CC BY-SA 3.0"
"48938426","1","","","2018-02-22 22:42:11","","6","1536","<p>I have a scenario where I need to sequence two @Ngrx actions in my Angular application.</p>

<p>The first action updates the state with some data, and the second action uses that data to trigger a server call. I am using an Effect to sequence the two actions and trigger the second action only after the first one has completed.</p>

<p>To ensure the second action includes the recently updated data from the state, I inject the store into my effect and use a selector function to retrieve the data and include it as the payload for the second action.</p>

<p>This works. </p>

<p><strong>My Question</strong></p>

<p>However, I believe that since the <code>this.actions$</code> is already an observable stream, I should be able to simply transform each event on that stream and convert that into a different action.</p>

<p>A rough marble diagram of what I have in mind:
<img src=""https://i.stack.imgur.com/ufqJD.png"" alt=""rough idea""></p>

<p>I am using the <code>withLatestFrom</code> operator to combine the action stream with the data from the state.</p>

<pre><code>  @Effect()
  lazyEffect1$ = this.actions$.ofType(LazyActions.TEST_ACTION_SEQUENCE)
     .withLatestFrom(this.filterId$, (x, y) =&gt; {
       return new LazyActionDone(y.number);
     });
</code></pre>

<p>But this code gives me an error:</p>

<p><strong><code>TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</code></strong></p>

<p>I have been able to get this to work using a slightly different construct, which is also included in the code below.</p>

<p>But I would like to understand why the <code>lazyEffect1</code> is not working. Where is my understanding failing me?</p>

<p><strong>The Code</strong></p>

<p>The NgRx Reducer:</p>

<pre><code>// reducers.ts
export function lazyReducer(
  state: any = {},
  action: LazyAction | LazyActionDone
) {

  switch (action.type) {
    case LazyActions.TEST_ACTION_SEQUENCE: {
      console.info('Action Received in Reducer: ', action.type);
      return {
        ...state,
        number: action.payload
      };
    }

    case LazyActions.TEST_ACTION_SEQUENCE_DONE: {
      console.info('Done Received in Reducer: ', action.type);
      return {
        ...state,
        retrieved: action.payload,
        done: true
      };
    }

    default: {
      return state;
    }
  }
}
</code></pre>

<p>The NgRx Effects:</p>

<pre><code>// effects.ts
@Injectable()
export class LazyEffects {
  private filterId$: Observable&lt;any&gt;;

  constructor(
    private actions$: Actions,
    private store: Store&lt;any&gt;
  ) {
    this.filterId$ = this.store.select(getLazyState);
  }

  // THIS DOES NOT WORK
  @Effect()
  lazyEffect1$ = this.actions$.ofType(LazyActions.TEST_ACTION_SEQUENCE)
     .withLatestFrom(this.filterId$, (x, y) =&gt; {
       // console.info(x, y);
       return new LazyActionDone(y.number);
     });

  // THIS WORKS
  @Effect()
  lazyEffect2$ = this.actions$.ofType(LazyActions.TEST_ACTION_SEQUENCE)
    .switchMap((action) =&gt; {
      console.info('Action Received in Effects: ', action.type);
      return of(action).withLatestFrom(this.filterId$, (x, y) =&gt; new LazyActionDone(y.number));
    });
}
</code></pre>
","8400917","","8400917","","2018-02-22 23:13:43","2019-02-17 15:00:04","@ngrx/effects gives TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable","<angular><observable><rxjs5><ngrx>","1","5","2","","","CC BY-SA 3.0"
"48949640","1","","","2018-02-23 14:04:44","","0","229","<p>I have an epic where I'm calling API and this API has authorization and token can expire. I want to try to refresh token and if refreshing was success retry action.</p>

<pre><code>action$ =&gt; 
    action$.ofType(actionTypes.GET_DATA)
        .mergeMap(action =&gt;
            ajax.getJSON('/api/endpoint', headers)
            .map(response =&gt; setData(response))
            .catch(error =&gt; Observable.concat(Observable.of({type: actionTypes.REFRESH_TOKEN}, Observable.of({type: actionTypes.GET_DATA}))
        ));
</code></pre>

<p>I've tried to concat streams but looks like it goes into an infinity loop.</p>
","2169572","","21926","","2018-02-23 14:24:37","2018-02-23 14:24:37","Retry action observable after catch","<rxjs><rxjs5><redux-observable>","0","3","","","","CC BY-SA 3.0"
"48973091","1","","","2018-02-25 11:51:35","","1","504","<p>In an Angular component I have a property of type <code>BehaviourSubject&lt;IController&gt;</code>:</p>

<pre><code>controllerData$ = new BehaviourSubject&lt;IController | null&gt;(null);

IController {
  users: IUser[];
  showDetails: boolean;
}
</code></pre>

<p>I need to iterate over the users array of type <code>IUser</code> and execute an intermediate transformation over the property data before returning the results as array.
Below the code I use:</p>

<ol>
<li>flatMap(): to flatten the IUsers[] items</li>
<li>map(): to iterate over the users and apply the intermediate processing</li>
<li>scan(): to pack the results into an array again</li>
</ol>

<p>Below my code:</p>

<pre><code>controllerData$                    
  .pipe(
        filter((input) =&gt; input !== null),
        flatMap((p) =&gt; {
            return p.users;
        }),
        map((m: IUser) =&gt; {
            const data = {m,
                    date: this.getWeekDay(m.occurrence),
                    nextOccurrence: this.service.getNextDate(m.frequency, m.occurrence),
                };
            return data;
         }),
        scan((acc: any, cur) =&gt; [...acc, cur], [])
        )
</code></pre>

<p>When the component loads the first time with two IUser items, everything works well. However when I add a new user to the array, the scan method copies also the previous array values, that is, having two initial items and adding a new one, I get 5 items in the array (the first two twice and the new one) instead of just three elements.</p>

<p>As a workaround I achieved it with the solution below, but <strong>I was wondering whether I can skip the <code>foreach</code> loop and obtain everything with just Rxjs operators</strong>:</p>

<pre><code>.pipe(
        filter((input) =&gt; input !== null),
        map((m) =&gt; {
            const results: any[] = [];
            m.users.forEach((ctlr: IUser) =&gt; {
                results.push({
                    user: ctlr.user,
                    date: this.getWeekDay(ctlr.occurrence),
                    nextOccurrence: this.service.getNextDateOccurrence(ctlr.frequency, ctlr.occurrence),
                });
            });
            return results;
         }),
</code></pre>
","706293","","","","","2018-02-25 11:51:35","Rxjs Scan method copies content of array property of Observable when new items added","<arrays><angular><observable><rxjs5>","0","2","","","","CC BY-SA 3.0"
"48974573","1","","","2018-02-25 14:29:09","","4","450","<p>I have a question why is this not writing to console the numbers 2,4,6? what is the explanation?</p>

<pre><code>Observable.range(1, 6)
  .groupBy(n =&gt; n % 2 === 0)
  .concatMap(obs =&gt; obs)
  .subscribe((n) =&gt; console.log(n), null, () =&gt; console.log('complete concatMap'))

// this is the output
1 -
3 -
5 -
complete concatMap
</code></pre>
","6008212","","310726","","2018-02-25 14:47:53","2018-11-28 12:45:49","why concatMap is not subscribing to all groupBy Observables rxjs?","<rxjs><rxjs5>","2","0","0","","","CC BY-SA 3.0"
"48985793","1","48985870","","2018-02-26 10:02:50","","0","2612","<p>Scenario -  The page needs to load data asynchronous from an external source and show the loading image based upon the isLoading property. 
Using an EventEmitter to manually trigger data refresh with a button, but in demo just subscribing to retrieve data (for simplicity). 
Pipe is used to retrieve data and to set isLoading to false or true. </p>

<pre><code>import { Component, EventEmitter } from '@angular/core';

import { Observable } from 'rxjs/Observable';
import { merge } from 'rxjs/observable/merge';
import { switchMap } from 'rxjs/operators/switchMap';
import { startWith } from 'rxjs/operators/startWith';
import { delay } from 'rxjs/operators/delay';
import { tap } from 'rxjs/operators/tap';
import { map } from 'rxjs/operators/map';
import { of as observableOf } from 'rxjs/observable/of';

@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: [ './app.component.css' ]
})
export class AppComponent  {
  tableRefreshEmitter = new EventEmitter&lt;any&gt;(true);
  isLoading = false;
  data: Observable&lt;{}&gt;;

  constructor() {
    this.data = merge(this.tableRefreshEmitter)
    .pipe(
      startWith({}),
      tap(() =&gt; {
        this.isLoading = true;
      }),
      switchMap(() =&gt; {
        // retrieve observable from http service example
        return observableOf({});
      },
      map(data =&gt; {
        this.isLoading = false;
        return data;
      })      
    ));

    this.data.subscribe(d =&gt; console.log(d));
  }
}
</code></pre>

<p>Code produces a error:
<a href=""https://i.stack.imgur.com/zgQAo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zgQAo.png"" alt=""enter image description here""></a></p>

<p>Currently stuck on finding the culprit and any help would be appreciated on how to resolve the error.</p>

<p>Working example on <a href=""https://stackblitz.com/edit/angular-rxjs-lift-missing"" rel=""nofollow noreferrer"">stackblitz</a></p>
","2872801","","","","","2018-02-26 10:07:26","Rxjs map operator used after switchMap operator in a pipe can't find lift() function","<angular><rxjs><angular5><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48985870","2","","48985793","2018-02-26 10:07:26","","2","","<p>The problem is in parenthesis. You have:</p>

<pre><code>switchMap(() =&gt; {
    // retrieve observable from http service example
    return observableOf({});
},
map(data =&gt; {
    this.isLoading = false;
    return data;
})
</code></pre>

<p>But this way you're passing <code>map</code> as second parameter to <code>switchMap</code>.</p>

<p>You probably want to have this instead:</p>

<pre><code>switchMap(() =&gt; {
    // retrieve observable from http service example
    return observableOf({});
}),
map(data =&gt; {
    this.isLoading = false;
    return data;
})   
</code></pre>

<p>Your updated demo prints ""loaded"": <a href=""https://stackblitz.com/edit/angular-rxjs-lift-missing-ypue7b?file=app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-rxjs-lift-missing-ypue7b?file=app/app.component.ts</a></p>

<p>Btw you can use <code>tap</code> instead of <code>map</code> if you just want to perform some side effects and don't want to modify the data:</p>

<pre><code>tap(() =&gt; this.isLoading = false)  
</code></pre>
","310726","","","","","2018-02-26 10:07:26","","","","1","","","","CC BY-SA 3.0"
"48988937","1","","","2018-02-26 12:50:37","","0","34","<p><code>var promise = http.get().toPromise();</code> gives a promise which executes once.</p>

<p>So no matter how much times <code>promise.then()</code> is called the http request is done only once.</p>

<p>How can I achieve the same with an observable?: <code>var observable = http.get().???</code> so that <code>obversable.subscribe()</code> only performs the http request one time?</p>
","2174621","","310726","","2018-02-26 12:57:12","2018-02-26 13:03:34","I would like to have an observable behaving like a promise","<rxjs><angular5><rxjs5><angular4-httpclient>","2","2","","","","CC BY-SA 3.0"
"48992126","1","48994333","","2018-02-26 15:46:57","","1","96","<p>I am working on fetching large amount of data Using rxjs/Observable by ajax. The server ouputs the data in pages. I am trying to make recursive ajax call with incremented page numbers. At present my code works when there is no paging. But 
 i am not able to make the paging work. </p>

<p>I created a <a href=""https://plnkr.co/edit/DUBZ4ue7pTOJYAEshPGv?p=info"" rel=""nofollow noreferrer"">plunker</a> with my use case with mock data and service to recreate the scenarios.</p>

<p>Would appreciate any help or direction. thanks</p>

<pre><code>export class App implements OnInit {        
    //mock db
    db:{[Id:string]:{data:number[],links:{next:number}}};

    uiData: number[];

    constructor() {
        this.name = `Angular! v${VERSION.full}`;

       //populate mock db with some data
       this.db = {
           '1_1': {data: [1,2,3,4,5], links: {next: null}},
           '2_1': {data: [1,2,3,4,5], links: {next: 2}},
           '2_2': {data: [6,7,8,9,10], links: {next: 3}},
           '2_3': {data: [11,12,13,14], links: {next: null}}
       };
    }

    /**
     * Mock db layer with API
     */
    private queryMasterData(key: string, page: number=1) {
       return Observable.of(this.db[`${key}_${page}`]);
    }

    /** Will be a angular service layer */
    private getPaged(key: string, page: number) {
        return this.queryMasterData(key, page).map(response =&gt; {
            if (response &amp;&amp; response.links &amp;&amp; response.links.next) {
                //? What Observable method to call? 
                return Observable.concat(Observable.of(response.data), 
                       this.getPaged(key, response.links.next).map(data =&gt; data));
            }

            if(!!response) {
                return response.data;
            }

            return [];
         });
     }

     /** Will be a angular service layer. UI can onlu call this */
     public getAll(key: string) {
         return this.getPaged(key, 1);
     }

     /** This is a component layer call */
     populateUI(key:string) {
         this.getAll(key).subscribe(data=&gt;{
         console.log('populateUI', data);
         this.uiData = data;
     });
  }

  ngOnInit() {

  }  
}
</code></pre>
","209609","","","","","2018-02-26 17:55:01","Which rxjs/Observable function to use for merging a recursive Observable paged data as a single stream or array","<observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"48994333","2","","48992126","2018-02-26 17:55:01","","1","","<p>Multiple ways to solve this, but the most important part is remembering to keep the dual responses you are dealing with the same.
Solution that works with your plunker:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>private getPaged(key: string, page: number) {
  return this.queryMasterData(key, page).flatMap(response =&gt; {
    if (response &amp;&amp; response.links &amp;&amp; response.links.next) {
        return Observable.forkJoin(Observable.of(response.data), this.getPaged(key, response.links.next).map(data =&gt; data)).map(x =&gt; {
          let combined = x[0].concat(x[1]);
          return combined
      });
    }                    
  
    if(!!response) {
      return Observable.of(response.data);
    }     
    
    return [];
  });
}</code></pre>
</div>
</div>
</p>
","2991956","","","","","2018-02-26 17:55:01","","","","1","","","","CC BY-SA 3.0"
"48997609","1","","","2018-02-26 21:44:45","","-2","416","<p>I am making a couple of similar http calls in my angular 5 application. I also need to apply similar data transformation logic and add the results to an array to display it on the page.</p>

<p>The 2nd call is not mandatory and is conditional.</p>

<p>On http subscribe, am doing the data transformation and pushing it to an array. I tried doing array concat to add the results from the 2nd call, but am not getting any results on the page.</p>

<p>What's the best way to approach this?</p>

<pre><code>if(oneReq) {
     this.http.get(url).subscribe ((message:       any[]) =&gt; {
     results.push({});
     }
   return results;

} else {
    forkJoin([this.http.get(url),        this.http.get(url)]) . subscribe ((message:    any[]) =&gt; {
     results.push({});
 }
  return results;
  }
</code></pre>
","1102835","","1102835","","2018-03-01 15:30:59","2018-03-01 15:30:59","Multiple http calls with data transformation using angular 5","<typescript><http><angular5><rxjs5>","2","3","","","","CC BY-SA 3.0"
"49009514","1","","","2018-02-27 13:09:48","","2","673","<p>I'm using <code>RxJS 5.5</code> and I'm importing operators like:</p>

<pre><code>import { mergeMap } from 'rxjs/operators';
import { fromPromise } from 'rxjs/observable/fromPromise';
</code></pre>

<p>Since I upgraded webpack 3 -> 4, I see that whole <code>rxjs</code> package is imported:</p>

<p><a href=""https://i.stack.imgur.com/tyk28.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tyk28.png"" alt=""enter image description here""></a></p>

<p>Seems like aliases configuration in webpack no longer work:</p>

<pre><code>const rxPaths = require('rxjs/_esm5/path-mapping');
resolve: {
  alias: rxPaths(),
  extensions: ['.js', '.jsx'],
},
</code></pre>
","4443323","","","","","2018-02-27 13:09:48","RxJs 5 - TreeShaking with webpack 4","<webpack><rxjs><rxjs5><webpack-4>","0","1","1","","","CC BY-SA 3.0"
"49020534","1","","","2018-02-28 01:16:54","","0","122","<p>I have a master list of array of objects and then two other list of selections represented also by arrays. I have these as 3 streams$.</p>

<pre><code>master$
filter1$
filter2$
</code></pre>

<p>On the UI, 
master$ is is bound to a datatable using the async pipe in angular.
filter1$ and filter2$ are bound to UI dropdowns as filter choices.</p>

<p>At any point the filter1$ and filter$ can change depending on what the user selects. I feel there has to be a way to combine the 3 streams together and apply both the filters if required. How can I do this in RxJs ? Can you show me an example. Can I achieve a simple, readable code using combineLatest, pipe and map ?</p>

<p><strong>Update:</strong></p>

<p>Below is my current solution, pretty sure there is a better way to compose this:</p>

<pre><code>combineLatest(
  master$.shareReplay(1),
  filter1$.shareReplay(1),
  filter2$.shareReplay(1)
)
  .map(([master, filter1, filter2]) =&gt; {
    let filtered = master;
    if (filter1.length &gt; 0) {
      filtered = [];
      filtered = master.filter(each =&gt; filter2.indexOf(each.organizationId) !== -1);
    }
    if (filter1.length &gt; 0) {
      master = filtered;
      filtered = [];
      filtered = master.filter(each =&gt; filter2.indexOf(each.organizationId) !== -1);
    }
    return filtered;
  })
  .subscribe(final =&gt; {
    this.list = final;
  });
</code></pre>

<p>}</p>
","8322270","","8322270","","2018-02-28 23:18:18","2018-02-28 23:44:27","RxJs Streams - Multiple Stream producing single master stream","<typescript><angular5><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49035900","1","","","2018-02-28 18:04:14","","0","41","<p>I've made this simple WebApp that ask for an Array to a server using HttpClient,</p>

<p>Here is the service I used:</p>

<pre><code>      /** Day Configuration **/
  getDayConfiguration(day: number | string): Observable&lt;DayConfiguration[]&gt; {

    return this.http.get&lt;DayConfiguration[]&gt;(this.dayConfigurationUrl+'?idweekDay='+day)
      .do(data =&gt; console.log(data)) // eyeball results in the console
      .catch(this.handleError);

  }
</code></pre>

<p>this service is injected in a component which use it in ngOnInit()</p>

<pre><code>  private daySettings:DayConfiguration[];

     ngOnInit() {

        this._route.paramMap.switchMap((param) =&gt;{

          return this._apiIwuService.getDayConfiguration(param.get('day'))

        }).subscribe(dayConf=&gt;{

          this.daySettings=dayConf;

        });

      }
</code></pre>

<p>then I use it in the View with *ngFor</p>

<pre><code>  &lt;li  *ngFor=""let daySetting of daySettings let i=index""&gt;
</code></pre>

<p>this way it is easy to remove an item from the list showed to the user, ny simply removing the Item (daySettings) form the Array</p>

<pre><code>delete(_daySetting: DayConfiguration, index: number){

    this._apiIwuService.deleteDayConfiguration(_daySetting.id)
    .subscribe(()=&gt;{

      this.daySettings.splice(index, 1);

    })

  }
</code></pre>

<p>if I do the same whitout ""transfoming"" the Observable into the array how can I delete the elment form the Observable? Is this the correct way to handle this kind of situation?</p>
","8284340","","3001761","","2018-02-28 18:05:34","2018-02-28 18:05:34","Observable or Array for list in Angular view","<angular><rxjs><observable><rxjs5>","0","2","","","","CC BY-SA 3.0"
"49036092","1","","","2018-02-28 18:18:59","","1","269","<p>How can I emit a fixed value every <code>x</code> seconds <strong><em>after</em></strong> any <code>y</code> second-long period of inactivity on a stream?</p>

<hr>

<p>In my app, I've got a RxJs wrapper around a WebSocket. This receives messages from both my client app and my API. There's a NGINX proxy sitting between the two that is configured to kill idle connections after 60 seconds. I already have retry logic implemented in my client code to try and re-establish a websocket connection if the connection drops, and that's working great. But it does mean that every 60 seconds I see a ""Reconnecting..."" message. I'd like to ""ping"" the server during periods of inactivity (ie, no messages sent from user actions or by the API) on an interval just shy of the NGINX timeout value. This should result in only seeing ""Reconnecting..."" when we have a legitimate connection failure.</p>

<p>Here's the observable code I have thus far:</p>

<pre><code>const openSubject = new Subject()
const closeSubject = new Subject()

const socketStream = Observable.webSocket({
  url: socketUrl,
  openObserver: openSubject,
  closeObserver: closeSubject
})

socketStream
  .retryWhen(errors =&gt;
    Observable.range(1, 15)
      .zip(errors, attempts =&gt; attempts)
      .mergeMap(attempts =&gt; {
        return Observable.timer(attempts * 1000)
      })
  )
  .merge(openSubject.mapTo(actions.socket.opened()))   
  .merge(closeSubject.mapTo(actions.socket.retrying()))
  .subscribe(dispatch, handleSocketError, handleSocketDone)

// messages from client are sent via
socketStream.next(/* ... */)
</code></pre>

<p>Ideally, if messages are being emitted on <code>socketStream</code> within the inactivity threshold, I should <strong><em>not</em></strong> see any emissions for my ping/keep-alive observable.</p>

<p>How can I accomplish this? I've tried various permutations of <code>switchMap</code>, <code>map().switch()</code>, and <code>race</code> and nothing I've come up with so far seems to work.</p>
","32154","","","","","2018-02-28 18:18:59","RxJs start an interval after a period of inactivity","<websocket><rxjs><rxjs5>","0","0","","","","CC BY-SA 3.0"
"49041772","1","49076820","","2018-03-01 02:37:14","","1","109","<p>I'm currently using angular 5, but this is more just a general RxJs question. I want to be able to respond to a controller's request for an api's data with the data, but then also push changes anytime the value becomes stale. I'm currently trying to achieve this using multicasting, but that doesn't seem right since only the initial value is received. </p>

<pre><code>export class EditorService {
  private getSubject = new Subject&lt;null&gt;();

  onLanguageChange() {
    // currentLanguage is a model so will be updated by angular
    this.getSubject.next();
  }

  get(): Observable&lt;DeltaStatic&gt; {
    const get = () =&gt; {
      return this.http.get&lt;BackEndResponse&lt;MasterBlob&lt;DeltaStatic|string&gt;&gt;&gt;(
        `${backendEndPoint}/get-all`,
      ).pipe(
        map(blob =&gt; blob.data[this.currentLanguage][this.currentKey].quillBlob)
      );
    };

    return get().pipe(
      multicast(this.getSubject),
      refCount(),
      switchMap(get),
    );
  }
}
</code></pre>

<p>The other option, which feels slightly more idiomatic, is to just use a subject with switchMap, but I don't want to have to trigger next from the controller to get the first value after I subscribe:</p>

<pre><code>export class EditorService {
  private getSubject = new Subject&lt;null&gt;();

  onLanguageChange() {
    // currentLanguage is a model so will be updated by angular
    this.getSubject.next();
  }

  get(): Observable&lt;DeltaStatic&gt; {
    const get = () =&gt; {
      return this.http.get&lt;BackEndResponse&lt;MasterBlob&lt;DeltaStatic|string&gt;&gt;&gt;(
        `${backendEndPoint}/get-all`,
      ).pipe(
        map(blob =&gt; blob.data[this.currentLanguage][this.currentKey].quillBlob)
      );
    };

    return this.getSubject.pipe(
      switchMap(get),
    );
  }
}

@Component({
  selector: 'editor',
  templateUrl: './editor.component.html',
  styleUrls: ['./editor.component.scss']
})
export class EditorComponent implements AfterViewInit {
  constructor(private editorService: EditorService) {}

  ngAfterViewInit() {
      this.editorService.get().subscribe(data =&gt; {...});
    this.editorService.getSubject.next();
  }
}
</code></pre>

<p>Finally I toyed with my go to solution of using a ReplaySubject, but that requires me to subscribe to the initial Observable in the service which goes against the best practice of waiting to make the call until the controller needs something and calls subscribe. I also feel like I always just resort to ReplaySubject since it is the most hackable, but there has to be a better way to achieve this. </p>
","3502272","","","","","2018-03-05 16:24:40","In Angular using Observable to respond to an api request and then push any changes to the controller","<angular><rxjs><observable><rxjs5>","1","4","","","","CC BY-SA 3.0"
"49052292","1","49056298","","2018-03-01 14:50:41","","1","233","<p>I have a Subject with publishReplay and refcount, so it effectively never completes. The output of the refcount is an Observable array of objects. I would like to decompose the Observable object array into emitted elements, transform as needed, and then merge them back into an array, but since the source is non-completing, the array boundary is 'lost' in the asynchronous nature.</p>

<p>As an example, I use mergeMap and scan to accumulate the data. However, as expected, it continually accumulates, so the resulting array is the entire history of the stream. The initial value of the scan is only initialized at the beginning of the stream. I can't use toArray, because the Observable never terminates.</p>

<p>I have a lot of experience in asynchronous hardware design. The hardware analogy to this asynchronous chain is using a latch. I'm not sure what the conceptual equivalent is in RxJS. I would assume taking the emitted array output from refcount and applying it to Observable.from(theArrayOutput) would work, but I can't figure out how to insert it in the chain of streams.</p>

<pre><code>import {Component, OnInit} from '@angular/core';
import {Observable} from 'rxjs/Observable';
import {Subject} from 'rxjs/Subject';

type IObjectsOperation = (types: Object[]) =&gt; Object[];

@Component({
    selector: 'app-events-test',
    templateUrl: './events-test.component.html',
    styleUrls: ['./events-test.component.css']
})

export class EventsTestComponent implements OnInit {
    public objects: Observable&lt;Object[]&gt;;
    public scanned: Observable&lt;any&gt;;
    protected updates: Subject&lt;any&gt; = new Subject&lt;any&gt;();
    protected functionStream: Subject&lt;any&gt; = new Subject&lt;any&gt;();
    protected addStream: Subject&lt;Object&gt; = new Subject&lt;Object&gt;();
    private initialObjects: Object[] = [1];

    constructor() {
        this.objects = this.updates
            .scan((objects: Object[],
                   operation: IObjectsOperation) =&gt; {
                    return operation(objects);
                },
                this.initialObjects)
            .publishReplay(1)
            .refCount();
        this.functionStream
            .map(function (message: Object): IObjectsOperation {
                return (messages: Object[]) =&gt; {
                    return messages.concat(message);
                };
            })
            .subscribe(this.updates);
        this.addStream.subscribe(this.functionStream);
        this.scanned = this.objects
            .mergeMap(val =&gt; val)
            // some transformation that I want to have happen, in this case no-op
            .filter(() =&gt; {return true})
            // attempt to rebuild array, but items are accumulated
            .scan( (acc: Array&lt;any&gt;, x: Object) =&gt; { return acc.concat(x); }, [])

    }


transform(objects) {
    return Observable.from(objects)
        // this withLatestFrom suggestion didn't work
        // .withLatestFrom( this.functionStream, ( val, fn ) =&gt; fn( val ) )
        .filter(() =&gt; {
            return true
        })
        .toArray()
}


    start(): void {
        console.log('---------STARTING');
        this.objects.mergeMap(obj =&gt; this.transform(obj))
        .subscribe(
            obj =&gt; console.log('objects: ' + obj)
        );
        this.scanned.subscribe(
            {
                next: obj =&gt; {
                    console.log('scanned: ' + obj);
                },
                error: () =&gt; {
                },
                complete: () =&gt; console.log('COMPLETED')
            }
        );
        this.add(2);
        this.add(3);
    }
    add(object: Object): void {
        this.addStream.next(object);
    }
    ngOnInit() {
        this.start();
    }

}
</code></pre>

<p>The output is below, and expected.</p>

<pre><code>---------STARTING
events-test.component.ts:49 objects: 1,2
events-test.component.ts:52 scanned: 1
events-test.component.ts:52 scanned: 1,2
events-test.component.ts:49 objects: 1,2,3
events-test.component.ts:52 scanned: 1,2,1
events-test.component.ts:52 scanned: 1,2,1,2
events-test.component.ts:52 scanned: 1,2,1,2,3
</code></pre>

<p>What I would like to see is: </p>

<pre><code>---------STARTING
events-test.component.ts:49 objects: 1,2
events-test.component.ts:52 scanned: 1,2
events-test.component.ts:49 objects: 1,2,3
events-test.component.ts:52 scanned: 1,2,3
</code></pre>

<p>I have a few workarounds that I can use:</p>

<ol>
<li>Keep the data as an array throughout the stream</li>
<li>Convert the source non-completing observable to completing</li>
</ol>

<p>I would assume the solutions for this architecture are:</p>

<ol>
<li>There is some operation I can insert into the stream to take the array from objects Observable, and return an observable that completes</li>
<li>There is some external signal that needs to occur from the source Observable that indicates 'processing' and then the termination bounds the scan. This seems clumsy to me.</li>
</ol>

<p>I would assume there would be some equivalent in RxJS to a asynchronous hardware latch, so I'd like to keep the current architecture. Additionally, I think RxJS is really cool and want to close a gap in my knowledge in terms of time based handling of streams.</p>

<p>EDIT: A good answer from @xtianjohns indicated how to do an inner loop, but the subscription still does not complete. The suggested addition of withLatestFrom caused the transform function to break, in commenting out that line, the array is rendered, but the outer loop does not complete. If the line is present, the array is not rendered, and the loop does not complete.</p>
","733002","","733002","","2018-03-30 01:34:37","2018-03-30 01:34:37","Rebuilding non-completing Observable Array after decomposing with mergeMap and transforming","<rxjs><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"49053753","1","49104587","","2018-03-01 16:00:25","","0","994","<p>I am having unexpected behavior with Observable.of() and repeatWhen. I was wondering if this is correct behavior or not, and why?</p>

<pre><code>const value = 5;
let variable = 0;

const getValue = () =&gt; {
    variable = variable + 1;
    return value * variable;
}

function test () {
    Observable.of(getValue())
        .repeatWhen(obs =&gt; obs.delay(1000))
        .subscribe(value =&gt; console.log(value);
}
</code></pre>

<p>Expected: 5 10 15 20 ...</p>

<p>Result: 5 5 5 5 ...</p>

<p>Apparently, the value returned by Observable.of() is reused for each subsequent subscribe. How, why?</p>
","1047461","","","","","2018-03-13 15:05:38","RepeatWhen in combination Observable.of(x) has unexpected behavior","<rxjs5><reactive>","2","0","","","","CC BY-SA 3.0"
"49056298","2","","49052292","2018-03-01 18:23:49","","1","","<p>Your problem comes from using <code>mergeMap</code> followed by <code>scan</code>, and doing so on the ""outer"" stream, rather than transforming your list of objects and then emitting that list.</p>

<p>Another way: if what you want is a stream of arrays, then let's always keep it a stream of arrays.</p>

<pre><code>        /* Function that takes array and returns stream of transformed arrays */
        function transform( objects ) {
          return Observable.from( objects )
            /* We only need this because your transformation is wrapped in a stream. */
            .withLatestFrom( this.functionStream, ( val, fn ) =&gt; fn( val ) )
            // some transformation that I want to have happen, in this case no-op
            .filter(() =&gt; {return true});
            .toArray();
        }

        this.scanned = this.objects
          /* let's keep this as Observable&lt;Array&lt;YourObject&gt;&gt; */
          .mergeMap( transform );
          /* No need to ""rebuild"" array, this is now a stream of arrays */
</code></pre>

<p>Note how in this example, I ""transform"" the elements of the array inside <code>transform</code>, rather than trying to ""unwrap"" the array in the stream and then recompose.</p>

<p>Does this fit your use case?</p>

<p>EDIT: I made a mistake reading your functionStream signature, have corrected this.</p>
","7806537","","7806537","","2018-03-01 19:16:10","2018-03-01 19:16:10","","","","4","","","","CC BY-SA 3.0"
"49057449","1","","","2018-03-01 19:38:33","","1","39","<p>I am processing data from GDAX's websocket that emits the status of trades in real time (Source B).  In order to build a complete order book I need to get a current snapshot of the book through an API call (Source A).</p>

<p>First I process Source A which contains a sequence number, while I am processing this I am queueing events from Source B.  Once Source A is processed I emit a ""SYNCED"" status, when SYNCED is received I release all of the queued events from B as an array and discard any that are prior to the sequence number from Source A and then processes them.  At the point that the queued events are released any incoming events from B should be processed in real time.</p>

<p><a href=""https://i.stack.imgur.com/a1F2X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/a1F2X.png"" alt=""enter image description here""></a></p>

<p>Source B can drop an event at any point, and when that happens I reset the state to blank, call Source A and repeat the process.</p>

<p>Right now, I am trying to use the buffer in RXJS, but it just releases the events from before SYNCED is emitted, and then starts to buffer B until the event is called again.  This is different because I only want to queue events while the sync is in process and then once it is done, I want to process the backpressured events and then process the events as they come in.  I am not really sure how to accomplish this in terms of observables... Here is what I have so far:</p>

<pre><code>Observable
  .fromEvent(this.ws$, 'message')
  .map((m: any) =&gt; m.data)
  .map((s: string) =&gt; JSON.parse(s))
  .buffer(process$)
  .flatMap(_ =&gt; _)
  .filter((message: any) =&gt; message.sequence &gt; this.sequence)
  .subscribe((message: any) =&gt; {
    if (message.sequence !== this.sequence + 1) {
      throw new Error(""Out of sync"");
    }
    this.sequence = message.sequence;
    this.emit('message', message);
  }, (err: any) =&gt; {
    throw new Error(err);
  });
</code></pre>
","1804656","","","","","2018-03-01 19:38:33","RXJS5 Queue some stream until event then process normally","<node.js><rxjs><rxjs5>","0","0","","","","CC BY-SA 3.0"
"49058307","2","","48775806","2018-03-01 20:36:42","","1","","<p>It turned out that the culprit was the <code>ErrorHandlerService.handleError()</code> function. Previously it worked like this:</p>

<pre><code>public static handleError(error: any): Promise&lt;any&gt; {
    console.error('An error occurred', error);
    return Promise.reject(error.message || error);
}
</code></pre>

<p>Promises and Pipeable operators do not get along well, so I updated the code to this:</p>

<pre><code>public static handleError(error: any): ErrorObservable {
    console.error('An error occurred', error);
    return ErrorObservable.create(error.message || error);
}
</code></pre>

<p>However I only needed an additional adjustment:</p>

<pre><code>public static handleError(error: any): ErrorObservable {
    console.error('An error occurred', error);
    return ErrorObservable.create(error);
}
</code></pre>

<p>Don't know how I missed that until now.</p>
","1509100","","","","","2018-03-01 20:36:42","","","","0","","","","CC BY-SA 3.0"
"49074250","1","49074482","","2018-03-02 17:23:46","","2","860","<p>I have the following requirement:</p>

<ul>
<li>I have an array of data</li>
<li>For each item in the array I need to perform a call resulting in an Observable</li>
<li>I need to chain all these observables together </li>
<li>If one of the observables results in a false response I need to return false

<ul>
<li>further observables should not have to proceed</li>
</ul></li>
</ul>

<p>The context is a guard in Angular which uses canActivate() returning an Observable&lt;boolean&gt;</p>

<p>I want to avoid following construction in the guard (pseudo code):</p>

<pre><code>// the actions to check
var actions = ['x', 'y', 'z'];

canActivate() : Observable&lt;boolean&gt; {
    return this.performAction(actions[0]).subscribe(result =&gt; {
      if(result){
        this.performAction(actions[1]).subscribe(result2 =&gt; {
           if(result2){
               this.performAction(actions[2]).subscribe(result3 =&gt; {
                 ...
               };
           }
       });
   }
   //result = false;
 };
}
</code></pre>
","2174621","","310726","","2018-03-02 17:39:40","2018-03-02 18:01:30","create observables from an array of data and chain all these together","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49074482","2","","49074250","2018-03-02 17:39:13","","1","","<p>You can do it like this:</p>

<pre><code>import { Observable, Subject, ReplaySubject } from 'rxjs';

const actions = ['x', 'y', 'z'];

const performAction = (action): Observable&lt;boolean&gt; =&gt; {
  if (action === 'y') {
    return Observable.of(false);
  }
  return Observable.of(true);
}

const observable = Observable.from(actions)
  .concatMap(a =&gt; performAction(a))
  .multicast(new ReplaySubject(1),
    s =&gt; s.takeWhile(result =&gt; result !== false).concat(s.take(1))
  );

observable.subscribe(console.log);
</code></pre>

<p>See live demo (open console): <a href=""https://stackblitz.com/edit/rxjs5-hnzwtt?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs5-hnzwtt?file=index.ts</a></p>

<p>The most important part is the <code>multicast</code> operator that passes through everything until it receives <code>false</code>. Then this <code>false</code> value is the last one before completing the chain (thanks to <code>concat</code>).</p>

<p>The output is:</p>

<pre><code>true
false
</code></pre>
","310726","","310726","","2018-03-02 18:01:30","2018-03-02 18:01:30","","","","4","","","","CC BY-SA 3.0"
"49076820","2","","49041772","2018-03-02 20:25:07","","1","","<p>Here's a solution if you want to not share data between subscribers at all. It's mostly like the one you had, it just uses <code>startWith</code> to trigger the initial request immediately, avoiding the problem you mentioned:</p>

<pre class=""lang-js prettyprint-override""><code>export class EditorService {

  private languageChange$ = new Subject&lt;void&gt;();

  public onLanguageChange() {
    this.languageChange$.next();
  }

  public get(): Observable&lt;DeltaStatic&gt; {
    // By appending startWith(), which is short for startWith(undefined),
    // we ensure that we trigger the request once initially.
    return this.languageChange$
        .startWith(undefined)
        .switchMap(() =&gt; this.requestData());
  }

  private requestData() {
    return this.http.get&lt;BackEndResponse&lt;MasterBlob&lt;DeltaStatic|string&gt;&gt;&gt;(`${backendEndPoint}/get-all`)
      .pipe(
        map(blob =&gt; blob.data[this.currentLanguage][this.currentKey].quillBlob)
      );
  }

}
</code></pre>

<p>If you want the refreshed data to be shared across subscribers, you can probably do this, although I didn't test it:</p>

<pre class=""lang-js prettyprint-override""><code>export class EditorService {

  private refreshed$ = new Subject&lt;DeltaStatic&gt;();

  public onLanguageChange() {
    this.requestData().subscribe(data =&gt; this.refreshed$.next(data));
  }

  public get(): Observable&lt;DeltaStatic&gt; {
    // Trigger request immediately, then concat any future updates
    // to it.
    return this.requestData().concat(this.refreshed$);
  }

  private requestData() {
    return this.http.get&lt;BackEndResponse&lt;MasterBlob&lt;DeltaStatic|string&gt;&gt;&gt;(`${backendEndPoint}/get-all`)
      .pipe(
        map(blob =&gt; blob.data[this.currentLanguage][this.currentKey].quillBlob)
      );
  }

}
</code></pre>
","1675492","","1675492","","2018-03-05 16:24:40","2018-03-05 16:24:40","","","","4","","","","CC BY-SA 3.0"
"49100844","1","49733720","","2018-03-04 21:48:36","","3","1403","<p>I am trying to intercept a 401 response, send a refresh token request before trying request again (but with a different header). I have it working except <code>retryWhen</code> does not give me to modify the original request header. So I've been trying to use <code>catchError</code> instead but I cannot seem to execute the request again.</p>

<p>Here is my current <code>retryWhen</code>:</p>

<pre><code>import {Injectable} from '@angular/core';
import {
    HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpErrorResponse
}
    from '@angular/common/http';

import {Observable} from 'rxjs/Observable';
import {CustomerService} from ""../customer/customer.service"";
import * as ApplicationSettings from ""application-settings"";
import {retryWhen, map} from ""rxjs/operators"";
import {LoginResponse} from ""./LoginResponse"";

/**
 * This takes a request that requires an access_token and refreshes it on 401 errors.
 */
@Injectable()
export class RefreshTokenInterceptor implements HttpInterceptor {

    public constructor(private customer: CustomerService) {}

    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        return next.handle(req).pipe(
            retryWhen(errors =&gt; {
                return Observable.create(observer =&gt; {
                    errors.forEach((error: HttpErrorResponse) =&gt; {
                        if (error.status === 401) {
                            let refresh_token = ApplicationSettings.getString('refresh_token');

                            return this.customer.refreshToken(refresh_token).subscribe(
                                (response: LoginResponse) =&gt; {
                                    this.customer.setToken(response);

                                    let headers = req.headers.set('Authorization', `Bearer ${response.access_token}`);
                                    console.log(`Bearer ${response.access_token}`);
                                    let newReq = req.clone({headers: headers});
                                    observer.next(next.handle(newReq));
                                    observer.complete();
                                },
                                error2 =&gt; {
                                    observer.error();
                                }
                            );
                        } else {
                            observer.error();
                        }
                    });
                });
            })
        );
    }
}
</code></pre>

<p>If I swap out <code>retryWhen</code> with <code>catchError</code>:</p>

<pre><code>        catchError((err, caught) =&gt; {
            console.log('err: ' + JSON.stringify(err));

            if (err.status === 401) {
                console.log('401 !!!! REFRESH MEH!');
                let newReqOb: Observable&lt;HttpEvent&lt;any&gt;&gt; = Observable.create(observer =&gt; {
                    console.log('going to refresh token');
                    let refresh_token = ApplicationSettings.getString('refresh_token');

                    let refresh = this.customer.refreshToken(refresh_token);

                    refresh.subscribe((response: LoginResponse) =&gt; {
                        console.log('token refreshed!');
                        this.customer.setToken(response);


                        let access_token = ApplicationSettings.getString('access_token');
                        let headers = req.headers.set('Authorization', `Bearer ${access_token}`);

                        console.log(`Bearer ${access_token}`);

                        let newReq = req.clone({headers: headers});

                        observer.next(next.handle(newReq)); // &lt;-- HERE IT WONT FIRE
                        observer.complete();

                    });

                });

                return newReqOb;
            }

            return caught;
        })
</code></pre>

<p>The important part is I am returning <code>next.handle(newReq)</code> and it doesn't seem to fire the request. If I switch it to <code>next.handle(newReq).subscribe()</code>, the request will fire but no callbacks are triggered.</p>

<p>Here is the full example with <code>retryWhen</code>:</p>

<pre><code>import {Inject, Injectable} from '@angular/core';
import {
    HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpErrorResponse, HttpClient
}
    from '@angular/common/http';

import {Observable, ObservableInput} from 'rxjs/Observable';
import {CustomerService} from ""../customer/customer.service"";
import * as ApplicationSettings from ""application-settings"";
import {retryWhen, map, catchError} from ""rxjs/operators"";
import {LoginResponse} from ""./LoginResponse"";
import {APP_CONFIG, AppConfig} from ""../../app.config"";

/**
 * This takes a request that requires an access_token and refreshes it on 401 errors.
 */
@Injectable()
export class RefreshTokenInterceptor implements HttpInterceptor {

    public constructor(private customer: CustomerService, private http: HttpClient, @Inject(APP_CONFIG) private config: AppConfig) {}

    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        return next.handle(req).pipe(
            catchError((err, caught) =&gt; {
                console.log('err: ' + JSON.stringify(err));

                if (err.status === 401) {
                    console.log('401 !!!! REFRESH MEH!');
                    let newReqOb: Observable&lt;HttpEvent&lt;any&gt;&gt; = Observable.create(observer =&gt; {
                        console.log('going to refresh token');
                        let refresh_token = ApplicationSettings.getString('refresh_token');

                        let refresh = this.customer.refreshToken(refresh_token);

                        refresh.subscribe((response: LoginResponse) =&gt; {
                            console.log('token refreshed!');
                            this.customer.setToken(response);


                            let access_token = ApplicationSettings.getString('access_token');
                            let headers = req.headers.set('Authorization', `Bearer ${access_token}`);

                            console.log(`Bearer ${access_token}`);

                            let newReq = req.clone({headers: headers});

                            observer.next(next.handle(newReq));
                            observer.complete();

                        });

                    });

                    return newReqOb;
                }

                return caught;
            })
        );
    }
}
</code></pre>
","134617","","","","","2018-04-09 13:05:50","Angular 5.2 & RxJS 5.5 HttpInterceptor retryWhen, but update request?","<angular5><rxjs5><retrywhen>","1","2","1","","","CC BY-SA 3.0"
"49104587","2","","49053753","2018-03-05 06:24:21","","1","","<p>The problem is that <code>getValue()</code> is evaluated only once and immediately. That's got nothing to do with rxjs, it's just how Javascript works.  You need to evaluate it on each retry instead, which you can do by using <code>defer</code>:</p>

<pre><code>Observable.defer(() =&gt; Observable.of(getValue()))
  .repeatWhen(obs =&gt; obs.delay(1000))
  .subscribe(console.log);
</code></pre>
","1675492","","1047461","","2018-03-13 15:05:38","2018-03-13 15:05:38","","","","0","","","","CC BY-SA 3.0"
"49130956","1","49131460","","2018-03-06 12:32:54","","4","7603","<p>I am implementing autocomplete with data from database service:</p>

<pre><code>@Injectable()
export class SchoolService {
  constructor(private db: AngularFirestore) {
  }

  getSchools(): Observable&lt;School[]&gt; {
    return this.db.collection&lt;School&gt;('schools').valueChanges();
  }
}
</code></pre>

<p>In my component:</p>

<pre><code>export class SchoolComponent implements OnInit {
  formControl: FormControl = new FormControl();
  schools: Observable&lt;School[]&gt;;
  filteredSchools: Observable&lt;School[]&gt;;

  constructor(private schoolService: SchoolService) {
  }

  ngOnInit() {
    this.schools = this.schoolService.getSchools();

    //Below line gives error ""Type Observable&lt;Observable&lt;School[]&gt;&gt; is not assignable to type Observable&lt;School[]&gt;"".
    this.filteredSchools = this.formControl.valueChanges.pipe(
      startWith(''),
      map(name =&gt; this.filterSchools(name))
    );
  }

  filterSchools(name: string): Observable&lt;School[]&gt; {
    return this.schools.map(school =&gt; school.filter(s =&gt; s.name.toLowerCase().includes(name)));
  }
}
</code></pre>

<p>And my html:</p>

<pre><code>&lt;form&gt;
  &lt;mat-form-field&gt;
    &lt;input type=""text"" matInput placeholder=""Type Your School to Continue"" [matAutocomplete]=""auto""
           [formControl]=""formControl""&gt;
    &lt;mat-autocomplete #auto=""matAutocomplete""&gt;
      &lt;mat-option *ngFor=""let school of filteredSchools | async"" [value]=""school""&gt;
        &lt;span&gt;{{school.name}}&lt;/span&gt; |
        &lt;small&gt;{{school.city}}&lt;/small&gt;
      &lt;/mat-option&gt;
    &lt;/mat-autocomplete&gt;
  &lt;/mat-form-field&gt;
&lt;/form&gt;
</code></pre>

<p>The function in <code>ngOnInit</code> gives <code>Type Observable&lt;Observable&lt;School[]&gt;&gt; is not assignable to type Observable&lt;School[]&gt;</code> error. How can I fix this?</p>
","4130867","","310726","","2018-03-06 13:06:50","2018-03-06 13:19:05","Type Observable<Observable<any[]>> is not assignable to type Observable<any[]>","<angular><typescript><rxjs><rxjs5>","2","6","1","","","CC BY-SA 3.0"
"49131460","2","","49130956","2018-03-06 12:58:48","","12","","<p>The error says exactly what's wrong. You defined:</p>

<pre><code>filteredSchools: Observable&lt;School[]&gt;;
</code></pre>

<p>but later you create an Observable that emits (maps each value) results of <code>filterSchools(name: string): Observable&lt;School[]&gt;</code> which returns an Observable as well so at the end you have an Observable chain of <code>Observable&lt;Observable&lt;School[]&gt;&gt;</code>.</p>

<p>It actually looks like you just wanted to use <code>switchMap</code> (or <code>mergeMap</code> or <code>concatMap</code>) instead of <code>map</code>. <code>switchMap</code> will subscribe to the nested Observable and turn the chain into <code>Observable&lt;School[]&gt;</code>:</p>

<pre><code>this.filteredSchools = this.formControl.valueChanges.pipe(
  startWith(''),
  switchMap(name =&gt; this.filterSchools(name))
);
</code></pre>
","310726","","310726","","2018-03-06 13:19:05","2018-03-06 13:19:05","","","","2","","","","CC BY-SA 3.0"
"49131892","1","49132091","","2018-03-06 13:22:32","","1","1349","<p>After update of contact I will show a message and after 1500ms I will route to another page. I did it like this:</p>

<pre><code>onSubmit() {
    if (this.form.valid) {            
        this.contactService.updateContact(this.contact).subscribe(response =&gt; {
            this.contactUpdated = true;
                Observable.interval(1500)
                  .subscribe(i =&gt; { 
                    this.router.navigate(['/commit']); 
                 })
              });
            }
          }
</code></pre>

<p>This works only once, after I will navigate with mouse to another menu, I will be automatically routed back to the commit route.
Does anyone know what I'm doing wrong?</p>
","3318489","","310726","","2018-03-06 13:33:53","2018-03-06 13:33:53","Angular timeout before routing","<angular><rxjs><angular2-routing><rxjs5>","1","1","","","","CC BY-SA 3.0"
"49132091","2","","49131892","2018-03-06 13:33:20","","8","","<p>So the problem is that you want to redirect the user just once after 1500ms and not every 1500ms and even when the user is already on a different page.</p>

<p><code>Observable.interval</code> emits a value after every interval so you could use <code>take(1)</code> to complete the chain after a single emission:</p>

<pre><code>Observable.interval(1500)
  .take(1)
  .subscribe(i =&gt; { 
     this.router.navigate(['/commit']); 
  })
</code></pre>

<p>Or even easier you can use <code>Observable.timer(1500)</code> that emits just once (if you use only the first parameter):</p>

<pre><code>Observable.timer(1500)
  .subscribe(i =&gt; { 
     this.router.navigate(['/commit']); 
  })
</code></pre>
","310726","","","","","2018-03-06 13:33:20","","","","0","","","","CC BY-SA 3.0"
"49153567","1","49153841","","2018-03-07 13:51:22","","2","3484","<p>I have an autocomplete input which, as the user types, fetches data from multiple endpoints, such as:</p>

<pre><code>//service call to fetch data and return as single observable
getAutocompleteSuggestions() {
    const subs$ = [
        this.http.get(endpoint1),
        this.http.get(endpoint2),
        this.http.get(endpoint3)
    ];

    return Observable.forkJoin(...subs$);
}
</code></pre>

<p>Each of these endpoints returns data of the form:</p>

<pre><code>{ data: [], status: xyz }
</code></pre>

<p>I would like to use switchmap as I want to only show results from the final call, and have tried the following:</p>

<pre><code>   this.getAutocompleteSuggestions(query)
          .switchMap(res =&gt; {
             return res.data;
           })
          .subscribe((results: any) =&gt; {
            this.results = results;
          });
</code></pre>

<p>But the 'res' in the switchmap is an array, any idea how results can contain a single array containing the data from the response of any number of observables?</p>
","930875","","930875","","2018-03-07 14:11:05","2018-03-07 14:24:43","combining results from multiple rxjs observables","<javascript><angular><rxjs><reactive-programming><rxjs5>","2","2","1","","","CC BY-SA 3.0"
"49153841","2","","49153567","2018-03-07 14:05:52","","5","","<p>I don't fully understand what you want, but I think this is it:</p>

<pre><code>$filter: Subject&lt;string&gt; = new Subject(); //I guess we have some value to filter by??
</code></pre>

<p>Push a value to the subject:</p>

<pre><code>this.$filter.next(myNewValue);
</code></pre>

<p>In the constructor or init:</p>

<pre><code>this.$filter
   .switchMap(filterValue =&gt; { //Get the values when filter changes
       subs$ = [
         this.http.get(endpoint1 + filterValue),
         this.http.get(endpoint2 + filterValue),
         this.http.get(endpoint3 + filterValue)
       ];

       return Observable.forkJoin(...subs$);
   })
   .map(results =&gt; { //now map you array which contains the results
      let finalResult = [];
      results.forEach(result =&gt; {
          finalResult = finalResult.concat(result.data)
      })
      return final;
   })
   .subscribe(); //Do with it what you want
</code></pre>

<p>The entire steam will be executed again when we put a new value into our subject. SwitchMap will cancel all ready requests if there are any.</p>
","2564847","","2564847","","2018-03-07 14:24:43","2018-03-07 14:24:43","","","","6","","","","CC BY-SA 3.0"
"49179234","1","49181899","","2018-03-08 17:38:30","","3","1650","<p>I write application in React an Redux and I have a case that I have to send request to some resource when specific action was called and response of type <code>'text/html'</code> write to state. This resource can return status 200 or 404, and I cannot write correct test for case with response 404.
To run tests I use jest library.</p>

<p>Action.js:</p>

<pre><code>export const actions = {
    GET_RESOURCE_SUCCESS: 'GET_RESOURCE_SUCCESS',
    GET_RESOURCE_FAILURE: 'GET_RESOURCE_FAILURE'
};

export const getResourceSuccess = (response) =&gt; ({
    type: actions.GET_RESOURCE_SUCCESS,
    payload: response
});

export const getResourceFailure = () =&gt; ({
    type: actions.GET_RESOURCE_FAILURE
});
</code></pre>

<p>Reducer.js:</p>

<pre><code>import { handleActions } from 'redux-actions';
import { actions } from './Action';

const initialState = {
    content: ''
};

export const getResourceReducer = handleActions(
    {
        [actions.GET_RESOURCE_SUCCESS]: (state, action) =&gt; ({ ...state, content: action.payload })
    },
    {
        [actions.GET_RESOURCE_FAILURE]: () =&gt; ({ initialState })
    },
    initialState
);
</code></pre>

<p>In brief: when resource returns status 200 and content exists I want to overwrite <code>content</code> from <code>initialState</code> and call action <code>GET_RESOURCE_SUCCESS</code>, when resource returns status 404 and content doesn't exist I want not to overwrite the <code>content</code> and call action <code>GET_RESOURCE_FAILURE</code>.</p>

<p>GetResourceEpic.js:</p>

<pre><code>import { ajax } from 'rxjs/observable/dom/ajax';
import { combineEpics } from 'redux-observable';
import { Observable } from 'rxjs';
import { getResourceSuccess, getResourceFailure } from '../Action';

const specificActionTypes = [
    'SPECIFIC_ACTION_ONE',
    'SPECIFIC_ACTION_TWO'
];

const getResource = () =&gt; ajax({
    method: 'GET',
    url: 'http://example.com',
    headers: {
        Accept: 'text/html'
    },
    crossDomain: true,
    responseType: 'text/html'
});

const getResourceEpic = (action$, store) =&gt; action$
    .filter(action =&gt; specificActionTypes.includes(action.type))
    .flatMap(() =&gt; getResource()
        // when response has status 200 and field response call getResourceSuccess
        .map(({ response }) =&gt; getResourceSuccess(response))
        // when response has status 404 and doesn't have field response call getResourceFailure
        .catch(() =&gt; {
            // helper statement to show in browser that the .catch() was called
            console.log('Error');
            return getResourceFailure();
        })
    );

export default combineEpics(
    getResourceEpic
);
</code></pre>

<p>And it works in generally, but I get two errors:</p>

<p>first:</p>

<pre><code>Uncaught TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at Object.subscribeToResult (subscribeToResult.js:73)
    at CatchSubscriber../node_modules/rxjs/operator/catch.js.CatchSubscriber.error (catch.js:111)
    at MapSubscriber../node_modules/rxjs/Subscriber.js.Subscriber._error (Subscriber.js:128)
    at MapSubscriber../node_modules/rxjs/Subscriber.js.Subscriber.error (Subscriber.js:102)
    at AjaxSubscriber../node_modules/rxjs/Subscriber.js.Subscriber._error (Subscriber.js:128)
    at AjaxSubscriber../node_modules/rxjs/Subscriber.js.Subscriber.error (Subscriber.js:102)
    at XMLHttpRequest.xhrReadyStateChange (AjaxObservable.js:327)
    at XMLHttpRequest.d (raven.js:363)
</code></pre>

<p>and second:</p>

<pre><code>Could not consume error: TypeError: Cannot read property 'length' of null
    at getLinesAround (http://localhost:3000/static/js/bundle.js:47197:74)
    at http://localhost:3000/static/js/bundle.js:47537:402
    at Array.map (native)
    at _callee2$ (http://localhost:3000/static/js/bundle.js:47517:54)
    at tryCatch (http://localhost:3000/static/js/bundle.js:58220:40)
    at Generator.invoke [as _invoke] (http://localhost:3000/static/js/bundle.js:58458:22)
    at Generator.prototype.(anonymous function) [as next] (http://localhost:3000/static/js/bundle.js:58272:21)
    at step (http://localhost:3000/static/js/bundle.js:47553:191)
    at http://localhost:3000/static/js/bundle.js:47553:361
raven.js:51 
</code></pre>

<p>And mentioned above problems don't allow me to write a tests, because only responses with status 200 pass the tests, other throws errors.</p>

<pre><code>it('should dispatch GET_RESOURCE_SUCCESS when SPECIFIC_ACTION_ONE was dispatched', async () =&gt; {
        store = mockStore();

        const response = 'some content';
        nock('http://example.com')
            .get('/')
            .reply(200, response);

        const payload = { type: 'SPECIFIC_ACTION_ONE' };
        // specificActionOne() produces and action of type 'SPECFIC_ACTION_ONE'
        const action$ = ActionsObservable.of(specificActionOne(payload));
        const resultAction = await getResourceEpic(action$, store).toPromise();

        expect(resultAction)
            .toEqual(getResourceSuccess(response));
    });
</code></pre>

<p>And test above pass, but case with status equal to 404 doesn't pass:</p>

<pre><code>it('should dispatch GET_RESOURCE_FAILURE when SPECIFIC_ACTION_ONE was dispatched', async () =&gt; {
            store = mockStore();
            nock('http://example.com')
                .get('/')
                .reply(404);

            const payload = { type: 'SPECIFIC_ACTION_ONE' };
            const action$ = ActionsObservable.of(specificActionOne(payload));
            const resultAction = await getResourceEpic(action$, store).toPromise();

            expect(resultAction)
                .toEqual(getResourceFailure());
        });
</code></pre>

<p>And test above doesn't pass and I get the result:</p>

<pre><code>TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.

      at Object.subscribeToResult (node_modules/rxjs/util/subscribeToResult.js:73:27)
      at CatchSubscriber.Object.&lt;anonymous&gt;.CatchSubscriber.error (node_modules/rxjs/operator/catch.js:111:42)
      at MapSubscriber.Object.&lt;anonymous&gt;.Subscriber._error (node_modules/rxjs/Subscriber.js:128:26)
      at MapSubscriber.Object.&lt;anonymous&gt;.Subscriber.error (node_modules/rxjs/Subscriber.js:102:18)
      at AjaxSubscriber.Object.&lt;anonymous&gt;.Subscriber._error (node_modules/rxjs/Subscriber.js:128:26)
      at AjaxSubscriber.Object.&lt;anonymous&gt;.Subscriber.error (node_modules/rxjs/Subscriber.js:102:18)
      at XMLHttpRequest.xhrReadyStateChange [as onreadystatechange] (node_modules/rxjs/observable/dom/AjaxObservable.js:327:32)
      at XMLHttpRequest.callback.(anonymous function) (node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:289:32)
      at invokeEventListeners (node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:219:27)
      at invokeInlineListeners (node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:166:7)
      at EventTargetImpl._dispatch (node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:122:7)
      at EventTargetImpl.dispatchEvent (node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:87:17)
      at XMLHttpRequest.dispatchEvent (node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:61:35)
      at readyStateChange (node_modules/jsdom/lib/jsdom/living/xmlhttprequest.js:829:9)
      at Request.properties.client.on (node_modules/jsdom/lib/jsdom/living/xmlhttprequest.js:947:7)
      at Request.emit (events.js:132:15)
      at IncomingMessage.&lt;anonymous&gt; (node_modules/request/request.js:1085:12)
      at Object.onceWrapper (events.js:219:13)
      at IncomingMessage.emit (events.js:132:15)
      at endReadableNT (_stream_readable.js:1101:12)
      at process._tickCallback (internal/process/next_tick.js:114:19)
</code></pre>
","6590294","","5521183","","2018-08-17 01:05:13","2018-08-17 01:05:13","Cannot proper handle error in ajax from rxjs","<redux><react-redux><rxjs><jestjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49181899","2","","49179234","2018-03-08 20:28:36","","4","","

<p>The function passed to <code>catch</code> has to return an observable. You are returning an action.</p>

<p>Instead, you should do this:</p>

<pre class=""lang-js prettyprint-override""><code>import { of } from 'rxjs/observable/of';
...
.catch(() =&gt; {
  console.log('Error');
  return of(getResourceFailure());
})
</code></pre>
","6680611","","","","","2018-03-08 20:28:36","","","","2","","","","CC BY-SA 3.0"
"49182800","1","","","2018-03-08 21:30:53","","0","49","<p>Why do() function is not invoked ?</p>

<pre><code>export class AppComponent implements OnInit {
  name = 'Angular 5';
  events = [];
  existingEvents = [1,2,3,4,6]

  ngOnInit() {
    let i = 0;
    this.events.push('Initial');
    Observable.of(1,2,3,4,5)
    .do(() =&gt; { 
      // this block is not executing - why ?
      console.log(this.existingEvents[i]); 
      this.events.push(this.existingEvents[i]);
      i++;
    });
  }
}
</code></pre>

<p>Here is a <a href=""https://stackblitz.com/edit/angular-6eb5b6"" rel=""nofollow noreferrer"">stackblitz</a> for you.</p>
","2103767","","","","","2018-03-08 21:30:53","RxJS Obsevrable do() not invoked","<angular><rxjs><rxjs5>","0","4","1","","","CC BY-SA 3.0"
"49189807","1","49204437","","2018-03-09 08:48:54","","2","1947","<p>In short, Iâd like set up an epic that performs a request and dispatches an action based on the request being fulfilled or rejected. Then I'd like the epic to maybe dispatch additional action(s) based on the result and the current state.</p>

<p>First part is straightforward</p>

<pre><code>const fetchFooEpic: Epic&lt;ActionAny, RootState&gt; = (action$, store) =&gt;
  action$.pipe(
    ofType&lt;ActionAny, ReturnType&lt;typeof actions.foo.fetch&gt;&gt;(actions.foo.types.FETCH_ALL),
    switchMap(action =&gt;
      ajax({
        method: 'GET',
        url: `${path}/foo/${action.payload}`,
        headers: { Authorization: store.getState().user.token }
      }).pipe(
        map(({response}) =&gt; actions.foo.fetchFulfilled(response)),
        catchError(error =&gt; of(actions.foo.fetchRejected(error)))
      )
    )
  )
</code></pre>

<p>But I'm running into trouble introducing another action or empty into the mix. I <em>think</em> I want to use mergeMap and empty when nothing should be dispatched, but I'm getting type errors.</p>

<pre><code>const fetchMissingRelations = (response: Foo[], state: RootState) =&gt; {
  const unknown: BarId[] = foo
    .map(foo =&gt; foo.barId)
    .filter(barId =&gt; !state.bar.entities[barId])
  return unknown.length
    ? actions.bar.fetch([...new Set(unknown)])
    : empty&lt;never&gt;()
}

const fetchFooEpic: Epic&lt;ActionAny, RootState&gt; = (action$, store) =&gt;
  action$.pipe(
    ofType&lt;ActionAny, ReturnType&lt;typeof actions.foo.fetch&gt;&gt;(actions.foo.types.FETCH_ALL),
    switchMap(action =&gt;
      ajax({
        method: 'GET',
        url: `${path}/foo/${action.payload}`,
        headers: { Authorization: store.getState().user.token }
      }).pipe(
        mergeMap(({response}) =&gt; of(
          actions.foo.fetchFulfilled(response),
          fetchMissingRelations(response, store.getState())
          // err: property 'type' is missing in {}
        )),
        catchError(error =&gt; of(actions.foo.fetchRejected(error)))
      )
    )
  )
</code></pre>

<p>I end up in <a href=""https://github.com/redux-observable/redux-observable/issues/339"" rel=""nofollow noreferrer"">https://github.com/redux-observable/redux-observable/issues/339</a>, but providing the explicit never type for empty didn't work for me.</p>

<p>That's the question (feel free to stop here), but here's some additional context why I'm trying to do this and I'll appreciate if someone can suggest an alternative approach:</p>

<p>I've got couple of state slices with relational data that all comes over the network from different API endpoints. In this case it's discussions with internal and external participants.</p>

<p>When I fetch discussions, I'd like to immediately parse them for any references to participants that aren't in the state yet, batching them into requests to fill in the missing data (so I can display names, avatars and such on the UI). In case all the information is already available locally, I don't want to request anything.</p>

<p>My initial plan was to rely on connected React components that use the data to check for missing referenced entities in the lifecycle events (componentDidMount/componentWillReceiveProps) and dispatch actions to fill in the data, so the epics can stick to their own domains and not care about what else needs to be updated.</p>

<p>However, that is getting a little out of hand as that state is being used in many different places that all need to do the checks and dispatch actions when necessary. As much as I like keeping the state domains separate, I think having the epics that handle discussions requests to also dispatch the actions to update other stuff will make a much smaller footprint. The reasoning is that this would free up the connected components to just render or wait for data, instead of dispatching updates to fill in missing references. But I'm all ears for better solutions.</p>
","1093332","","1093332","","2018-03-09 09:02:37","2018-03-10 01:27:43","Dispatching additional actions conditionally from redux-observable epic","<typescript><redux><rxjs><rxjs5><redux-observable>","1","1","","","","CC BY-SA 3.0"
"49191962","1","","","2018-03-09 10:44:12","","0","587","<p>I believe the following code can be refactored using a flatMap but I cant seem to get it working as desired. </p>

<p>I understand flatMap essentially maps and then flattens, which is perfect for me as I'm using forkJoin so get an array of responses back from getAutocompleteSuggestions().</p>

<p>I want a single array of results upon subscription (which is what the code below produces), but changing the top level map to flatMap sends multiple single objects to the subscription. How can this code be better written with flatMap()?</p>

<pre><code>   const $resultsObservable: Observable&lt;any&gt; = Observable.of(query)
          .switchMap(q =&gt; this.getAutocompleteSuggestions(q))
          //tried changing the below to flatMap()
          .map(res =&gt; { 
            return res.map(resp =&gt; {
              const content = resp.content;
              content.map(result =&gt; this.someMethod(result));
              return content;
            })
            .reduce((flatArr, subArray) =&gt; flatArr.concat(subArray), []);
          });



  getAutocompleteSuggestions(query: string): Observable&lt;any&gt; {
    const subs$ = [];
    //... add some observables to $subs
    return Observable.forkJoin(...subs$);
  }
</code></pre>
","930875","","930875","","2018-03-09 11:14:34","2018-03-09 20:00:52","convert rjxs map and flatten/reduce to flatMap","<javascript><angular><typescript><rxjs><rxjs5>","1","6","","","","CC BY-SA 3.0"
"49204437","2","","49189807","2018-03-10 01:27:43","","1","","

<p><code>empty</code> returns an observable, so depending upon <code>unknown.length</code> your <code>fetchMissingRelations</code> function will return either (what appears to be) an action or an observable.</p>

<p>You should change it so that it always returns an observable:</p>

<pre class=""lang-ts prettyprint-override""><code>const fetchMissingRelations = (response: Foo[], state: RootState) =&gt; {
  const unknown: BarId[] = foo
    .map(foo =&gt; foo.barId)
    .filter(barId =&gt; !state.bar.entities[barId])
  return unknown.length
    ? of(actions.bar.fetch([...new Set(unknown)]))
    : empty&lt;never&gt;()
}
</code></pre>

<p>And you should change your <code>mergeMap</code> to take that into account:</p>

<pre class=""lang-ts prettyprint-override""><code>...
mergeMap(({response}) =&gt; concat(
  of(actions.foo.fetchFulfilled(response)),
  fetchMissingRelations(response, store.getState())
)),
</code></pre>
","6680611","","","","","2018-03-10 01:27:43","","","","0","","","","CC BY-SA 3.0"
"49208171","1","49208433","","2018-03-10 10:47:05","","2","457","<p>I am a bit new to RxJS and am having problems with <code>map</code> on an Observable which causes the upstream Observable being called multiple times (i.e. an HTTP request).</p>

<p>I have the following example:</p>

<p><a href=""https://stackblitz.com/edit/angular-rxjs-playground-uxygsb?file=app%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-rxjs-playground-uxygsb?file=app%2Fapp.component.ts</a></p>

<p>the gist is the following</p>

<pre><code>function simulateHttp(val: any, delay:number) {
    return Observable.of(val)
        .delay(delay);
}

function timeLog(msg) {
    console.log(`${new Date().toISOString()}:  ${msg}`);   
}

const timerStream: Observable&lt;number&gt; = IntervalObservable
  .create(8000)
const manualRefreshStream = new Subject&lt;any&gt;();
const combinedTriggerStream: Observable&lt;any&gt; = Observable.merge(timerStream, manualRefreshStream);

const httpResultStream = combinedTriggerStream.switchMap(v =&gt; {
  return simulateHttp('http ' + v, 3000);
});
const dataStream = httpResultStream
  .map(v =&gt; `*${v}*`)
  .map(v =&gt; `#${v}#`);
</code></pre>

<p>Basically as soon as I do a transformation via <code>map</code> on the <code>httpResult</code> stream I get the <code>simulateHttp</code> method being called multiple times.</p>

<p>I googled around and it seems that <code>share</code> might be the solution but I am not versed well enough to understand where to put it and <em>why</em>.</p>
","464773","","","","","2018-03-10 11:17:26","RxJs map function causes upstream observable to be called multiple times","<javascript><angular><rxjs><rxjs5>","1","3","1","","","CC BY-SA 3.0"
"49208433","2","","49208171","2018-03-10 11:17:26","","1","","<p>I managed to remove the multiple invocations by doing</p>

<pre><code>const httpResultStream = combinedTriggerStream
   .switchMap(v =&gt; simulateHttp('http ' + v, 3000))
   .share(); 
</code></pre>

<p>Still not sure why I need this.</p>

<p>Also I found this article quite helpful even though it didn't pertain to my question <a href=""https://blog.angular-university.io/rxjs-switchmap-operator/"" rel=""nofollow noreferrer"">https://blog.angular-university.io/rxjs-switchmap-operator/</a></p>
","464773","","","","","2018-03-10 11:17:26","","","","2","","","","CC BY-SA 3.0"
"49219258","1","","","2018-03-11 11:02:33","","0","470","<pre><code>const allAnimatedElement$ = ($val: JQuery) =&gt; from($val).pipe(
  map(val =&gt; $(val)),
  concatMap($val =&gt; animateElement$($val)),
  toArray(),
  tap(val =&gt; console.log(`all: ${val}`)),
)

const animateDescription$ = nonStopedStream$.pipe(
  map(val =&gt; $('return array')),
  // switchMap($val =&gt; allAnimatedElement$($val)),
  switchMap($val =&gt; from($val).pipe(finalize(() =&gt; console.log('end arr')))),
  map(val =&gt; $(val)),
  concatMap($val =&gt; animateElement$($val)),
  toArray(),
  tap(val =&gt; console.log(`all: ${val}`)),,
);

const animateElement$ = ($element: JQuery): Observable&lt;JQuery&gt; =&gt;
  new Observable((observer: Observer&lt;any&gt;) =&gt; {
    const initialWidth = $element.width();

    $element.css({ width: 0, opacity: 1 }).velocity(
      { width: initialWidth },
      {
        duration: 1000,
        complete() {
          observer.next($element);
          observer.complete();
        },
      }
    );
  });
</code></pre>

<p>First switchMap perform as expected (see all message), but second - don't see all message. How can fix that in the second switchMap?</p>

<p>Eventually, I want that array divide on previous and current elements, then when nonstop emit new values, asynchronously animate current array, and restore previous array to initial position.</p>

<p>I just study rxjs and want to write a slider for learning.</p>

<p>Thanks for your help</p>
","8234354","","8234354","","2018-03-13 12:02:30","2018-03-13 12:02:30","Rxjs switchMap -> concatMap -> toArray not comleted toArray","<javascript><rxjs><observable><rxjs5>","0","4","","","","CC BY-SA 3.0"
"49235925","1","49236380","","2018-03-12 13:01:43","","1","169","<p>So I need to a complete a hot observable chain when the very first observable fires its completion handler.</p>

<p>An example is probably easier:</p>

<pre><code>const hot1 = new Rx.Subject();
const hot2 = new Rx.Subject();

const example = hot1
  .do(() =&gt; console.log('HOT1 emitted'))
  .switchMap(() =&gt; hot2.do(() =&gt; console.log('HOT2 emitted')));

const subscribe = example.subscribe({
  next: console.log,
  error: console.error,
  complete: () =&gt; console.info('CHAIN COMPLETE')
});

hot1.next();
hot2.next('abc');

hot1.complete();
</code></pre>

<p>Demo: <a href=""http://jsbin.com/berexexoyu/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/berexexoyu/edit?js,console</a></p>

<blockquote>
  <p>I need <code>CHAIN COMPLETE</code> to be output when I call <code>hot1.complete()</code>.</p>
</blockquote>

<p>Can this be solved functionally, without moving into imperative territory?</p>
","536485","","1000551","","2018-03-12 13:03:48","2018-03-12 13:24:20","Completing a hot observable chain with multiple hot observables","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49236380","2","","49235925","2018-03-12 13:24:20","","1","","<p>It might look like a little hack but since you want to control the chain only by completing <code>hot1</code> you can use <code>takeUntil</code> to complete chain after <code>hot1</code> completed while ignoring all its values:</p>

<pre><code>const hot1 = new Subject();
const hot2 = new Subject();

const example = hot1
  .do(() =&gt; console.log('HOT1 emitted'))
  .switchMap(() =&gt; hot2.do(() =&gt; console.log('HOT2 emitted')))
  .takeUntil(hot1.ignoreElements().concat(Observable.of(1)));

const subscribe = example.subscribe({
  next: console.log,
  error: console.error,
  complete: () =&gt; console.info('CHAIN COMPLETE')
});

hot1.next();
hot2.next('abc');

hot1.complete();
</code></pre>

<p>See your updated demo (open console): <a href=""https://stackblitz.com/edit/rxjs5-rfhpi2?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs5-rfhpi2?file=index.ts</a></p>

<p>The trick is with using <code>hot1.ignoreElements().concat(Observable.of(1))</code> that emits a single value after <code>hot1</code> completes which notifies <code>takeUntil</code> and the whole chain is completed.</p>
","310726","","","","","2018-03-12 13:24:20","","","","4","","","","CC BY-SA 3.0"
"49242391","1","49242435","","2018-03-12 18:42:04","","4","8728","<p>I'm trying to map the result of my httpclient and we need to use the new import for RxJs to get the treeshaking working.</p>

<p>so i've found 2 map but none work...</p>

<pre><code>import { map } from 'rxjs/operator/map'; 
import { map } from 'rxjs/operators/map';
</code></pre>

<p>the old fashion way that we need to remove </p>

<pre><code>import 'rxjs/add/operator/map';
</code></pre>

<p>Here is the code i need to get to work!</p>

<pre><code>  getValues(): Observable&lt;Value[]&gt; {   
    return this.http.get&lt;Response&lt;Values&gt;&gt;(this.url).map(reponse =&gt; {
      return reponse.data.values;
    });
  }
</code></pre>

<p>but the .map is not known for the observable,</p>
","4321014","","","","","2020-04-08 11:15:23","angular 5, RxJs { map } import doesn't work or i'm missing something?","<angular><angular5><rxjs5>","3","0","","","","CC BY-SA 3.0"
"49242435","2","","49242391","2018-03-12 18:44:53","","12","","<p>The proper ""modern"" way to import RxJS operators is:</p>

<pre><code>import { map } from 'rxjs/operators';
</code></pre>

<p>Along with the use of <a href=""https://rxjs.dev/guide/v6/pipeable-operators"" rel=""noreferrer"">pipeable operators</a>.</p>

<p>Your code becomes:</p>

<pre><code>getValues(): Observable&lt;Value[]&gt; {   
  return this.http.get&lt;Response&lt;Values&gt;&gt;(this.url).pipe(
    map(reponse =&gt; reponse.data.values)
  );
}
</code></pre>
","965834","","965834","","2020-04-08 11:15:23","2020-04-08 11:15:23","","","","3","","","","CC BY-SA 4.0"
"49243531","1","","","2018-03-12 20:00:25","","0","483","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var button = document.querySelector('button');

var obs1 = Rx.Observable.fromEvent(button, 'click').scan(count =&gt; count + 1, 0).multicast(new Rx.Subject())

function obs2$(result) {
  return Rx.Observable.of(result).delay((Math.random() * 10000 % 2000) + 1000)
}

obs1.concatMap((count) =&gt; {
  return obs2$(count)
}).subscribe(x =&gt; console.log(""Sync Finished "" + x))

obs1.subscribe(x =&gt; console.log(""Sync Request  "" + x))

obs1.connect()</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://unpkg.com/@reactivex/rxjs@5.3.0/dist/global/Rx.js""&gt;&lt;/script&gt;

&lt;button&gt;Click me&lt;/button&gt;

&lt;h3 id='show'&gt;Foo&lt;/h3&gt;</code></pre>
</div>
</div>
</p>

<p>I am implementing a syncing system with two observables in play. One is just a stream of sync request actions:</p>

<pre><code>actions$.ofType('SYNC_REQUESTED')
</code></pre>

<p><code>actions$</code> in this case is a <a href=""https://redux-observable.js.org"" rel=""nofollow noreferrer"">redux-observable</a> construct representing Redux actions.</p>

<p>The other observable performs the actual sync and dispatches a Redux action when it is completed.</p>

<p>I want it to behave such that if a sync is currently being performed, and another emission is made to the sync request observable, the sync gets queued up (like in the case of <code>concatMap</code>). However, if multiple emissions are made during a sync, only one of them is actually taken.</p>

<p>In other words, I want a <code>switchMap</code> that doesn't cancel the current sync.</p>

<p>If you run the attached snippet and click the button five times in a row within a second you'll see:</p>

<pre><code>Sync Request  1
Sync Request  2
Sync Request  3
Sync Request  4
Sync Request  5
Sync Finished 5
</code></pre>

<p>If you use <code>switchMap</code>.</p>

<p>And using <code>concatMap</code> you'll see:</p>

<pre><code>Sync Request  1
Sync Request  2
Sync Request  3
Sync Request  4
Sync Request  5
Sync Finished 1
Sync Finished 2
Sync Finished 3
Sync Finished 4
Sync Finished 5
</code></pre>

<p>I want it read:</p>

<pre><code>Sync Request  1
Sync Request  2
Sync Request  3
Sync Request  4
Sync Request  5
Sync Finished 1
Sync Finished 5
</code></pre>

<p>Now because I am using Redux I could always use the store to help me out, maybe keeping track of <code>syncPending</code> and <code>syncInProgress</code> flags and using <code>skipWhile</code> to skip sync requests that happen while a sync is in progress if there's already one pending. </p>

<p>I was wondering if there was a way to do this just by using RxJS though since that would require extra code / actions / reducers / Redux state.</p>
","785215","","785215","","2018-03-12 20:08:23","2018-03-14 02:36:00","Skipping observable emissions after first pending one","<rxjs><reactive-programming><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"49249222","1","49249422","","2018-03-13 05:58:45","","0","5265","<p>I see that in Angular 5 one should be using rxjs operators differently and importing from <code>'rxjs/operators'</code> but I'm a little unclear on how it is supposed to work. I have something like: </p>

<pre><code>import { Observable } from 'rxjs/Observable';

import { combineLatest, takeUntil } from 'rxjs/operators';

@Component({ ... })
export class FooComponent implements OnInit, OnDestroy {


  constructor(private route: ActivatedRoute) {}


  ngOnInit() {

    this.route_data = Observable.combineLatest(this.route.params, this.route.data,
                             (params, data) =&gt; ({params,data}));

    this.route_data_sub = this.route_data.takeUntil(this.destroyed$).subscribe(
      (params_and_data) =&gt; {
                            ...
                           }
   }
 ...
}
</code></pre>

<p>but I'm getting <code>Observable.combineLatest is not a function</code> errors. If I add the combineLatest operator the old way it works for combineLatest, but then <code>takeUntil</code> is now not found. How is this supposed to be done with Angular 5?</p>

<p>I have quite a bit of rxjs code all over the app and don't know how it is supposed to be rewritten or how to change the imports. Does everything have to be rewritten with .pipe() now?</p>
","128508","","","","","2018-03-13 10:54:01","How to use combineLatest and takeUntil rxjs operators in Angular 5","<angular5><rxjs5>","2","0","","","","CC BY-SA 3.0"
"49249422","2","","49249222","2018-03-13 06:13:59","","4","","<p>You should import <code>combileLatest</code> use <br></p>

<p><code>import { combineLatest } from 'rxjs/observable/combineLatest';</code> <br></p>

<p>For <code>takeUntil</code> <br></p>

<p><code>import { takeUntil } 'rxjs/operators';</code></p>

<p>I found that information: </p>

<p><a href=""https://www.learnrxjs.io/operators/combination/combinelatest.html"" rel=""nofollow noreferrer"">combineLatest</a> <br>
<a href=""https://www.learnrxjs.io/operators/filtering/takeuntil.html"" rel=""nofollow noreferrer"">takeUntil</a></p>
","8481561","","","","","2018-03-13 06:13:59","","","","0","","","","CC BY-SA 3.0"
"49261883","1","","","2018-03-13 17:03:40","","0","164","<p>I have a question. I am starter in RxJS and didn't find answer yet network. Thus, would like to ask you.
<strong>What I need:</strong> I extract a Id from ActivatedRoute and then (on my mind, however not sure) create 2 streams. 1st - will download realted parts for item, and 2nd  - will download main details. Next requests depends on this details.<br>
I perform this logic with code below. Everything works well. However, I am afraid that I wrote not good code as it should be. Maybe somebody could correct me and explain my mistakes. I have some straight questions I put it here and mark with number in code for easier navigation.</p>

<p>1) When I create 2 separate streams it launches router$ twice. Is it important? How I could launch it once and then separate on 2 streams?</p>

<p>2) forkJoin. Acctually I don't need to wait untill all request will be executed. I didn't find proper operator which will emit values without waiting another. And it was good if error on any request does not cancel all another. Is there some another suitable operator?</p>

<p>3)  switchMap or mergeMap? I know that switchMap cancel previous request, but still I don't know which operator is preferable for it.</p>

<p>4) I decided at the end to merge this into 1 subscription and in ngOnDestroy unsubscribe. But maybe it would be better to use subscribe instead of operator map and unsubscribe from each separatly?</p>

<p>Thank you in advance for you answer. If you have any another idea or remarks please shoot. I will be very appriciate!</p>

<pre><code>router$ =  this.aRoute.paramMap.map(params =&gt; +params.get('id'));        // &lt;----  1

ngOnInit() {
  this.details$ = this.router$.mergeMap(id =&gt; {                           // &lt;---- 3
    return this.claimSvc.getClaimDetails(id);
  }).do(details =&gt; {
    this.currentDetails = details;
    .... // some borring things            
  }).switchMap(details =&gt; {                                              // &lt;---- 3
    return  Observable.forkJoin(                                          // &lt;--- 2
      this.claimSvc.getDocuments(details.date....),
      this.claimSvc.getHolders(details.date...),
      this.claimSvc.getSubTypes(details.date...),
      this.claimSvc.getCategories(details.date...)
    )
  }).map(([documents, holders, subtypes, categories]) =&gt; {
    this.documents = documents;
    this.holders = holders;
    this.subTypes = subtypes;
    this.categories = categories;
  });

  this.claimParts$ = this.router$.switchMap(id =&gt; {                     // &lt;---- 3
    return Observable.forkJoin(                                         //  &lt; ------ 2
      this.claimSvc.getAttributes(id), 
      this.claimSvc.getParties(id),
      this.claimSvc.getClaimObjects(id),
      this.claimSvc.getClaimInsurances(id),
      this.claimSvc.getClaimPayments(id)
    )
  }).map(([Attribute, Parties, Objects, Insurances, Payments]) =&gt; {
    this.attributes = Attribute;
    this.parties = Parties;
    this.objects = Objects;
    this.insurances = Insurances;
    this.payments = Payments;
  });

  this.subscription = Observable.merge(this.claimParts$, this.claimDetails$).subscribe();  // &lt;----  4
}
</code></pre>
","5745531","","8882952","","2018-03-13 22:24:26","2018-03-13 22:24:26","RxJS in combining http requests during component initialization in Angular 2+","<angular><typescript><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49295975","1","","","2018-03-15 09:41:59","","1","2093","<p>I have a fairly complicated reactive behavior which I would like to achieve using RxJS but I didn't find a proper solution yet.</p>

<p>In my angular app which can be found in <a href=""https://plnkr.co/edit/HihTaEQWBMI6InbmjTlv?p=preview"" rel=""nofollow noreferrer"">Plnkr</a> I have a series of sync, async and parallel async execution.</p>

<ol>
<li><p>First the user clicks on a button which calls next on my RxJS Subject 
<code>userClick$ = new Subject&lt;void&gt;();</code>.</p>

<p><code>&lt;button (click)=""model.on = !model.on; userClick$.next()""&gt;
  {{ model.on ? 'Stop' : 'Start' }}
&lt;/button&gt;</code></p></li>
<li>then I provide a random number using <code>getRandomNumber</code></li>
<li>then I calculate the exponential of that random number using <code>getExpNumber</code></li>
<li>Finally I need to run <code>getFloor</code> and <code>getCeil</code> all in parallel.</li>
</ol>

<h2>What I need?</h2>

<ul>
<li>Be able to use <code>forkJoin</code> on the last two parallel executions #4.</li>
<li>Be able to express dependency of #3 on #2 and #4 on #3:

<ul>
<li>getExpNumber depends on getRandomNumber and run after it</li>
<li>getFloor runs in parallel with getCeil and both depend on getExpNumber.</li>
</ul></li>
<li>Be able to use the return value of the stream in each of my <code>flatMap</code>, currently I get only the last value (I need to display the random value (first flatMap) to the user using <code>ngFor</code> and <code>async</code> pipe.</li>
</ul>

<p>Depencency: I can acheive that by checking the type of my current observable value in each <code>flatMap</code> but I am thinking there must be a better way.</p>

<p>Full code:</p>

<pre><code>import { Component, NgModule, VERSION } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/switchMap';

@Component({
  selector: 'my-app',
  template: `
    &lt;button (click)=""model.on = !model.on; userClick$.next()""&gt;{{ model.on ? 'Stop' : 'Start' }}&lt;/button&gt;
    &lt;h1&gt;Numbers stream&lt;/h1&gt;
    &lt;div *ngFor=""let numberValue of (numbers$ | async)""&gt;
      &lt;h2&gt;{{ numberValue }}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;label&gt;{{ model.log }}&lt;/label&gt;
  `,
})
export class App {
  model = {
    on: false,
    log: ''
  }
  userClick$ = new Subject&lt;void&gt;();
  numbers$: Observable&lt;number[]&gt; = this.userClick$
    .filter(() =&gt; !!this.model.on)
    .do(() =&gt; this.model.log = '')
    .switchMap(() =&gt; this.getRandomNumber())
    .switchMap((num) =&gt; this.getExpNumber(num))
    .switchMap((num) =&gt; this.getFloor(num))
    .switchMap((num) =&gt; this.getCeil(num));
  constructor() {
  }
  /**
   * Runs after user click
   */
  getRandomNumber(): Observable&lt;number[]&gt; {
    return new Observable&lt;number[]&gt;(observer =&gt; {
      this.model.log += ' getRandomNumber';
      observer.next([Math.floor(Math.random() * 10) + 1]);

      return () =&gt; {}
    }
  }
  /**
   * Depends on getRandomNumber and run after it
   */
  getExpNumber(n: number): Observable&lt;number[]&gt; {
    return new Observable&lt;number[]&gt;(observer =&gt; {
      this.model.log += ' getExpNumber';
      observer.next([Math.floor(Math.exp(n)]);

      return () =&gt; {}
    }
  }
  /**
   * Runs in parallel with getCeil
   */
  getFloor(n: number): Observable&lt;number[]&gt; {
    return new Observable&lt;number[]&gt;(observer =&gt; {
      this.model.log += ' getFloor';
      observer.next([Math.floor(n)]);

      return () =&gt; {}
    }
  }
  /**
   * Runs in parallel with getFloor
   */
  getCeil(n: number): Observable&lt;number[]&gt; {
    return new Observable&lt;number[]&gt;(observer =&gt; {
      this.model.log += ' getCeil';
      observer.next([Math.ceil(n)]);

      return () =&gt; {}
    }
  }
}
@NgModule({
  imports: [ BrowserModule ],
  declarations: [ App ],
  bootstrap: [ App ]
})
export class AppModule {}
</code></pre>
","9434594","","","","","2018-03-16 07:49:14","Angular RxJS combine sync, async and forkJoin in one Subject stream","<angular><rxjs><angular5><rxjs5>","2","0","","","","CC BY-SA 3.0"
"49296906","1","49304241","","2018-03-15 10:21:54","","0","115","<p>Every time a new value is produced I need to compare it with all previous values and only if a condition is met it will be added to the stream.</p>

<p>How can this be done with observables?</p>
","799853","","","","","2018-03-15 16:09:20","rxjs - Iterate back in Observables","<rxjs><rxjs5><angular2-observables><rxjs-lettable-operators>","1","2","","","","CC BY-SA 3.0"
"49300037","1","49300271","","2018-03-15 12:55:18","","1","679","<p>I have a question about unsubscribing <code>Output</code>s in Angular. I know that EventEmitter gets cleaned up automatically, but the last time I needed use <code>Observable</code> as my <code>Output</code>. I mean, I wanted take <code>Output</code> which emit maximum once event per second. So my code looked like: </p>

<pre><code>@Output() loadNextEvent: Observable&lt;any&gt;;
loadNextSubject = new Subject();

constructor(private el: ElementRef) {
    this.loadNextEvent = this.loadNextSubject.asObservable()
        .throttleTime(1000); // once per second
    }

emit() {
    this.loadNextSubject.next('new event');
}
</code></pre>

<p>Ok, it works pretty fine - I thought. The only problem is unsubscribing. I found <a href=""https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription"">one solution</a> on StackOverflow, but I'm still not sure, how I should do it correctly. In my case:</p>

<pre><code>@Output() loadNextEvent: Observable&lt;any&gt;;
loadNextSubject = new Subject();

constructor(private el: ElementRef) {
    this.loadNextEvent = this.loadNextSubject.asObservable()
        .takeUntil(this.loadNextSubject) //does it make any sense?
        .throttleTime(1000); // once per second
    }

emit() {
    this.loadNextSubject.next('new event');
}

ngOnDestroy() {
    this.loadNextSubject.complete();
}
</code></pre>

<p><strong>Question:</strong>
Is this the correct unsubscribing of <code>observable Output</code>? <code>.takeUntil(this.loadNextSubject)</code> make any sense? Or maybe <code>.asObservable()</code> give ensurance that Observable was cleaned, when <code>Subject</code> is completed? Anyone know answer for my problem? or maybe, there is a better solution, then use <code>Observable</code> as <code>Output</code>, for my case? </p>
","6848233","","310726","","2018-03-15 13:07:47","2018-03-15 13:14:27","How to unsubscribe @Output as Observable","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49300271","2","","49300037","2018-03-15 13:06:33","","3","","<p>If you want to use <code>takeUntil</code> the notifier Observable needs to emit a <code>next</code> notification and not just complete. So the correct way to do this would be like this:</p>

<pre><code>ngOnDestroy() {
    this.loadNextSubject.next();
    this.loadNextSubject.complete();
}
</code></pre>

<p>Also you don't need to use <code>asObservable()</code> in this case. Subjects are Observables so using <code>asObservable()</code> will just wrap it with another Observable which is unnecessary.</p>

<p>One more thing. In Angular 5 there's a bug that is creating memory leaks when chaining operators with <code>EventEmitter</code> (the chain wasn't properly disposed). For more details you can have a look here <a href=""https://github.com/angular/angular/issues/21999"" rel=""nofollow noreferrer"">https://github.com/angular/angular/issues/21999</a>. </p>

<p>This was fixed here <a href=""https://github.com/angular/angular/pull/22016"" rel=""nofollow noreferrer"">https://github.com/angular/angular/pull/22016</a> and should be available since Angular 6.</p>

<p>And I think this is exactly what you're doing right now. An easy way to avoid this until Angular 6 is actually using <code>asObservable()</code> before adding any operators (see this comment <a href=""https://github.com/angular/angular/issues/21999#issuecomment-362921475"" rel=""nofollow noreferrer"">https://github.com/angular/angular/issues/21999#issuecomment-362921475</a>).</p>
","310726","","310726","","2018-03-15 13:14:27","2018-03-15 13:14:27","","","","2","","","","CC BY-SA 3.0"
"49304241","2","","49296906","2018-03-15 16:09:20","","1","","<p>This is an example, maybe a little convoluted, which should do something similar to what you are looking for</p>

<pre><code>import {Observable} from 'rxjs';

const values = ['aa', 'ab', 'ac', 'ba', 'db', 'bc', 'cc', 'cb', 'cc']

Observable.from(values)
// accumulate all previous values into an array of strings
.scan((previousValues, thisValue) =&gt; {
    previousValues.push(thisValue)
    return previousValues
}, [])
// create an object with the previous objects and the last one
.map(previousValues =&gt; {
    const lastValue = previousValues[previousValues.length - 1]
    return {previousValues, lastValue}
})
// filters the ones to emit based on some similarity logic
.filter(data =&gt; isNotSimilar(data.lastValue, data.previousValues))
// creates a new stream of events emitting only the values which passed the filter
.mergeMap(data =&gt; Observable.of(data.lastValue))
.subscribe(
    value =&gt; console.log(value)
)

function isNotSimilar(value: string, otherValues: Array&lt;string&gt;) {
    const otherValuesButNotLast = otherValues.slice(0, otherValues.length - 1);
    const aSimilar = otherValuesButNotLast.find(otherValue =&gt; otherValue[0] === value[0]);
    return aSimilar === undefined;
}
</code></pre>
","5699993","","","","","2018-03-15 16:09:20","","","","0","","","","CC BY-SA 3.0"
"49311802","1","49312109","","2018-03-16 01:21:41","","0","76","<p>I have a service which pulls in data from the API</p>

<pre><code>import { IStats } from './istats';
export class WebService {
  BASE_URL = 'http://localhost:3000/api';
  public stats = new BehaviorSubject&lt;IStats&gt;({
    date: this.datePipe.transform(new Date(), 'dd-MM-yyyy'),
    answeringMachine:0,
    hangUp:0,
    conversations:0
  });

  constructor(private http: HttpClient, private datePipe: DatePipe) {
    this.getStatsbyDate('04-03-2018');
    // this.getStatsbyDate(this.datePipe.transform(new Date(), 'dd-MM-yyyy'));
  }
  getStatsbyDate(date) {
    this.http.get&lt;IStats&gt;(this.BASE_URL + '/stats/' + date)
      .subscribe((data: IStats) =&gt; {
        this.stats.next(data);
      });
  }
</code></pre>

<p>And then I have a component which subscribes to that BehavioralSubject in the service.</p>

<pre><code>export class StatsComponent {
  private stats: IStats;
  constructor(private webService: WebService, private datePipe: DatePipe)     {
    this.stats = this.webService.stats.getValue();
  }
</code></pre>

<p>I thought if the backend API doesn't have any data then the behavioralSubject returns the default values, which works as of now, but what if the backend does have data coming through then isn't it supposed to replace the default values with the values from the API?
Is there anything wrong that I am doing here?
Please advise!</p>
","3826733","","2495283","","2018-03-16 01:26:57","2018-03-16 02:16:56","Angular BehavioralSubject not working as expected","<angular><typescript><rxjs5><behaviorsubject>","1","1","","","","CC BY-SA 3.0"
"49312109","2","","49311802","2018-03-16 02:01:56","","0","","<p>I was able to work it out making some changes on the component code</p>

<pre><code>export class StatsComponent {
  private stats: IStats;
  constructor(private webService: WebService, private datePipe: DatePipe) {
    this.webService.stats$.subscribe(data =&gt; {
      if (data !== null) { this.stats = data; }  
      else { this.webService.stats$.next(this.stats); }
    })
  }
</code></pre>

<p>In this way the BehavioralSubject supplies the default values from the service if there is no data from API and also vice versa.</p>
","3826733","","","","","2018-03-16 02:01:56","","","","0","","","","CC BY-SA 3.0"
"49319020","1","49319183","","2018-03-16 10:53:52","","3","3657","<p>I have an angular5 service which does an HTTP get and returns a specific type as shown below</p>

<pre><code>public getProductByIDproductId: string): Observable&lt;Product&gt; {
    const headers = new HttpHeaders({ ""Content-Type"": ""application/json"" });
    const url = `${environment.productservice_baseurl}/${productId}`;
    return this.http
      .get&lt;Product&gt;(url, { headers: headers })
      .pipe(       
        tap(data =&gt; (this._product = data)),
        catchError(this.handleError)
      );
  }
</code></pre>

<p>The Product class is a class which has properties and methods. A small excerpt is below.</p>

<pre><code>class Product{
    productID:string;
    productName:string;

    setQuantity(quantity:number){

    }
}
</code></pre>

<p>When I call the setQuantity function on this._product returned by the get I get a 'setQuantity is not a function' error. When I try to check the instance of this._product, it is not of type Product but if type Object.</p>

<p>Is the generic type set on the get method only to help compile-time type checking? How do I get a concrete instance of the product class from getProductByIDproductId method? </p>
","4613054","","","","","2018-03-16 11:31:21","Angular Service - Type of object returned is object and not that of the generic type specified","<angular><typescript><angular5><rxjs5>","3","5","","","","CC BY-SA 3.0"
"49319183","2","","49319020","2018-03-16 11:01:44","","5","","<p>You can't do what you're doing.</p>

<p>When you fetch data from an URL, you get just JSON. You're telling TypeScript that <code>data</code> is of type <code>Product</code>, but that is just a hint for the compiler and does not make it true.</p>

<p><code>data</code> was not created with a call to <code>new Product</code> and so it doesn't share its methods.</p>

<p>If you want your <code>this._product</code> to behave like a native <code>Product</code> instance, you can do this:</p>

<pre><code>this._product = data;
Object.setPrototypeOf(this._product, Product.prototype);
</code></pre>

<p>This way you turn <code>this._product</code> into a real <code>Product</code> instance, including its methods.</p>

<p>Another option, if you are worried about <code>setPrototypeOf</code> and its potential performance drawback, is doing it this way:</p>

<pre><code>this._product = new Product();
Object.assign(this._product, data);
</code></pre>

<p>Of course, this is only a good idea if <code>Product</code> has a parameterless constructor. And, in any case, if <code>data</code> has properties not defined in <code>Product</code> class you can also run into performance issues.</p>
","3203588","","3203588","","2018-03-16 11:31:21","2018-03-16 11:31:21","","","","4","","","","CC BY-SA 3.0"
"49328258","1","","","2018-03-16 19:33:00","","1","693","<p>I have an epic like this</p>

<pre><code>const getProjectsEpic = action$ =&gt; 
  action$.ofType(state.GET_PROJECTS_REQUEST)
         .switchMap(action =&gt;  fetchService())
         .map(res =&gt; actions.getProjectsRequestSuccess(res))
         .catch((error) =&gt; actions.getProjectsRequestFailure(error));
</code></pre>

<p>And inside <code>fetchService</code> I got </p>

<pre><code>export async function fetchService() {
  let response = await fetch('http://apiendpoint');
  return (validateStatusCode(response)) ? response.json() : new Error(response.statusText); 
}
</code></pre>

<p>Trying to find out what I'm doing wrong but the console is throwing me:</p>

<pre><code>runtime.js?c1c3:288 Uncaught (in promise) RangeError: Maximum call stack size exceeded
at Generator.invoke [as _invoke] (runtime.js?c1c3:288)
at Generator.prototype.(anonymous function) [as next] (webpack-internal:///../node_modules/regenerator-runtime/runtime.js:114:21)
at step (asyncToGenerator.js?6185:17)
at eval (asyncToGenerator.js?6185:35)
</code></pre>

<p>Can someone explain it to me and how to debug better having a similar issue in future.</p>
","2595644","","310726","","2018-03-16 19:49:02","2018-03-17 00:59:31","Redux Observable and async fetch call","<rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"49385487","1","49385948","","2018-03-20 13:25:12","","3","12173","<p>I have a list of songs setup with Subject and Observable (shown with <code>| async</code> in view), and now I want to delete a song off the list, do some <code>filter()</code> and call <code>next()</code> on the Subject.</p>

<p><strong>How and where do I filter?</strong> Right now I am doing <code>getValue()</code> on Subject and passing that to <code>next()</code> on, well, Subject. This just seems wrong and circularish.</p>

<p>I also tried subscribing to the Subject and getting the data that way, filtering it and calling <code>next()</code> inside <code>subscribe()</code>, but I got a RangeError.</p>

<p>I could filter the Observable by storing all deleted id's. The Subject's list then becomes out of sync by having deleted songs on there and also every observer would have to have the deleted-id's-list which seems ludicrous. I'm rapidly growing old and mental. Please help me internet :(</p>

<pre><code>export class ArtistComponent implements OnInit {
  private repertoire$;
  private repertoireSubject;
  constructor(
    private route: ActivatedRoute,
    private service: ArtistService
  ) {
    this.getRepertoire().subscribe(
      songs =&gt; this.repertoireSubject.next(songs)
    );
  }

  getRepertoire() {
    return this.route.paramMap
      .switchMap((params: ParamMap) =&gt;
      this.service.fetchRepertoire(params.get('id')));
  }

  //THIS IS WHERE I'M HAVING TROUBLE
  delete(id): void {
    this.repertoireSubject.next(
      this.repertoireSubject.getValue().filter(song =&gt; (song.id !== id))
    );
    // TODO remove song from repertoire API
  }

  ngOnInit() {
    this.repertoireSubject = new BehaviorSubject&lt;any&gt;(null);
    this.repertoire$ = this.repertoireSubject.asObservable();
  }

}
</code></pre>
","4004856","","","","","2018-03-20 14:09:36","Subject and Observable, how to delete item, filter() list and next()","<angular><rxjs><observable><rxjs5><subject-observer>","3","3","1","","","CC BY-SA 3.0"
"49385948","2","","49385487","2018-03-20 13:45:39","","3","","<p>i recommand you to create new attribute on your component, where you will last store state. (here understands array of songs).</p>

<p>Is always better conceptualize your code by, internal property who represent your state (or store) and another attribute who have the role to sync rest of your application (by observable / event).</p>

<p>Another tips is to strong type your code by model. Will be easier to debug and maintain.</p>

<p>Then you just have to update it according to your logic and next on your Subject </p>

<pre><code>export interface SongModel {
        id: number;
        title: string;
        artiste: string;
    }

    export class ArtistComponent implements OnInit {
        private repertoire$ : Observable&lt;SongModel[]&gt;;
        private repertoireSubject: BehaviorSubject&lt;SongModel[]&gt;;
        //Array of song, should be same type than repertoireSubject.
        private songs: SongModel[];

        constructor(
            private route: ActivatedRoute,
            private service: ArtistService
        ) {

            //We push all actual references.
            this.getRepertoire().subscribe(
                songs =&gt; {
                    this.songs = songs;
                    this.repertoireSubject.next(this.songs);
                }
            );
        }

        ngOnInit() {
            //Because is suject of array, you should init by empty array.
            this.repertoireSubject = new BehaviorSubject&lt;SongModel[]&gt;([]);
            this.repertoire$ = this.repertoireSubject.asObservable();
        }


        getRepertoire() {
            return this.route.paramMap
                .switchMap((params: ParamMap) =&gt;
                this.service.fetchRepertoire(params.get('id')));
        }

        //THIS IS WHERE I'M HAVING TROUBLE
        delete(id: number): void {
            // Update your array referencial.
            this.songs = this.songs.filter(songs =&gt; songs.id !== id);
            // Notify rest of your application.
            this.repertoireSubject.next(this.songs);
        }
    }
</code></pre>
","9483405","","","","","2018-03-20 13:45:39","","","","1","","","","CC BY-SA 3.0"
"49409302","1","","","2018-03-21 14:41:40","","0","664","<p>I have a route in my application that I've attached a resolver to it so that before the route is accessed I have the data needed for the page. These last few days I've been updating the application from Angular 4 to Angular 5 and as part of the update I'm also changing the code to use the <code>HttpClientModule</code> rather than the deprecated <code>HttpModule</code> and <code>rxjs</code> 5.5.6.</p>

<p>For some reason the resolver is now always returning undefined as the data. This is a sample of the resolver I have:</p>

<pre><code>@Injectable()
export class GameLoaderResolver implements Resolve&lt;any&gt; {
    constructor(
        private router: Router,
        private service1: Service1,
        private service2: Service2
    ) { }

    resolve(): Observable&lt;any&gt; {
        let observable1 = this.service1.get('http://localhost:1234/api/Users/getData');

        let observable2 = this.service2.get('http://localhost:1234/api/Countries/getData');

        return forkJoin(observable1, observable2);
    }
}
</code></pre>

<p>Above is a sample of what I have in my resolver. I need data from multiple service calls before the route loads so I'm using <code>forkJoin</code> to combine them into one single <code>Observable</code>. What happens with the above code is that an array with an element for each observable is returned. So in this case an array with two elements are returned, index <code>0</code> has the data of <code>observable1</code> and index <code>1</code> has the data of <code>observable2</code>. After I changed to using <code>HttpClient</code> and <code>rxjs</code> 5.5.6 I'm getting an array <code>[ undefined, undefined ]</code>.</p>

<p>This used to work when using <code>HttpModule</code>, I did my research and unless I missed it I couldn't find any changes to the router resolvers, so I'm not sure if there's anything wrong with the code above.</p>

<p><strong>Environment Verions:</strong></p>

<ul>
<li><strong>Angular:</strong> 5.2.8</li>
<li><strong>RXJS:</strong> 5.5.6</li>
</ul>

<p><strong>Update</strong></p>

<p>I managed to fix the issue by using <code>map</code> on each observable and on the <code>forkJoin</code>, this way the result is returned. So the updated code has to look something like this:</p>

<pre><code>@Injectable()
export class GameLoaderResolver implements Resolve&lt;any&gt; {
    constructor(
        private router: Router,
        private service1: Service1,
        private service2: Service2
    ) { }

    resolve(): Observable&lt;any&gt; {
        let observable1 = this.service1.get('http://localhost:1234/api/Users/getData')
            .map(res =&gt; return res);

        let observable2 = this.service2.get('http://localhost:1234/api/Countries/getData')
            .map(res =&gt; return res);

        return forkJoin(observable1, observable2)
            .map(res =&gt; return res);
    }
}
</code></pre>

<p>I'm guessing that since before when using <code>HttpModule</code> we had to implement a  function to extract the data from the response, the data was being returned. Now with the latest update I'm guessing that this has to be done with an ""extra step"".</p>
","2312637","","2312637","","2018-03-21 15:20:48","2018-03-21 15:20:48","Issue with Angular Router Resolve - Data undefined","<angular><typescript><angular5><angular-routing><rxjs5>","0","2","","","","CC BY-SA 3.0"
"49423863","1","49424490","","2018-03-22 08:31:58","","4","9114","<p>I'd like to build a wrapper class, that does something before and after each emitted value of an Observable.</p>

<p>Here's what I came up with:</p>

<pre><code>class Wrapper&lt;T&gt; {
    wrapped$: Observable&lt;T&gt;;

    _dataSubject = new Subject&lt;T&gt;();
    data$ = this._dataSubject.pipe(
        tap(_ =&gt; console.log(""BEFORE""),
        //
        // map( ??? )
        //
    );

    constructor(wrapped$: Observable&lt;T&gt;) {
        this.wrapped$ = wrapped$.pipe(
            tap(_ =&gt; console.log(""AFTER"")
        );
    }
}

let subject = new Subject&lt;string&gt;();
let wrapper = new Wrapper(subject);
wrapper.data$.subscribe(val =&gt; console.log(val));
subject.next(""foo"")
</code></pre>

<p>The console output should be:</p>

<pre><code>BEFORE
foo
AFTER
</code></pre>

<p>I can't figure out how to connect the <code>$wrapped</code> Observable with the <code>_dataSubject</code>.</p>

<p>But maybe I'm completely wrong and it needs a different approach.</p>
","1321564","","1321564","","2018-03-22 08:44:45","2018-03-22 12:18:10","Wrap an Observable. Do something before and after each emitted value","<typescript><rxjs><observable><rxjs5><subject-observer>","4","2","2","","","CC BY-SA 3.0"
"49424490","2","","49423863","2018-03-22 09:06:09","","11","","<p>What about something like this</p>

<pre><code>import {Observable} from 'rxjs';

export class DoBeforeAfter&lt;T&gt; {
    wrapped$: Observable&lt;T&gt;;


    constructor(wrapped$: Observable&lt;T&gt;, doFunction: (data: any) =&gt; void) {
        this.wrapped$ = Observable.of(null)
            .do(_ =&gt; console.log(""BEFORE""))
            .switchMap(_ =&gt; wrapped$)
            .do(doFunction)
            .do(_ =&gt; console.log('AFTER'));
    }

}
</code></pre>

<p>to be consumed like this</p>

<pre><code>const source = Observable.of('NOW');
const beforeAfter = new DoBeforeAfter(source, data =&gt; console.log(data));

beforeAfter.wrapped$.subscribe(
        null,
        error =&gt; console.error(error),
        () =&gt; console.log('DONE')
</code></pre>

<p>)</p>

<p>It looks a bit cumbersome, but maybe it can help</p>
","5699993","","","","","2018-03-22 09:06:09","","","","2","","","","CC BY-SA 3.0"
"49429322","1","49430046","","2018-03-22 12:57:25","","4","1474","<p>I have the following requirement.</p>

<p>I have An Angular service with an BehaviorSubject.
A http request is done and when this is done the BehaviorSubject.next method is invoked with the value.
This value can change during the lifecycle of the single page.</p>

<p>Different subscribers are registered to it and get invoked whenever this changes.</p>

<p>The problem is that while the http request is pending the BehaviorSubject already contains a default value and subscribers are already immediately getting this value.</p>

<p>What I would want is that subscribers have to wait till the http request is done (deferred) and get the value when the http request is done and sets the value.
So what I need is some kind of deferred Behavior subject mechanism.</p>

<p>How would i implement this using rxjs?</p>

<p>Another requirement is that if I subscribe to the behaviorsubject in a method we want the subcriber to get the first non default value and that the subscription ends. We don't want local subscriptions in functions to be re-executed.</p>
","2174621","","2174621","","2018-03-22 13:35:57","2018-03-22 23:08:57","deferred Rxjs BehaviorSubject mechanism","<rxjs><rxjs5>","2","5","","","","CC BY-SA 3.0"
"49430046","2","","49429322","2018-03-22 13:32:49","","1","","<p>Use a filter on your behavior subject so your subscribers won't get the first default emitted value: </p>

<pre><code>mySubject$: BehaviorSubject&lt;any&gt; = new BehaviorSubject&lt;any&gt;(null);

httpResponse$: Observable&lt;any&gt; = this.mySubject$.pipe(
  filter(response =&gt; response)
  map(response =&gt; {
     const modifyResponse = response;
    // modify response
    return modifyResponse;
  }),
  take(1)
);
this.httpResponse$.subscribe(response =&gt; console.log(response));

this.myHttpCall().subscribe(response =&gt; this.mySubject$.next(response));
</code></pre>

<p>You can of course wrap the httpResponse$ observable in a method if you need to.</p>
","4693209","","4693209","","2018-03-22 15:52:10","2018-03-22 15:52:10","","","","8","","","","CC BY-SA 3.0"
"49437252","1","","","2018-03-22 19:48:43","","4","1302","<p>I am using the Azure AD adal library to do authentication. There is a call to aquire a token that returns an observable. How can this observable be added into the intercept? In the below example, how can I get the request that is set inside the subscribe to be returned as the Observable?</p>

<pre><code>  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    this.authAzureService.getAccessToken()
    .subscribe(token =&gt; {
      // I need this to be returned
      request = this.getRequestWithHeaders(request, token);
    });

    // This returns the request before the access token is added
    return next.handle(request);
  }
</code></pre>
","1775513","","","","","2018-03-22 20:40:01","Angular HTTP Interceptor how to chain an observable","<angular><rxjs><rxjs5><adal><adal.js>","3","0","1","","","CC BY-SA 3.0"
"49438573","1","","","2018-03-22 21:12:30","","1","379","<p>I want to optimize our <strong>Angular 5.2</strong> (with <strong>RxJS 5.6</strong> and <strong>Angular CLI 1.7.1</strong>) application.</p>

<p>Watching <a href=""https://youtu.be/75ObMlqrhFY?t=16m6s"" rel=""nofollow noreferrer"">this</a> talk by Igor Minar, I wanted to imitate what he is doing. But he is dealing with <code>vanilla JS</code> application + <code>webpack</code> and <code>babel-loader</code> loader. We have <code>ejected Angular CLI</code> application, and there is <code>@ngtools/webpack</code> loader. He is talking about the problems with <code>CommonJS</code> Modules and that you should use <code>ES</code> Modules.</p>

<p><strong>1st sub question: How do I know if we are using CommonJS modules or ES modules?</strong> Igor himself is saying that it's hard. So... what do I do?</p>

<p>If I understand it correctly, he achieves this by adding this piece of configuration into his webpack loader (provided video is set to this moment in talk):</p>

<pre><code>""options"": {
  ""presets"": [
    [""env"", { ""modules"": false }]
  ]
}
</code></pre>

<p>I added it also, but I have no idea what does it do.</p>

<p><strong>2nd sub question: how can I find what options can I use and what do they do?</strong> I was trying to find out by reading webpack <a href=""https://webpack.js.org/configuration/module/#rule-options-rule-query"" rel=""nofollow noreferrer"">documentation</a> but there isn't anything. Is it a <code>loader</code> thing and not a <code>webpack</code> thing? How can I found out please?</p>

<p>After adding mentioned options and <code>ModuleConcatenationPlugin()</code> (also mentioned in the talk, which really helped with the bundle size) I've arrived to this state (webpack bundle analyzer):</p>

<p><a href=""https://i.stack.imgur.com/msdVI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/msdVI.png"" alt=""enter image description here""></a></p>

<p>The text <em>Rx.js 368 modules</em> is achieved thanks to <code>ModuleConcatenationPlugin</code> if I'm not mistaken.</p>

<p>The bundle still seems huge, or am I just crazy? If it is huge, <strong>what am I doing wrong please?</strong>
I checked the whole application and it looks like we are using the imports the correct way:</p>

<pre><code>import { map, filter, scan } from 'rxjs/operators';
import { Observable } from 'rxjs/Observale';
somefunction(): Observable&lt;any&gt; {
  ...
  something.map...
}
</code></pre>

<p><strong>So what am I missing? What am I doing wrong? What should I focus on? Please.</strong></p>
","3701011","","","","","2018-03-22 21:23:34","Angular RxJS 5.6 Pipeable bundle optimization","<angular><webpack><bundle><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49455379","1","49455447","","2018-03-23 17:29:47","","0","56","<p>I have an array with 3 items : </p>

<pre><code>arrActions: Array&lt;Item&gt; = [{ url: 'http://1.com', data: '5' }, 
                           { url: 'http://2.com', data: '6' }, 
                           { url: 'http://3.com', data: '7' }];
</code></pre>

<p>I want to execute an Ajax request for each item. That's no problem . But I also need to know which item am I dealing with in the <code>subscribe</code> callback.</p>

<p>This is what I tried : </p>

<pre><code> from(this.arrActions).pipe(
      mergeMap((i) =&gt; this.ajaxAlike(i)))
      .subscribe(data =&gt; {
        console.log(data)
      });
</code></pre>

<p>This returns :</p>

<p><a href=""https://i.stack.imgur.com/pYJJL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pYJJL.png"" alt=""enter image description here""></a></p>

<p>But I don't know to which request each callback relates to.</p>

<p>So I thought maybe this  : </p>

<pre><code>from(this.arrActions).pipe(  
      mergeMap((i) =&gt;(of({data:i.data, url: this.ajaxAlike(i.url)}))))
      .subscribe(data =&gt; {
        console.log(data)
      });
</code></pre>

<p>But now , the http is not executing :</p>

<p><a href=""https://i.stack.imgur.com/qqnpW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qqnpW.png"" alt=""enter image description here""></a></p>

<p>And besides ,I think I'm going the wrong way here.</p>

<p><a href=""https://stackblitz.com/edit/angular-http-client-8lbrge?file=app/app.component.ts"" rel=""nofollow noreferrer""><strong>Online demo</strong></a></p>

<p><strong>Question:</strong></p>

<p>How can I invoke all urls , and at <code>subscribe</code>, get both <code>http</code> result + <code>item</code> itself ?</p>
","859154","","310726","","2018-03-23 17:42:12","2018-03-23 17:42:12","How can I pass parameters through RXJS chain?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49455447","2","","49455379","2018-03-23 17:35:17","","2","","<p>You can just map each result after you receive it:</p>

<pre><code>from(this.arrActions)
  .pipe(
    mergeMap((i) =&gt; this.ajaxAlike(i)
      .pipe(
        map(result =&gt; ({ data: i.data, result })),
      )
    )
  )
  .subscribe(data =&gt; {
    console.log(data)
  }, err =&gt; {
    console.log(' error which is -&gt;', err);
  });
</code></pre>

<p>This will print the following output:</p>

<pre><code>{data: ""5"", result: ""httpResponse""}
{data: ""6"", result: ""httpResponse""}
{data: ""7"", result: ""httpResponse""}
</code></pre>

<p>You updated demo: <a href=""https://stackblitz.com/edit/angular-http-client-y43j1w?file=app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-http-client-y43j1w?file=app/app.component.ts</a></p>
","310726","","","","","2018-03-23 17:35:17","","","","2","","","","CC BY-SA 3.0"
"49459150","1","","","2018-03-23 22:34:16","","1","2305","<p>I'm getting really confused and wondered if anyone can help me try to understand .subscribe in angular 2 rxjs.</p>

<p>If i have a page with a button to submit some form data, do i need to subscribe in order to post information or use a promise?</p>

<p>As my understanding is when you subscribe, then you click the button again, you will then have 2 instances of the subscribe and so on. Now i know what your going to say, well you can kill the subscription in the destroy or whatever, but that isn't my question. </p>

<p>My question is, if the form is never destroyed until you clicked the home button and the form was clearing upon submit in order to submit some more data, do I need to use Promise over Subscribe? As subscribe (from what I understand) is like a newsletter, the more you click subscribe, the more occurrences of the newsletter you will receive.</p>

<p>So which is best to submit data over and over again, without having multiple subscriptions?</p>

<p>myObsFunc(dataToSend).subscribe(err => console.log(err), () => console.log(success));</p>

<p>or</p>

<p>myObsFunc(dataToSend).toPromise().then().catch(e => console.log(e));</p>
","8250675","","8250675","","2018-04-01 21:54:11","2018-04-01 21:54:11","Angular: Understanding when to subscribe when submitting data","<angular><typescript><angular2-forms><rxjs5><angular2-observables>","2","7","","","","CC BY-SA 3.0"
"49463542","1","49465158","","2018-03-24 10:18:00","","3","1172","<p>I have a queue of tasks (20 in length) where each tasks is an ajax request to be invoked . </p>

<p>I want to : </p>

<p>1) Create chunks of 5       ( 20/5 =4 chunks)<br>
2) Execute each chunk where each <em>item in chunk</em> will be executed with delay of 1000 ms.<br>
3) When each chunks item complete , wait 3 seconds .</p>

<p>So :</p>

<p>1..<sub>1sec( â¦ green)</sub>..2..<sub>1sec( â¦ green)</sub>..3..<sub>1sec( â¦ green)</sub>..4..<sub>1sec( â¦ green)</sub>..5.....................<sub>3sec</sub>..........<br>
6..<sub>1sec( â¦ green)</sub>..7..<sub>1sec( â¦ green)</sub>..8..<sub>1sec( â¦ green)</sub>..9..<sub>1sec( â¦ green)</sub>..10..................... <sub>3sec</sub>..........
...
11..<sub>1sec( â¦ green)</sub>..12..<sub>1sec( â¦ green)</sub>..13..<sub>1sec( â¦ green)</sub>..14..<sub>1sec( â¦ green)</sub>..15..................... <sub>3sec</sub>..........<br>
16..<sub>1sec( â¦ green)</sub>..17..<sub>1sec( â¦ green)</sub>..18..<sub>1sec( â¦ green)</sub>..19..<sub>1sec( â¦ green)</sub>..20</p>

<p>I did manage to do something close : </p>

<p><a href=""https://i.stack.imgur.com/YZJHt.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YZJHt.gif"" alt=""enter image description here""></a></p>

<p>With : </p>

<pre><code>from(this.httpCodes)
      .pipe(bufferCount(5),
       concatMap((i, y) =&gt; from(i).pipe(mergeMap(f =&gt; {
                                    this.httpCodes[f.index].wasExecuted = true;
                                     return this.ajaxAlike(f.data).pipe(
                                                               catchError(() =&gt; { return of(-1) }),
                                                               map((r) =&gt; ({ res: r, data: f }))
                                                                      )
                                                      }) 
                                        ,delay(3000) )),

      )
</code></pre>

<p>But   it doesn't executed as I intended. I don't see delays between each item in chunk   </p>

<p><strong>Question:</strong></p>

<p>Why do I see so many requests , And how can I change my code so that each item in a chunk will be executed with a 1 sec delay (green should be appear after each second) , and - after each chunk , wait 3 seconds?</p>

<p><a href=""https://stackblitz.com/edit/ajax-chunks-alike-rxjs-with-dalay-jmx6py?file=app/app.component.ts"" rel=""nofollow noreferrer""><strong>Online Demo</strong></a></p>
","859154","","859154","","2018-03-24 11:30:22","2018-03-24 17:21:32","Using Rxjs to invoke simultaneous chunks of requests in parallel with delay?","<javascript><angular><rxjs><rxjs5>","2","0","2","","","CC BY-SA 3.0"
"49465158","2","","49463542","2018-03-24 13:20:08","","4","","<p>The <strong>delay</strong> operator delays an emitted item. It seems like you expect it to emit the item and then 'sleep' for 3 seconds before emitting the next. To achieve this you can <strong>concat an empty delayed observable</strong>.</p>

<p>You can create the following <em>pipeable</em> <strong>sleep</strong> operator:</p>

<pre><code>const sleep = ms =&gt; concat(Rx.Observable.empty().pipe(delay(ms)))
</code></pre>

<p>And use it as follows:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const {concatMap, concat, delay, bufferCount} = Rx.operators;

const sleep = ms =&gt; concat(Rx.Observable.empty().pipe(delay(ms)));

const ajaxAlike = call =&gt; Rx.Observable.of(call).pipe(delay(500));

Rx.Observable.range(0, 20).pipe(
  bufferCount(5),
  concatMap(calls =&gt; 
    Rx.Observable.from(calls).pipe(
      concatMap(call =&gt; ajaxAlike(call).pipe(sleep(1000))),
      sleep(3000)
    )
  )
)
.subscribe(console.log)</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.7/Rx.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3306656","","3306656","","2018-03-24 17:21:32","2018-03-24 17:21:32","","","","3","","","","CC BY-SA 3.0"
"49486848","1","","","2018-03-26 08:15:37","","0","178","<p>I have a list of multiple inputs (dynamically generated - unknown number).</p>

<ul>
<li><p>I want each to trigger an ajax request on every keystroke</p></li>
<li><p>I want these ajax requests to be queued up, so only one is sent to
the server at a time, and the next one is sent only after getting a response from the earlier one.</p></li>
<li><p>if new requests are triggered from an input that already has requests in the queue, I want the old ones associated with the same input to be cancelled.</p></li>
<li><p>if new requests are triggered from an input that does <em>not</em> already have inputs in the queue, I want the new requests to just be added to the end of the queue without cancelling anything.</p></li>
</ul>

<p>I'm told that RxJS makes these kinds of complicated async operations easy, but I can't seem to wrap my head around all the RxJS operators.</p>

<p>I have queueing working with a single input below, but I don't really understand why the defer is necessary or how to queue requests for separate inputs while maintaining the switchMap-like behavior I think I want for individual inputs themselves.</p>

<pre><code>Rx.Observable.fromEvent(
    $(""#input""),
    'keyup'
)
.map((event) =&gt; {
    return $(""#input"").val();
});
.concatMap((inputVal) =&gt; {
    return Rx.Observable.defer(() =&gt; Rx.Observable.fromPromise(
        fetch(myURL + inputVal)
    ))
    .catch(() =&gt; Rx.Observable.empty());
})
.subscribe();
</code></pre>
","6186484","","6186484","","2018-03-26 17:11:08","2018-03-26 17:11:08","RxJS - Queueing ajax requests from separate inputs","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49501195","1","","","2018-03-26 21:50:57","","3","1024","

<p>Sometimes we have functions, which modifies original source using async operators like delay.</p>

<p>Lets assume we have something really simple:</p>

<pre class=""lang-js prettyprint-override""><code>// Old syntax
function modify(source) {
   return source.delay(1000);
}
</code></pre>

<p>I am using marbles to test RxJs, so my test looks like: </p>

<pre class=""lang-js prettyprint-override""><code>it(""mock chain style call (modify function)"", function() {
    var values = {
      a: ""test"",
      x: ""test""
    }; 

    var source = hot(    ""-a"", values);
    var delayTime = time( ""--|"");
    var result = cold(   ""---x"", values);

    var originalDelay = Rx.Observable.prototype.delay;
    spyOn(Rx.Observable.prototype, ""delay"").and.callFake(function () { 
       return originalDelay.call(this, delayTime, jm.getTestScheduler()); 
    });

    expect(modify(source)).toBeObservable(result);
});
</code></pre>

<p>It's pretty the same what is used in rxjs library for testing: <a href=""https://github.com/ReactiveX/rxjs/blob/master/spec/operators/delay-spec.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/spec/operators/delay-spec.ts</a></p>

<p>But we have to patch Observable.delay function, because we don't have direct access to it.
And it works good. </p>

<p>But we decided to start using pipeable operators from RxJs. Is there any ideas how test for this function: </p>

<pre class=""lang-js prettyprint-override""><code>// New syntax
function modify(source) {
   return source.pipe(Rx.operators.delay(1000));
}
</code></pre>

<p>could look like?</p>

<p><a href=""https://jsbin.com/zirosah/edit?html,js,output"" rel=""nofollow noreferrer"">JsBin demo</a> </p>
","3745017","","542251","","2020-05-28 13:29:59","2020-05-28 13:30:28","Testing async pipeable operators in RxJS","<rxjs5><jasmine2.0><jasmine-marbles>","1","0","","","","CC BY-SA 4.0"
"49526346","1","49528833","","2018-03-28 04:52:17","","0","475","<p>I'm composing multiple observables using an observable's <code>pipe</code> method and I'd like to emit a final composite value when all observables in the array emit.</p>

<pre class=""lang-js prettyprint-override""><code>import { apiSvc } from '../lib/api-service'

import { of as observableOf } from 'rxjs/observable/of'
import { map } from 'rxjs/operators'

const uris = [
  '/api/items/1',
  '/api/items/2',
  '/api/items/3'
]

observableOf(uris).pipe(
  // Map uris array to an array of observables.
  map((uris) =&gt; calls.map(uri) =&gt; apiSvc.get(uri) /* returns observable*/),
  // Perform magic and emit when all calls complete.
  magic()
)
.subscribe((results) =&gt; {
  console.log(results) // [{id: 1}, {id: 2}, {id: 3}]
})
</code></pre>

<p>I was able to make this work with <code>forkJoin</code>:</p>

<pre class=""lang-js prettyprint-override""><code>import { forkJoin } from 'rxjs/observable/forkJoin'

observableOf(uris).pipe(
  // Map uris array to an array of observables.
  map((uris) =&gt; calls.map(uri) =&gt; apiSvc.get(uri)),
)
.subscribe((requests) =&gt; {
  // Emits when all request observables emit.
  forkJoin(requests).subscribe((results) =&gt; {
    console.log(results) // [{id: 1}, {id: 2}, {id: 3}]
  })
})
</code></pre>

<p>...but I'm looking for a way to get it done in the <code>pipe</code> chain without having to nest <code>subscribe</code> calls.</p>

<p>The <code>zip</code> operator is sort of in the ballpark but it doesn't appear to work on arrays of observables. Is there a lettable operator that works like <code>forkJoin</code> and can be used with <code>pipe</code>?</p>
","1861779","","1861779","","2018-03-28 13:46:04","2018-03-28 13:46:04","RXJS 5 - Emit a single composite value from an array of observables when all sources emit","<rxjs><rxjs5><rxjs-lettable-operators>","1","1","","","","CC BY-SA 3.0"
"49528833","2","","49526346","2018-03-28 07:47:26","","2","","<p>You were very close. You want to return the <code>forkJoin</code>ed Observable inside the chain and wait until it emits with <code>concatMap</code> (<code>mergeMap</code> will work as well here).</p>

<pre><code>observableOf(uris)
  .pipe(
    // Map uris array to an array of observables.
    concatMap(uris =&gt; forkJoin(uris.map(uri =&gt; apiSvc.get(uri))),
  )
  .subscribe((responses) =&gt; {
    ...
  });
</code></pre>
","310726","","","","","2018-03-28 07:47:26","","","","3","","","","CC BY-SA 3.0"
"49533100","1","49533469","","2018-03-28 11:17:17","","0","103","<p>How do I use a method starting a listener on an observable which it returns in an if statement?</p>

<p>I'm in an Angular 5 project, I have this sort of setup in one of my components with an timeline where double click opens up a modal and you can type in the name for the item you're creating into that modal.</p>

<p>for the modals I used a reworked version of <a href=""https://stackoverflow.com/a/46410959/4770754"">this answer</a>. (I needed more up to date syntax and imports).</p>

<p>I've got it all nearly working now, here's my setup,</p>

<p>(timeline component which opens the modals) :</p>

<pre><code>@Component({
  selector: 'app-planning',
  templateUrl: './planning.component.html',
  styleUrls: ['./planning.component.css']
})
export class PlanningComponent implements AfterViewInit {

  options = {
    onAdd: (item, callback) =&gt; {
      if(this.timeline.getCurrentTime() &gt; item.start){

        this.errorTimelineItemModal();
        callback(null);

      } else {
          if (this.createNewTimelineItemModal()) { // &lt;-- currently I have no return but
                                                  //   having one would be meaningless
                                                 // anyways because the if wouldn't wait
                                                // for the observable response and as a
                                               // result, it would always assess false.
          callback(item);

        } else callback(null);
      }
    }
  }


  constructor(
      private _element: ElementRef,
      private modalService: BsModalService
  ) {}

  ngAfterViewInit(){
    this.container = this._element.nativeElement.querySelector('#timeline');
    if (!this.items) {
      this.items = new vis.DataSet(this.mydataset);
      this.timeline = new vis.Timeline(this.container, this.items, this.groups, this.options);
    }
  }

  createNewTimelineItemModal() {
    const initialState = {
      title: 'Ajouter',
      multipleChoice: 'Bid',
      choices: ['Bid', 'D.C.', 'Kickoff'],
      accceptBtnName: 'Ajouter',
      closeBtnName: 'Annuler',
    };
    this.bsModalRef = this.modalService.show(Modal, {initialState});
    this.bsModalRef.content.onClose.subscribe(result =&gt; {
        this.createItemResult = result;
        console.log(JSON.stringify(result));
    })
  }

  updateTimelineItemModal(name) {
    const initialState = {
      title: 'Nouveau Nom ?',
      itemCurrentName: name,
      accceptBtnName: 'Rennomer',
      closeBtnName: 'Annuler',
    };
    this.bsModalRef = this.modalService.show(Modal, {initialState});
    this.bsModalRef.content.onClose.subscribe(result =&gt; {
        this.createItemResult = result;
        console.log(JSON.stringify(result));
    })
  }

  deleteTimelineItemModal() {
    const initialState = {
      title: 'Ãtes-vous sÃ»r de vouloir supprimer cet element?',
      accceptBtnName: 'Supprimer',
      closeBtnName: 'Annuler',
    };
    this.bsModalRef = this.modalService.show(Modal, {initialState});
    this.bsModalRef.content.onClose.subscribe(result =&gt; {
        this.createItemResult = result;
        console.log(JSON.stringify(result));
    })
  }

  errorTimelineItemModal() {
    const initialState = {
      title: 'Erreur',
      list: ['DÃ©solÃ©, crÃ©er des Ã©lÃ©ments avant la date d\'aujourd\'hui est dÃ©sactivÃ©']
    };
    this.bsModalRef = this.modalService.show(Modal, {initialState});
    this.bsModalRef.content.onClose.subscribe(result =&gt; {
        this.createItemResult = result;
        console.log(JSON.stringify(result));
    })
  }
}
</code></pre>

<p>(modal component) :</p>

<pre><code>export class Modal implements OnInit {

  onClose: Subject&lt;Object&gt;;

  constructor(
    private formBuilder: FormBuilder,
    public _bsModalRef: BsModalRef) {}

  ngOnInit(): void {
    this.onClose = new Subject();
  }

  public onConfirm(): void {
    this.onClose.next(true);
    this._bsModalRef.hide();
  }

  public onCancel(): void {
     this.onClose.next(false);
     this._bsModalRef.hide();
  }
}
</code></pre>

<p>As you can see I am getting an answer from validating or not the modal. I can console log it.</p>

<p>Now is where I'm stuck. How can I get the code execution to just halt until an observable has been received by that method so as to assess correctly within the if?</p>

<p>this is actually very important for the correct execution of my code because the <code>callback(null);</code> and <code>callback(item);</code> that you might have noticed are the syntaxe one must have to either finalize the item creation or prevent it.</p>

<p>see : <a href=""http://visjs.org/docs/timeline/#Methods"" rel=""nofollow noreferrer"">http://visjs.org/docs/timeline/#Methods</a></p>

<p>I had this working with alerts but I'm trying to switch to something with more functionalities and cleaner.</p>
","4770754","","4770754","","2018-03-28 11:23:16","2018-03-28 11:35:33","need to know when answer received by function that listens to rxjs Observable","<javascript><angular><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49533469","2","","49533100","2018-03-28 11:35:33","","1","","<p>If I can understand you correctly, you need to synchronize two separate events. It is usually a bad practice to do so.</p>

<p>Try to re-organise your code. It is an async process, so you should divide the process into sub-""transactions"", that can happen separately. </p>

<ol>
<li>Separate the logic for opening up your modal. </li>
<li>Wait for the user to enter the data</li>
<li>Process the answer from the modal.</li>
</ol>

<p>Something like this:</p>

<pre><code>  createNewTimelineItemModal() {
    const initialState = {
    ... 

    this.bsModalRef.content.onClose.subscribe(result =&gt; {
        this.createItemResult = result;
        this.continueToCreateItem(result);
      });
    }

  private continueToCreateItem(result: any){
    &lt;insert your code here&gt;
  }
</code></pre>

<p>Or other solution can be to return observable objects and hande it within the onAdd</p>

<pre><code>options = {
    onAdd: (item, callback) =&gt; {
    ...
          this.createNewTimelineItemModal().subscribe(result =&gt; {
             if(result is something){
              callback(item);
             } else callback(null);
         }
      }
    }
  }
</code></pre>

<p>To ""halt"" the process is a pretty bad practice, but can be achived with <a href=""https://basarat.gitbooks.io/typescript/docs/promise.html"" rel=""nofollow noreferrer"">Promise</a> object.</p>

<pre><code>this.myPromiseReturningMethod(params).then(() =&gt; {
</code></pre>

<p>but this will block all your application for the time being (with the user being unable to do anything) so I recommend to alter the structure instead.</p>
","3486691","","","","","2018-03-28 11:35:33","","","","7","","","","CC BY-SA 3.0"
"49552698","1","","","2018-03-29 09:38:37","","0","167","<p>I'm doing a paginator with RxJS, I use a subject to centralize any time a new page is called. And on each event, I use exhaustMap to retrieve the page. That's prevent the getPage http call to be fired several time for the same page.</p>

<pre><code>this._nextPage$.pipe(
    exhaustMap(nextPageNumber =&gt; this.getPage(nextPageNumber))
).subscribe();
</code></pre>

<p>But I'd like to also show a spinner on each http pending.</p>

<p><strong>With this code, how to reach the subscription of the merged http Observable ?</strong>
(in order to bind a pending component to the subscription)</p>

<p>Thx in advance !</p>

<hr>

<p>[EDIT]</p>

<p>I need/prefer using a Subscription that hold the pending state itself for 2 main reasons:</p>

<ul>
<li>I already use several custom components/directives based on Subscription</li>
<li>As it's used in many different places I hopped to manage the pending state without too much boilerplate code ...</li>
</ul>

<p>Here is a simple example of component displaying pending action</p>

<pre><code>@Component({
  selector: 'anie-busy',
  templateUrl: './busy.component.html',
  styleUrls: ['./busy.component.scss']
})
export class BusyComponent implements OnChanges {

  @Input() subscription;
  isPending = false;

  constructor() { }

  ngOnChanges() {
    if (this.subscription) {
      this.isPending = true;
      this.subscription.add(() =&gt; this.isPending = false);
    } else {
      this.isPending = false;
    }
  }

}
</code></pre>
","4092518","","4092518","","2018-04-03 16:04:15","2018-04-03 16:04:15","Is there a way to reach the subscription of a merged Observable (mergeMap/concatMap/exhaustMap)","<rxjs><rxjs5>","1","0","","","","CC BY-SA 3.0"
"49562074","1","49576806","","2018-03-29 17:34:05","","1","249","<p>I know this has been asked a few times but I cant find a solution that actually works in Angular 5 with rxjs5.</p>

<p><strong>TL;DR;</strong>
How do I get these 4 observables to run synchronously in sequence:</p>

<pre><code>    const getImage$ = this.fileService.getImage(this.shape.imageFile.id);
    const getUrl$ = Observable.create((blob: Blob) =&gt; {
        return URL.createObjectURL(blob);
    });
    const fromURL$ = Observable.bindCallback(fabric.Image.fromURL);
    const addImage$ = Observable.create((img: any) =&gt; {
        this.shapeElement = img;
        this.shapeGroup = new fabric.Group([this.shapeElement], {
            lockScalingFlip: true,
            centeredRotation: true,
            angle: this.shape.rotation
        });
        this.fabric.add(this.shapeGroup);
    } );
</code></pre>

<p>and then return the Observable so I can do more things in the subscriber.</p>

<p>Longer version...</p>

<p>I have a file service that requests an image and returns an observable for the blob:</p>

<pre><code>getImage(id) =&gt; Observable&lt;Blob&gt;
</code></pre>

<p>I then need to get the url for this blob:</p>

<pre><code>URL.createObjectURL(blob)
</code></pre>

<p>THen I need to load this to a FabricJS canvas, which has a func with a callback.  I create and observable from this:</p>

<pre><code>fromURL = Observable.bindCallback(fabric.Image.fromURL)
</code></pre>

<p>Lastly, I need to fiddle with the image object that is created by Fabric before I return the observable - the subscription has more stuff to update the ui.</p>

<pre><code>this.shapeGroup = new fabric.Group([this.shapeElement], {
   lockScalingFlip: true,
   centeredRotation: true,
   angle: this.shape.rotation,
   tag: Date.now()
  });
this.shapeGroup.shapeView = this;
this.shapeGroup.setShadow(this.getShadow());
this.canvas.fabric.add(this.shapeGroup);
</code></pre>

<p>This is where I get lost.  I've tried to understand mergeMap and map and pipe and a few other things but I cant get this working.</p>

<p>Has anyone here done this sort of thing before?  This does seem overly complex to achieve.</p>

<p>Ive got this for a start:</p>

<pre><code>draw(): Observable&lt;ImageView&gt; {  

  const fromURLOb = Observable.bindCallback(fabric.Image.fromURL);

  return Observable.create(o =&gt; {
    if (this.shape.imageFile) {
      console.log('started loading');               
      o.next(this.fileService.getImage(this.shape.imageFile.id));
    }
    o.complete();
  })
 ...
</code></pre>

<p>which works, but after than Im lost.  </p>

<p><strong>Solution!</strong></p>

<p>Thanks to @Ingo, this is my working version.</p>

<pre><code>    draw(): Observable&lt;ImageView&gt; {
      return this.fileService.getImage(this.shape.imageFile.id)
        .map(blob =&gt; URL.createObjectURL(blob))
        .switchMap&lt;string, any&gt;(url =&gt; {
            return Observable.bindCallback(fabric.Image.fromURL).call(this, url);
        })
        .do&lt;ImageView&gt;(image =&gt; {
            this.handleImage(image);
            return this;
        });
}
</code></pre>
","98406","","98406","","2018-03-31 02:46:03","2018-03-31 02:46:03","Chaining observables","<fabricjs><angular5><rxjs5>","1","0","1","","","CC BY-SA 3.0"
"49576806","2","","49562074","2018-03-30 15:09:07","","2","","<p>There are a few things going on here:</p>

<ol>
<li><code>URL.createObjectURL</code> actually is just a synchronous function, it doesn't return an observable. Thus you just use <code>map</code> to map the result from <code>getImage</code> to the URL.</li>
<li>The <code>fromUrl</code> call does use a callback, so you can use <code>bindCallback</code> as you did; however, <code>bindCallback</code> doesn't return an observable (as you indicate), instead it returns a function that returns an observable. So you need to call that function with the URL you got; you can either use <code>switchMap</code> or one of its variants in the chain here; since you only deal with ""emits once and completes"" observables, the differences between these variants don't matter much.</li>
<li>The final handling you are doing are actually just a side effect that doesn't affect the value you want to return, thus you can just use a <code>do</code> operator to execute a side effect.</li>
<li>Your usage of <code>Observable.create</code> suggests some misunderstanding. The function passed into <code>Observable.create</code> <em>always</em> receives an observer as the parameter, not some value. I think you're confusing functions and observables here.</li>
</ol>

<p>As a result, you can do this:</p>

<pre class=""lang-js prettyprint-override""><code>private handleImage(img: any) {
    this.shapeElement = img;
    this.shapeGroup = new fabric.Group([this.shapeElement], {
        lockScalingFlip: true,
        centeredRotation: true,
        angle: this.shape.rotation
    });

    this.fabric.add(this.shapeGroup);
}

draw() {
  return this.fileService.getImage(this.shape.imageFile.id)
    .map(blob =&gt; URL.createObjectURL(blob))
    .switchMap(url =&gt; Observable.bindCallback(fabric.Image.fromURL)(url))
    .do(image =&gt; this.handleImage(image));
}
</code></pre>
","1675492","","","","","2018-03-30 15:09:07","","","","4","","","","CC BY-SA 3.0"
"49596583","1","49596891","","2018-04-01 09:17:32","","0","51","<p>I am using angular 5.2.9 and angularfire to access my firestore database. When I call a function on load.service.ts it runs the following function  block with a argument of status and returns an observable; this gets assigned to an observable in the calling component. This works perfectly if you navigate to the component for the first time since the default status is ""Active"". If you set the status to ""Complete"" I don't get any results.</p>

<p>*****************Component.ts ****************</p>

<pre><code>//this is inside the constructor
private loads = new BehaviorSubject&lt;Load[]&gt;(new Array&lt;Load&gt;());
public currentLoads = this.loads.asObservable();

this.userService.currentUser.subscribe(user =&gt; {
  this.user = user;
  //loadsService depends on user
  this.loadsObservable = this.loadService.getLoads(""Active"");
  this.loadsObservable.subscribe(loads =&gt; {
    this.loads = loads;
  });
});


//this gets fired by a button group  
onChangeFilter(event: any){
  this.loadsObservable = this.loadService.getLoads(this.currentStatus);
}
</code></pre>

<p>*************** load.service.ts *****************</p>

<pre><code>getLoads(status: string){
  const loadCollection = this.afs.collection&lt;Load&gt;('loads');
  loadCollection.ref.where(""status"", ""=="", status).where(""driver/id"",""=="", this.user.id)
  return loadCollection.valueChanges();
});
</code></pre>
","9581414","","4256274","","2018-04-01 10:00:22","2018-04-01 10:00:22","Why doesnt my subcribed variable update when observable is updated?","<angular><firebase><angularfire2><rxjs5>","1","5","","","","CC BY-SA 3.0"
"49596891","2","","49596583","2018-04-01 09:59:53","","0","","<p>That's because in <code>onChangeFilter</code> you exchanged the references in <code>this.loadsObservable</code>, but you've subscribed only to the first one in the constructor. The second isn't subscribed to, so the emitted items never appear in your view.</p>

<p>I assume you are using <code>currentLoads</code> in your template with <code>async</code> pipe. In that case you can directly in <code>onChangeFilter</code> have eg. this code:</p>

<pre><code>onChangeFilter(event: any) {
  this.currentLoads = this.loadService.getLoads(this.currentStatus)
                                      .switch();
}
</code></pre>

<p>That way you get the inner Observable (the loads themselves) from the outer Observable you get out of <code>getLoads</code> call. Each time the outer emits, the subscription to the previous inner Observable is dropped thanks to the <code>switch</code> operator, more on that <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switch"" rel=""nofollow noreferrer"">here</a>. With this approach, you don't need to subscribe manually or have auxiliary varibles like your <code>private loads</code>.</p>
","4256274","","","","","2018-04-01 09:59:53","","","","1","","","","CC BY-SA 3.0"
"49630053","1","49635712","","2018-04-03 12:25:36","","2","303","<p>I am experiencing some interesting behaviour regarding a subscription on a collection's valueChanges.</p>

<p>Immediately after creating a doc, the collection's subscription is invoked, but <strong>instead of an array of many documents I am only receiving an array of size one</strong> - the single, newly created document.  </p>

<p>After having a read through this <a href=""https://firebase.google.com/docs/firestore/query-data/listen#events-local-changes"" rel=""nofollow noreferrer"">(Firestore Docs | Get Realtime Updates)</a> I am still slightly confused.</p>

<blockquote>
  <p>Local writes in your app will invoke snapshot listeners immediately. This is because of an important feature called ""latency compensation."" When you perform a write, your listeners will be notified with the new data before the data is sent to the backend.</p>
</blockquote>

<p>Does this explain the behaviour I am seeing?</p>

<hr>

<p>Here is a <a href=""https://stackblitz.com/edit/angular-firebase-subscription-test"" rel=""nofollow noreferrer"">stackblitz</a> demonstrating the problem. Just uncomment out the commented line in ngOnInit() and reload to see what I believe is expected behaviour.</p>

<hr>

<p><em>I can solve this by either having an empty subscription listening to this collection elsewhere, or duplicating the take(1) subscription code directly before</em></p>
","8718715","","","","","2018-04-04 11:21:45","Unexpected Firebase Firestore collection subscription behaviour","<javascript><angular><rxjs><rxjs5>","2","0","0","","","CC BY-SA 3.0"
"49635712","2","","49630053","2018-04-03 17:13:11","","1","","<p>Thats a good catch. Pretty sure you are right - <code>valueChanges()</code> as docs states:</p>

<blockquote>
  <p>The current state of your collection. Returns an Observable of data as
  a synchronized array of JSON objects.</p>
</blockquote>

<p>And as you found yourself:</p>

<blockquote>
  <p>Local writes in your app will invoke snapshot listeners immediately.</p>
</blockquote>

<p>So this is what happens:</p>

<p>Your <code>addPizza()</code> is an <strong>async</strong> function. It sends request to backed to add new pizza. But it doesnt wait for anything and jumps to your second function - <code>this.getPizzasAsyncAwait()</code>. And because that local write invokes listener immediately, your Observable emits that value and broadcasts it. And since you also use Rxjs's <code>take(1)</code> - after that it unsubscribes. That also explains why <code>take(2)</code> brings all other records. You can move your <code>getPizzasNormal()</code> method to <code>OnInit()</code> and you'll receive the whole collection.  </p>
","4554116","","4554116","","2018-04-03 17:20:36","2018-04-03 17:20:36","","","","2","","","","CC BY-SA 3.0"
"49639127","1","49639216","","2018-04-03 21:04:17","","2","81","<p>I've create an Http request to get json data. Inside that json - there is an object which has an array. ( I need that array).</p>

<pre><code>fromDb$ = of({
    Result: {
      Countries: [{      &lt;--wanted array
        ISOCode: 1,
        Name: 'aaa'

      }, {
        ISOCode: 2,
        Name: 'bbb'

      }]
    }
  });
</code></pre>

<p>But- the data in  the array  has a different structure than I actually need. </p>

<p>I need to map (<code>name</code> &amp;<code>ISOcode</code>) to (<code>name</code> and <code>value</code>  )</p>

<p>This is what I've tried:</p>

<ul>
<li>Use <code>pluck</code> to extract the inner Array</li>
<li><code>mergeMap</code> the array object to a stream of objects (using <code>of()</code>)</li>
<li>using <code>map</code> to transform each item to a desired structure</li>
<li>using <code>toArray</code> to wrap all to an array ( so I can bind it to a control)</li>
</ul>

<p>Here is the actual code : </p>

<pre><code>this.data = this.fromDb$.pipe(pluck&lt;PtCountries, Array&lt;Country&gt;&gt;('Result', 'Countries'), 
                                mergeMap(a =&gt; from(a)),
                                map((c: Country) =&gt; ({
                                  name: c.Name,
                                  value: c.ISOCode,
                                })),
                              toArray());
</code></pre>

<p>The code does work and <a href=""https://stackblitz.com/edit/angular-goqrxl?file=app%2Fapp.component.ts"" rel=""nofollow noreferrer""><strong>here is the online demo</strong></a> </p>

<p><strong>Question</strong></p>

<p>It looks like I've complicated it much more than it can be ,Is there a better  way of doing it? </p>
","859154","","859154","","2018-04-03 21:27:42","2018-04-06 13:36:33","Reduce number of operators in an RxJS mapping expression","<javascript><angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"49639216","2","","49639127","2018-04-03 21:12:22","","5","","<p>This line: <code>mergeMap(a =&gt; from(a))</code> does not make a lot of sense. It's almost as if you did <code>[1,2,3].map(v =&gt; v)</code>. You can just remove it.</p>

<p>To simplify this you basically need to use Array.map inside Observable.map.</p>

<p>Try this:</p>

<pre><code>this.data = this.fromDb$.pipe(pluck&lt;PtCountries, Array&lt;Country&gt;&gt;('Result', 'Countries'),
  map((countries: Country[]) =&gt; countries.map(country =&gt; ({
    name: country.Name,
    value: country.ISOCode,
}))));
</code></pre>

<p><a href=""https://stackoverflow-reduce-number-of-operators.stackblitz.io"" rel=""nofollow noreferrer"">Live demo</a></p>
","5594389","","5594389","","2018-04-06 13:36:33","2018-04-06 13:36:33","","","","0","","","","CC BY-SA 3.0"
"49674827","1","49728690","","2018-04-05 14:24:57","","1","442","<p>I found the docs for the old <code>case</code> operator here: <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/case.md"" rel=""nofollow noreferrer"">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/case.md</a></p>

<p>It is not listed in the migration guide:
<a href=""https://github.com/ReactiveX/rxjs/blob/stable/MIGRATION.md"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/stable/MIGRATION.md</a></p>

<p>Is there some combination of supported operators that would provide the same functionality?</p>
","4237830","","","","","2018-04-09 08:35:20","Is there an equivalent to the RxJS v4 case operator in RxJS v5?","<rxjs5>","1","0","1","","","CC BY-SA 3.0"
"49683600","1","53347696","","2018-04-06 00:43:28","","24","8223","<p>In the following code:-</p>

<pre><code>RxJS.Observable.of(1,2).first().subscribe((x) =&gt; console.log(x););
</code></pre>

<p>is it necessary to unsubscribe given the operator <code>first()</code>?</p>
","2103767","","2103767","","2018-04-06 11:45:23","2020-11-10 09:41:24","Any need to call unsubscribe for RxJS first()","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"49714425","1","","","2018-04-08 04:29:20","","2","32","<p>I am making an API call using the HttpClient in Angular. It returns a JSON array of User.</p>

<pre><code>users$ = this.httpClient.get&lt;User[]&gt;('api1')
</code></pre>

<p>I am showing the users (name and email) using the async pipe in the template.</p>

<pre><code>&lt;div *ngFor=""let user user of users$ | async""&gt;
&lt;h1&gt;{{user.name}}&lt;/h1&gt;
&lt;h2&gt;{{user.email}}&lt;/h2&gt;
&lt;/div&gt;
</code></pre>

<p>Now, for every user, I need to make another (different) API call to get the user's picture URL. How can I efficiently </p>

<ol>
<li>Save the picture URL in the users$</li>
<li>Show the picture in the template (img tag)</li>
</ol>

<p>I don't want to get the images along with the user name and email</p>
","5030144","","5377805","","2018-04-08 04:32:04","2018-04-08 14:27:50","Add a property to every array element returned in observable","<angular><rxjs5><angular-httpclient>","1","1","","","","CC BY-SA 3.0"
"49728690","2","","49674827","2018-04-09 08:35:20","","1","","<p>RxJS v4 <code>Rx.Observable.case(selector, sources, [elseSource|scheduler])</code>, example given is</p>

<pre class=""lang-js prettyprint-override""><code>var sources = {
    'foo': Rx.Observable.return(42),
    'bar': Rx.Observable.return(56)
};

var defaultSource = Rx.Observable.empty();

var source = Rx.Observable.case(
    function () {
        return 'foo';
    },
    sources,
    defaultSource);
</code></pre>

<p>I guess you could could do this in RxJS v5</p>

<pre class=""lang-js prettyprint-override""><code>var sources = {
    'foo': Rx.Observable.return(42),
    'bar': Rx.Observable.return(56)
};

var defaultSource = Rx.Observable.empty();

var source = Rx.Observable.of('foo')
  .mergeMap(srcName =&gt; {
    const src = sources[srcName];
    return src || defaultSource;
  })
</code></pre>

<p>Would be interested to know where you are using / want to use this operator.</p>
","4716245","","","","","2018-04-09 08:35:20","","","","2","","","","CC BY-SA 3.0"
"49733720","2","","49100844","2018-04-09 13:05:50","","3","","<p>I did find out the issue, here is the resulting code:</p>

<pre><code>import {Inject, Injectable} from '@angular/core';
import {
    HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpErrorResponse, HttpClient
}
    from '@angular/common/http';

import {Observable, ObservableInput} from 'rxjs/Observable';
import {CustomerService} from ""../customer/customer.service"";
import * as ApplicationSettings from ""application-settings"";
import {catchError, switchMap, finalize} from ""rxjs/operators"";
import {LoginResponse} from ""./LoginResponse"";
import {APP_CONFIG, AppConfig} from ""../../app.config"";
import {RouterExtensions} from ""nativescript-angular/router"";

/**
 * This takes a request that requires an access_token and refreshes it on 401 errors.
 * @TODO What happens on 400 errors?
 */
@Injectable()
export class RefreshTokenInterceptor implements HttpInterceptor {

    isRefreshingToken: boolean = false;

    public constructor(private customer: CustomerService,
                       private http: HttpClient,
                       private router: RouterExtensions,
                       @Inject(APP_CONFIG) private config: AppConfig) {}

    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        let validate = {
            is_api_v1: req.url.indexOf('api/v1') &gt; -1,
            is_not_register_end_point: !(req.url.indexOf('api/v1/customers') &gt; -1 &amp;&amp; req.method === 'POST')
        };

        if (validate.is_api_v1 &amp;&amp; validate.is_not_register_end_point) {
            return next.handle(req).pipe(
                catchError((err, caught) =&gt; {
                    if (err instanceof HttpErrorResponse &amp;&amp; err.status === 401) {
                        console.log(req.url);
                        console.log('Injecting Refresh Token');

                        return this.handle401Error(req, next);
                    }

                    // return caught;
                })
            );
        } else {
            return next.handle(req);
        }

    }

    handle401Error(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
        //-- Test if we are refreshing so we are not stuck in an infinite loop
        if (!this.isRefreshingToken) {
            this.isRefreshingToken = true;

            let refresh_token = ApplicationSettings.getString('refresh_token');
            let refresh = this.customer.refreshToken(refresh_token);

            return refresh.pipe(
                switchMap((tokenResp: LoginResponse) =&gt; {
                    this.customer.setToken(tokenResp);

                    let access_token = ApplicationSettings.getString('access_token');
                    let headers = req.headers.set('Authorization', `Bearer ${access_token}`);

                    return next.handle(req.clone({headers: headers}));
                }),
                catchError(error =&gt; {
                    ApplicationSettings.setBoolean(""authenticated"", false);
                    this.router.navigate([""/login""], { clearHistory: true, queryParams: {
                        error: 'Your session is no longer valid, please log in again',
                    }});

                    return Observable.throw("""");
                }),
                finalize(() =&gt; {
                    this.isRefreshingToken = false;
                })
            )
        }
    }
}
</code></pre>
","134617","","","","","2018-04-09 13:05:50","","","","0","","","","CC BY-SA 3.0"
"49735826","1","49742144","","2018-04-09 14:50:22","","20","16216","<p>I'm trying to trigger a callback when all my observables are executed. In my other, older project i used <code>finally</code> like so and that worked like a charm:</p>
<pre class=""lang-js prettyprint-override""><code>this.myService.callDummy()
  .finally(() =&gt; console.log('Works!'))
  .subscribe(result =&gt; ...)
</code></pre>
<p>But now I'm using a newer version of RxJS with <strong>Pipeable operators</strong>, but the <code>finally</code> call (now renamed to <code>finalize</code>) never gets executed. There is little information to be found and I'm not sure what I'm doing wrong.</p>
<pre class=""lang-js prettyprint-override""><code>combineLatest(
  this.route.queryParams,
  this.myService.callDummy1(),
  this.myService.callDummy2()
)
.pipe(finalize(() =&gt; console.log('Does not work!')))
.subscribe(results =&gt; ...);
</code></pre>
<p>Any help is appreciated.</p>
","7506820","","6595016","","2020-08-31 18:43:08","2020-09-01 15:15:08","RxJS5 finalize operator not called","<angular><rxjs><observable><rxjs5>","3","5","5","","","CC BY-SA 4.0"
"49742144","2","","49735826","2018-04-09 21:45:18","","29","","<p>In observables, firing and completing are not the same thing.</p>
<p>Even though each of the items emits a value, route.queryParams by definition will never complete since that is how Angular implements it, as a non terminating observable. You will need to manually complete it for your finalize to execute since combineLatest will only complete when EVERY observable being combined inside of it has completed.</p>
<pre class=""lang-js prettyprint-override""><code>combineLatest(
  this.route.queryParams.pipe(take(1)), // take(1) will complete the observable after it has emitted one value
  this.myService.callDummy1(),
  this.myService.callDummy2()
)
.pipe(finalize(() =&gt; console.log('Does not work!')))
.subscribe(results =&gt; ...);
</code></pre>
<p>This will complete.</p>
","4855306","","10871073","","2020-09-01 15:15:08","2020-09-01 15:15:08","","","","9","","","","CC BY-SA 4.0"
"49753065","1","49774144","","2018-04-10 11:58:30","","1","484","<p>let's say for instance I have an observable emiting at x0 emitions per second (maybe 50, 60, ...) sometimes and sometimes it's just 1 or 2 emitions per second.</p>

<p>Now how can I Buffer those fast emitions and still handling slow ones.</p>

<p>What I tired:</p>

<p>BufferTime needs a time span, so even if one emition it will be bufferd, (plus BufferTime makes protractor tests timeout).</p>

<p>BufferCount(x) doesn't emit until all x emitions are received.</p>
","1543885","","","","","2020-06-26 16:28:27","Rxjs buffer when source emitions rate is fast","<rxjs><rxjs5>","2","7","","","","CC BY-SA 3.0"
"49774144","2","","49753065","2018-04-11 11:38:07","","1","","<p>Sounds like you want something similar to debounce + buffer. The simplest implementation of that is to use a debounce of the stream to trigger emiting the buffer of that same stream. You may want to share the stream to prevent duplicate subscriptions. Here is a running example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const source = new Rx.Observable.create((o) =&gt; {
  let count = 0;
  const emit = () =&gt; {
    const timeout = Math.random() * 1000;
    setTimeout(() =&gt; {
      o.next(count++);
      if (count &lt; 20) {
      	emit();
      } else {
        o.complete();
      }
    }, timeout);
  };
  emit();
}).share();

const triggerBuffer = source.debounceTime(500);
source.buffer(triggerBuffer).subscribe((x) =&gt; { console.log(x); });</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.9/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Note that the debounce does not have an upper limit in that it wont emit if it continues to receive values under the debounce time. Practically this shouldn't make a difference in your scenario but in other scenarios it theoretically could.</p>
","959745","","","","","2018-04-11 11:38:07","","","","0","","","","CC BY-SA 3.0"
"49783568","1","49784212","","2018-04-11 20:00:57","","1","102","<p>I am wondering if there was way to wrap an observable around <code>sessionStorage.getItem('currentuser')</code> so calling code can subscribe and gets the value only after it is set in the <code>sessionStorage</code></p>

<p>Is this possible?</p>

<p>Anand</p>
","4603068","","4603068","","2018-04-11 20:21:02","2018-04-12 17:29:18","How to return a value with observable when it becomes defined?","<angular><rxjs5>","1","3","","","","CC BY-SA 3.0"
"49784212","2","","49783568","2018-04-11 20:47:26","","1","","<p>Of course you can. You could solve it this way with a Service</p>

<pre><code>import {Subject} from 'rxjs/Subject';
import {Observable} from 'rxjs/Observable';

@Injectable()
export class StorageService {

    private storageAlert: Subject&lt;any&gt; = new Subject('');
    private propagationIsBlocked: false;

    // use this blocker for option 3
    blockPropagation(): void {
        propagationIsBlocked = true;
    }

    // use this unblocker for option 3
    unblockPropagation(): void {
        propagationIsBlocked = false;
    }

    // subscribe to this method in order to get updated whenever a change happens
    getValue(): Observable&lt;any&gt; {
        return this.storageAlert.asObservable();
    }

    // trigger the update &lt;&lt; option1
    setValue(value: any) {
        if(value){
            this.sessionStorage.setItem('key', 'value');
            this.storageAlert.next(value);
       } 
    }

    // trigger the update &lt;&lt; option2
    setValue(value: any) {
        if(value &amp;&amp; value.id !== storageAlert.getValue().id){
            this.sessionStorage.setItem('key', 'value');
            this.storageAlert.next(value);
       }
    }

    // trigger the update &lt;&lt; option3
    setValue(value: any) {
        if(!this.propagationIsBlocked){
            this.sessionStorage.setItem('key', 'value');
            this.storageAlert.next(value);
        }
    }
}
</code></pre>

<p>But honestly speaking, if you use this Service you do not need the sessionStorage or localStorage as the value is already stored in the Service's variable 'storageAlert'. And each Subscribing Instance gets the new value due to the subscription. </p>
","","user6749601","","user6749601","2018-04-12 17:29:18","2018-04-12 17:29:18","","","","3","","","","CC BY-SA 3.0"
"49788228","1","","","2018-04-12 04:52:30","","0","2377","<p>I use  to change dynamic child component in body and keep static header, bottom and menu. 
My problem: When use BehaviorSubject as shared-data between components, then UI (*ngFor) not be updated event shared-data transferred well. I am using Angular 5.2.0, RxJs 5.5.6</p>

<p>My app has flow:
user click search button on Layout-top.component.ts -> fetch data from Backend server by Home.service.ts-> set data in BehaviorSubject object.</p>

<p>On Home.component.ts constructor always subscribe shared-data from Home.service.ts -> change data of Home.component.ts -> display them.
1. App.compoenet.ts </p>

<pre><code>  @Component({
  selector: 'xxx',
  template:
    `
    &lt;gotop position=""200""&gt;&lt;/gotop&gt;  
    &lt;layout-top&gt;&lt;/layout-top&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
    &lt;layout-bottom&gt;&lt;/layout-bottom&gt;
    `
})

export class AppbComponent implements OnInit, AfterViewInit{

    public ngAfterViewInit(): void {
        this.spinner.hide();           
    }

    message:string;

    constructor(private spinner:Spinner){

    }
    public ngOnInit(){
        this.spinner.show();
    }

}
</code></pre>

<ol start=""2"">
<li><p>Layout-top.component.ts </p>

<p>public doSearch(){<br>
    let filter = {
        xx:'XXX'
    };<br>
    this.homeService.setData(filter);<br>
 }</p></li>
</ol>

<p>3.Home.service.ts</p>

<pre><code>@Injectable()
export class HomeService extends BaseService{
    public data =new BehaviorSubject&lt;DataType&gt;(&lt;DataType&gt;{});
    public eventFilter: EventEmitter&lt;{}&gt; = new EventEmitter();
    public constructor(private http: HttpClient, 
            private _const: Const,
            private util:Util,
            private appref: ApplicationRef) {
       super(_const, util);
    }

    public listProduct(filter):Observable&lt;any&gt;{
        const url = url to my backend api
        let headers:HttpHeaders = this.util.header(this._const, null, 'application/json');
        return this.http.post(
            url,
            filter,
            {headers})
            .map(res =&gt; {
                return res;
            });
    }

    public getData():Observable&lt;DataType&gt;{
        return this.data.asObservable();   
    }

    public setData(filter:any):void {
        const listProduct$ = this.listProduct(filter);
        listProduct$.subscribe(res =&gt; {
            this.data.next({res:res, filter:filter});
        });
    }
    public cleanData() {
        this.data.next(null);
    }
}
</code></pre>

<ol start=""4"">
<li>layout-top.html</li>
</ol>

<p></p>

<p>5.home.html</p>

<pre><code>  &lt;div class=""product-item""
            *ngFor=""let item of listProducts""&gt;
     &lt;!--display some thing here--&gt;
&lt;/div&gt;
</code></pre>

<p>6.home.component.ts</p>

<pre><code> constructor(private service: HomeService,               
                private cdRef:ChangeDetectorRef,
                private zone:NgZone,private appref: ApplicationRef ){

        this.subsListProduct = this.service.getData().subscribe(obj=&gt;{
            this.zone.run(()=&gt;{
                $(""#in-blur"").css(""display"", ""block"");
                if(!obj){
                    return;
                }
                const res = obj.res;
                const filter = obj.filter;
                if(res &amp;&amp; filter){
                    this.listProducts = res.list;
                    this.cdRef.detectChanges();
                }
            });

            setTimeout(()=&gt;{
                $(""#in-blur"").css(""display"", ""none"");
            }, 1000);//for test loading spinner. will be remove in product            
        });
    }
</code></pre>

<p>""this.listProducts = res.list;"" work fine, ther listProducts be updated, but UI is not any change.</p>

<p>Many people advised use zone.run() or ChangeDetectorRef.detectChanges() but not work in my app. Plz support me.</p>
","8688300","","","","","2018-04-12 09:05:48","Angular 5 BehaviorSubject data not update UI","<angular5><rxjs5>","1","2","","","","CC BY-SA 3.0"
"49795527","1","","","2018-04-12 11:36:37","","2","1241","<p>I want to make RxJS observable which will make async request and timeout at the same time.
<br>
<code>-&gt; promise -&gt; filter -&gt; promise and timeout -&gt; complete</code><br>
In synchronous version with async/await code looks like this: </p>

<pre><code>(async () =&gt; {
  const gameInfo = await function1(); // return undefined or {start, id}

   if (!gameInfo) {
     return;
   }

  const gameStart = gameInfo.start;

  setTimeout(() =&gt; {
     function3(gameInfo._id).then(res =&gt; {
         console.log('Done');
     });
  }, getDelayTime(gameStart));

 await function2();

 // Completed
})();

const getDelayTime = (time) =&gt; {
  const now = new Date();
  const parsedTime = new Date(time);

  console.log('In delay', parsedTime.getTime() - now.getTime());
  return parsedTime.getTime() - now.getTime();
};
</code></pre>

<p>So the goal is to receive some data asynchronously from <code>function1()</code>, then make some operations with first part of it and at the same time started timer, to make second operation when time ends, not matter wether <code>function3()</code> end or not.</p>

<p><br>
So, in RxJS I came with something like this:</p>

<pre><code>Rx.Observable
  .fromPromise(function1())
  .filter(data =&gt; data)
  .concatMap(data =&gt; {
    Rx.Observable.fromPromise(function2());
    Rx.operators.delay(data =&gt; Rx.operators.timeout(getDelayTime(data.start)));
  })
  .subscribe(
    data =&gt; {
       console.log('Data', data); 
       function3(data._id)
    }
    err =&gt; console.error('Err', err.message),
    () =&gt; console.log('Completed'),
  );
</code></pre>

<p>But, it's not working as expected for my goal.<br></p>

<p>If I change my code to something like this: </p>

<pre><code>Rx.Observable
  .fromPromise(function1())
  .filter(data =&gt; data)
  .delayWhen(data =&gt; getDelayTime(data.start)) // or .timeout() or .delay
  .map(data =&gt; {Rx.Observable.fromPromise(function2());})
</code></pre>

<p>It's not working.<br>
So, my question is, <strong>how can I make concurrent timer and async http request in RxJS</strong>?</p>
","6066986","","6066986","","2018-04-12 14:52:19","2018-04-12 19:00:44","RxJS concat/merge async request with timeout","<javascript><node.js><rxjs><rxjs5>","1","6","","","","CC BY-SA 3.0"
"49824424","1","49824635","","2018-04-13 20:08:52","","3","4754","<p>I have this </p>

<pre><code>  public getRouteData(): BehaviorSubject&lt;string[]&gt; {
     return this.routeData;
  }
</code></pre>

<p>I wan to map this to an Observable of <code>{name: r}</code> where <code>r</code> is an item in the <code>string[]</code></p>

<pre><code>public gridData: BehaviorSubject&lt;any[]&gt; = new BehaviorSubject([]);
</code></pre>

<p>I would like to take the <code>string[]</code> and map to array of object <code>{name: r}</code> where <code>r</code> is item of array, so that I can bind the object array to the grid.</p>

<p>Somehow not able to sequence or the syntax right.</p>

<p>Tried <code>getRouteData().map(r =&gt; ({name: r})).subscribe(r =&gt; this.gridData.next(r));</code> but this is not correct as I am ending up with <code>{name:string[]}</code> instead of <code>[{name:string}]</code></p>

<p>Can anyone please help?</p>

<p>Thanks!</p>
","4603068","","4603068","","2018-04-13 20:32:50","2018-04-13 20:32:50","How to map an Observable to another type of Observable?","<angular><rxjs5>","1","3","2","","","CC BY-SA 3.0"
"49824635","2","","49824424","2018-04-13 20:24:37","","9","","<p>If I'm understanding correctly, I think you are looking for this:</p>

<pre class=""lang-js prettyprint-override""><code>getRouteData() // =&gt; Observable&lt;string[]&gt;
    .map(r =&gt; r.map(v =&gt; ({name: v}))) // =&gt; Observable&lt;{ name: string }[]&gt;
    .subscribe(r =&gt; this.gridData.next(r));
</code></pre>

<p>The outer <code>map(...)</code> is iterating over each value emitted from your observable. So, <code>r</code> is of type <code>string[]</code>.</p>

<p>The inner <code>map(...)</code> is iterating over each element in your <code>r</code> array and converting the <code>string</code> to the <code>{ name: string }</code> type.</p>
","7407935","","","","","2018-04-13 20:24:37","","","","0","","","","CC BY-SA 3.0"
"49832218","1","49833558","","2018-04-14 13:58:01","","1","135","<p>I'm trying to subscribe to a ""loading"" Observable which returns a boolean. The goal is to have a delay for the items in the stream if loading is true, but not if loading is false. It should also be possible to ignore an outdated item, lets assume following case:</p>

<p>In the stream are two items:</p>

<ul>
<li>Item A with value true, and is passed immediately</li>
<li>Item B with value false, and is passed 200ms later</li>
</ul>

<p>Item A has value true, because of that it will be delayed by 500ms, Item B will not be delayed. In this situation Item B will arrive before Item A. I'm searching for an solution to completely ignore Item A for the mentioned case.</p>

<p>Here you see my current not-working solution:</p>

<pre><code>this.loading$
        .pipe(
            distinctUntilChanged(),
            delayWhen(loading =&gt; timer(loading ? 500 : 0))
        )
        .subscribe(loading =&gt; {
            // Do something
        });
</code></pre>
","1706142","","","","","2018-04-14 16:19:27","RxJS: How to ignore item in stream when outdated","<rxjs><reactive-programming><rxjs5><reactive>","1","2","","","","CC BY-SA 3.0"
"49833558","2","","49832218","2018-04-14 16:19:27","","2","","<p>Just replace <code>delayWhen</code> with <code>switchMap</code> and it should work. <code>switchMap</code> can cancel outdated inner stream. And you probably an one-time observable rather than an timer:</p>

<pre><code>this.loading$
        .pipe(
            distinctUntilChanged(),
            switchMap(
               loading =&gt; 
                           of(loading).pipe(delay(loading ? 500 : 0)))
        )
        .subscribe(loading =&gt; {
            // Do something
        });
</code></pre>
","5006372","","","","","2018-04-14 16:19:27","","","","0","","","","CC BY-SA 3.0"
"49842815","1","","","2018-04-15 14:04:15","","0","127","<p>I have this code, and failing to understand why I am not getting inside the map function (where I have the comment ""I AM NEVER GETTING TO THIS PART OF THE CODE""):</p>

<pre><code>export const fiveCPMonitoringLoadEpic = (action$, store) =&gt;
action$
    .ofType(
        FIVE_CP_MONITORING_ACTION_TYPES.LOAD_FIVE_CP_MONITORING_DATA_STARTED
    )
    .debounceTime(250)
    .switchMap(action =&gt; {
        const params = action.params;
        const siteId = { params };

        // getting site's EDC accounts (observable):
        const siteEdcAccount$ = getSiteEDCAccountsObservable(params);
        const result$ = siteEdcAccount$.map(edcResponse =&gt; {
            // getting here - all good so far.
            const edcAccount = edcResponse[0];
            // creating another observable (from promise - nothing special)
            const fiveCPMonitoringEvent$ = getFiveCPAndTransmissionEventsObservable(
                {
                    ...params,
                    edcAccountId: edcAccount.utilityAccountNumber
                }
            );

            fiveCPMonitoringEvent$.subscribe(x =&gt; {
                // this is working... I am getting to this part of the code
                // --------------------------------------------------------
                console.log(x);
                console.log('I am getting this printed out as expected');
            });

            return fiveCPMonitoringEvent$.map(events =&gt; {
                // I NEVER GET TO THIS PART!!!!!
                // -----------------------------
                console.log('----- forecast-----');
                // according to response - request the prediction (from the event start time if ACTIVE event exists, or from current time if no active event)
                const activeEvent = DrEventUtils.getActiveEvent(events);
                if (activeEvent) {
                    // get event start time
                    const startTime = activeEvent.startTime;
                    // return getPredictionMeasurementsObservable({...params, startTime}

                    const predictions = getPredictionMock(startTime - 300);
                    return Observable.of(predictions).delay(Math.random() * 2000);
                } else {
                    // return getPredictionMeasurementsObservable({...params}

                    const predictions = getPredictionMock(
                        DateUtils.getLocalDateInUtcSeconds(new Date().getTime())
                    );
                    return Observable.of(predictions).delay(Math.random() * 2000);
                }
            });
</code></pre>

<p>can someone please shed some light here?
why when using subscribe it is working, but when using map on the observable it is not?
isn't map suppose to be invoked every time the observable fires?</p>

<p>Thanks,
Jim.</p>
","3019935","","","","","2018-04-15 15:45:04","redux observable map not invoked","<rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"49858440","1","","","2018-04-16 13:24:45","","0","121","<p>I have a list of objects that I get from an http GET request.</p>

<pre><code>http.get&lt;Array&lt;Item&gt;&gt;(url)
</code></pre>

<p>I'm using the directive <strong>*ngFor</strong> in my template to display the items. Because I'm working directly with <strong>Observable</strong>, I'm using the <strong>asyncPipe</strong>. Like this, if I understand well, I don't have to use an intermediate list of objects and I don't have to subscribe manually to the result of the http GET request.</p>

<pre><code>&lt;tr *ngFor=""let item of itemList | async ""&gt;
</code></pre>

<p>Now, I would like to implement an automatic refresh of my list. When I get the items for the first time, if some of them are in a special state, I would like to refresh the Observable Array until all items are in the desired state.</p>

<p>Is it possible to do that without using an intermediate list of Items and subscribe manually ?</p>

<p>I tried something like that, I have almost the behavior I expect but without any refreshing of my template :</p>

<pre><code>ngOnInit() {

  this.itemList = this.itemService.getItemList().do(items =&gt; {

    let processingItem = items.filter(item =&gt; item.status == ItemStatus.InProcess);

    if (processingItem.length &gt; 0) {
      Observable.timer(5000).subscribe(() =&gt; this.itemList.subscribe());
    }
 });
}
</code></pre>

<p>Where getItemList() return an Observable&lt;Array&lt;Item>> </p>
","1813612","","","","","2018-04-19 06:33:45","Is it possible to use AsynPipe in a *ngFor and refresh the list of Observable objects","<angular><rxjs5><ngfor><angular-pipe>","1","0","","","","CC BY-SA 3.0"
"49863340","1","","","2018-04-16 17:45:38","","0","326","<p>I'm stuck trying to accomplish the following. In my React app, I am using redux-observable Epics.</p>

<p>I have two promises, one which needs to wait for the second, before it fires.</p>

<pre><code>import { map, mergeMap, catchError } from 'rxjs/operators';
import { of } from 'rxjs/observable/of';
import { fromPromise } from 'rxjs/observable/fromPromise';
.....

    const promise1 = Auth.getCredentials().then( credentials =&gt; {
        return credentials
    }

    const promise2 = ( credentials ) =&gt; {
         return doQuery(credentials, someData).then(function(data) {
                   // return success
                }).catch(function(err) {
                    // reject error
                });
    }
</code></pre>

<p>So promise 2 needs the credentials from promise1, I am having a hard time knowing how to use observable/fromPromise etc to 'chaing' these items together so that the result of ends up either in the 'map' or 'catchError' result
In my Epic, i have something like this:</p>

<pre><code>const searchEpic: Epic&lt;RootAction, RootState&gt; =
    (action$, store) =&gt; action$.ofType(DO_QUERY)
        .mergeMap(({payload}) =&gt; {

               ???????? - this is where Im stuck 


               const $stream = RESULT_OF_PROMISES.pipe(
                    map((response) =&gt; {
                        return actionCreators.success(..)
                    },
                    catchError(e =&gt; {
                        return of(actionCreators.failure(..));
                    }
                )));


            return $stream
        });
</code></pre>

<p>Thank you!</p>
","130560","","","","","2018-04-16 17:45:38","Redux Observable ( Epic ) - concat two promises before returning action","<redux><rxjs5><redux-observable>","0","2","","","","CC BY-SA 3.0"
"49866089","1","","","2018-04-16 20:56:33","","2","382","<p>I have been attempting to write an RxJS marble test for a simple redux-observable epic but cannot get it to pass.  It appears that using fromPromise in the observable chain under test does not emit the items per the expected marble sequence when flush is called on the testScheduler.</p>

<p>Providing a sample of the test.  If I replace Observable.fromPromise to Observable.of the test will pass.</p>

<p>Any insight is appreciated. RxJS 5 / redux-observable 0.18</p>

<pre><code>...
const MY_ACTION = 'MY_ACTION';

const myAction = () =&gt; ({
  type: MY_ACTION,
  payload: {test: 'testval'},
});

const epic = action$ =&gt;
  action$.ofType(MY_ACTION).switchMap(() =&gt;
    Observable.concat(
      Observable.of({type: 'test1'}),
      Observable.fromPromise(Promise.resolve({type: 'test2'})),
    )
  );

it('it should work', () =&gt; {
  const deepEquals = (actual, expected) =&gt; {
    expect(actual).to.deep.equal(expected);
  };

  const createTestScheduler = () =&gt;
    new TestScheduler(deepEquals);

  const marbles1 = '-a-';
  const marbles2 = '-(bc)-';
  const values = {
    a: myAction(),
    b: {type: 'test1'},
    c: {type: 'test2'},
  };

  const ts = createTestScheduler();
  const source = ActionsObservable.from(
    ts.createColdObservable(marbles1, values)
  );
  const actual = epic(source);


  ts.expectObservable(actual);

  ts.expectObservable(actual).toBe(marbles2, values);
  ts.flush();
});
...
</code></pre>
","7973587","","7973587","","2018-04-16 21:20:02","2018-04-16 21:20:02","RxJs Marble Test Fails When Using Observable.fromPromise","<unit-testing><rxjs5><redux-observable>","0","3","","","","CC BY-SA 3.0"
"49874438","1","49875338","","2018-04-17 09:26:08","","1","132","<p>I am making an API call through an Observable. If this API call takes more than 200ms, I would like to show a loading screen (by assigning 'true' to my 'loading' variable), otherwise I don't want to show anything, in order to avoid a blink on screen.</p>

<p>Is there an RxJS operator capable of doing this ?</p>

<pre><code>this.apiService.get(`/api/someEndpoint`)

// I hope for something like
.triggerIfAtLeastThisAmountOfTimeHasElapsed(200, () =&gt; {
  this.loading = true;
})

.subscribe(response =&gt; {

  // Process the response

  this.loading = false;
});
</code></pre>
","6114088","","310726","","2018-04-17 14:25:29","2018-04-17 14:25:29","Execute function if and only if a certain amount of time has elapsed since subscription with RxJS","<rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"49875338","2","","49874438","2018-04-17 10:09:30","","3","","<p>There are many ways to do this so you can use for example this:</p>

<pre><code>const api = this.apiService.get(`/api/someEndpoint`);
const loading = Observable
  .timer(1000)
  .do(() =&gt; loading = true) // show loading
  .ignoreElements(); // or `filter(() =&gt; false)

Observable.merge(api, loading)
  .take(1)
  .subscribe(() =&gt; loading = false);
</code></pre>
","310726","","310726","","2018-04-17 10:50:30","2018-04-17 10:50:30","","","","2","","","","CC BY-SA 3.0"
"49876510","2","","48821954","2018-04-17 11:09:03","","3","","<p>Found Solution by my own</p>

<pre class=""lang-ts prettyprint-override""><code>export function rxIterable&lt;T, R&gt;(source: Iterator&lt;T&gt;, consumer: (value: T) =&gt; Observable&lt;R&gt;) {
    const first = source.next();
    if (first.done) {
        return empty&lt;R&gt;();
    }
    return consumer(first.value).pipe(
        expand(() =&gt; {
            const next = source.next();
            if (next.done) {
                return empty&lt;R&gt;();
            }
            return consumer(next.value);
        }),
        finalize(() =&gt; source.return())
    );
}
</code></pre>
","1859367","","","","","2018-04-17 11:09:03","","","","0","","","","CC BY-SA 3.0"
"49884348","1","49884411","","2018-04-17 17:41:01","","2","1711","<p>Trying to follow an online video, then this appears, I am new to angular, other solutions are not helping me out.</p>

<p><a href=""https://i.stack.imgur.com/KMNT4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KMNT4.png"" alt=""enter image description here""></a></p>

<pre><code>import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import 'rxjs/add/operator/map';

/*
  Generated class for the WeatherProvider provider.

  See https://angular.io/guide/dependency-injection for more info on providers
  and Angular DI.
*/
@Injectable()
export class WeatherProvider {
  apikey='7d2dc7a226a78c14';
  url;

  constructor(public http: HttpClient) {
    console.log('Hello WeatherProvider Provider');
    this.url='http://api.wunderground.com/api/'+this.apikey+'/conditions/q'
  }

    getWeather(city,state){
      return this.http.get(this.url+'/'+state+'/'+city+'.json')
        .map(res =&gt; res.json() );      
    }
}
</code></pre>
","5237614","","5237614","","2018-04-18 05:32:53","2018-04-18 05:32:53","Angular 5, rxjs map to json, 'json' does not exist on the the type 'object","<json><angular><ionic-framework><rxjs><rxjs5>","2","0","","","","CC BY-SA 3.0"
"49884411","2","","49884348","2018-04-17 17:44:28","","8","","<p>If you're using the new <code>HttpClient</code> you don't need to parse JSON because it's decoded automatically for you:</p>

<p><a href=""https://angular.io/guide/http#type-checking-the-response"" rel=""noreferrer"">https://angular.io/guide/http#type-checking-the-response</a></p>

<blockquote>
  <p>The <code>HttpClient.get()</code> method parsed the JSON server response into the anonymous Object type. It doesn't know what the shape of that object is.</p>
</blockquote>

<p>Also <a href=""https://angular.io/guide/http#requesting-non-json-data"" rel=""noreferrer"">https://angular.io/guide/http#requesting-non-json-data</a>.</p>
","310726","","","","","2018-04-17 17:44:28","","","","3","","","","CC BY-SA 3.0"
"49885335","1","49885845","","2018-04-17 18:42:59","","3","929","<p>I am confused about using httpclient in angular 5.I am new to angular and just following the official angular tutorial.I dont know much about observables,promise,pipe etc..Currently I am having a service for handling all the http methods.For post request I am using with pipe.Below is the method.</p>

<pre><code>create(model: any,URI) :Observable&lt;Object&gt;{
    return this.http.post(API_URL+URI, model)
    .pipe(
        catchError(this.handleError('create', model))
    );
}



private handleError&lt;T&gt; (operation = 'operation', result?: T) {
        return (error: any): Observable&lt;T&gt; =&gt; {

        console.error(""default""+error); // log to console instead
        var errors=error[""error""];

        var type=errors.errors;

        this.log(`${operation} failed: ${JSON.stringify(errors.errors)}`);

        return of(result as T);
        };
    }

      private log(message: string) {
        this.messageService.add('DataService: ' + message);
      }
</code></pre>

<p>And inside the component I am calling this create method like this..</p>

<pre><code>onSubmit() { 
        this.loading = true;
        this._dataService.create(this.model,companytype_url).subscribe(data =&gt; {
            console.log(""inside component data type-company""+JSON.stringify(data));
        },
        error=&gt;{
            var error_data=JSON.stringify(error);
            console.log(""inside component error type-company -&gt;"" + error_data)
        }
        );
        this.submitted = true;
        this.loading = false;
        this.companytypeForm.reset();
    }
</code></pre>

<p>Should I use subscribe in component?
I need a general http class to handle the all the api requests.It is a big application and there are a lot of components.Since I am new to Angular I am confused about the different ways of calling http methods.</p>
","2177607","","2177607","","2018-05-09 12:02:12","2018-05-09 12:02:12","What is the benefit of using observable in Angular 5 http requests?","<angular><rxjs><angular5><rxjs5>","1","1","1","","","CC BY-SA 4.0"
"49885845","2","","49885335","2018-04-17 19:13:51","","2","","<blockquote>
  <p>Should I use subscribe in component?</p>
</blockquote>

<p>Yes. If you don't subscribe, nothing will be sent to the server</p>

<blockquote>
  <p>I need a general http class to handle the all the api requests</p>
</blockquote>

<p>That's what HttpClient is. If your service is completely generic, it won't add anything to what HttpClient already provides. Use dedicated services, which actually provide a higher-level abstraction: have typed arguments, transform inputs necessary, use the appropriate URL, return typed objects, know how to transform the response, etc.</p>

<blockquote>
  <p>Since I am new to Angular I am confused about the different ways of calling http methods.</p>
</blockquote>

<p>That's why Angular provides... documentation. For example, this <a href=""https://angular.io/guide/http"" rel=""nofollow noreferrer"">HttpClient guide</a>, and this <a href=""https://angular.io/guide/rx-library"" rel=""nofollow noreferrer"">RxJS guide</a>. Read them.</p>
","571407","","","","","2018-04-17 19:13:51","","","","8","","","","CC BY-SA 3.0"
"49906424","1","49912245","","2018-04-18 18:15:16","","2","1074","<p>I run <code>tsc</code> on my project, and I get these errors relating to the RxJS5 lib:</p>

<pre><code>$ tsc
node_modules/rxjs/observable/FromEventObservable.d.ts(11,39): error TS2304: Cannot find name 'EventTarget'.
node_modules/rxjs/observable/FromEventObservable.d.ts(11,103): error TS2304: Cannot find name 'NodeList'.
node_modules/rxjs/observable/FromEventObservable.d.ts(11,114): error TS2304: Cannot find name 'HTMLCollection'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(16,23): error TS2304: Cannot find name 'XMLHttpRequest'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(77,59): error TS2304: Cannot find name 'Event'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(82,13): error TS2304: Cannot find name 'Event'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(97,20): error TS2304: Cannot find name 'Event'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(98,10): error TS2304: Cannot find name 'XMLHttpRequest'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(108,32): error TS2304: Cannot find name 'Event'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(108,44): error TS2304: Cannot find name 'XMLHttpRequest'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(119,10): error TS2304: Cannot find name 'XMLHttpRequest'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(128,39): error TS2304: Cannot find name 'XMLHttpRequest'.
node_modules/rxjs/observable/dom/AjaxObservable.d.ts(136,22): error TS2304: Cannot find name 'XMLHttpRequest'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(10,29): error TS2304: Cannot find name 'MessageEvent'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(11,33): error TS2304: Cannot find name 'Event'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(12,34): error TS2304: Cannot find name 'CloseEvent'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(15,63): error TS2304: Cannot find name 'WebSocket'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(27,13): error TS2304: Cannot find name 'WebSocket'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(28,32): error TS2304: Cannot find name 'Event'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(29,33): error TS2304: Cannot find name 'CloseEvent'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(32,63): error TS2304: Cannot find name 'WebSocket'.
node_modules/rxjs/observable/dom/WebSocketSubject.d.ts(36,23): error TS2304: Cannot find name 'MessageEvent'.
</code></pre>

<p>does anyone know why this is happening? this is my package.json file:</p>

<pre><code>{
  ""name"": ""oplog.rx"",
  ""version"": ""0.0.101"",
  ""description"": """",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""suman test""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/ORESoftware/oplog.rx.git""
  },
  ""keywords"": [
    ""oplog"",
    ""mongodb"",
    ""rx"",
    ""rxjs""
  ],
  ""author"": ""Olegzandr V.D."",
  ""license"": ""MIT"",
  ""bugs"": {
    ""url"": ""https://github.com/ORESoftware/oplog.rx/issues""
  },
  ""homepage"": ""https://github.com/ORESoftware/oplog.rx#readme"",
  ""dependencies"": {
    ""bson"": ""^2.0.4"",
    ""json-stdio"": ""0.0.1016"",
    ""mongodb"": ""^3.0.4"",
    ""rxjs"": ""^5.5.7""
  },
  ""devDependencies"": {
    ""@types/mongodb"": ""^3.0.8""
  }
}
</code></pre>
","1223975","","","","","2018-04-19 03:47:26","RxJS5 TypeScript typings fail","<node.js><typescript><rxjs><rxjs5><tsc>","1","0","1","","","CC BY-SA 3.0"
"49910220","1","49910992","","2018-04-18 22:56:46","","5","3534","<p>I'm having difficulty wrapping my head around why <code>combineLatest</code> isn't returning the latest value.  This example is a bit contrived but at least it illustrates my problem.  Notice the value of <code>color</code> from the <code>combineLatest</code> observable returns a previous value, when the <code>subject.value</code> is correct. It's like the <code>color$</code> observable hasn't emitted.</p>

<pre><code>import { map, distinctUntilChanged, combineLatest } from 'rxjs/operators'
import { Observable } from 'rxjs/observable';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

const main$ = new BehaviorSubject({color: 'red'});

const color$ = main$.pipe(
  map(state =&gt; state.color),
)

main$.pipe(
  combineLatest(color$)
)
.subscribe(([state, color]) =&gt; {
  console.log(state, color, main$.value.color);
})

main$.next({
    color: 'yellow'
});
</code></pre>

<p><strong>Actual Output</strong></p>

<pre><code>{color: ""red""} ""red"" ""red""

{color: ""yellow""} ""red"" ""yellow""

{color: ""yellow""} ""yellow"" ""yellow""
</code></pre>

<p><strong>Expected Output</strong></p>

<pre><code>{color: ""red""} ""red"" ""red""

{color: ""yellow""} ""yellow"" ""yellow""  // Notice middle value is yellow

{color: ""yellow""} ""yellow"" ""yellow""
</code></pre>

<p><a href=""https://stackblitz.com/edit/combine-latest-issue"" rel=""noreferrer"">https://stackblitz.com/edit/combine-latest-issue</a></p>

<p>If someone could help explain whats going, and provide a workaround or proper way to think about this in <code>rxjs</code> I would appreciate it.</p>
","684869","","","","","2019-03-15 05:27:11","combineLatest doesn't emit latest value","<rxjs><rxjs5>","3","0","","","","CC BY-SA 3.0"
"49910992","2","","49910220","2018-04-19 00:43:31","","6","","<p>It may be useful to visualize what is going on rather than words:</p>

<pre><code>main$     R--------------------Y------------------------------

color$    -------R-----------------------Y---------------------

output    -----[R,R]---------[Y,R]-----[Y,Y]------------------
</code></pre>

<p>If you use <code>zip</code> instead of <code>combineLatest</code>, you will get very closer to what you expect. See bellow what happens if you use <code>zip</code>:</p>

<pre><code>main$     R--------------------Y------------------------------

color$    -------R-----------------------Y---------------------

output    -----[R,R]-------------------[Y,Y]------------------
</code></pre>
","475247","","475247","","2018-04-19 01:50:36","2018-04-19 01:50:36","","","","1","","","","CC BY-SA 3.0"
"49912245","2","","49906424","2018-04-19 03:28:28","","4","","<p>You need to add <code>""dom""</code> to the <code>lib</code> setting in your <code>tsconfig.json</code> file's <code>compilerOptions</code>:</p>

<pre><code>""lib"": [""dom"", ""es2015""]
</code></pre>

<p>Alternatively, you can use the <code>skipLibCheck</code> <code>compilerOption</code> to avoid checking <code>.d.ts</code> files within <code>node_modules</code>:</p>

<pre><code>""skipLibCheck"": true
</code></pre>

<p>See <a href=""https://github.com/ReactiveX/rxjs/issues/3558"" rel=""nofollow noreferrer"">this issue</a> for an explanation.</p>

<p>Basically, the <code>fromEvent</code> observable factory supports both Node and DOM event sources and TypeScript needs to know about the DOM types.</p>

<p><a href=""https://github.com/ReactiveX/rxjs/pull/3566"" rel=""nofollow noreferrer"">This PR</a> should resolve the problem.</p>
","6680611","","6680611","","2018-04-19 03:47:26","2018-04-19 03:47:26","","","","1","","","","CC BY-SA 3.0"
"49926842","1","","","2018-04-19 17:24:45","","0","103","<p>I try to follow the example in the documentation to test epic:</p>

<p><strong>Epic</strong></p>

<pre><code>import { ofType } from 'redux-observable';
import { combineEpics } from 'redux-observable';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';
import { switchMap } from 'rxjs/add/operator/switchMap';
import { from } from 'rxjs/observable/from';
import { of } from 'rxjs/observable/of';
import { fromPromise } from 'rxjs/observable/fromPromise';

import { 
  getTopStories
} from '../../../utils/service-helper';

import { type, actions } from './action';

export const getHackernewsStoryEpic = (action$, store) =&gt; 
  action$.ofType(type.GET_HACKERNEWS_STORIES_REQUEST)
          .switchMap(
            action =&gt;  { 
              return from(getTopStories())
                        .takeUntil(action$.ofType(type.GET_HACKERNEWS_STORIES_REQUEST_CANCEL))
                        .map(result =&gt; actions.getHackernewsStoriesRequestSuccess(result))
                        .catch((error) =&gt; actions.getHackernewsStoriesRequestFailure(error))
            }
        );

export default combineEpics(
  getHackernewsStoryEpic
);
</code></pre>

<p>Get <strong>getTopStories</strong> is service call which talks to hackernews API:</p>

<pre><code>export const getTopStories = async () =&gt; await getRequest('/topstories.json');
</code></pre>

<p>My test looks like this:</p>

<pre><code>describe('Hackernews stories epic', () =&gt; {
  describe('getHackernewsStoryEpic', () =&gt; {
    let store;

    beforeEach(() =&gt; {
      store = mockStore();
    });

    afterEach(() =&gt; {
      nock.cleanAll();
      epicMiddleware.replaceEpic(storiesEpic);
    });
    it('should return success on request success', async () =&gt; {
      store.dispatch({ type: type.GET_HACKERNEWS_STORIES_REQUEST });
      expect(store.getActions()).toEqual([
        { type: type.GET_HACKERNEWS_STORIES_REQUEST },
        { type: type.GET_HACKERNEWS_STORIES_SUCCESS }
      ]);
    });
  });
});
</code></pre>

<p>Looking at the test it fails as one action is trigger and <strong>getTopStories()</strong> is never trigger (nock is not complaining that there is no mock) and not getting next action. I think I missing something as from should run async call?</p>
","2595644","","","","","2018-04-23 20:23:10","Observable epics not running service call","<rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 3.0"
"49931157","1","49934768","","2018-04-19 22:29:46","","2","34","<p>I am looking for some pre-built functionality that does something like this:</p>

<pre class=""lang-js prettyprint-override""><code>const Rx = require('rxjs');
const proto = Rx.Observable.prototype;

proto.whenCompleted = function () {

    const source = this;

    return Rx.Observable.create(sub =&gt; {

        const ret = [];
        return source.subscribe(
            function (v) {
                ret.push(v);
            },
            function (e) {
                sub.error(e);
            },
            function () {
                sub.next(ret);
            }
        )

    });

};
</code></pre>

<p>is there an RxJS observable method that can do that?</p>
","1223975","","7407935","","2018-04-21 03:42:44","2018-04-21 03:42:44","Is there a build in Observable that fires next after the previous in the chain has completed?","<rxjs><rxjs5><angular2-observables>","1","2","1","","","CC BY-SA 3.0"
"49932656","1","49932762","","2018-04-20 01:43:55","","1","36","<p>I want to do something like 
<code>&lt;span *ngIf=""admins.includes(name) | async""&gt;</code> where <code>admins</code> is defined in the component class as <code>admins:Observable&lt;string[]&gt;</code>
I know this does not work but is possible to achieve this in any way?</p>

<p>Thanks so much for help!</p>
","4603068","","","","","2018-04-20 01:58:28","How to use angular async binding","<angular><rxjs5>","1","2","","","","CC BY-SA 3.0"
"49932762","2","","49932656","2018-04-20 01:58:28","","3","","<p>The async pipe needs to be on the observable itself like below.</p>

<pre><code>&lt;span *ngIf=""(admins | async)?.includes(name)""&gt;
</code></pre>
","3534636","","","","","2018-04-20 01:58:28","","","","0","","","","CC BY-SA 3.0"
"49934768","2","","49931157","2018-04-20 05:43:33","","1","","<p><code>concat</code> allows you to merge streams ""one after another"".</p>

<p>E.g.: in the case below, the stream will first emit 1, 2, 3 and only after that will send the form changes.</p>

<pre class=""lang-js prettyprint-override""><code>from([1, 2, 3])
.pipe( 
  concat(
    myForm.get('age').valueChanges
  ) 
)
</code></pre>
","946789","","7407935","","2018-04-21 03:41:39","2018-04-21 03:41:39","","","","0","","","","CC BY-SA 3.0"
"49943861","1","","","2018-04-20 14:21:40","","1","536","<p>I have an action which requires me to go to the server, get 2 chunks of data, and on getting those then dispatching an action with each chunk of data respectively.
This is to be done when action$.ofType(PROCESSDATA).
Pretty new to rxjs and I can't quite figure out the right combination.</p>

<pre><code>epic = (action$) =&gt; {
    return action$.ofType(PROCESSDATA)
        //should I be using switchMap? It is for initialising data 
        //so I figure no point in carrying on with original request 
        //if a new one comes in
        .switchMap(action=&gt;{
            //is merge right? return statement currently just gives me
            //an error about my epic does not return a stream
            const token = localStorage.getItem('token');
            return Observable.merge(
               Observable.ajax({
                 url:'/first',
                 headers:{Authorization:'Bearer ' + token}
                })
               .map(r=&gt;{type:PROCESSFIRST, data:r.response, item:action.item}),
               Observable.ajax({
                 url:'/second',
                 headers:{Authorization:'Bearer ' + token}
                })
               .map(r=&gt;{type:PROCESSSECOND, data:r.response}),

            )
        })
}
</code></pre>

<p>The reason I am doing it this way (in case it doesn't make sense) is that I already have an app using redux-thunk (and axios) and I am trying to replace one part of it with redux-observable to get the hang of it, so that is why I want to issue the 2 actions (PROCESSFIRST and PROCESSSECOND) for redux-thunk to deal with as they are already catered for. So I am simply putting a step in the middle to see if I can work with redux-observable but I am very much a newbie to rxjs etc</p>

<p>Ultimately I want to trigger the continuation actions using the data returned and then finish at that.
Also, if you have time, how and where should errors be handled in this.</p>

<p><strong>UPDATE:</strong>
OK, so I just realised I need a return statement at the top of the epic. That gets me out of the first error.
Then I was using mapTo instead of map, and I was using r.data where it should have r.response. Amazingly it all works now. BUT I am not handling errors correctly OR not calling it in the right way.
So, because of what I said about the existing project using redux-thunk, I have an actionCreator that controls this:</p>

<pre><code>initState = (lang) =&gt; {
   return dispatch =&gt; new Promise(resolve,reject){
     const pr1 = dispatch({type:INIT_STATE});
     //this was another thunk that returned a Promise which did the axios
     //calls to the server, dispatched the relevant continuation action 
     //and then either resolved or rejected
     //and then dispatched further actions to process the results
     const pr2 = dispatch(processData()); 
     Promise.all([pr1,pr2])
       .then(r=&gt;resolve(true))
       .catch(e=&gt;reject(e))
   }
}
</code></pre>

<p>I have changed this where const pr2 = .... to:</p>

<pre><code>const pr2 = dispatch({type:PROCESSDATA})
</code></pre>

<p>, thereby swapping the thunk for an epic and left everything else the same. This does seem to trigger the epic and process the data but for example if I use the wrong url, nothing happens (as expected) but more importantly I don't catch the error. So what do I need to change to catch that error?
thanks in advance</p>
","2047485","","2047485","","2018-04-20 16:14:38","2018-04-20 16:14:38","How to execute 2 async calls in redux-observable epic and return/dispatch action on result of each one","<rxjs><rxjs5><redux-observable>","0","2","","","","CC BY-SA 3.0"
"49958809","2","","46411508","2018-04-21 18:11:45","","0","","<p>Incrementing and decrementing a counter was too susceptible to bugs, so I ended up going with a wholly different approach. I now separately track whether the local data is ""dirty."" I use this dirty signal to show a ""Savingâ¦"" vs ""Saved"" message to the user:</p>

<ol>
<li>Every time the user makes a local edit, I locally update the data and set <code>dirty</code> to <code>true</code>.</li>
<li>After each save operation, the server responds with the latest version of the data it has.</li>
<li>Upon receiving that response, I diff the local version of the data with what gets returned by the server, and if they match I set <code>dirty</code> to <code>false</code>.</li>
</ol>

<h1>Setting <code>dirty</code> to <code>true</code> on each edit</h1>

<p>Here I define an <code>Rx.Subject</code> for each time the user makes an edit. Each time it receives a signal, I set <code>dirty</code> to <code>true</code>.</p>

<pre class=""lang-js prettyprint-override""><code>// stream of signals to save the active document
const userEditSignal$ = new Rx.Subject();

const savePrototype = () =&gt; {
  userEditSignal$.next();
};

userEditSignal$.subscribe(() =&gt; {
  // runs for each call to save the active document
  store.commit(""SET_DIRTY"", true);
});
</code></pre>

<h1>Observe the <code>dirty</code> state to decide when to save to server</h1>

<p>This lets us know every time the <code>dirty</code> value changes, which is not the same as every time it is set.</p>

<pre class=""lang-js prettyprint-override""><code>const observeState = (store, getter) =&gt; {
  // irrelevant details redacted
}

// emits only when `dirty` changes, not every time it's set
const shouldSaveToServer$ = observeState(store, state =&gt; state.dirty);
</code></pre>

<h1>Create a stream of request objects and server responses</h1>

<p>This custom timing logic replaces the need for the <code>auditTime()</code> operator.</p>

<pre class=""lang-js prettyprint-override""><code>const saveToServerSignal$ = shouldSaveToServer$.switchMap(shouldSave =&gt; {
  return shouldSave ?
    // as long as we should save, save every 500 ms
    Rx.Observable.interval(500) :
    // when we should not, stop
    Rx.Observable.never();
});

// create a request object for each save-to-server signal
const saveRequest$ = saveToServerSignal$
  .mapTo(store.state.activeDocument)
  .map(createSaveRequest);

// 
const saveResponse$ = saveRequest$
  // sends immediately
  .flatMap(request =&gt; axios(request));
</code></pre>

<h1>On every response, check diff the local document and the version returned from the server</h1>

<p>If they agree, we can set <code>dirty</code> to <code>false</code>.</p>

<pre class=""lang-js prettyprint-override""><code>saveResponse$
  .map(response =&gt; response.data)
  .do(savedDocument =&gt; {
    const activeDocument = store.state.activeDocument;

    // update just `created`, `modified`, and `user`
    store.commit({
      type: ""UPDATE_ACTIVE_DOCUMENT"",
      // irrelevant details omitted
    });

    // diff current state and saved document (function details omitted)
    const activeAndSavedDocsMatch = diff(activeDocument, savedDocument);
    if (activeAndSavedDocsMatch) {
      store.commit(""SET_DIRTY"", false);
    }
  })
  .subscribe();
</code></pre>
","101869","","","","","2018-04-21 18:11:45","","","","0","","","","CC BY-SA 3.0"
"49965259","1","49965712","","2018-04-22 11:11:14","","1","272","<p>friends. I get a Subject <code>c</code>, by dynamic subscribe from other observable object. but want when all observable complete then <code>c</code> complete without the first complete. </p>

<p>How can I do this ?</p>

<pre><code>const c = new Subject;

const a = Observable.interval(100).take(3).mapTo('a');
const b = Observable.interval(150).take(3).mapTo('b');


a.subscribe(c);
b.subscribe(c);
c.subscribe(console.log);
</code></pre>

<p>real output</p>

<pre><code>a
b
a
a
</code></pre>

<p>expect</p>

<pre><code>a
b
a
a
b
b
</code></pre>
","6497005","","","","","2018-04-22 12:04:36","How create never complete subject of rxjs","<rxjs><rxjs5>","1","4","","","","CC BY-SA 3.0"
"49965712","2","","49965259","2018-04-22 12:04:36","","1","","<p>This is correct behavior because a Subject has an internal state and when it receives the <code>complete</code> notification it marks itself as ""stopped"" and will never ever emit anything. And that's exactly what's happening in you example. When you use <code>a.subscribe(c)</code> you're subscribing <code>c</code> to all three types of notifications and when the source emits <code>complete</code> it's received by <code>c</code> as well and it stops emitting.</p>

<p>Instead you can subscribe <code>c</code> only to <code>next</code> notifications:</p>

<pre><code>a.subscribe(v =&gt; c.next(v));
b.subscribe(v =&gt; c.next(v));
</code></pre>

<p>Then if you want the source to properly complete when all sources complete you could do the following (you also need to use <code>share()</code> on all source Observables):</p>

<pre><code>const a = Observable.interval(100)...share();
const b = Observable.interval(150)...share();

...

Observable.forkJoin(a, b)
  .subscribe(() =&gt; c.complete());
</code></pre>
","310726","","","","","2018-04-22 12:04:36","","","","2","","","","CC BY-SA 3.0"
"49982016","1","49992500","","2018-04-23 13:11:45","","1","315","<p>This code shows nothing in console. But if i change the second line with the commented code it works. Is this expected or something wrong here?</p>

<pre><code>let bSubject = new BehaviorSubject&lt;any&gt;(1);
of(2).subscribe(bSubject); // of(2).subscribe(data =&gt; bSubject.next(data));
bSubject.subscribe(data =&gt; console.log(data));
</code></pre>
","3263519","","","","","2018-04-24 08:06:46","BehaviorSubject as an observer","<rxjs5><behaviorsubject>","1","0","","","","CC BY-SA 3.0"
"49992500","2","","49982016","2018-04-24 02:20:28","","3","","<p>The behavior is by-design.</p>

<p>The first <code>subscribe</code> call sees the subject's <code>complete</code> method called, as the source observable completes.</p>

<p>Once the subject's <code>complete</code> method is called, the <code>BehaviorSubject</code> is done and no further values will be emitted.</p>

<p>That is, calling <code>next</code> on a completed <code>BehaviorSubject</code> will not emit a value and subscribing to a completed <code>BehaviorSubject</code> won't emit an initial value.</p>

<p>When you replace the second line with:</p>

<pre><code>of(2).subscribe(data =&gt; bSubject.next(data));
</code></pre>

<p>The subject's <code>complete</code> will no longer be called when the source observable completes and the subsequent subscription to the subject will emit the subject's current value.</p>
","6680611","","6680611","","2018-04-24 08:06:46","2018-04-24 08:06:46","","","","0","","","","CC BY-SA 3.0"
"49993155","1","59678514","","2018-04-24 03:53:35","","11","6117","<p>When creating an RxJS <code>BehaviorSubject</code>, it stays a <code>BehaviorSubject</code> until it's <code>pipe</code>'d. As soon a <code>pipe</code>'d version is returned, it becomes an <code>AnonymousSubject</code>.</p>

<h1>Examples:</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Instance of `BehaviorSubject`
const behaviorSubject$ = new BehaviorSubject({ someValue: null })

// Suddenly becomes an Anonymous Subject
const anonymousSubject$ = (
    behaviorSubject$
    .pipe(
        pluck('someValue')
    )
)

// Also suddenly becomes an Anonymous Subject
const anonymousSubject$ = (
    new BehaviorSubject({ someValue: null })
    .pipe(
        pluck('someValue')
    )
)</code></pre>
</div>
</div>
</p>

<p>I experience this same issue with <code>ReplaySubject</code> as well. I can't seem to pipe through the subject and return that subject back. It always converts to an <code>AnonymousSubject</code>. I think what I'm looking for here is Promise-like behavior where I can subscribe to this observable from anywhere and grab the one value passed into it.</p>
","1624862","","1624862","","2018-04-24 16:35:41","2021-10-13 04:18:12","Why does piping a BehaviorSubject create an AnonymousSubject in RxJS?","<javascript><rxjs><rxjs5><behaviorsubject><subject-observer>","1","8","","","","CC BY-SA 3.0"
"49996986","1","50001730","","2018-04-24 08:36:26","","3","1094","<p><a href=""https://i.stack.imgur.com/uJpwO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uJpwO.png"" alt=""enter image description here""></a></p>

<p>Example:</p>

<pre><code>ob$.subscribeOn(Scheduler.queue) 
 .subscribe(() =&gt; {...})
</code></pre>

<p>or</p>

<pre><code>ob$.subscribe(() =&gt; {...})
</code></pre>

<p>There is nothing difference, right?</p>
","6497005","","","","","2018-04-24 12:29:28","RxJS What difference with Scheduler.queue and null?","<rxjs><rxjs5>","1","1","","","","CC BY-SA 3.0"
"50001050","1","50002513","","2018-04-24 11:55:27","","3","1031","<p>It seems that <code>debounceTime</code> ignores inner calls to it's subjects <code>next</code> method:</p>

<pre><code>var subject: Subject&lt;number&gt; = new Subject&lt;number&gt;();

subject.pipe(
    tap((a) =&gt; console.log(""tab:"" + a)), 
    debounceTime(300), 
).subscribe((a) =&gt; {
    console.log(a);
    subject.next(100)
});

subject.next(19);
subject.next(20);
</code></pre>

<p>the code above should create an infinite loop - but it does not:</p>

<pre><code>tab:19
tab:20
20
tab:100
</code></pre>

<p>if I add a <code>delay(1)</code> to the pipe it works as expected:</p>

<pre><code>subject.pipe(
    tap((a) =&gt; console.log(""tab:"" + a)), 
    debounceTime(300), 
    delay(1)
).subscribe((a) =&gt; {
    console.log(a);
    subject.next(100)
});
</code></pre>

<p>am I missing something?</p>

<p><strong>Edit</strong>: added an example: <a href=""https://typescript-fbt2mn.stackblitz.io"" rel=""nofollow noreferrer"">https://typescript-fbt2mn.stackblitz.io</a></p>
","1859022","","114900","","2018-04-24 15:39:31","2018-04-24 18:06:45","rxjs observable debounceTime inner next ignored","<rxjs><rxjs5><redux-observable>","1","2","","","","CC BY-SA 3.0"
"50001730","2","","49996986","2018-04-24 12:29:28","","10","","<p>The difference is apparent when you look at how the <code>queue</code> scheduler affects the behaviour of <code>combineLatest</code>.</p>

<p>Compare the behaviour of this snippet in which no scheduler (i.e. the <code>null</code> scheduler) is specified:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const a = Rx.Observable.of(1, 2);
const b = Rx.Observable.of(3, 4);
const c = Rx.Observable.of(5, 6);

console.log(""before"");
Rx.Observable
  .combineLatest(a, b, c)
  .subscribe(value =&gt; console.log(JSON.stringify(value)));
console.log(""after"");</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>With this snippet:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const a = Rx.Observable.of(1, 2, Rx.Scheduler.queue);
const b = Rx.Observable.of(3, 4, Rx.Scheduler.queue);
const c = Rx.Observable.of(5, 6, Rx.Scheduler.queue);

console.log(""before"");
Rx.Observable
  .combineLatest(a, b, c, Rx.Scheduler.queue)
  .subscribe(value =&gt; console.log(JSON.stringify(value)));
console.log(""after"");</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Note that both snippets run synchronously. The <code>queue</code> scheduler executes scheduled actions synchronously when no delay is specified.</p>

<p>In the first snippet, the observables are enumerated in a depth-first manner. That is, all of the values from the source observable <code>a</code> are enumerated before the values from the observables <code>b</code> and <code>c</code> are enumerated. That sees only two combined values emitted with the last values from <code>a</code> and <code>b</code> and both values from <code>c</code>.</p>

<p>However, in the second snippet the values are enumerated in a breadth-first manner. That is, a value is enumerated from <code>a</code> followed by a value from <code>b</code>, etc. That sees more combinations emitted.</p>

<p>In short, the <code>queue</code> scheduler behaves this way because when an action is scheduled whilst an already-scheduled action is being executed, the newly scheduled action is queued.</p>
","6680611","","","","","2018-04-24 12:29:28","","","","2","","","","CC BY-SA 3.0"
"50002513","2","","50001050","2018-04-24 13:07:13","","5","","<p>This type of issues where something seems to be broken and that can be magically fixed with using <code>delay(0)</code> or <code>setTimeout</code> usually means that you're expecting RxJS to behave asynchronously all the time while in fact it usually works synchronously unless forced to do otherwise.</p>

<p>And that's exactly your case.</p>

<ul>
<li><p>When debounce pushes its value you're on this line <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L100"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L100</a>.</p></li>
<li><p>Inside <code>subscribe</code> you call <code>next</code> which reaches <code>_next</code> inside <code>debounceTime</code> <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L84"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L84</a> which sets <code>lastValue</code> and <code>hasValue</code> internal variables.</p></li>
<li><p>Now it starts going upwards in the call stack and only now it stops processing this line <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L100"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L100</a>. At this point it continues and overrides <code>lastValue</code> and <code>hasValue</code> again <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L101-L102"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L101-L102</a>. This sets them to <code>null</code> and <code>false</code>.</p></li>
<li><p>Then after <code>300ms</code> <code>debounceTime</code> wants to emit its value but <code>hasValue</code> is <code>null</code> <a href=""https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L99"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.10/src/operators/debounceTime.ts#L99</a> because it was already overrided.</p></li>
</ul>

<p>Btw, a little more elegant way is using the <code>observeOn</code> operator with an <code>async</code> scheduler that should be more performance efficient then <code>delay(1)</code>.</p>

<pre><code>import { async } from 'rxjs/scheduler/async';

var obs = Observable.of(1, 2, 3);
var subject: Subject&lt;number&gt; = new Subject&lt;number&gt;();

subject.pipe(
    tap((a) =&gt; console.log(""tab:"" + a)), 
    debounceTime(300),
    observeOn(async),
).subscribe((a) =&gt; {
    console.log(a);
    subject.next(a+1)
});
</code></pre>

<p>See you updated demo: <a href=""https://stackblitz.com/edit/typescript-tsek9s?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-tsek9s?file=index.ts</a></p>

<p>Edit: This behavior has probably changed in RxJS 6: <a href=""https://github.com/ReactiveX/rxjs/pull/3218"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/pull/3218</a></p>
","310726","","310726","","2018-04-24 18:06:45","2018-04-24 18:06:45","","","","2","","","","CC BY-SA 3.0"
"50009645","1","","","2018-04-24 19:40:52","","1","3667","<p>I have a ResultsComponent in my application, where I am making two service calls at the same time joining both observable by using a rxjs forkJoin operator. I want to mock the data for the rxjs operator. I have google lot time and tried different ways, but didn't find a way to do it. can anyone please help me.</p>

<p>angular version: 5.2.9
rxjs version: 5.5.7
angular-cli: 1.6.6</p>

<p>getting this error at forkJoin statement in <strong>results.component.ts</strong></p>

<blockquote>
  <p>TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p><strong>results.component.ts</strong></p>

<pre class=""lang-js prettyprint-override""><code>@Component({
  selector: ""app-results"",
  templateUrl: ""./results.component.html"",
  styleUrls: [""./results.component.scss""]
})
export class ResultsComponent 
  implements OnInit, OnDestroy {
  searchForm: FormGroup;


  constructor(
    private rxnsSearchService: RxnsSearchService,
    private rxnsSearchHitCountService: RxnsSearchHitCountService,
    public store: Store&lt;fromAppReducer.AppState&gt;,
    private route: ActivatedRoute,
    public formBuilder: FormBuilder,
    public router: Router
  ) {

  }

  ngOnInit() {

    this.route.queryParams.subscribe(params =&gt; {
      this.searchForm = this.formBuilder.group({
        searchInput: new FormControl(params.q, Validators.required),
        searchType: new FormControl(params.searchType),
        searchBy: new FormControl(params.searchBy)
      });
      this.store.dispatch(new AppActions.ChemQueryString(params.q));
      const rxnsObservable: Observable&lt;Array&lt;any&gt;&gt; = this.rxnsSearchService.getReactions(params, 0);
      const headCountObservable: Observable&lt;number&gt; = this.rxnsSearchHitCountService.getHitCount(params);
      forkJoin([rxnsObservable, headCountObservable]).subscribe(results =&gt; {
        this.reactions = results[""0""];
        this.total = results[""1""];
      }, (error) =&gt; {
        console.log(error);
      });
    });
    this.store.select(""rxnState"").subscribe(data =&gt; {
      console.log(data);
      this.searchString = data.slice(-1)[0].searchString;
    });
  }
  ngOnDestroy() {}
}
</code></pre>

<p><strong>results.component.spec.ts</strong></p>

<pre class=""lang-js prettyprint-override""><code>const dummydata = [
  {
    ruid: ""02b01f46288b4f71950d03856bc8f173"",
    rxnString: ""Cl.NCCC1(C(F)(F)F)CC1.NCC1=CC=CC(NC""
  },
  {
    ruid: ""02b01f46288b4f71950d03856bc8f173"",
    rxnString: ""Cl.NCCC1(C(F)(F)F)CC1.NCC1=CC=CC(NC""
  }
];
const dummyParams = {q: ""[H]N(C(=O)C([H])([H])C)C1([H])CCCC22"", searchType: ""SUBSTRUCTURE"", searchBy: ""PRODUCT""};

class RouterStub {
  navigate(commands: any[], extras?: NavigationExtras) { }
}
class ActivatedRouteStub {
  private _testParams: {};
  private subject = new BehaviorSubject(this._testParams);
   queryParams = this.subject.asObservable();
  setQueryParams(params: Params) {
    this._testParams = params;
    this.subject.next(params);
  }
}

describe(""ResultsComponent"", () =&gt; {
  beforeEach(() =&gt; {
    activatedRoute = new ActivatedRouteStub();
  });
  let component: ResultsComponent;
  let injector;
  let store: Store&lt;any&gt;;
  let fixture: ComponentFixture&lt;ResultsComponent&gt;;
  let rxnsSearchService: RxnsSearchService;
  let rxnsSearchHitCountService: RxnsSearchHitCountService;
  let activatedRoute: ActivatedRouteStub;

  beforeEach(async(() =&gt; {

    TestBed.configureTestingModule({
      imports: [
        ResultsModule,
        NgxPaginationModule,
        HttpClientTestingModule,
        RouterTestingModule,
        StoreModule.forRoot(fromAppReducer.reducers)
      ],
      declarations: [ ],
      providers: [
          RxnsSearchService,
          RxnsSearchHitCountService,
        { provide: ActivatedRoute, useValue: activatedRoute },
        { provide: Router, useClass: RouterStub},
        FormBuilder
      ]
    }).compileComponents();
    injector = getTestBed();
    rxnsSearchService = injector.get(RxnsSearchService);
    rxnsSearchHitCountService = injector.get(RxnsSearchHitCountService);
    spyOn(rxnsSearchService, 'getReactions').and.returnValue(Observable.of(dummydata));
    spyOn(rxnsSearchHitCountService, 'getHitCount').and.returnValue(Observable.of(300));
    store = injector.get(Store);
  }));

  beforeEach(async(() =&gt; {
    activatedRoute.setQueryParams(dummyParams);
    fixture = TestBed.createComponent(ResultsComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  }));

  it(""should create results component"", () =&gt; {
    expect(component).toBeTruthy();
  });
});
</code></pre>
","7110325","","6680611","","2018-04-25 06:16:03","2018-07-20 20:57:26","How to test angular 5 component with rxjs 5 forkJoin","<angular><rxjs><angular5><rxjs5>","1","5","","","","CC BY-SA 3.0"
"50058031","1","","","2018-04-27 08:08:09","","1","1265","

<p>I wrap a http call to a new Observable, but I cannot detect if the subscription is cancelled:</p>

<pre class=""lang-js prettyprint-override""><code>constructor( @Inject(Http) private http: Http) {
}


...


const observable = Observable.create((observer: Observer&lt;any&gt;) =&gt; {
            this.http.post(url, body)
                .subscribe((p) =&gt; {
                    observer.next(p.json());
                    observer.complete();
                }, (err) =&gt; {
                    observer.error(err);
                    observer.complete();
                });
        });
const subscription = observable.subscribe((r) =&gt; { alert(""result : ""+r); }, (err) =&gt; { alert(""error occured"");}

subscription.unsubscribe(); // if user cancels the request
</code></pre>

<p>How can I detect in <code>Observable.create(...)</code> if the user cancels the subscription?  I would like to cancel the http post request when the outer Observable is cancelled.</p>
","5728926","","542251","","2019-10-08 12:12:17","2019-10-08 12:12:24","How to detect unsubscribe in Observer","<observable><angular5><rxjs5>","1","0","","","","CC BY-SA 4.0"
"50062140","1","50066610","","2018-04-27 12:13:25","","1","2083","<p>Hey I am new to rxjs and ngrx, and I am building an app using these technologies.
I am trying to think on how to create a Polling system using rxjs observables and operators.</p>

<p>I have created a basic Polling system which contains a map of subscriptions of the observables. each observable dispatch an action every 5 seconds to ngrx-effects which handle the action and perform the side effects like http call using a service.</p>

<p>My problem is that I want to create a specific mechanisim for current pooling system which has the following conditions:</p>

<p>1.The first pool happens right away,I am using timer(0,poolingTime) for this,
or interval with pipe of stratwith(null).</p>

<p>2.The pool know to delay its next request according to the time of the previous request.I mean that when the previous request finished then the second request occur.</p>

<p>The first conidition I have acheived alone , the second condition(2) I need help in achieving this.
I thoungth about debounce or throttle inorder to complete the second condition, but as I said in the first place I don't have alot of expriences with rxjs.</p>

<p>Here is the code of my simple pooling system</p>

<pre><code>import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { Subscription } from 'rxjs/Subscription';
import { timer } from 'rxjs/observable/timer';
import { interval } from 'rxjs/observable/interval';
import { throttleTime, debounceTime, startWith, tap, delay } from 'rxjs/operators';
import { Utils } from '../utils';
@Injectable()
export class PoolingService {

  private subscriptions: { [id: string]: Subscription };

  constructor() {
    this.subscriptions = {};
  }

  public startPooling(time: number, callback: Function): string {
    const id = Utils.guid();
    const interval$ = interval(time).pipe(tap(tick =&gt; console.log(""tick"", tick))).pipe(startWith(null));
    // const interval$ = timer(0, time).pipe(tap(tick =&gt; console.log(""tick"", tick)));

    const subscription = interval$.subscribe(() =&gt; { callback() });
    this.subscriptions[id] = subscription;
    return id;
  }

  public stopPooling(id: string) {
    const subscription = this.subscriptions[id];
    if (!subscription) {
      return;
    }
    subscription.unsubscribe();
  }

}
</code></pre>

<p>Here is the use of the Poll Service:</p>

<pre><code>ngOnInit() {

    this.store.select('domains').subscribe((state: any) =&gt; {
      const { list, lastAddedDomain } = state;
      this.markers = list;
      this.roots = Utils.list_to_tree(list);
    });

    this.poolService.startPooling(5000, () =&gt; {
      this.store.dispatch(new AllHttpActions.HttpActionGet({}, HttpMethods.GET, ""/getDomainsForMap"", AllDomainActions.FETCH_DOMAINS, Utils.guid()));
    });

  }
</code></pre>
","5908188","","5908188","","2018-04-27 18:26:01","2018-07-21 14:15:27","Polling in rxjs and ngrx","<angular><typescript><rxjs5><ngrx-store><ngrx-effects>","1","2","","","","CC BY-SA 3.0"
"50066610","2","","50062140","2018-04-27 16:22:15","","3","","<p>I would probably try out something like this. I added comments throughout the code which should help you understand why I did certain things.</p>

<pre><code>import { Injectable, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { Observable } from 'rxjs/Observable';
import { timer } from 'rxjs/observable/timer';
import { interval } from 'rxjs/observable/interval';
import { startWith, tap, mergeMap, take, takeUntil, filter, map, catchError, delay } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs/observable/of';
import { Subscription } from 'rxjs/Subscription';

@Injectable()
export class PollingService implements OnDestroy {

    private destroyed$ = new Subject&lt;any&gt;();

    poll&lt;PollResultType&gt;(intervalTime: number, pollFunction: () =&gt; Observable&lt;PollResultType&gt;): Observable&lt;any&gt; {
        let isRequesting = false;
        return timer(0, intervalTime)
            .pipe(
                // When the service is destroyed, all polls will be unsubscribed from
                takeUntil(this.destroyed$)),
                tap(tick =&gt; console.log('tick', tick))),
                // Only continue if isRequesting is false
                filter(() =&gt; !isRequesting)),
                // Set isRequesting to true before requesting data
                tap(() =&gt; isRequesting = true)),
                // Execute your poll function
                mergeMap(pollFunction)),
                // Set isRequesting to false, so the next poll can come through
                tap(() =&gt; isRequesting = false)
            );
    }

    ngOnDestroy() {
        // When the service gets destroyed, all existing polls will be destroyed as well
        this.destroyed$.next();
        this.destroyed$.complete();
    }
}

// In this example this is a service. But this could also be a component, directive etc.
@Injectable()
export class ConsumerService {

    private subscription: Subscription;

    private requester: Observable&lt;any&gt;;

    constructor(private polling: PollingService, private http: HttpClient) {
        // Instead of calling poll and subscribing directly we do not subscribe.
        // Like that we can have a requester where we can subscribe to activate
        // the polling. You might not need that.
        this.requester = this.polling.poll(
            500,
            // This is our polling function which should return another observable
            () =&gt; this.http.get('https://cors-test.appspot.com/test')
                .pipe(
                    // Uncomment following line to add artificial delay for the request
                    // delay(2000),
                    // Don't forget to handle errors
                    catchError(error =&gt; {
                        return of('Failed');
                    })
                )
        );

        // Let's activate our poll right away
        this.activate();
    }

    activate() {
        // Deactivate on activation to deactivate any subscriptions that are already running
        this.deactivate();

        // Subscribe to activate polling and do something with the result
        this.subscription = this.requester
            // This is for testing purposes. We don't want to overload the server ;)
            .pipe(take(10))
            .subscribe(res =&gt; console.log(res));
    }

    deactivate() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = undefined;
        }
    }
}
</code></pre>

<p>Maybe some general things to note:</p>

<ul>
<li>To run this code you need to do following things:</li>
<li>Copy the code into a ts file in your source.</li>
<li>Add the PollingService and the ConsumerService to your app modules provider.</li>
<li>Add the ConsumerService as dependency somewhere, so it gets executed.</li>
<li>I set the polling time to 500 ms for testing purposes.</li>
<li>In the constructor of the ConsumerService, there is a commented out line with a delay statement. If you uncomment that line, you can simulate what happens if a request takes longer to execute. You should see the effect in the console, as long as the delay is longer as the intervalTime</li>
<li>In the ConsumerService.activate method, I limited the polls to 10, in order to not annoy the server behind the test url I'm calling.</li>
<li>It might help understand better what is going on by adding <code>tap(() =&gt; ...)</code> with console log statements between the different steps.</li>
</ul>

<p>I hope this helps. </p>
","1517357","","1517357","","2018-07-21 14:15:27","2018-07-21 14:15:27","","","","4","","","","CC BY-SA 4.0"
"50091731","1","50091882","","2018-04-29 22:04:21","","1","5772","<p>I'm writing an Angular app that gets a selection of stores from a service, as an Observable.</p>

<p>When the user clicks a marker on the map, I want to get the index of the store in the array that lives inside the Observable.</p>

<pre><code>stores: Observable&lt;Store[]&gt;;

ngOnInit() {
    this.stores = http.get&lt;Store[]&gt;('URL');
}

onMarkerClick(event) {
   const geopoint = event.geopoint;
   //How can I get the index where store.geopoint === event.geopoint?
}
</code></pre>
","929380","","929380","","2018-04-29 22:38:09","2018-04-30 08:53:48","Observable of array, find index of value","<angular><rxjs><rxjs5>","2","1","","","","CC BY-SA 3.0"
"50091882","2","","50091731","2018-04-29 22:24:56","","2","","<p>For filtering the stores from the array you do:</p>

<pre><code>this.storesCollection.filter(store =&gt; store.geopoint === event.geopoint); // -1 if not found
</code></pre>

<p>And for transforming the Observable to an Array use map:</p>

<pre><code>this.stores$.map((stores: Stores[]) =&gt; this.storesCollection = stores)
</code></pre>

<p>You don't need to do subscribe() because http returns a hot observable, always firing regardless of there being a subscriber or not</p>
","4125622","","4125622","","2018-04-30 08:53:48","2018-04-30 08:53:48","","","","1","","","","CC BY-SA 3.0"
"50099813","1","","","2018-04-30 11:42:00","","0","47","<p>I'm building a component that has a material datagrid</p>

<p>Within each row I'm creating a component dynamically and adding to the last cell, it's set up as an ellipsis (a view more button)</p>

<p>I have a function that adds them to the table cell and adds information to them from data returned from an api call</p>

<pre><code>  addEllipsisToTable() {
    setTimeout(() =&gt; {
      let sideMenu = this.sideMenu.toArray()
      // Add ellipsis menus' to returned results
      for (let i = 0; i &lt; sideMenu.length; i++) {
        const factory = this.resolver.resolveComponentFactory(this.ellipsis);
        let container = this.sideMenu.toArray()[i]
        const ellipsisComponent = container.createComponent(factory);
        ellipsisComponent.instance.data = this.returnedData[i]
      }
    }, 300)

  }
</code></pre>

<p>This works, however when I filter the records using a search field, some times the ellipsis is added twice.</p>

<p>This is the code for the search:</p>

<pre><code>let txt: Filter;
    fromEvent(this.input.nativeElement, 'keyup')
      .pipe(
        debounceTime(200),
        distinctUntilChanged(),
        tap(() =&gt; {
          this.filtersArray = [];
          txt = {
            Value: this.input.nativeElement.value,
            Operation: 5,
            Property: 'Name'
          }
          this.filtersArray.push(txt);
        })
      )
      .subscribe((data) =&gt; {
        this.paginator.pageIndex = 0;
        this.loadUserPage();//reloads datagrid
      });
</code></pre>

<p>As you type and data is returned, the getPagedInfo function gets executed, which removes the ellipsis, gets the data and then adds new ones back in:</p>

<pre><code>getPagedInfo() {
    return this.dataSource.pagedInfoSubject
      // .skip(1)
      .pipe(
        tap(() =&gt; this.removeEllipsisFromTable())
      )
      .subscribe((data) =&gt; {
        this.selection.clear();
        this.totalItems = data.totalItems;
        this.returnedData = data.returnedData;
        this.addEllipsisToTable()//This sometimes gets performed twice
        console.log(this.returnedData)
        //returnedData holds array of current visible items
        if (this.totalItems == 0) {
          this.filtersArray = [];
        } else if (this.totalItems &lt; 10) {
          this.filtersArray = [];
        }
      });
  }
</code></pre>

<p>Is there an rxjs function I can use maybe, or am I going to have to match new returned data with old and if different, then add?</p>
","1373036","","","","","2018-04-30 11:53:48","only return results if they are different, rxjs Angular","<javascript><angular><rxjs5>","0","2","","","","CC BY-SA 3.0"
"50103048","1","","","2018-04-30 14:52:31","","3","22544","<p>I am making the http service calls 3 times when i get 401 error using the retryWhen method form Rxjs operators. My problem is when i get 401 error as status i need to make other service to get the token updated and then re-try the http service call 3 times . I am unable to use service inside retryWhen call back method as it always showing this as undefined . Can you please provide me solution for this.</p>

<pre><code> return this.http.get(url, this.getOptions(options)).retryWhen(errors =&gt; {
       return errors.mergeMap((error) =&gt; {
            console.error('error status....', this, error, error.status);
            if (error.status === 401) {
                // i need to make other service call here 
                this.httpPollingService.updateToken(); // unable to call this call.
                return Observable.of(error);
            } else {
                return Observable.throw(error);
            }
        }).delay(5000).take(2);
    });
</code></pre>
","3751764","","","","","2021-11-07 23:01:45","how to use angular service inside rxjs retryWhen method","<angular><rxjs5>","2","4","2","","","CC BY-SA 3.0"
"50109847","1","","","2018-05-01 00:14:28","","1","82","<p>I have this function:</p>

<pre><code>const subs: Array&lt;Subscription&gt; = [];

const startActions = function () {

  const db = client.db('local');

  const delSub = del.subscribe(function (v: OplogDoc) {

     // ...
  });

  const insertSub = insert.subscribe(function (doc: OplogDoc) {

      // ...
  });

  const updateSub = update.subscribe(function (doc: OplogDoc) {

       // ... 
  });

  subs.push(
    delSub,
    insertSub,
    updateSub
  );
};
</code></pre>

<p>I am getting this transpilation error:</p>

<p><a href=""https://i.stack.imgur.com/B97bz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B97bz.png"" alt=""enter image description here""></a></p>

<p>Here is the type:</p>

<pre><code>export type SubjectMap = {
  [key: string]: Subject&lt;Object&gt;,
  all: Subject&lt;any&gt;,
  update: Subject&lt;Object&gt;,
  insert: Subject&lt;Object&gt;,
  delete: Subject&lt;Object&gt;,
  errors: Subject&lt;Object&gt;,
  end: Subject&lt;Object&gt;,
  del: Subject&lt;Object&gt;
}
</code></pre>

<p>so <code>delSub</code>, <code>insertSub</code>, and <code>updateSub</code> should all have the same type...anyone know what might be going on here?</p>

<p>UPDATE:</p>

<p>Did some more investigation. The type checking seems to only occur for the first argument to Array.prototype.push, and in that case, all the subscriptions fail, but now I see this fun one:</p>

<p><a href=""https://i.stack.imgur.com/g607e.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/g607e.png"" alt=""enter image description here""></a></p>
","1223975","","1223975","","2018-05-01 00:19:52","2018-05-01 00:19:52","Strange transpile error with RxJS5 Subject/Subscription","<typescript><rxjs><rxjs5><typescript2.0>","0","13","1","","","CC BY-SA 3.0"
"50140434","1","50141203","","2018-05-02 17:32:55","","1","357","<p>I have the following code. It gets an array of Patients and builds a rows object <code>this.rows</code> that I show in a table on the frontEnd of this angular 4 component (I am also using rxjs 5.5). </p>

<p>My issue is the hasAlert property of each row is assigned by a call to hasAlerts(). In the HasAlerts method, I make an http request, for each patient via <code>this.dataService.fetchItems&lt;Observation&gt;(</code>. </p>

<p><strong>When there are many patients, too many HTTP requests will occur asynchronously and they will start to fail (timeout) from HasAlerts(). Is there a way to throttle this,or process one Observable at a time from hasAlerts()?</strong></p>

<p>Below are possible ways to solve this</p>

<ol>
<li>I think concatMap may be helpful but I am not sure how to use it. Also should use it to process each patient/row or should try and aggregate each hasAlert() observable into a list and then try and use concatMap to process them one at a time?</li>
<li>A workaround is the patientsAlertsProcessed variable wrapper that I added with the comment // is done to throttle the hasAlertsMethod. I limit it to only hit that method for 15 times to avoid timeout issues. This is not ideal because I am not able to start it up again once those 15 async requests complete. </li>
</ol>

<p>Code is below</p>

<pre><code>ngOnInit(): void {
    this.store.dispatch(new patients.Load([]));

    this.patients$ = this.store.select(fromPatients.getAll); 
    var patientsAlertsProcessed =0;
    this.patients$.debounceTime(2000).map(p =&gt;{//Emits Observable&lt;Patient[]&gt;s, the debounceTime is to take the last one as it builds up
      this.rows = p.map(pat =&gt; {// p = Patient[], iterate through the array of patients
        var observations=0;
        var rowX= {
          username: pat.username,
          id: pat.id,
          hasAlert:false, 
        };

        if (patientsAlertsProcessed&lt;15){// this is done to throttle the HasAlerts Method
          this.hasAlerts(pat).do(x =&gt; {
            observations++;
            if (observations&gt;0)
            {
              rowX.hasAlert=true;
            }
          }).subscribe();
          patientsAlertsProcessed++;
        }
        return rowX;
      });
    }).subscribe(
       ()=&gt; { },
       ()=&gt; {
        this.table.recalculatePages();
      }
    );

  }
  hasAlerts(pat: Patient): Observable&lt;Observation&gt; {
    var obs$= this.dataService.fetchItems&lt;Observation&gt;(// this is making an HTTP get request 
        ""Observation"",
        null,
        pat.id
      ).filter(function (x){
        if (x.category.coding[0].code == ""GlucoseEvent""){ 
            return true;
        }
        else{
          return false; 
        }
      }
    );
    return obs$;
  }
</code></pre>
","1255713","","","","","2018-05-03 18:19:50","Synchronously process Observable to prevent too many HTTP requests from timing out using rxjs Angular and ngrx","<angular><rxjs><observable><rxjs5><ngrx>","1","0","","","","CC BY-SA 4.0"
"50141203","2","","50140434","2018-05-02 18:24:51","","2","","<p>You may want to try something along these lines.</p>

<pre><code>const concurrency = 10; 
const rowsWithAlerts = [];

this.patients$.debounceTime(2000)
.switchMap(patients =&gt; Observable.from(patients)) // patients is of type Patient[]
.mergeMap(patient =&gt; {
   rowsWithAlerts.push(patient);
   this.hasAlerts(patient).do(
   hasAlertsResult =&gt; {
     // here you have hold to both the patient and the result of
     // hasAlerts call
     patient.hasAlerts = hasAlertsResult;
   }}), concurrency)
.subscribe(
   () =&gt; this.rows = rowsWithAlerts;
)
</code></pre>

<p>The key here is to use the <code>mergeMap</code> operator with the concurrency level set to a value, in this example 10 but clearly can be anything.</p>

<p>This allows to limit the number of observables to which you subscribe at the same time, which in your case means to limit the number of http calls you make.</p>
","5699993","","5699993","","2018-05-03 18:19:50","2018-05-03 18:19:50","","","","9","","","","CC BY-SA 4.0"
"50141417","1","50143542","","2018-05-02 18:40:11","","5","1852","<p>I have an angular 5 website which consumes a restful wcf web service.  The web service, in turn, interacts with business objects, that talk to a database.  I'm using the @angular/common/http module to consume the web service into an observable object which then renders on the web page.  So far so good.</p>

<p>Now, am also updating the database via the web service, which also works fine.</p>

<p>But, it's a tad slow, and I would like to be able to update the Observable directly and simulaneously with the update web service call, so that the web site does not have to wait for the data to go through the web service, through the incredibly slow enterprise resource planning business objects, to the database, and then back down into the Observable objects, updating the screen via the async pipe.</p>

<p>So, I thought to myself, why not just replace the Observables with BehaviorSubjects?  Then, I could just use the ""next"" method on the BehaviorSubject to quickly update the page.</p>

<p>But, when I try that...</p>

<pre class=""lang-js prettyprint-override""><code>public cartons$: BehaviorSubject&lt;ICartonTrackDetail[]&gt;;
this.cartons$ = this.cartonService.getCartonsObservable();
</code></pre>

<p>I get this error...</p>

<pre><code>Type 'Observable&lt;ICartonTrackDetail[]&gt;' is not assignable to type 'BehaviorSubject&lt;ICartonTrackDetail[]&gt;'.
  Property '_value' is missing in type 'Observable&lt;ICartonTrackDetail[]&gt;'.```
</code></pre>

<p>Now, the error makes sense, but it makes me step back and wonder: What is the best way to accomplish my goal?</p>
","538253","","538253","","2018-05-02 20:07:45","2018-05-02 21:05:31","Angular 5 http.get into a BehaviorSubject to multicast data changes on the client","<angular><rxjs><angular5><rxjs5><angular-http>","1","0","","","","CC BY-SA 4.0"
"50143542","2","","50141417","2018-05-02 21:05:31","","2","","<p>you want a subject that will let you inject client-side updates into the stream and you want to merge this subject with the observable that is streaming data from the server.</p>

<p>Something like this:</p>

<pre><code>private clientStream$ : Subject&lt;ICartonTrackDetail[]&gt;;

public cartons$ : Observable&lt;ICartonTrackDetail[]&gt;;

// setup
const serverStream = this.cartonService.getCartonsObservable();
this.clientStream$ = new Subject&lt;ICartonTrackDetail[]&gt;();
this.cartons$ = serverStream.merge(this.clientStream$);

// when you get new data to send to server:
this.clientStream$.next(newData);
.. add code to send newData to server like normal ..
</code></pre>

<p>Now any code subscribing to <code>cartons$</code> will receive updates as you call <code>clientStream$.next(newData)</code></p>
","674326","","","","","2018-05-02 21:05:31","","","","7","","","","CC BY-SA 4.0"
"50149851","1","","","2018-05-03 08:01:05","","1","2941","<p>We have implemented a queue system in Javascript.</p>

<p>Consumers log items and internally it is inserted into a queue (which is an array stored in session storage).</p>

<p>A time interval is used to dequeue a number of items and to send these items to the backend.</p>

<p>How can we implement this using Rxjs and streams?</p>
","2174621","","","","","2018-05-07 11:00:32","implement queue system with RxJs","<rxjs><rxjs5>","2","0","","","","CC BY-SA 4.0"
"50171985","1","50172198","","2018-05-04 09:45:41","","2","571","<p>Im slowly starting to grasp rxjs, but once in a while i encounter things that puzzle me. </p>

<p>In this case its about the withLatestFrom operator. The rxjs statement below sits in the OnInit method of my angular component. When the screen loads, i see that the api call in the getApiData() method is executed twice, while im sure that the userEventSubject$ was never triggered (thats why i have the first tap operator).</p>

<p>What i expect to happen is that the getApiData() method only gets called when userEventSubject$.next() is called, and never when the screen loads ...</p>

<pre><code>this.userEventSubject$
    .pipe(
        tap(creditNote =&gt; console.log('tapped!')),
        takeUntil(this.ngUnsubscribe$),
        filter(userEventData =&gt; this.checkValidity(userEventData)),
        withLatestFrom(this.apiService.getApiData()),
        mergeMap(([userEventData, apiData]) =&gt; {
            let modalRef = this.modalService.show(ModalDialogComponent, {
                initialState: { apiData }
            });
            let instance = &lt;ModalDialogComponent&gt;modalRef.content;

            return instance.save.pipe(
                mergeMap((info) =&gt;
                    this.apiService.saveSomeData(userEventData, info).pipe(
                        catchError((error, caught) =&gt; {
                            instance.error = error;
                            return empty();
                        })
                    )
                ),
                tap(response =&gt; modalRef.hide())
            );
        })
    )
    .subscribe((response) =&gt; {
        this.handleResponse(response);
    });
</code></pre>

<p>Fixed version:</p>

<pre><code>this.userEventSubject$
    .pipe(
        tap(creditNote =&gt; console.log('tapped!')),
        takeUntil(this.ngUnsubscribe$),
        filter(userEventData =&gt; this.checkValidity(userEventData)),
        mergeMap(userEventData =&gt;
            this.apiService.getApiData().pipe(
                map(data =&gt; {
                    return { userEventData, data };
                })
            )
        ),
        mergeMap(values =&gt; {
            let modalRef = this.modalService.show(ModalDialogComponent, {
                initialState: { data: values.apiData }
            });
            let instance = &lt;ModalDialogComponent&gt;modalRef.content;

            return instance.save.pipe(
                mergeMap((info) =&gt;
                    this.apiService.saveSomeData(userEventData, info).pipe(
                        catchError((error, caught) =&gt; {
                            instance.error = error;
                            return empty();
                        })
                    )
                ),
                tap(response =&gt; modalRef.hide())
            );
        })
    )
    .subscribe((response) =&gt; {
        this.handleResponse(response);
    });
</code></pre>
","1854793","","1854793","","2018-05-04 10:20:03","2018-05-04 10:20:03","Dont understand why my withLatestFrom operator is being triggered","<angular><rxjs5>","1","0","","","","CC BY-SA 4.0"
"50172198","2","","50171985","2018-05-04 09:56:10","","4","","<p>When you're building the pipe, the <code>this.apiService.getApiData()</code> is not in an arrow function, but it's executed right away. It doesn't matter that the call passed as an argument. The expression gets executed as any other JS call would (try putting <code>console.log</code> in the same place).</p>

<p>You could do <code>.concatMap(userData =&gt; this.apiService.getApiData().map(apidata =&gt; {userData, apiData}))</code> (or <code>switchMap</code>), but that would call the API always. I don't know what bests suits your needs.</p>
","1956072","","","","","2018-05-04 09:56:10","","","","1","","","","CC BY-SA 4.0"
"50218784","1","50219421","","2018-05-07 16:36:15","","7","8588","<p>What is the correct expression and import for <code>Observable.of([]);</code>. </p>

<p><code>import { of } from 'rxjs';</code> does not work for me.</p>
","5798225","","13860","","2018-06-11 13:27:13","2019-04-07 17:40:56","How to get ""Observable.of([]);"" to work?","<angular><typescript><rxjs><rxjs5><rxjs6>","2","7","","","","CC BY-SA 4.0"
"50219421","2","","50218784","2018-05-07 17:19:25","","18","","<p>Since RxJS 6 you should import all ""creation"" observables directly from <code>'rxjs'</code> (assuming you have <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#build-and-treeshaking"" rel=""noreferrer"">path maps</a> set when bundling your app).</p>

<p>More detailed explanation: <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#import-paths"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#import-paths</a></p>

<pre><code>import { of } from 'rxjs';

of(1).subscribe(console.log);
</code></pre>

<p>See demo: <a href=""https://stackblitz.com/edit/typescript-e3lxkb?file=index.ts"" rel=""noreferrer"">https://stackblitz.com/edit/typescript-e3lxkb?file=index.ts</a></p>
","310726","","","","","2018-05-07 17:19:25","","","","1","","","","CC BY-SA 4.0"
"50220711","1","50220979","","2018-05-07 18:53:49","","9","7353","<p>I want an observable to be delayed depending on its value. For example:</p>

<pre><code>of(someBool).pipe(delay(1000))
</code></pre>

<p>skip delay when <code>someBool</code> is false, but wait a sec when it's true.</p>
","3263519","","","","","2021-08-20 14:13:41","Rxjs conditional delay","<rxjs5>","3","0","","","","CC BY-SA 4.0"
"50220979","2","","50220711","2018-05-07 19:14:55","","12","","<p>You can use <code>delayWhen</code> for that:</p>

<pre><code>of(someBool).pipe(
  delayWhen(val =&gt; val ? interval(1000) : of(undefined))
)
</code></pre>

<hr>

<p>Side note, according to the docs using <code>empty()</code> instead of <code>of()</code> should IMHO work, but doesn't appear to. I believe this might be a bug. I have <a href=""https://github.com/ReactiveX/rxjs/issues/3663"" rel=""noreferrer"">reported it</a>.</p>
","1675492","","1675492","","2018-05-07 20:50:18","2018-05-07 20:50:18","","","","3","","","","CC BY-SA 4.0"
"50223248","1","","","2018-05-07 22:16:38","","5","626","<p>It's a good practice to create my own Observable extended classes? i want to implement my own Single and Completable classes for the sake of know the amount or absence of data than and observable can return and i want it as a class because i use <code>reclect-metadata</code> and i use <code>design:returntype</code> in my decorators so i need a classes not an alias (because using alias the type returned will be always Object and not the original class constructor).</p>

<p>The idea is: for Single observables use the single operator and for Completable observables use the ignoreElements operators but without a class in Typescript for Singles i don't know the amount of data by only reading in the code Observable, that observable can return one or many or none and i want a Single for particular cases, this is what i want:</p>

<pre><code>// some methods in some class
loginUser(userName: string, password: string): Single&lt;User&gt;
saveUser(user: User): Completable
</code></pre>

<p>For my this is more readable (because i use RxJava 2 in my Android projects) and with that i know that expect or not, without that i need to do:</p>

<pre><code>loginUser(userName: string, password: string): Observable&lt;User&gt; // if i chain this with other observables i don't know how much users this will return
saveUser(user: User): Observable&lt;void&gt; // simply ugly
</code></pre>

<p>That is not good for my eyes you know? so i want to create that classes for a better read of my code and better implementation.</p>
","813353","","","","","2021-05-09 22:11:41","Create classes for Single, Maybe and Completable in RxJS 6","<typescript><rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50230896","1","50234131","","2018-05-08 09:58:38","","0","1752","<p>A user is typing values in a form and an event is emitted every time a user edits a particular field, with the value being the field they edited.</p>

<p>For example a user typing 3 times into the description field, followed by two times in the name field, would look like</p>

<blockquote>
  <p>""description"" => ""description"" => ""description"" => ""name"" => ""name"" => ...</p>
</blockquote>

<p>I want to buffer <em>unique</em> values and emit them as an array when the user stops typing for <em>x</em> amount of seconds. A value <em>may</em> reappear again in a different buffer window. </p>

<p>Essentially this is to track which fields were updated when the user stopped typing and communicate with the server to save the edited values.</p>

<hr>

<p>I have this so far which emits <em>every</em> 3000 ms, plus it doesn't prevent duplicates when buffering but instead we ""deduplicate"" the array afterwards. </p>

<pre><code>   this.update$
      .bufferTime(3000)
      .filter(buffer =&gt; buffer.length &gt; 0)
      .map(buffer =&gt; [...new Set(buffer)])
      .subscribe(x =&gt; console.log(x));
</code></pre>

<p>So it should listen until a value is emitted and then buffer <strong>unique</strong> values <em>until</em> no more values have been emitted for <em>x</em> seconds, then emit the buffer and repeat. How can one achieve this?</p>
","777510","","777510","","2018-05-08 10:09:48","2018-05-08 12:59:54","RxJS - Buffer unique values and emit when no other values have been emitted for x seconds?","<javascript><rxjs><rxjs5><reactive-extensions-js>","2","4","3","","","CC BY-SA 4.0"
"50234131","2","","50230896","2018-05-08 12:52:45","","1","","<p>This could be an alternate version:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { Observable } = Rx;

const log = (prefix) =&gt; (...args) =&gt; { console.log(prefix, ...args); };

const inputs = document.querySelectorAll('input');

const updates$ = Observable
  .fromEvent(inputs, 'input')
  .pluck('target', 'id')
;

// wait x ms after last update
const flush$ = updates$.debounceTime(3000);

const buffered$ = updates$
  // use `distinct` without `keySelector`, but reset with flush$
  .distinct(null, flush$)
  
  // flush the buffer using flush$ as `notifier`
  .buffer(flush$)
;

buffered$.subscribe(log('buffered$ =&gt;'));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/@reactivex/rxjs@^5/dist/global/Rx.min.js""&gt;&lt;/script&gt;

&lt;div&gt;&lt;input type=""text"" placeholder=""foo"" id=""input.foo""&gt;&lt;/div&gt;
&lt;div&gt;&lt;input type=""text"" placeholder=""bar"" id=""input.bar""&gt;&lt;/div&gt;
&lt;div&gt;&lt;input type=""text"" placeholder=""baz"" id=""input.baz""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","697154","","697154","","2018-05-08 12:59:54","2018-05-08 12:59:54","","","","1","","","","CC BY-SA 4.0"
"50247784","1","50271497","","2018-05-09 07:28:03","","4","6251","<p>In my case there are multiple requests could be performed in parallel at first, after those requests complete, another request will be sent with previous result, the pseudo code would look like</p>

<pre><code>let uploads$ = [obs1$, obs2$, obs3$];
Observable.forkJoin(uploads$).mergeMap(
  res =&gt; {
    // never get called if uploads$ = []
    let data = someCalculation(res);
    return this.http.post('http://endpoint/api/resource', data);
  }
).subscribe(
  res =&gt; {
  }
);
</code></pre>

<p>If <code>uploads$ = []</code>, the inner mergeMap never got called.</p>

<p>Can someone help? I'm on RxJS 5.4</p>
","663948","","310726","","2018-05-09 07:29:45","2018-05-10 11:06:20","rxjs, forkJoin(array).mergeMap(...), inner mergeMap never get called","<rxjs><rxjs5>","1","4","3","","","CC BY-SA 4.0"
"50262880","1","","","2018-05-09 22:21:28","","0","48","<p>I'm learning RxJS and, coming from a synchronous world, it's hard. Anyways I'm trying to do simple stuff, that is combining them.</p>

<ul>
<li><p><code>login</code> is the first <code>Observable&lt;any&gt;</code>: if it completes, I want to <strong>map</strong> the result (simply the the token property):</p>

<p><code>const login = this.userService.login({ username: username, password: password });</code></p></li>
</ul>

<p>Getting the token seems easy: <code>login.pipe(map(res =&gt; res.token));</code></p>

<ul>
<li><p><code>storage</code> is the second <code>Obsevable&lt;boolean&gt;</code>: it should take the <code>token</code> above and should return it's value (Observable, again)</p>

<p><code>const store = this.localStorage.setItem('token', token);</code></p></li>
</ul>

<p>How do I ""pass"" the <code>login</code> (mapped) result to the <code>store</code> (and make <code>store</code> wait for it)?</p>

<p><strong>Attempt 1</strong>, don't know if the second waits until the first completes:</p>

<pre><code>return this.userService.login({username: username, password: password})
  .pipe(
    map(res =&gt; res.token),
    mergeMap(token =&gt; this.localStorage.setItem(AUTH_TOKEN_KEY, token)),
    tap(res =&gt; console.log(res)) // boolean true
  );
</code></pre>
","220180","","220180","","2018-05-09 22:36:59","2018-05-09 22:36:59","RxJS v5.x Observables wait for the first, map the result and pass to the second?","<rxjs><observable><rxjs5>","0","3","","","","CC BY-SA 4.0"
"50271497","2","","50247784","2018-05-10 11:06:20","","9","","<p>It's not called b/c there is no emission on the source observable. To create one on, if observables is empty you can use the <code>defaultIfEmpty</code> or <code>toArray</code> operators.</p>

<pre><code>const observables = [];
Rx.Observable.forkJoin(observables)
  .defaultIfEmpty([]) // or .toArray()
  .mergeMap(results =&gt; Rx.Observable.of(results.length))
  .subscribe(console.log);
</code></pre>
","1984166","","","","","2018-05-10 11:06:20","","","","1","","","","CC BY-SA 4.0"
"50271560","1","50271808","","2018-05-10 11:10:40","","2","2699","<p>Below is the code snippet of my problem.</p>

<pre><code>this.locationService.getUserLocation()
    .flatMap(location =&gt; {
        // Some code
        return this.searchService.getResults(location); // returns an observable
    })
    .flatMap(searchResponse =&gt; {
        // some code  
        // NEED ANOTHER CALL with searchResponse.  --- (A)
        return this.resultsService.getCount(searchResponse.results); --- (B)
    })
    .subscribe(count =&gt; {
        console.log(count);
    });
</code></pre>

<p>Now I need to make one more call in the second flatMap block. How can I handle this?</p>

<p>If I make multiple Calls how can I subscribe multiple results and retrieve the data in subscribe?</p>

<p><strong>P.S:</strong> A and B calls can be done parallely. They just need <code>searchResponse</code> as input.</p>
","967638","","","","","2018-05-10 19:31:35","Angular + RxJS: Make multiple Server calls within flatMap and retrieve them in subscribe","<angular><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 4.0"
"50271808","2","","50271560","2018-05-10 11:23:47","","2","","<p>You can use <code>Observable.forkJoin</code>, which will make the calls in parallel and return once all of the inner observables are completed:</p>

<pre><code>this.locationService.getUserLocation()
    .flatMap(location =&gt; {
        // Some code
        return this.searchService.getResults(location); // returns an observable
    })
    .flatMap(searchResponse =&gt; {
        return Observable.forkJoin(
          this.resultsService.getCount(searchResponse.results),
          Observable.of(searchResponse) // replace with second call here
        );
    })
    .subscribe(([count, results]) =&gt; { // forkJoin returns array of results
        console.log(count, results);
    });
</code></pre>

<p>Here's more info on the <code>forkJoin</code> operator: <a href=""https://www.learnrxjs.io/operators/combination/forkjoin.html"" rel=""nofollow noreferrer"">Docs</a></p>

<hr>

<p><strong>UPDATE</strong></p>

<p>As @ChauTran noticed in comments, if your one or more of the observables do not complete (or you need to get the results before they are completed), then you can use <code>Observable.combineLatest</code> (<a href=""https://www.learnrxjs.io/operators/combination/combinelatest.html"" rel=""nofollow noreferrer"">Docs</a>).</p>

<p>This operator returns as soon as each of the inner observables emits at least <strong>once</strong>. Here's an example with <code>combineLatest</code>:</p>

<pre><code>this.locationService.getUserLocation()
    //...
    .flatMap(searchResponse =&gt; {
        return Observable.combineLatest(
          this.resultsService.getCount(searchResponse.results),
          Observable.of(searchResponse) // replace with second call here
        );
    })
    .subscribe(([count, results]) =&gt; { // forkJoin returns array of results
        console.log(count, results);
    });
</code></pre>
","2610466","","2610466","","2018-05-10 19:31:35","2018-05-10 19:31:35","","","","6","","","","CC BY-SA 4.0"
"50274719","1","","","2018-05-10 14:01:12","","1","46","<p>I have a stream that will either complete or throw an exception (ie. not an infinite stream). </p>

<p>It emits 2 values (say A and B) before it finishes. Is it possible to map the last value emitted to something else?</p>

<pre><code>stream$
    .debounceTime(100)
    .mergeMap(element =&gt;
      api(stream$, ...) // This emits A B
        .last()
        .map(lastElement =&gt; f(lastElement.result)) // produces C based on B
</code></pre>

<p>Now I have a stream containing just <code>C</code>, is it possible to keep <code>A</code> (so that the <code>$stream</code> emits <code>A C</code>) without resorting to have local variables to store the intermediate stream?</p>
","777510","","","","","2018-05-10 14:14:56","RxJS - Map over last element of a stream","<javascript><rxjs5><reactive-extensions-js>","0","0","","","","CC BY-SA 4.0"
"50274959","1","","","2018-05-10 14:12:57","","3","2601","<p>I created a timer observable to call an HTTP call like this,</p>

<pre class=""lang-ts prettyprint-override""><code>this.timer = Observable
       .timer(0, 30000)
       .switchMap(() =&gt; this.getMyData())
       .share();

 getMyData(){
     return this.http.get(this.url, this.options )
        .map(this.extractDataFromAPI)
        .retry(3)
        .catch(this.handleError)
        .share();
</code></pre>

<p>This works for calling my api every 30 seconds, however after I make an edit to the data I would like to immediately refresh the data and not wait for the timer to expire, but I do not know the proper way to do this.</p>

<p>Does anyone know how? I tried to unsubscribe and re-subscribe but that did not seem to work. Is there a better way to do this?</p>

<p>Also, are both .share()s needed?</p>
","6167534","","1127428","","2019-03-20 02:36:48","2019-03-20 02:36:48","How do I refresh an Angular HTTP call when using a timer?","<angular><rxjs><observable><rxjs5>","3","2","","","","CC BY-SA 4.0"
"50275898","1","50299917","","2018-05-10 14:59:37","","0","22","<p>Is there is an operator which allows me to map over elements of a stream but instead of transforming them, concatenating them?</p>

<p>I have a stream</p>

<blockquote>
  <p>A => B => C</p>
</blockquote>

<p><code>items$.concatMap(x =&gt; f(x))</code>
would lead to</p>

<blockquote>
  <p>""f(A)"" => ""f(B)"" => ""f(C)""</p>
</blockquote>

<p>while <code>concat</code> does not receive an element as param so that won't work either</p>

<p>I want to achieve:</p>

<blockquote>
  <p>""A"" => ""B"" => ""C"" => ""f(A)"" => f(B) => ""f(C)""</p>
</blockquote>

<p>This will do it but I have to annoyingly break up and store my stream (I guess it's fine for a small example but on a longer pipeline it is more troublesome).</p>

<pre><code>item$ = Observable.of(""A"",""B"",""C"");

item$.concat(item$.map(x =&gt; f(x)));
</code></pre>
","777510","","777510","","2018-05-10 15:08:23","2018-05-11 20:35:53","RxJS - concatenate mapped elements onto a stream","<javascript><rxjs5><reactive-extensions-js>","1","0","","","","CC BY-SA 4.0"
"50290874","1","","","2018-05-11 11:02:40","","1","179","<p>I am trying to use RxJS pipeable operators in my angular project. I have an implementation as below.</p>

<pre><code>// Service Method
public getItems(params: Object = {}): Observable&lt;JsendResponse&gt; {
    return this.apiService.get('v1/url', params);
}

// JsendResponse interface
import { Response } from '@angular/http';

export interface JsendResponse extends Response {
    data: any;
    message: string;
    status: number;
}

// Component call
this.service
    .getItems({})
    .finally(() =&gt; this.loading = false)
    .subscribe(
         response =&gt; this.actions = response.data,
         error =&gt; this.errors = error
    );
</code></pre>

<p>In the above example, I am getting the <code>response</code> typed correctly with <code>JsendResponse</code> type. But when I use <code>pipe</code> operator, the <code>response</code> is not typed correctly and my IDE is telling that <code>TS2339: Property 'data' does not exist on type {}</code>.</p>

<pre><code>this.service
    .getItems({})
    .pipe(
        finalize(() =&gt; this.loading = false)
    )
    .subscribe(
        response =&gt; this.actions = response.data,
        error =&gt; this.errors = error
    );
</code></pre>

<p>What could be the reason? Thanks in advance.</p>
","1816449","","6120338","","2018-05-13 18:14:40","2018-05-13 18:14:40","RxJS type issue in subscribe for pipeable operators","<angular><typescript><rxjs5><tslint><rxjs-pipeable-operators>","0","3","","","","CC BY-SA 4.0"
"50299917","2","","50275898","2018-05-11 20:35:53","","0","","<p>I finally discovered the right operator for this (at the time of writing I couldn't find it in the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""nofollow noreferrer"">RxJS 5 docs</a>), but it is called <code>let</code> and gives you the whole current observable as an argument.</p>

<pre><code>item$.let(obs$ =&gt; obs$.concat(obs$.map(f));
</code></pre>

<p>Which is not really impressive if its the first operation, it's really useful but you could have more stuff in front and want to avoid having to stop and store the stream in a local variable:</p>

<pre><code>item$.debounce(1000)
     .map(z =&gt; f(z.id))
     .moreOperators(...)
     .let(obs$ =&gt; obs$.concat(obs$.map(f));
</code></pre>
","777510","","","","","2018-05-11 20:35:53","","","","0","","","","CC BY-SA 4.0"
"50304528","1","50369204","","2018-05-12 09:02:24","","0","1685","<p>i'm making an app in Angular (5), and i'm not very practice with Subject.
I want catch the Observable error in my component, but i can't do.
This is my code</p>

<p>My model:
<strong>example-model.ts</strong></p>

<pre><code>export class ExampleModel { 
    public value: string; 
}
</code></pre>

<p>My Service:
<strong>example-model-service</strong></p>

<pre><code>@Injectable()
export class ExampleModelService implements OnDestroy{

  destroy$: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();
  private exampleModel$ = new ReplaySubject&lt;ExampleModel&gt;(1);

  constructor() { }

  exampleModelInit(){
    //Observable.from([{'value': 'Hello World'}])
    Observable.create(sub =&gt; sub.error('Observable Error'))
      .pipe(
        distinctUntilChanged(),
        takeUntil(this.destroy$)
      )
      .subscribe((exampleModel: ExampleModel) =&gt; {
        this.sendExampleModel(exampleModel);
      },
        err =&gt; this._handleError(err));
  }

  private _handleError(err: any) {
    return Observable.throw(err);
  }

  private sendExampleModel(exampleModel: ExampleModel) {
    this.exampleModel$.next(exampleModel);
  }

  public whenExampleModel(): Observable&lt;ExampleModel&gt; {
    this.exampleModelInit();
    return this.exampleModel$.asObservable();
  }

  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.unsubscribe();
  }
}
</code></pre>

<p>My Component:
<strong>home-component.ts</strong></p>

<pre><code>export class HomeComponent implements OnInit, OnDestroy {

  public exampleModel$: Observable&lt;ExampleModel&gt;;

  public unsubscribe$: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();

  controls: boolean = false;
  indicators: boolean = false;

  constructor(private exampleModelService$: ExampleModelService) {
  }

  ngOnInit() {
  }

  getExampleModel() {
    this.exampleModel$ = this.exampleModelService$.whenExampleModel();

  }

  ngOnDestroy(): void {
    this.unsubscribe$.next(true);
    this.unsubscribe$.unsubscribe();
  }

}
</code></pre>

<p>I want catch my error in <code>getExampleModel()</code>, i tried with <code>.catch</code> with no result.</p>

<p>Thanks</p>
","9390208","","","","","2018-05-16 11:29:46","Angular - Catch error in component","<angular><observable><angular5><rxjs5>","2","0","","","","CC BY-SA 4.0"
"50310637","1","50322466","","2018-05-12 21:01:35","","0","724","<p>i have an issue when user click very fast on two buttons that update in firebase database same object and the same property. the issue that only one of the request save and the rest override. its happen in case user clicked on both button on the same second.</p>

<p>my question is if there a way to execute the click streams with minimum delay between them. i want that there will be minimum of 2 seconds between every execution. thanks for the help.</p>

<p>I want to record all clicks but execute the functionality with minimum delay between. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>(function($){ 
    $(function($, undefined){
       var count = 0;
        const click$ = Rx.Observable.fromEvent($('.btn'), 'click').share();

        click$
            .map((ev)=&gt; {
                count ++;
                return count;
            })
            .bufferTime(1000)
            .filter(buffer =&gt; buffer.length &gt; 0)
             
            .do((buffer) =&gt; console.log(`new buffer: ${buffer}`))
            .map((buffer)=&gt; {
              return  Rx.Observable.fromArray(buffer).concatMap(streams =&gt; Rx.Observable.of(streams).delay(2000))
            })
            .flatMap((s)=&gt; s)
            .subscribe((a)=&gt; {
                console.log(`${a} : ${new Date()}`)
            });
    });

})(jQuery);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js""&gt;&lt;/script&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
&lt;head&gt;
    &lt;meta charset=""UTF-8""&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button class=""btn""&gt;Click&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>the issue is when i click multiple times more than second. streams from different buffer will execute on the same time. how i can solve it :(
example: </p>

<p>new buffer: 1,2,3,4</p>

<p>new buffer: 5,6,7,8,9,10</p>

<p>1 : Sat May 12 2018 17:22:29 GMT-0600 (MDT)</p>

<p>new buffer: 11,12,13</p>

<p>5 : Sat May 12 2018 17:22:30 GMT-0600 (MDT)</p>

<p>2 : Sat May 12 2018 17:22:31 GMT-0600 (MDT)</p>

<p>11 : Sat May 12 2018 17:22:31 GMT-0600 (MDT)</p>

<p>2 and 11 happened on the same time. how i can solve it :(</p>
","8987378","","8987378","","2018-05-13 05:19:27","2018-05-14 02:41:03","separate stream of click events by minimum delay between each other with Rxjs","<firebase-realtime-database><rxjs><rxjs5><data-stream><rxjs-dom>","2","3","","","","CC BY-SA 4.0"
"50314536","1","50314951","","2018-05-13 09:13:22","","3","1247","<p>I have this service in the services file which is an http call.</p>

<pre><code>    export class BackendServices {
      addons: IAddons[];   
      constructor(private http: HttpClient) { 
        this.getWorkOrders();
      }
     getAddons() {
      this.http.get&lt;IAddons&gt;(this.BASE_URL + '/addons/')
      .subscribe((data: any) =&gt; {
          this.addons = data;
      });
    }
</code></pre>

<p>COMPONENT PART
Then from my main component I have a button which calls the modal dialog. Here is the code of the main component:</p>

<pre><code>export class OrdersComponent { 
openAddonsDialog() {
    let dialogRef = this.pickAddonsDialog.open(PickaddonsComponent);
  }
}
</code></pre>

<p>And then I am calling the getAddons method which is on the service from the constructor of the dialog.
I am just wondering how do we make the modal dialog open only when the addons property has received data from the http call.</p>

<pre><code>export class PickaddonsComponent implements OnInit {
    constructor(public bs: BackendServices) {
        this.bs.getAddons();
    }
</code></pre>

<p>But it says this.service.getAddons() is undefined. Read a lot about this on stackoverflow, tried quite a few steps from different posts, but none helped me so far.</p>
","3826733","","3826733","","2018-05-13 18:40:11","2018-05-13 19:11:59","Angular - Calling method on service from component returns undefined","<angular><observable><rxjs5>","1","8","","","","CC BY-SA 4.0"
"50314951","2","","50314536","2018-05-13 10:05:21","","1","","<p>It seems that initialized <code>BackendService</code> has attribute <code>addons</code> undefined. Which is true. Because it is set only when calling method <code>getAddons</code>.</p>

<p>Try this:</p>

<pre><code>export class BackendServices {
  addons: IAddons[] = [];   
  constructor(private http: HttpClient) { 
    this.getWorkOrders();
  }
 getAddons() {
  return this.http.get&lt;IAddons&gt;(this.BASE_URL + '/addons/')
  .subscribe((data: any) =&gt; {
      this.addons = data;
  });
}
</code></pre>

<p>Replacing </p>

<pre><code> addons: IAddons[];
</code></pre>

<p>with</p>

<pre><code> addons: IAddons[] = [];   
</code></pre>
","4274679","","4274679","","2018-05-13 18:56:17","2018-05-13 18:56:17","","","","10","","","","CC BY-SA 4.0"
"50322466","2","","50310637","2018-05-14 02:41:03","","1","","<p>How about this one, but normally you can replace the timer function with http call, you cannot really sure about how long the http call will take.</p>

<pre><code>const click$ = Rx.Observable.fromEvent(btn, 'click')

click$.concatMap(e=&gt;click$.concatMap(e=&gt;Rx.Observable.timer(2000)))
.subscribe(a=&gt; console.log(`${a} : ${new Date()}`));
</code></pre>
","8618350","","","","","2018-05-14 02:41:03","","","","2","","","","CC BY-SA 4.0"
"50369204","2","","50304528","2018-05-16 11:04:11","","0","","<p>First problem is you are using a asynchronous method as a normal method that return a value when is executed.</p>

<p>Then, the first change that we need to make is move logic for catch error in this.exampleModelService$.whenExampleModel(); method.</p>

<p>The whenExampleModel() method must return an observable to the consumer for can obtaing asynchronus result. <strong>An asynchronus result is a result that will come in the future but not is available</strong></p>

<p>Try to change this</p>

<pre><code>    @Injectable()
export class ExampleModelService implements OnDestroy{

  destroy$: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();
  private exampleModel$ = new ReplaySubject&lt;ExampleModel&gt;(1);
  private obs : Observable&lt;ExampleModel&gt;;

  constructor() { }

  exampleModelInit(){
    //Observable.from([{'value': 'Hello World'}])
    this.obs = Observable.create(sub =&gt; sub.error('Observable Error'))
      .pipe(
        distinctUntilChanged(),
        takeUntil(this.destroy$)
      );
  }

  private _handleError(err: any) {
    return Observable.throw(err);
  }

  private sendExampleModel(exampleModel: ExampleModel) {
    this.exampleModel$.next(exampleModel);
  }

  public whenExampleModel(): Observable&lt;ExampleModel&gt; {
    this.exampleModelInit();
    return this.obs;
  }

  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.unsubscribe();
  }
}
</code></pre>

<p><strong>Component</strong></p>

<p>whenExampleModel.subscribe(s=>{},e=>{});</p>
","9606376","","9606376","","2018-05-16 11:29:46","2018-05-16 11:29:46","","","","0","","","","CC BY-SA 4.0"
"50372973","1","","","2018-05-16 14:01:31","","0","376","<p>I have a function in which I'm calling an instance of <code>Manager</code>'s <code>onSpecificData()</code> to which I'm subscribing in order to update my application's state (I'm managing a state on the server-side as well).</p>

<p>The problem is that in the <code>SomeManager</code>'s implementation of <code>onSpecificData()</code> I'm merging 3 different <code>Observable</code>s using <code>merge()</code> operator, which for some reason triggers the invocation of all the underlying <code>Observable</code>'s operators even though only 1 of the sources is the one that's emitting a value</p>

<p><strong>SomeManager.ts</strong></p>

<pre><code>export class DerivedManager implements Manager {
    private driver: SomeDriver;

    constructor(...) {
        this.driver = new SomeDriver(...);
    }

    public onSpecificData(): Observable&lt;DataType&gt; {
        return merge(
            this.driver.onSpecificData(Sources.Source1).map((value) =&gt; {
                return {source1: value};
            }),
            this.driver.onSpecificData(Sources.Source2).map((value) =&gt; {
                return {source2: value};
            }),
            this.driver.onSpecificData(Sources.Source3).map((value) =&gt; {
                return {source3: value};
            })
        );
    }
</code></pre>

<p><strong>Manager.ts</strong></p>

<pre><code>export type DataType = Partial&lt;{value1: number, value2: number, value3: number}&gt;;

export interface Manager {
    onSpecificData(): Observable&lt;DataType&gt;;
}
</code></pre>

<p><strong>SomeDriver.ts</strong></p>

<pre><code>export const enum Sources {
    Source1,
    Source2,
    Source3,
}

export class SomeDriver extends Driver {
    private static specificDataId = 1337; // some number

    private handler: Handler;

    constructor(...) {
        super(...);
        this.handler = new Handler(this.connection, ...);
        // ...
    }

    // ...

   onSpecificData(source: Sources): Observable&lt;number&gt; {
       return this.handler
           .listenToData&lt;SpecificDataType&gt;(
               SomeDriver.specificDataId,
               (data) =&gt; data.source === source)
           ).map((data) =&gt; data.value);
   }
}
</code></pre>

<p><strong>Driver.ts</strong></p>

<pre><code>export abstract class Driver {
     protected connection: Duplex;

     constructor(...) {
         // init connection, etc...
     }

     public abstract onSpecificData(source: number);

     // some implementations and more abstract stuff...
}
</code></pre>

<p><strong>Handler.ts</strong></p>

<pre><code>export class Handler {
    private data$: Observable&lt;Buffer&gt;;

    constructor(private connection: Duplex, ...) {
        this.data$ = Observable.fromEvent&lt;Buffer&gt;(connection as any, 'data');
    }

    listenToData&lt;T&gt;(dataId: number, filter?: (data: T) =&gt; boolean) {
        return this.data$
            .map((data) =&gt; {
                 // decode and transform
            })
            .filter((decodedData) =&gt; !decodedData.error &amp;&amp; decodedData.value.id)
            .do((decodedData) =&gt; {
                 console.log(`Got ${decodedData.value.id}`);
            })
            .map((decodedData) =&gt; decodedData.value.value as T)
            .filter(filter || () =&gt; true);
    }
}
</code></pre>

<p>And finally, <code>subscribe()</code>-ing:</p>

<pre><code>export default function(store: Store&lt;State&gt;, manager: Manager) {
    // ...

    manager.onSpecificData()
        .subscribe((data) =&gt; {
            // update state according to returned data
        });
}
</code></pre>

<p>As you can see, there is only <strong>1</strong> underlying <code>Observable</code> (<code>data$</code>) but apparently the operator chain in <code>listenToData&lt;T&gt;()</code> is invoked <strong>3</strong> times <em>for each value</em> emitted by it. I already know this is because of <code>SomeManager#onSpecificData()</code>'s <code>merge</code> of those 3 <code>Observable</code>s, but I don't know why this happens. I want it to be invoked once for each value.</p>

<p>Help will be much appreciated.</p>
","8592430","","8592430","","2018-05-16 14:31:54","2018-05-17 07:16:27","Operators invoked multiple times for merged Observable although only one source emits","<node.js><typescript><rxjs><rxjs5>","1","6","","","","CC BY-SA 4.0"
"50376325","1","","","2018-05-16 16:56:26","","3","857","<p>I am in the middle of migrating my Angular 5 application from using rxjs 5 to rxjs 6. A big part of this is the change from using dot-chaining to using .pipe(). My application is using ngrx, and I am having trouble with Effects. When using rxjs 5, this works.</p>

<pre><code>@Effect() public onSave$: void | Observable&lt;void|{}&gt; =
this.actions.ofType&lt;DashboardGroupsActions.Save&gt;(DashboardGroupsActions.SAVE_DASHBOARD_GROUPS)
  .map((action: DashboardGroupsActions.Save) =&gt; action.payload)
  .switchMap((payload: DashboardGroups) =&gt; {

      return this.api.saveDashboardGroup(payload);
  })
  .catch(() =&gt; {

      return Observable.of();
  });
</code></pre>

<p>Below is what my code looks like after converting the dot-chaining to .pipe(). But now I also get the following error that I can't seem to fix. </p>

<p>""Property 'pipe' does not exist on type '<code>Actions&lt;Action&gt;</code>'""</p>

<pre><code>import { Observable, pipe, of } from 'rxjs';
import { catchError, filter, map, mergeMap, switchMap } from 'rxjs/operators';
import { Action, Store } from '@ngrx/store';
import { Actions, Effect, ofType } from '@ngrx/effects';

@Effect() public onSave$: Observable&lt;{}|Action&gt; = this.actions.pipe(
      ofType&lt;DashboardGroupsActions.Save&gt;(DashboardGroupsActions.SAVE_DASHBOARD_GROUPS),
      map((action: DashboardGroupsActions.Save) =&gt; action.payload),
      switchMap((payload: DashboardGroups) =&gt; {

          return this.api.saveDashboardGroup(payload);
      }),
      catchError(() =&gt; {

          return of({});
      })
  );
</code></pre>

<p>Any help is much appreciated.</p>
","9800971","","9800971","","2018-05-30 17:58:01","2018-05-30 17:58:01","ngrx help for migrating from rxjs 5 to 6","<rxjs5><ngrx-effects><rxjs6>","0","2","","","","CC BY-SA 4.0"
"50412389","1","50412516","","2018-05-18 13:26:14","","2","1596","<p>I upgraded my Angular application from version 5.2 to 6.0 with the instructions from <a href=""https://update.angular.io"" rel=""nofollow noreferrer"">https://update.angular.io</a>. </p>

<p>Now my Angular application doesn't build because of the ""rxjs-5-to-6-migrate"" migration:</p>

<blockquote>
  <p>ERROR in bla.ts: error TS2339:
  Property 'map' does not exist on type 'Observable'.</p>
</blockquote>

<p>I have the following imports:</p>

<pre><code>import { Observable } from 'rxjs/observable';
import { of } from 'rxjs/observable/of';
import { map } from 'rxjs/operators';
</code></pre>

<p>If I change the imports like this it works:</p>

<pre><code>import { Observable } from 'rxjs/observable';
import 'rxjs/Rx';
</code></pre>

<p>But I don't understand why... I want to use the explicit imports and not import all operators.</p>

<hr>

<p><strong>UPDATE:</strong> As some answers pointed out I have to use pipes to be able to use operators. This was my problem because I thought I can still chain the operators to the observables.</p>

<p><em>Old Style:</em></p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';

this.http.get('/api/appsettings/get').map(data =&gt; { return true; }).catch(() =&gt; { return Observable.of(false); });
</code></pre>

<p><em>New Style</em></p>

<pre><code>import { of,  Observable } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

this.http.get('/api/appsettings/get').pipe(map(data =&gt; { return true; }), catchError(() =&gt; { return of(false); }));
</code></pre>
","2301612","","2301612","","2018-05-18 13:55:33","2018-05-18 14:21:28","Property 'map' does not exist on type 'Observable' after upgrading rxjs to 6","<angular><rxjs><rxjs5><rxjs6><rxjs-compat>","3","2","1","","","CC BY-SA 4.0"
"50412516","2","","50412389","2018-05-18 13:33:54","","5","","<p>You need to use <code>pipe</code> method on Observable and pass map function inside, like:</p>

<pre><code>import { of } from 'rxjs';
import { map } from 'rxjs/operators';

of([1,2,3]).pipe(
  map(i =&gt; i*2)
);
</code></pre>
","9811936","","9811936","","2018-05-18 13:54:47","2018-05-18 13:54:47","","","","4","","","","CC BY-SA 4.0"
"50436726","1","","","2018-05-20 16:00:05","","0","22","<p>Let's say there is function that returns observable, and the function has an argument</p>

<pre><code>getObservable(arg){
   return obs$.pipe(map(data =&gt; { // wanna use arg here }));
}
</code></pre>

<p>I am probably being paranoid here but it always confuses me if I can use <code>arg</code> inside map's callback and therefore I use <code>combineLatest</code> or <code>withLatestFrom</code> to send <code>arg</code> inside operator which feels redundant, but I am not sure.</p>

<pre><code>getObservable(arg){
   return combineLatest(of(arg), obs$).pipe(
     map(([arg, data]) =&gt; {})
   );
}
</code></pre>

<p>Could there be any problem if I go with the first way?</p>
","3263519","","","","","2018-05-20 16:00:05","Usage of non-argument variables in rxjs operators","<rxjs5>","0","2","","","","CC BY-SA 4.0"
"50448421","1","","","2018-05-21 11:59:17","","0","229","<p>I'm using rxjs in my application.</p>

<p>In <strong>package.json</strong> my rxjs dependency is <code>""rxjs"": ""^5.2.0""</code></p>

<p>From that I'm using the ajax module:</p>

<pre><code>import { ajax } from 'rxjs/observable/dom/ajax'
</code></pre>

<p>I can't find the documentation for the ajax function.</p>

<p>My code:</p>

<pre><code>let categories = action.payload.subcategories.map(cat =&gt; cat.id)
let shop = JSON.stringify(action.payload.shop)
action.payload.categories = JSON.stringify(categories)
action.payload.shop = shop
return ajax
  .post('http://192.xxx.xxxx:4000/products', action.payload, {
    'Content-': 'application/json'
  })
</code></pre>

<p>I'm getting an issue where if the <code>shop</code> object has an ampersand in one of its fields, that breaks the json.stringified object being sent.</p>

<p>How do I allow ampersands in the text fields of the objects being json.stringified without breaking the field?</p>

<p>Do I have to url encode it? It will just mean a bit more work on the back end to decode so I'm looking at my options. </p>

<p><a href=""https://stackoverflow.com/a/3319145/3935156"">This SO answer</a> seems like an easy way to do it although I'm not using jquery and I don't know how to set request type to data object in the <code>ajax.post</code> function being used.</p>

<p>action.payload:</p>

<p><a href=""https://i.stack.imgur.com/vSPjc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vSPjc.png"" alt=""enter image description here""></a></p>

<p>The actual form data being sent (network tab in developer console)</p>

<p><a href=""https://i.stack.imgur.com/tsthV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tsthV.png"" alt=""enter image description here""></a></p>

<p>I noticed when I used <code>encodeURIComponent()</code> in javascript it did change the payload massively. I have the backend decoding json currently so would like to avoid changing the payload that much if possible. The back end is in Elixir.</p>
","3935156","","3935156","","2018-05-21 12:57:26","2018-05-21 12:57:26","Ajax request with using rxjs problems with ampersand","<javascript><ajax><rxjs><rxjs5>","0","2","","","","CC BY-SA 4.0"
"50477107","1","50477183","","2018-05-22 22:06:04","","1","290","<p>I often end up with a situation where i got an array with arguments and have to manually break the array into parts. For example</p>

<pre><code>Observable.combineLatest(obs1$, obs2$, obs3$).subscribe((data) =&gt; {
  let fancyArg = data[0];
  let epicArg = data[1];
  let wonderfulArg = data[2];
})
</code></pre>

<p>Is there a shortcut to do something like this</p>

<pre><code>Observable.combineLatest(obs1$, obs2$, obs3$)
  .subscribe([fancyArg, epicArg, wonderfulArg] =&gt; { //something like this
    ...                                             //would be great
  })
</code></pre>

<p>I know that there is the option with the last argument as function</p>

<pre><code>Observable.combineLatest(obs1$, obs2$, obs3$, 
  (arg1, arg2, arg3) =&gt; {
    return {
      fancyArg:arg1, 
      epicArg:arg2, 
      wonderfulArg:arg3
    }
  })
  .subscribe((args) =&gt; {
    ...
  })
</code></pre>

<p>but this is also very unhandy. I look for a more general approach (to use it by bindCallback and other functions as well)</p>
","1280664","","","","","2018-05-22 22:28:20","Is there a way to map array items to function parameters in typescript directly?","<typescript><rxjs><rxjs5><typescript2.0>","1","0","","","","CC BY-SA 4.0"
"50477183","2","","50477107","2018-05-22 22:15:52","","3","","<p>Javascript has <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"" rel=""nofollow noreferrer"">destructuring assignment</a> which you can use in your parameter list to unpack an array. Example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function takeAnArray([firstItem, secondItem, thirdItem]) {
  console.log(firstItem, secondItem, thirdItem);
}

takeAnArray([1, ""a"", false]);</code></pre>
</div>
</div>
</p>

<p>So you were almost right in your second snippet. You just need to add a pair of parenthases around the argument list:</p>

<pre><code>Observable.combineLatest(obs1$, obs2$, obs3$)
  .subscribe(([fancyArg, epicArg, wonderfulArg]) =&gt; {
    // Here, fancyArg is the first array element,
    // epicArg is the second
    // wonderfulArg is the third
  })
</code></pre>

<p>The <a href=""https://www.learnrxjs.io/operators/combination/combinelatest.html"" rel=""nofollow noreferrer"">documentation for <code>combineLatest</code></a> even shows this syntax in it's first example.</p>
","6293409","","6293409","","2018-05-22 22:28:20","2018-05-22 22:28:20","","","","2","","","","CC BY-SA 4.0"
"50484585","1","50484907","","2018-05-23 09:23:35","","0","1079","<p>In my Angular2 app I have an <em>api.service</em> with method <em>sendRequest</em> that should do following:</p>

<ol>
<li>Sends request to the server </li>
<li>Returns promise to the caller (I want callers to get success responses only)</li>
<li>If error occured handle the error localy (navigate user to login or show a popup)</li>
</ol>

<p>I implemented it using Promise:</p>

<pre><code>sendRequest(method: string, url: string, data: any) : Promise&lt;any&gt; {
    return this.http.request(method, url, {
        body: data,
        headers: {
            'Accept': 'application/json, text/plain, */*',
            'Authorization': 'bearer ' + token,
            'Content-Type': 'application/json;charset=UTF-8'
        }
    }).toPromise().catch((res) =&gt; this.handleError(res));
}

handleError(response: any) {
    if (response.status === 401 || response.status === 403) {
        this.tokenService.deleteToken();
        this.router.navigate(['login']);
    }
    // Show popup etc.
    ...
}
</code></pre>

<p>I'd like to replace promise by observable:</p>

<pre><code>sendRequest(method: string, url: string, data: any) : Observable&lt;any&gt; {...}
</code></pre>

<p>Please advise how to do that. Thank you.</p>

<p><strong>EDIT 1</strong>: I found examples that handled response and then passed some result to the observer. That's not what I need. If error occurs the observer shouldn't be notified at all. Observers should be notified only if a successful response arrived. If error occurs it should be processed inside <em>api.service</em> only.</p>
","1071282","","1071282","","2018-05-23 09:34:01","2018-05-23 09:39:04","How to handle HTTP errors in API service and return response through Observable only in case of success?","<angular><rxjs><angular2-services><rxjs5><angular2-observables>","3","1","","","","CC BY-SA 4.0"
"50484907","2","","50484585","2018-05-23 09:39:04","","0","","<pre><code>sendRequest(method: string, url: string, data: any) : Observable&lt;any&gt; {
    return this.http.request(method, url, {
        body: data,
        headers: {
            'Accept': 'application/json, text/plain, */*',
            'Authorization': 'bearer ' + token,
            'Content-Type': 'application/json;charset=UTF-8'
        }
    }).map((response: Response) =&gt; &lt;any&gt;response.json()).catch(this.handleError);
}

handleError(response: any) {
    if (response.status === 401 || response.status === 403) {
        this.tokenService.deleteToken();
        this.router.navigate(['login']);
    }
    // Show popup etc.
    ...
}

//get response like below
  this.yoursevice.sendRequest(resdata)
        .subscribe((resdata) =&gt; {}, 
(error) =&gt; {
            this.statusMessage =
                'Problem with the service. Please try again after sometime';
            console.error(error);
        }););
</code></pre>
","4757394","","","","","2018-05-23 09:39:04","","","","0","","","","CC BY-SA 4.0"
"50487056","1","50487294","","2018-05-23 11:18:42","","0","48","<p>I want to manipulate properties of an object but streaming the whole object</p>

<p>Is there a shortcut for this beauty?</p>

<pre><code>Observable.of(data)
  .map((data) =&gt; {data.newDueDate = this.filterDate(data.newDueDate); return data;})
  .map((data) =&gt; {data.reply = this.generateReply(data.request); return data;})
  ...
</code></pre>

<p>I am searching for something like this, so i can alter the <code>data</code> object in <strong>clear atomic steps</strong>. </p>

<pre><code>Observable.of(data)
  .mapProperty('newDueDate' =&gt; this.filterDate)
  .mapProperty('reply' =&gt; this.generateReply(data.request))
  ...
</code></pre>
","1280664","","1280664","","2018-05-23 11:34:58","2018-05-23 11:41:16","rxjs shortcut for mapping of one property but streaming the whole object","<rxjs><rxjs5>","2","1","","","","CC BY-SA 4.0"
"50487294","2","","50487056","2018-05-23 11:30:31","","1","","<p>You can use <code>do</code>:</p>

<pre><code>Observable.of(data)
  .do(data =&gt; {
     data.newDueDate = this.filterDate(data.newDueDate);
     data.reply = this.generateReply(data.request);
  })
</code></pre>

<p>Edit to the comment:</p>

<pre><code>Observable.of(data)
  .do(data =&gt; data.newDueDate = this.filterDate(data.newDueDate))
  .do(data =&gt; data.reply = this.generateReply(data.request))
</code></pre>

<p>You can do that or create or own custom operator, but I think that's too much.</p>
","1124350","","1124350","","2018-05-23 11:41:16","2018-05-23 11:41:16","","","","2","","","","CC BY-SA 4.0"
"50502741","1","","","2018-05-24 06:49:09","","0","196","<p>Given the following javascript pseudo code (example 1),<br>
as you can see, there are <code>3 async streams</code> which in turn write to the response. They will of course write to the response in an async way, so the order of the chunks is not kept (it is actually unpredictable).</p>

<pre class=""lang-js prettyprint-override""><code>import pre from './pre';
import content from './content';
import post from './post';

export function renderIndex(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/html; charset=utf-8',
    'Transfer-Encoding': 'chunked',
  });

  const onEnd = () =&gt; {
    if(!pre._readableState.ended) return;
    if(!body._readableState.ended) return;
    if(!post._readableState.ended) return;

    res.end();
  };

  pre.on('data', (chunk) =&gt; { res.write(chunk); }).on('end', onEnd);
  body.on('data', (chunk) =&gt; { res.write(chunk); }).on('end', onEnd);
  post.on('data', (chunk) =&gt; { res.write(chunk); }).on('end', onEnd);
}
</code></pre>



<p>is it possible to tell the client the position of each chunk of data?</p>

<p>I'd like to achieve something like this:</p>

<pre class=""lang-js prettyprint-override""><code>// ---- Stream 1 keep open
&lt;html&gt;
  &lt;head&gt;
  ...
  ...
  ...
  ...


// --- Stream 2 keep open

&lt;body&gt;
  ...
  ...
  ...

// --- Stream 3 keep open
&lt;script src=""...""&gt;&lt;/script&gt;
&lt;script src=""...""&gt;&lt;/script&gt;
&lt;script src=""...""&gt;&lt;/script&gt;


// --- Stream 1 CLOSE
  &lt;/head&gt;

// --- Stream 2 CLOSE
  &lt;/body&gt;

// --- Stream 3 CLOSE
  &lt;/html&gt;


// res.end()
</code></pre>



<ol>
<li><a href=""https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests"" rel=""nofollow noreferrer"">Range Requests</a></li>
<li><a href=""https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests#Multipart_ranges"" rel=""nofollow noreferrer"">Multipart Range</a></li>
</ol>

<h3>Marble-like Explanation:</h3>

<ul>
<li><strong>actual</strong>: <code>[pre] [post] [body] [pre] [body] [/pre] [/post] [/body]</code></li>
<li><strong>desired</strong> <code>[pre] [/pre] [body] [/body] [post] [/post]</code></li>
</ul>
","4099454","","4099454","","2018-05-24 09:18:30","2018-05-24 09:18:30","Dynamic Chunked Response in NodeJS","<javascript><node.js><httpresponse><rxjs5><multipart>","2","6","1","","","CC BY-SA 4.0"
"50515357","1","50519552","","2018-05-24 17:49:41","","3","1607","<p>I have a message queue processor that feeds messages to a service...</p>
<pre class=""lang-js prettyprint-override""><code>q.on(&quot;message&quot;, (m) =&gt; {
  service.create(m)
    .then(() =&gt; m.ack())
    .catch(() =&gt; n.nack())
})
</code></pre>
<p>The service uses an RxJS Observable and subscription to <code>debounceTime()</code> those requests.</p>
<pre class=""lang-js prettyprint-override""><code>class Service {
  constructor() {
    this.subject = new Subject()
    this.subject.debounceTime(1000)
      .subscribe(({ req, resolve, reject }) =&gt;
        someOtherService.doWork(req)
          .then(() =&gt; resolve())
          .catch(() =&gt; reject())
      )
  }

  create(req) {
    return new Promise((resolve, reject) =&gt;
      this.subject.next({
        req,
        resolve,
        reject
      })
    )
  }
}
</code></pre>
<p>The issue is that only the debounced request gets ackd/nackd.  How can I ensure that the subscription also resolves/rejects the other requests?  <code>bufferTime()</code> gets me a part of the way there, but it does not reset the timeout duration on each call to <code>next()</code>.</p>
","137623","","74089","","2021-03-12 13:36:25","2021-03-12 13:41:17","Debounce and buffer an rxjs subscription","<rxjs><rxjs5>","2","4","1","","","CC BY-SA 4.0"
"50519552","2","","50515357","2018-05-24 23:31:51","","3","","

<p>The <code>debounceTime</code> operator that you are currently using can be used to create an observable that can notify <code>buffer</code> of when the current buffer should be closed.</p>

<p>Then, <code>buffer</code> will emit an array of the messages that were received whilst debouncing and you can do with them whatever you want:</p>

<pre class=""lang-js prettyprint-override""><code>this.subject = new Subject();
const closingNotifier = this.subject.debounceTime(1000);
this.subject.buffer(closingNotifier).subscribe(messages =&gt; {
  const last = messages.length - 1;
  messages.forEach(({ req, resolve, reject }, index) =&gt; {
    if (index === last) {
      /* whatever you are doing, now, with the debounced message */
    } else {
      /* whatever you need to do with the ignored messages */
    }
  });
});
</code></pre>
","6680611","","","","","2018-05-24 23:31:51","","","","3","","","","CC BY-SA 4.0"
"50528086","1","","","2018-05-25 11:23:08","","0","378","<p>I'm trying to query a user collection with dynamically passed uids, following <a href=""https://github.com/angular/angularfire2/blob/master/docs/firestore/querying-collections.md"" rel=""nofollow noreferrer"">https://github.com/angular/angularfire2/blob/master/docs/firestore/querying-collections.md</a> steps.
For some reason, even if there're two existing ids in this collection, it only returns one.
Note that I'm still using the compat rxjs5 syntax for switchMap.</p>

<pre><code>const ids$ = new Subject&lt;string&gt;();
const queryIds = ids$.switchMap(id =&gt; {
  this.afs.collection('user_previews', ref =&gt; {
    return ref.where('id', '==', id)).valueChanges()
  });
});

queryIds.subscribe(queriedIds =&gt; {
  console.log(queriedIds); // Logs only 1 value when there're 2 existing ids
});

this.friendRequests.forEach(request =&gt; {
  console.log(request.id_sent); // Logs 2 ids
  ids$.next(request.id_sent);
});
</code></pre>

<p>EDIT
It always returns the oldest user in the collection. It doens't matter how many ids are matched.</p>
","4783564","","4783564","","2018-05-25 13:54:06","2018-05-25 13:54:06","Querying dynamically a Firestore collection with AngularFire 2","<angular><angularfire2><rxjs5>","0","2","","","","CC BY-SA 4.0"
"50547823","1","50548154","","2018-05-26 23:31:51","","0","330","<p>I want to read directory using rxjs style but I can't get it to work</p>

<pre><code>import { readdir } from 'fs';
import { bindNodeCallback } from 'rxjs/observable/bindNodeCallback'; 
import { tap } from 'rxjs/operators';

function test() {

  bindNodeCallback(readdir).pipe(
    tap((x: any) =&gt; console.log(x))
  ).subscribe();
}

test();
</code></pre>

<p>It seems that the <code>bindNodeCallback</code> is not pipable, any ideas?</p>

<p><em>I am using rxjs@5.5.2</em></p>
","1015648","","","","","2018-05-27 00:47:26","rxjs 5.5 pipe fs readdir event","<typescript><rxjs><rxjs5><fs>","1","0","","","","CC BY-SA 4.0"
"50548154","2","","50547823","2018-05-27 00:47:26","","2","","<p>You need to pass somehow the name of the directory you want to read.
BindNodeCallback returns a function which you have to call to get an observable.</p>

<p>If you use bindNodeCallback with readdir then you have to do something like</p>

<p>bindNodeCallback(readdir)(dirName).pipe(....)</p>

<p>where dirName is a string containing the name of the directory you want to read.</p>

<p>You may find some more details in this article <a href=""https://medium.freecodecamp.org/rxjs-and-node-8f4e0acebc7c"" rel=""nofollow noreferrer"">https://medium.freecodecamp.org/rxjs-and-node-8f4e0acebc7c</a></p>
","5699993","","","","","2018-05-27 00:47:26","","","","0","","","","CC BY-SA 4.0"
"50551128","1","50551189","","2018-05-27 10:16:44","","1","1270","<pre><code>LoginComponent.html:18 ERROR TypeError: Observable.Observable.of is not a function
at LogConsole.webpackJsonp../node_modules/angular-logger/angular-logger.umd.js.LogConsole.log (angular-logger.umd.js:142)
at LogService.webpackJsonp../node_modules/angular-logger/angular-logger.umd.js.LogService.writeToLog (angular-logger.umd.js:351)
at LogService.webpackJsonp../node_modules/angular-logger/angular-logger.umd.js.LogService.fatal (angular-logger.umd.js:311)
at LoginComponent.webpackJsonp../src/app/user/login/login.component.ts.LoginComponent.hi (login.component.ts:83)
at Object.eval [as handleEvent] (LoginComponent.html:18)
at handleEvent (core.js:13254)
at callWithDebugContext (core.js:14739)
at Object.debugHandleEvent [as handleEvent] (core.js:14326)
at dispatchEvent (core.js:9703)
at core.js:10317
</code></pre>

<p>I'm getting this error in the app consuming my custom logger library.</p>

<p>login.component.ts:</p>

<pre><code>    hi(){
    alert('hi!');
    this.logService.fatal('hi there!');
}
</code></pre>

<p>which ends up calling the following function in my custom logger library, which is the cause of the error:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';

import { LogPublisher } from './log-publisher.class';
import { LogEntry } from './log-entry.class';

export class LogConsole extends LogPublisher {

log(record: LogEntry) : Observable&lt;boolean&gt; {
    console.log(record.buildLogString());

    return Observable.of(true);
}

}
</code></pre>

<p>I tried changing the import url for the 'of' operator, with no success.</p>

<p>The rxjs version in the custom logger library is</p>

<pre><code>  ""dependencies"": {
    ""rxjs"": ""~5.5.0""
  }
</code></pre>

<p>and the version in the consuming app is:</p>

<pre><code>""rxjs"": ""~5.5.0""
</code></pre>
","6743682","","","","","2018-06-11 21:33:56","Observable.Observable.of is not a function - not resolved by changing import statement","<angular><npm><rxjs><rxjs5>","1","0","","2018-05-27 10:35:22","","CC BY-SA 4.0"
"50551189","2","","50551128","2018-05-27 10:23:40","","3","","<p>You should use the newer version of invoking Rxjs  methods: </p>

<pre><code>import {of}                 from 'rxjs/observable/of';
</code></pre>

<p>and then : </p>

<pre><code> return of(true);
</code></pre>

<p><strong>Update rxjs version 6:</strong></p>

<pre><code>import { of } from 'rxjs';
</code></pre>
","859154","","6743682","","2018-06-11 21:33:56","2018-06-11 21:33:56","","","","0","","","","CC BY-SA 4.0"
"50576496","1","","","2018-05-29 04:50:31","","1","423","<p>I recently came across this (Angular) code:</p>

<pre><code>ngOnInit() {
  this.subscriptions.add(
    this.createSomeObservable()
      .subscribe(v =&gt; console.log('v=', v))
  );
}
</code></pre>

<p>Is this safe or should the returned observable from <code>this.createSomeObservable()</code> be stored as a member on the class to prevent being garbage collected?</p>

<p>The <code>this.createSomeObservable()</code> was actually a select from an ngrx store if that matters.</p>
","365696","","365696","","2018-05-29 14:36:06","2018-05-29 14:36:06","Should a reference to an observable be kept or will the subscription alone do","<angular><garbage-collection><observable><rxjs5><subscription>","2","0","","","","CC BY-SA 4.0"
"50589564","1","50612385","","2018-05-29 17:07:24","","2","1489","<p>I am trying to show one of the headers according to the value of <code>isComplex$</code> observable in *ngIf:</p>

<pre><code>&lt;complex-header *ngIf=""isComplex$ | async; else ordinaryHeader""&gt;&lt;/complexheader&gt;
&lt;ng-template #ordinaryHeader&gt;
  &lt;ordinary-header&gt;&lt;/ordinary-header&gt;
&lt;/ng-template&gt;
</code></pre>

<p>The problem is <code>*ngIf</code> goes with else case without waiting for observable to emit value. How can I accomplish both of headers wait for observable to emit its first value.</p>
","3263519","","3263519","","2018-05-29 17:49:43","2018-05-30 23:00:35","AsyncPipe in *ngIf","<angular5><rxjs5>","2","6","","","","CC BY-SA 4.0"
"50592218","1","","","2018-05-29 20:10:46","","2","1355","<p>I have a hard time understanding RxJs. The breaking changes between 5 and 6 are hard for me to understand.</p>

<p>I have the following code and the following issues.</p>

<ol>
<li>.interval method is no longer available from Observable</li>
<li>.switchMap method is no longer available from .interval</li>
</ol>

<p>I checked the changelog and the recommendations for fixing breaking changes and I wasn't able to sort out what I need to do. The way I understand it, the code I have is old and doesn't use the pipe operator but that's about all I've been able to figure out.</p>

<pre><code>let polling = Observable.interval(2000)
.switchMap(() =&gt; this.http.get(this.videoStatusURL + this.taskID))
.subscribe(
  (data) =&gt; {              
    if (data[""state""] === ""SUCCESS"") {
      //get final video here
      console.log(""polling succeeded"");
      this.downloadFinalVideo();
      polling.unsubscribe();
    }            
  },
  error =&gt; this.handleError(error));
</code></pre>
","1467034","","","","","2018-05-30 00:49:52","Migrating from RxJs 5 to 6: switchMap and Interval broken","<javascript><rxjs><rxjs5><angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"50595556","1","","","2018-05-30 02:30:37","","1","64","<p>I have a json file which looks like this :</p>

<pre><code>{
  ""Mappings"": [
    {
      ""LocalizedName"": ""39d256271e16456e8ec352c3cb87d778"",
      ""EnglishLocalizedName"": ""Default Outfit"",
      ""DevName"": ""Outfit_Alchemist_01"",
      ""IdRangeName"": ""OutfitEnum"",
      ""StackableRangeName"": ""Outfits"",
      ""StackableId"": 300001
    },
    ...
     ,
}
</code></pre>

<p>My service which retreive the data looks like this :</p>

<pre><code>return this.http.get(../assets/json/stackables.json).pipe(filter( (data) =&gt; data != null ))
</code></pre>

<p>And I want to know if a data[""Mappings""][...][""StackableId""] exist and if so, just return the array.</p>

<p>But if I do : </p>

<pre><code>this.http.get(../assets/json/stackables.json)[""Mappings""].pipe(filter( (data) =&gt; data[""StackableId""] === myId ))
</code></pre>

<p>It looks like the object is empty (maybe because of the async task)</p>

<p>How to manage this properly?</p>
","8126612","","","","","2018-05-30 02:49:33","Return the matched id contained in a sub-array provided by a json file","<angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"50604909","1","50611714","","2018-05-30 12:38:47","","0","2419","<p>When the user update your profile picture I need to upload his photo to Firebase Storage and immediately retrieve the download URL to update his profile collection.</p>

<p>In another scenario, when the user update his profile, he do not change his profile picture, so I don't have the imageData and also don't need to upload his picture, just update his profile information.</p>

<p>My <code>saveProfile()</code> method:</p>

<pre><code>if (this.profileForm.valid) {
....

  //Check if the user change his picture. If yes, the userProfilePicture has data.
  If (userProfilePicture) {
    //upload the picture to firestorage
      const path = `/profile/${this.profile.id}.jpg`;
      const task =  this.afStorage
        .ref(path)
        .putString(imageData, 'base64', { contentType: 'image/jpeg' });

   // subscribe to download url
      task.downloadURL().subscribe(
        url =&gt; {
          //updating profileUrl in the form
          this.profileForm.patchValue({ avatar: url });
      //Doing the update in Firestore
      this.afs.doc(`/profile/${id}`).update(this.profileForm.value);
      });

  }
  Else {
     // just update the profile information
     this.afs.doc(`/profile/${id}`).update(this.profileForm.value);
  }

}
</code></pre>

<p>I want to avoid to duplicate the update code in 2 places. Is there a more convenient way tho achieve this?
Maybe if there is a way to do the update just when I have the downloadUrl available (in 2 scenarios) something like this:</p>

<pre><code>If (userProfilePicture) {
  //upload the picture
  //subscribe to get the download url
}

//AWAIT for the subscribe to return the download URL and when the download URL is available then update
?? How to do this

//update the profile information with the new or existent download URL
await??? this.afs.doc(`/profile/${id}`).update(this.profileForm.value); 
</code></pre>
","9500119","","209103","","2018-05-30 13:49:27","2018-05-30 19:04:07","Insert / Update user profile picture using Firebase Storage and Firebase","<angular><typescript><firebase-storage><angularfire2><rxjs5>","1","1","1","","","CC BY-SA 4.0"
"50611714","2","","50604909","2018-05-30 18:58:02","","1","","<p>FYI <code>downloadURL()</code> on task is depreciated in 5.0, you'll need to use the one on ref after the upload is completed; so you'll need to keep a reference to that around:</p>

<pre><code>const path = `/profile/${this.profile.id}.jpg`;
const ref = this.afStorage.ref(path);
const task =  ref.putString(imageData, 'base64', { contentType: 'image/jpeg' });

task.snapshotChanges().pipe(
  filter(snap =&gt; snap.state === storage.TaskState.SUCCESS)
  switchMap(() =&gt; ref.getDownloadURL())
).subscribe(url =&gt; {
  ...
})
</code></pre>

<p>As for reducing the duplicate code, just using update is fine; as that will only update the fields specified. Just leave the profile picture out of the profileForm.</p>

<pre><code>// if there's a profile picture to upload, do so
if (userProfilePicture) {
  const path = `/profile/${this.profile.id}.jpg`;
  const ref = this.afStorage.ref(path);
  const task =  ref.putString(imageData, 'base64', { contentType: 'image/jpeg' });

  task.snapshotChanges().pipe(
    filter(snap =&gt; snap.state === storage.TaskState.SUCCESS)
    switchMap(() =&gt; ref.getDownloadURL())
  ).subscribe(profilePicture =&gt; {
    this.afs.doc(`/profile/${id}`).update({profilePicture});
  })
}

// also just update the rest of the profile, update is non-destructive and only overwrites the fields specified
this.afs.doc(`/profile/${id}`).update(this.profileForm.value); 
</code></pre>
","1028647","","1028647","","2018-05-30 19:04:07","2018-05-30 19:04:07","","","","4","","","","CC BY-SA 4.0"
"50612385","2","","50589564","2018-05-30 19:47:25","","2","","<p>The solution to not use async pipe multiple times is to wrap everything in a ng-container with the async pipe and use <code>*ngFor</code>. But to use <code>*ngFor</code> isComplex$ must always emit an itterable. So we need a new observable to use in the template:</p>

<pre><code>isComplexIterable$ = isComplex$.pipe(map(isComplex =&gt; [isComplex]))

&lt;ng-container *ngFor=""let isComplex of isComplexIterable$ | async""&gt;
   &lt;complex-header *ngIf=""isComplex""&gt;&lt;/complexheader&gt;
   &lt;ordinary-header *ngIf=""!isComplex""&gt;&lt;/ordinary-header&gt;
&lt;/ng-container&gt;
</code></pre>
","5468463","","5468463","","2018-05-30 23:00:35","2018-05-30 23:00:35","","","","2","","","","CC BY-SA 4.0"
"50651008","1","50659390","","2018-06-01 21:07:23","","2","580","<p>I'm trying to catch and retry a 103 Http error status response. The service call returns 103 if the server understood the request and will start processing it but resource is immediately unavailable. What I'd like to do is when I receive 103, I'd like to retry getting the resource after every 5 seconds for up to 5 times and at the end of which I'd like it to timeout and give back 404 error. This is what I have so far</p>

<pre><code>getDoc() {
  return this.getError()
    .retryWhen((errors: any) =&gt; {
      return errors.switchMap((sourceError) =&gt; {
        console.log(sourceError);
        if (sourceError.status === 103) {
          console.log('status is 103');
          const notFoundError = new HttpErrorResponse({
            status: 404
          });
          return errors.delay(5000).take(5).concat(Observable.throw(notFoundError));
        }
        return Observable.throw(sourceError);
      });
    })
    .toPromise();
}

getError() {
  console.log('getting error');
  return Observable.throw(new HttpErrorResponse({
    status: 103
  }));
}
</code></pre>

<p>with getError() function, I am trying to mimic a 103 because the server doesn't send 103 yet. Maybe getError() is not a good representation of httpError response. I wasn't sure how else to reproduce and throw an observable error. </p>

<p>Anyway, this setup doesn't work. It calls getError(), fails and goes all the way up to console.log('status is 103') and after that nothing. Any help is appreciated.</p>
","4206178","","4206178","","2018-06-01 21:18:26","2018-06-02 17:21:35","Retrying a http call on receiving a certain http status","<angular><observable><httpclient><rxjs5><retrywhen>","1","0","1","","","CC BY-SA 4.0"
"50659390","2","","50651008","2018-06-02 17:21:35","","3","","<p>You can use <a href=""https://angular.io/api/common/http/HttpInterceptor"" rel=""nofollow noreferrer"">HttpInterceptor</a>.</p>

<pre><code>@Injectable()
export class ServiceCallProvider implements HttpInterceptor {

public intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    return next.handle(request).do((event: HttpEvent&lt;any&gt;) =&gt; {
      if (event instanceof HttpResponse) {
        // do stuff with response if you want
      }
    }, (err: any) =&gt; {
      if (err instanceof HttpErrorResponse) {
        if (err.status === 103) {
          // handle logic
        }
      }
    });
  }
}
</code></pre>
","3354409","","","","","2018-06-02 17:21:35","","","","1","","","","CC BY-SA 4.0"
"50674426","1","","","2018-06-04 06:21:57","","1","642","<p>I'm developing user activity tracking system and trying reach next goals:</p>

<ol>
<li>Catch <code>mousemove</code> event once after two seconds user started moving a mouse.</li>
<li>Catch a moment after two seconds user finished moving a mouse.</li>
</ol>

<p>I have next streams:</p>

<pre><code>const activityStream$ = Rx.Observable.fromEvent(document, 'mousemove');

const enterActivityStream$ = activityStream$.throttleTime(1000).skip(2);

const finishActivityStream$ = activityStream$.debounceTime(2000);
</code></pre>

<p>Separately they work as intended and I would like combine them, so they will work in repeated manner. </p>

<p>E.g:
User started moving a mouse, after two seconds observer gets event about that (or at least <code>do</code> operator), then user finishes moving a mouse and the observer gets notified about that as well. If user started moving a mouse again, this routine repeated.</p>

<p>I found similar question there <a href=""https://stackoverflow.com/questions/48144202/example-rxjs-observable-when-mouse-or-click-activity-re-starts"">Example RxJS Observable when mouse or click activity Re-starts</a> but solution seems complicated and doesn't work as intended. (<code>lastact$</code> stream fires twice, when it should fire once).</p>

<p>Please, can anyone give me a clue about how can I achieve this? Thanks!</p>
","2960225","","2960225","","2018-06-04 06:58:41","2019-02-24 19:52:41","RxJS mouse activity tracking","<rxjs><rxjs5>","3","0","","","","CC BY-SA 4.0"
"50740106","1","50740199","","2018-06-07 11:31:31","","1","1080","<p>I am trying to get an <code>Observable&lt;MyType&gt;</code> by doing the following:</p>

<pre><code>return this.cache.get&lt;MyType, number&gt;(storageName, version)
    .map(cached =&gt; {
        if (cached !== undefined) {
            return cached;
        }
        return this.http.get&lt;MyType&gt;(`MyTypeGetUrl/${version}`)
            .map(m =&gt; m)
            .do(result =&gt; {
                this.cache.put&lt;MyType&gt;(storageName, result).first().subscribe();
            });
        }).publishReplay(1).refCount();
</code></pre>

<p><code>cache.get</code> returns an <code>Observable&lt;MyType&gt;</code> and <code>http.get&lt;T&gt;</code> returns <code>Observable&lt;T&gt;</code>.</p>

<p>I want check the cache for an object, and if it doesn't exist, get it from the server, cache it and return it.</p>

<p>However, if the object exists in the cache, it returns <code>Observable&lt;MyType&gt;</code>, but if it needs to go to the server, it returns <code>Observable&lt;Observable&lt;MyType&gt;&gt;</code>.</p>

<p>How can I flatten the result from the server, so that I can return an Observable, only calling to the server when I must?</p>
","117507","","","","","2018-06-07 11:36:05","How to flatten an Observable<Observable<any>> to Observable<any>?","<rxjs><observable><rxjs5>","2","0","","","","CC BY-SA 4.0"
"50740199","2","","50740106","2018-06-07 11:35:54","","3","","<p>Instead of <code>map</code> use <code>mergeMap</code> and wrap the cached result into an Observable. In both cases it'll go through <code>mergeMap</code> so it'll unwrap <code>Observable&lt;MyType&gt;</code> into <code>MyType</code> (you could use <code>concatMap</code> or <code>switchMap</code> as well in this example).</p>

<pre><code>return this.cache.get&lt;MyType, number&gt;(storageName, version)
  .mergeMap(cached =&gt; {
    if (cached !== undefined) {
      return Observable.of(cached);
    }
    return this.http.get(...);
  })
  ...
</code></pre>
","310726","","","","","2018-06-07 11:35:54","","","","0","","","","CC BY-SA 4.0"
"50753545","1","50753626","","2018-06-08 04:48:29","","3","2192","<p>I have an observable of an array of objects that looks like this:</p>

<pre><code>[
  {
    id: 1,
    name: ""New York"",
    latitude: 15.5539737,
    longitude: -78.5989487
  },
  {
    id: 2,
    name: ""Chicago"",
    latitude: 55.5539737,
    longitude: 28.5989487
  },
  {
    id: 3,
    name: ""Los Angeles"",
    latitude: 95.5539737,
    longitude: -72.587
  }
]
</code></pre>

<p>How can I return a new observable array of objects that extracts only 2 of the properties (latitude and longitude)?</p>
","5332322","","","","","2018-06-24 07:49:30","How to extract 2 properties from an array of objects as an observabe?","<rxjs><observable><rxjs5>","2","2","","","","CC BY-SA 4.0"
"50753626","2","","50753545","2018-06-08 04:58:23","","4","","<p>You may use map operator from RxJS first, then use map from Array, as follows:</p>

<pre><code>// first use the map operator from RxJS    
    YourObservable.map(x=&gt;{
    // then use Array.prototype.map
        x.map(return {longiture:x.longitude, latitude:x.latitude})
        })
</code></pre>

<p>Do not confuse the two maps used above, <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map"" rel=""nofollow noreferrer"">one</a> is from RxJS and the <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"" rel=""nofollow noreferrer"">other</a> is from Array, both are completely different.</p>

<p>Also note that if you use RxJS6, you need to use pipe as follows:</p>

<pre><code> YourObservable.pipe(
     map(x=&gt;{
           x.map(return {longiture:x.longitude, latitude:x.latitude})
        }))
</code></pre>
","475247","","475247","","2018-06-08 05:10:27","2018-06-08 05:10:27","","","","0","","","","CC BY-SA 4.0"
"50780681","1","50780718","","2018-06-10 04:57:30","","1","473","<p>I have an HTTPClient 'get' method that returns a JSON array of objects. In addition, I'm currently using a key from the route params to extract one object from that array.</p>

<p>The component is dynamic, meaning when the route param changes, the component won't get destroyed. </p>

<p><strong>The Problem</strong></p>

<p>When a new route param is switched, the component doesn't change the selectedUser objecct. </p>

<p><strong>Why?</strong></p>

<p>Because the httpClient completes the observable stream after one emitted item therefore the paramMap observable is also closed so it won't emit when a different value for the route param changes.</p>

<p>ex: '/user/:name' </p>

<ol>
<li>'/user/bob' ---> component finds the selected user </li>
<li>from the component a new user is entered '/user/john'</li>
<li>'/user/john' ----> component doesn't detect the new param</li>
</ol>

<p>Here is the code snippet below (users$ is the http.get() observable).</p>

<pre><code>  ngOnInit() {
    this.users$.pipe(
      withLatestFrom(this.params$),
      map( ([users, params]) =&gt; {
        return users.find((user) =&gt; user.slug === params.landmark);
      })
    ).subscribe(user =&gt; this.selecteduser = user);
  }
}
</code></pre>

<p>EDIT: Switching to combineLatest does work, but I had to rearrange the observable as such:</p>

<pre><code>  ngOnInit() {
    this.params$.pipe(
      combineLatest(this.users$, this.params$),
      map( ([params, users]) =&gt; {
        this.users = users;
        return users.find((user) =&gt; user.slug === params.landmark);
      })
    ).subscribe(user =&gt; this.selecteduser = user);
  }
</code></pre>
","5332322","","5332322","","2018-06-10 05:25:17","2018-06-10 05:25:17","How to use the Observables from HttpClient and paramMap together for a dynamically loading component?","<angular><rxjs><observable><httpclient><rxjs5>","1","0","1","","","CC BY-SA 4.0"
"50780718","2","","50780681","2018-06-10 05:04:29","","0","","<p>Use <code>combineLatest</code> instead of <code>withLatestFrom</code>. This will make the resulted stream active even after one stream completes.</p>

<pre><code>ngOnInit() {
     combineLatest(this.users$, this.params$).pipe(
      map( ([users, params]) =&gt; {
        return users.find((user) =&gt; user.slug === params.landmark);
      })
    ).subscribe(user =&gt; this.selecteduser = user);
  }
</code></pre>
","475247","","475247","","2018-06-10 05:10:44","2018-06-10 05:10:44","","","","5","","","","CC BY-SA 4.0"
"50840502","1","","","2018-06-13 15:03:48","","0","712","<p>I've imported EmptyObservable like this:</p>

<pre><code>import { EmptyObservable } from 'rxjs/observable/EmptyObservable'
</code></pre>

<p>I then assigned it to an object like this:</p>

<pre><code>public user = { initCompleted: new EmptyObservable() }
</code></pre>

<p>Both lines validate in Visual Studio Code, the library appears to be found, and no warnings are shown. Based on that, I hope I am on the right path...</p>

<p>Now, when an API call I'm making is done and the results are assigned to a few values on the user object, I want to emit the Completed signal. How do I emit the Completed signal using the EmptyObservable in Angular 6, using RXJS 5.5.6?</p>

<p>I was able to make this work using <code>Subject</code> observer/observable by simply subscribing to <code>user.InitCompleted</code> and waiting for any value from <code>user.initCompleted.next(somevalue)</code>, but I'm fairly certain this is not the best tool for the job.</p>
","7964447","","7964447","","2018-06-13 18:14:20","2018-06-13 18:14:20","How to return Completed status on RxJS Observable in Angular","<angular><observable><rxjs5>","0","2","","","","CC BY-SA 4.0"
"50860934","1","","","2018-06-14 15:21:35","","0","262","<p>I am upgrading from rxjs 5.5 to 6.2.1. I went through the code base and made all the changes suggested in the rxjs migration document, changed imports, piping instead of chaining, etc. When I run my <code>npm install</code> the <code>build.bundle.rxjs</code> script throws an error on fetch for rxjs-compat and says it is loading rxjs/Rx, which I can find no reference to in my code base. Has anyone else seen similar problems when upgrading their rxjs?</p>

<p>EDIT:</p>

<p>I found that the source of the error is coming from various packages inside of my node_modules. They are using the deprecated import paths. </p>
","6915873","","6915873","","2018-06-14 16:03:47","2018-06-14 16:03:47","When migrating to rxjs 6 gulp build.bundle.rxjs throws error","<angular><rxjs5><rxjs6><rxjs-compat>","0","2","","","","CC BY-SA 4.0"
"50873026","1","","","2018-06-15 09:47:20","","3","1074","<p>Consider the following rxjs@5.5.11 code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>{
  const source1 = Rx.Observable.of(1, 2, 3);
  const source2 = Rx.Observable.of(4, 5);

  const combined = Rx.Observable.combineLatest(source1, source2);

  const subscribe = combined.subscribe(([value1, value2]) =&gt; {
    console.log(`value1 Latest: ${value1}`);
    console.log(`value2 Latest: ${value2}`);
  });
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.11/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>I imagined this result would be something like this:</p>

<p>(emit 1 time and gives lasted)</p>

<pre class=""lang-none prettyprint-override""><code>value1 Latest: 3
value2 Latest: 5
</code></pre>

<p>or </p>

<p>(emit 3 times and gives lasted from each)</p>

<pre class=""lang-none prettyprint-override""><code>value1 Latest: 1
value2 Latest: 4
value1 Latest: 2
value2 Latest: 5
value1 Latest: 3
value2 Latest: 5
</code></pre>

<p>but actually it is:</p>

<p>(emit 2 times and gives lasted from each)</p>

<pre class=""lang-none prettyprint-override""><code>value1 Latest: 3
value2 Latest: 4
value1 Latest: 3
value2 Latest: 5
</code></pre>

<p>Why?</p>
","1855830","","493729","","2018-06-15 10:20:59","2018-06-15 10:29:35","Why my rxjs combineLatest output only 2 times?","<javascript><rxjs><rxjs5>","2","1","","","","CC BY-SA 4.0"
"50904012","1","50904106","","2018-06-18 06:51:42","","8","6464","<p>Is there a way to detect when a Subscription has closed?  I have a loading component that displays a loading message when a Subscription exists &amp;&amp; is not closed, and otherwise displays the content, but once closed I wanted to reset the variable that was referencing the subscription, otherwise I can't use <code>mySubscription.closed</code> as an useful indicating in the template.</p>
","1148107","","","","","2019-02-27 23:01:19","RxJS Detect When Subscription has Closed","<angular><rxjs><angular5><rxjs5>","3","1","1","","","CC BY-SA 4.0"
"50904106","2","","50904012","2018-06-18 06:57:49","","6","","<p>Yes, based on the <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md"" rel=""noreferrer"">RxJS subscribe() documentation</a> there are 3 arguments that can be passed, last one being the OnCompleted callback.</p>

<pre><code>var observer = Rx.Observer.create(
    function (x) {
        console.log('Next: %s', x);
    },
    function (err) {
        console.log('Error: %s', err);
    },
    function () {
        console.log('Completed');
    });
</code></pre>
","6457480","","","","","2018-06-18 06:57:49","","","","0","","","","CC BY-SA 4.0"
"50905033","1","","","2018-06-18 08:02:02","","4","4050","<p>We're facing an issue while updating our application to RxJs 6 (with rxjs-compat). 
A referenced library, which is still on RxJs 5 is using ErrorObservable as a return type of a method.</p>

<pre><code>public handleError(error: Error): ErrorObservable {
    ...
    return Observable.throw('some error message');
}
</code></pre>

<p>As of now ErrorObservable is a non-generic type in RxJs:
<a href=""https://github.com/ReactiveX/rxjs/blob/5.5.11/src/observable/ErrorObservable.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.11/src/observable/ErrorObservable.ts</a></p>

<pre><code>export class ErrorObservable extends Observable&lt;any&gt; {
  ...
}
</code></pre>

<p>This has changed with RxJs 6<br>
(see <a href=""https://github.com/ReactiveX/rxjs/blob/master/compat/observable/ErrorObservable.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/compat/observable/ErrorObservable.ts</a>)</p>

<pre><code>export class ErrorObservable&lt;T&gt; extends Observable&lt;T&gt; {
  static create&lt;T&gt;(error: any, scheduler?: SchedulerLike) {
    return throwError(error, scheduler);
  }
}
</code></pre>

<p>Which of course leads to a compile error:</p>

<pre><code>ERROR in ... : error TS2314: Generic type 'ErrorObservable&lt;T&gt;' requires 1 type argument(s).
</code></pre>

<p>Is this a case, which is not covered by <code>rxjs-compat</code> or is it an issue with the type definition in <code>rxjs-compat</code>?</p>
","9955459","","","","","2018-06-18 09:26:43","Breaking change in RxJs ErrorObservable (Migration 5 -> 6)","<typescript><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50957701","1","50958670","","2018-06-20 22:02:54","","8","5276","<p>I have an array of observables that need to fire off sequentially. Once an error happens, I need the to catch the error, log it, and continue observing.</p>

<p>At the moment, once an error occurs, the observer stops. It's essential that the observer continues and does not restart or complete on error.</p>

<pre><code>import * as Rx from ""rxjs"";
const source = [
  Rx.Observable.from(""1"").delay(200),
  Rx.Observable.from(""2"").delay(150),
  Rx.Observable.throw(""error""),
  Rx.Observable.from(""3"").delay(124),
  Rx.Observable.from(""4"").delay(201),
];
let sSource = Rx.Observable.concat(...source);
sSource.subscribe((v) =&gt; {console.log(v)}, (e) =&gt; {console.log(e)});
</code></pre>

<p>Current output:</p>

<pre><code>1
2
error
</code></pre>

<p>Expected output:</p>

<pre><code>1
2
error
3
4
</code></pre>

<p>The only solution that we could come up with was to pre-loop through the <code>source</code> observables and add catch handlers to them individually, then once an error occurs, it's handled correctly and the observer can continue without completing the entire concatenated observable.</p>

<p>We feel like there should be a more elegant solution to this. I'll post the solution we have at the moment if need be.</p>
","3345621","","","","","2019-02-14 10:24:56","RXJS Continue with concat subscribe after error","<typescript><rxjs><rxjs5><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"50958670","2","","50957701","2018-06-21 00:09:38","","7","","<p>You can apply the <code>catch</code> operator to each of the source observables and can perform the error logging within it. Like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const sources = [
  Rx.Observable.from(""1"").delay(200),
  Rx.Observable.from(""2"").delay(150),
  Rx.Observable.throw(""error""),
  Rx.Observable.from(""3"").delay(124),
  Rx.Observable.from(""4"").delay(201),
];
const sourcesWithCatch = sources.map(s =&gt; s.catch(e =&gt; {
  console.log(e);
  return Rx.Observable.empty();
}));
const concatted = Rx.Observable.concat(...sourcesWithCatch);
concatted.subscribe(v =&gt; console.log(v));</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@5/bundles/Rx.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","6680611","","","","","2018-06-21 00:09:38","","","","1","","","","CC BY-SA 4.0"
"50970026","1","","","2018-06-21 13:39:54","","0","19","<p>I want to ensure that a given API call is throttled so that for a given time interval, only a single request is fired, and that the other, throttled requests wait and receive the results of the request that was actively fired</p>

<p><strong>Example</strong></p>

<pre><code>const generateReport = (args) =&gt; client.get(...)

const generateReportA = (argsForA) =&gt;
    generateReport(argsForA).then(saveReportSomewhere)

const generateReportB = (argsForB) =&gt;
    generateReport(argsForB).then(saveReportSomewhere)

const generateReportC = (argsForC) =&gt;
    generateReport(argsForC).then(saveReportSomewhere)
</code></pre>

<p>If we then run the statements below</p>

<pre><code>generateReportA(...).then(console.log) // should log result of C
generateReportB(...).then(console.log) // should log result of C
generateReportC(...).then(console.log) // should log result
</code></pre>

<p>right after each other, I only want to fire the request associated with <code>generateReportC</code> and I'd like both <code>generateReportA</code> and <code>generateReportB</code> to receive and handle the result of <code>generateReportC</code>. </p>

<p>In the end <code>generateReport</code> should have been called once and <code>saveReportSomewhere</code> should have been called 3 times, each with the result from <code>generateReportC</code></p>

<p>Is this possible?</p>
","3287921","","","","","2018-07-04 22:10:06","Throttle service with multiple, independant callers","<rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"50989189","1","","","2018-06-22 13:35:41","","1","45","<p>Given the below code sample:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { timer } from 'rxjs/observable/timer';
import { tap } from 'rxjs/operators';

@Component({ selector: 'foo' })
export class FooComponent implements OnInit {
  private foo: number;

  constructor () { }

  ngOnInit () {
    const timer$ = timer(0, 1000);
    timer$.pipe(
      tap((i: number) =&gt; this.foo = i)
    );
  }
}
</code></pre>

<p>I am creating an observable with an operator <code>tap</code> and just assigning to a private variable with no subscription.</p>

<p>1) Do I need to explicitly complete this observable or will that be handled transparently?</p>

<p>2) Does this behavior change for certain operators, like <code>map</code> or <code>switchMap</code>?</p>
","1042350","","1042350","","2018-06-22 13:46:23","2018-06-22 13:46:23","Observable: If I never subscribe, do I have to garbage collect?","<typescript><angular5><rxjs5>","0","3","","2018-06-22 13:52:48","","CC BY-SA 4.0"
"51002250","1","51003322","","2018-06-23 14:45:18","","0","177","<p><a href=""https://rxjs-playground.github.io/#/?html=%3Cbutton%20onclick%3D%22addFilter%28%29%22%3Eadd%3Cbutton%3E&amp;js=let%20filters%24%20%3D%20new%20Rx.BehaviorSubject%28%5B%5D%29%3B%20%0Alet%20id%20%3D%200%3B%0A%0Afilters%24.subscribe%28f%20%3D%3E%20console.log%28f%29%29%3B%0A%0Afunction%20addFilter%28%29%20%7B%0A%20%20filters%24.first%28%29%0A%20%20%20%20.map%28filters%20%3D%3E%20%28%5B...filters%2C%20%7B%20id%20%7D%5D%29%29%0A%20%20%20%20.subscribe%28filters%24%29%3B%0A%20%20id%2B%2B%3B%0A%7D"" rel=""nofollow noreferrer"">live example</a></p>

<p>I've an Array of Filters as an <code>Observable</code> and I'd like to add/remove filters from it. Here is the code I have that is currently only adding a <code>Filter</code> the first time the function runs.</p>

<p>The second time nothing happens.</p>

<pre><code>private _filters$ = new BehaviorSubject&lt;Filter[]&gt;([]);

addFilter(added: Filter) {
    debugger
    // adding to array of filters
    this._filters$.pipe(
        tap(d =&gt; { debugger; }),
        first(), 
        map(filters =&gt; ([...filters, added]))
    ).subscribe(this._filters$);
}
</code></pre>

<p>So my question is: why does this happen ? Why does it run only once ? (By the way <code>first()</code> is not the reason). </p>

<p>I know I can make the code work like so: </p>

<pre><code>private _filters$ = new BehaviorSubject&lt;Filter[]&gt;([]);

currentFilters;

init() {
   this._filters$.subscribe(f =&gt; this.currentFilters = f);
}

addFilter(added: Filter) {
    this._filters$.next([...this.currentFilters, added]);
}
</code></pre>
","4299560","","","","","2018-06-23 17:01:58","Adding to previous result, Observable pipeline only running once","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51003322","2","","51002250","2018-06-23 17:01:58","","2","","<p>Actually, it is because of <code>first</code>. When you run the function the first time it is creating the stream and subscribing to the <code>BehaviorSubject</code>. When it receives the first event it forwards it to <code>BehaviorSubject</code> and then it completes <code>BehaviorSubject</code>. The second time you run it <code>BehaviorSubject</code> is already shutdown so it immediately unsubscribes any new subscriptions to it.</p>

<p>Without knowing too much about your actual goal my suggestion is that instead of putting the <code>BehaviorSubject</code> at the bottom of the pipeline you instead put it at the top.</p>

<pre><code>// You don't actually need the caching behavior yet so just use a `Subject`
private _filters$ = new Subject&lt;Filter&gt;()

// Hook this up to whatever is going to be using these filters
private _pipeline$ = this._filters.pipe(
  // Use scan instead mapping back into self
  scan((filters, newFilter) =&gt; ([...filters, newFilter]), []),
  // Store the latest value for new subscribers
  shareReplay(1)
);

// Now this method is just pushing into the `Subject` and the pipeline never has to be torn down
addFilter(added: Filter) {
    debugger
    this._filters$.next(added);
}
</code></pre>
","2521865","","","","","2018-06-23 17:01:58","","","","3","","","","CC BY-SA 4.0"
"51060758","1","","","2018-06-27 10:42:24","","2","1339","<p>I have this service with return null initially (init background job) <code>[ this.q = true]</code>. But later if I change it change to <code>[ this.q = false]</code> and if the job successes it will return value. </p>

<p>So, 1st I need to call <code>[ this.q = true]</code> and retry <code>[ this.q = false]</code>.
But the below code didn't works. it always make <a href=""https://api.example.com?q=true"" rel=""nofollow noreferrer"">https://api.example.com?q=true</a></p>

<pre><code>return this.http.get('https://api.example.com?q=' + this.q)
  .map((res: any) =&gt; {    
    if (res === null) {          
      throw new Error(""not enough tiles !"");
    }                
    return res;
  }).catch((e) =&gt; {    
    this.q = false;
    return error;
  })
  .retryWhen(e =&gt; e.delay(2000))
  .retry(3);
</code></pre>
","1250195","","","","","2018-06-28 07:59:20","Can I change the query params value on Rxjs Retry?","<angular><rxjs><rxjs5>","1","4","","","","CC BY-SA 4.0"
"51089579","1","","","2018-06-28 18:52:50","","7","1137","<p>The documentation to use rxjs-5-to-6-migrate states the following: </p>

<pre><code>To refactor TypeScript code so that it doesn't depend on rxjs-compat, you can use rxjs-tslint.

npm i -g rxjs-tslint
rxjs-5-to-6-migrate -p [path/to/tsconfig.json]
</code></pre>

<p>So I did that and then copied the </p>

<p>root path to my tsconfig file</p>

<pre><code>rxjs-5-to-6-migrate -p [/home/ri
ckus/Documents/softwareProjects/211hospitality/suitsandtables/frontend/frontendsuitsandtables/suitsandtables/tsconfig.json]
</code></pre>

<p>But when I run the command I get the following <strong>error</strong>.</p>

<pre><code>Running the automatic migrations. Please, be patient and wait until the execution completes.
child_process.js:643
    throw err;
    ^

Error: Command failed: ""/usr/local/lib/node_modules/rxjs-tslint/node_modules/.bin/tslint"" -c ""/usr/local/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.json"" -p ""[home/rickus/Documents/softwareProjects/211hospitality/suitsandtables/frontend/frontendsuitsandtables/suitsandtables/tsconfig.json"" --fix
    at checkExecSyncError (child_process.js:603:11)
    at Object.execSync (child_process.js:640:13)
    at migrate (/usr/local/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.js:18:34)
    at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.js:25:14)
    at Module._compile (internal/modules/cjs/loader.js:702:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:713:10)
    at Module.load (internal/modules/cjs/loader.js:612:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:551:12)
    at Function.Module._load (internal/modules/cjs/loader.js:543:3)
    at Module.require (internal/modules/cjs/loader.js:650:17)
</code></pre>

<p>But for why? It seems this  code is more fickle than my ex and unfortunately I can't run away from this.</p>

<p>I checked this answer and it did not help: 
<a href=""https://stackoverflow.com/questions/50639923/rxjs-5-to-6-migrate-crashes"">RxJs-5-to-6-migrate crashes</a></p>
","10001823","","5859957","","2018-06-29 02:39:11","2019-11-11 09:50:03","usng rxjs-5-to-6-migrate correctly. issues with tsconfig path","<angular><rxjs><rxjs5><tsconfig><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"51114763","1","","","2018-06-30 12:05:28","","0","205","<p>i am getting undefined data when subscribing this service<br>
can i return value in service </p>

<p>--- service.ts file</p>

<pre><code>return this.restService.get(url, null, headers).map(data =&gt; {

       data.forEach(element =&gt; {
        if (element.key === 'List') {
          console.log(element.value);
          return element.value;
        }
      });
    });
</code></pre>

<p>--- component.ts</p>

<pre><code>this.productService.getProducts().subscribe(data =&gt; {

       Console.log(data)  // giving undefined here  
     }
 });
</code></pre>
","2244293","","571407","","2018-06-30 12:06:39","2018-06-30 12:10:12","Getting data undefined when subscribing a service in angular 6","<angular><typescript><rxjs5>","1","2","","","","CC BY-SA 4.0"
"51120793","1","51121664","","2018-07-01 05:59:46","","4","2383","<p>my component:</p>

<pre><code>import {Observable, Subject , merge} from 'rxjs';
import {debounceTime, distinctUntilChanged, filter, map} from 'rxjs/operators';

focus$ = new Subject&lt;string&gt;();
click$ = new Subject&lt;string&gt;();

search = (text$: Observable&lt;string&gt;) =&gt; {
        const debouncedText$ = text$.pipe(debounceTime(200), distinctUntilChanged());
        const clicksWithClosedPopup$ = this.click$.pipe(filter(() =&gt; !this.instance.isPopupOpen()));
        const inputFocus$ = this.focus$;

        return merge(debouncedText$, inputFocus$, clicksWithClosedPopup$).pipe(
            map(term =&gt; (term === '' ? states
                : states.filter(v =&gt; v.toLowerCase().indexOf(term.toLowerCase()) &gt; -1)).slice(0, 10))
        );
}
</code></pre>

<p>versions:</p>

<pre><code>""rxjs"": ""^5.5.6"",
""@angular/cli"": ""1.3.2"",
""@angular/compiler-cli"": ""^4.2.4""
</code></pre>

<p>i get error:</p>

<blockquote>
  <p>node_modules/rxjs/Rx""' has no exported member 'merge'</p>
</blockquote>
","8990367","","","","","2018-07-01 08:31:19","node_modules/rxjs/Rx has no exported member 'merge'","<angular><rxjs><rxjs5>","1","2","","","","CC BY-SA 4.0"
"51121664","2","","51120793","2018-07-01 08:31:19","","3","","<p><a href=""https://www.learnrxjs.io/operators/combination/merge.html"" rel=""nofollow noreferrer""><code>merge</code></a> can be used as either a <code>static</code> or <code>instance</code> method.</p>

<p>for <code>static</code> method use<br>
<code>import { merge } from 'rxjs/observable/merge';</code></p>

<pre><code> return merge(debouncedText$, inputFocus$, clicksWithClosedPopup$).pipe(
            map(term =&gt; (term === '' ? states
                : states.filter(v =&gt; v.toLowerCase().indexOf(term.toLowerCase()) &gt; -1)).slice(0, 10))
        );
</code></pre>

<p>for <code>instance</code> method use <br>
<code>import { merge } from 'rxjs/operators';</code> <br></p>

<pre><code>return Observable.merge(debouncedText$, inputFocus$, clicksWithClosedPopup$).pipe(
            map(term =&gt; (term === '' ? states
                : states.filter(v =&gt; v.toLowerCase().indexOf(term.toLowerCase()) &gt; -1)).slice(0, 10))
        );
</code></pre>

<p><strong><a href=""https://stackblitz.com/edit/angular-rxjs-playground-btmk3n"" rel=""nofollow noreferrer""><code>Live Demo</code></a></strong></p>
","5695162","","","","","2018-07-01 08:31:19","","","","0","","","","CC BY-SA 4.0"
"51128911","1","51136802","","2018-07-02 03:48:25","","14","13478","<p>I just recently updated A LOT of packages in my angular project.</p>

<p>Old package.json:</p>

<pre><code>{
  ""name"": ""data-jitsu"",
  ""version"": ""0.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""^5.2.10"",
    ""@angular/cdk"": ""^5.2.5"",
    ""@angular/common"": ""5.2.7"",
    ""@angular/compiler"": ""5.2.7"",
    ""@angular/core"": ""5.2.7"",
    ""@angular/forms"": ""5.2.7"",
    ""@angular/http"": ""5.2.7"",
    ""@angular/material"": ""^5.2.5"",
    ""@angular/platform-browser"": ""5.2.7"",
    ""@angular/platform-browser-dynamic"": ""5.2.7"",
    ""@angular/router"": ""5.2.7"",
    ""@types/youtube"": ""0.0.29"",
    ""angular-froala-wysiwyg"": ""^2.7.2-1"",
    ""angular2-materialize"": ""^15.1.10"",
    ""angularfire2"": ""^4.0.0-rc0"",
    ""core-js"": ""^2.4.1"",
    ""d3"": ""^4.13.0"",
    ""firebase"": ""^3.9.0"",
    ""hammerjs"": ""^2.0.8"",
    ""jquery"": ""^3.0.0"",
    ""materialize-css"": ""^0.100.2"",
    ""ngx-youtube-player"": ""0.0.41"",
    ""rxjs"": ""^5.5.6"",
    ""zone.js"": ""^0.8.4""
  },
  ""devDependencies"": {
    ""@angular/cli"": ""1.7.2"",
    ""@angular/compiler-cli"": ""5.2.7"",
    ""@types/bootstrap"": ""^3.3.36"",
    ""@types/d3"": ""^4.13.0"",
    ""@types/jasmine"": ""2.5.38"",
    ""@types/node"": ""~6.0.60"",
    ""codelyzer"": ""~2.0.0"",
    ""jasmine-core"": ""~2.5.2"",
    ""jasmine-spec-reporter"": ""~3.2.0"",
    ""karma"": ""~1.4.1"",
    ""karma-chrome-launcher"": ""~2.0.0"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^0.2.0"",
    ""karma-jasmine"": ""~1.1.0"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.1.0"",
    ""ts-node"": ""~2.0.0"",
    ""tslint"": ""~4.5.0"",
    ""typescript"": ""2.6.2""
  }
}
</code></pre>

<p>New package.json:</p>

<pre><code>{
  ""name"": ""data-jitsu"",
  ""version"": ""0.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""^6.0.3"",
    ""@angular/cdk"": ""^6.3.1"",
    ""@angular/common"": ""^6.0.3"",
    ""@angular/compiler"": ""^6.0.3"",
    ""@angular/core"": ""^6.0.3"",
    ""@angular/forms"": ""^6.0.3"",
    ""@angular/http"": ""^6.0.3"",
    ""@angular/material"": ""^6.2.0"",
    ""@angular/platform-browser"": ""^6.0.3"",
    ""@angular/platform-browser-dynamic"": ""^6.0.3"",
    ""@angular/router"": ""^6.0.3"",
    ""@types/youtube"": ""^0.0.29"",
    ""angular-froala-wysiwyg"": ""^2.7.2-1"",
    ""angular2-materialize"": ""^15.1.10"",
    ""angularfire2"": ""^5.0.0-rc.11"",
    ""core-js"": ""^2.4.1"",
    ""d3"": ""^4.13.0"",
    ""firebase"": ""^5.0.3"",
    ""hammerjs"": ""^2.0.8"",
    ""jquery"": ""^3.0.0"",
    ""materialize-css"": ""^0.100.2"",
    ""ngx-youtube-player"": ""0.0.41"",
    ""rxjs"": ""^6.2.1"",
    ""zone.js"": ""^0.8.26""
  },
  ""devDependencies"": {
    ""@angular-devkit/build-angular"": ""~0.6.8"",
    ""@angular/cli"": ""~6.0.8"",
    ""@angular/compiler-cli"": ""^6.0.3"",
    ""@angular/language-service"": ""^6.0.3"",
    ""@types/bootstrap"": ""^3.3.36"",
    ""@types/d3"": ""^4.13.0"",
    ""@types/jasmine"": ""~2.8.6"",
    ""@types/jasminewd2"": ""~2.0.3"",
    ""@types/node"": ""^10.5.1"",
    ""codelyzer"": ""~4.2.1"",
    ""jasmine-core"": ""~2.99.1"",
    ""jasmine-spec-reporter"": ""~4.2.1"",
    ""karma"": ""~1.7.1"",
    ""karma-chrome-launcher"": ""~2.2.0"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""~2.0.0"",
    ""karma-jasmine"": ""~1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.3.0"",
    ""ts-node"": ""~5.0.1"",
    ""tslint"": ""~5.9.1"",
    ""typescript"": ""~2.7.2""
  }
}
</code></pre>

<p>When I run <code>npm install</code> using the new package.json updates and then <code>ng serve</code>, I get many compilation errors:</p>

<blockquote>
  <p>ERROR in src/app/all-matches/all-matches.component.ts(35,39): error
  TS2339: Property 'takeUntil' does not exist on type
  'Observable'. src/app/app.component.ts(28,39): error TS2339:
  Property 'takeUntil' does not exist on type 'Observable'.
  src/app/authorization.service.ts(19,41): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(29,37): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(42,39): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(66,39): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(74,37): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(82,39): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/database.service.ts(7,31): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseListObservable'.
  src/app/database.service.ts(7,55): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseObjectObservable'.
  src/app/match-display/match-display.component.ts(27,49): error TS2339:
  Property 'takeUntil' does not exist on type 'AngularFireObject&lt;{}>'.
  src/app/new-match/new-match.component.ts(10,30): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseListObservable'.
  src/app/new-match/new-match.component.ts(10,54): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseObjectObservable'.
  src/app/new-match/new-match.component.ts(130,37): error TS2339:
  Property 'switchMap' does not exist on type 'Observable'.
  src/app/protection.guard.ts(14,34): error TS2339: Property 'map' does
  not exist on type 'Observable'.
  src/app/test-db/test-db.component.ts(7,30): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseListObservable'.
  src/app/test-db/test-db.component.ts(7,54): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseObjectObservable'.
  src/app/user-status-report/user-status-report.component.ts(28,39):
  error TS2339: Property 'takeUntil' does not exist on type
  'Observable'.
  src/app/user-status-report/user-status-report.component.ts(33,45):
  error TS2339: Property 'subscribe' does not exist on type
  'AngularFireObject&lt;{}>'.
  src/app/user-status-report/user-status-report.component.ts(35,56):
  error TS2339: Property 'takeUntil' does not exist on type
  'AngularFireObject&lt;{}>'.
  src/app/user-status-report/user-status-report.component.ts(43,66):
  error TS2339: Property 'takeUntil' does not exist on type
  'AngularFireObject&lt;{}>'.</p>
</blockquote>

<p>Most of these errors seemed like they had to do with rxjs, and I think rightly so because I'm using rxjs v.6 in the update, and my understanding is that many things were broken between v.5 and v.6. </p>

<p>I played around with installing rxjs-compat
<code>npm install rxjs@6 rxjs-compat@6 --save</code>, and I can confirm that this package, in addition to being a hefty addition, does not resolve any of the errors I'm seeing.</p>

<p>I also automated some of the updating by running ts-lint, per the advice <a href=""https://auth0.com/blog/whats-new-in-rxjs-6/"" rel=""noreferrer"">here</a> and <a href=""https://rxjs-dev.firebaseapp.com/guide/v6/migration"" rel=""noreferrer"">here</a>: </p>

<pre><code>npm i -g rxjs-tslint
rxjs-5-to-6-migrate -p [path/to/tsconfig.json]
</code></pre>

<p>I get the following message:</p>

<blockquote>
  <p>No valid rules have been specified for JavaScript files</p>
</blockquote>

<p>I'm guessing this means that I didn't use proper ts conventions when using rxjs?</p>

<p>I'm still pretty incompetent when it comes to rxjs, so it's not clear to me exactly what else needs to be refactored.</p>

<p>But I think that my issue actually occurs before the refactoring can of worms:</p>

<p>I took a look at the first error (the </p>

<blockquote>
  <p>error TS2339: Property 'takeUntil' does not exist on type 'Observable'</p>
</blockquote>

<p>one). The error came from a method in my authentication service. In the import statements at the top of this service (and most of the other .ts files, for that matter), my IDE is highlighted a lot of, ""cannot find module foo"" errors (e.g., ""cannot find module, 'rxjs'"" for the import statement, <code>import { Observable } from 'rxjs';</code>).</p>

<p>Similar errors in the same file:</p>

<p><code>import { Injectable, EventEmitter } from '@angular/core';</code> (""Cannot find module, ""@angular/core"")</p>

<p><code>import * as firebase from 'firebase/app';</code> (""Cannot find module, ""firebase/app)</p>

<p><code>import { Router } from '@angular/router';</code> (""Cannot find module, ""@angular/router"")</p>

<p>Here's my app.module.ts file, in case that's useful:</p>

<pre><code>import { MaterializeModule } from 'angular2-materialize'
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';
import { masterFirebaseConfig } from './api-keys';
import { AngularFireModule } from 'angularfire2';
import { AngularFireDatabaseModule } from 'angularfire2/database';
import { AppComponent } from './app.component';
import { YoutubeComponent } from './youtube/youtube.component';
import { routing } from './app.routing';
import { NewMatchComponent } from './new-match/new-match.component';
import { CreateAccountComponent } from './create-account/create-account.component';
import { TestDbComponent } from './test-db/test-db.component';
import { LandingComponent } from './landing/landing.component';
import { MatchDisplayComponent } from './match-display/match-display.component';
import { AuthorizationService } from './authorization.service';
import { AngularFireAuthModule } from 'angularfire2/auth';
import { DatabaseService } from './database.service';
import { TextTransformationService } from './text-transformation.service';
import { ValidationService } from './validation.service';
import { LoginComponent } from './login/login.component';
import { ProtectionGuard } from './protection.guard';
import { AllMatchesComponent } from './all-matches/all-matches.component';
import { AnnotationDisplayComponent } from './annotation-display/annotation-display.component';
import { D3Service } from './d3.service';
import { NotfoundComponent } from './notfound/notfound.component';
import { UserStatusReportComponent } from './user-status-report/user-status-report.component';
import { PaymentOrAnnotationDetailsComponent } from './payment-or-annotation-details/payment-or-annotation-details.component';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatSelectModule } from '@angular/material/select';
import { MatOptionModule } from '@angular/material/core';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material';
import { MatTableModule } from '@angular/material/table';
// import { MatTreeModule } from '@angular/material';
import { MatTreeModule } from '@angular/material/tree';
import { MatSortModule } from '@angular/material';
import { MatDatepickerModule, MatNativeDateModule, MatPaginatorModule } from '@angular/material';
import {MatProgressSpinnerModule} from '@angular/material/progress-spinner';
import { CdkTreeModule } from '@angular/cdk/tree';


export const firebaseConfig = {
  apiKey: masterFirebaseConfig.apiKey,
  authDomain: masterFirebaseConfig.authDomain,
  databaseURL: masterFirebaseConfig.databaseURL,
  storageBucket: masterFirebaseConfig.storageBucket
};

@NgModule({
  declarations: [
    AppComponent,
    YoutubeComponent,
    NewMatchComponent,
    CreateAccountComponent,
    TestDbComponent,
    LandingComponent,
    MatchDisplayComponent,
    LoginComponent,
    AllMatchesComponent,
    AnnotationDisplayComponent,
    NotfoundComponent,
    UserStatusReportComponent,
    PaymentOrAnnotationDetailsComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    routing,
    MaterializeModule,
    ReactiveFormsModule,
    AngularFireModule.initializeApp(firebaseConfig),
    AngularFireDatabaseModule,
    AngularFireAuthModule,
    BrowserAnimationsModule,
    MatSlideToggleModule,
    CdkTreeModule,
    MatSelectModule,
    MatOptionModule,
    MatInputModule,
    MatNativeDateModule,
    MatDatepickerModule,
    MatTableModule,
    MatSelectModule,
    MatSortModule,
    MatProgressSpinnerModule,
    MatPaginatorModule,
    MatTreeModule
  ],
  providers: [AuthorizationService, DatabaseService, ProtectionGuard, D3Service, ValidationService, TextTransformationService],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>

<p>And here's the branch of the repo containing all of these issues.</p>

<pre><code>git clone https://github.com/Atticus29/dataJitsu.git
cd dataJitsu
git checkout version-hell-SO 
npm install
ng serve
</code></pre>

<p>Any troubleshooting hints or outright solutions to the importing issues are welcome and encouraged!</p>
","1009215","","1009215","","2018-07-02 04:21:46","2019-01-17 12:08:06","error TS2339: Property 'takeUntil' does not exist on type 'Observable<Foo>' and other rxjs v.6 errors","<angular><typescript><rxjs><rxjs5><rxjs6>","1","1","5","","","CC BY-SA 4.0"
"51136802","2","","51128911","2018-07-02 12:57:17","","44","","<p>It looks like your operators are still chained in rxjs 5.x fashion.</p>

<p>So to recap what changed in rxjs6 : </p>

<ol>
<li><p>Imports are different. Now, you should import Observable, Subject, BehaviorSubject etc. AND methods that were in 'rxjs/add/observable' differently. So all of these must be imported from 'rxjs'. For example : </p>

<p><code>import {Observable, Subject, of, from} from 'rxjs'</code>;</p>

<p>Alternatively, all operators like map, concat, do (which now is called tap) etc. are to be imported from <code>rxjs/operators</code>. so something like : </p>

<p><code>import { map, tap, takeUntil} from 'rxjs/operators';</code></p>

<p><strong>I think your imports are pretty sane.</strong> </p></li>
<li><p>You must use pipes instead of chaining your operators.
For instance, in your all-matches.components.ts, line 33, if you replace :
<code>this.authService.getCurrentUser().takeUntil(this.ngUnsubscribe).subscribe(user=&gt;{</code></p>

<p>by </p>

<p><code>this.authService.getCurrentUser().pipe(takeUntil(this.ngUnsubscribe)).subscribe(user=&gt;{</code></p>

<p>your takeUntil error will disappear. </p>

<p>In the same fashion, instead of <code>Observable.of(true)</code>, you should import of operator and use <code>of(true)</code>. </p>

<p>You can try this in your authorization.service.ts file. All the ""of errors"" will be fixed.</p>

<p><strong>maybe you should inspect this</strong></p></li>
<li><p>Concerning the import errors regarding custom files, please check the files actually exist. For example : </p>

<p><code>ERROR in src/app/app.module.ts(6,38): error TS2307: Cannot find module './api-keys'</code></p>

<p>related to </p>

<p><code>import { masterFirebaseConfig } from './api-keys'</code></p>

<p>is normal, since this file './api-keys' doesn't exist. 
PS: maybe you don't have these errors if keys are not stored in git, if so ignore this. </p></li>
<li><p>Finally, about AngularFire5.0, you should use one of the operators : </p>

<p><code>Db.list('items').subscribe(console.log)</code></p>

<p>becomes (with valueChanges method) :</p>

<p><code>Db.list&lt;Item&gt;('items').valueChanges().subscribe(console.log)</code></p>

<p>More info : 
<a href=""https://github.com/angular/angularfire2/blob/master/docs/version-5-upgrade.md"" rel=""noreferrer"">https://github.com/angular/angularfire2/blob/master/docs/version-5-upgrade.md</a></p></li>
</ol>

<p>Good luck! </p>
","9057497","","9057497","","2018-08-29 07:54:07","2018-08-29 07:54:07","","","","1","","","","CC BY-SA 4.0"
"51153720","1","","","2018-07-03 11:40:24","","0","272","<p>I am quite new to rxjs . I just want to trigger an redux action after an observables stop emitting data. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const removeUsersEpic = (action$, store) =&gt;
  action$
    .ofType(REMOVE_USERS)
    .mergeMap(action =&gt;
      Rx.Observable.from(action.payload).mergeMap(user =&gt; {
        return Rx.Observable.authorizedAjax({
          headers: { 'Content-Type': 'application/form-data' },
          method: 'DELETE',
          url: `${consoleBaseUrl}/api/v1/users/${user}`,
          body: {}
        })
          .mergeMap(() =&gt;
            Rx.Observable.of(
              setUserDeleteCount(store.getState().components.userListComponentData.deletedUserCount + 1),
              getUserCount()
            )
          )
          .catch(error =&gt; {
            console.log(error)
            return Rx.Observable.of(
              setUserDeleteExceptionCount(
                store.getState().components.userListComponentData.deleteUserExceptionCount + 1
              ),
              getUserCount()
            )
          })
      }).map(()=&gt;{return setDeleteOperationStatus(true)})
    )
    .catch(error =&gt; {
      console.log(error)
      return Rx.Observable.empty()
    })</code></pre>
</div>
</div>
</p>

<p>In this example, I am trying to trigger <code>setDeleteOperationStatus</code> at the end. <code>action.payload</code> is nothing but list of userids to be deleted. I am looping through ids and deleting them one by one. At the end of loop I just want to perform some action. I tried using <code>.map</code> , <code>mergemap</code> but it didn't work.</p>
","3124703","","9912706","","2018-07-03 12:12:01","2018-07-03 14:05:58","Trigger an action after the iterating through an observable","<javascript><redux><react-redux><rxjs><rxjs5>","1","1","","","","CC BY-SA 4.0"
"51155690","1","","","2018-07-03 13:20:00","","0","40","<p>I want to handle any error responses from the server after a user create post response. The post is made in the UserService createUser() method. There any errors are catched with the <code>catch</code> method after which a new error is thrown. I've read that this is neccessary otherwise the success callback within the subscribe method will be activated regardless of an error.</p>

<p>I am using Visual studio code as my IDE for this project and when you type in the <code>.</code> operator after a variable it gives a list of any methods it can call on that variable. The success callback variable has all the methods expected, including headers. The error callback only has html. So my question is: how do i get the headers out of the error? I need access to the headers because my custom header message is sent in the headers. This needs to be done within subscribe method thats situated within the component controller because when i handle the error in the service i cannot make an error message popup appear. Here is my code:</p>

<p>The code on the component controller side:</p>

<pre><code>  createUser():void{
    this.loading = true;
      this.userService.createUser(new UserCreateDTO(this.userForm.get('userName').value, 
                this.userForm.get('emailAddress').value, 
                this.userForm.get('password').value))
      .subscribe(
        success =&gt;{
            this.msgs.push({severity:'success', summary:'Success', detail: `User ${this.userForm.get('userName').value} succesfully created.`});
        },
        error =&gt;{
          let errorMessage: string = error.???
            this.msgs.push({severity:'error', summary:'Error', detail: `error`});
        }),
        () =&gt;{
          this.loading = false;
        }
  }
}
</code></pre>

<p>The questionmarks indicate that no method suggestions appear aside from method html.</p>

<p>The code on the service side, where the post is being made:</p>

<pre><code>  createUser(newUser: UserCreateDTO): Observable&lt;Response&gt; {
    return this.http.post&lt;Response&gt;(this.authUrl + ""/user/create"", newUser)
            .catch((error:any) =&gt;{
                return Observable.throw(new Error(error.status));
            });
}
</code></pre>

<p>Thank you</p>
","6351733","","","","","2018-07-03 13:30:52","How do i get the headers from the error callback of subscribe?","<angular><rxjs><angular5><rxjs5>","1","0","","","","CC BY-SA 4.0"
"51171194","1","51173651","","2018-07-04 10:13:21","","2","2301","<p>I have this method to get token via localstorage, if token is not exist or is expired, I will call API to get another token and store to localstorage. </p>

<p>In this case, which map should I use, currently using mergeMap, or other way to do this?</p>

<pre><code>public doGetToken():Observable&lt;Token&gt; {
    return this.loadToken().pipe( //get via localstorage
      map(token=&gt;{
        let valid = this.validateTokenIsValid(token);
        let data = {
          token: token,
          valid: valid
        };
        return data;
      }),
      mergeMap(data=&gt;{
        if (!data.valid) {
          return this.doApiGetToken(data.token).pipe(
            map(
              token=&gt;{
                this.saveToken(token); //save to localstorage
                return token;
              }
            )
          );
        } else {
          return of(data.token);
        }
      })
    );
</code></pre>

<p>version: Angular 5, rxjs5</p>

<p>Thank you in advance.</p>
","383307","","","","","2021-01-22 11:07:12","Angular 5 RxJs concatMap,switchMap,mergeMap which?","<angular><angular5><rxjs5><angular-local-storage>","1","0","1","","","CC BY-SA 4.0"
"51173605","1","51173706","","2018-07-04 12:22:31","","1","675","<p>I need to produce this result for a POST request:</p>

<pre><code>{
""names"": [
    {
        ""id"": ""t3xcb9xAyX"",
        ""username"": ""Gennaro""
    },
    {
        ""id"": ""Csdu65RKon"",
        ""username"": ""Marco""
    },
    ...
],
""createdAt"":""04/07/2018 - 11.49.51""
}
</code></pre>

<p>so I've done this job, using rxjs: I've created two Observable (one for names, one for createdAt) and merge at the end:  </p>

<pre><code>const notObj = utils.getNotificationType(codeProduct, Parse);
const csvObj = utils.getNotificationType(codeProduct, Parse);

const query = new Parse.Query(notObj);
const dateQuery = new Parse.Query(csvObj).descending('createdAt');


const names = from(query.find())
    .map(el =&gt; el.map((e) =&gt; {
        return {
            id: e.id,
            username: e.get('username')
        }
    }))
    .mergeMap((arr) =&gt; Observable.of({
        names: arr
    }));

const lastUpdate = from(dateQuery.first())
    .map(res =&gt; moment(res.createdAt).format('DD/MM/YYYY - HH:mm:ss'))
    .map(res =&gt; {
        return {
            createdAt: res
        }
    });


merge(names, lastUpdate)
    .subscribe(
        (data) =&gt; res.send(serialize(data)),
        (error) =&gt; res.send(serialize(error)),
        () =&gt; console.log('complete')
    );
</code></pre>

<p>the problem is that finally merge retrieve me only <code>""names""</code>. I could have another result using <code>.zip()</code> operator, but I have a JSON array instead an object.</p>

<p>My question is: why <code>merge()</code> doesn't merge two result but only the first? Thank you</p>
","4279905","","","","","2018-07-04 12:26:52","rxjs Observable merge doesn't work as expected","<javascript><rxjs><observable><rxjs5>","1","0","","","","CC BY-SA 4.0"
"51173651","2","","51171194","2018-07-04 12:24:16","","8","","<p>If you <strong>only make one request</strong>, then <strong>it doesn't matter</strong> which map you use.</p>
<p>mergeMap (also called flatMap), concatMap , exhaustMap or switchMap will behave the same.</p>
<p>These operators behave differently when you emit more than 1 value:</p>
<p><strong>switchMap</strong></p>
<p>will apply the mapping to the latest input received:</p>
<pre><code>Src : -----A----B----C--D-E-------

switchMap (x =&gt; x--x) // emit x twice when received

Out:  ------A--A-B--B-C-D-E--E----
</code></pre>
<p><strong>concatMap</strong></p>
<p>will finish the mapping before taking another input:</p>
<pre><code>Src : -----A----B----C--D-E-----------

concatMap (x =&gt; x--x) // emit x twice when received

Out:  ------A--A-B--B-C--C--D--D-E--E
</code></pre>
<p><strong>mergeMap</strong></p>
<p>is like concatMap, but it doesn't wait for mapping to complete. The results can overlap though:</p>
<pre><code>Src : -----A----B----C-D---E-----------

mergeMap (x =&gt; x--x) // emit x twice when received

Out:  ------A--A-B--B-C-D-C-D-E--E-----
</code></pre>
<p><strong>exhaustMap</strong></p>
<p>is like a reversed switchMap, it gives priority to the output:</p>
<pre><code>Src : -----A--------B----C-D---E-----------

exhaustMap (x =&gt; x--x--x) // emit x thrice when received

Out:  ------A--A--A--B--B--B-D--D--D-------
</code></pre>
<p>For more information :</p>
<p><a href=""https://medium.com/@vdsabev/the-simple-difference-between-rxjs-switchmap-and-mergemap-397c311552a5"" rel=""nofollow noreferrer"">https://medium.com/@vdsabev/the-simple-difference-between-rxjs-switchmap-and-mergemap-397c311552a5</a></p>
<p>Marble diagrams :</p>
<p><a href=""http://rxmarbles.com/#mergeMap"" rel=""nofollow noreferrer"">http://rxmarbles.com/#mergeMap</a></p>
<p>Edit : I moved the simplification of your code to the bottom to make the general information visible at first sight.</p>
<pre><code>public doGetToken(): Observable&lt;Token&gt; {
  return this.loadToken()
    .pipe( //get via localstorage
      mergeMap(token =&gt; {
        if(!this.validateTokenIsValid(token))
          return of(token)
        return this.doApiGetToken(token)
          .pipe(
            tap( token =&gt; this.saveToken(token)) //save to localstorage
          );
      })
    )
};
</code></pre>
","9057497","","3087130","","2021-01-22 11:07:12","2021-01-22 11:07:12","","","","0","","","","CC BY-SA 4.0"
"51173706","2","","51173605","2018-07-04 12:26:52","","4","","<p>That's not what <code>merge</code> does. It merges Observable streams not objects themselves. Use <code>forkJoin</code> instead that will emit an array of results and then merge it yourself with <code>map</code>:</p>

<pre><code>const names$ = ...;
const lastUpdate$ = ...;

forkJoin(names$, lastUpdate$)
  .map(([ names, lastUpdate ]) =&gt; ({ names, lastUpdate }))
  .subscribe(...)
</code></pre>
","310726","","","","","2018-07-04 12:26:52","","","","2","","","","CC BY-SA 4.0"
"51201998","1","51202065","","2018-07-06 01:47:34","","2","1102","<p>i have define a behaviorSubject:</p>

<pre><code>measurementSearchChange$ = new BehaviorSubject('');
this.measurementSearchChange$
  .asObservable()
  .pipe(debounceTime(500))
  .pipe(
    switchMap((keyword: string) =&gt;
      this.warningService.getInfluxdbQuery(
        this.selectedMonitorOption,
        'measurement',
        { search_name: keyword }
      )
    )
  )
  .subscribe((data: any) =&gt; {
    this.measurementOptions = data;
    this.isLoading = false;
  });
</code></pre>

<p>when some action, will do that:</p>

<pre><code>this.measurementSearchChange$.next(keyword);
</code></pre>

<p>it work well now, but i want add a switchMap and zip them so that i can subscribe two different data, likeï¼</p>

<pre><code>this.measurementSearchChange$
  .asObservable()
  .pipe(debounceTime(500))
  .pipe(
    switchMap((keyword: string) =&gt;
      this.warningService.getInfluxdbQuery(
        this.selectedMonitorOption,
        'measurement',
        { search_name: keyword }
      )
      // another 
      this.warningService.getInfluxdbQuery2(
        this.selectedMonitorOption,
        'measurement2',
        { search_name: keyword }
      )
    )
  )
  .subscribe((data1: any, data2: any) =&gt; {
    this.measurementOptions = data;
    this.isLoading = false;
  });
</code></pre>

<p>so how can do that? any help is appreciate</p>
","6408449","","","","","2018-07-06 03:03:25","rxjs zip two switchMap?","<angular><rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51202065","2","","51201998","2018-07-06 01:59:52","","3","","

<p>If your queries emit a single result and then complete, you can use <code>forkJoin</code>, like this:</p>

<pre class=""lang-ts prettyprint-override""><code>import { forkJoin } from 'rxjs';
/* ... */
this.measurementSearchChange$
  .asObservable()
  .pipe(
    debounceTime(500),
    switchMap((keyword: string) =&gt; forkJoin(
      this.warningService.getInfluxdbQuery(
        this.selectedMonitorOption,
        'measurement',
        { search_name: keyword }
      ),
      this.warningService.getInfluxdbQuery2(
        this.selectedMonitorOption,
        'measurement2',
        { search_name: keyword }
      )
    ))
  )
  .subscribe(([data1, data2]: [any, any]) =&gt; {
    this.measurementOptions = data;
    this.isLoading = false;
  });
</code></pre>

<p>If they emit multiple results, use <code>combineLatest</code> instead of <code>forkJoin</code>.</p>

<p>I wouldn't use <code>zip</code>, unless it's the case that the queries can emit more than one result and it's guaranteed that each time one query emits a result the other query will emit one, too.</p>
","6680611","","6680611","","2018-07-06 03:03:25","2018-07-06 03:03:25","","","","2","","","","CC BY-SA 4.0"
"51281017","1","51301958","","2018-07-11 08:45:14","","0","449","<p>I'm having an issue upgrading from RxJS5 to version 6.  I've got the following code:</p>

<pre><code>  private captureEvents(canvasEl: HTMLCanvasElement) {

    Observable
      .fromEvent(canvasEl, 'mousedown')
      .switchMap((e) =&gt; {
        return Observable
          .fromEvent(canvasEl, 'mousemove')
          .takeUntil(Observable.fromEvent(canvasEl, 'mouseup'))
          .pairwise()
      })
      .subscribe((res: [MouseEvent, MouseEvent]) =&gt; {
        const rect = canvasEl.getBoundingClientRect();

        const prevPos = {
          x: res[0].clientX - rect.left,
          y: res[0].clientY - rect.top
        };

        const currentPos = {
          x: res[1].clientX - rect.left,
          y: res[1].clientY - rect.top
        };

        this.drawOnCanvas(prevPos, currentPos);
      });
  }
</code></pre>

<p>But when I upgrade to RxJS6 I get the following error:</p>

<blockquote>
  <p>Property 'fromEvent' does not exist on type 'typeof Observable'.</p>
</blockquote>

<p>I tried to change my imports from this (RxJS5):</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/operator/pairwise'; 
import 'rxjs/add/operator/switchMap';
</code></pre>

<p>To this (RxJS6):</p>

<pre><code>import { Observable, fromEvent } from 'rxjs';
import { switchMap, takeUntil, pairwise } from 'rxjs/operators';
</code></pre>

<p>This was my best attempt up upgrading the code:</p>

<pre><code>  private captureEvents(canvasEl: HTMLCanvasElement) {

    const obsMouseDown = fromEvent(canvasEl, 'mousedown').pipe(
      switchMap((e) =&gt; {
        const obsMouseMove = fromEvent(canvasEl, 'mousemove').pipe(
          takeUntil(a =&gt; {
            const obsMouseUp = fromEvent(canvasEl, 'mouseup').pipe(
              pairwise()
            );
            return obsMouseUp;
          }));

        return obsMouseMove;
      }))
      .subscribe((res: [MouseEvent, MouseEvent]) =&gt; {
        const rect = canvasEl.getBoundingClientRect();

        const prevPos = {
          x: res[0].clientX - rect.left,
          y: res[0].clientY - rect.top
        };

        const currentPos = {
          x: res[1].clientX - rect.left,
          y: res[1].clientY - rect.top
        };

        this.drawOnCanvas(prevPos, currentPos);
      });
  }
</code></pre>

<p>But this isn't working - I get an error for the ""takeUntil"" code:</p>

<blockquote>
  <p>Argument of type '(a: any) => Observable&lt;[Event, Event]>' is not
  assignable to parameter of type 'Observable'</p>
</blockquote>

<p>plnkr example of original code here:<br>
<a href=""https://embed.plnkr.co/QSvJxi/"" rel=""nofollow noreferrer"">https://embed.plnkr.co/QSvJxi/</a></p>
","1659806","","","","","2018-07-18 14:57:46","Upgrading from RxJS5 to RxJS6","<angular5><observable><rxjs5><angular6><rxjs6>","3","0","","","","CC BY-SA 4.0"
"51301958","2","","51281017","2018-07-12 09:27:59","","1","","<p>For some reason your plnkr didn't work for me but I'll try my best to provide an answer. I think you should do 2 things here for starter. Try initializing your Observables so it's easier to call them and subscribe to them like so:</p>

<pre><code>const mousedown$ = fromEvent(pauseButton, 'mousedown');
const mouseup$ = fromEvent(resumeButton, 'mouseup');
const mousemove$ = fromEvent(resumeButton, 'mousemove');
</code></pre>

<p>The second thing you should pipe your operators now with Rxjs 5 &amp; 6, like so, And subscribe to all your events</p>

<pre><code>mousedown$.pipe(
    switchMap(res =&gt; {
       mousemove$.pipe(//Whatever Operators and subscribitions to other events).subscribe(...)
    }),
    map(// Whatever you want back from your event)
  ).subscribe(...)
</code></pre>

<p>I refer to you the documentation links <a href=""https://www.learnrxjs.io/operators/transformation/switchmap.html"" rel=""nofollow noreferrer"">switchMap</a> &amp;&amp; <a href=""https://www.learnrxjs.io/operators/filtering/takeuntil.html"" rel=""nofollow noreferrer"">takeUntil</a> . As many syntaxes are changing in Rxjs don't be shy to brows the documentation, there is nothing better.</p>
","5221527","","","","","2018-07-12 09:27:59","","","","1","","","","CC BY-SA 4.0"
"51434876","1","","","2018-07-20 04:00:15","","1","621","<p>I am using Angular 6 with RxJs 6 and I have a backend api which will <strong>send the response with generic class object</strong>, which means the response data model is not static, <strong>but I have one more indicator that can tell me what model is passing in</strong>, code example are:</p>

<pre><code>interface orderSummary {...}
interface orderDetail {...}
interface IResponse {
    objectType: string;
    objectData: any
}

GetGenericDataModel() {
    return this.httpClient.get&lt;IResponse&gt;(`../api/method`)
        .map?flatmap?pipe?( --&gt;what should I use here?
            (response) =&gt; {
                 if (response.objectType === 'orderSummary')
                    return response.objectData.ToOrderSummary --&gt; how to convert to orderSummary
                 else if (response.objectType === 'orderDetail')
                    return response.objectData.ToOrderDetail --&gt; how to convert to orderDetail                           
            }
        );
}
</code></pre>

<p>On client side when I use http.get to fetch my result and <strong>depend on my response indicator(objectType), I need to convert/transform the response data(objectData) into my interface(either orderSummary or orderDetail)</strong>, How should I work with rxjs to convert/transform my response data into my pre-defined interface in Angular 6? </p>
","6524600","","","","","2018-07-20 04:37:05","How should I transform generic observable into specific data model in rxjs 6/Angular 6?","<typescript><angular5><angular6><rxjs5><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51439044","1","","","2018-07-20 09:10:14","","0","83","<p><a href=""https://i.stack.imgur.com/tLzqt.png"" rel=""nofollow noreferrer"">Please have look on attached image for better idea. Click on this link to show</a></p>

<p>I took the reference to create my image gallery from following the link - <a href=""https://www.npmjs.com/package/angular2-image-gallery"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/angular2-image-gallery</a></p>

<p>Steps I executed.</p>

<ol>
<li>Clear the cache &amp; removed node_modules</li>
<li>Installed angular2-Image-Gallery package and try to run app throws above error</li>
</ol>

<p>Please help!</p>
","9023642","","9023642","","2018-07-20 09:20:49","2018-07-20 09:24:51","When I installed angular2-image-gallery package it throws error in node-module's file imports rxjs/internal/Subscription","<angular5><npm-install><node-modules><rxjs5>","1","3","","","","CC BY-SA 4.0"
"51498259","1","","","2018-07-24 12:09:01","","0","143","<p><strong>In system.config.js file, i used this rxjs link:</strong></p>

<blockquote>
  <p>'rxjs': '<a href=""https://unpkg.com/rxjs@5.5.10/"" rel=""nofollow noreferrer"">https://unpkg.com/rxjs@5.5.10/</a>'</p>
</blockquote>

<p>**it makes error bcz,it generate another one slash and add it to the end of link, bcz of this my source is not defind **</p>

<p><strong>instead of above link, if i use this link, it will work. i want to know the reason?</strong></p>

<blockquote>
  <p>'rxjs': '<a href=""https://unpkg.com/rxjs@5.5.10"" rel=""nofollow noreferrer"">https://unpkg.com/rxjs@5.5.10</a>'</p>
  
  <p>my system.config.js file</p>
</blockquote>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>System.config({
    transpiler: ""typescript"",
    typescriptOptions: {
        compilerOptions: {
            target: ""umd"",
            module: ""commonjs"",
            moduleResolution: ""node"",
            emitDecoratorMetadata: true,
            experimentalDecorators: true
        }
    },
    paths: {
        ""syncfusion:"": ""{{:CDN_LINK}}"",
        ""angular:"": ""https://unpkg.com/@angular/""
    },
    map: {
        app: 'app',
        typescript: ""https://unpkg.com/typescript@2.2.2/lib/typescript.js"",
          ""@syncfusion/ej2-base"": ""syncfusion:ej2-base/dist/ej2-base.umd.min.js"",
        ""@syncfusion/ej2-dropdowns"": ""syncfusion:ej2-dropdowns/dist/ej2-dropdowns.umd.min.js"",
        ""@syncfusion/ej2-inputs"": ""syncfusion:ej2-inputs/dist/ej2-inputs.umd.min.js"",
        ""@syncfusion/ej2-lists"": ""syncfusion:ej2-lists/dist/ej2-lists.umd.min.js"",
        ""@syncfusion/ej2-data"": ""syncfusion:ej2-data/dist/ej2-data.umd.min.js"",
        ""@syncfusion/ej2-popups"": ""syncfusion:ej2-popups/dist/ej2-popups.umd.min.js"",
        ""@syncfusion/ej2-buttons"": ""syncfusion:ej2-buttons/dist/ej2-buttons.umd.min.js"",
        ""@syncfusion/ej2-ng-base"": ""syncfusion:ej2-ng-base/dist/ej2-ng-base.umd.min.js"",
        ""@syncfusion/ej2-ng-popups"": ""syncfusion:ej2-ng-popups/dist/ej2-ng-popups.umd.min.js"",
        ""@syncfusion/ej2-ng-buttons"": ""syncfusion:ej2-ng-buttons/dist/ej2-ng-buttons.umd.min.js"",
        ""@syncfusion/ej2-ng-dropdowns"": ""syncfusion:ej2-ng-dropdowns/dist/ej2-ng-dropdowns.umd.min.js"",
 

        '@angular/core': 'angular:core@5.2.10/bundles/core.umd.js',
        '@angular/common': 'angular:common@5.2.10/bundles/common.umd.js',
        '@angular/compiler': 'angular:compiler@5.2.10/bundles/compiler.umd.js',
        '@angular/http': 'angular:http@5.2.10/bundles/http.umd.js',
        '@angular/forms': 'angular:forms@5.2.10/bundles/forms.umd.js',
        '@angular/router': 'angular:router@5.2.10/bundles/router.umd.js',
        '@angular/platform-browser': 'angular:platform-browser@5.2.10/bundles/platform-browser.umd.js',
        '@angular/platform-browser-dynamic': 'angular:platform-browser-dynamic@5.2.10/bundles/platform-browser-dynamic.umd.js',
        '@angular/material': 'angular:material@5.2.10/bundles/material.umd.js',
        'rxjs': 'https://unpkg.com/rxjs@5.5.10'
    },
    packages: {
        'app': { main: 'main', defaultExtension: 'ts' },
        'rxjs': { main: 'index' },
    }
});
 
System.import('app');
 </code></pre>
</div>
</div>
</p>
","9440892","","9440892","","2018-07-24 12:43:29","2018-07-24 12:43:29","Rxjs link is not working?","<javascript><angular><rxjs5>","2","0","1","","","CC BY-SA 4.0"
"51516721","1","","","2018-07-25 10:33:16","","10","6201","<p>My AlertService has 
<code>private subject = new Subject&lt;Alert&gt;();</code>.
I want to autocratically clear alert after 5 seconds. I can do it with using <code>setTimeout()</code> like this:</p>

<pre><code>autoClear(alertId?: string) {
   setTimeout(
      () =&gt; this.subject.next(new Alert({alertId})),
   5000);
  }
</code></pre>

<p>I tried to do that more elegant and I created this code:</p>

<pre><code>autoClear(alertId?: string) {
    const delay = new Observable(x =&gt; {
      x.next();
    }).delay(5000).subscribe(() =&gt; {
      this.subject.next(new Alert({alertId}));
      delay.unsubscribe();
    });
  }
</code></pre>

<p>Both of example <strong>works</strong> but it doesn't look like a proper way of using RxJS. How can I improve it?</p>
","4955934","","","","","2018-07-25 13:27:58","How to delay next(value) on subject?","<angular><rxjs><angular5><rxjs5><subject>","2","3","","","","CC BY-SA 4.0"
"51520584","1","","","2018-07-25 13:49:01","","20","21047","<p>I am learning angular and i got confuse in these observable, observer and subscribe
thing. So please explain.</p>
","8383194","","","","","2021-06-18 20:04:52","What is observable, observer and subscribe in angular?","<angular><rxjs><angular6><rxjs5>","4","0","12","","","CC BY-SA 4.0"
"51529291","1","","","2018-07-26 00:08:45","","1","1172","<p>I couldn't find a way to handle promise rejection while writing following redux-observable epic. How can I handle <code>getDataFromPromise</code> rejection? I've tried pipe, catch, catchError etc.</p>

<pre><code>(action$, store) =&gt;
  action$
    .ofType(request().type)
    .mergeMap(action =&gt;
      fromPromise(getDataFromPromise(action.payload)).map(data =&gt;
        success(data)
      )
    )
</code></pre>

<p>Following should be working according to <a href=""https://www.learnrxjs.io/operators/creation/frompromise.html"" rel=""nofollow noreferrer"">this</a> example, but it doesn't.</p>

<pre><code>(action$, store) =&gt;
   action$.ofType(request().type).mergeMap(action =&gt;
     fromPromise(getDataFromPromise(action.payload))
       .pipe(catchError(error =&gt; of(failure(error))))
       .map(data =&gt; success(data))
   )
</code></pre>
","2746389","","2746389","","2018-07-26 19:09:38","2018-07-26 19:09:38","How to handle promise rejection when using fromPromise (rxjs5.5)","<rxjs><rxjs5><redux-observable>","1","2","","","","CC BY-SA 4.0"
"51554571","1","51554748","","2018-07-27 09:09:45","","2","1045","<p>Problem: looking for a way to get a regular event emission (saying every 200ms) while the user hovering a DOM element with RxJs on angular 5.</p>

<p>Actually, using <code>mouseover</code> via simple JS, angular or RxJs doesn't produce a regular event and the behavior differs from browsers. Using <code>debounce</code> doesn't help about event emission.</p>

<p>So, I thought instead using <code>mouseenter</code> and <code>mouseleave</code> events and a timer between them. But I have no idea how to start and stop a timer from events.</p>

<p>Something like <a href=""https://stackoverflow.com/a/3966307/7457567"">this solution in JQuery</a>, but with observables.</p>

<p>A (bad) code is better than 1000 words:</p>

<pre class=""lang-js prettyprint-override""><code>// RxJs syntax in typescript for angular
const enter = fromEvent(nativeElement, ""mouseenter"");
const leave = fromEvent(nativeElement, ""mouseleave"");

// Bad code, just an idea
enter.pipe(
  merge(interval(200 /* ms */)),
  takeUntil(leave)
).subscribe(event =&gt; console.log(""hovering"", event));
</code></pre>

<p>Do you know if it is possible to start an interval emission after each <code>mouseenter</code>?</p>

<p>For libraries, I'm using <strong>RxJs 5</strong> with Angular 5 on typescript 2.5.</p>
","7457567","","","","","2018-07-27 09:19:06","Regular observable emission while DOM hovering","<angular><rxjs><observable><rxjs5><angular2-observables>","1","0","","","","CC BY-SA 4.0"
"51554748","2","","51554571","2018-07-27 09:19:06","","1","","<p>I think you were very close. Just instead of <code>merge</code> you should use <code>mergeMap</code> that will subscribe to the <code>interval</code> Observable only after an emission from <code>enter</code>. Then you probably want to use <code>repeat()</code> as well that will repeat the process after every <code>leave</code> emission (however, this depends on how use/call this code).</p>

<pre><code>enter.pipe(
  mergeMap(() =&gt; interval(200 /* ms */)),
  takeUntil(leave),
  repeat(),
).subscribe(event =&gt; console.log(""hovering"", event));
</code></pre>

<p>See demo: <a href=""https://stackblitz.com/edit/rxjs6-demo-nrb7km?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs6-demo-nrb7km?file=index.ts</a></p>
","310726","","","","","2018-07-27 09:19:06","","","","2","","","","CC BY-SA 4.0"
"51628761","1","","","2018-08-01 08:33:32","","0","865","<p>I am trying to execute 5 parallel http requests with mergeMap and forkJoin conditionally. For me only the first api is getting executed and rest of the apis are not triggering.</p>

<p>my function will execute first api and if it returns status as  'NOT_FOUND', then I need to execute another 5 apis and need to return the final result. If Iam getting status different from 'NOT_FOUND', need to just return the observable from first http request. I tried different options, but nothing seems to be working. Below shared code, Im getting  ""ERROR TypeError: Unable to get property 'map' of undefined or null reference""</p>

<pre><code>public myPostWrapper( url, body, flag): Observable&lt;any&gt; {
 return this.http.post( url, body, { headers: this.headers } )
        .map(( out: any ) =&gt; {
            console.log( 'out', JSON.stringify( out ) );
            this.result = out;
        } )
        .mergeMap(( response: any ) =&gt; {
            console.log( 'response-inside', JSON.stringify( response ) );
            if ( this.result.status === 'NOT_FOUND' ) {
                return Observable.forkJoin(
                    response.map(( resp: any ) =&gt; {
                        return this.http.post(url, body, { headers: this.headers })
                            .map(( res: any ) =&gt; {
                                const section: any = res;
                                return section;
                            } );
                    } ),
                    response.map(( resp: any ) =&gt; {
                        return this.http.post(url, body, { headers: this.headers })
                            .map(( res: any ) =&gt; {
                                const section: any = res;
                                return section;
                            } );
                    } )
                );
            } else {
                return Observable.of( this.result );
            }
        } )
        .catch(( error: any ) =&gt; Observable.throw( error || 'Server error' ) 
);
</code></pre>

<p>}</p>

<p>Any help/direction would be greately appreciated. Note Im using Rxjs 5.52 with Angular 5</p>
","756975","","","","","2018-08-01 08:38:37","Issue with MergeMap with forkJoin Angular 5","<angular><http><observable><rxjs5><fork-join>","1","0","","","","CC BY-SA 4.0"
"51655067","1","51811185","","2018-08-02 13:36:00","","0","156","<p>I am running angular5 with RxJs 5.5 and just found that operators like filter are available without importing them. They seem to be known methods of the Observable type without patching. If that is true though then there would be no point in pipeable operators since they came in to address the issue of patching the global observable type by instead offering methods that dont patch. Does that sound correct?</p>

<p>If it is correct then how is this even working without importing filter?</p>

<pre><code>.callFunctionThatReturnsObserable()
.filter(x =&gt; x == ""astring"")
</code></pre>
","7230887","","","","","2018-08-12 18:35:43","RxJs operators are available without patching?","<rxjs><rxjs5>","1","3","","","","CC BY-SA 4.0"
"51774172","1","51774346","","2018-08-09 19:06:22","","1","1688","<p>What is the correct way to apply an RXJS v5.5 filter to an array of objects?</p>

<p>I am getting back a json array that looks like this:</p>

<pre><code>[
    0: {CompanyName: ""Facebook Inc-A"", Symbol: ""FB"", is_etf: false},
    1: {CompanyName: ""Flagstar Bancp"", Symbol: ""FBC"", is_etf: false},
    2: {CompanyName: ""UBS AG FI Enhanced Large Cap Growth ETN"", etf_data: {â¦}, Symbol: ""FBGX"", is_etf: true},
    3: {CompanyName: ""Fortune Brd H&amp;S"", Symbol: ""FBHS"", is_etf: false},
    4: {CompanyName: ""Fortress Biotec"", Symbol: ""FBIO"", is_etf: false},
    5: {CompanyName: ""First Bus Finl"", Symbol: ""FBIZ"", is_etf: false},
...]
</code></pre>

<p>I need to keep values with <code>is_etf === false</code> </p>

<p>I currently have: </p>

<p>...</p>

<pre><code>.switchMap(val =&gt; this.symbolSearchService.symbolLookup(val))
      .takeUntil(this.ngUnsubscribe)
      .filter((value) =&gt; {
        console.log(value)
        return true
      })
      .subscribe(val =&gt; {
        console.log('val', val)
        this.searchResults = val;
      });
</code></pre>

<p>symbolLookup returns the array referenced above. inside the filter I've tried:</p>

<p><code>value =&gt; !value.is_etf</code></p>

<p><code>value =&gt; return value.is_etf === false</code></p>

<p><code>value =&gt; value['is_etf'] === false</code></p>

<p>but none of these work, as the is_etf property is on each object, not on the value response. Before RXJS I would've just done a for loop and then just go with <code>value[i]['is_etf']</code> etc but no luck here. All the reading materials I've encountered are doing simple filters like value => value > 2 ... any advice?</p>

<p>Thanks!!</p>
","5376548","","5376548","","2018-08-09 19:17:31","2018-08-09 19:28:47","Angular: How do I Rxjs filter by property through an array of objects?","<javascript><arrays><object><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"51774346","2","","51774172","2018-08-09 19:17:18","","1","","<p>The <code>filter</code> operator in RxJS does not behave like the <code>Array.filter</code> function used for filtering out items from a list.  </p>

<p>What you are actually getting from <code>this.symbolSearchService.symbolLookup(val)</code> seems to be an array, so the type of the emmission in <code>filter</code> will also be an array. So, what you might be looking for is a <code>map</code> operator that forwards the filtered list, like that:</p>

<pre><code>.switchMap(val =&gt; this.symbolSearchService.symbolLookup(val))
      .takeUntil(this.ngUnsubscribe)
      .map((values) =&gt; {
        return values.filter(v =&gt; !v.is_etf);
      })
      .subscribe(val =&gt; {
        console.log('val', val)
        this.searchResults = val;
      });
</code></pre>
","7247920","","","","","2018-08-09 19:17:18","","","","2","","","","CC BY-SA 4.0"
"51811185","2","","51655067","2018-08-12 17:26:56","","1","","<p>If you import Observable from 'rxjs' (or 'rxjs/Rx') anywhere in your application, that will patch Observable with most of the standard operators for your entire application.</p>

<p>This has the disadvantage of including all operators in your production built file, but has the advantage that you do not need to specifically import the needed operators anywhere.</p>

<p>If you change to importing from 'rxjs/Observable' everywhere, the operators will no longer be pulled in, so you will need to import those that you use - but again, note that you only need to import them once, anywhere within your application, and they will be globally available.</p>

<p>In RxJS 6 / Angular 6, this is changed and the operators are no longer patched onto the Observable type, but are standalone functions to be used with the Observable <code>pipe</code> method. With this, you import Observable from 'rxjs', and you then import the operators in each file you use them in. It's much cleaner, because you don't end up in the situation you describe where you find that, actually, somehow you've imported all of them globally whether or not you need them.</p>
","789529","","789529","","2018-08-12 18:35:43","2018-08-12 18:35:43","","","","0","","","","CC BY-SA 4.0"
"51839719","1","","","2018-08-14 10:51:55","","1","22","<p>I have an AuthenticatedHttpClient class which extends HttpClient and all my services make use of this so that each request that is made provides a JWT token to the API.</p>

<p>I've also got a generic error handler that handles a 401 response when the token expires, and refreshes the token with a refresh token, then should replay the original request, so it appears seamless (baring a slight increase in delay).</p>

<p>This is all working fine, except that the replayed requests have the original headers in them that were set at the time it was created, and so they JWT token in the headers is now out of date.</p>

<p>I can come up with two solutions...</p>

<p>1) somehow edit the request on retry and alter the headers to use the current token</p>

<p>2) (preferred) make the requests retrieve the token at the time they are sent, rather than when they are created. </p>

<p>I don't know how to do either currently...  If someone can tell me the solution to either I'd greatly appreciate it...</p>

<p>Example use of retry mechanics in my AuthenticatedHttpClient:</p>

<pre><code>public get&lt;T&gt;(endPoint: string, options?: IRequestOptions): Observable&lt;T&gt; {
    console.log('my http client requesting Get');
    return this.http.get&lt;T&gt;(endPoint, options).retryWhen(this.handleErrorAndRetry(this.authService));
}
</code></pre>

<p>handleErrorAndRetry definition:</p>

<pre><code>private handleErrorAndRetry(authService: AuthenticationService): (error: any) =&gt; any {
  return (error: any) =&gt; {
    return error
      .flatMap((err: any) =&gt; {
        if (err.status === 401) {
          return authService.refreshTokenObservable()
        }
        return Observable.throw({error: 'No retry'});
      })
      .take(2);
  };
}
</code></pre>

<p>Example use of AuthenticatedHttpClient in a service:</p>

<pre><code>listEntities(companyId: any): Observable&lt;Entity[]&gt; {
    return this.http.get&lt;Entity[]&gt;(`${this.apiBase}/${this.apiResource}/${companyId}/${this.apiSubResource}`, {
        headers: this.getHeaders()
    });
}
</code></pre>
","460785","","13860","","2018-08-14 11:08:51","2018-08-14 11:08:51","Dynamic headers that are recalculated with each retry","<angular5><rxjs5><angular-httpclient>","0","1","","","","CC BY-SA 4.0"
"51841374","1","51841749","","2018-08-14 12:24:17","","0","470","<p>I have two observables, the second need the result of the first, so I used <a href=""https://www.learnrxjs.io/operators/transformation/switchmap.html"" rel=""nofollow noreferrer"">switchMap</a> :</p>

<pre><code>this.fooSharer.getFoo().pipe(switchMap((foo: Foo) =&gt; {
    return this.http.post('/someUrl',
    body,
    headers
  )
}));
</code></pre>

<p>So I have in return an Observable of Object (from http.post), but my subscription from the foo Observale is still active and I can't unsubscribe, how can I do ?</p>
","2898190","","","","","2018-08-14 12:43:28","Unsubscribe first observable in switchmap","<rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"51841749","2","","51841374","2018-08-14 12:43:28","","2","","<p>If you use emitted value from <code>fooSharer.getFoo()</code> just as a signal to start the second Observable you can put <code>take(1)</code> just before the <code>switchMap</code>.
This way, after the first emitted value the <code>fooSharer.getFoo()</code> will complete.</p>
","4952067","","","","","2018-08-14 12:43:28","","","","0","","","","CC BY-SA 4.0"
"51845378","1","","","2018-08-14 15:52:34","","0","58","<p>Having following setup,</p>

<blockquote>
  <p>Angular-4.2.4, 
  RXJS - 5.4.2 </p>
</blockquote>

<p>I wanted to upgrade RXJS so I did it and now it is</p>

<blockquote>
  <p>rxjs-6.2.2</p>
</blockquote>

<p>I faced problems like <code>map, subscribe, Observable</code> not exist.</p>

<p>So installed <code>rxjs-compat</code> for backward compatibility.</p>

<blockquote>
  <p>rxjs-compat-6.2.2</p>
</blockquote>

<p>But still I get the same errors.</p>

<p>Any solution? Am I doing something wrong? </p>

<p>Any guidance will be pretty helpful.</p>

<p><strong><em>Plesae note that I don't want to upgrade Angular</em></strong></p>
","3751711","","","","","2018-08-14 16:46:23","Property map, subscribe, observable not exist","<angular><rxjs5><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51914371","1","51915733","","2018-08-19 04:05:26","","0","971","<p>I'd like to handle ajax timeouts using redux-observable so that if a timeout occurs (after say 10 seconds) it will retry the request another two times (firing a <code>SAVE_RETRYING</code> action every time so the UI can notify the user that it's retrying).</p>

<p>For any other type of error or if we've already retried twice it should just fail and fire a <code>SAVE_FAILURE</code> action.</p>

<p>I can make it work if I trigger the <code>SAVE_RETRYING</code> action using <code>store.dispatch</code> but getting deprecation warnings about this and I'm a bit stuck figuring out how to do it the proper way (adding <code>SAVE_RETRYING</code> to the stream that is returned by the epic).</p>

<p>Here's what I have (simplified):</p>

<pre><code>function saveEpic(action$, store) {
  return action$.ofType('SAVE_CLICKED')
    .mergeMap(action =&gt; (
      ajax({
        url: '/a-long-request',
      })
        .timeout(10000)
        .map(() =&gt; ({ type: 'SAVE_SUCCESS' }))
        .retryWhen(errors =&gt; (
          errors.scan((count, e) =&gt; {
            if (count &gt;= 2 || e.name !== 'TimeoutError') {
              throw e;
            } else {
              store.dispatch({ type: 'SAVE_RETRYING', count });
              return count + 1;
            }
          }, 0)))
        .startWith({ type: 'SAVE_STARTED' })
        .catch(() =&gt;
          Observable.of({ type: 'SAVE_FAILURE' }))
    ));
}
</code></pre>

<p>How can I get that <code>SAVE_RETRYING</code> action up to the main stream? Thx.</p>
","215792","","","","","2018-08-19 08:11:53","Redux observable retry on timeout","<redux><rxjs><rxjs5><redux-observable>","1","0","","","","CC BY-SA 4.0"
"51915733","2","","51914371","2018-08-19 08:11:53","","2","","<p>This is not ideal, but you could use <code>catch</code> and undocumented second argument (which is the source observable) to resubscribe. The downside I don't like is you have to count retries in the <code>mergeMap</code> callback closure.</p>

<pre><code>function saveEpic(action$, store) {
  return action$.ofType('SAVE_CLICKED')
    .mergeMap(action =&gt; {
      let retries = 0;
      return ajax({
        url: '/a-long-request',
      })
        .timeout(10000)
        .map(() =&gt; ({ type: 'SAVE_SUCCESS' }))
        .catch((error, source) =&gt; {
          retries += 1;
          if (retries &gt;= 2 || error.name !== 'TimeoutError') {
            return Observable.of({ type: 'SAVE_FAILURE' });
          }

          return source.startWith({ type: 'SAVE_RETRYING', count: retries });
        })
        .startWith({ type: 'SAVE_STARTED' });
    });
}
</code></pre>
","3024975","","","","","2018-08-19 08:11:53","","","","1","","","","CC BY-SA 4.0"
"51979619","1","51982276","","2018-08-23 06:33:56","","2","2807","<p>In my angular project, I need to refresh the token before it expires by doing user interaction. on UI we display session timeout message and a renew icon just before 5 minutes before it expires and when user click on renew icon we refresh the token and now it again checks the session with this new token and so on.</p>

<ul>
<li><p>RxJs v 5.1</p></li>
<li><p>Angular v 4.0</p></li>
</ul>

<p>I was using <code>setInterval()</code> and <code>clearInterval()</code>   and here is relevant code</p>

<pre><code>@Compononet({})
export class AdminLayoutComponent implements OnInit {
    isRefreshingToken: boolean;
    interval: any;
    period: number;
    constructor() {
        this.notifyMinutes = 5; // in minutes
        this.isRefreshingToken = false;
        this.period = 60 * 1000;
        this.timer$ = Observable.timer(0, this.period);
    }

    ngOninit() {
        this.interval = &lt;any&gt;setInterval(() =&gt; this.checkSession(), this.period);
    }

    private checkSession() {
        // calculate the remaining time and display the message accordingly
        if (remainingTime &lt; 5 minutes) {
            this.refreshTokenMethod.finally(() =&gt; {
                this.isRefreshingToken = false;
            }).subscribe() {
                this.isRefreshingToken = true;
            }
        }
    }
    ngOnDestroy() {
        if (this.interval) {
            clearInterval(this.interval);
        }

    }
}
</code></pre>

<p>This is working fine but I think Observables are a better tool to achieve the same. so tried this way</p>

<pre><code>export class AdminLayoutComponent implements OnInit {

    timer$: Observable&lt;any&gt;;
    subscription: Subscription;

    constructor() {
        this.timer$ = Observable.timer(0, this.period);
    }

    ngOnInit() {
        this.subscription = this.timer$.subscribe((i) =&gt; {
            console.log('timer: ', i);
            this.checkSession();
        });
    }

    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
</code></pre>

<p>Now problem is that when the user clicks on renew icon; I want to reset the timer again to check the timing.</p>

<p>How can I do this? or is it okay to run timer?</p>
","155861","","155861","","2018-08-24 03:46:40","2018-08-24 03:46:40","Reset the Observable Timer on user action?","<angular><observable><rxjs5>","1","0","1","","","CC BY-SA 4.0"
"51982276","2","","51979619","2018-08-23 09:16:25","","3","","<p>You need to use Subject Observable. Reset the timer using next().</p>

<pre><code>export class AdminLayoutComponent implements OnInit {

    private reset$ = new Subject();
    timer$: Observable&lt;any&gt;;
    subscription: Subscription;

    constructor() {
        this.timer$ = this.reset$.pipe(
          startWith(0),
          switchMap(() =&gt; timer(0, 30000))
        );
    }

    ngOnInit() {
        this.subscription = this.timer$.subscribe((i) =&gt; {
            console.log('timer: ', i);
            this.checkSession();
        });
    }

   refreshTimer(): void {
      this.reset$.next(void 0);
    }

    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
</code></pre>

<p>Also updated stackblitz code <a href=""https://stackblitz.com/edit/angular-pnwh44"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-pnwh44</a></p>
","10154951","","10154951","","2018-08-23 09:26:36","2018-08-23 09:26:36","","","","6","","","","CC BY-SA 4.0"
"52018881","1","52019214","","2018-08-25 15:50:14","","26","19312","<p><strong>Use case:</strong> Call a function every minute (60000 ms) that dispatches store action to fetch <code>lastUpdated</code> status of items, which upon response and filtering, updates the store, and updated store is read as an observable and displayed in the view). This needs to happen for as long as the web app is open (so indefinitely).</p>

<p>Currently, I'm using this:</p>

<pre><code>this.refreshDate = window.setInterval(
  () =&gt; this.store.dispatch(new FetchLastUpdate())
, 60000);
</code></pre>

<p>And when view is destroyed/dismounted, I delete the interval as so:</p>

<pre><code>if (this.refreshDate) {
  clearInterval(this.refreshDate);
}
</code></pre>

<p>Is this efficient/effective, or is it troublesome?</p>

<p>Why would I want to use an RxJS polling strategy like:</p>

<pre><code>interval(60000)
  .pipe(
    startWith(0),
    switchMap(() =&gt; this.store.dispatch(new FetchLastUpdate()))
   );
</code></pre>

<p>Or</p>

<pre><code>timer(0, 60000)
  .pipe(
    switchMap(() =&gt; this.store.dispatch(new FetchLastUpdate()))
  );
</code></pre>

<hr>

<p><strong>TL;DR:</strong> <code>window.setInterval()</code> vs. RxJS <code>timer()</code>/<code>interval()</code></p>

<hr>

<h2><strong>Conclusion/answers (for ease of research):</strong></h2>

<p>There is great benefit to using RxJS functions to set an interval or perform polling, these benefits are explained in the <a href=""https://stackoverflow.com/a/52019030/5872268""><em>selected answer</em></a> but also in comments, but it is concluded (by discussions in the comments) that for the very simple requirement defined in the ""<strong>Use case</strong>"" section at the beginning of this post, it is unnecessary to use RxJS, and in fact if you are not using RxJS in any other part of your program, do not import it just for this, however in my case, I had already imported and used RxJS elsewhere.</p>
","5872268","","5872268","","2018-08-26 10:34:07","2021-01-26 19:32:47","Why would I use RxJS interval() or timer() polling instead of window.setInterval()?","<javascript><typescript><rxjs><rxjs5><rxjs6>","2","4","7","","","CC BY-SA 4.0"
"52019214","2","","52018881","2018-08-25 16:30:29","","30","","<p>Advantage of RxJS:</p>

<p><strong>Laziness</strong></p>

<p>You can create your Observables and until you call <code>subscribe</code> nothing is happening. Observable = pure function. This gives you more control, easier reasoning and allows for next point...</p>

<p><strong>Composability</strong></p>

<p>You can combine <code>interval/timer</code> with other <code>operators</code> creating custom logic very easily in unified way - for example you can <code>map</code>, <code>repeat</code>, <code>retry</code>, <code>take</code>... etc. <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html"" rel=""noreferrer"">see all operators</a></p>

<p><strong>Error Handling</strong></p>

<p>In case of an error you are responsible for calling <code>clearTimeout/clearInterval</code> - Observables are handling this for you. Resulting in <strong>cleaner code</strong> and <strong>fewer memory leak</strong> bugs.</p>

<p>Of course anything you do with Observables you can also do without Observables - but that's not the point. Observables are here to make your life easier.</p>

<hr>

<p>Also note that <code>interval/timer</code> are not good observable factories for polling because they do not ""wait"" for your async action to finish (you can end up with multiple async calls running over each other). For that I tend to use <code>defer</code> and <code>repeatWhen</code> like this:</p>

<pre><code>defer(() =&gt; doAsyncAction())
  .pipe(
    repeatWhen(notifications =&gt; notifications.pipe(delay(1234)))
  );
</code></pre>
","3024975","","3024975","","2018-08-25 16:40:06","2018-08-25 16:40:06","","","","5","","","","CC BY-SA 4.0"
"52157219","1","52157440","","2018-09-03 23:56:55","","0","65","<p>Is it correct way to use <code>flatMap</code>?</p>

<pre><code>const observer = Observable
    .interval(3000)
    .takeUntil(Observable.timer(10000))
    .flatMap(this.askToReadyRecordVideo);

private askToReadyRecordVideo(): Observable&lt;any&gt; {
    return this.requestMethods.askToReadyRecordVideo({});
}
</code></pre>

<p>In this line I tied to send request to server each 3 seconds until 10 seconds then call method <code>this.askToReadyRecordVideo()</code> that returns data from server.</p>

<p>I finish this when I get successfull response. Is it true?</p>
","8291684","","2829204","","2018-09-04 02:45:43","2018-09-04 02:45:43","Correct way to use FlatMap in Rx?","<angular><rxjs><rxjs5>","1","5","1","","","CC BY-SA 4.0"
"52157440","2","","52157219","2018-09-04 00:40:55","","1","","<p>I'm not sure whether I understand you correctly, but your code does the following:
The method <code>askToReadyRecordVideo</code> will get called every 3 seconds until 10 seconds are over (there will be three calls, at 3s, 6s and 9s).
Your observable <code>observer</code> will emit the results of those server calls.</p>

<p>If you want to cancel the process after your first successful response add the following:</p>

<pre><code>.filter(resp =&gt; /* return true when resp indicates success */)
.take(1)
</code></pre>

<p>If every answer is a success (i.e. errors are indicated by an error event pushed through the observable), then just omit the <code>filter</code> line.</p>

<p>By the way: Be careful when passing callbacks to avoid surprises about what <code>this</code> means in <code>askToReadyRecordVideos</code>. You may use <code>flatMap(() =&gt; this.askToReadyRecordVideo())</code> or <code>flatMap(this.askToReadyRecordVideo.bind(this))</code> instead of <code>flatMap(this.askToReadyRecordVideo)</code>.</p>
","10245948","","","","","2018-09-04 00:40:55","","","","5","","","","CC BY-SA 4.0"
"52232088","1","52233139","","2018-09-08 04:44:01","","0","53","<p>I'm using RxJS v6, but this question applies to v5 as well.</p>

<p>When using <code>mergeMap</code>, my original array disappears and while I can do a number of operations in parallel, I no longer have a way of monitoring when all those observables I sent into <code>mergeMap</code> are complete.</p>

<h1>Example</h1>

<pre class=""lang-js prettyprint-override""><code>of([1, 2, 3, 4])
.pipe(
    mergeMap(values =&gt; values),
)
.subscribe(console.log)

// 1
// 2
// 3
// 4
</code></pre>

<p>I'd like to see:</p>

<pre class=""lang-js prettyprint-override""><code>// [1, 2, 3, 4]
</code></pre>

<p>The only way I've come up with so far requires getting the length of the array, but I'm sure there's gotta be some operator I'm missing:</p>

<pre class=""lang-js prettyprint-override""><code>of([1, 2, 3, 4])
.pipe(
    switchMap(values =&gt; (
        of(values)
        .pipe(
            mergeMap(value =&gt; value),
            bufferCount(values.length),
        )
    ))
)
.subscribe(console.log)
</code></pre>
","1624862","","","","","2018-09-08 07:41:02","Combine a fixed number of mergeMapped observables - RxJS","<rxjs><observable><rxjs5><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52232956","1","52233373","","2018-09-08 07:17:11","","1","48","<blockquote>
  <p>I'm using RxJS v6, but the answer could apply to RxJS v5 as well.</p>
</blockquote>

<p>I'd like to make it so if I have say 8 values, I would only have 4 actively being processed at a time.</p>

<p>The code I have right now sends in 4 items, then waits till all 4 finish, then sends in the next 4. I'd like it to send in the first 4, then as an observable completes, another one comes in to be processed.</p>

<pre class=""lang-js prettyprint-override""><code>from([1, 2, 3, 4, 5, 6, 7, 8])
.pipe(
    bufferCount(4),
    concatMap(values =&gt; (
        from(values)
        .pipe(
            mergeMap(value =&gt; (
                timer(1000) // Async stuff would happen here
                .pipe(
                    mapTo(value),
                )
            )),
        )
    )),
)
.subscribe(console.log)
</code></pre>
","1624862","","","","","2018-09-08 08:13:09","How can I have only X observables active at a time?","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52233139","2","","52232088","2018-09-08 07:41:02","","1","","<blockquote>
  <p>When using mergeMap, my original array disappears</p>
</blockquote>

<p>The reason is that <code>mergeMap</code> accepts an <code>ObservableInput</code> as parameter of the function you pass in. A javascript <code>Array</code> is an <code>ObservableInput</code> and therefore works in <code>mergeMap</code> and <code>mergeMap</code> does its job, which is to <em>flatten</em> the <code>ObservableInput</code> (consider that <code>mergeMap</code> was previously called <code>flatMap</code>).</p>

<p>So, as @cartant says, if you want to get back to an array, you have to use <code>toArray</code> operator.
In other words</p>

<pre><code>of([1, 2, 3, 4])
.pipe(
    mergeMap(value =&gt; { // do stuff with a value of an array}),
    toArray()
)
.subscribe(console.log)
</code></pre>

<p>is equivalent to </p>

<pre><code>of([1, 2, 3, 4])
.pipe(
    map(values =&gt; values.map(value =&gt; { // do stuff with a value of an array})),
)
</code></pre>

<p>If your array though contains Observables and you want to eventually get the values they notify when all of them emit, than you have to use <code>forkJoin</code>. This is a simple example</p>

<pre><code>of([1, 2, 3, 4].map(n =&gt; of(n)))
.pipe(
    switchMap(observablesOfValues =&gt; forkJoin(observablesOfValues))
)
.subscribe(console.log)
</code></pre>
","5699993","","","","","2018-09-08 07:41:02","","","","1","","","","CC BY-SA 4.0"
"52233373","2","","52232956","2018-09-08 08:13:09","","3","","<p>You have to use the second parameter of <code>mergeMap</code>, which is a number that allows to specify the <em>concurrency</em> <em>level</em> you want.</p>

<p>So your code could look like</p>

<pre><code>from([1, 2, 3, 4, 5, 6, 7, 8])
.pipe(
    map(val =&gt; of(val)),
    mergeMap(val =&gt; val, 4),
)
.subscribe(console.log)
</code></pre>

<p>or</p>

<pre><code>of([1, 2, 3, 4, 5, 6, 7, 8])
.pipe(
    mergeMap(val =&gt; val, 4),
)
.subscribe(console.log)
</code></pre>

<p>Consider that <code>concatMap</code> is <code>mergeMap</code> with concurrency level set to 1.</p>

<p>Read <a href=""https://stackoverflow.com/questions/42120680/how-does-rxjs-mergemap-work/42122031"">this SO post</a> for more details on <code>mergeMap</code>.</p>
","5699993","","","","","2018-09-08 08:13:09","","","","1","","","","CC BY-SA 4.0"
"52301297","1","52302880","","2018-09-12 18:19:52","","3","311","<p>When multiple observers subscribe to an RXJS Subject, is it possible to stop an error from one observer propagating and stopping the other observers (registered later) from seeing the event</p>

<p>Stackblitz Example: <a href=""https://stackblitz.com/edit/rxjs-cy7swm"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-cy7swm</a></p>

<pre><code>const sub = new Subject&lt;string&gt;();

sub.asObservable().subscribe((val) =&gt; {
  console.log('1st sees: ' + val);
});

sub.asObservable().subscribe((val) =&gt; {
  console.log('2nd sees: ' + val);
  throw new Error('2nd throws error');
});

sub.asObservable().subscribe((val) =&gt; {
  console.log('3rd sees: ' + val);
});

sub.next('test');
sub.next('test2');
</code></pre>

<p>Here the 3rd observer doesn't see the event as the 2nd throws an exception, and the test2 value isn't seen by anything as the first error effectively shuts the subject down</p>

<pre><code>1st sees: test
2nd sees: test
ERROR Error: 2nd throws error
</code></pre>

<p><strong>Without obviously wrapping</strong> each subscribe block in a try catch, is there a better RXJS framework way of making sure that the 3rd observer still sees the value and the second call to sub.next() is observed too?</p>

<h2>Update (as per cartant's answer):</h2>

<p>This is better handled in rxjs6 - see updated Stackblitz with the same code, but without the side effects: <a href=""https://stackblitz.com/edit/rxjs6-subject-err"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs6-subject-err</a></p>
","1279787","","1033581","","2018-10-15 01:09:17","2018-10-15 01:09:17","RXJS Subject - stopping errors from propagating","<typescript><rxjs><rxjs5>","1","4","","","","CC BY-SA 4.0"
"52302880","2","","52301297","2018-09-12 20:20:13","","3","","<p>This is a known problem with RxJS v5 and it's something that's been addressed in v6 - in which the <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md#synchronous-error-handling"" rel=""nofollow noreferrer"">synchronous error handling has been changed</a>.</p>

<p>In v6, what you are seeing will no longer happen. Instead, errors thrown from within 'listeners' will be rethrown asynchronously and will be seen by the application as unhandled errors.</p>

<p>For more information, see <a href=""https://youtu.be/JCXZhe6KsxQ?t=489"" rel=""nofollow noreferrer"">this video</a>.</p>
","6680611","","","","","2018-09-12 20:20:13","","","","4","","","","CC BY-SA 4.0"
"52317601","1","","","2018-09-13 16:01:46","","0","2698","<p><strong>Question 1</strong></p>

<pre><code> combineLatest(this.layerService.layersData$, this.displayService.displayData$, this.dataSource.data$,
      (layer, display, data) =&gt; ({ layer, display, data }))
      .pipe(
        skipWhile(({ layer, display, data }) =&gt;
          _.isEmpty(layer) || _.isEmpty(display) || _.isEmpty(data)),
        takeWhile(() =&gt; this.cacheService.isDirty()),
        sample(interval(2000)),
        map(result =&gt; {
          const layerFiltered = result.layer.filter(ly =&gt; result.display.findIndex(d =&gt; d.id === ly.id) !== -1);
          return { ...result, layer: layerFiltered };
        })
  )
  .subscribe(result =&gt; {
    console.log(result);
  });
</code></pre>

<p>I want to avoid sampling on very first emit and use the sampling after that.</p>

<p>By very first emit i mean, it was to able to get to the map function. 
Can it achieved without using external local variable?</p>

<hr>

<p><strong>Question 2</strong></p>

<pre><code>ngOnInit() {
   this.displayService.displayData$.delay(500).take(1).subscribe(data =&gt;  this.displayMeta = data);

   this.layerService.getLayerData()
     .subscribe(layers =&gt; {
       this.layers = layers;
     });
}
</code></pre>

<p>I want layerService subscribe to wait till displayService completes, I can put the layerService subscribe logic inside displayService subscribe method, but that doesn't seem nice solution to the problem.</p>

<p>I want <strong>this.displayService.......</strong> code to be synchronous. 
I this also required once, not the take(1) operator.</p>

<hr>

<p><strong>Question 3</strong></p>

<pre><code>dirty = {};
fetchedData = {};
reportData$ = new BehaviorSubject({});

constructor(private dataSourceService: DataSourceService, private someService: SomeService) {
  const dataFetch$ = this.dataSourceService.data$
    .pipe(
      tap(dList =&gt; {
        // update dirty by comparing dList, if this.dirty has 3 keys and dList have two item then this.dirty length will be two
        this.dirty = dList.reduce((acc, et) =&gt; ({ ...acc, [et.id]: _.get(this.dirty, et.id, true) }), {});
      }),
      filter(dList =&gt; !_.isEmpty(dList)),
      map(dList =&gt; _.filter(dList, dL =&gt; this.dataSourceService.dirty[dL.id])),
      concatMap(dList =&gt; from(dList)),
      flatMap(dItem =&gt; this.someService.getDataFromApi(dItem), (item, data) =&gt; {
        return { id: item.id, data };
      }),
      tap(({ id, data }) =&gt; {
        this.fetchedData[id] = data;
        this.dirty[id] = false;
        this.dataSourceService.resetDirty(id);
      })
    );

  dataFetch$.merge(this.dataSourceService.data$)
    .subscribe(() =&gt; {
      this.fetchedData = _.pickBy(this.fetchedData, (__, key) =&gt; _.has(this.dirty, key));
      this.reportData$.next(this.fetchedData);
    });
}
</code></pre>

<p>The subscribe method should be called even if the filter return false. 
The problem with above approach is that subscribe will be called twice.</p>

<p>If dList is empty, dataFetch$ is not called, so the subscribe is called once but if its not empty then subscribe is called twice.</p>

<hr>

<p>The design is if item are removed from this.dataSourceService.data$  one by one and finally this.dataSourceService.data$.length becomes 0, observable chain would not reach subscribe, in that case also make this.fetchedData = empty </p>

<p>As item from dataSourceService.data$ is removed corresponding item from this.fetchedData should be remove, I don't know which item is removed, thats why dirty flag, notice the first tap operation.
In the subscribe the dirtyList is used to update the fetchedData.</p>
","4404499","","4404499","","2018-09-21 04:47:43","2018-09-21 04:47:43","RxJs Skip Sample on first Emit, wait for one Observable to complete","<angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"52345083","1","52346301","","2018-09-15 13:21:17","","1","2099","<p>Have a piece of code like this:</p>

<pre><code>const hoverQueue$ = new Rx.Subject()
    .debounceTime(1000)
    .subscribe(() =&gt; {
        console.log('subject')
});

const callback = () =&gt; {
    hoverQueue$.next(true)
}
</code></pre>

<p>Which doesn't seem to work. Instead of having my events being delayed by 1s and getting only the last value emitted, they all pass through as if debounceTime doesn't exist. the same behaviour happens with delay, doesn't seem to work.
Seems to work as intended on observables. 
callback is a callback called by another library i am using.</p>

<p>Not sure if i have missed something or if im doing something that's not supposed to be done, cant find much about this online.</p>

<p>have a fiddle below with an example to demonstrate</p>

<p>here is a fiddle with rxjs 5.4.1 which is what im running
<a href=""https://jsfiddle.net/theya222/2nhu1ka7/"" rel=""nofollow noreferrer"">https://jsfiddle.net/theya222/2nhu1ka7/</a></p>

<p>and here is one with the latest version of rxjs
<a href=""https://jsfiddle.net/theya222/j1uLw80d/"" rel=""nofollow noreferrer"">https://jsfiddle.net/theya222/j1uLw80d/</a></p>

<p>thanks</p>
","6345432","","","","","2018-09-16 07:13:36","rxjs debounceTime on Subject","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"52346301","2","","52345083","2018-09-15 15:49:42","","3","","<p><code>hoverQueue$</code> is the result of executing <code>subscribe</code> on an Observable. Therefore <code>hoverQueue$</code> is a <code>Subcription</code> not an Observable and a <code>Subscription</code> does not have the method <code>next</code>.</p>

<p>What you have to do is this</p>

<pre><code>const subj = new Rx.Subject();
const hoverQueue$ = subj.debounceTime(1000);

hoverQueue$.subscribe(() =&gt; {
        console.log('subject')
});

const callback = () =&gt; {
    subj.next(true)
}
</code></pre>

<p>if callback is a </p>

<blockquote>
  <p>callback called by another library</p>
</blockquote>

<p>take
a look at <code>bindCallback</code> method/function defined with Observable.</p>
","5699993","","5699993","","2018-09-16 07:13:36","2018-09-16 07:13:36","","","","2","","","","CC BY-SA 4.0"
"52372807","1","52427602","","2018-09-17 17:17:28","","5","465","<p>Example code, using Angular 4.1.3, rxjs 5.3.0, typescript 2.2.2:</p>

<pre><code>import { Subject } from 'rxjs'

export class Example {
  public response$: Subject&lt;boolean&gt;;

  public confirm(prompt: string): Subject&lt;boolean&gt; {
    // ...set up a confirmation dialog...
    this.response$ = new Subject&lt;boolean&gt;();
    return this.response$.first();
  }
}
</code></pre>

<p>When I try to compile this code, typescript complains about the last line:</p>

<pre><code>The 'this' context of type 'Subject&lt;boolean&gt;' is not assignable to method's 'this' of type 'Observable&lt;boolean&gt;'.
  Types of property 'lift' are incompatible.
    Type '&lt;R&gt;(operator: Operator&lt;boolean, R&gt;) =&gt; Observable&lt;boolean&gt;' is not assignable to type '&lt;R&gt;(operator: Operator&lt;boolean, R&gt;) =&gt; Observable&lt;R&gt;'.
  Type 'Observable&lt;boolean&gt;' is not assignable to type 'Observable&lt;R&gt;'.
    Type 'boolean' is not assignable to type 'R'.
</code></pre>

<p>My sense is that this is saying that <code>first()</code> is a method of Observable, not Subject, but my understanding is that a Subject is also an Observable, so this should not be a problem. And, in fact, if I ignore the error the code compiles and runs fine.</p>

<p>Things I have tried:</p>

<ol>
<li>Various ways of importing the <code>first</code> operator explicitly, e.g. <code>import 'rxjs/add/operator/first'</code>. This does not change the error.</li>
<li>Casting the Subject to an Observable before calling <code>first()</code>, e.g. <code>return (this.response$ as Observable&lt;boolean&gt;).first();</code>. This results in a different but similar error, which also seems incorrect to me: <code>Type 'Observable&lt;boolean&gt;' is not assignable to type 'Subject&lt;boolean&gt;'. Property 'observers' is missing in type 'Observable&lt;boolean&gt;'.</code></li>
</ol>

<p>How can I convince typescript that it is valid to call <code>first()</code> on a Subject?</p>

<p>To clarify in response to the discussion of return types below: the method may also have had an incorrect return type (should be Observable rather than Subject) but that appears to be a separate issue; changing the return type does not resolve the error described above. A further detail confirming this is that when vscode highlights the error, it only highlights <code>this.response$</code>, not the entire return line, suggesting that the problem is between <code>this.response$</code> and <code>first()</code>, not between <code>first()</code> and the function's signature:</p>

<p><a href=""https://i.stack.imgur.com/Ikwht.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ikwht.png"" alt=""error highlighted in vscode""></a></p>
","2442167","","2442167","","2018-09-18 18:35:49","2018-09-20 15:27:52","How can I convince typescript that it's ok to call Observable operators on a Subject?","<angular><typescript><rxjs><rxjs5>","2","6","","","","CC BY-SA 4.0"
"52383807","1","52386217","","2018-09-18 09:51:38","","0","277","<p>I have json deployed in server like this as below:</p>

<pre><code>{
  ""data"": [
    {
      ""id"": 1,
      ""name"": ""Angular Connect"",
      ""date"": ""2036-09-25T23:00:00.000Z"",
      ""time"": ""10:00 am"",
      ""price"": 599.99,
      ""imageUrl"": ""/assets/images/angularconnect-shield.png"",
      ""location"": {
        ""address"": ""1057 DT"",
        ""city"": ""London"",
        ""country"": ""England""
      },
      ""sessions"": [
        {
          ""id"": 1,
          ""name"": ""Using Angular 4 Pipes"",
          ""presenter"": ""Peter Bacon Darwin"",
          ""duration"": 1,
          ""level"": ""Intermediate"",
          ""abstract"": ""Learn all about the new pipes in Angular 4, both \n        how to write them, and how to get the new AI CLI to write \n        them for you. Given by the famous PBD, president of Angular \n        University (formerly Oxford University)"",
          ""voters"": [
            ""bradgreen"",
            ""igorminar"",
            ""martinfowler""
          ]
        },
        {
          ""id"": 2,
          ""name"": ""Getting the most out of your dev team"",
          ""presenter"": ""Jeff Cross"",
          ""duration"": 1,
          ""level"": ""Intermediate"",
          ""abstract"": ""We all know that our dev teams work hard, but with \n        the right management they can be even more productive, without \n        overworking them. In this session I'll show you how to get the \n        best results from the talent you already have on staff."",
          ""voters"": [
            ""johnpapa"",
            ""bradgreen"",
            ""igorminar"",
            ""martinfowler""
          ]
        },
        {
          ""id"": 3,
          ""name"": ""Angular 4 Performance Metrics"",
          ""presenter"": ""Rob Wormald"",
          ""duration"": 2,
          ""level"": ""Advanced"",
          ""abstract"": ""Angular 4 Performance is hot. In this session, we'll see \n        how Angular gets such great performance by preloading data on \n        your users devices before they even hit your site using the \n        new predictive algorithms and thought reading software \n        built into Angular 4."",
          ""voters"": []
        },
        {
          ""id"": 4,
          ""name"": ""Angular 5 Look Ahead"",
          ""presenter"": ""Brad Green"",
          ""duration"": 2,
          ""level"": ""Advanced"",
          ""abstract"": ""Even though Angular 5 is still 6 years away, we all want \n        to know all about it so that we can spend endless hours in meetings \n        debating if we should use Angular 4 or not. This talk will look at \n        Angular 6 even though no code has yet been written for it. We'll \n        look at what it might do, and how to convince your manager to \n        hold off on any new apps until it's released"",
          ""voters"": []
        },
        {
          ""id"": 5,
          ""name"": ""Basics of Angular 4"",
          ""presenter"": ""John Papa"",
          ""duration"": 2,
          ""level"": ""Beginner"",
          ""abstract"": ""It's time to learn the basics of Angular 4. This talk \n        will give you everything you need to know about Angular 4 to \n        get started with it today and be building UI's for your self \n        driving cars and butler-bots in no time."",
          ""voters"": [
            ""bradgreen"",
            ""igorminar""
          ]
        }
      ]
    },
    {
      ""id"": 2,
      ""name"": ""ng-nl"",
      ""date"": ""2037-04-14T23:00:00.000Z"",
      ""time"": ""9:00 am"",
      ""price"": 950,
      ""imageUrl"": ""/assets/images/ng-nl.png"",
      ""onlineUrl"": ""http://ng-nl.org/"",
      ""sessions"": [
        {
          ""id"": 1,
          ""name"": ""Testing Angular 4 Workshop"",
          ""presenter"": ""Pascal Precht &amp; Christoph Bergdorf"",
          ""duration"": 4,
          ""level"": ""Beginner"",
          ""abstract"": ""In this 6 hour workshop you will learn not only how to test Angular 4, \n        you will also learn how to make the most of your team's efforts. Other topics\n        will be convincing your manager that testing is a good idea, and using the new\n        protractor tool for end to end testing."",
          ""voters"": [
            ""bradgreen"",
            ""igorminar""
          ]
        },
        {
          ""id"": 2,
          ""name"": ""Angular 4 and Firebase"",
          ""presenter"": ""David East"",
          ""duration"": 3,
          ""level"": ""Intermediate"",
          ""abstract"": ""In this workshop, David East will show you how to use Angular with the new\n        ultra-real-time 5D Firebase back end, hosting platform, and wine recommendation engine."",
          ""voters"": [
            ""bradgreen"",
            ""igorminar"",
            ""johnpapa""
          ]
        },
        {
          ""id"": 3,
          ""name"": ""Reading the Angular 4 Source"",
          ""presenter"": ""Patrick Stapleton"",
          ""duration"": 2,
          ""level"": ""Intermediate"",
          ""abstract"": ""Angular 4's source code may be over 25 million lines of code, but it's really \n        a lot easier to read and understand then you may think. Patrick Stapleton will talk\n        about his secretes for keeping up with the changes, and navigating around the code."",
          ""voters"": [
            ""martinfowler""
          ]
        },
        {
          ""id"": 4,
          ""name"": ""Hail to the Lukas"",
          ""presenter"": ""Lukas Ruebbelke"",
          ""duration"": 1,
          ""level"": ""Beginner"",
          ""abstract"": ""In this session, Lukas will present the \n        secret to being awesome, and how he became the President \n        of the United States through his amazing programming skills, \n        showing how you too can be success with just attitude."",
          ""voters"": [
            ""bradgreen""
          ]
        }
      ]
    },
    {
      ""id"": 3,
      ""name"": ""ng-conf 2037"",
      ""date"": ""2037-05-03T23:00:00.000Z"",
      ""time"": ""9:00 am"",
      ""price"": 759,
      ""imageUrl"": ""/assets/images/ng-conf.png"",
      ""location"": {
        ""address"": ""The Palatial America Hotel"",
        ""city"": ""Salt Lake City"",
        ""country"": ""USA""
      },
      ""sessions"": [
        {
          ""id"": 1,
          ""name"": ""How Elm Powers Angular 4"",
          ""presenter"": ""Murphy Randle"",
          ""duration"": 2,
          ""level"": ""Intermediate"",
          ""abstract"": ""We all know that Angular is written in Elm, but did you\n        know how the source code is really written? In this exciting look\n        into the internals of Angular 4, we'll see exactly how Elm powers\n        the framework, and what you can do to take advantage of this knowledge."",
          ""voters"": [
            ""bradgreen"",
            ""martinfowler"",
            ""igorminar""
          ]
        },
        {
          ""id"": 2,
          ""name"": ""Angular and React together"",
          ""presenter"": ""Jamison Dance"",
          ""duration"": 2,
          ""level"": ""Intermediate"",
          ""abstract"": ""React v449.6 has just been released. Let's see how to use \n        this new version with Angular to create even more impressive applications."",
          ""voters"": [
            ""bradgreen"",
            ""martinfowler""
          ]
        },
        {
          ""id"": 3,
          ""name"": ""Redux Woes"",
          ""presenter"": ""Rob Wormald"",
          ""duration"": 1,
          ""level"": ""Intermediate"",
          ""abstract"": ""Everyone is using Redux for everything from Angular to React to \n        Excel macros, but you're still having trouble grasping it? We'll take a look\n        at how farmers use Redux when harvesting grain as a great introduction to \n        this game changing technology."",
          ""voters"": [
            ""bradgreen"",
            ""martinfowler"",
            ""johnpapa""
          ]
        },
        {
          ""id"": 4,
          ""name"": ""ng-wat again!!"",
          ""presenter"": ""Shai Reznik"",
          ""duration"": 1,
          ""level"": ""Beginner"",
          ""abstract"": ""Let's take a look at some of the stranger pieces of Angular 4,\n        including neural net nets, Android in Androids, and using pipes with actual pipes."",
          ""voters"": [
            ""bradgreen"",
            ""martinfowler"",
            ""igorminar"",
            ""johnpapa""
          ]
        },
        {
          ""id"": 5,
          ""name"": ""Dressed for Success"",
          ""presenter"": ""Ward Bell"",
          ""duration"": 2,
          ""level"": ""Beginner"",
          ""abstract"": ""Being a developer in 2037 is about more than just writing bug-free code. \n        You also have to look the part. In this amazing expose, Ward will talk you through\n        how to pick out the right clothes to make your coworkers and boss not only\n        respect you, but also want to be your buddy."",
          ""voters"": [
            ""bradgreen"",
            ""martinfowler""
          ]
        },
        {
          ""id"": 6,
          ""name"": ""These aren't the directives you're looking for"",
          ""presenter"": ""John Papa"",
          ""duration"": 2,
          ""level"": ""Intermediate"",
          ""abstract"": ""Coinciding with the release of Star Wars Episode 18, this talk will show how\n        to use directives in your Angular 4 development while drawing lessons from the new movie,\n        featuring all your favorite characters like Han Solo's ghost and Darth Jar Jar."",
          ""voters"": [
            ""bradgreen"",
            ""martinfowler""
          ]
        }
      ]
    },
    {
      ""id"": 4,
      ""name"": ""UN Angular Summit"",
      ""date"": ""2037-06-09T23:00:00.000Z"",
      ""time"": ""8:00 am"",
      ""price"": 800,
      ""imageUrl"": ""/assets/images/basic-shield.png"",
      ""location"": {
        ""address"": ""The UN Angular Center"",
        ""city"": ""New York"",
        ""country"": ""USA""
      },
      ""sessions"": [
        {
          ""id"": 1,
          ""name"": ""Diversity in Tech"",
          ""presenter"": ""Sir Dave Smith"",
          ""duration"": 2,
          ""level"": ""Beginner"",
          ""abstract"": ""Yes, we all work with cyborgs and androids and Martians, but \n        we probably don't realize that sometimes our internal biases can make it difficult for\n        these well-designed coworkers to really feel at home coding alongside us. This talk will\n        look at things we can do to recognize our biases and counteract them."",
          ""voters"": [
            ""bradgreen"",
            ""igorminar""
          ]
        },
        {
          ""id"": 2,
          ""name"": ""World Peace and Angular"",
          ""presenter"": ""US Secretary of State Zach Galifianakis"",
          ""duration"": 2,
          ""level"": ""Beginner"",
          ""abstract"": ""Angular has been used in most of the major peace brokering that has\n        happened in the last decade, but there is still much we can do to remove all\n        war from the world, and Angular will be a key part of that effort."",
          ""voters"": [
            ""bradgreen"",
            ""igorminar"",
            ""johnpapa""
          ]
        },
        {
          ""id"": 3,
          ""name"": ""Using Angular with Androids"",
          ""presenter"": ""Dan Wahlin"",
          ""duration"": 3,
          ""level"": ""Advanced"",
          ""abstract"": ""Androids may do everything for us now, allowing us to spend all day playing \n        the latest Destiny DLC, but we can still improve the massages they give and the handmade\n        brie they make using Angular 4. This session will show you how."",
          ""voters"": [
            ""igorminar"",
            ""johnpapa""
          ]
        }
      ]
    },
    {
      ""id"": 5,
      ""name"": ""ng-vegas"",
      ""date"": ""2037-02-10T00:00:00.000Z"",
      ""time"": ""9:00 am"",
      ""price"": 400,
      ""imageUrl"": ""/assets/images/ng-vegas.png"",
      ""location"": {
        ""address"": ""The Excalibur"",
        ""city"": ""Las Vegas"",
        ""country"": ""USA""
      },
      ""sessions"": [
        {
          ""id"": 1,
          ""name"": ""Gambling with Angular"",
          ""presenter"": ""John Papa"",
          ""duration"": 1,
          ""level"": ""Intermediate"",
          ""abstract"": ""No, this talk isn't about slot machines. We all know that \n        Angular is used in most waiter-bots and coke vending machines, but\n        did you know that was also used to write the core engine in the majority\n        of voting machines? This talk will look at how all presidential elections\n        are now determined by Angular code."",
          ""voters"": [
            ""bradgreen"",
            ""igorminar""
          ]
        },
        {
          ""id"": 2,
          ""name"": ""Angular 4 in 60ish Minutes"",
          ""presenter"": ""Dan Wahlin"",
          ""duration"": 2,
          ""level"": ""Beginner"",
          ""abstract"": ""Get the skinny on Angular 4 for anyone new to this great new technology.\n        Dan Wahlin will show you how you can get started with Angular in 60ish minutes, \n        guaranteed!"",
          ""voters"": [
            ""bradgreen"",
            ""igorminar"",
            ""johnpapa""
          ]
        }
      ]
    },
    {
      ""name"": ""ng Spectacular"",
      ""date"": ""12/10/2017"",
      ""time"": ""10:00 am"",
      ""price"": 1200,
      ""location"": {
        ""address"": ""102, rue ibn tachfine"",
        ""city"": ""Casablanca"",
        ""country"": ""Morocco""
      },
      ""onlineUrl"": null,
      ""imageUrl"": ""https://i.imgflip.com/yhzjy.jpg"",
      ""id"": 6
    }
  ]
}
</code></pre>

<p>Also, i created two models interfaces that represents the above json:</p>

<pre><code>export interface IEvent{
    id:number
    name:string
    date:Date
    time:string
    price:number
    imageUrl:string
    location?:{
        address:string
        city:string
        country:string
    },
    onlineUrl?:string,
    sessions:ISession[]
}

export interface ISession{
    id:number
    name:string
    presenter:string
    duration:number
    level:string
    abstract:string
    voters:string[]
}
</code></pre>

<p>(ISession represents the json whose key equals to ""sessions"", note that the last json is nested in the parent json whose model is IEvent).</p>

<p>And I want search sessions by keyword:then i find this track by searching events that correponds to desired session, for instance when i type this url:
<strong><em><a href=""http://localhost:3000/data?q=pipe"" rel=""nofollow noreferrer"">http://localhost:3000/data?q=pipe</a></em></strong> It returns all events that contains the keyword ""pipe"".On the other hand i want just sessions not all events that matches the keyword. For example i want that returned json will be like below:</p>

<pre><code>{
        ""id"": 1,
        ""name"": ""Using Angular 4 Pipes"",
        ""presenter"": ""Peter Bacon Darwin"",
        ""duration"": 1,
        ""level"": ""Intermediate"",
        ""abstract"": ""Learn all about the new pipes in Angular 4, both \n        how to write them, and how to get the new AI CLI to write \n        them for you. Given by the famous PBD, president of Angular \n        University (formerly Oxford University)"",
        ""voters"": [
          ""bradgreen"",
          ""igorminar"",
          ""martinfowler""
        ]
      },
{
        ""id"": 4,
        ""name"": ""ng-wat again!!"",
        ""presenter"": ""Shai Reznik"",
        ""duration"": 1,
        ""level"": ""Beginner"",
        ""abstract"": ""Let's take a look at some of the stranger pieces of Angular 4,\n including neural net nets, Android in Androids, and using pipes with actual pipes."",
        ""voters"": [
          ""bradgreen"",
          ""martinfowler"",
          ""igorminar"",
          ""johnpapa""
        ]
      }
</code></pre>

<p>Finally, i want consume the result of url by using rxjs like below:</p>

<pre><code>  searchSession(sessionKeyWord: string):Observable&lt;ISession[]&gt; {
    return this.http.get(this.url + '?q=' + sessionKeyWord).pipe(map(response =&gt; {
      return response.json();
      }), catchError((e: Response) =&gt; {return e.statusText}))
  }
</code></pre>

<p>But the result is events and not sessions. So I want just sessions that matches the keyword like the above returned json.</p>

<p>Please any help is very appreciated. Thanks in advance for your reply.</p>
","8384029","","","","","2018-09-18 12:04:45","Access to nested json using Rxjs","<json><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"52386217","2","","52383807","2018-09-18 12:04:45","","0","","<p>After a deep research on operators of <strong>rxjs</strong>.I find this solution and it works for me:
Look at this method below :
1) First I request for json reponse from <strong>API</strong> using get of <strong>http</strong> <strong>angular</strong> module.</p>

<p>2) I map json response to IEvent model and I create <strong>searchedSessions</strong> variable of type ISession Array. After I concat result's sessions array to each of them in the last variable.</p>

<p>3)I filter resulting sessions that contain keyword with indexOf(keyword).</p>

<p>4) Finally I return observables of filtered sessions.  </p>

<pre><code>searchSession(sessionKeyWord: string):Observable&lt;ISession[]&gt; {

    return this.http.get(this.url + '?q=' + sessionKeyWord).pipe(map(response =&gt; {
      return response.json();
      }),map((data:IEvent[])=&gt;{
        var searchedSessions:ISession[]=[];
        data.forEach((event:IEvent)=&gt;{
          searchedSessions=searchedSessions.concat(event.sessions);
          console.log(searchedSessions)
        });
        var filteredSessions:ISession[]=[]
        filteredSessions=searchedSessions.filter((session:ISession)=&gt;{
                          return session.abstract.toLocaleLowerCase().indexOf(sessionKeyWord.toLocaleLowerCase())&gt;-1})
        console.log(filteredSessions)
        return filteredSessions;
      }))
  }
</code></pre>

<p>I hope that my answer help you if you fall into the same situation.</p>
","8384029","","","","","2018-09-18 12:04:45","","","","0","","","","CC BY-SA 4.0"
"52392834","1","","","2018-09-18 18:45:54","","0","1180","<p>I have an Observable which return as observable of data and that is binding with async using HTML.</p>

<p>here I have called the service.</p>

<pre><code>this.ProductOptions = this.ProductService.fetchProduct();
</code></pre>

<p>In HTML we have binding as </p>

<pre><code>Productoptions | async.
</code></pre>

<p>It's working fine.</p>

<p>In another function call, I have filtered based on product name, but it's not working.</p>

<pre><code>getCategory() {
  const productListOptions = this.productOptions.pipe(
    switchMap((itemList: BindingModel[]) =&gt; itemList.filter(product =&gt; product.name !== ""Active"")));

  console.log(this.productListOptions);
}
</code></pre>

<p><code>this.productOptions</code> shows below in console.</p>

<p><a href=""https://i.stack.imgur.com/ZSnG0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZSnG0.png"" alt=""enter image description here""></a></p>

<hr>

<p>But when I subscribe to the observable.</p>

<pre><code>this.productService.fetchproducts().subscribe(response =&gt; console.log(response));
</code></pre>

<p>I am getting below format</p>

<pre><code>[{id:1,name:""Active""},{id:1,name:""InActive""}]; i need to filter based on Active
</code></pre>
","4031891","","2622292","","2018-09-18 18:53:05","2018-09-18 19:10:33","How to filter Observable of array with rxjs 6 with async","<angular><angular6><angular2-services><rxjs5><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52392915","1","","","2018-09-18 18:51:57","","0","76","<p>Using Angular 6 with RxJS 5, ngx-restangular and ngrx store.</p>

<p>I'm dealing with an API that breaks very easily, and can easily take 5+ seconds to respond, or frequently responds with 500.</p>

<p>I need to send in multiple (n) requests, I've been using forkJoin but I'd like to start populating the UI as soon as the anything is returned, and not have to wait for all to return at once (and also if one of those calls fails, the rest will continue so I can at least display that data).  I also tried combineLatest, but that one also waits for all of the observables to emit something.</p>

<p>I think there's something wrong with the way I have it set up in ngrx store and could use some advice on how to accomplish this.</p>

<p>Say I have this in my services to accept an array of timestamps:</p>

<pre><code>getForTimestamps(timestamps: string[] = []) {
    const observableBatch = [];

    timestamps.forEach((timestamp) =&gt; {
      observableBatch.push(this.restangular.all('myapi').customGET('', {timestamp})
        .pipe(
          catchError((err) =&gt; observableThrowError(err) ),
          map((r) =&gt; {
            return {[timestamp]: r}
          })));
    })
    return observableBatch.length &gt; 0 ? observableForkJoin(observableBatch) : observableOf([]);
}
</code></pre>

<p>However, this doesn't emit anything to my effect until all of those observables have completed.  Should I pull out the array observable and deal with the array in the effect instead?</p>

<p>I apologize if this has been asked before, I couldn't figure out what to search for.  Many thanks in advance!</p>
","6096126","","","","","2018-09-18 18:51:57","Using rxjs and ngrx store to deal with fragile API","<angular><rxjs5><ngrx-store>","0","3","","","","CC BY-SA 4.0"
"52403111","1","","","2018-09-19 09:55:42","","0","95","<p>I've got an application that displays a list of questions. When the app starts up, I want to check if we've got any questions stored, and if we don't, then we do a request to get the questions from the cloud.</p>

<p>I've got a simple function that returns a POST request:</p>

<pre><code>getQuestions() {
   return this.http.post(AppSettings.CI_GET_QUESTIONS, '')
</code></pre>

<p>}</p>

<p>If I subscribe to this Observable:</p>

<pre><code>this.dataService.getQuestions()
  .map(questions =&gt; questions.json())
  .map((questions) =&gt; {
    return questions;
  })
  .subscribe((success) =&gt; {
    console.log(""### sc:"", success)
  })
</code></pre>

<p>I get my array of questions printed out, so far so good.</p>

<p>However, I went to check if we already have the questions stored locally, and if we don't then go get the questions from the cloud. So I've wrote this Observable to do this:</p>

<pre><code>this.storage.checkQuestionsLocally()
  .catch((error) =&gt; {
    return this.dataService.getQuestions()
      .map(questions =&gt; questions.json())
      .map((questions) =&gt; {
        return questions;
      })

  })
  .subscribe((done) =&gt; {
    console.log(""### questions done:"", done)
  }, (error) =&gt; {
    console.log(""### error during getting questions:"", error)
  }, () =&gt; {
    console.log(""### questions found routine is completed"");
  })
</code></pre>

<p>On startup we check do we have anything stored locally, and if we receive an error, then go get the questions.</p>

<p>The problem I'm having is in this <code>catch</code> function. The error triggers the <code>catch</code>, and the code attempts to execute the request but nothing actually happens. I can see on the Network page (of Chrome Dev Tools) that the request I have is cancelled:</p>

<p><code>getQuestions (canceled)    xhr polyfills.js:3  0 B 15 ms</code></p>

<p>Why is this being cancelled? Shouldn't the request just fire and bring the questions back?</p>

<p>Thanks,
bengrah</p>
","5135604","","","","","2018-09-19 09:55:42","Angular - Observable.catch does not fire returned observable","<angular><http><ionic3><rxjs5><angular2-observables>","0","3","","","","CC BY-SA 4.0"
"52412091","1","","","2018-09-19 18:25:27","","1","201","<pre><code>onSave() {
  // event handler 
  const save$ = combineLatest(this.configData.data, this.layerService.layerData)
    .pipe(
      filter(([configData]) =&gt; !_.isEmpty(configData)),
      take(1),
      tap(_ =&gt; this.loadingService.showLoading()),
      map(data =&gt; this.createSaveConfig(data)),
      flatMap(dataJSON =&gt; this.saveService.save(dataJSON)),
    ).share();

  const saveAndReload$ = save$.pipe(
    filter(_ =&gt; !this.savedId),
    pluck('savedId'),
    flatMap(savedId =&gt; this.saveService.getData(savedId)),
    tap(reportData =&gt; this.retrievedReport = reportData),
    pluck('savedId'),
    tap(savedId =&gt; {
      this.savedId = savedId;
      this.location.replaceState(`/notes/${this.savedId}`);
    })
  );

  save$.merge(saveAndReload$).subscribe(_ =&gt; {
    this.loadingService.hideLoading();
  }, err =&gt; this.errorService.error(err));

}
</code></pre>

<p>On initial save saveId doesn't exist and in that case specific operation is performed which is changing the url with saveId.
And during subsequent saveId would be present so, in that case no need to change the url.
The problem with above is that during first save subscribe method is called twice.</p>
","4404499","","4404499","","2018-10-08 16:04:20","2018-10-08 16:04:20","RxJs Branching If Else Logic","<angular><rxjs><rxjs5>","0","0","","","","CC BY-SA 4.0"
"52427602","2","","52372807","2018-09-20 14:35:03","","2","","<p><strong>TL;DR:</strong> Stricter type checks introduced in TypeScript 2.4 are not compatible with RxJS &lt; 5.4.2 (<a href=""https://github.com/ReactiveX/rxjs/pull/2722"" rel=""nofollow noreferrer"">due to a bug</a>). Your IDE is probably using TypeScript >= 2.4 for type checks. Either upgrade RxJS (recommended), downgrade TypeScript, or use the programatic solution <code>Subject.asObservable</code> together with a return type <code>Observable&lt;boolean&gt;</code>.</p>

<p><strong>Explanation:</strong></p>

<p>After the discussion, I looked into the RxJS 5.3.0 source code and found that the signatures of <code>lift</code> differ between <code>Subject</code> and <code>Observable</code>. Specifically, we can see the following difference:</p>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/5.3.0/src/Subject.ts"" rel=""nofollow noreferrer"">Subject.ts:</a></p>

<pre><code>lift&lt;R&gt;(operator: Operator&lt;T, R&gt;): Observable&lt;T&gt;
</code></pre>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/5.3.0/src/Observable.ts"" rel=""nofollow noreferrer"">Observable.ts:</a></p>

<pre><code>lift&lt;R&gt;(operator: Operator&lt;T, R&gt;): Observable&lt;R&gt;
</code></pre>

<p>The Generic Type of the returned Observable is <strong>T</strong> in <code>Subject</code>, but <strong>R</strong> in <code>Observable</code>. </p>

<p>The <code>first()</code> operator requires an <code>Observable</code> for its <code>this</code> context, that can't be matched by <code>Subject</code> due to the mismatching signatures of <code>lift</code>. This is very strange to me, as <code>Subject</code> extends <code>Observable</code> and therefore should have matching signatures for all its properties. </p>

<p>Now here is the solution: TypeScript introduced stricter type checks with version 2.4 and indeed RxJS needed to catch up with that change by changing the signature of the <code>lift</code> method. This change can be seen <a href=""https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md"" rel=""nofollow noreferrer"">in the changelog</a> at version <strong>5.4.2</strong>.:</p>

<blockquote>
  <p>Subject: lift signature is now appropriate for stricter TypeScript 2.4 checks</p>
</blockquote>

<p><a href=""https://github.com/ReactiveX/rxjs/pull/2722"" rel=""nofollow noreferrer"">Here is the corresponding issue</a>. It seems to have been a bug.</p>

<p>You're running RxJS <strong>5.3</strong>, so that's why you get the error.</p>

<p>There are two options. Either upgrade RxJS (recommended) or use <code>Subject.asObservable</code> to change the type from <code>Subject</code> to <code>Observable</code>. </p>

<p>As mentioned in my comment, the return type of your function needs to change to <code>Observable&lt;boolean&gt;</code> as well. </p>

<p>Applied on your snipped, this should look like this:</p>

<pre><code>public confirm(prompt: string): Observable&lt;boolean&gt; {
    // ...set up a confirmation dialog...
    this.response$ = new Subject&lt;boolean&gt;();
    return this.response$.asObservable().first();
  }
</code></pre>

<p>I see your TypeScript version is <strong>2.2</strong>, but it may very well be that your IDE uses another TypeScript version for type checks.</p>

<p><strong>Alternative</strong></p>

<p>As mentioned by @cartant, <code>Subject.lift</code> is implemented to return a <code>Subject</code>, but that can't be expressed with TypeScript's types (no return type overloading, not even sure if there is a language that supports that). </p>

<p>So, another solution is to ignore the type checks by casting to <code>&lt;any&gt;</code>. That way you can also return <code>Subject</code>.</p>
","7247920","","7247920","","2018-09-20 15:27:52","2018-09-20 15:27:52","","","","1","","","","CC BY-SA 4.0"
"52504988","1","52532558","","2018-09-25 18:52:17","","2","380","<p>I'm using Redux Observable and need to solve a timing issue when firing off actions from epics.</p>

<p>I have an array of items that I want to loop over for making AJAX calls on each one. Immediately after receiving the AJAX response, I want to fire off some actions. After all of the AJAX responses come back for each item in the original array, I want to fire off more actions.</p>

<p>How can I get these actions to fire immediately after the <code>timer</code> expires even though the original array hasn't finished looping?</p>

<pre class=""lang-js prettyprint-override""><code>const someEpic = action$ =&gt; (
    action$
    .pipe(
        ofType(SOME_ACTION),
        switchMap(({ payload }) =&gt; (
            from(payload) // This is an array of items
            .pipe(
                mergeMap(() =&gt; (
                    timer(5000) // This is my AJAX call
                    .pipe(
                        map(loadedAction),
                    )
                )),
                toArray(),
                map(anotherAction),
            )
        ))
    )
)
</code></pre>
","7113321","","1624862","","2018-09-30 17:45:11","2018-09-30 17:45:11","Emit actions before `toArray` - Redux Observable","<rxjs><rxjs5><redux-observable><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"52532558","2","","52504988","2018-09-27 08:22:51","","1","","<p>Probably the easiest way is actually emitting actions using <code>tap</code> wherever you want. This is assuming you have access to the store. For example:</p>

<pre><code>tap(result =&gt; this.store.dispatch(...))
</code></pre>

<p>However a more ""Rx"" way would be splitting the chain using <code>multicast</code> and then reemitting one part immediatelly (that's the loading progress) and the other half chaining with <code>toArray()</code> to collect all results that would be then turn into another action signaling that loading is done.</p>

<pre><code>import { range, Subject, of } from 'rxjs';
import { multicast, delay, merge, concatMap, map, toArray } from 'rxjs/operators';

const process = v =&gt; of(v).pipe(
  delay(1000),
  map(p =&gt; `processed: ${p}`),
);

range(1, 5)
  .pipe(
    concatMap(v =&gt; process(v)),
    multicast(
      () =&gt; new Subject(), 
      s =&gt; s.pipe(
        merge(s.pipe(toArray()))
      )
    ),
  )
  .subscribe(console.log);
</code></pre>

<p>Live demo: <a href=""https://stackblitz.com/edit/rxjs6-demo-k9hwtu?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs6-demo-k9hwtu?file=index.ts</a></p>
","310726","","","","","2018-09-27 08:22:51","","","","1","","","","CC BY-SA 4.0"
"52539367","1","52539610","","2018-09-27 14:28:17","","2","5826","<p>I recently update my application to angular 6 as well as the RxJs to <code>6.3.3</code> <code>version</code>. </p>

<p>As described in <a href=""https://auth0.com/blog/whats-new-in-rxjs-6/"" rel=""nofollow noreferrer"">here</a>, I used the package <code>rxjs-compat</code> to have temporarily the code written in RxJS5 and RxJS6 compatibility mode, at the same time.</p>

<p>As suggested by the RxJS team, after I update all my code to be compatible with RxJS6, I uninstalled the <code>rxjs-compat</code> because it is not longer necessary.</p>

<p>After that, I'm trying to run my code but the compiler is retrieving the following error:</p>

<blockquote>
  <p>ERROR in node_modules/rxjs/Rx.d.ts(1,15): error TS2307: Cannot find
  module 'rxjs-compat'</p>
</blockquote>

<p>Any one know what can be the problem in here? This seems that the RxJS pacadge depends on <code>rxjs-compat</code>, but if what I'm saying is true, why the RxJS team recommends to uninstall <code>rxjs-compat</code>?</p>
","5148197","","","","","2020-11-26 12:10:12","RxJS6 (angular 6) - ERROR in node_modules/rxjs/Rx.d.ts(1,15): error TS2307: Cannot find module 'rxjs-compat'","<angular><rxjs><rxjs5><rxjs6>","5","3","","","","CC BY-SA 4.0"
"52539610","2","","52539367","2018-09-27 14:43:38","","13","","<p>After some search I found out <a href=""https://github.com/ReactiveX/rxjs/issues/3764#issuecomment-393456370"" rel=""noreferrer"">this post</a> that advice to search in all of my code and remove all imports that referenced the <code>rxjs/Rx</code>:</p>

<pre><code>import 'rxjs/Rx'
</code></pre>

<p>After I remove this import in all places of my code, the error disappear.</p>
","5148197","","","","","2018-09-27 14:43:38","","","","0","","","","CC BY-SA 4.0"
"52596486","1","52597029","","2018-10-01 18:03:08","","1","2229","<p>For example:</p>

<pre><code>this.saveSubscription$ = this.ds.onSave$.subscribe(x =&gt; 
  this.sb.updateMachineTool(this.viewEditModel.viewEditModel).subscribe(x = {
    console.log('alert results', x)
  })
)
</code></pre>

<p><code>this.ds.onSave$</code> is a subject that triggers when a save button on a different component is clicked.</p>

<p><code>this.sb.updateMachineTool</code> is an httpClient post that updates a specific tool</p>

<p>should I be using some type of map so i'm not subscribing to both areas?</p>

<p>How can I refactor this code?</p>
","9457997","","5377805","","2018-10-01 18:11:24","2018-10-01 18:46:37","How to refactor a subscribe inside a subscribe in rxjs","<angular><rxjs><angular6><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52597029","2","","52596486","2018-10-01 18:40:03","","2","","<p>To Refactor your code You can use<br>
<a href=""https://www.learnrxjs.io/operators/transformation/mergemap.html"" rel=""nofollow noreferrer""><code>mergeMap</code></a><br>
<a href=""https://www.learnrxjs.io/operators/transformation/switchmap.html"" rel=""nofollow noreferrer""><code>switchMap</code></a><br></p>

<p>your question is the perfect use case for <code>switchMap</code>. because as you have mentioned <code>this.ds.onSave$</code> is a subject that triggers when a save button on a different component is clicked.<br>
The advantage <code>switchMap</code> gives you in this scenario is it will cancel all the old subscription(Http Call in Progress in your case) automatically if the button is clicked repeatedly.</p>

<p><strong>ModifiedCode</strong></p>

<pre><code>this.saveSubscription$ = this.ds.onSave$.pipe(switchMap(()=&gt; 
  this.sb.updateMachineTool(this.viewEditModel.viewEditModel)
  )
).subscribe(x = {
    console.log('alert results', x)
  });
</code></pre>

<p><strong>For More</strong><br></p>

<ol>
<li><a href=""https://netbasal.com/understanding-mergemap-and-switchmap-in-rxjs-13cf9c57c885"" rel=""nofollow noreferrer""><code>Understanding mergeMap and switchMap in
RxJS</code></a><br></li>
<li><a href=""https://medium.com/@vdsabev/the-simple-difference-between-rxjs-switchmap-and-mergemap-397c311552a5"" rel=""nofollow noreferrer""><code>The Simple Difference Between RxJS switchMap and
mergeMap</code></a></li>
</ol>
","5695162","","5695162","","2018-10-01 18:46:37","2018-10-01 18:46:37","","","","4","","","","CC BY-SA 4.0"
"52605777","1","","","2018-10-02 09:38:45","","0","246","<p>I have three source of data :</p>

<pre><code>let insightsFromDB$;// Return observable of insight object
let insightsFromAPI$;// Return observable of insight object
let insightsFromWebsockets; // Return observable of insight object
     otherObservable$
       .merge(insightsFromDB$, insightsFromAPI$) // Return observable of insight object 
      .map(insight=&gt;insight.likes)
</code></pre>

<p>I want to add the <code>insightsFromWebsockets$</code> to the <code>otherObservable$</code> in such a way that if it's emits a value, it cancels the insight object coming from the merge operator and emit the object coming from <code>insightsFromWebsockets$</code> to the map operator.</p>

<p>For more clarity, I have added the following marble diagram that summarize my code: 
<a href=""https://i.stack.imgur.com/25KNV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/25KNV.png"" alt=""enter image description here""></a></p>
","4396585","","4396585","","2018-10-02 10:24:07","2018-10-02 11:00:52","Canceling observable when certain observable emit data rxjs","<typescript><rxjs><observable><reactive-programming><rxjs5>","1","3","","","","CC BY-SA 4.0"
"52608870","1","52609434","","2018-10-02 13:00:18","","1","544","<p>With regular JS and Jquery you can do something like <code>$(document).on('click', '#id', function () { // whatever })</code>. This allows us to add an event in a element that may not exist in the DOM yet. I would like to use <code>Rx.Observable.fromEvent(ele, 'click')</code> to do the same - I need to do that because the elements are being created in another stream. Is this possible?</p>

<hr>

<p><strong>CONTEXT</strong></p>

<p>Some context of what I am trying to achieve. I'm following <a href=""https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"" rel=""nofollow noreferrer"">The introduction to Reactive Programming you've been missing</a>. The proposed exercise is:</p>

<ol>
<li>Fetch users from GitHub API</li>
<li>Display three users as suggestions to follow;</li>
<li>Each user should have a ""remove"" button;</li>
<li>Whenever a remove button is clicked, remove that suggestion and load another one from the buffer;</li>
</ol>

<p>It goes very well until the part of loading the three suggestions. For example: </p>

<pre><code>Rx.Observable
    .fromEvent($('#refresh'), 'click')
    .startWith('start up click')
    .map(() =&gt; Math.floor(Math.random() * 500))
    .map(offset =&gt; `${GITHUB_API}?since=${offset}`)
    .map(url =&gt; jQuery.getJSON(url))
    .flatMap(promisse =&gt; Rx.Observable.from(promisse))
    .map(users =&gt; users.slice(0, 3))
    .do(_ =&gt; $('#users').empty())
    .flatMap(users =&gt; users)
    .map(user =&gt; createItem(user))
    .subscribe(user =&gt; $('#users').append(user));

// Just an example for creating the elements
function createItem(user, idx) {
  return $(`
    &lt;li class=""item-wrapper horizontal"" &gt;
      &lt;img src=""${user.avatar_url}"" class=""rounded-circle"" width=""50"" height=""50""&gt;

      &lt;div class=""item-infos-wrapper vertical""&gt;
        &lt;span class=""font-weight-bold""&gt;${user.login}&lt;/span&gt;
        &lt;span class=""font-weight-normal""&gt;What can we put in here?&lt;/span&gt;
      &lt;/div&gt;

      &lt;button id=""close${idx}"" type=""button"" class=""btn btn-outline-danger btn-sm item-action""&gt;remove&lt;/button&gt;
    &lt;/li&gt;
  `);
}
</code></pre>

<p>From what I understood of the aforementioned article, the idea to handle the item removal is to use <code>combineLatest</code> with a stream of ""remove button clicked"" and ""requestStream"" (containing the results of the API), feeding the combined data in the pipe that creates the elements. My current problem is build this retro feeding from the remove button clicked stream plus request stream into the consumer that creates the elements.</p>
","7822962","","7822962","","2018-10-02 13:25:02","2018-10-02 13:45:25","How to use Rx.Observable.fromEvent in an element that does not exist in the DOM yet?","<rxjs><rxjs5>","1","2","","","","CC BY-SA 4.0"
"52609434","2","","52608870","2018-10-02 13:31:33","","1","","<p>You could do something like this but it's not clear to me where <code>idx</code> comes from. Is it a property of the user?</p>

<pre><code>Rx.Observable
    .fromEvent($('#refresh'), 'click')
    .startWith('start up click')
    .map(() =&gt; Math.floor(Math.random() * 500))
    .map(offset =&gt; `${GITHUB_API}?since=${offset}`)
    .map(url =&gt; jQuery.getJSON(url))
    .flatMap(promisse =&gt; Rx.Observable.from(promisse))
    .map(users =&gt; users.slice(0, 3))
    .do(_ =&gt; $('#users').empty())
    .flatMap(users =&gt; users)
    .map(user =&gt; createItem(user)) //at this point we have a listItem in the stream

    // from this point it's changed

    .tap(listItem =&gt; $('#users').append(listItem)) //append to users, but keep the listItem in the stream
    .map(listItem =&gt; $(listItem).find('button')[0]) //get the button element
    .mergemMap(closeButton =&gt; fromEvent(closeButton, 'click')) //subscribe to click on the button and merge all the clicks into one stream
    .subscribe((event: MouseEvent) =&gt; {
        console.log('clicked', event); //a close button was clicked...
    });
</code></pre>

<p>and here is a way of removing the <code>li</code> when the button is clicked:</p>

<pre><code>Rx.Observable
    .fromEvent($('#refresh'), 'click')
    .startWith('start up click')
    .map(() =&gt; Math.floor(Math.random() * 500))
    .map(offset =&gt; `${GITHUB_API}?since=${offset}`)
    .map(url =&gt; jQuery.getJSON(url))
    .flatMap(promisse =&gt; Rx.Observable.from(promisse))
    .map(users =&gt; users.slice(0, 3))
    .do(_ =&gt; $('#users').empty())
    .flatMap(users =&gt; users)
    .mergeMap(user =&gt; {
        const listItem = createItem(user);
        $('#users').append(listItem);

        const closeButton = $(listItem).find('button')[0];
        return Rx.Observable.fromEvent(closeButton, 'click').first().tap(_ =&gt; listItem.remove());
    })
    .subscribe();
</code></pre>
","3016654","","3016654","","2018-10-02 13:45:25","2018-10-02 13:45:25","","","","3","","","","CC BY-SA 4.0"
"52619758","1","","","2018-10-03 04:36:16","","0","141","<p>Say I have this:</p>

<pre><code>const register = function(cb){

   process.on('message', m =&gt; {

         cb(m, (err, v) =&gt; {

            process.send({error: err, value: v});

         });
   });

};
</code></pre>

<p>we use the above like:</p>

<pre><code>register((m, cb) =&gt; {

   // do something with m

   setTimeout(() =&gt; {
      cb('some error', m);
   }, 100);

});
</code></pre>

<p>my question is - is there a way to use <code>Rx.Observable</code> with this - most examples of <code>Rx.Observable.fromCallback</code> will wrap an <em>error-first</em> callback. But in this case, the callback is not error first. As an exercise, how to make it work for non-error first callbacks? Here is a start:</p>

<pre><code>const {Observable, bindNodeCallback} = require('rxjs');

const obs = bindNodeCallback(register);

const subscription = obs().subscribe(v =&gt; {

}, e =&gt; {
       // this gets hit since the first arg is not an error
 });
</code></pre>

<p>anyone dealt with this one before?</p>

<p><strong>Update</strong>, I got a little closer, the following example uses setInterval instead of process.on('message') so it is easier to work with for testing:</p>

<p><a href=""https://gist.github.com/ORESoftware/ea5d754d6ca6c92ca7e3bddc7eb318c2"" rel=""nofollow noreferrer"">https://gist.github.com/ORESoftware/ea5d754d6ca6c92ca7e3bddc7eb318c2</a></p>
","1223975","","1223975","","2018-10-03 04:59:13","2018-10-03 08:41:27","Observable from callback, where callback is not error-first","<rxjs><observable><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52641088","1","52641348","","2018-10-04 07:17:36","","0","614","<p>I have a List of Post with Pagination that I subscribe to the query parameter <code>?page=</code> to recalled the service API</p>

<pre><code>ngOnInit(): void {

    this.route.queryParams.subscribe(params =&gt; {

        const page = params['page'];

        // on query parameter change, call the API service here


    });
}
</code></pre>

<p>Now, I have a new requirement where User can also filter the list by selecting Category dropdown using <strong>Reactive Form</strong>. </p>

<p>Using Reactive Form, I can subscribe to the observer using this code here</p>

<pre><code>onChanges(): void {
  this.myForm.get('category').valueChanges.subscribe(val =&gt; {
    // on form value change, call the API service here
  });
}
</code></pre>

<p>My question is, how can I simplify this using Angular and RXJS? </p>

<p>The method in the example above not really DRY because the are calling the same API, only with different request parameter</p>

<p>Thanks.</p>
","417899","","7470786","","2018-10-04 07:25:10","2018-10-04 07:33:08","How to combine query parameter observable and form observable using Angular and RXJS","<angular><rxjs5><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"52641348","2","","52641088","2018-10-04 07:33:08","","1","","<p>You can use the <a href=""https://www.learnrxjs.io/operators/combination/combinelatest.html"" rel=""nofollow noreferrer""><code>combineLatest</code></a> operator:</p>

<pre><code>ngOnInit(): void {
  combineLatest(
    this.route.queryParams, 
    this.myForm.get('category').valueChanges
  ).subscribe(([{ page }, category]) =&gt; {
     // on any change call the API service here
  });
}
</code></pre>

<p>Side note: Don't forget to unsubscribe in the <code>onDestroy</code> hook, or use the <code>takeUntil</code> operator</p>
","3106920","","","","","2018-10-04 07:33:08","","","","1","","","","CC BY-SA 4.0"
"52652902","1","52653206","","2018-10-04 18:03:48","","8","2162","<p>If I have code like the below:</p>

<pre><code>const d: any = {};

return this.http.post(url, body, httpOptions).map(data =&gt; {
  return d;
}, error =&gt; {
  console.error('error');
})
.catch((err, d$) =&gt; {
  return Observable.of(d);
});
</code></pre>

<p>and if there is any kind of error i.e. the POST request failed or some error in the <code>.map()</code> success callback or any other kind of error.</p>

<p>Which of the two error handlers would be invoked the error callback on the <code>.map()</code> or the <code>.catch()</code> callback? Is it dependent on the type of the error that might happen?</p>

<p>Would the error callback on the <code>.map()</code> be skipped always because of the presence of the <code>.catch()</code> operator?</p>
","5552182","","","","","2018-10-04 18:47:48","In RxJS what's the difference between error callback vs .catch()?","<angular><observable><rxjs5><angular-httpclient>","2","2","2","","","CC BY-SA 4.0"
"52653206","2","","52652902","2018-10-04 18:22:16","","12","","<p>In your example the catch would be invoked if an error occurred. Additionally, the <code>map</code> operator does not have a second argument so that function will never be called. If you have an error handler on a subscribe then the callback will be invoked if an unhandled exception occurs. The <code>catchError</code> operator is a way of handling errors. It basically acts as a <code>switchMap</code> to switch to a new observable stream.</p>

<h2>Examples:</h2>

<h3>Subscribe Error Handler (<a href=""https://stackblitz.com/edit/typescript-6yrczn?embed=1&amp;file=index.ts&amp;devtoolsheight=100"" rel=""noreferrer"">Demo</a>)</h3>

<pre class=""lang-js prettyprint-override""><code>return throwError('This is an error!').subscribe(data =&gt; {
  console.log(""Got Data: "", data);
}, error =&gt; {
  console.error('error', error); // Observable stream has error so this prints
});
</code></pre>

<h3>Catching an error (<a href=""https://stackblitz.com/edit/typescript-g1ackn?embed=1&amp;file=index.ts&amp;devtoolsheight=100"" rel=""noreferrer"">Demo</a>)</h3>

<pre class=""lang-js prettyprint-override""><code>return throwError('This is an error!').pipe(
  catchError(error =&gt; {
    console.log(""Error Caught"", error);
    return of(2); // Catches the error and continues the stream with a value of 2
  }),
).subscribe(data =&gt; {
  console.log(""Got Data: "", data); // Data will be logged
}, error =&gt; {
  console.error('error', error); // Will not be called
});
</code></pre>

<h3>Catching an error and re-throwing (<a href=""https://stackblitz.com/edit/typescript-pus7t8?embed=1&amp;file=index.ts&amp;devtoolsheight=100"" rel=""noreferrer"">Demo</a>)</h3>

<pre class=""lang-js prettyprint-override""><code>return throwError('This is an error!').pipe(
  catchError(error =&gt; {
    console.log(""Error Caught"", error);
    return throwError(error); // Catches the error and re-throws
  }),
).subscribe(data =&gt; {
  console.log(""Got Data: "", data);
}, error =&gt; {
  console.error('error', error); // Observable stream has error so this prints
});
</code></pre>
","5914191","","5914191","","2018-10-04 18:47:48","2018-10-04 18:47:48","","","","1","","","","CC BY-SA 4.0"
"52707668","2","","48857550","2018-10-08 17:52:33","","0","","<p>If you assert that the observable returned from your chain matches your marble diagram you are also testing that your observer methods are called correctly. If you want to test your observer methods I would do that independently. </p>

<p>With marble testing you have the possibility to test if your Observable has a subscription. Let's say you have for example the following source observable.</p>

<pre><code>const source =  m.hot(""--^-a-b-c-|"");
</code></pre>

<p>You could then test if your observable has the correct subscription:</p>

<pre><code>const expectedSubscription = ""^-------!"";
m.expect(source).toHaveSubscriptions(subs);
</code></pre>

<p>Of course it depends which version you are using and which marble library you use. (the syntax may be different). There is also a good blogpost which gives you a good overview of the whole topic. <a href=""https://itnext.io/findings-about-rxjs-marble-testing-and-the-testscheduler-b23c6bdf6b49"" rel=""nofollow noreferrer"">https://itnext.io/findings-about-rxjs-marble-testing-and-the-testscheduler-b23c6bdf6b49</a></p>
","4382345","","","","","2018-10-08 17:52:33","","","","0","","","","CC BY-SA 4.0"
"52718262","1","52723645","","2018-10-09 09:59:41","","0","23","<p>Look the excerpt below:</p>

<pre class=""lang-js prettyprint-override""><code>  let requestStream = Rx.Observable
    .of(`${GITHUB_API}?since=${randomNumber()}`)
    .mergeMap(url =&gt; {
      console.log(`performing request to: ${url}`)
      return Rx.Observable.from(jQuery.getJSON(url))
    });

  let refreshStream = Rx.Observable.fromEvent(refreshButton, 'click')
    .startWith('click')
    .do(_ =&gt; users.empty())
    .combineLatest(requestStream, (_, users) =&gt; users.slice(randomNumber(users.length)));

  let randomUserStream = userRemovedStream
    .combineLatest(requestStream, (_, users) =&gt; users[randomNumber(users.length)]);

  requestStream
    .merge(refreshStream)
    .flatMap(users =&gt; users)
    .merge(randomUserStream)
    .filter(_ =&gt; users.children().length &lt; MAX_SUGGESTIONS)
    .do(user =&gt; users.append(createItem(user)))
    .mergeMap(user =&gt; Rx.Observable.fromEvent($(`#close-${user.login}`), 'click'))
    .map(event =&gt; event.target.parentNode)
    .subscribe(user =&gt; {
      user.remove();
      userRemovedStream.next('');
    });
</code></pre>

<hr>

<p>The <code>requestStream</code> returns an array with 100 users, however, I am consuming only three (<code>MAX_SUGGESTIONS</code>) of them at the time. <code>refreshStream</code> and <code>randomUserStream</code> exists in order to reuse the other 97 users from <code>requestStream</code>. The problem is, when I run the code above, I still see on console <code>performing request to: ...</code> three times.</p>

<p><em>I've noticed that this happens after adding the <code>merge</code> methods in the last stream, however, I am not sure why this behaviour is happening.</em> </p>

<p>My understand is: when I <code>merge</code> <code>refreshStream</code> and <code>randomUserStream</code>, whenever a new item is emitted, a click on <code>refresh</code> button for the former and a click on <code>remove</code> button for the later, the previously emitted array on <code>requestStream</code> will be parsed and passed forward instead of the click itself. This should not re-trigger the <code>requestStream</code>.</p>

<p>Can someone help me understand why is this happening and how to deal with this situation? - so I can take the maximum out of the users already returned by the API during the first call?</p>
","7822962","","","","","2018-10-09 14:38:16","Why is initial stream being triggered again after combineLatest and merge in this example?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"52723645","2","","52718262","2018-10-09 14:38:16","","1","","<p>It happens because you have effectively three subscriptions to the <code>requestStream</code>. Your intuition in how the three interact is correct, however, because your <code>requestStream</code> Observable is cold it will create a new stream each time there is a subscription.</p>

<p>It isn't necessarily obvious because only one subscription is explicitly made, but each time you pass <code>requestStream</code> to <code>combineLatest</code> it will end up creating an new subscription which will in turn start a new stream, which in this case calls your underlying API.</p>

<p>If you don't want that to happen, I would suggest you use a multicasting operator like <code>publishLast</code></p>

<p>So <code>requestStream</code> will become:</p>

<pre><code>let requestStream = Rx.Observable
    .of(`${GITHUB_API}?since=${randomNumber()}`)
    .mergeMap(url =&gt; {
      console.log(`performing request to: ${url}`)
      return Rx.Observable.from(jQuery.getJSON(url))
    })
    .publishLast();
</code></pre>

<p>In this case <code>requestStream</code> is now actually a <code>ConnectableObservable</code> so you will need to also start it at some point, usually you would wait until all of your subscribers are hooked up.</p>

<pre><code>/* Rest of you example */
.map(event =&gt; event.target.parentNode)
.subscribe(user =&gt; {
  user.remove();
  userRemovedStream.next('');
});

requestStream.connect();
</code></pre>
","2521865","","","","","2018-10-09 14:38:16","","","","1","","","","CC BY-SA 4.0"
"52739292","1","52743525","","2018-10-10 11:33:09","","1","1819","<p>I'm trying to implement ngbTypeAhead , but having an issue with RxJS , using 5.5.5 version . I've took this example from rxjs 6 version .</p>

<pre><code>""rxjs"": ""^5.5.2"" and
 angular ""^5.0.1"",
""typescript"": ""~2.6.1"",
</code></pre>

<p>when I tried to implement typeahead on focus , getting an error like ,</p>

<pre><code> *[ts] Property 'pipe' does not exist on type 'UnaryFunction&lt;Observable&lt;{}&gt;, Observable&lt;string | {}&gt;&gt;'.
any*


search2 = (text$: Observable&lt;string&gt;) =&gt; {
    const debouncedText$ = text$.pipe(debounceTime(200), distinctUntilChanged());
    const clicksWithClosedPopup$ = this.click$.pipe(filter(() =&gt; !this.instance.isPopupOpen()));
    const inputFocus$ = this.focus$;

    let mer = merge(debouncedText$, inputFocus$, clicksWithClosedPopup$);
    debugger;
    return mer.pipe(
      map(term =&gt; (term === '' ? this.roadList
        : this.roadList.filter(v =&gt; v.toLowerCase().indexOf(term.toString().toLowerCase()) &gt; -1)).slice(0, 10))
    );
  }
</code></pre>

<p>could anyone please help me figure it the issue how to rewrite the above search2 method?</p>
","4480993","","310726","","2018-10-10 15:16:35","2018-10-11 12:35:30","Rxjs : [ts] Property 'pipe' does not exist on type 'UnaryFunction<Observable<{}>, Observable<string | {}>>'. any","<angular><typescript><rxjs><angular5><rxjs5>","1","0","","","","CC BY-SA 4.0"
"52743525","2","","52739292","2018-10-10 15:16:14","","3","","<p>You're most likely importing <code>merge</code> as an operator while you want <code>merge</code> that it so called <em>""Observable creation method""</em> and comes directly form <code>'rxjs'</code>.</p>

<p>So check if you're really using this import in RxJS 6:</p>

<pre><code>import { merge } from 'rxjs';
</code></pre>

<p>...instead of this import that imports <code>merge</code> operator that you don't want:</p>

<pre><code>import { merge } from 'rxjs/operators'; // This imports just the operator
</code></pre>

<p>For RxJS 5 use the following:</p>

<pre><code>import { merge } from 'rxjs/observable/merge';
</code></pre>
","310726","","310726","","2018-10-11 12:35:30","2018-10-11 12:35:30","","","","4","","","","CC BY-SA 4.0"
"52758954","1","52759075","","2018-10-11 11:28:21","","3","5176","<p>Trying to upgrade to Angular 6 from 5 and got this error:</p>

<blockquote>
  <p>ERROR in src/app/app.component.ts(26,23): error TS2339: Property
  'distinctUntilChanged' does not exist on type 'Observable'.</p>
</blockquote>

<p>I've imported distinctUntilChanged in app.module.ts:</p>

<pre><code>import ""rxjs/add/operator/distinctUntilChanged"";
</code></pre>

<p>And my code in app.component.ts:</p>

<pre><code>import { Component } from ""@angular/core""; import { Router, NavigationEnd } from ""@angular/router"";
import { TranslateService } from ""@ngx-translate/core"";
import { GeoService } from ""app/services/geo.service"";
import { ArbeteService } from ""app/services/arbete.service"";
import { GoogleAnalyticsEventsService } from ""app/services/google-analytics-events.service"";

import * as _ from ""lodash"";

@Component({
    selector: ""app-root"",
    templateUrl: ""./app.component.html"",
    styleUrls: [""./app.component.scss""]
})
export class AppComponent {

        //Send pageview to Google Analytics
        router.events.distinctUntilChanged((previous: any, current: any) =&gt; {
        if (current instanceof NavigationEnd) {
            return previous.url === current.url;
        }
        return true;
    }).subscribe((x: any) =&gt; {
        googleAnalytics.emitVirtualPageView(""Rekryteringsguiden"", ""Rekryteringsguiden"");
    });
</code></pre>

<p>What am I missing here?</p>
","7208045","","","","","2019-05-31 18:23:38","Property 'distinctUntilChanged' does not exist on type 'Observable<Event>'","<angular><angular5><angular6><rxjs5><rxjs6>","3","0","1","","","CC BY-SA 4.0"
"52759075","2","","52758954","2018-10-11 11:34:49","","6","","<pre><code>import { distinctUntilChanged } from 'rxjs/operators';

router.events.pipe(distinctUntilChanged((previous: any, current: any) =&gt; {})).subscribe();
</code></pre>
","571156","","391715","","2019-05-31 18:23:38","2019-05-31 18:23:38","","","","0","","","","CC BY-SA 4.0"
"52760890","1","52761241","","2018-10-11 13:09:40","","3","6428","<p>I am trying to upgrade to Angular 6 from 5 and got this error:</p>

<blockquote>
  <p>ERROR in src/app/services/http.service.ts(17,14): error TS2339:
  Property 'timeout' does not exist on type 'Observable'.</p>
</blockquote>

<p>My code in http.service.ts:</p>

<pre><code>import { throwError as observableThrowError,  Observable } from 'rxjs';
import { Injectable } from '@angular/core';
import { environment } from ""environments/environment"";
import { AppService } from 'app/app.service';
import { HttpClient } from '@angular/common/http';

@Injectable()
export class HttpService {

    private baseUrl = environment.apiUrl;

    constructor(private http: HttpClient, private appService: AppService) { }

    public get(endpoint: string): Observable&lt;any&gt;{
        return this.http.get(this.baseUrl + endpoint)
            .timeout(this.appService.timeoutInterval)
            .retryWhen(error =&gt; error.delay(this.appService.waitInterval)
                .take(this.appService.numberOfRetries)
                .concat(observableThrowError(new Error())))
            .share();
    }
}
</code></pre>

<p>What am I missing here?</p>
","7208045","","1205871","","2018-10-11 13:28:51","2020-06-04 06:56:38","Property 'timeout' does not exist on type 'Observable<Object>'","<angular><angular5><angular6><rxjs5><rxjs6>","4","1","","","","CC BY-SA 4.0"
"52761241","2","","52760890","2018-10-11 13:26:30","","1","","<p>You should be updating with ng update - see <a href=""https://blog.angular.io/version-6-of-angular-now-available-cc56b0efa7a4"" rel=""nofollow noreferrer"">https://blog.angular.io/version-6-of-angular-now-available-cc56b0efa7a4</a> (scroll down a little)</p>

<p>As per this link, this will auto install <code>rxjs-compat</code> which will enable support for RxJs v5 and v6</p>

<p>You could however install <code>rxjs-compat</code> manually if you want.</p>

<p>This will ease the transition for ng5 to ng6 and then (optionally) pull it out later in a more RxJs focused task.</p>
","1205871","","","","","2018-10-11 13:26:30","","","","1","","","","CC BY-SA 4.0"
"52802608","1","","","2018-10-14 12:24:51","","1","218","<p>I am trying to test an effect with Jasmine.</p>

<p>Unfortunaltely I don't manage to get the completion as I don't know how to mock pipeable operator...</p>

<pre><code>@Effect()
initData$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(INIT_DATA_ACTION),
    tap(() =&gt; {
        this.loadingService.showLoading();
    }),
    switchMap((data: any) =&gt; {
        return this.store.pipe(
            select(getAppDataResolved),
            take(1),
            switchMap((resolved: boolean) =&gt; {
                console.log('resolved');
                if (!resolved) {
                    return this.dataService.getInitData(this.loginService.user.id).pipe(
                        tap(() =&gt; {
                            this.loadingService.hideLoading();
                        }),
                        switchMap((response: any) =&gt; {

                            return Observable.from([
                                new AislesInitDataAction(response.userAisles),
                                new ItemsInitDataAction(response.userItems),
                                new ListsInitDataAction(response.userLists),
                                new ShopsInitDataAction(response.userShops),
                                new InitDataResolvedAction(),
                            ]);
                        }
                    ));
                } else {
                    this.loadingService.hideLoading();
                    return of(new InitDataResolvedAction());
                }
            }
            ));
    }),
</code></pre>

<p><strong>My test:</strong></p>

<pre><code>fit('should return InitDataResolvedAction if resolved is true', () =&gt; {
    const spy = spyOn(store, 'pipe').and.returnValue(of(true));
    const spyOnLoadingService = spyOn(loadingService, 'showLoading');
    const action = new InitDataAction();
    const completion = new InitDataResolvedAction();

    actions$ = new ReplaySubject(1);
    actions$.next(action);

    effects.initData$.subscribe((a) =&gt; {
        console.log(a)
        // expect(a).toEqual(completion);
    });
});
</code></pre>

<p>All what I get is true as I mocked piped function.</p>

<p>Any idea how to mock operators used in pipe() ?</p>

<p>Thanks in advance</p>
","7256629","","5377805","","2018-10-14 12:54:21","2018-10-14 13:30:44","Testing with pipeable operator","<angular><karma-jasmine><rxjs5><angular-test>","0","1","","","","CC BY-SA 4.0"
"52812813","1","","","2018-10-15 08:44:37","","0","354","<p>Is there an observable in RxJS that emits in a date range?</p>

<p>For instance, <code>interval(1000)</code> would emit every second. I could use this to check the current date, but I didn't know if RxJS (or JavaScript really) has a method I could hook into that emits when subscribed based on if I'm in a certain date range or at a specific time like October 1st, 2019 at midnight.</p>
","1624862","","","","","2018-10-15 14:53:32","RxJS Observable that emits in a date range?","<rxjs><scheduled-tasks><scheduler><rxjs5><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52833823","1","52922986","","2018-10-16 10:53:52","","-2","803","<p>I have multiple requests with dynamic parameter array parameter in observable interval. So how can I return a subject based on the array parameter. Because of the <code>BehaviorSubject</code> contain all data in it</p>

<p><strong>initialize subject</strong></p>

<pre><code>getSchedularData: BehaviorSubject &lt; any &gt; = new BehaviorSubject &lt; any &gt; (null);
constructor(private httpClient: HttpClient, ) {
  SchedulerStore.select('jobSchedulerState')
    .subscribe(response =&gt; {
      this.schedularDataCollector = response;
    });
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>this.schedulerService.startScheduler(this.channelList1)
  .subscribe((value) =&gt; {
    // console.log(value);
    // tslint:disable-next-line:forin
    for (const keys in value) {
      this.schedularData[keys] = value[keys];
    }
  });
</code></pre>

<p><strong>service</strong></p>

<pre><code>Observable.interval((!this.backChannelEnvironment.schedularInterval) ? 10000 : this.backChannelEnvironment.schedularInterval)
  .pipe(
    map(() =&gt; {
      /**
       * dispatch request for schedular for requesting http request for channel
       */
      this.SchedulerStore.dispatch(new SchedulerAction.GetScheduler(Channels));
    })
  )
  .subscribe(() =&gt; {
    /**
     * get data from schedular store and return it at schedular interval
     */
    if (this.schedularDataCollector != null) {
      if (JSON.stringify(this.schedularDataCollector['jobScheduler']) !==
        JSON.stringify(this.getSchedularData.value)) {

        this.getSchedularData.next(this.schedularDataCollector['jobScheduler']);
      }
    }
  });
return this.getSchedularData.asObservable();
</code></pre>
","5181115","","2622292","","2018-10-26 13:53:20","2018-10-26 13:53:20","RXJS subject and behaviour subject","<angular><rxjs5><rxjs6>","2","3","","","","CC BY-SA 4.0"
"52849930","1","52850402","","2018-10-17 07:57:27","","1","913","<p>I have two sequential subscriptions:</p>
<pre><code> this.authService.tokenObs.pipe( map(res =&gt; res),mergeMap( token =&gt;
    this.service.getUsers(token).subscribe(res2=&gt;{
            console.log('res2', res2)
  })
));
</code></pre>
<p>I get error on token param within merge map:</p>
<blockquote>
<p>Argument of type '(token: {}) =&gt; Subscription' is not assignable to</p>
<p>parameter of type '(value: {}, index: number) =&gt; ObservableInput&lt;{}&gt;'.</p>
<p>Type 'Subscription' is not assignable to type 'ObservableInput&lt;{}&gt;'.</p>
<p>Type 'Subscription' is not assignable to type 'ArrayLike&lt;{}&gt;'.</p>
<p>Property 'length' is missing in type 'Subscription'. (parameter) token: {}</p>
</blockquote>
<p>I am using mergeMap for first time so not familiar with this error.</p>
","3032338","","-1","","2020-06-20 09:12:55","2018-10-17 09:59:39","Getting Error when using mergeMap to merge two sequential subscriptions in Angular","<angular><observable><rxjs5>","2","0","","","","CC BY-SA 4.0"
"52850402","2","","52849930","2018-10-17 08:25:55","","1","","<p>You need to modify your code like below</p>

<pre><code>this.authService.tokenObs.pipe(
     map(res =&gt; res),
     mergeMap(this.service.getUsers(token))
).subscribe(res2=&gt;{
    console.log('res2', res2)
});
</code></pre>

<hr>

<p>Since you are new to this, Can you take a look at the working example <a href=""https://stackblitz.com/edit/angular-gsefpz"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-gsefpz</a></p>

<pre><code>import { Component } from '@angular/core';
import { map, mergeMap } from 'rxjs/operators';
import { HttpClient} from '@angular/common/http';

@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  name = 'Angular';

  constructor(public http: HttpClient) {
    this.http.get('https://jsonplaceholder.typicode.com/users').pipe(
      map(res =&gt; res[0].id),
      mergeMap(id =&gt; this.http.get(`https://jsonplaceholder.typicode.com/posts?userId=${id}`))
    ).subscribe(res2 =&gt; {
      console.log('res2', res2)
    });
  }
}
</code></pre>

<hr>

<p>EDIT 2:</p>

<p><a href=""https://stackblitz.com/edit/angular-gsefpz"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-gsefpz</a></p>

<p>Updated the code for handling error. Test the error case you changing it to wrong url. </p>

<pre><code>import { Component } from '@angular/core';
import { map, mergeMap, tap, catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  name = 'Angular';

  constructor(public http: HttpClient) {
    this.http.get('https://jsonplaceholder.typicode.com/users').pipe(
      tap(data =&gt; console.log('data &gt;&gt;&gt; ', data)),
      map(res =&gt; res[0].id),
      tap(data =&gt; console.log('transformed data &gt;&gt;&gt; ', data)),
      mergeMap(id =&gt; this.http.get(`https://jsonplaceholder.typicode.com/posts?userId=${id}`)),
      catchError(error =&gt; {
        console.log('ERROR &gt;&gt;&gt;&gt; ', JSON.stringify(error));
        return throwError({ status: error.status, errorMsg: error.statusText });
      })
    ).subscribe(res2 =&gt; { console.log('res2', res2) }, err =&gt; console.log(err));
  }
}
</code></pre>

<hr>

<p><strong>EDIT 3</strong>
for rxjs 5.5
<a href=""https://stackblitz.com/edit/angular-5-tutorial-yzowvt"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-5-tutorial-yzowvt</a></p>

<pre><code>import { Component } from '@angular/core';
import {HttpClient} from '@angular/common/http';
import { Observable } from 'rxjs';

  constructor(public http: HttpClient) {
    this.http.get('https://jsonplaceholder.typicode.com/users')
    .do(data =&gt; console.log('data &gt;&gt;&gt; ', data))
    .map(res =&gt; res[0].id)
    .do(data =&gt; console.log('transformed data &gt;&gt;&gt; ', data))
    .mergeMap(id =&gt; this.http.get(`https://jsonplaceholder.typicode.com/posts?userId=${id}`))
    .catch(error =&gt; {
        console.log('ERROR &gt;&gt;&gt;&gt; ', JSON.stringify(error));
        return Observable.throw({ status: error.status, errorMsg: error.statusText });
    })
    .subscribe(res2 =&gt; { console.log('res2', res2) }, err =&gt; console.log(err));
  }
</code></pre>
","571156","","571156","","2018-10-17 09:59:39","2018-10-17 09:59:39","","","","7","","","","CC BY-SA 4.0"
"52922986","2","","52833823","2018-10-22 05:38:09","","1","","<p>You can try below one as we are having almost same implementation as you have : </p>

<pre><code>private requests: Request[];
private observableRequests: BehaviorSubject&lt;Request[]&gt;;  

constructor() {
  this.requests = new Array&lt;Request&gt;;  
  this.observableRequests = &lt;BehaviorSubject&lt;Request[]&gt;&gt;new BehaviorSubject([]);
}

get requests() {
  return this.observableRequests.asObservable();
}

addRequest(request: Request) {
  this.requests.push(request);
  this.observableRequests.next(this.requests);
}
</code></pre>

<p>Here all request object will return whenever array is you call <strong>addRequest</strong>.
You have to do some workaround in that method as per your requirement.</p>
","7334873","","","","","2018-10-22 05:38:09","","","","0","","","","CC BY-SA 4.0"
"52978032","1","52978617","","2018-10-24 21:17:22","","3","444","<p>I am using rxjs 6 and I am executing two async operations where the order is important. </p>

<p>I do have this chunk of code which works perfectly: </p>

<pre><code>dbmsProxy.createDatastores().subscribe(() =&gt; {
    UsersDAO.insert(users).subscribe(() =&gt; {
        console.log('FINISHED ALL THE CHAIN');
    });
});
</code></pre>

<p>But when I try to use <code>concat</code> of <code>rxjs</code> I do have an issue because the second one is executed before the first one finishes: </p>

<pre><code>concat([dbmsProxy.createDatastores(), UsersDAO.insert(users)]).subscribe();
</code></pre>

<p>Below the DBMSProxy methods</p>

<pre><code>public createDatastores(): Observable&lt;string&gt; {
    const _this: DBMSProxy = this;
    const subject = new Subject&lt;string&gt;();
    const subscription: Subscription = UsersDAO.createDatastore().subscribe(
        onSuccess,
        onError,
        onFinally
    );
    return subject;

    function onSuccess(datastore: Nedb): void {
        console.log(`USERS Datastore Created Successfully`);
        _this.db.users = datastore;
        subject.next('success');
    }

    function onError(err: string) {
        subject.error('error');
        console.error(err);
    }

    function onFinally() {
        subject.complete();
        subscription.unsubscribe();
    }
}

public insertDocuments(documents: any, datastore: Nedb): Subject&lt;any&gt; {
    const subject = new Subject&lt;any&gt;();
    datastore.insert(documents, onInsert);
    return subject;

    function onInsert(err: Error, newDocuments: any) {
        if (err) {
            subject.error(err);
        } else {
            // add to the documents to insert the id just created from nedb when inserting the document
            documents.forEach((document: any, ind: number) =&gt; {
                document.id = newDocuments[ind]._id;
            });
            subject.next(documents);
        }
        subject.complete();
    }
}
</code></pre>

<p>And below the UsersDAO methods: </p>

<pre><code>public static createDatastore(): Subject&lt;Nedb | string&gt; {
        const subject = new Subject&lt;Nedb | string&gt;();
        const datastore = new Nedb({
            filename: USERS_DATASTORE_FULL_NAME,
            autoload: true,
            onload
        });
        return subject;

        function onload(err: Error) {
            if (err) {
                subject.error(
                    `Error creating USERS datastore: ${err.name} - ${err.message}`
                );
            } else {
                subject.next(datastore);
            }
            subject.complete();
        }
    }

    public static insert(users: User[]): Observable&lt;any&gt; {
        return DBMSProxy.getInstance()
            .insertDocuments(users, DBMSProxy.getInstance().db.users)
            .pipe(catchError((val: any) =&gt; of('Error inserting the users')));
    }
</code></pre>

<p>Any idea of what's going on please? </p>
","2652759","","","","","2018-10-24 22:47:30","Rxjs issue with the concat operator when executing operations sequentially","<javascript><typescript><rxjs><rxjs5><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"52978617","2","","52978032","2018-10-24 22:13:12","","4","","<p>My current solution is to convert the <code>Subject</code> to <code>Observable</code>, create a new Observable with the second one, and remove the square brackets (otherwise I will get back the observables and not the results) and this seems to work:</p>

<pre><code>const operations = concat(
    dbmsProxy.createDatastores().asObservable(),
    defer(() =&gt; UsersDAO.insert(users))
);
operations.subscribe(onSubscribe);
function onSubscribe(result: any) {
    console.log('Finished all: ', result);
}
</code></pre>
","2652759","","2652759","","2018-10-24 22:47:30","2018-10-24 22:47:30","","","","7","","","","CC BY-SA 4.0"
"53056457","1","","","2018-10-30 02:16:50","","4","889","<p>This is some code from an angular component. It is a search component where <code>characterIndexes</code> is an array of search results. </p>

<p>The search results are retrieved by typing in a searchbox which triggers the <code>searchtrigger</code> or <code>searchEmptyTrigger</code> depending on its content. After getting the first results I have to perform another <code>http.post()</code> to get the names belonging to the indexes so I can sort them ( I omitted that part from the code ). Then the results are inserted in the <code>characterIndex</code>-array.</p>

<p>A similar thing happens when <code>searchEmptyTrigger</code> is triggered. Except for the <code>characterIndex</code>-array is just set to empty and no http-requests are needed.</p>

<p>The issue I run into is that in some cases, when the <code>searchEmptyTrigger</code> is triggered, the code from the <code>searchtrigger</code> is still running ( due to delays because of the http-requests ). </p>

<p>The result is that the <code>characterIndexes</code> are empty first. And then it would fill up again after receiving the result from the http-request in the <code>searchtrigger</code>.</p>

<p>So the big question is: <strong>'How to cancel my running <code>http.post()</code> while it is waiting for a response?'</strong></p>

<pre><code>  public characters: any[];
  public characterIndexes: number[];

  let searchBox = document.getElementById('search-box');
  let searchTrigger = fromEvent(searchBox, 'input')
  .pipe(
    map((event: any) =&gt; event.target.value ),
    filter( text =&gt; text.length &gt; 2 ),
    debounceTime( 500 ),
    distinctUntilChanged(),
    switchMap( text =&gt;  ajax(`https://esi.evetech.net/v2/search/?categories=character&amp;datasource=tranquility&amp;language=en-us&amp;search=^${text}&amp;strict=false`)
    )
  );

  let searchEmptyTrigger = fromEvent(searchBox, 'input')
  .pipe(
    map((event: any) =&gt; event.target.value ),
    filter( text =&gt; text.length &lt;= 2 )
  );

  searchTrigger.subscribe( response =&gt; {
    if( response.response.character ){
      let characterIndexes = response.response.character;
        this.http.post('https://esi.evetech.net/latest/universe/names/?datasource=tranquility', characterIndexes)
        .subscribe( (charactersInfo: any[]) =&gt; {
           // do some stuff with this.characterIndexes and this.characters = [];
        });
      } else {
        this.characterIndexes = [];
        this.characters = [];
      }
    });

    searchEmptyTrigger.subscribe( () =&gt; {
      // reset values 
      this.characterIndexes = [];
      this.characters = [];
    });
</code></pre>

<p>PS: I am also open for an alternate approach that performs the same operations as the code above, where I can cancel the http-request.</p>
","4182029","","3198804","","2018-10-30 02:46:19","2018-10-31 14:45:05","How to cancel a http.post() while it is waiting for a response?","<angular><rxjs><angular6><rxjs5>","3","0","2","","","CC BY-SA 4.0"
"53162040","1","53162314","","2018-11-05 20:52:43","","1","757","<p>I have a stream who starts by an http request : </p>

<pre><code>this.myService.getData()
</code></pre>

<p>After getting the data, I have a filter operator :</p>

<pre><code>.filter(() =&gt; boolean)
</code></pre>

<p>In this filter I want to wait an answer from the user, like 'Do you want to continue ?' Then the user click on 'Yes' or 'No'.</p>

<p>If the user clicks on 'Yes' then the stream continue with data.</p>

<p>If the user clicks on 'No' then the filter does its job.</p>

<p>It works fine with the confirm() native function but I need a custom modal, I won't use package like @angular/material, because I would like to know how to do this from scratch.</p>

<p>I'm pretty sure that a good way is to use Promise stuffs in the stream.</p>

<p>Do you how to resolve it ?</p>
","5627096","","","","","2018-11-05 21:14:22","Rxjs, how to pause the stream and wait the user click","<angular><rxjs5>","1","0","","","","CC BY-SA 4.0"
"53162314","2","","53162040","2018-11-05 21:14:22","","2","","<p>Initialize a subject on your component and call the .next() function when the user clicks any button on the modal. Then pipe the getData Observable into flatMap and evaluate the next value emitted by the subject. </p>

<pre class=""lang-js prettyprint-override""><code>public onModalButtonClick = new Subject&lt;boolean&gt;();
public openModal(): void {
    this.showModal = true;
    this.http.get('https://jsonplaceholder.typicode.com/todos/1').pipe(
      flatMap(data =&gt; {
        return this.onModalButtonClick.pipe(
          take(1),
          flatMap((bool) =&gt; bool? of(data) : throwError(""abort button clicked""))
        )
      }),
      finalize(() =&gt; this.showModal = false)
    ).subscribe(data =&gt; {
        console.log(data);
      }, error =&gt; {
        console.log(error);
      });
  }
</code></pre>

<p>I made a simple blitzstack. You may need to adjust this for your needs: <a href=""https://stackblitz.com/edit/angular-zkx7kf?file=src%2Fapp%2Fhello.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-zkx7kf?file=src%2Fapp%2Fhello.component.ts</a></p>
","9874983","","","","","2018-11-05 21:14:22","","","","3","","","","CC BY-SA 4.0"
"53239457","1","53239489","","2018-11-10 13:30:49","","0","781","<p>I have two <code>Observable</code> requests to server:</p>

<pre><code>this.initService.__init__(res).subscribe((profile) =&gt; {
    console.log(profile); // It works
    this.initService.initializePeriod(profile).subscribe((period) =&gt; {
        console.log(period); // It does not work
    });

});
</code></pre>

<p>When first gets response it calls second, but I can not get result for second subscribe. I know, better to use Promises in this case, but I need pass result from first request to second, promises dont allow to do this.</p>

<p>I tried to use this, but Alert message does not work:</p>

<pre><code> this.initService.__init__(res)
            .pipe(
              mergeMap(profile =&gt; this.initService.initializePeriod(profile)))
              .subscribe((response) =&gt; {
              alert('aa');

});
</code></pre>

<p>Also tried this:</p>

<pre><code>this.initService.__init__(res)
              .mergeMap(profile =&gt; this.initService.initializePeriod(profile))
              .subscribe((response) =&gt; {
              alert('aa');
});
</code></pre>
","8291684","","8291684","","2018-11-10 14:45:46","2018-11-10 16:16:14","How to get result of Observer in subscribe?","<angular><rxjs><rxjs5>","2","0","1","","","CC BY-SA 4.0"
"53239489","2","","53239457","2018-11-10 13:34:01","","2","","<p>You can use <code>switchMap</code> rxjs operators to chain the observables.</p>

<pre><code>import { switchMap } from 'rxjs/operators';

this.initService.__init__(res)
.pipe(
   switchMap(profile=&gt; this.initService.initializePeriod(profile))
).subscribe((period) =&gt; {
    console.log(period);
});
</code></pre>

<p>If you want to have response from both then use <code>mergeMap</code></p>

<pre><code>import { mergeMap } from 'rxjs/operators';

this.initService.__init__(res)
.pipe(
   mergeMap(
      profile=&gt; this.initService.initializePeriod(profile), 
     (profile, period) =&gt; {
       return [profile,period];
}
   )
).subscribe((response) =&gt; {
    console.log(response[0]); //profile
    console.log(response[1]); //period
});
</code></pre>

<p>Working copy is here - <a href=""https://stackblitz.com/edit/typescript-wy26a7"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-wy26a7</a></p>
","5166336","","5166336","","2018-11-10 15:50:32","2018-11-10 15:50:32","","","","5","","","","CC BY-SA 4.0"
"53248447","1","53248504","","2018-11-11 11:50:09","","1","689","<p>I have a quite simple request:
I would like to investigate the activateRoute observables (both paramMap and queryParamMap) - I would like set component variables according to the results of them.
Tried doing that using rxjs operators pipe and flatMap, but couldn't result it successfully.
See my code:</p>

<pre><code>param1: number;
param2: string;


ngOnInit() {
  this.activatedRoute.paramMap.pipe(
    flatMap(params =&gt; {
      this.param1 = +params.get(&lt;name Of Param&gt;);
      return this.activatedRoute.queryParamMap;
    }),
    flatMap(queryParams =&gt; {
      this.param2= queryParams.get(&lt;name of query param&gt;);
    })
  ).subscribe(result =&gt; /*no need to do anything*/);
</code></pre>
","6721134","","","","","2018-11-11 15:48:16","Investigate activatedRoute observables using rxjs operators","<angular><rxjs5><angular-observable><angular-activatedroute>","2","5","","","","CC BY-SA 4.0"
"53248504","2","","53248447","2018-11-11 11:58:13","","1","","<p>Actually you should use the <code>switchMap</code> instead of <code>mergeMap</code> since you don't need the result of all the Observable at the end.</p>

<pre><code>param1: number;
param2: string;

ngOnInit() {
  this.activatedRoute.paramMap.pipe(
    switchMap(params =&gt; {
      this.param1 = +params.get(&lt;name Of Param&gt;);
      return this.activatedRoute.queryParamMap;
    }),
    map(queryParams =&gt; {
      this.param2= queryParams.get(&lt;name of query param&gt;);
    })
  ).subscribe(result =&gt; /*no need to do anything*/);
</code></pre>
","5166336","","","","","2018-11-11 11:58:13","","","","2","","","","CC BY-SA 4.0"
"53282811","1","","","2018-11-13 14:06:11","","2","881","<p>I've been wondering if it's safe to assume that after the using the tap operator, the side effect inside it has completed.</p>

<p>My use case is with ngrx. </p>

<pre class=""lang-js prettyprint-override""><code> ...
tap(() =&gt; {
    this.store.dispatch(new SetValue(""Hello World""));
  }
}),
switchMap(() =&gt; this.store),
select(state =&gt; state.value),
tap(state =&gt; {
  if (state === undefined) {
    throw new Error(""Couldn't find value"");
  }
})
</code></pre>

<p>SetValue is an class that implements ngrx </p>

<pre class=""lang-js prettyprint-override""><code>export class SetValue implements Action {
  readonly type = SET_VALUE;
  constructor(public payload: string) {}
}
</code></pre>



<p>What I'm trying to implement is to set a value on the store and then check if it's effectively been set.</p>

<p>Can I assume the dispatch has completed after tap operator?</p>

<p><strong>Answer</strong></p>

<p>I used this on <em>Angular Router guards</em> to set initial state by the parameters on the url, so I ended up filtering to only continue when the store has new value</p>

<pre class=""lang-js prettyprint-override""><code> ...
tap(() =&gt; this.store.dispatch(new SetValue(""Hello World""))),
switchMap(() =&gt; this.store),
select(state =&gt; state.value),
filter(value =&gt; value === ""Hello World""),
take(1)
</code></pre>
","7037861","","7037861","","2019-03-12 17:10:27","2019-03-12 17:10:27","RxJS 6 / When does tap operator emit a value","<rxjs><ngrx><rxjs5><rxjs6><ngrx-store>","1","1","","","","CC BY-SA 4.0"
"53347696","2","","49683600","2018-11-17 02:38:18","","37","","<p>No. It unsubscribes automatically after calling <code>first()</code>. The current syntax is  <code>observable.pipe(first()).subscribe(func);</code> for RxJS 6.</p>
<p>The <a href=""https://rxjs-dev.firebaseapp.com/api/operators/first#description"" rel=""noreferrer"">documentation</a> states:</p>
<blockquote>
<p>If called with no arguments, <code>first</code> emits the first value of the source Observable, then completes.</p>
</blockquote>
","5387035","","11105280","","2020-11-10 09:41:24","2020-11-10 09:41:24","","","","4","","","","CC BY-SA 4.0"
"53528334","1","","","2018-11-28 21:23:20","","-1","597","<p>i am trying to use filter in angular 4, this is my code</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { range } from 'rxjs/observable/range';
import { map, scan, filter, tap } from 'rxjs/operators';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {  

  ngOnInit(){
    this.rxjs();
  }
  rxjs(){
    const source$ = range(1, 10);

    source$.pipe(
      filter(n =&gt; n % 2 !== 0), 
      tap(n =&gt; console.log('filtered value: ' + n)),
      map(n =&gt; n * n),
      tap(n =&gt; console.log('squared value: ' + n)),
      scan((acc,s) =&gt; acc + s, 0)
    )
    .subscribe(v =&gt; console.log(`sum of squared values : ${v}`));    
  }    
}
</code></pre>

<p>this is my angular version, which i found out using <strong>ng --version</strong> command</p>

<pre><code>@angular/cli: 1.4.10
node: 8.9.1
os: win32 x64
@angular/animations: 4.4.7
@angular/common: 4.4.7
@angular/compiler: 4.4.7
@angular/core: 4.4.7
@angular/forms: 4.4.7
@angular/http: 4.4.7
@angular/platform-browser: 4.4.7
@angular/platform-browser-dynamic: 4.4.7
@angular/router: 4.4.7
@angular/cli: 1.4.10
@angular/compiler-cli: 4.4.7
@angular/language-service: 4.4.7
typescript: 2.3.4
</code></pre>

<p>but when i compile, i am getting an error like this</p>

<blockquote>
  <p>ERROR in E:/angular-mock/routes/src/app/app.component.ts (19,19): The
  left-hand side of an arithmetic operation must be of type 'any',
  'number' or an enum type.</p>
</blockquote>

<p>can anyone help me on what i am doing wrong in this</p>
","2711059","","","","","2019-03-14 13:11:48","Not able to use filter operators of rxjs in angular4","<angular><rxjs5><rxjs-pipeable-operators>","2","8","","","","CC BY-SA 4.0"
"53544393","1","53544484","","2018-11-29 17:18:59","","1","23","<p>How can I do the following? </p>

<pre><code>let button = document.querySelector('.this');
let clickStream = Observable.fromEvent(button, 'click');
let multiClickStream = clickStream
   .buffer(() =&gt; { return clickStream.throttleTime(250); } )
   .map(function(list) { return list.length; })
   .filter(function(x) { return x &gt;= 2; });
</code></pre>

<p>The error message is: </p>

<blockquote>
  <p>TS2345: argument of type '()=> void' is not assignable to paramter of
  type Observabl. Property '_isScalar' is missing in type ()=>void</p>
</blockquote>

<p>Alternatives like <code>"".buffer(function() { return clickStream.throttleTime(250); })
""</code> give a similar error. </p>

<p>I also tried <code>throttle(250)</code>, but that does not work neither. </p>
","3143823","","310726","","2018-11-29 17:22:59","2018-11-29 17:25:13","RxJs v5 in Angular5 - clickStream.bufer( () => clickStream.throttleTime(250)) etc fails","<angular><rxjs><rxjs5>","1","0","1","","","CC BY-SA 4.0"
"53544484","2","","53544393","2018-11-29 17:25:13","","2","","<p>It looks like you wanted to use <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-bufferWhen"" rel=""nofollow noreferrer""><code>bufferWhen</code></a> that accepts a function as an argument.</p>

<p>Otherwise just pass the Observable directly to <code>buffer</code> without wrapping it:</p>

<pre><code>...
.buffer(clickStream.throttleTime(250))
</code></pre>
","310726","","","","","2018-11-29 17:25:13","","","","0","","","","CC BY-SA 4.0"
"53562113","1","","","2018-11-30 17:19:30","","0","76","<p>I am trying to migrate some code from Angular 5 to Angular 7. I tried the official update guide, but not everything was migrated. So I tried it manually, but I can not get it to work.</p>

<p>This is  Angular 5 Code </p>

<pre class=""lang-js prettyprint-override""><code>getNodes(): Observable &lt; Node[] &gt; {
   return Observable.create(obs =&gt; {
     ros.getNodes(data =&gt; {
      obs.next(data);
      obs.complete();
     });
   }).flatMap(data =&gt; {
     return Observable.forkJoin(data.map(name =&gt; Observable.create(obs =&gt; {
       const detailClient = new ROSLIB.Service({
         ros: ros,
         name: '/rosapi/node_details',
         serviceType: 'rosapi/NodeDetails'
       });
       const request = new ROSLIB.ServiceRequest({ node: name });
       detailClient.callService(request, data2 =&gt; {
         obs.next({ name, subscribing: data2.subscribing });
         obs.complete();
       });
     })));
   });
 }
 loadData(): void {
   Observable.forkJoin(this.getNodes()).subscribe(([nodes]) =&gt; {
     //this.data.nodes = nodes;
     console.log(nodes);
   });
 }
</code></pre>

<p>And the output of console.log is the following and the new Angular 7 code should look like the same </p>

<pre class=""lang-js prettyprint-override""><code>[
  {
    ""name"": ""/mission_controller""
  },
  {
    ""name"": ""/mavros""
  },
  {
    ""name"": ""/pose_analyser""
  }
]
</code></pre>

<p>This is what I tried, but it gives me the error ""Property 'pipe' does not exist on type '{}'""</p>

<pre class=""lang-js prettyprint-override""><code>getNodes(): Observable&lt;Node[]&gt; {
  return Observable.create(obs =&gt; {
    ros.getNodes(data =&gt; {
      obs.next(data);
      obs.complete();
    });
  }).pipe(mergeMap( data =&gt; {
    return forkJoin(data.pipe(map(name =&gt; Observable.create(obs =&gt; {
      const detailClient = new ROSLIB.Service({
        ros: ros,
        name: '/rosapi/node_details',
        serviceType: 'rosapi/NodeDetails'
      });
      const request = new ROSLIB.ServiceRequest({ node: name });
      detailClient.callService(request, data2 =&gt; {
        obs.next({ name });
        obs.complete();
      });
    }))));
  }));
}
loadNodes(): void {
  forkJoin(this.getNodes()).subscribe(([nodes]) =&gt; {
    console.log(nodes);      
  });
}
</code></pre>

<p>I hope somebody can help me</p>

<p>Best regards </p>

<p>newsub7</p>
","10728632","","7109869","","2018-12-08 19:07:35","2018-12-08 19:07:35","Problem migrating code from Angular 5 to Angular 7","<angular><rxjs5><angular7><rxjs6>","0","8","","","","CC BY-SA 4.0"
"53619503","1","53619577","","2018-12-04 18:42:00","","2","967","<p>I have method described in component (controller):</p>

<pre><code>public requestPassportData(): void {
    const th = this;
    const data = {
      get_scanned_data: true
    };

    Observable.timer(0, 1000)
      .switchMap(() =&gt; this.requestMethods.requestPassportData(data))
      .takeWhile(() =&gt; {
        return (
          th.formRegister.currentForm().index == 1 ||
          th.formRegister.currentForm().index == 2 ||
          th.formRegister.currentForm().index == 3
        );
      })
      .subscribe(response =&gt; {});
}
</code></pre>

<p>If to call method <code>requestPassportData()</code> five times, it will send each second five request to server. Why switchMap does not cancel last observer?</p>
","8291684","","","","","2018-12-07 08:49:24","Why switchMap does not cancel previous observer?","<angular><rxjs><rxjs5>","1","1","1","","","CC BY-SA 4.0"
"53619577","2","","53619503","2018-12-04 18:48:13","","5","","<p>Because every time you call <code>requestPassportData()</code> you'll create a new chain with new <code>Observable.timer</code> that has nothing to do with the previous calls.</p>

<p>There are obviously multiple ways to solve this but you can for example do the following:</p>

<pre><code>private requestPasswordSubject$ = new Subject();

private requestPassword = this.requestPasswordSubject$
  .switchMap(() =&gt; Observable.timer(0, 1000)
    .switchMap(() =&gt; this.requestMethods.requestPassportData(data))
    .takeWhile(() =&gt; {
      return (
         th.formRegister.currentForm().index == 1 ||
         th.formRegister.currentForm().index == 2 ||
         th.formRegister.currentForm().index == 3
      );
    });
  )
  .subscribe(response =&gt; {});

public requestPassportData(): void {
  ...
  this.requestPasswordSubject$.next();
}
</code></pre>

<p>Actual implementation depends on what exactly you're trying to achieve but hopefully you get the point what is different to what you have now.</p>
","310726","","310726","","2018-12-07 08:49:24","2018-12-07 08:49:24","","","","5","","","","CC BY-SA 4.0"
"53712345","1","53731708","","2018-12-10 19:27:41","","2","991","<p>I've got a service call that loads ten items onto the screen. When users click a ""View More"" button, I send another call to the service with different paging arguments. What's the best way to gracefully append the new array of items from the second call into the existing array emitted by the first call?</p>

<p>My example below technically works, but it resets the original observable, refreshing all items on the screen, rather than just adding the new ones. Thoughts? Could Subjects help with this?</p>

<pre><code>private onViewMoreClicked(): void {
    this.pageOffset += this.pageLimit;

    const moreItems$ = this.itemService.get(
        this.pageLimit,
        this.pageOffset
    );

    this.items$ = forkJoin(this.items$, moreItems$).pipe(
        map(([a, b]) =&gt; [...a, ...b])
    );
</code></pre>
","6757270","","","","","2018-12-11 20:16:47","How to append an Observable array to existing one consumed via Angular async pipes?","<angular><rxjs><rxjs5><rxjs6>","2","1","","","","CC BY-SA 4.0"
"53731708","2","","53712345","2018-12-11 20:16:47","","0","","<p>Maybe try something like <a href=""https://stackoverflow.com/a/48677496/251614"">this</a> or this...</p>

<p>Setup in the on-initâ¦</p>

<pre><code>ngOnInit() {
   this.pageOffset = 0;

    this.items$ = this.nextPage$.pipe(
        // load first batch when Angular async pipe subscribes
        startWith(this.pageOffset),
        // switch observable to output of getMessages
        switchMap(offset =&gt; this.itemService.get(
            this.pageLimit,
            offset
        )),
        // add newly-emitted batch to previously-emitted items
        scan((acc, curr) =&gt; {
            acc.push(...curr);
            return acc;
        }, [])
    );
}
</code></pre>

<p>And this should be the view more click handlerâ¦</p>

<pre><code>private onViewMoreClicked(): void {
   this.pageOffset += this.pageLimit;

   // load new items into message$  
    this.nextPage$.next(this.pageOffset);
}
</code></pre>
","251614","","","","","2018-12-11 20:16:47","","","","0","","","","CC BY-SA 4.0"
"53798142","1","","","2018-12-15 23:31:05","","6","557","<p>My usecase is this: I connect to a service with a websocket and get periodic (but unpredictable) health data from the service.  The app may have multiple users of this data stream, so I want to share it.  New subscribers should see the most recently emitted health data.  I also want to close the websocket when there are no more subscribers.</p>
<p>My app used <code>shareReplay(1)</code> for quite some time, until it was discovered that it leaks the underlying connection (<a href=""https://blog.strongbrew.io/share-replay-issue/"" rel=""nofollow noreferrer"">https://blog.strongbrew.io/share-replay-issue/</a>).  At which point we changed to <code>pipe(publishReplay(1), refCount)</code>.  It turns out that this also has a subtly that I did not expect:</p>
<ol>
<li>Subscriber A connects &amp; the websocket connection is established.</li>
<li>Subscriber B connects and shares correctly, as well as getting the most recent data.</li>
<li>Both A and B disconnect.  The websocket is torn down</li>
<li>Subscriber C connects, but only needs one value <code>take(1)</code>.  The value that is cached by the <code>publishReplay(1)</code> is returned.</li>
</ol>
<p>In step 4 I really wanted the websocket to be re-created.  The cached value is of no use.  The timewindow parameter of <code>publishReplay</code> is tempting, but also not quite what I want.</p>
<p>I've managed to find a solution, by using <code>pipe(multicast(() =&gt; new ReplaySubject(1)), refCount())</code>, but I don't know Rx well enough to understand the full implications of this.</p>
<p>My question is - what's the best way to achieve the behaviour I want?</p>
<p>Thanks!</p>
<p>Code sample can be seen at <a href=""https://repl.it/@bradb/MinorColdRouter"" rel=""nofollow noreferrer"">https://repl.it/@bradb/MinorColdRouter</a>
Inline code</p>
<pre class=""lang-js prettyprint-override""><code>    const { Observable, ReplaySubject } = require('rxjs');
    const { tap, multicast, take, publishReplay, refCount } = require('rxjs/operators');
    
    const log = console.log;
    
    function eq(a, b) {
      let result = JSON.stringify(a) == JSON.stringify(b);
      if (!result) {
        log('eq failed', a, b);
      }
      return result;
    }
    
    function assert(cond, msg) {
      if (!cond) {
        log('****************************************');
        log('Assert failed: ', msg);
        log('****************************************');
      }
    }
    
    function delay(t) {
      return new Promise(resolve =&gt; {
        setTimeout(resolve, t);
      });
    }
    
    let liveCount = 0;
    
    // emitValue 1 happens at 100ms, 2 at 200ms etc
    function testSource() {
      return Observable.create(function(observer) {
        let emitValue = 1;
        liveCount++;
        log('create');
        let interv = setInterval(() =&gt; {
          log('next --------&gt; ', emitValue);
          observer.next(emitValue);
          emitValue++;
        }, 100);
    
        return () =&gt; {
          liveCount--;
          log('destroy');
          clearInterval(interv);
        };
      });
    }
    
    async function doTest(name, o) {
      log('\nDOTEST: ', name);
      assert(liveCount === 0, 'Start off not live');
      let a_vals = [];
      o.pipe(take(4)).subscribe(x =&gt; {
        a_vals.push(x);
      });
      await delay(250);
      assert(liveCount === 1, 'Must be alive');
    
      let b_vals = [];
      o.pipe(take(2)).subscribe(x =&gt; {
        b_vals.push(x);
      });
      assert(liveCount === 1, 'Two subscribers, one source');
      await delay(500);
      assert(liveCount === 0, 'source is destroyed');
      assert(eq(a_vals, [1, 2, 3, 4]), 'a vals match');
      assert(eq(b_vals, [2, 3]), 'b vals match');
    
      let c_vals = [];
      o.pipe(take(2)).subscribe(x =&gt; {
        c_vals.push(x);
      });
      assert(liveCount === 1, 'Must be alive');
    
      await delay(300);
      assert(liveCount === 0, 'Destroyed');
      assert(eq(c_vals, [1, 2]), 'c_vals match');
    }
    
    async function main() {
      await doTest(
        'bad: cached value is stale',
        testSource().pipe(
          publishReplay(1),
          refCount()
        )
      );
      await doTest(
        'good: But why is this different to publish replay?',
        testSource().pipe(
          multicast(() =&gt; new ReplaySubject(1)),
          refCount()
        )
      );
      await doTest(
        'bad: But why is this different to the above?',
        testSource().pipe(
          multicast(new ReplaySubject(1)),
          refCount()
        )
      );
    }
    main();
</code></pre>
","1502846","","15159603","","2021-09-13 12:36:53","2021-09-13 12:36:53","Rxjs - unexpected publishReplay + refCount behaviour after refCount goes to 0","<rxjs><rxjs5><rxjs6>","1","3","1","","","CC BY-SA 4.0"
"53847764","1","","","2018-12-19 09:03:30","","1","1710","<p>The component.ts file is given below. Why it is throwing an error even after importing interval from rxjs/add/observable/interval.</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/interval';
@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {

  constructor() { }
  ngOnInit() {
      const myNumber = Observable.interval(1000);
      myNumber.subscribe(
        (number: number) =&gt; {
          console.log(number);
        }
      );
  }
}
</code></pre>

<p><strong>Error Messages in the browser:</strong></p>

<blockquote>
  <p>ERROR TypeError:
  rxjs_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable.interval is
  not a function
      at HomeComponent.push../src/app/home/home.component.ts.HomeComponent.ngOnInit
  (home.component.ts:15)
      at checkAndUpdateDirectiveInline (core.js:20665)
      at checkAndUpdateNodeInline (core.js:21929)
      at checkAndUpdateNode (core.js:21891)
      at debugCheckAndUpdateNode (core.js:22525)
      at debugCheckDirectivesFn (core.js:22485)
      at Object.eval [as updateDirectives] (HomeComponent_Host.ngfactory.js? [sm]:1)
      at Object.debugUpdateDirectives [as updateDirectives] (core.js:22477)
      at checkAndUpdateView (core.js:21873)
      at callViewAction (core.js:22114) View_HomeComponent_Host_0 @ HomeComponent_Host.ngfactory.js? [sm]:1 proxyClass @ compiler.js:17945
  push../node_modules/@angular/core/fesm5/core.js.DebugContext_.logError
  @ core.js:22729
  push../node_modules/@angular/core/fesm5/core.js.ErrorHandler.handleError
  @ core.js:14645 (anonymous) @ core.js:16895
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @
  zone.js:388 push../node_modules/zone.js/dist/zone.js.Zone.run @
  zone.js:138
  push../node_modules/@angular/core/fesm5/core.js.NgZone.runOutsideAngular
  @ core.js:16115
  push../node_modules/@angular/core/fesm5/core.js.ApplicationRef.tick @
  core.js:16895 (anonymous) @ core.js:16779
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @
  zone.js:388 onInvoke @ core.js:16156
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @
  zone.js:387 push../node_modules/zone.js/dist/zone.js.Zone.run @
  zone.js:138 push../node_modules/@angular/core/fesm5/core.js.NgZone.run
  @ core.js:16070 next @ core.js:16779 schedulerFn @ core.js:12609
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.SafeSubscriber.<strong>tryOrUnsub @ Subscriber.js:196
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.SafeSubscriber.next
  @ Subscriber.js:134
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber._next
  @ Subscriber.js:77
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next
  @ Subscriber.js:54
  push../node_modules/rxjs/_esm5/internal/Subject.js.Subject.next @
  Subject.js:47
  push../node_modules/@angular/core/fesm5/core.js.EventEmitter.emit @
  core.js:12593 checkStable @ core.js:16125 onHasTask @ core.js:16169
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.hasTask @
  zone.js:441
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate._updateTaskCount
  @ zone.js:461
  push../node_modules/zone.js/dist/zone.js.Zone._updateTaskCount @
  zone.js:285 push../node_modules/zone.js/dist/zone.js.Zone.runTask @
  zone.js:205 drainMicroTaskQueue @ zone.js:595 Promise.then (async)
  scheduleMicroTask @ zone.js:578
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.scheduleTask @
  zone.js:410 push../node_modules/zone.js/dist/zone.js.Zone.scheduleTask
  @ zone.js:232
  push../node_modules/zone.js/dist/zone.js.Zone.scheduleMicroTask @
  zone.js:252 scheduleResolveOrReject @ zone.js:862
  ZoneAwarePromise.then @ zone.js:962
  push../node_modules/@angular/core/fesm5/core.js.PlatformRef.bootstrapModule
  @ core.js:16660 ./src/main.ts @ main.ts:11
  __webpack_require</strong> @ bootstrap:78 0 @ main.ts:12
  <strong>webpack_require</strong> @ bootstrap:78 checkDeferredModules @ bootstrap:45 webpackJsonpCallback @ bootstrap:32 (anonymous) @ main.js:1
  HomeComponent_Host.ngfactory.js? [sm]:1 ERROR CONTEXT
  DebugContext_Â {view: {â¦}, nodeIndex: 0, nodeDef: {â¦}, elDef: {â¦},
  elView: {â¦}} View_HomeComponent_Host_0 @
  HomeComponent_Host.ngfactory.js? [sm]:1 proxyClass @ compiler.js:17945
  push../node_modules/@angular/core/fesm5/core.js.DebugContext_.logError
  @ core.js:22729
  push../node_modules/@angular/core/fesm5/core.js.ErrorHandler.handleError
  @ core.js:14650 (anonymous) @ core.js:16895
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @
  zone.js:388 push../node_modules/zone.js/dist/zone.js.Zone.run @
  zone.js:138
  push../node_modules/@angular/core/fesm5/core.js.NgZone.runOutsideAngular
  @ core.js:16115
  push../node_modules/@angular/core/fesm5/core.js.ApplicationRef.tick @
  core.js:16895 (anonymous) @ core.js:16779
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @
  zone.js:388 onInvoke @ core.js:16156
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @
  zone.js:387 push../node_modules/zone.js/dist/zone.js.Zone.run @
  zone.js:138 push../node_modules/@angular/core/fesm5/core.js.NgZone.run
  @ core.js:16070 next @ core.js:16779 schedulerFn @ core.js:12609
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.SafeSubscriber.<strong>tryOrUnsub @ Subscriber.js:196
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.SafeSubscriber.next
  @ Subscriber.js:134
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber._next
  @ Subscriber.js:77
  push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next
  @ Subscriber.js:54
  push../node_modules/rxjs/_esm5/internal/Subject.js.Subject.next @
  Subject.js:47
  push../node_modules/@angular/core/fesm5/core.js.EventEmitter.emit @
  core.js:12593 checkStable @ core.js:16125 onHasTask @ core.js:16169
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.hasTask @
  zone.js:441
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate._updateTaskCount
  @ zone.js:461
  push../node_modules/zone.js/dist/zone.js.Zone._updateTaskCount @
  zone.js:285 push../node_modules/zone.js/dist/zone.js.Zone.runTask @
  zone.js:205 drainMicroTaskQueue @ zone.js:595 Promise.then (async)
  scheduleMicroTask @ zone.js:578
  push../node_modules/zone.js/dist/zone.js.ZoneDelegate.scheduleTask @
  zone.js:410 push../node_modules/zone.js/dist/zone.js.Zone.scheduleTask
  @ zone.js:232
  push../node_modules/zone.js/dist/zone.js.Zone.scheduleMicroTask @
  zone.js:252 scheduleResolveOrReject @ zone.js:862
  ZoneAwarePromise.then @ zone.js:962
  push../node_modules/@angular/core/fesm5/core.js.PlatformRef.bootstrapModule
  @ core.js:16660 ./src/main.ts @ main.ts:11
  __webpack_require</strong> @ bootstrap:78 0 @ main.ts:12
  <strong>webpack_require</strong> @ bootstrap:78 checkDeferredModules @ bootstrap:45 webpackJsonpCallback @ bootstrap:32 (anonymous) @ main.js:1</p>
</blockquote>
","7702096","","","","","2018-12-19 09:34:16","rxjs obervable.interval(); throws not a function exception in browser","<angular><typescript><rxjs><rxjs5><angular-observable>","1","5","","2018-12-19 10:18:57","","CC BY-SA 4.0"
"53951524","1","","","2018-12-27 22:30:29","","1","381","<p>I have a list of users that I want to cache so that different component in my Angular 5 app does not hit the web service, and rather return cached response. To do this I did the following:</p>

<pre><code>getAllUsers() {
  return this.getUncachedUsersList().publishReplay().refCount();
}

getUncachedUsersList() {
  return this.http.get('https://......');
}
</code></pre>

<p>In the above code snippet, I have two methods. I call getAllUsers inside all the components that needs users list, except in the case where let say I am adding a user and then I need an updated list. In that case I call 'getUncachedUsersList' to get the latest.</p>

<p>The problem is, when I call 'getUncachedUsersList', I expect 'getAllUsers' to cache the new list, but instead it return the same old list that was cached before adding a new user. So I would like to know how can I clear the cached response and save the new response that I get from 'getUncachedUsersList' and return the new response when 'getAllUsers' is called.</p>
","4984434","","","","","2018-12-28 00:46:31","Update cached data using rxjs publishReplay: Angular 5","<rxjs><rxjs5>","1","1","","","","CC BY-SA 4.0"
"54012253","1","","","2019-01-02 19:44:22","","2","231","<p>Hy, im new in Rxjs.. </p>

<p>React have its <a href=""http://reactjs.org/docs/context.html"" rel=""nofollow noreferrer"">React context</a>. Similar is possible with Rxjs? My goal is create property, which is accessible from rxjs operators with <code>this</code>...</p>

<pre><code>const myObserver = Observable.create(function(observer) {
  Object.defineProperty(observer, ""context"", {
    value: {test: 'test'},
    writable: false
  });
  observer.next(data);
  observer.complete();
});

myObserver.pipe(map(function(data){
// this.context === {test: 'test'} //true
 return data
}))
</code></pre>
","10054091","","5437671","","2019-01-02 21:13:35","2019-01-02 21:13:35","Its possible for RXJS Observers create Context, as in React?","<angular><rxjs><rxjs5><rxjs6>","0","1","","","","CC BY-SA 4.0"
"54066717","1","","","2019-01-06 23:04:29","","4","1878","<p>I am using observables to get information from different sources via <code>http</code>. I understand that subscriptions to these observables are managed by Angular, so there is a low risk of memory leaks in that part. However, maybe I am a little paranoid, I am using the <code>takeUntil()</code> operator to guarantee the unsubscription to that observables.
Furthermore, I am planning to make an intensive use of observables in other tasks like counters an detection of events. So I am a little worried about the active subscriptions that could cause any problem.</p>
<p>The system I am working in includes:</p>
<pre><code>Angular CLI: 7.1.4
Node: 10.15.0
Angular: 7.1.4
rxjs 6.3.3
typescript 3.1.6
webpack 4.23.1
Linux rdz1 4.15.0-43-generic #46-Ubuntu SMP Thu Dec 6 14:45:28 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
<p>The components have code like this:<br></p>
<pre><code>import { Component, OnInit, OnDestroy } from '@angular/core';
import { Observable, Subject} from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { QueryInvoiceService } from '../services/query-invoice.service';
import { RegInvoice } from '../classes/reg-invoice';

@Component({
  selector: 'app-detail-notes',
  templateUrl: './detail-notes.component.html',
  styleUrls: ['./detail-notes.component.css']
})
export class DetailNotesComponent implements OnInit {

    private ngUnsubscribe$ = new Subject();

    constructor(private queryInvoiceService: QueryInvoiceService) { }

    ngOnInit() {  }

    getInvoice(): void {
    this.queryInvoiceService.getInvoice(this.refInvNumber, this.refTo)
    .pipe(takeUntil(this.ngUnsubscribe$))
    .subscribe(
      (regInvoices: RegInvoice[]) =&gt; {
        this.regInvoices = regInvoices;
        console.log(regInvoices);

      },
      err =&gt; console.log(err)
      );
    }

    onClick(): void {
      console.log(this.refInvNumber);
      this.getInvoice();
    }

    ngOnDestroy() {
      this.ngUnsubscribe$.next();
      this.ngUnsubscribe$.complete();
    }
}
</code></pre>
<p>In this case, the subscription activates on click. Once the data transfer is complete, the subscription must be cancelled. For this purpose I am using the operator <code>takeUntil()</code> through a pipe.</p>
<p>Under these circumstances, I would like to know how can I check if active subscriptions remain outside the control of the components, and under what conditions there is a greater risk of this happening.</p>
","10867527","","66384","","2020-06-27 22:31:26","2020-06-27 22:31:26","How to check for active subscriptions to observables to avoid memory leaks in Angular","<javascript><angular><typescript><observable><rxjs5>","0","1","1","","","CC BY-SA 4.0"
"54078694","1","","","2019-01-07 17:02:40","","1","313","<p>I am trying to implement autosave functionality in which i have used switchMap operator within switchMap operator i.e. multiple nested inner observable </p>

<pre><code>merge(...eventObservables)
    .pipe(switchMap(({ syncWithServer }) =&gt; {
        const source = of(cloneDeep(this.getData()))
            .pipe(tap((data) =&gt; this.storageService.storeItem(data.id, {
                data: data,
                synced: false
            })));
        if (syncWithServer) {
            return source.pipe(delay(5 * 1000),
                switchMap((data) =&gt;
                    this.apiService.saveData(data)
                        .pipe(tap(() =&gt; this.storageService.storeItem(data.RespondentId, {
                            data: data,
                            synced: true
                        })), tap((response) =&gt; response &amp;&amp; this.setData(response['Data'], false)))));
        }
        return source;
    }))
</code></pre>

<p>The problem with above code is API request is completing instead of cancelling when there is new value from eventObservables. Can someone point out what is issue here. As per my understanding when source observable is unsubscribed (As i have used switchMap which will unsubscribe previous observable) switchMap will also unsubscribe inner observable. If i have understood it wrong could someone point out mistake in above code?</p>
","7415356","","1118978","","2019-01-07 17:09:41","2019-01-07 17:09:41","How to unsubscribe inner observable when source observable completes","<angular><rxjs><reactive-programming><rxjs5><rxjs6>","0","4","","","","CC BY-SA 4.0"
"54090015","1","","","2019-01-08 10:39:28","","2","727","<p>I have code with <code>subscribe</code> inside <code>subscribe</code>:</p>

<pre><code>this.http.post('/update1', newData).subscribe(
    (response) =&gt; {
        const r = response.json;
        const id = r['id'];
        this.http.post('/update2?id=' + id, newData).subscribe(
            () =&gt; {
                this.http.post('/update3?id=' + id, newData).subscribe(
                    () =&gt; {
                        console.log('success');
                    },
                    () =&gt; {
                        // revert changes made to update2
                        this.http.post('/update2', previousValues).subscribe();
                        // revert changes made to update1
                        this.http.post('/update1', previousValues).subscribe();
                    });
            },
            () =&gt; {
                // revert changes made to update1
                this.http.post('/update1', previousValues).subscribe();
            }
        );
    },
    (error) =&gt; {
        console.log(error);
    }
);
</code></pre>

<p>How can I optimize it in RxJS 5?</p>
","905865","","","","","2019-01-08 11:50:26","RxJS subscribe inside subscribe with actions on error","<angular><typescript><rxjs><rxjs5>","1","2","","","","CC BY-SA 4.0"
"54201629","1","","","2019-01-15 15:09:25","","6","5114","<p>I am working with ionic/angular and RXJS observables.</p>

<p>I am trying to refactor my code using Rxjs observables and i have the next Code : </p>

<pre><code>ionViewWillEnter() {
    if (this.platform.is('core') || this.platform.is('mobileweb')) {
      this.lat = 37.3675506;
      this.lng = -6.0452695;
      this.printMap();
    } else {
      if (this.platform.is('android')) {       
        this.tryGeolocation();            
      } else if (this.platform.is('ios')) {
        console.log(""IOS"")
      }
    }
  }
</code></pre>

<p>If user access from android mobile i should check : isLocationAuthorized, isLocationEnabled() to get the current position with getCurrentPosition(), then i have to print Map where I use Observables forkjoin. </p>

<p>The problem is to check the methods returns promises and I dont know how to chain this flow . </p>

<p>tryGeolocation is the next : </p>

<pre><code> async tryGeolocation() {
    try {
      if (await this.diagnostic.isLocationAuthorized()) {
        if (await this.diagnostic.isLocationEnabled()) {
          this.loading = this.loadingCtrl.create({
            content: 'Localizando...',
            dismissOnPageChange: true
          });
          this.loading.present();
          const {coords} = await this.geolocation.getCurrentPosition();
          this.lat = coords.latitude;
          this.lng = coords.longitude;
          this.loading.dismiss();
          alert(this.lat);
          alert(this.lng);
          this.printMap();
        } else {
         console.log(""error1"")
        }
      } else {
console.log(""error2"")
      }
    } catch (e) {
      console.log('Error getting location', e);
    }
  }


printMap() {
    let obs1 = this._sp.getLocationsByPosition(this.lat, this.lng);
    let obs2 = this._sp.getUserFavoriteLocations2();
    this.subscription = forkJoin([obs1, obs2]).subscribe(results =&gt; {
      this.allLocations = results[0];
      this.myLocations = results[1];
      this.allLocations = this.allLocations.filter(item =&gt; !this.myLocations.some(other =&gt; item.id.sid_location === other.id.sid_location &amp;&amp; item.id.bid_environment === other.id.bid_environment));   

      this.map = new google.maps.Map(this.mapElement.nativeElement, {
        zoom: 13,
        center: {lat: parseFloat(this.lat), lng: parseFloat(this.lng)},
        zoomControl: true,
        draggable: true            
      });

      new google.maps.Marker({
        position: {lat: parseFloat(this.lat), lng: parseFloat(this.lng)},
        map: this.map,
        icon: {
          url: ""https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png""
        }
      });
      this.printMarkers();
    });
  }
</code></pre>

<p>I've tried to convert promise to observables like this : </p>

<pre><code>let obs1 = Observable.fromPromise(this.diagnostic.isLocationAuthorized());
    let obs2 = Observable.fromPromise(this.diagnostic.isLocationEnabled());
    let obs3 = Observable.fromPromise(this.geolocation.getCurrentPosition());

    obs1.flatMap(() =&gt; obs2)
      .flatMap(() =&gt; obs3)
      .subscribe(coords =&gt; {
        console.log(coords);
//CALL TO printMap?
      })
</code></pre>

<p>Could someone helpe me to achieve this flow refactoring my code ? </p>

<p>Thank you in advance</p>
","10030734","","","","","2021-03-08 22:49:46","Could I mix async/await Promises with observable RXJS?","<angular><ionic-framework><rxjs><observable><rxjs5>","2","3","","","","CC BY-SA 4.0"
"54254148","1","","","2019-01-18 12:34:31","","0","545","<p>I have the nex flow with observable : </p>

<pre><code>verifyFacebookUser2(): Observable&lt;User&gt; {       
    let userFacebook = {""type"": ""facebook"", ""id_facebook"": this.userId};
    return this._us.verifyRegisterFacebookObs(userFacebook )
      .flatMap(token =&gt; {
        if (!token) {
          return Observable.of([])
        }
        else {
          return Observable.fromPromise(this.storage.set('token', token));
        }
      }, error =&gt; {
        error =&gt; console.log(""FIRST ERROR"" + JSON.stringify(error));
      })
      .catch(err =&gt; {
        if (err.status === 404) {
          throw new Error(""404"");
        } else {
          throw new Error("""");
        }
        //return Observable.of([])
      })
      .flatMap(res =&gt; {
        return Observable.fromPromise(this.storage.get('token'));
      })
      .flatMap(tokenStorage =&gt; {
        let decodedToken = this.jwtHelper.decodeToken(JSON.stringify(tokenStorage));
        let idUser = parseInt(decodedToken.id);
        return this._ups.getUserProfileObs(idUser);
      })
  }
</code></pre>

<p>As you can see, my observable return User if all flow is ok, my service verifyRegisterFacebookObs return an user : </p>

<pre><code>verifyRegisterFacebookObs(user): Observable&lt;any&gt; {
    let url = URL_SERVICIOS + '/users/verify';
    return this.http2.post(url, user)
      .map(res =&gt; res['result'])
      /*.catch(error =&gt; {
         if (error.status === 404)
           return Observable.of("""");
      })*/
  }
</code></pre>

<p>So, this flow function well when all is ok , but How can I execute another flow or observable if my service return 404 error. </p>

<p>If my service return 404 error, it does mean that user doesnt exist and i need to 
 register this user calling a new http request </p>

<p>TO use that I do the next : </p>

<pre><code>this.verifyFacebookUser2()
              .subscribe((user: User) =&gt; {
                alert(""OK"");               
              }, error =&gt; {
                alert(error);               
    // Can I call another function that call observable to do another flow ? 
                    this.registerIdFacebook(this.userId);    
                  })
</code></pre>

<p>If all is ok print ok , if I get error I need to call registerIdFacebook, so I only call to registerIdFacebook when error is emited by this._us.verifyRegisterFacebookObs(userFacebook ) and its 404.</p>

<pre><code> registerIdFacebook(id) {    
   this._us.facebookRegisterObs({""id_facebook"": id}).
    subscribe(resultado =&gt; {
      alert(JSON.stringify(resultado));
    }, error =&gt; {
      //TODO PRESENT TOAST
      alert(JSON.stringify(error));
    })
  }
</code></pre>

<p>Could someone help me to achieve that ? </p>
","10030734","","","","","2019-01-21 13:06:57","How can I break my flow on my observable to call another observable with RXJS?","<javascript><angular><rxjs><rxjs5><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54451257","1","","","2019-01-30 23:41:12","","1","3548","<p><a href=""https://i.stack.imgur.com/t7uce.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t7uce.png"" alt=""enter image description here""></a>I am trying to migrate from rx5 to rx6 by following the guide <a href=""https://github.com/reactivex/rxjs/blob/HEAD/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">here</a>. Initially, I installed along with the rxjs-compat package and everything works fine. However, when I try to remove the rxjs-compat package, I am getting an exception <code>Cannot find module 'rxjs-compat/Subscription'</code>. I used the rxjs-5-to-6-migrate to perform the migration</p>

<p>I am using this statement for Subscription : import { Subscription } from ""rxjs""; </p>

<p>For reference this is my branch- <a href=""https://github.com/akshita31/omnisharp-vscode/tree/rxjs_update"" rel=""nofollow noreferrer"">https://github.com/akshita31/omnisharp-vscode/tree/rxjs_update</a> and this is the corresponding pull request that lists all the changes - <a href=""https://github.com/OmniSharp/omnisharp-vscode/pull/2830"" rel=""nofollow noreferrer"">https://github.com/OmniSharp/omnisharp-vscode/pull/2830</a></p>
","4950937","","4950937","","2019-01-31 02:38:40","2019-02-01 00:40:46","Cannot find module 'rxjs-compat/Subscription'","<rxjs><rxjs5><rxjs6>","2","8","","","","CC BY-SA 4.0"
"54512315","1","","","2019-02-04 08:19:37","","0","314","<p>I have this code:</p>

<pre><code>await commuteReportService.getAddresses(query).pipe(debounceTime(1000))
            .subscribe((response: AddressesAPIResponse) =&gt; {
                console.log('execute call', response);
            });
</code></pre>

<p>However, in the network tab I still see that all the requests are being sent. This code is used in a autocomplete component where I want to limit the calls being sent.
I'm using rxjs 5.5, React and Typescript.</p>
","3103015","","","","","2019-02-04 08:47:07","debounceTime not limiting api calls","<reactjs><typescript><rxjs5>","1","4","","","","CC BY-SA 4.0"
"54536850","1","","","2019-02-05 14:41:40","","1","155","<p>I need to subscribe to a result, but wait for intermediate operations to finish before getting the result. The trick is that I ""visit"" my result to populate it:</p>

<pre><code>// a service that gets a model
service.getModel(): Observable&lt;MyModel&gt;;

// I need to enrich my model before consuming it
service.getModel()
    .makeSureAllCodesAreFetched(data =&gt; visitModel(model))
    .subscribe(data =&gt; console.log(""data is ready: "", data));

// a visitor that visits the model tree and enriches the leaves
// recursively visit the branches
visitModel(model: MyModel) {
    if (model.isLeaf) {
       // on condition, call a service to fetch additional data
       service.fetchCodes(model.codeKey).subscribe(codes =&gt; model.codes = codes);
    } else {
        model.properties.forEach(prop: MyModel =&gt; visit(prop));
    }
}
</code></pre>

<p>I tried to play with merges and forkJoin() without success. I just want to make sure that all calls to <code>fetchCodes()</code>, regardless of the result, are done before my data is subscribed to.</p>
","1093496","","114900","","2019-02-05 14:43:54","2019-02-05 15:52:34","RXJS wait for other Observable","<rxjs><rxjs5>","1","1","","","","CC BY-SA 4.0"
"54756469","1","","","2019-02-18 22:44:50","","0","453","<p>I am working on a case where during a network connection we sometimes might have a limited internet connectivity where we unable to get response from the server or failed response as HttpError.
I hereby trying to ping the URL every second to check whether we are getting response or not, for this </p>

<p>I am trying this code, this is working fine in online method but when i am turning my internet of is doesn't return me false value.</p>

<p><strong>fetch-data.service.ts</strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient, HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { Posts } from './posts';
import { Observable, interval, throwError, of } from 'rxjs';
import { take, exhaustMap, map, retryWhen, retry, catchError, tap, mapTo, } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class FetchDataService {

  public url = 'https://jsonplaceholder.typicode.com/posts';

  constructor(private _httpClient: HttpClient) { }

  getData() {
    const ob = interval(1000);
    return ob.pipe(
      exhaustMap(_ =&gt; {
        return this._httpClient.get&lt;Posts[]&gt;(this.url, { observe: 'response' });
      }),
      map(val =&gt; {
        if (val.status === 200)
          return true;
        throw val;
      }),
      retryWhen(errors =&gt; {
        return errors.pipe(map(val =&gt; {
          if (val.status === 0)
            return false;
        }))
      })
    );
  }


  // private handleError(error: HttpErrorResponse) {
  //   if (error.error instanceof ErrorEvent) {
  //     // A client-side or network error occurred. Handle it accordingly.
  //     console.error('An error occurred:', error.error.message);
  //   } else {
  //     // The backend returned an unsuccessful response code.
  //     // The response body may contain clues as to what went wrong,
  //     console.error(
  //       `Backend returned code ${error.status}, ` +
  //       `body was: ${error.error}`);
  //     if (error.status !== 200)
  //       return of(false);
  //   }
  //   // return an observable with a user-facing error message
  //   return throwError(
  //     'Something bad happened; please try again later.');

  // };

}
</code></pre>

<p><strong>pulldata.component.html</strong></p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { FetchDataService } from '../fetch-data.service';
import { Observable } from 'rxjs';
import { Posts } from '../posts';

@Component({
  selector: 'app-pulldata',
  templateUrl: './pulldata.component.html',
  styleUrls: ['./pulldata.component.css']
})
export class PulldataComponent implements OnInit {

  public data;
  public error = '';

  constructor(private _fecthDataServe: FetchDataService) { }

  ngOnInit() {
    this._fecthDataServe.getData().subscribe(val =&gt; {
      this.data = val;
      console.log(this.data);
    });

  }

}
</code></pre>

<p>what would be the best solution to check the internet connectivity in this manner? </p>
","4825104","","","","","2019-02-18 23:02:13","HttpClient & Rxjs","<javascript><angular><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"54864684","1","","","2019-02-25 10:59:55","","0","181","<p>My use-case scenario is following:<br>
I have some observable chain and at some point I need to grab additional information from web service and basing on resolved information I'd like to continue chain or stop it by throwing out.</p>

<p>To wait for information from service I use <code>concatMap</code> (each value emitted form stream is mapped to new observable returned by service and I need value, nit observable of value). To flat all inner observables, all is enclosed within <code>concatMap</code></p>

<p>Following code works well:</p>

<pre><code>/* Begin of chain */
        .concatMap&lt;Type, Type&gt;((pld: Type) =&gt; {
            return this.appService.getInfo()
            .concatMap&lt;string, Type&gt;((info) =&gt; {
                if (someFailingCondition(info)) {
                    Observable.throw(`Failed`);
                }
                /* Pass-through operation */
                return Observable.of(pld);
            });
        })
/* Rest of chain */
</code></pre>

<p>But I'd like to drop outer <code>concatMap</code> in favor of plain <code>map</code> to operate on plain values only from main chain perspective. I came with <code>concatAll</code> solution:</p>

<pre><code>/* Begin of chain */
        .map&lt;Type, Type&gt;((pld: Type) =&gt; {
            return this.appService.getInfo()
            .concatMap&lt;string, Type&gt;((info) =&gt; {
                if (someFailingCondition(info)) {
                    Observable.throw(`Failed`);
                }
                /* Pass-through operation */
                return Observable.of(pld);
            })
            .concatAll()
        })
/* Rest of chain */
</code></pre>

<p>But im wondering is there any other way to flat inner series of observables into flat values pipe once again after <code>concatMap</code>-ing them in inner operator series?</p>
","2759473","","2759473","","2019-02-25 11:11:43","2019-02-25 13:52:19","returning non-observable flat value from nested concatMap","<rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"55117297","1","","","2019-03-12 08:46:27","","2","786","<p>I am coding a Single Page Application in Angular 5 and it requires to periodically check if API still has the same version as when the SPA was loaded to inform the user about the desync and allow her to refresh (the first call must be performed as soon as possible).</p>

<p>I have little experience working with rxjs and I know that if I am not careful I might end with unsubscribed observables and/or more HTTP calls than required.</p>

<p>My current code looks like this:</p>

<h3>The service</h3>



<pre class=""lang-js prettyprint-override""><code>import { Injectable } from ""@angular/core"";
import { IValidationResult } from ""../models/validation-result"";
import { Subscription } from ""rxjs/Subscription"";
import { Observable } from ""rxjs/Observable"";
import { HttpClient } from ""@angular/common/http"";

@Injectable()
export class KeepAliveService {

  checkVersion$: Observable&lt;IValidationResult&lt;string&gt;&gt;;
  checkVersionSubscription: Subscription;

  constructor(
    private readonly httpClient: HttpClient) {
  }

  isUpToDate: boolean;
  isLive = true;
  liveVersion: string;

  performCheckVersion(): void {

    const localVersion = localStorage.getItem(""MyAppLocalVersion"");

    this.checkVersion$ = this.httpClient.get&lt;IValidationResult&lt;string&gt;&gt;(""GetApiVersion"");

    this.checkVersionSubscription = this.checkVersion$.subscribe(
      (result: IValidationResult&lt;string&gt;) =&gt; {
        this.liveVersion = result.payload;
        this.isUpToDate = localVersion === this.liveVersion;
        this.isLive = true;

        this.checkVersionSubscription.unsubscribe();
    });
  }
}
</code></pre>

<h3>Refreshing code (app.module.ts)</h3>

<pre class=""lang-js prettyprint-override""><code>console.log(""Quick version check"");
this.keepAliveService.performCheckVersion();

console.log(""Set check version setInterval"");
setInterval(() =&gt; {
  this.keepAliveService.performCheckVersion();
}, this.checkVersionInterval);
</code></pre>

<p>This does the job, but I feel it seems rather complex for such a simple job. Is there a ""Observableish"" way of obtaining the same functionality?</p>

<hr/>

<p>I have tried the following:</p>

<h3>The service</h3>

<pre class=""lang-js prettyprint-override""><code>import { Injectable } from ""@angular/core"";
import { IValidationResult } from ""../models/validation-result"";
import { Subscription } from ""rxjs/Subscription"";
import { Observable } from ""rxjs/Observable"";
import { HttpClient } from ""@angular/common/http"";
import { interval } from ""rxjs/observable/interval"";
import { switchMap } from ""rxjs/operator/switchMap"";

  startCheckingVersion() {

    const httpObservable = interval(this.checkVersionInterval)
      .switchMap(_ =&gt; this.httpClient.get&lt;IValidationResult&lt;string&gt;&gt;(""GetApiVersion""));  

      this.checkVersionSubscription = httpObservable.subscribe(
        (result: IValidationResult&lt;string&gt;) =&gt; {
          const localVersion = localStorage.getItem(""MyAppLocalVersion"");
          this.liveVersion = result.payload;
          this.isUpToDate = localVersion === this.liveVersion;
          this.isLive = true;
        });
  }
</code></pre>

<p>However, there is an issue related to how I use <code>timer</code> and <code>switchMap</code> as I received the following error:</p>

<blockquote>
  <p>timer_1.timer(...).switchMap is not a function ; Zone:  ; Task:
  Promise.then ; Value: TypeError: timer_1.timer(...).switchMap is not a
  function</p>
</blockquote>

<p>My package.json rxjs version:</p>

<pre class=""lang-js prettyprint-override""><code>""rxjs"": ""^5.5.6"",
</code></pre>
","2780791","","2780791","","2019-03-12 08:53:56","2019-03-12 09:10:59","How to periodically poll information in Angular 5 using Observables and also have immediate fetch using RxJs 5.x?","<angular><angular5><observable><rxjs5><polling>","1","5","1","","","CC BY-SA 4.0"
"55236973","1","55238170","","2019-03-19 08:58:39","","0","475","<p>I have used behaviourSubject in shared service to get the current value while clicking a button.It is working as expected but some times the api call inside the subscribe block of behavioursubject hits multiple times.</p>

<p>what will be the issue??</p>
","8536398","","","","","2019-03-19 09:58:34","BehaviourSubject hit multiple times if there is only one value","<javascript><angular><rxjs5>","1","2","","","","CC BY-SA 4.0"
"55238170","2","","55236973","2019-03-19 09:58:34","","2","","<p><strong>There can be any of the following reasons:</strong></p>

<ol>
<li>This happens, when you subscribe to BehaviorSubject in a block of code that executes multiple times. Example if you subscribe in ngAfterViewChecked life cycle hook of angular component that executes multiple times.</li>
<li>You never unsubscribed but every time app loads the component, subscribe your behaviour subject.</li>
<li>Subscriber of BehaviorSubject always executes at least once, because BehaviorSubject requires a default argument when created and emits the passed default argument at least once, if you call .next() method only once on the instance of BehaviorSubject, Subscriber will execute twice. 1st time for default value passed while creating instance of BehaviorSubject, 2nd time for the value you passed by calling .next method on the instance of BehaviorSubject.</li>
</ol>

<p>Did I answer your question ?</p>

<p>If not, please provide the code snippet, so that we could understand the problem better.</p>
","10269163","","","","","2019-03-19 09:58:34","","","","1","","","","CC BY-SA 4.0"
"55261606","1","55262148","","2019-03-20 13:14:19","","2","1024","<p>I use RxJS 5.2.0 (yes, it's pretty old).
I subscribe on some observable and I want to execute some code.
If there is a js error in this code, then RxJS will just unsubscribe my subscriber and will not report an error into the console.</p>

<p>It looks very bad for me because the error will be hidden and I cannot see it and correct. Maybe, I already have some errors in my project, but I don't know about them.</p>

<p>The only way which I see is wrapping all code in my subscribers into try-catch. But it looks crazy, there are hundreds of such places.</p>

<p>I'm going to update RxJS in a couple of months but would be great to find some solution to this problem for now.</p>

<p>Here is an example on jsfiddle <a href=""https://jsfiddle.net/Eugene_Ilyin/18kw3hde/"" rel=""nofollow noreferrer"">https://jsfiddle.net/Eugene_Ilyin/18kw3hde/</a></p>

<pre><code>let subj = new Rx.BehaviorSubject(1);

subj.asObservable().subscribe(number =&gt; {
  console.log(number);
  let book;
  book.page();
  console.log(number);
});

setTimeout(() =&gt; {
  subj.next(2);
}, 1000);
</code></pre>

<p>There is a line <code>book.page();</code> which provokes an error. But in a console of the browser, you will not see any error. After the error, the subscription will not be called again. Because it will be unsubscribed by RxJS, when it will catch an error by this code:</p>

<pre><code>SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
    try {
        fn.call(this._context, value);
    }
    catch (err) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
    }
    return false;
};
</code></pre>

<p>This <a href=""https://stackoverflow.com/questions/45476902/why-does-rxjs-unsubscribe-on-error"">question</a> could be related to my question. But there is a bit different situation and doesn't provide an answer.</p>
","1906096","","","","","2019-03-21 09:15:31","Why does Rxjs unsubscribe on error in the subscription callback?","<javascript><rxjs><rxjs5>","1","3","","","","CC BY-SA 4.0"
"55262148","2","","55261606","2019-03-20 13:42:25","","2","","<p>try this out. You should put logics in operators, instead of inside subscribe.
Take a look at this question 
<a href=""https://stackoverflow.com/questions/55001680/rxjs-is-it-good-practice-to-have-code-in-subscribe-method/55004939?noredirect=1#comment97192972_55004939"">rxjs. is it good practice to have code in subscribe method?</a></p>

<pre><code>let subj = new Rx.BehaviorSubject(1);

subj.asObservable().do(()=&gt;{
  console.log(number);
  let book;
  book.page();
  console.log(number);
}).catch(e =&gt; {
  console.error(e);
  return Rx.Observable.throw(e)
}).onErrorResumeNext()
  .subscribe(number =&gt; {
});

setTimeout(() =&gt; {
  subj.next(2);
}, 1000);
</code></pre>

<p><code>catch</code> operator will catch you error and <code>onErrorResumeNext()</code> will keep the subscription.</p>

<p><a href=""https://jsfiddle.net/cvd7Lu4q/"" rel=""nofollow noreferrer"">https://jsfiddle.net/cvd7Lu4q/</a></p>
","8618350","","1906096","","2019-03-21 09:15:31","2019-03-21 09:15:31","","","","1","","","","CC BY-SA 4.0"
"55292196","1","","","2019-03-22 02:49:43","","1","209","<p>RsJs moved from a ""dot"" to a ""pipe"" abstraction for its operators for <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#why"" rel=""nofollow noreferrer"">these four reasons</a>. Would those reasons have also been addressed if the operators were aliased with symbols? So instead of adding a property named <code>'myOp'</code> to the prototype, what if the name were a symbol like <code>Symbol('myOp')</code>? Then it could be invoked as </p>

<pre class=""lang-js prettyprint-override""><code>var MyOp = require('my-op');
var o = getObservable();
var x = o[MyOp]();
</code></pre>

<p>Taking the justifications one-by-one:</p>

<blockquote>
  <p>Any library that imports a patch operator will augment the Observable.prototype for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</p>
</blockquote>

<p>The symbol would only be attached to the prototype when the module is loaded via <code>require('myOp')</code> and wouldn't collide because it's a symbol and wouldn't be removed.</p>

<blockquote>
  <p>Operators patched directly onto the prototype are not ""tree-shakeable"" by tools like rollup or webpack. Pipeable operators will be as they are just functions pulled in from modules directly.</p>
</blockquote>

<p>Symbols added to the prototype would not need to be shaken because they're imported one-by-one as needed; If the symbol is present on the prototype then it's being used by whoever imported it. </p>

<blockquote>
  <p>Unused operators that are being imported in apps cannot be detected reliably by any sort of build tooling or lint rule. That means that you might import scan, but stop using it, and it's still being added to your output bundle. With pipeable operators, if you're not using it, a lint rule can pick it up for you.</p>
</blockquote>

<p>Symbols that are loaded but not used are easy to detect; If <code>var MyOp = require('my-op')</code> and <code>MyOp</code> is not used, then the linter could ask that the package be removed and so the op would never be attached as the module is never loaded. </p>

<blockquote>
  <p>Functional composition is awesome. Building your own custom operators becomes much, much easier, and now they work and look just like all other operators from rxjs. You don't need to extend Observable or override lift anymore.</p>
</blockquote>

<p>The module <code>my-op</code> would declare the operator like so:</p>

<pre class=""lang-js prettyprint-override""><code>var MyOp = Symbol('MyOp');
Observable.prototype[MyOp] = function() { ... }
module.exports = MyOp
</code></pre>
","2303356","","","","","2019-03-22 02:49:43","RxJS ""dot"" vs ""pipe"" abstraction","<javascript><angular><rxjs><rxjs5><rxjs-pipeable-operators>","0","11","","","","CC BY-SA 4.0"
"55348948","1","","","2019-03-26 02:19:55","","0","1211","<p>I am trying to install Expo for React Native using <code>npm install -g expo-cli</code>. But the installation halts or indefinite time at <code>extract:rxjs: still extract rxjs@5.5.2 extracted to c:/...</code></p>

<p>Now,
1. I used administrator privilege for cli
2. I tried this for 3 time in a day, but each time the system halts in same place</p>

<p>Node -v 10.15.3</p>

<p>npm -v 6.4.1</p>

<p>windows 7</p>

<p>How can i make this done? Any guess?</p>
","2899968","","","","","2020-02-09 10:25:58","npm install Expo cli, stops at extraxt: rxjs","<react-native><npm><expo><rxjs5>","2","0","","","","CC BY-SA 4.0"
"55361441","1","","","2019-03-26 15:59:49","","0","262","<p>I have a scenario in which I have to make some api calls, then show some toast messages informing the user if the calls succeeded or failed. In the code below, the <code>processSaveResponses</code> method gets called before the observable's are resolved. The <code>processSaveResponses</code> method is responsible for displaying the toast messages. I understand this is expected behavior, since observable's are asynchronous, but I don't know how to ""wait"" unit the observable's have finished. </p>

<p>The <code>deliveryPreferencesService.save</code> and <code>deliveryPreferencesService.saveAutoEnroll</code> methods are independent of each other, but <code>deliveryPreferencesService.saveAutoEnroll</code> should not be called if <code>deliveryPreferencesService.save</code> failed. </p>

<pre class=""lang-js prettyprint-override""><code>  private saveChanges(changeSet: DeliveryPreferencesChangeSet) {

    let deliveryPrefernceResult;
    let saveAutoEnroll = true;

    const { accountPreferences: accountPreferenceChanges, autoEnrollPreferences: autoEnrollPreferenceChanges } = changeSet.changes;

    if (accountPreferenceChanges.length) {
      this.deliveryPreferencesService.save(accountPreferenceChanges).
        subscribe(
          () =&gt; deliveryPrefernceResult = true,
          () =&gt; saveAutoEnroll = false);
    }

    if (autoEnrollPreferenceChanges.length) {
      if (saveAutoEnroll) {
        this.deliveryPreferencesService.saveAutoEnroll(autoEnrollPreferenceChanges).
          subscribe(
            () =&gt; console.log('save auto enroll completed'),
            () =&gt; saveAutoEnroll = false);
      }
    }

    this.processSaveResponses([{ success: deliveryPrefernceResult }, {success: saveAutoEnroll}]);
  }

</code></pre>

<p>Here is the code for the <code>processSaveResponses</code> :</p>

<pre><code>    if (every(responses, ['success', false])) {
      this.showErrorToastr(this.ALL_CHANGES_FAILURE_MESSAGE);
    }
    else if (every(responses, ['success', true])) {
      this.originalPreferences = cloneDeep(this.currentPreferences);
      this.onChange.next();
      this.showSuccessToastr(this.ALL_CHANGES_SUCCESS_MESSAGE);
    }
    else {
      if ((responses[0] as any).success) {
        this.originalPreferences.accountPreferenceSets = cloneDeep(this.currentPreferences.accountPreferenceSets);
        this.showSuccessToastr(this.DELIVERY_PREFERENCES_SUCCESS_MESSAGE);
        this.showErrorToastr(this.AUTO_ENROLL_FAILURE_MESSAGE);
      } else {
        this.originalPreferences.autoEnrollPreferences = cloneDeep(this.currentPreferences.autoEnrollPreferences);
        this.showSuccessToastr(this.AUTO_ENROLL_SUCCESS_MESSAGE);
        this.showErrorToastr(this.DELIVERY_PREFERENCES_FAILURE_MESSAGE);
      }
    }
  }
</code></pre>

<p>Any help would be appreciated. I am using rxjs version 5.5.2. </p>
","203948","","","","","2019-03-28 11:41:53","How can I make sure all my observables have completed before showing a toast message?","<angular><typescript><rxjs><observable><rxjs5>","3","1","","","","CC BY-SA 4.0"
"55586924","1","","","2019-04-09 07:06:23","","0","46","<p>I'm looking at the convert guide available <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">here</a> and I'm trying to convert merge used in pipe following this guide, but it is not working as it was before the change. </p>

<p>Here is my piece of code I'm using to learn new merge: </p>

<pre class=""lang-js prettyprint-override""><code>    this.form.valueChanges.pipe(
      startWith(1),
      merge(this.form.statusChanges),
      merge(this.click$),
      map(() =&gt; this.form.value.query),
      filter(() =&gt; this.form.valid)
    )
    .subscribe(this.search);
</code></pre>

<pre class=""lang-js prettyprint-override""><code>  private search = (query: string) =&gt; {
    this.tvs.search(query).subscribe(shows =&gt; this.shows = shows);
  }
</code></pre>

<p>I've tried to do something like that: </p>

<pre class=""lang-js prettyprint-override""><code>    merge(
    this.form.valueChanges.pipe(
    startWith(1),
      map(() =&gt; this.form.value.query),
      debounceTime(500),
      tap(() =&gt; this.form.controls.query.errors &amp;&amp; console.log(this.form.controls.query.errors)),
      tap(() =&gt; this.form.status &amp;&amp; console.log(this.form.status)),
      filter(() =&gt; this.form.valid)
    ), this.form.statusChanges, this.click$)
    .subscribe(this.search);
</code></pre>

<p>But in network tab in chrome I'm getting the call to api with query equal to status of the form (VALID or INVALID). What is the proper way to convert this?</p>
","2846167","","","","","2019-04-09 07:57:56","How should I convert merge used in pipe in v5 to v6","<angular><typescript><rxjs5><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"55639908","1","","","2019-04-11 19:31:27","","0","62","<p>I'm trying to make a service return an error.</p>

<p>I'm mocking the service, using rxjs _throw and then testing if a router navigate function has been executed.</p>

<p>But the router navigate function should fire only if the HttpErrorResponse object has the value errorMessage: 'Session not found'</p>

<p>The entire object should be <code>{error: {error: errorMessage: 'Session not found'}}}</code></p>

<p>I've used the mock service before, but I'm having issues getting it to return an error and behave the same as the actual function in the component</p>

<p>The component function:</p>

<pre><code>this.sub = this.addressService.getAddress(postcode.replace(/\s+/g, ''), houseNo)
          .subscribe((response: AddressResponse) =&gt; {

            if (response.getAddressFromPostcodeResponse &amp;&amp;
                response.getAddressFromPostcodeResponse.address &amp;&amp;
                response.getAddressFromPostcodeResponse.address.length &gt; 0) {

                  this.yourAddressDetails.addressDetails.placeholder = 'Please select';
                  this.yourAddressDetails.addressDetails.options = this.addressService.setAddressDetails(response.getAddressFromPostcodeResponse.address);
            } else {
                  this.yourAddressDetails.addressDetails.options = [];
                  this._noPostcodeMatch = true;
            }
          }, error =&gt; {

                 this.yourAddressDetails.addressDetails.options = [];
                 this.httpPostcodeError = true;

            if (error.error &amp;&amp; error.error.errorMessage === 'Session not found') {
                 this.router.navigate([`${this.journeyService.type}/${FeatureType.SessionTimeout}`]);
            }
         });
</code></pre>

<p>The test:</p>

<pre><code>it('should navigate to session-timeout component if no session.', () =&gt; {
    mockAddressService.getAddress.and.returnValue(_throw({error : {
      error: {
        errorMessage: 'Session not found'
      }
     }}));
     spyOn(component['router'], 'navigate');
    expect(component['router'].navigate).toHaveBeenCalledWith(['quote/session-timeout']);
  });
</code></pre>

<p>There are other variables being set in that part of the component code <code>httpPostcodeError</code> that I've tested to see if being set but, they are not, so it seems it does not execute that statement.</p>

<p>I get <code>Expected spy navigate was not called</code></p>
","1373036","","5106017","","2019-04-12 18:59:40","2019-04-12 18:59:40","Jasmine testing a service","<angular><jasmine><rxjs5>","0","8","","","","CC BY-SA 4.0"
"55711810","1","","","2019-04-16 15:33:32","","1","2200","<p>Hi I am recieving a typescript error in my code . following is my code .</p>

<pre><code>combineLatest(
          this.translateService.get('CLONE_FLIGHT', { item: this.flight.name}),
          this.flightsService.getCampaignsToClone(this.flight.id)
        ).subscribe([  header, campaigns]) =&gt; { 
          console.log('test');
        });
</code></pre>

<p>the error i am receiving is </p>

<pre><code>Argument of type 'any[]' is not assignable to parameter of type '(value: [any, Campaign[]]) =&gt; void'.
  Type 'any[]' provides no match for the signature '(value: [any, Campaign[]]): void'.ts(2345)
Cannot find name 'campaigns'.ts(2304)
</code></pre>

<p>the method signature for translateService.get is as following</p>

<pre><code>get(key: string | Array&lt;string&gt;, interpolateParams?: Object): Observable&lt;string | any&gt;;
</code></pre>

<p>the method call flightsService.getCampaignsToClone(this.flight.id)</p>

<p>is </p>

<pre><code>getCampaignsToClone(flightId: string){
    let campaigns: Campaign[] = [
      {  id:""1"", name: ""test campaign 001"", createdOn:"""",lastUpdated: """", createdBy: null,
      type:null, status: null, startDate: null, endDate: null, budget: null, description: """",
      account: null },
      {  id:""2"", name: ""test campaign 002"", createdOn:"""",lastUpdated: """", createdBy: null,
      type:null, status: null, startDate: null, endDate: null, budget: null, description: """",
      account: null },
      {  id:""3"", name: ""test campaign 003"", createdOn:"""",lastUpdated: """", createdBy: null,
      type:null, status: null, startDate: null, endDate: null, budget: null, description: """",
      account: null }
     ];
    return Observable.of(campaigns);

  }
</code></pre>

<p>the I code wants to achieve is first resolve the property 'CLONE_FLIGHT' &amp;  loads campaigns objects, then in the subscribe i want to call a modal dialog box. However i am getting the above error
i am newbie to typescript and observables. </p>

<p>appreciate any help
thank you so much
prasanth</p>
","11119821","","11119821","","2019-04-16 15:52:46","2019-04-16 16:16:34","Argument of type 'any[]' is not assignable to parameter of type '(value: [any, Campaign[]]) => void'","<angular><typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"55730668","1","","","2019-04-17 15:01:33","","0","1647","<p>Having issues using RxJS operators the way they were intended to be used.</p>

<p>My endpoint returns <code>Observable&lt;Array&lt;TaskReprintReasonCode&gt;&gt;</code></p>

<p>I then use the async pipe to subscribe to this observable.</p>

<pre class=""lang-js prettyprint-override""><code>this.reason$ = this.taskService.getTaskReprintReasonCodes();
</code></pre>

<p>This works great until i need to filter or map something out of that list of reasons.</p>

<pre class=""lang-js prettyprint-override""><code>this.reasons$ = this.taskService
  .getTaskReprintReasonCodes()
  .pipe(filter(r =&gt; r.reasonDescription === ""New""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/bwIG9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bwIG9.png"" alt=""Error Produced from my IDE""></a></p>

<p>I am guessing it has to do with the way I am defining the type coming back from the DB. Is it bad practice to be naming <code>Observabe&lt;INSERTTYPE[]&gt;</code></p>
","8479878","","6118550","","2020-01-01 20:35:37","2020-01-01 20:35:37","Why do the RxJS filter method not work for me","<angular><rxjs><observable><rxjs5>","1","3","","","","CC BY-SA 4.0"
"55745046","1","55745289","","2019-04-18 11:27:29","","-5","462","<p>Hi I have an angular 5 application. I have a service method that returns undefined . 
here is what i am trying to do . i have a function named cloneFlight. i am making a call to flightsService.getCampaignsToClone(this.flight) which is returning value undefined .</p>

<pre><code>cloneFlight() {
    combineLatest(
      this.translateService.get('CONFIRM.CLONE_FLIGHT', { item: this.flight.name}),
      this.flightsService.getCampaignsToClone(this.flight)
    ).subscribe( ([header, campaigns]) =&gt; { 
      this.cloneFlightService.openModal(header,this.flight,campaigns);
    });
  }
</code></pre>

<p>the code for getCampaignsToClone  is as follows.</p>

<pre><code> getCampaignsToClone(flight: Flight){

    let campaignStatusesIdArr: string[];
    let campaigns: CampaignUnpaginated[] ; 
    this.campaignService.getStatuses().subscribe(
      (data) =&gt; { 
        campaignStatusesIdArr = data.filter( x =&gt; x.code === (CampaignStatusCode.IN_PROGRESS || 
          CampaignStatusCode.READY)).map( y =&gt; y.id);
      }
    );
    let accountId: string = flight.campaign.account.id;    

    this.campaignService.getUnpaginatedCampaigns(
      {
        statuses: campaignStatusesIdArr,
        accounts: accountId
      }
    ).subscribe(data=&gt;{
      console.log(data);
      campaigns = data;
    });
    return Observable.of(campaigns);
  }
</code></pre>

<p>in getCampaignsToClone i am making an http call  campaignService.getStatuses() that returns Observable . then filtering out some of them and then i make a call to 
getUnpaginatedCampaigns which is another http call. anyidea what is the best way to write this code so that the method wont return undefined. I think i am probably not utilising the rxjs operators. could someone help me to figure it out . </p>

<p>thank you so much</p>
","11119821","","","","","2019-04-18 11:42:17","typescript method returning undefined?","<typescript><rxjs5><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"55745289","2","","55745046","2019-04-18 11:42:17","","1","","<p>Rewrite your <code>getCampaignsToClone</code> method so it returns an Observable sequence. Use flatMap to subscribe to the getUnpaginatedCampaigns observable in turn.</p>

<pre><code>getCampaignsToClone(flight: Flight): Observable&lt;CampaignUnpaginated[]&gt; {
 return this.campaignService.getStatuses().pipe(
    map(data =&gt; data.filter( x =&gt; x.code === (CampaignStatusCode.IN_PROGRESS || CampaignStatusCode.READY)).map(x =&gt; x.id)),
    flatMap(ids =&gt; this.campaignService.getUnpaginatedCampaigns({
        statuses: ids,
        accounts: flight.campaign.account.id,
    }))
  );
}
</code></pre>
","3699838","","","","","2019-04-18 11:42:17","","","","2","","","","CC BY-SA 4.0"
"55763056","1","55763251","","2019-04-19 14:00:39","","0","700","<p>I need to make 2 API calls, first one will always execute and return a true or false.  2nd one should only call subscribe if the 1st one returned true.  </p>

<p>Is there an Rxjs operator I can use for this, rather than putting a subscribe within a subscribe?  </p>

<p>I've used switchmap when invoking 2 subscribes, but in that scenario i passed the result from the 1st to the 2nd and 2nd always had to execute.  </p>

<p>Here I want to avoid the 2nd call if it's not necessary.</p>
","1242889","","4964569","","2019-04-19 14:39:36","2019-04-19 14:39:36","invoke subscribe on 2nd observable based on the value of the first","<angular><rxjs><rxjs5>","3","0","","","","CC BY-SA 4.0"
"55763251","2","","55763056","2019-04-19 14:17:00","","2","","<p>Refer this article.</p>

<p><a href=""https://medium.com/javascript-everyday/rxjs-iif-operator-ternary-operator-under-the-hood-148b28e752e4"" rel=""nofollow noreferrer"">https://medium.com/javascript-everyday/rxjs-iif-operator-ternary-operator-under-the-hood-148b28e752e4</a></p>

<p>OR</p>

<p><a href=""https://rxjs-dev.firebaseapp.com/api/index/function/iif"" rel=""nofollow noreferrer"">https://rxjs-dev.firebaseapp.com/api/index/function/iif</a></p>

<p>RXJS <strong>""IFF""</strong> Operator provide an ternary operator kind of behavior.</p>

<pre><code>firstCall(args).pipe(
   iif(res =&gt; res===true,secondCall(otherArgs),EMPTY),
).subscribe(doStuff);
</code></pre>
","6235175","","","","","2019-04-19 14:17:00","","","","0","","","","CC BY-SA 4.0"
"55840409","1","","","2019-04-25 00:56:04","","0","304","<p>I have this epic:</p>

<pre><code>export const updateIsNotVeganInDbFulfilledEpic: Epic &lt; * , * , * &gt; = (
        action$: ActionsObservable &lt; * &gt; ,
        store: Store &lt; * , * &gt;
    ): Observable &lt; any &gt; =&gt;
    action$.ofType('UPDATE_IS_NOT_VEGAN_IN_DB_FULFILLED').mergeMap(action =&gt; {
        return Observable.of(
            updateToastComponentIsOpen(true),
            updateToastComponentMessage(action.payload.response.errors[0])
        )
    })
</code></pre>

<p>How can I dispatch another action (<code>updateToastComponentIsOpen(false)</code>) 2 seconds after <code>updateToastComponentIsOpen(true)</code>?</p>

<p>I tried this:</p>

<pre><code>  action$.ofType('UPDATE_IS_NOT_VEGAN_IN_DB_FULFILLED').mergeMap(action =&gt; {
    return Observable.of(
      updateToastComponentIsOpen(true),
      updateToastComponentMessage(action.payload.response.errors[0])
    ).timeout(2000)
    .flatMap(function(result) {
      return Observable.of(updateToastComponentIsOpen(false))
    })
  })
</code></pre>

<p>But it stopped the first two actions from being dispatched.</p>
","3935156","","","","","2019-04-25 05:14:19","Redux Observable epic, set timeout interval between actions","<react-redux><rxjs5><redux-observable>","1","0","","","","CC BY-SA 4.0"
"55876625","1","","","2019-04-27 01:55:57","","0","95","<p>how i can get single item at a time (concatMerge) and delay it from result of group.pipe(toArray()). i want each item coming out of group array with delay inside that group item.</p>

<pre><code>const people = [
  { name: 'Sue', age: 25 },
  { name: 'Joe', age: 30 },
  { name: 'Frank', age: 25 },
  { name: 'Sarah', age: 35 }
];

from(people).pipe(
  groupBy(person =&gt; person.age, p =&gt; p.name),
  mergeMap(group =&gt; zip(of(group.key), group.pipe(toArray())))
).subscribe(console.log);
</code></pre>
","6069595","","6069595","","2019-04-27 16:31:05","2019-04-27 16:31:05","How to delay in result of group by","<rxjs><rxjs5><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"55939911","1","","","2019-05-01 17:09:26","","1","87","<p>When I make a http call, I use my own http which extends httpclient. here is get method:</p>

<pre><code>return this.httpClient.get(environment.newApiEndpoint + url).map((resp) =&gt; resp['data']);
</code></pre>

<p>as you see, I transform response and only return data from it. but i also want to return 'message' and 'status' . but maybe only 'message'. what do I have to do in the <code>map</code> so that i can achieve my purpose?</p>
","10046099","","571407","","2019-05-01 17:10:33","2019-05-01 17:36:08","how to get data,message and status from http client response","<angular><rxjs><rxjs5>","1","3","","","","CC BY-SA 4.0"
"56232821","2","","37057872","2019-05-21 07:03:58","","2","","<p>I believe you were close to a good solution.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;template *ngIf = ""model | async as mycar"" &gt;
    &lt;p&gt;{{ mycar.make }}&lt;/p&gt; 
&lt;/template&gt;</code></pre>
</div>
</div>
</p>
","8523794","","","","","2019-05-21 07:03:58","","","","0","","","","CC BY-SA 4.0"
"56238325","1","56276641","","2019-05-21 12:29:28","","5","6750","<p>I have some sibling components and a <code>DataService</code> in my <code>Angular</code> (v7) project and I call methods as the following scenario:</p>

<p><code>TicketComponent</code> adds ticket and calls <code>reloadTickets</code> method in <code>TicketListComponent</code> and similarly <code>FileComponent</code> adds file and calls <code>reloadFiles</code> method in <code>FileListComponent</code> via <code>DataService</code> as shown below:</p>

<p><strong><em>DatasService.ts:</em></strong></p>

<pre><code>export class DatasService {

    private eventSubject = new BehaviorSubject&lt;any&gt;(undefined);

    getEventSubject(): BehaviorSubject&lt;any&gt; {
        return this.eventSubject;
    }

    reloadTickets(param: boolean) {
        this.eventSubject.next(param);
    }

    reloadFiles(param: any) {
        this.eventSubject.next(param);
    }
}
</code></pre>

<p><strong><em>TicketComponent:</em></strong></p>

<pre><code>ngOnInit(): void {
    this.dataService.getEventSubject().subscribe((param: any) =&gt; {
        this.reloadTickets();
    });
}
</code></pre>

<p><strong><em>FileComponent:</em></strong></p>

<pre><code>ngOnInit(): void {
    this.dataService.getEventSubject().subscribe((param: any) =&gt; {
        this.reloadFiles();
    });
}
</code></pre>

<p><br/></p>

<p>When I use single <code>BehaviorSubject</code> for these 2 methods, both methods are called at the same time when one of them is called. I mean that <em>As both of them subscribed via getEventSubject() method, reloadTickets() methods also triggers reloadFiles() in the DataService as both of them use the same subject (eventSubject).</em> I know creating another <code>BehaviorSubject</code> and <code>getEventSubject</code> method fix the problem but I am confused if I should do this for all of the independent method calls or if there is a smarter way to fix the problem via using single <code>BehaviorSubject</code> as mentioned below:</p>

<p><a href=""https://stackoverflow.com/questions/51478183/behaviorsubject-subscriber-gets-same-next-element-multiple-times"">BehaviorSubject subscriber gets same next() element multiple times</a></p>

<p>Could you please post a proper usage for this scenario? </p>

<p><strong><em>Update:</em></strong></p>

<p>Finally I have used the following approach in order to call different methods between different components using <strong>a single BehaviorSubject</strong>. </p>

<p><strong><em>EventProxyService:</em></strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable()
export class EventProxyService {

    private eventTracker = new BehaviorSubject&lt;any&gt;(undefined);

    getEvent(): BehaviorSubject&lt;any&gt; {
        return this.eventTracker;
    }

    setEvent(param: any): void {
        this.eventTracker.next(param);
    }
}
</code></pre>

<p><strong><em>CommentComponent:</em></strong> Call the method from ListComponent after a comment is added:</p>

<pre><code>import { EventProxyService } from './eventProxy.service';

export class CommentComponent implements OnInit {
    constructor(private eventProxyService: EventProxyService) {}        

    public onSubmit() {
        //...
        this.reloadComment(true);
    }

    reloadComment(param: boolean): void {
        this.eventProxyService.setEvent(param);
    }
}
</code></pre>

<p><strong><em>ListComponent:</em></strong> Triggered via reloadComment() method in CommentComponent :</p>

<pre><code>import { EventProxyService } from './eventProxy.service';

export class ListComponent implements OnInit {

    subscription;

    constructor(private eventProxyService: EventProxyService) {}

    ngOnInit() {
        this.subscription = this.eventProxyService.getEvent().subscribe((param: any) =&gt; {
            this.listComment(param);
        });
    }

    // Multi value observables must manually unsubscribe to prevent memory leaks
    ngOnDestroy(): void {
        this.subscription.unsubscribe();
    }

    listComment(param) {
        //retrieve data from service
    }
}
</code></pre>
","836018","","836018","","2019-05-29 23:03:38","2019-05-29 23:03:38","Should I use multiple BehaviorSubject for different subscriptions?","<angular><typescript><rxjs><rxjs5><rxjs6>","2","7","0","","","CC BY-SA 4.0"
"56276641","2","","56238325","2019-05-23 13:44:15","","2","","<p>It's hard for me to know what you're actually trying to achieve, but..</p>

<p>First, never use this construction, because it creates an infinte loop:</p>



<pre class=""lang-js prettyprint-override""><code>this.dataService.getEventSubject().subscribe((param: any) =&gt; {
    this.reloadTickets();
});
</code></pre>

<p>When the value changes, you have access to the new values in the component. You should only update the observable once you manipulated your data, like:</p>

<pre class=""lang-js prettyprint-override""><code>// Reads the observable
this.dataService.getEventSubject().subscribe((param: any) =&gt; {
    this.populateForm();
});

// Updates the observable
this.addTicket() {
  this.dataService.addTicket()
}
</code></pre>

<p>Next, you should always <em>type</em> your variables, for example:</p>

<pre class=""lang-js prettyprint-override""><code>export interface Ticket {
  artist: string;
  price: number;
}

export interface File {
  name: string;
  type: 'gif' | 'jpg' | 'png';
}
</code></pre>

<p>As soon as you add the types to the Observable, you notice that you actually <strong>need</strong> two Subjects.</p>

<pre class=""lang-js prettyprint-override""><code>// As a convention, It's recommended to use singular form, and add a $.
public ticket$ = new BehaviorSubject&lt;Ticket[]&gt;(null);
public file$ = new BehaviorSubject&lt;File[]&gt;(null);
</code></pre>

<p>Also, I should make them public, to have easy access without needing a <code>get()</code>. You can simply access it by injecting the service and calling the observable.</p>

<pre class=""lang-js prettyprint-override""><code>constructor(
  private dataService: DataService
)

this.dataService.ticket$
</code></pre>

<p>When you <em>need</em> to make them private, you should use:</p>

<pre class=""lang-js prettyprint-override""><code>private _ticket$: Subject&lt;Ticket[]&gt; = new BehaviorSubject&lt;Ticket[]&gt;(null);
public ticket$ = this._ticket$.asObservable();
</code></pre>

<p>With that construction, <em>you can read the observable in every service/component</em>, but only <em>update them in the containing service</em>.</p>

<p>Another thing you should always do is <em>complete</em> the observables in your component, otherwise you keep an open subscription forever:</p>

<pre class=""lang-js prettyprint-override""><code>private destroy$ = new Subject&lt;any&gt;();

ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}

this.dataService.ticket$.pipe(takeUntil(this.destroy$)).subscribe(tickets =&gt; {
  // Do something
})
</code></pre>

<hr>

<p><strong>Bottom line: When you follow the right patterns, you will get a lot less issues/bugs.</strong></p>
","1803156","","1803156","","2019-05-23 22:22:16","2019-05-23 22:22:16","","","","11","","","","CC BY-SA 4.0"
"56287670","1","","","2019-05-24 07:21:26","","0","40","<p>I want to print a list of cars whenever a new object is added to my existing array. the loop repeats and i print from start again. How can i avoid this ?</p>

<pre><code>I tried using async pipe and also track by


// in the service
           getVehicles(){
        obj = { data: [{name: 'car 1'},{name: 'car 2'}] }
            return Observable.interval(2200).map(i=&gt; obj.data.push({name: 'car 3'}));
        }


    // in the controller
    vehicles: Observable&lt;Array&lt;any&gt;&gt;
    ngOnInit() {
        this.vehicles = this._vehicleService.getVehicles().obj.data;
    }


// in template
&lt;div *ngFor='let vehicle of vehicles | async'&gt;
    {{vehicle.name}}
&lt;/div&gt;
</code></pre>

<p>expected
car 1
car 2
car 3
car 3</p>

<p>but it gives</p>

<p>car 1
car 2
car 1
car 2
car 3
car 1
car 2
car 3
car 3</p>
","6829803","","1850851","","2019-05-24 07:57:28","2019-05-24 09:05:33","every time a new object is pushed into array my loop in template repeats. how can I handle this in template?","<angular><rxjs><rxjs5><angular2-observables><angular-ngfor>","2","0","","","","CC BY-SA 4.0"
"56394878","1","","","2019-05-31 12:10:26","","2","152","<p>I have a function <code>doSomething()</code> that can be triggered by 
many different DOM events.
Is it possible to listen not to an event, but to a moment, when that function is being called/ listen to a function execution? </p>

<p>I mean - I cannot edit the original function and looking for a solution on don't want to reapeat everything attatching another function to all those events.</p>
","7607735","","8820972","","2019-05-31 12:11:44","2019-05-31 12:28:15","listening for a function execution","<javascript><rxjs><rxjs5><rxjs6>","2","1","1","","","CC BY-SA 4.0"
"56609155","1","56609261","","2019-06-15 09:35:35","","3","563","<p>Previously I was using rxjs-5 and I was using observable.partition as follows:</p>

<pre><code>const [isTiming$, isNotTiming$] = this.store.select(state =&gt; state.tetris.isTiming)
        .partition(value =&gt; value);
</code></pre>

<p>After upgrade <code>angular</code> to <code>8</code> <code>rxjs</code> got upgraded to <code>rxjs-6</code> which started throwing following error:</p>

<pre><code> providers/timer.provider.ts(27,5): error TS2339: Property 'partition' does not exist on type 'Observable&lt;boolean&gt;'.
</code></pre>

<p>when I checked in older rxjs implementation it was implemented as follows: </p>

<pre><code>  import { Observable } from '../Observable';
  import { partition as higherOrder } from '../operators/partition';
  /**
   * Splits the source Observable into two, one with values that satisfy a
   * predicate, and another with values that don't satisfy the predicate.
   */
   export function partition&lt;T&gt;(this: Observable&lt;T&gt;, predicate: (value: T, index: number) =&gt; boolean, thisArg?: any): [Observable&lt;T&gt;, Observable&lt;T&gt;] {
    return higherOrder(predicate, thisArg)(this);
  }
</code></pre>
","11584774","","","","","2019-06-15 10:11:34","error TS2339: Property 'partition' does not exist on type 'Observable<boolean>'","<angular><observable><rxjs5><rxjs6><angular8>","2","0","1","","","CC BY-SA 4.0"
"56609261","2","","56609155","2019-06-15 09:52:50","","3","","<p>After seeing <a href=""https://github.com/ReactiveX/rxjs/issues/3797"" rel=""nofollow noreferrer"">github conversion</a></p>

<p>I think we should deprecate the partition operator and remove it for v7.</p>

<p>Reasons:</p>

<ul>
<li><p>Not really an operator: partition isn't really an ""operator"" in that it returns [Observable, Observable] rather than Observable. This means it doesn't compose via pipe like the others.</p></li>
<li><p>Easy to replace with filter: partition is easily replaced with the much more widely known filter operator. As partition is effectively the same thing as: <code>const partition = (predicate) =&gt; [source.pipe(filter(predicate)), source.pipe(filter((x, i) =&gt; !predicate(x, i)))]</code></p></li>
</ul>

<p>in your case: </p>

<pre><code>import {filter} = ""rxjs/operators""
const source = this.store.select(state =&gt; state.tetris.isTiming);
const partition = (predicate) =&gt; [source.pipe(filter(predicate)), source.pipe(filter((x, i) =&gt; !predicate(x, i)))]

const [isTiming$, isNotTiming$] = partition(value =&gt; value);
</code></pre>

<ul>
<li>Rarely used: It's little used, by any code survey I've taken (within thousands of lines of code that I know use RxJS)</li>
</ul>
","4655241","","4655241","","2019-06-15 10:11:34","2019-06-15 10:11:34","","","","0","","","","CC BY-SA 4.0"
"56762201","1","56762767","","2019-06-25 21:24:49","","-1","42","<p>i have following code written in rxjs5 and it broke with rxjs6</p>

<p>can some one help me with write in rxjs 6</p>

<p>its failing mergemap receiving groupedObserable which does not have count method and along also filter method does not exist.</p>

<pre><code>list [

{id: '1', type: 't1',  name: 'f1', des:'d1', selected: true},
{id: '2', type: 't1',  name: 'f2', des:'d2', selected: false},

{id: '3', type: 't1',  name: 'f11', des:'d11', selected: false},
{id: '4', type: 't1',  name: 'f22', des:'d22', selected: true},
]

Observable.from(list)
.filter(a =&gt; a.name != null)
.groupBy(i =&gt; i.type)
.mergeMap(list =&gt; {
let count = list.count;
let selectedCount = 0;
list.filter( f =&gt; f.selected).count.subscribe(c =&gt; selectedCount = c)
return count.map(count =&gt;  {
   {
     key: list.key,
     totalCount: count,
     selected: selectedCount
   }
}
}).reduce((x, y) =&gt; {
x.isValid = x.selectedCount &gt; 0 
return x;
}).subscribe(r =&gt; {
  console.log(r + 'any item selected')
}
)
</code></pre>

<p>when i tried to write in rxjs6 only progress i was able to made till here
thanks in advance.</p>

<pre><code>from(list)
    .pipe(
    filter( s=&gt; s.name != null) ,
    groupBy(i =&gt; i.type),
    mergeMap( (value, index) =&gt; {
      value.count // that's where it starts to fail
    }
    ))
</code></pre>
","216431","","","","","2019-06-26 16:17:00","convert rxjs5 operators into rxjs6","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56762767","2","","56762201","2019-06-25 22:21:35","","1","","<p>The equivalent rxjs6 code should be like this:</p>

<pre><code>from(list)
      .pipe(
        filter(a =&gt; a.name != null),
        groupBy(i =&gt; i.type),
        mergeMap((p) =&gt; {
          return p.pipe(
                    filter(f =&gt; f.selected),
                    count(),
                    mergeMap(c =&gt; {
                      return p.pipe(
                        count(),
                        map(totalCount =&gt; {
                          return {
                            key: p.key,
                            totalCount: totalCount,
                            selected: c
                          };
                        })
                      );
                    })
                );
        }),
        reduce((x, y) =&gt; {
          //please adjust your code here as i could not see isValid on x
          x.isValid = x.selectedCount &gt; 0; 
          return x;
         })
      ).subscribe(r =&gt; {
        console.log(r + 'any item selected')
      }
      )
</code></pre>

<p>Hope it gives an idea of how to proceed.</p>
","2216584","","2216584","","2019-06-26 16:17:00","2019-06-26 16:17:00","","","","3","","","","CC BY-SA 4.0"
"56892496","1","","","2019-07-04 17:50:22","","13","5325","<p>After searching online, I see that people generally use one or the other and not both. Is it possible to use both? Is it good or bad practice?</p>

<p><strong>Edit</strong></p>

<p>I am not asking what take(1) or takeUntil is used for. Rather I am asking if it is possible to have both effects of take(1) and takeUntil. I understand that take(1) will take only the first value and end the subscription. However, it will not end the subscription if I never receive the event. I also understand that this use of takeUntil will always clean up the subscription when the component is no longer active as long as I trigger the unsubscribeSubject in the destroy. However, it will not free up that subscription after I receive the first value and will exist for the entire time the component is active.</p>

<p>What I want is a way to free the subscription after the first value as well as prevent memory leaks when the component is no longer active if not value is received. Specifically in a scenario where you have many subscriptions. This is because when you have many subscriptions, it is handy to have a single subject that can clean up all your subscriptions when the component is no longer needed.</p>

<pre><code>ngAfterViewInit(){
    //if first value comes, we process it and unsubscribe
    this.myService.GetOneTimeObservable()
        .pipe(take(1))
        .pipe(takeUntil(this.unsubscribeSubject))
        .subscribe(this.fooOT.bind(this))

    //other subscriptions (assume many)
    this.myService.GetLongLifeObservable1()
        .pipe(takeUntil(this.unsubscribeSubject))
        .subscribe(this.foo1.bind(this))

    this.myService.GetLongLifeObservable2()
        .pipe(takeUntil(this.unsubscribeSubject))
        .subscribe(this.foo2.bind(this))

    this.myService.GetLongLifeObservable3()
        .pipe(takeUntil(this.unsubscribeSubject))
        .subscribe(this.foo3.bind(this))
}

ngOnDestroy(){
    //Ideally cleans all subscriptions, including the OneTime if no value is received
    this.unsubscribeSubject.next();
    this.unsubscribeSubject.complete();
}
</code></pre>
","2461179","","2461179","","2019-07-05 14:51:18","2020-08-27 06:27:11","RXJS - Using both take(1) and takeUntil()","<angular><rxjs><rxjs5>","3","0","2","","","CC BY-SA 4.0"
"56992771","1","56993355","","2019-07-11 15:35:09","","0","873","<p>I have a service that I use to auto-fetch data at regular intervals:</p>
<pre class=""lang-js prettyprint-override""><code>export class ApiService {
    interval$: BehaviorSubject&lt;number&gt; = new BehaviorSubject&lt;number&gt;(0); // Feed a 0 initially so it makes HTTP call even if auto-refresh is 0
                                                                         // variable ending in $ is common convention to mean it is an Observable
    constructor(private http: HttpClient) { }

    getApi(url: string, auto_refresh=false) {
        if (!auto_refresh)
            return this.http.get(url);

        return this.interval$.pipe(
            switchMap(duration =&gt; {
                if (duration == 0)
                    return this.http.get(url);

                return interval(duration * 1000).pipe(
                    startWith(0),
                    switchMap(() =&gt; this.http.get(url))
                )
            })
        );
    }

    updateInterval(i: number) {
        this.interval$.next(i);
    }
}
</code></pre>
<p>This works great if I do something in a component like:</p>
<pre class=""lang-js prettyprint-override""><code>this.subscription = this.apiService.getApi('/api/foo/bar', true).subscribe(tempjson =&gt; {
    this.foo = tempjson;
});
</code></pre>
<p>If I have auto-refresh interval set to 1, it will fetch <code>/api/foo/bar</code> every second.</p>
<p>The problem is if the API returns a non <code>200</code> return code. In this case, it seems to break the Observable and never tries doing a <code>GET</code> ever again.</p>
<p>I can't figure out the root cause for this. I am guessing some sort of exception is propagating out of the Observable and makes the Observable get destroyed. But I can't figure out how to prevent it. I tried adding an error handler to the subscription, but that doesn't make any difference:</p>
<pre class=""lang-js prettyprint-override""><code>this.subscriptions.push(this.apiService.getApi('/api/modem/lte_signal_info', true).subscribe(tempjson =&gt; {
  this.lte_signal_info = tempjson;
},
error =&gt; {
  console.log(error)
}));
</code></pre>
<p>I also tried catching the error in the service itself, but it seems like you can't just swallow the exception, you have to rethrow it when you are done as per: <a href=""https://angular.io/guide/http#getting-error-details"" rel=""nofollow noreferrer"">https://angular.io/guide/http#getting-error-details</a></p>
","2516916","","6595016","","2020-07-16 15:34:06","2020-07-16 15:34:06","How to prevent Observable error propagation?","<angular><rxjs><angular5><observable><rxjs5>","1","0","","","","CC BY-SA 4.0"
"56993355","2","","56992771","2019-07-11 16:11:08","","1","","<p>As per the Observable design, if an error (exception) occurs in the observable pipeline then observable is in error state and it cannot emit new values (<a href=""https://blog.angular-university.io/rxjs-error-handling/"" rel=""nofollow noreferrer"">https://blog.angular-university.io/rxjs-error-handling/</a>) and it can be considered as completed [i.e it cannot emit new values]. Because of this reason, if API returns a non 200 code, your observable is in error state and it will not emit new values. </p>

<p>Now to keep the source observable live in case of error (in your case <code>interval</code> observable keep running in case of error), handle the error in the observable which throws an error by using <code>catchError</code> operator. Change your code like this:</p>

<pre><code>getApi(url: string, auto_refresh=false) {
      if (!auto_refresh)
          return this.http.get(url);

      return this.interval$.pipe(
          switchMap(duration =&gt; {
              if (duration == 0)
                  return this.http.get(url)
                             .pipe(
                               catchError(err =&gt; {

                                 //return an observable as per your logic
                                 //for now I am returning error wrapped in an observable
                                 //as per your logic you may process the error
                                 return of(err);
                               })
                             );

              return interval(duration * 1000).pipe(
                  startWith(0),
                  switchMap(() =&gt; {
                    return this.http.get(url)
                             .pipe(
                               catchError(err =&gt; {
                                 //return an observable as per your logic
                                 //for now I am returning error wrapped in an observable
                                 //as per your logic you may process the error
                                 return of(err);
                               })
                             );
                  })
              )
          })
      );
</code></pre>

<p>Of course, you can write a function to put the duplicate code [as you can see in the above code] and use that method.</p>

<p>Hope it will give you an idea and solves your problem.</p>
","2216584","","2216584","","2019-07-11 18:57:46","2019-07-11 18:57:46","","","","4","","","","CC BY-SA 4.0"
"57008473","1","","","2019-07-12 13:56:34","","1","602","<p>I have a simple subscription, where i want to execute some more logic at the end (both in error and success cases, that is why i need a finally/complete behaviour). The subscription looks like this:</p>

<pre><code>this.service.call(x)
 .subscribe(response =&gt; {
     ...
  }, (error: HttpErrorResponse) =&gt; {
     ...
  });
</code></pre>

<p>It is weird that i dont get the finally work.. i have tried a bunch of suggestions like </p>

<ul>
<li><p>finally(() => ...) before the .subscribe</p></li>
<li><p>pipe(finalize()...) before the .subscribe</p></li>
<li><p>a 3. callback in the current subscribe function..  (complete)</p></li>
<li><p>.add(() => {
}); after .subscribe</p></li>
</ul>

<p>None of them worked for me until now.. What should i do?</p>

<p>Content of the weird call function (external dependency):</p>

<pre><code>  public readDetails(id: string): Observable&lt;Details&gt; {
    return new Observable&lt;Details&gt;(subscriber =&gt; {
      this.appConfig.getEndpoint('details').subscribe(
        (endpoint: Endpoint) =&gt; {
          const url = `${endpoint.toUrl()}/${id}`;
          const headers = new HttpHeaders({
            ...
          });
          this.http.get&lt;Details&gt;(url, {headers})
            .subscribe(
              (response: Details) =&gt; {
                subscriber.next(response);
              },
              (error) =&gt; {
                subscriber.error(error);
              }
            );
        },
        error =&gt; subscriber.error(error)
      );
    });
  }
</code></pre>
","2224454","","2224454","","2019-07-12 14:07:59","2020-06-20 08:21:11","RxJS 5 - finally, finalize, complete, none works","<angular><rxjs><rxjs5>","2","4","","","","CC BY-SA 4.0"
"57065724","1","57065884","","2019-07-16 21:33:46","","3","1418","<p>I have an observable stream set up as below. I have an interval that is polling every two seconds. I then switchMap that to make two dependent API calls (mocked here with 'of's). After, I want to use distinctUntilChanged to make sure the final object is different. The only thing is that distinctUntilChanged doesn't fire.</p>

<p>I'm assuming it has SOMETHING to do with the fact that we are creating new streams and therefore never collects two objects to compare, but I don't fully understand.</p>

<pre><code>interval(2000).pipe(
    switchMap(() =&gt; loadData()),
  )
  .subscribe(res =&gt; console.log(res)); // { name: 'test' } is printed every two seconds

function loadData() {
  return of('API call').pipe(
     mergeMap(numb =&gt; of({ name: 'test' })),
     distinctUntilChanged((prev, cur) =&gt; {
       console.log('CompareFn'); // This will never fire.
       return JSON.stringify(prev) === JSON.stringify(cur)})
  );
}
</code></pre>

<p>Stackblitz: <a href=""https://stackblitz.com/edit/rxjs-ko6k3c?devtoolsheight=60"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-ko6k3c?devtoolsheight=60</a></p>

<p>In this case, I would like there to only be a single value ever printed from the next handler as distinctUntilChanged should stop all values after the first.</p>

<p>Would appreciate an explanation as to why this isn't working as I would expect it to.</p>
","7892913","","7892913","","2019-07-16 21:41:32","2019-07-16 21:49:06","distinctUntilChanged in nested pipe with switchMap","<rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57065884","2","","57065724","2019-07-16 21:49:06","","3","","<p>the problem is that your distinctUntilChanged is operating on the inner observable, not the outter... you need to do this</p>

<pre><code>interval(2000).pipe(
    switchMap(_ =&gt; loadData()),
    distinctUntilChanged((prev, cur) =&gt; {
       console.log('CompareFn');
       return JSON.stringify(prev) === JSON.stringify(cur);
    })
  )
  .subscribe(res =&gt; console.log(res));

function loadData() {
  return of('API call').pipe(
     mergeMap(numb =&gt; of({ name: 'test' }))
  );
}
</code></pre>

<p>in your prior set up, only one value ever reached distinctUntilChanged as the interval switched into a new observable via switch map.</p>
","4855306","","","","","2019-07-16 21:49:06","","","","1","","","","CC BY-SA 4.0"
"57175787","1","","","2019-07-24 05:25:17","","0","259","<p>I'm looking for an example on http request cache in angular >=6, I tried an example as well but some how its not working.</p>

<p>Here is the sample code I tried but not working. <a href=""https://stackblitz.com/edit/angular-jggfzh?embed=1&amp;file=src/app/app.component.html"" rel=""nofollow noreferrer"">Stackblitz Code Example</a></p>

<p>Any help will be much appreciated.</p>

<p>@JBNizet, Thank you for looking into it. Here is the service code I have. </p>

<p><strong>What I'm trying to do :</strong></p>

<p>I wrote a sample code to test http cache request, I came to know that I can implement caching using publishReplay() and refCount() from rxjs.</p>

<p><strong>Expected Behavior :</strong></p>

<p>The service should make http get call only once.</p>

<p><strong>Actual Behavior :</strong></p>

<p>The service is making http get call every time I reload the browser.
If you observe the console.log statement in my service code, its printing every time undefined which I guess shouldn't.</p>

<p><strong>Component :</strong></p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { HelloService } from './hello.service';
import { Observable } from 'rxjs';

@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {

  name = 'Angular';
  test$: Observable&lt;String&gt;;
  test: string = '';

  constructor(private helloService: HelloService) { }

  ngOnInit() {
    this.helloService.test.subscribe(res =&gt; this.test = res);
  }

}

</code></pre>

<p><strong>Service :</strong></p>

<pre><code>import { Injectable, OnDestroy } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { shareReplay, publishReplay, refCount, map } from 'rxjs/operators';

const API_ENDPOINT = 'https://api.icndb.com/jokes/random/';

@Injectable()
export class HelloService {

  private test$: Observable&lt;String&gt;;

  constructor(private http: HttpClient) { }

  get test(): Observable&lt;String&gt; {

   console.log('Object Testing : ', this.test$); \\ First time the value is undefined which is expected, second time when I execute also coming as undefined.

    if (!this.test$) {
      this.test$ = this.requestService().pipe(
        publishReplay(1),
        refCount()
      );
    }
    return this.test$;
  }

  private requestService(): Observable&lt;String&gt; {
    return this.http.get(API_ENDPOINT).pipe(
      map(response =&gt; response['type'])
    );
  }

}

</code></pre>
","11828184","","11828184","","2019-07-25 16:08:40","2019-07-25 16:08:40","angular caching in http request is not cached when using publishReplay and refCount rxjs operators","<angular><typescript><rxjs><rxjs5><angular-httpclient>","0","7","","","","CC BY-SA 4.0"
"57196188","1","","","2019-07-25 07:09:37","","1","3462","<p>I am trying to build an old project but unable to do it because of below errors.Using angular 5.2.9 to build the project but getting these errors.Can someone help</p>

<p>My package.json file looks like this</p>

<pre><code>""dependencies"": {
 ""@angular/core"": ""&gt;=5.2.9"",
 ""@angular/router"": ""&gt;=5.2.9"",
 ""ng-packagr"": ""^3.0.6"",
 ""rxjs-compat"": ""^6.2.2""
 },

  ""devDependencies"": {
    ""@angular/common"": ""&gt;=5.2.9"",
    ""@angular/compiler"": ""&gt;=5.2.9"",
    ""@angular/compiler-cli"": ""^6.1.0"",
    ""@angular/platform-browser"": ""&gt;=5.2.9"",
    ""@angular/platform-browser-dynamic"": ""&gt;=5.2.9"",
    ""@angular/platform-server"": ""&gt;=5.2.9"",
    ""@types/es6-shim"": ""^0.31.32"",
    ""@types/jasmine"": ""^2.5.40"",
    ""@types/selenium-webdriver"": ""^2.53.39"",
    ""awesome-typescript-loader"": ""^3.1.2"",
    ""extract-text-webpack-plugin"": ""^2.1.0"",
    ""jasmine-core"": ""^2.5.2"",
    ""rxjs"": ""^6.5.2"",
    ""source-map-loader"": ""^0.2.0"",
    ""ts-helpers"": ""^1.1.2"",
    ""tslint"": ""^4.5.1"",
    ""tslint-loader"": ""^3.4.3"",
    ""typescript"": ""^2.2.1"",
    ""webpack"": ""2.1.0-beta.22"",
    ""webpack-dev-middleware"": ""^1.10.1"",
    ""webpack-dev-server"": ""^2.4.1"",
    ""webpack-md5-hash"": ""0.0.5"",
    ""webpack-merge"": ""^4.0.0"",
    ""zone.js"": ""&gt;=0.7.2""
  },
</code></pre>

<p>Build is happening but I am getting these warnings when running test cases</p>

<pre><code>WARNING in ./~/rxjs-compat/observable/merge.js
Cannot find source file '../src/compat/observable/merge.ts': Error: Can't resolve '../src/compat/observable/merge.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\observable'
 @ ./~/rxjs/observable/merge.js 6:9-48
 @ ./~/@angular/core/esm5/core.js
 @ ./src/master-sales.service.ts
 @ ./src/master-sales.service.spec.ts
 @ ./src \.spec\.ts
 @ ./spec-bundle.js

WARNING in ./~/rxjs-compat/add/observable/from.js
Cannot find source file '../../src/compat/add/observable/from.ts': Error: Can't resolve '../../src/compat/add/observable/from.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\add\observable'
 @ ./~/rxjs-compat/Rx.js 24:0-32
 @ ./~/rxjs/Rx.js
 @ ./spec-bundle.js

WARNING in ./~/rxjs-compat/add/observable/fromEvent.js
Cannot find source file '../../src/compat/add/observable/fromEvent.ts': Error: Can't resolve '../../src/compat/add/observable/fromEvent.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\add\observable'
 @ ./~/rxjs-compat/Rx.js 25:0-37
 @ ./~/rxjs/Rx.js
 @ ./spec-bundle.js
WARNING in ./~/rxjs-compat/add/observable/defer.js
Cannot find source file '../../src/compat/add/observable/defer.ts': Error: Can't resolve '../../src/compat/add/observable/defer.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\add\observable'
 @ ./~/rxjs-compat/Rx.js 21:0-33
 @ ./~/rxjs/Rx.js
 @ ./spec-bundle.js
</code></pre>
","8286878","","8286878","","2019-07-27 08:41:06","2019-07-27 08:41:06","@angular/common error TS2304 cannot find name 'unknown'","<angular><rxjs><node-modules><rxjs5><rxjs6>","1","2","","","","CC BY-SA 4.0"
"57785380","1","57785459","","2019-09-04 09:25:09","","1","157","<p>I want to call several http calls, and do some operations after got all responses.</p>

<p>I tried using Observable.forkJoin, it works fine until when some of the calls got error. Seems it will catch the first response error for error handling and lost others. I want a whole list of all requests with status, successfully or fail.</p>

<pre><code>const requests: Observable&lt;any&gt;[] = [];
requests.push(...);
requests.push(...);
requests.push(...);

Observable.forkJoin(requests).subscribe(response =&gt; {
  ...
}, error =&gt; {
  ...
});
</code></pre>
","7967302","","","","","2019-09-04 09:32:17","How to get the whole result of Observable.forkJoin","<angular><rxjs><rxjs5>","2","0","","","","CC BY-SA 4.0"
"57785459","2","","57785380","2019-09-04 09:30:01","","2","","<p>You can add <code>catchError</code> operator on each of your requests</p>

<pre><code>requests.push(...pipe(
  catchError(val =&gt; console.log(val))
));
</code></pre>
","2342414","","","","","2019-09-04 09:30:01","","","","0","","","","CC BY-SA 4.0"
"58368844","1","","","2019-10-14 00:34:11","","0","88","<p>The situation is as follows:
There is a text. Every text change, and I submit a request. 
The response text is divided into parts.
Then I send each part to the server again.</p>

<p>Example:</p>

<p>Request - Response
<strong>1234567 => [1], [2], [3,4], [5, 6, 7]</strong>
Request Queue
<strong>[1] => [2] => [3,4] => [5,6,7]</strong></p>

<p>Change the text</p>

<p>Request - Response
<strong>12334567 => [1], [2], [3,3,4], [5, 6, 7]</strong></p>

<p>Here I want to compare prev answer with new one, to send only
<strong>[3, 3, 4]</strong></p>

<p>I decided to make it all as stream, and finally deal with RxJS.
Actually looking for RxJS way</p>
","5242690","","","","","2019-10-14 04:55:26","How do I cache requests using RXjs?","<rxjs><rxjs5><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"58553855","1","58553932","","2019-10-25 07:12:56","","1","176","<p>Currently I have the following request:</p>

<pre><code>      return this.registrationService.registratePerson(data).pipe(
        switchMap(
          res =&gt; {
            return this.registrationService.sendPassportScan(this.form.value.passportScanCopyFile, res.AisUserIsn);
          }
        )
      );
</code></pre>

<p>The second request makes use of the result obtained in the first one, that's something that I need but the problem with it is that now it returns what comes from the second request (the inner one). Is it possible somehow with the help of rxjs operators to make it return an observable containing fields from the inner request as well as those from the outer one?</p>

<p>In the application the 5th version of rxjs is used.</p>
","11815621","","","","","2019-10-25 07:43:45","Making two http requests sequentially in angular, rxjs","<angular><rxjs5>","2","0","1","","","CC BY-SA 4.0"
"58553932","2","","58553855","2019-10-25 07:19:01","","1","","<p>Sure. Something like this:</p>

<pre><code>return this.registrationService.registratePerson(data).pipe(
    switchMap(
        res =&gt; forkJoin(
            of(res), 
            this.registrationService.sendPassportScan(/* relevant args */),
        )))
</code></pre>

<p>(The resulting stream will contain a 2 element array).</p>
","7194268","","","","","2019-10-25 07:19:01","","","","2","","","","CC BY-SA 4.0"
"58598965","1","58599397","","2019-10-28 22:01:50","","0","370","<p>I have a method that creates timer:</p>

<pre><code> create(options: any) {
    return timer(0, 1000).pipe(
      map(() =&gt; {
        return options;
      }),
      takeWhile(() =&gt; new Date() &lt; options.finishDate)
    );
  }
</code></pre>

<p>Then this timer I add to array <code>this.timers</code> of Observables:</p>

<pre><code>this.timers.push(this.create({finishDate: new Date()}))
</code></pre>

<p>When I merge observers:</p>

<pre><code>this.mergeObserver = Observable.merge(this.timers).subscribe(x =&gt; {
   console.log(x);
});
</code></pre>

<p>I see that <code>console.log(x);</code> continues work despite timer was finished.</p>

<p>Why? And how to stop all timers in array?</p>

<p>I can unsubscribe  here:</p>

<pre><code> Observable.merge(this.timers).subscribe(x =&gt; {
   x.unsubscribe();
});
</code></pre>

<p>But it does not stop <code>Observable.merge</code>.</p>
","","user11314257","","user11314257","2019-10-28 22:11:33","2019-10-28 22:55:45","How to stop observers in Observable.merge?","<javascript><rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58599397","2","","58598965","2019-10-28 22:55:45","","1","","<pre><code>this.mergeObserver = Observable.merge(this.timers).subscribe(x =&gt; {
   console.log(x);
});
</code></pre>

<p>In this case mergeObserver is not an observable but a subscription. The subscribe method returns a subscription. So renaming this to mergeSubscription and calling unsubscribe on this object is how to unsubscribe.</p>

<p>If you want a reference to the observable you need to subscribe after you have taken a reference.</p>

<pre><code>this.mergeObserver = Observable.merge(this.timers);

this.mergeSubscription = this.mergeObserver.subscribe(x =&gt; {
   console.log(x);
});
</code></pre>

<p>and then you unsubscribe with the mergeSubscription object.</p>

<pre><code>Observable.merge(this.timers).subscribe(x =&gt; {
   x.unsubscribe();
});
</code></pre>

<p>Here you cannot call unsubscribe on x as x is the value that comes out of the merged timers. When one of the timers emits then the merge will emit that value as well, it is just a number and does not have an unsubscribe method.</p>
","1679126","","","","","2019-10-28 22:55:45","","","","3","","","","CC BY-SA 4.0"
"58608627","1","58608721","","2019-10-29 13:42:43","","-1","38","<p>I have old Rxjs merge:</p>

<pre><code>Observable.merge(this.timers).subscribe(x =&gt; {
      let subscription = x.subscribe((value: ITimer) =&gt; {});

});
</code></pre>

<p>How to rewrite it on new Rxjs notation?</p>

<p>I have tried import this:</p>

<pre><code>import { merge } from ""rxjs/operators"";
</code></pre>
","8291684","","","","","2019-10-29 13:47:55","How to rewrite merge on new Rxjs?","<rxjs><rxjs5><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"58608721","2","","58608627","2019-10-29 13:47:55","","1","","<p>As you can see: <code>merge</code> is still part of rxjs, it doesn't live as an operator... It is just a factory from which you can create a new observable out of n...</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { merge, from } = rxjs;

const a$ = from([1, 2, 3, 4]);
const b$ = from(['hello', 'world', 'dude']);

merge(a$, b$).subscribe(console.log);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.5.3/rxjs.umd.js"" integrity=""sha256-Nihli32xEO2dsnrW29M+krVxoeDblkRBTkk5ZLQJ6O8="" crossorigin=""anonymous""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","4099454","","","","","2019-10-29 13:47:55","","","","0","","","","CC BY-SA 4.0"
"58617865","1","58618347","","2019-10-30 02:17:39","","2","882","<p>I use <code>rxjs</code> in <code>React Native</code>. I call <code>Observable.fromPromise(storage.load({key: key})).map(() =&gt; value);</code> shows the error.</p>

<p>My rxjs version:</p>

<pre><code>""rxjs"": ""^6.5.3"",
""rxjs-compat"": ""^6.5.3"",
</code></pre>

<p>I have three steps.</p>

<p>Step1:</p>

<pre><code>rxInit().flatMap(() =&gt; {

  console.log('I can not see the console log');

  return rxInit()

}).subscribe(() =&gt; {

  console.log('I can not see the console log');
  // some code...

})
</code></pre>

<p>Step2 rxInit():</p>

<pre><code>import { Observable } from 'rxjs';

  rxInit() {
    console.log('I can see the console log')

    return StorageService.shared.get('deviceuuid').flatMap((deviceuuid) =&gt; {

      console.log('I can't not see the console log')

      if (deviceuuid == null) {
        return StorageService.shared.set('deviceuuid', this.deviceuuid);
      } else {
        return Observable.of(this.deviceuuid);
      }

    }).do((deviceuuid) =&gt; {
        // some code...
    })
  }
</code></pre>

<p>Step3 about the get():</p>

<pre><code>import { Observable } from 'rxjs';
import Storage from 'react-native-storage';
import AsyncStorage from '@react-native-community/async-storage';

let storage = new Storage({
  size: 1000,
  storageBackend: AsyncStorage,
  defaultExpires: null,
})  

export default class StorageService {
  set(key, value) {
    console.log('StorageService set');
    return Observable.fromPromise(storage.save({ key: key, data: value })).map(() =&gt; value);
  }

  get(key) {
    console.log('It is a ', storage.load({key: key}));  // It is a Promise
    return Observable.fromPromise(storage.load({key: key})).map(() =&gt; value);
  }

  remove(key) {
    return Observable.fromPromise(storage.remove({key: key})).catch(() =&gt; Observable.of(null))
  }
}

StorageService.shared = new StorageService();
</code></pre>

<p>I looking for some answer, somebody says it is because rxjs is above 6.0, so I try to use </p>

<pre><code>import { from } from 'rxjs';

return from(storage.load({key: key})).map(() =&gt; value);
</code></pre>

<p>It sill shows </p>

<pre><code>TypeError: _rxjs.from.fromPromise is not a function
</code></pre>

<p>or</p>

<pre><code>_rxjs.from().map is not a function.
</code></pre>

<p>Any help would be appreciated.</p>
","6902961","","6902961","","2019-10-30 02:36:27","2019-10-30 03:29:01","TypeError: _rxjs.Observable.fromPromise is not a function","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"58618347","2","","58617865","2019-10-30 03:29:01","","2","","<p>I understand that there are already some hints on the comments, but I will provide an answer to give more context to the answer.</p>

<p>For RxJS 6, the practice when it comes to working with RxJS operators (such as map and switchMap) would be to use the <code>pipe</code> utility, rather than dot-chaining the operators. You may read more about the changes over <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Building onto your example, for instance, if you want to use both <code>map</code> and <code>filter</code> operators, rather than doing something like</p>

<pre><code>from(storage.load({key: key})).map(() =&gt; value).filter(value =&gt; value)
</code></pre>

<p>RxJS 6 will require you to do this instead:</p>

<pre><code>from(storage.load({key: key}))
  .pipe(
    map(() =&gt; value),
    filter(value =&gt; value),
  .subscribe(res =&gt; {
    console.log(res);
    // do the rest here
  })
</code></pre>
","10959940","","","","","2019-10-30 03:29:01","","","","0","","","","CC BY-SA 4.0"
"58619944","1","58620434","","2019-10-30 06:48:35","","0","787","<p>I use the code with <code>rxjs 5.5.12</code> in React Native, it works.</p>

<p>In rxjs 5.5.12:</p>

<pre><code>// the function will return Observable
  rxInit() {
    return Observable.combineLatest(
      myObservable1,
      myObservable2,
    ).flatMap((result) =&gt; {
      console.log('rxInit result =&gt;', result) // I can see the result
      const [token, email] = result

      this.token = token
      this.email = email

      // check the value is empty or not and return Observable.

      if (this.token != null &amp;&amp; this.email != null) {
        return Observable.fromPromise(myApiPromise).catch(handleErrorFunction)
      } else if (this.token != null &amp;&amp; this.uid != null) {
        return Observable.fromPromise(myApiPromise).catch(handleErrorFunction)
      } else {
        return Observable.of(null)
      }
    })
  }
</code></pre>

<p>In rxjs 6.5.3:</p>

<p>import some oerator first:</p>

<pre><code>import { combineLatest } from 'rxjs';
import { flatMap } from 'rxjs/operators';
</code></pre>

<p>I change the code:</p>

<pre><code>rxInit() {
  console.log('rxInit start');

  return combineLatest(
    myObservable1,
    myObservable2
   ).flatMap((result) =&gt; {
     console.log('rxInit result =&gt;', result)
   });

   console.log('rxInit end');
 }
</code></pre>

<p>It will show error <code>TypeError: (0 , _rxjs.combineLatest)(...).flatMap is not a function</code>.</p>

<p>So I note that may be I have to use <code>pipe</code>, I try to change the code.</p>

<pre><code>rxInit() {
    console.log('rxInit start'); // it works.

    return combineLatest(
      myObservable1,
      myObservable2
    ).pipe(flatMap((result) =&gt; {
      console.log('rxInit result =&gt;', result);  // the console log doesn't work
    }));
    console.log('rxInit end'); // the console log doesn't work
  }
</code></pre>

<p>I have no idea why I can't get the result in my console.log.</p>

<p>Any help would be appreciated.</p>
","6902961","","","","","2019-10-30 07:30:58","How to use combineLatest with flatMap in rxjs6?","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58620434","2","","58619944","2019-10-30 07:30:58","","2","","<p>looks like you are not returning anything from flatMap(), mergeMap is used in rxjs in favor of flatMap btw. You need to return an observable. </p>

<pre><code>return combineLatest(
  myObservable1,
  myObservable2
).pipe(mergeMap((result) =&gt; {
  console.log('rxInit result =&gt;', result);  // the console log doesn't work
  return of(result)
}));
</code></pre>
","8618350","","","","","2019-10-30 07:30:58","","","","1","","","","CC BY-SA 4.0"
"58622320","1","58622526","","2019-10-30 09:33:49","","0","190","<p>In <code>rxjs 5.5.12</code>, I created a <code>login()</code> to <code>subscribe</code> with multiple observable by <code>do()</code></p>

<pre><code>login(userEmail, userPassword).subscribe((response) =&gt; {
  console.log(response);

  if (response === 'something') {
    // some actions
  } else {
    // some actions
  }
},(error) =&gt; {
  // some error actions
});
</code></pre>

<p>I use rxLoginPOST to call api:</p>

<pre><code>rxLoginPOST(url, params) {
  return Rx.Observable.fromPromise(somePromise).catch(handleErrFunction);
}
</code></pre>

<p>I use it in login function it return multiple observable:</p>

<pre><code>login(email, password) {
  return APIService.shared.rxLoginPOST('users/signin', { ...arguments })
  .flatMap((response) =&gt; {
    if (response.status === 200) {
        return Rx.Observable.combineLatest(
          myObservable1,
          myObservable2,
          myObservable3
        )
      } else {
        return Rx.Observable.of(response)
      }
  }).do((result) =&gt; {
      if (result.length &gt; 0) {
        // some logic
      } else {
        return Rx.Observable.of(result)
      }
  }).flatMap((result) =&gt; {
      if (result.length &gt; 0) {
        return this.checkUserIsRegistered()
      } else {
        return Rx.Observable.of(result)
      }
  })
}
</code></pre>

<p>In <code>rxjs 6.5.3</code>, I had changed all the import like</p>

<pre><code>import { Observable, combineLatest, of } from 'rxjs';
import { mergeMap, map, catchError, flatMap, tap } from 'rxjs/operators';
</code></pre>

<p>If I trigger <code>login()</code> it will show <code>do is not a function</code></p>

<p>So I change the code:</p>

<pre><code>login(userEmail, password) {
    return APIService.shared.rxLoginPOST('users/signin', { ...arguments }).pipe(
        mergeMap((response) =&gt; {
        if (response.status === 200) {
          return combineLatest(
            myObservable1,
            myObservable2,
            myObservable3
          )
        } else {
          return of(response)
        }
      }).tap((result) =&gt; { // I am stuck here, I have no idea how to continue with it...
         console.log('check 4');  // check 4 does not appear.
         console.log('response', response);
         return of(response)
      }
    );
</code></pre>

<p>I try to use <code>tap</code> instead of <code>do</code>, but check 4 does not appear.</p>

<p>Any help would be appreciated.</p>
","6902961","","","","","2019-11-04 16:39:04","How to subscribe multiple observable in rxjs 6 ? do is not a function in rxjs 6","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58622526","2","","58622320","2019-10-30 09:45:41","","1","","<p>With <code>pipe</code>, you should chain your operators like this: <code>pipe(op1, op2)</code> and not like <code>pipe(op1).op2()</code></p>

<pre><code>login(userEmail, password) {
    return APIService.shared.rxLoginPOST('users/signin', { ...arguments })
      .pipe(
          mergeMap((response) =&gt; {
            if (response.status === 200) {
              return combineLatest(
                myObservable1,
                myObservable2,
                myObservable3
              )
            }
            return of(response)
          }),
          tap((result) =&gt; { 
            console.log('check 4');  // check 4 does not appear.
            console.log('response', response);
          })
        );
</code></pre>

<p>I also removed your useless <code>else</code> statement since you are returning something before :)</p>

<p><strong>EDIT</strong>: As suggested in comments, the <code>return</code> instruction from <code>tap</code> has also been removed since unecessary</p>
","10417856","","10417856","","2019-11-04 16:39:04","2019-11-04 16:39:04","","","","1","","","","CC BY-SA 4.0"
"58806560","1","58806697","","2019-11-11 18:11:19","","0","21","<p>Hi I am getting an error when i tries to do the following operation </p>

<pre><code>export class FlightFormTemplatesStepComponent
{

 tagonMessagePrefix: TagOnMessagePrefix;


  ngOnInit() {
     this.flightService.get(this.flightId).pipe(
         tap (flight =&gt; {this.flight = flight}),
         mergeMap( (flight) =&gt; {
           return this.flightService.getTagonMessagePrefix(flight);
         })
        ).subscribe(
          (tagonMessagePrefix) =&gt; { this.tagonMessagePrefix = tagonMessagePrefix}

        );
   }
}
</code></pre>

<p>this is the error I am recieving. </p>

<pre><code>property) FlightFormTemplatesStepComponent.tagonMessagePrefix: TagOnMessagePrefix
Type '{}' is missing the following properties from type 'TagOnMessagePrefix': id, flightName, flightTagonTypes, configuredGlobalTagonSettings, tagonTextts(2739)
</code></pre>

<p>Any idea how can i fix this issue </p>
","11957755","","11957755","","2019-11-11 18:16:31","2019-11-11 22:52:23","How can I pass the output of an http call as input to another http call in Rx JS?","<rxjs><angular5><rxjs5><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"58806697","2","","58806560","2019-11-11 18:21:57","","0","","<p>I changed to map operation and it works </p>

<pre><code>this.flightService.get(this.flightId).pipe(
 tap (flight =&gt; {this.flight = flight}),
 switchMap( (flight) =&gt; {
   return this.flightService.getTagonMessagePrefix(flight);
 })
).subscribe(
  (tagonMessagePrefix:TagonMessagePrefix) =&gt; { this.tagonMessagePrefix = tagonMessagePrefix}

);
</code></pre>
","11957755","","11957755","","2019-11-11 22:52:23","2019-11-11 22:52:23","","","","0","","","","CC BY-SA 4.0"
"59160503","1","","","2019-12-03 15:35:00","","1","924","<p>I stumbled upon a weird issue that I can't explain, here is effects code that I'm referring to:</p>

<pre class=""lang-js prettyprint-override""><code>import { Injectable } from '@angular/core';
import { Actions, Effect, ofType } from '@ngrx/effects';
import { Store } from '@ngrx/store';
import { combineLatest } from 'rxjs/observable/combineLatest';
import { withLatestFrom, tap, map } from 'rxjs/operators';


@Injectable()
export class SomeEffects {
  constructor (
    private actions$: Actions,
    private smthStore1: Store&lt;fromSmth1.State&gt;,
    private smthStore2: Store&lt;fromSmth2.State&gt;,
    private smthStore3: Store&lt;fromSmth3.State&gt;,
    private smthStore4: Store&lt;fromSmth4.State&gt;,
    private smthStore5: Store&lt;fromSmth5.State&gt;,
  ) {}

  private common$ = combineLatest(
    this.smthStore1.select(fromSmth1.getSmth),
    this.smthStore2.select(fromSmth2.getSmth),
    this.smthStore3.select(fromSmth3.getSmth),
    this.smthStore4.select(fromSmth4.getSmth),
    this.smthStore5.select(fromSmth5.getSmth),
  ).pipe(
    map(([smth1, smth2, smth3, smth4, smth5]) =&gt; ({ smth1, smth2, smth3, smth4, smth5 }))
  );

  @Effect({ dispatch: false })
  public someEffect$ = this.actions$
    .pipe(
      ofType(actions.SOME_ACTION),
      withLatestFrom(this.common$),
      tap(([action, data]) =&gt; do something...),
    );
}
</code></pre>

<p>So I have several effects relying on common$ stream. This is a stream that I built purely to not repeat myself in every effect and just compose actions$ and common$ for the same effect, but for some reason this does not work. App just stops loading without any errors.</p>

<p>Now if I comment out withLatestFrom, app is working again:</p>

<pre class=""lang-js prettyprint-override""><code>@Effect({ dispatch: false })
public someEffect$ = this.actions$
  .pipe(
    ofType(actions.SOME_ACTION),
//    withLatestFrom(this.common$),
    tap(([action, data]) =&gt; do something...),
  );
</code></pre>

<p>Is there something I'm missing about rxjs and ngrx?</p>

<p>Angular 5
RxJS 5</p>
","3267198","","","","","2020-11-20 14:49:43","Streams composition using withLatesFrom or combineLatest in ngrx effects","<angular><rxjs><ngrx><rxjs5><ngrx-effects>","2","2","","","","CC BY-SA 4.0"
"59650312","1","","","2020-01-08 16:42:49","","7","569","<p>I have 5 different API calls to make, and they all are chained right now in forkJoin. 
My new requirement is the subscribe should fire anytime any new observable solves. </p>

<p>Is there any operator or any other trick in rxjs where I can keep the chaining but, it should fire each time any observable solves?</p>

<pre><code>forkJoin(
        this.myService.api1(),
        this.myService.api2(),
        this.myService.api3(),
        this.myService.api4(),
        this.myService.api5()
    )
        .subscribe(
            ([r1,r2,r3,r4,r5]) =&gt; { ... do something })
</code></pre>
","2955866","","","","","2020-01-08 22:25:16","Hasty forkjoin alternative rxjs for observable chaining?","<angular><rxjs><rxjs5>","2","6","1","","","CC BY-SA 4.0"
"59678514","2","","49993155","2020-01-10 09:09:45","","8","","<p>This is happening due to <a href=""https://stackoverflow.com/questions/43774407/rx-js-understanding-the-lift-method""><code>lift</code></a> called on <a href=""https://github.com/ReactiveX/rxjs/blob/388c4852948660abcff22d7b82ccb0a29c77428c/src/internal/Subject.ts#L55"" rel=""nofollow noreferrer""><code>Subject</code></a>.</p>
<p>Let's take a deeper look at your example:</p>
<ol>
<li>You are instantiating a <code>BehaviorSubject</code> which extends
<code>Subject</code></li>
<li>You are calling <code>pluck</code> operator which <a href=""https://github.com/ReactiveX/rxjs/blob/e0c5b7c790bb9d99fa8bee26c805b5e70c1e456b/src/internal/operators/pluck.ts#L53"" rel=""nofollow noreferrer"">internally</a> calls
<code>map</code> operator</li>
<li><code>map</code> operator <a href=""https://github.com/ReactiveX/rxjs/blob/df0ea7c78767c07a6ed839608af5a7bb4cefbde5/src/internal/operators/map.ts#L47"" rel=""nofollow noreferrer"">internally</a> calls <code>lift</code> on <code>BehaviorSubject</code> which is delegated to <code>Subject</code> which then returns an <code>AnonymousSubject</code></li>
</ol>
","10715502","","10715502","","2021-10-13 04:18:12","2021-10-13 04:18:12","","","","0","","","","CC BY-SA 4.0"
"60418574","1","","","2020-02-26 16:37:53","","0","249","<p>I am using RxJs concatMap to control the saving of some data in my application.</p>

<pre><code>this.myService.saveData(this.updatedData)
  .pipe(
    tap(data1Res =&gt; this.onData1Success(data1Res)),
    concatMap(() =&gt; this.myService.saveOne(this.OneData)),
    tap(data2Res =&gt; this.onData2Success(data2Res)),
    concatMap(() =&gt; this.myService.saveTwo(this.TwoData)),
    tap(data3Res =&gt; this.onData3Success(data3Res)),
    concatMap(() =&gt; this.myService.saveThree(this.ThreeData)),
    tap(data4Res =&gt; this.onData4Success(data4Res)),
    concatMap(() =&gt; this.myService.saveFour(this.FourData)),
  )
  .subscribe(
    res =&gt; this.onSaveSuccess(), // Reload values
    err =&gt; console.log('error while saving', err) // Save to file or db
  );
</code></pre>

<p>Currently this works however it also executes even if say ""this.OneData"" is empty or null...how can I keep it from sending essentially a NoOpp request?</p>
","3557112","","","","","2020-02-27 11:29:02","Using RxJs ConcatMap don't send a value of null or empty string","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"60569209","1","60570110","","2020-03-06 17:48:58","","0","332","<p>Values is list of obervables over input fields</p>

<pre><code>    var example = combineLatest(values);
</code></pre>

<p>How do I find sum of values in text field.</p>

<pre><code>    example.subscribe(val =&gt; {
        console.log('Sum:', val);
    });
</code></pre>

<p>Having subscriber over it gives me output of the form </p>

<p><em>Sum: (2)Â [""1"", ""2""]</em></p>

<p>Piping over combineLatest gives me NaN</p>

<pre><code>     .pipe(reduce((acc, one) =&gt; {
         var a =Number(acc) + Number(one);
         console.log(a);
         return a;
     }, 0));
</code></pre>
","4206540","","","","","2020-03-06 19:00:20","How to find sum using reduce, pipe and combinelatest?","<javascript><rxjs><rxjs5><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"60570110","2","","60569209","2020-03-06 19:00:20","","3","","<p>You don't have to reduce the Observable, you have to reduce the array it emits.</p>

<pre><code>var example = combineLatest(values).pipe(
  map(array =&gt; array.reduce((pv, cv) =&gt; pv + Number(cv), 0))
);
</code></pre>
","9423231","","","","","2020-03-06 19:00:20","","","","0","","","","CC BY-SA 4.0"
"60607260","1","","","2020-03-09 19:35:47","","0","45","<p>Im trying to update this code to version 6 but I cannot figure out how rework the flow, from reading and playing around I think I need to pipe results etc but I cant see how it can be done using the flow of merge, filter, timer, map, first, toPromise() that used to work. Any RxJS folks able to educate me or point me in the right direction ?</p>

<pre class=""lang-js prettyprint-override""><code>const chats: chats[] = &lt;chats[]&gt;await Observable.merge(
  this.chatService.$chats.filter(chats =&gt; chats.length &gt; 0),
  Observable.timer(5000).map(x =&gt; { 
    throw 'Timeout'
  })
).first().toPromise()

if(chats.find( chat =&gt; chat.id === chatId )) {
  this.log.log(`Found active chat ${chatId}, navigating to it from push notification...`)                       
}
</code></pre>
","12903777","","9423231","","2020-03-10 12:31:39","2020-03-10 12:31:39","Converting old RxJS code to v6 : merge, filter, timer, map, first, toPromise()","<rxjs><rxjs5><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"60673374","1","60673460","","2020-03-13 15:40:17","","0","17","<p>Hi i am getting an error in my code . I have an angular 5 formGroup and i am trying to use the pipe operation and switchMap inside.</p>

<p>However it give me an error. The following is my code snippet.</p>

<pre><code>this.formGroup.valueChanges.pipe(
  switchMap(
      (formValue) =&gt; {
        console.log(formValue);
      }

  )

).subscribe();
</code></pre>

<p>the error i is as below</p>

<pre><code>Argument of type '(formValue: any) =&gt; void' is not assignable to parameter of type '(value: any, index: number) =&gt; ObservableInput&lt;{}&gt;'.
  Type 'void' is not assignable to type 'ObservableInput&lt;{}&gt;'.ts(2345)
</code></pre>

<p>really appreciate any help
thank you </p>
","11957755","","","","","2020-03-13 16:56:42","compilation problem/error while using an rxjs switchmap","<rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"60673460","2","","60673374","2020-03-13 15:46:15","","0","","<p>You have to return an <code>observable</code> in the <code>switchMap</code>. <code>switchMap</code> switches to a new observable and you can do it conditionally based on the previous value.</p>

<p>If you want to just <code>console.log</code>, I would use <code>tap</code>.</p>

<pre><code>this.formGroup.valueChanges.pipe(
  tap(
      (formValue) =&gt; {
        console.log(formValue);
      }

  ),

).subscribe();
</code></pre>

<p>====================== Edit ==========================
I assume <code>this.generatePerformanceGraph(formValue);</code> is a regular function and it doesn't return an observable, then you can do it in the <code>subscribe</code>.</p>

<pre><code>this.formGroup.valueChanges.pipe(
  tap( // you can remove this tap, it is just for logging
      (formValue) =&gt; {
        console.log(formValue);
      }

  ),

).subscribe(formValue =&gt; {
  this.generatePerformanceGraph(formValue);
});
</code></pre>
","7365461","","7365461","","2020-03-13 16:56:42","2020-03-13 16:56:42","","","","2","","","","CC BY-SA 4.0"
"60674548","1","60675723","","2020-03-13 17:03:00","","0","72","<p>Hi I am having a small code snippet in my project . </p>

<p>it basically subscribe to an angular form group and calls a method generatePerformanceGraph that draws an svg. </p>

<p>the form group has around 6 form controls . the problem is some times when i change the value of a form control , it will set another values to another form controls. As a result  when i change some form control value it causes generatePerformanceGraph to called multiple times . How can i prevent this problem . </p>

<p>in short basically what i want is when there is a change in form group ,I would like to subscribe to the last observable and then execute the generatePerformanceGraph once.</p>

<pre><code>this.formGroup.valueChanges.subscribe(formValue =&gt; {
  if(this.formGroup.valid) {
    this.generatePerformanceGraph(formValue);
  }
});
</code></pre>

<p>I have tried the following how ever it didnt work out well.</p>

<pre><code>this.formGroup.valueChanges.
pipe(
  distinctUntilChanged()
) .subscribe( formValue =&gt; {
  if(this.formGroup.valid) {
    this.generatePerformanceGraph(formValue);
  }
});
</code></pre>
","11957755","","11957755","","2020-03-13 17:25:55","2020-03-14 03:38:28","how to subscribe to the last observable and execute a funtion in rxjs?","<rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"60675723","2","","60674548","2020-03-13 18:42:29","","1","","<p>Try <code>debounceTime</code>, the time is up to you in <code>ms</code>. The <code>debounceTime</code> ignores events that happen within <code>200ms</code> of each other and only accept the last one.</p>

<p><a href=""https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime</a></p>

<pre><code>this.formGroup.valueChanges.
pipe(
  debounceTime(200),
) .subscribe( formValue =&gt; {
  if(this.formGroup.valid) {
    this.generatePerformanceGraph(formValue);
  }
});
</code></pre>

<p>To go the <code>distinctUntilChanged</code> way, you have to do it a different way because <code>formValue</code> is an object.</p>

<pre><code>this.formGroup.valueChanges.
pipe(
  distinctUntilChanged((prev, curr) =&gt; JSON.stringify(prev) === JSON.stringify(curr)),
) .subscribe( formValue =&gt; {
  if(this.formGroup.valid) {
    this.generatePerformanceGraph(formValue);
  }
});
</code></pre>
","7365461","","7365461","","2020-03-14 03:38:28","2020-03-14 03:38:28","","","","0","","","","CC BY-SA 4.0"
"60871229","1","60871399","","2020-03-26 15:57:58","","1","126","<p>I have multiple http request in angular 5 application. </p>

<pre><code>const response1 = this.http.get('url1').subscribe(data =&gt; {
    this.list1 = data;
});

const response2 = this.http.get('url2').subscribe(data =&gt; {
    this.list2 = data;
});

const response3 = this.http.get('url3').subscribe(data =&gt; {
    this.list3 = data;
});

const response4 = this.http.get('url4').subscribe(data =&gt; {
    this.list4 = data;
});
</code></pre>

<p>So I can get <code>this.list1</code>, <code>this.list2</code>, <code>this.list3</code> and <code>this.list4</code>. Then I want to use these data to render the UI. I used the sequential call and took some time. Now I want to use forkJoin.</p>

<p>My code likes.</p>

<pre><code>const response1 = this.http.get('url1').subscribe(data =&gt; {
    this.list1 = data;
});

const response2 = this.http.get('url2').subscribe(data =&gt; {
    this.list2 = data;
});

const response3 = this.http.get('url3').subscribe(data =&gt; {
    this.list3 = data;
});

const response4 = this.http.get('url4').subscribe(data =&gt; {
    this.list4 = data;
});

return Observable.forkJoin([response1, response2, response3, response4]).then(this.loadUiFromAllList());
</code></pre>

<p>I am not sure how to use it correctly? How can I get the results from forkJoin then doing something? This is for <code>rxjs 5.5.6.</code></p>
","12121988","","","","","2020-03-26 16:40:33","How to use fofkJoin to get multiple results then using the results?","<javascript><angular><typescript><rxjs5>","4","0","","","","CC BY-SA 4.0"
"60871399","2","","60871229","2020-03-26 16:06:50","","1","","<p>forkJoin takes Observables, not subscriptions which are returned by subscribe method. So you need to a little refactor your code.</p>

<p>Also there is no need to import Observable. You could import forkJoin directly. </p>

<p>Here is nice source of knowledge and examples: <a href=""https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin</a></p>

<pre class=""lang-js prettyprint-override""><code>import {forkJoin} from ""rxjs/observable/forkJoin"";
</code></pre>

<pre class=""lang-js prettyprint-override""><code>const source1 = this.http.get('url1');

const source2 = this.http.get('url2');

const source3 = this.http.get('url3');

const source4 = this.http.get('url4');

return forkJoin([source1, source2, source3, source4])
  .subscribe(([response1, response2, response3, response4]) =&gt; {
    // here you can assign responses to properties: 
    // this.list1 = response1...
    this.loadUiFromAllList()
  },
  (error) =&gt; {
    // here you can handle error
  });
</code></pre>
","13093310","","13093310","","2020-03-26 16:35:29","2020-03-26 16:35:29","","","","5","","","","CC BY-SA 4.0"
"61035351","1","61036283","","2020-04-04 21:57:34","","1","263","<p>I am working on a front-end project with Rxjs and Angular Framework and I want to get json data from a api ""api/data_processor_classlib.php...."". There are three parts was subscribed the pipe this.webProtectionHTML$ at HTML. I don't know why the pipe this.webProtectionHTML$ made requests 3 times. Is any possible solution that just sent one request and update all data in HTML? Thanks.</p>

<p>HTML Code:</p>

<pre><code>    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Phishing &amp; Other Frauds&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.phishing}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Spam URLs&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.spamURLs}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Malware Sites&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.malware}}&lt;/div&gt;
    &lt;/div&gt;
</code></pre>

<p>Component:</p>

<pre><code>this.webProtectionHTML$ = this.dayService$
      .pipe(
        mergeMap((days: DaysPeriod // params added to request url) =&gt; this.httpClient.get(`api/data_processor_classlib.php....`//request url, { responseType: 'text' })),
        map((html: string) =&gt; {
          //get html code and find data return as json data
          let result = this.getWebProtectionData(html)
          return result
        }))
</code></pre>

<p>Network log:</p>

<p><a href=""https://i.stack.imgur.com/H4asb.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/H4asb.jpg"" alt=""enter image description here""></a></p>
","12919784","","","","","2020-04-05 12:25:52","How to remove the redundant requests in RXJS?","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","5","0","1","","","CC BY-SA 4.0"
"61036283","2","","61035351","2020-04-04 23:49:32","","5","","<p>A few previous answers correctly point out that each usage of <code>async</code> pipe results in a http request - but don't explain why. In fact it's not an issue with the async pipe per se. It's because your http request observable is ""cold"" (as explained e.g. here: <a href=""https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#what-is-an-observable"" rel=""noreferrer"">https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#what-is-an-observable</a>).</p>

<p>""Cold"" observable means it will only start doing smth and emitting values when some consumer subscribes to it. Moreover, by default each new subscription initiates new execution - even if multiple subscriptions to the same observable are created in parallel. This is exactly what you observed in your code: each async pipe subscribes to the observable separately.</p>

<p>There are a couple of ways to fix that.</p>

<ol>
<li><p>Make sure you only have a single subscription. The answer by @Michael D exploits this approach. This is quite a common way to address the problem. A potential drawback is that the subscription manually created this way is not automatically unsubscribed from when the component is destroyed. In your example it might not be a big deal (if <code>dayService$</code> only emits a single value). However, if the component is destroyed before the http request has finished, this http request would not be canceled without writing some extra code (involves implementing a ngOnDestroy lifecycle method). Another drawback - you would need to manually call <code>changeDetector.markForCheck()</code>, if your component uses OnPush.</p></li>
<li><p>Make this observable ""hot"". ""Hot"" means the async action has initiated already, and all subscribers will just receive the result of that action - no matter how many subscribers there are. Using .toPromise(), as suggested by @xdeepakv, does exactly that. Note that promises are not cancellable at all - so you will have no way to cancel such a request. Another drawback - it only works if your observable emits a single value and then completes (e.g a single http request). </p></li>
<li><p>You can use <code>shareReplay({refCount: true})</code> operator to make your observable muticast - this allows multiple subscribers to share the same result. In this case you won't need to change your template, (can have multiple async pipes) and benefit from auto-unsubscribe / http request cancelation implemented in the async pipe.</p></li>
</ol>

<pre><code>this.webProtectionHTML$ = dayService$.pipe(
  mergeMap(...),
  map(...),
  shareReplay({refCount: true}) // &lt;- making it a multicast
)
</code></pre>
","2638874","","","","","2020-04-04 23:49:32","","","","0","","","","CC BY-SA 4.0"
"61050264","1","","","2020-04-05 22:16:47","","2","109","<p>I'm trying to convert promise chaining:</p>

<pre><code>this.tradeTypesLogicService.getList().$promise
    .then(this.filterTradeTypes)
    .then(this.setSelectedTradeType)
</code></pre>

<p>to an rxjs observable:</p>

<pre><code>this.tradeTypesLogicService
    .getList() //returns observable now
    .pipe(mergeMap(this.filterTradeTypes), map(this.setSelectedTradeType))
    .subscribe();



protected filterTradeTypes = (tradeTypes: Array&lt;any&gt;) =&gt; {
    this.tradeTypes = filter(tradeTypes, (trade) =&gt; {
        if (trade.id === this.mappedItem.tradeTypeId &amp;&amp; !trade.isActive) {
            trade.label = trade.label + "" (inactive)"";
            return true;
        }
        return trade.isActive;
    });
    return this.tradeTypes;
}



public setSelectedTradeType = (tradeTypes): void =&gt; {
    this.selectedTradeTypeModel = tradeTypes.find(tt =&gt; tt.id === this.mappedItem.tradeTypeId);
}
</code></pre>

<p>I need to pass the array that is returned from <code>filterTradeTypes</code> into <code>setSelectedTradeType</code> and it is only passing one item from that array. </p>
","3935156","","3935156","","2020-04-05 22:36:34","2020-04-05 22:36:34","RxJS - Convert promise chain to observable not working","<typescript><rxjs5>","0","8","","","","CC BY-SA 4.0"
"61232603","1","61330250","","2020-04-15 15:30:55","","0","105","<p>I have get rest service data call that is called 3 times. I need to create a data service to reduce the call to once so it keeps a local copy.if the copy hasn't been populated yet, it hits the api to get them. it should do this only once. So,  need a bool  that indicates the status of the get call.
If not already making a call to get data, toggle the bool and get the data. 
I know this can be done if 
The component would subscribe to observable, and when the data service had data, it would provide it via the BehaviorSubject. BUt not sure how to implement it because i havent worked with observables and behaviour subject. Any guidance on this is appreciated. Thanks.</p>

<p>Here is my sample stackblitz 
<a href=""https://stackblitz.com/edit/angular-sqxp9e?file=src%2Fapp%2Fnotifications-data.service.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-sqxp9e?file=src%2Fapp%2Fnotifications-data.service.ts</a></p>
","13041945","","","","","2020-04-20 19:15:12","behaviour subject and observable in Angular8","<angular><angular8><rxjs5><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61330250","2","","61232603","2020-04-20 19:15:12","","0","","<p>I created the data service as below:</p>

<pre><code>  private notificationsSubject = new BehaviorSubject&lt;any&gt;([]);
  private loaded = false;

  public notifications$ = this.notificationsSubject.asObservable();
  public data = [];


  constructor(private restSvc: RestService) { }

  getNotification$(): void {

    if (!this.loaded) {
      this.loaded = true;
      this.restSvc.getData(""/api/app/getnotifs"").subscribe((data: any) =&gt; {
        this.data = data;
        this.notificationsSubject.next(this.data);

      });
    }
    else {
      this.notificationsSubject.next(this.data);
    }
  }
</code></pre>
","13041945","","","","","2020-04-20 19:15:12","","","","0","","","","CC BY-SA 4.0"
"61358936","1","61359681","","2020-04-22 06:52:24","","0","267","<p>I am new to rjxs programming so wondering how can I do the following.</p>

<pre><code>    const downloadUrls$: any = filelist.map((file: any) =&gt; {
      const fileName = ...
      const path = ...
      const fileRef = ....
      const task: any = ...

      // get notified when the download URL is available
      return task.snapshotChanges().pipe(
        filter(snap =&gt; snap.state === TaskState.SUCCESS),
        switchMap(() =&gt; from(fileRef.getDownloadURL()))
      );
    });
</code></pre>

<p>So in the above code instead of doing <code>from(fileRef.getDownloadURL())</code> is there is a way I can do create a object like below and the return will be a  list of below objects.</p>

<pre><code>             from (
                {
                 name: fileName,
                 filepath: fileRef.getDownloadURL(),
                 relativePath: path
                }
              )
</code></pre>

<p>Method signature</p>

<pre><code> `.getDownloadURL(): Observable&lt;any&gt;`  
</code></pre>
","663011","","663011","","2020-04-22 07:28:23","2020-04-22 07:38:55","Return object inside switchMap","<rxjs><rxjs5><rxjs6><switchmap>","1","1","1","","","CC BY-SA 4.0"
"61359681","2","","61358936","2020-04-22 07:38:55","","0","","<p>I don't have anything that is runnable from the code you provided, so I'm writing this just as a concept.</p>

<p>What you have is something that is already an Observable (<code>fileRef.getDownloadURL()</code>). And what we need is the new object. We can get there by mapping over the Observable from earlier, and changing it to the result that we need. Something along the lines of:</p>

<pre><code>task.snapshotChanges().pipe(
    filter(snap =&gt; snap.state === TaskState.SUCCESS),
    switchMap(() =&gt; {
        return fileRef.getDownloadURL().pipe(
            map(url =&gt; ({
                name: fileName,
                filepath: url,
                relativePath: path
            }))
        );
    })
);
</code></pre>
","1688785","","","","","2020-04-22 07:38:55","","","","1","","","","CC BY-SA 4.0"
"61361838","1","","","2020-04-22 09:36:29","","0","37","<p>I have the following code</p>

<p>I am new to rjxs programming so wondering what can be the root cause. I am trying to do a certain task and first combine all latest result, then subscribe to assign results.  But combineLatest is not working seems like. What can be the cause ?</p>

<pre><code>const downloadUrls$: any = Array.from(event.target.files).map((file: any) =&gt; {
  const fileName = ...
  const path = ...
  const fileRef = ....
  const task: any = ...

  return task.snapshotChanges().pipe(
    filter(snap =&gt; snap.state === firebase.storage.TaskState.SUCCESS),
    switchMap(() =&gt; {
      return fileRef.getDownloadURL().pipe(
        map((url: string) =&gt; ({
          name: fileName,
          filepath: url,
          relativePath: path,
        }))
      );
    })
  );
});

combineLatest(...downloadUrls$).subscribe((urls: any) =&gt; {
  console.log(hi); // not printing
});
</code></pre>
","663011","","","","","2020-04-22 18:09:38","combineLatest is not getting called","<firebase><rxjs><rxjs5><rxjs6><combinelatest>","2","2","","","","CC BY-SA 4.0"
"61432196","1","61436756","","2020-04-25 20:29:58","","-1","36","<p>I need to run observer if after one second there is no result from forkJoin:</p>

<pre><code> of().pipe(delay(1000), skipUntil(!forkJoin$))
.subscribe(());
</code></pre>

<p>It does not work for me...</p>
","","user13406409","","user13406409","2020-04-25 20:50:43","2020-04-26 06:39:30","How to run observer if no result from forkJoin?","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61436756","2","","61432196","2020-04-26 06:39:30","","1","","<p>You can use <code>timeoutWith()</code>:</p>

<pre><code>forkJoin([timer(500), timer(750)]).pipe(
  timeoutWith(1000, of('Hi')),
).subscribe(console.log);
</code></pre>

<p>Try changing <code>timer()</code> delays.</p>

<p>Live demo: <a href=""https://stackblitz.com/edit/rxjs-v2jmu8?devtoolsheight=60"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-v2jmu8?devtoolsheight=60</a></p>
","310726","","","","","2020-04-26 06:39:30","","","","0","","","","CC BY-SA 4.0"
"61441036","1","61441208","","2020-04-26 12:47:03","","0","21","<p>I have custom function:</p>

<pre><code>activate(seconds: number) {
   of(true)
      .pipe(delay(seconds))
      .subscribe(
        () =&gt; {
          console.log(""Run..."");

        },
        (error) =&gt; console.log(error)
      );
}
</code></pre>

<p>And I call this like:</p>

<pre><code>activate(4);
</code></pre>

<p>Why I get <code>console.log(""Run..."");</code> instantly, wihtout delay?</p>
","","user13406409","","","","2020-04-26 12:58:53","Delay is not working for obserber passing delay time?","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61441208","2","","61441036","2020-04-26 12:58:53","","1","","<p><code>delay</code> takes milliseconds as parameter you should do </p>

<pre><code>delay(4000)
</code></pre>
","8618350","","","","","2020-04-26 12:58:53","","","","2","","","","CC BY-SA 4.0"
"61458533","1","","","2020-04-27 12:06:47","","0","60","<p>The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/switch.md"" rel=""nofollow noreferrer"">switch</a> documentation on github contains an example on how to use the command. </p>

<pre><code>var source = Rx.Observable.range(0, 3)
.select(function (x) { return Rx.Observable.range(x, 3); })
.switch();

var subscription = source.subscribe(
function (x) {
    console.log('Next: ' + x);
},
function (err) {
    console.log('Error: ' + err);
},
function () {
    console.log('Completed');
});
</code></pre>

<p>I've tested the code at <a href=""https://stackblitz.com/edit/rxjs-vmvjni?file=index.ts"" rel=""nofollow noreferrer"">stackblitz</a> but the output differs. Instead of</p>

<pre><code>Next: 0
Next: 1
Next: 2
Next: 3
Next: 4
Completed 
</code></pre>

<p>the console logs</p>

<pre><code>Next: 0
Next: 1
Next: 2
Next: 1
Next: 2
Next: 3
Next: 2
Next: 3
Next: 4
Completed
</code></pre>

<p>Can somebody explain?</p>
","3443820","","3443820","","2020-04-29 14:24:57","2020-05-24 17:55:10","Confusion using Observable.switch","<rxjs5><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61627982","1","61628186","","2020-05-06 05:26:31","","1","96","<p>I am trying to create a BehaviourSubject using RxJs. Here in this code </p>

<pre><code>import { BehaviourSubject } from 'rxjs';

const name = new BehaviourSubject(""Dog"");

// Here in the subscribe callback, I am using TypeScript to specify the argument type should be string.
name.subscribe((name: string):void =&gt; {console.log(name)});
name.next(""cat""); //cat
</code></pre>

<p>I want to restrict these below calls, as I need to pass a string as an argument in the above mentioned subscribe callback.</p>

<pre><code>name.next(5); // This will print 5
name.next({a:5,b:{c:10}}); // This will print the object
name.next(true); // This will print true
</code></pre>

<p>Is there any way to restrict the below calls which do not have valid arguments in the subscribe callback?</p>
","9227853","","","","","2020-05-06 05:54:04","How to use TypeScript in RxJs (BehaviourSubject) for strict type checking?","<javascript><typescript><ecmascript-6><rxjs><rxjs5>","2","2","","","","CC BY-SA 4.0"
"61628186","2","","61627982","2020-05-06 05:43:47","","3","","<p>If you have a look at the type definition of <a href=""https://rxjs-dev.firebaseapp.com/api/index/class/BehaviorSubject"" rel=""nofollow noreferrer"">BehaviorSubject</a>, notice that the class accepts a generic type parameter (i.e. <code>BehaviorSubject&lt;T&gt;</code>).</p>

<p>In your example, you can stipulate that the inner value is of a <code>string</code> type by creating a parameterised version of <code>BehaviorSubject</code>, specifically:</p>

<pre><code>const name = new BehaviorSubject&lt;string&gt;(""Dog"");
</code></pre>

<p>In doing so, you should get the type-checking applied to the subsequent usages of <code>next()</code> and <code>subscribe()</code>.</p>
","2888753","","","","","2020-05-06 05:43:47","","","","0","","","","CC BY-SA 4.0"
"61760475","1","","","2020-05-12 19:37:28","","2","528","<p>I am using EMPTY from rxjs in order to handle the catchError, What is the correct value for expected in order to pass the fail scenario.</p>

<pre><code>import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { EMPTY } from 'rxjs';
import { map, mergeMap, catchError } from 'rxjs/operators';
import { MoviesService } from './movies.service';

@Injectable()
export class MovieEffects {

  loadMovies$ = createEffect(() =&gt; this.actions$.pipe(
    ofType('[Movies Page] Load Movies'),
    mergeMap(() =&gt; this.moviesService.getAll()
      .pipe(
        map(movies =&gt; ({ type: '[Movies API] Movies Loaded Success', payload: movies })),
        catchError(() =&gt; EMPTY)
      ))
    )
  );

  constructor(
    private actions$: Actions,
    private moviesService: MoviesService
  ) {}
}


</code></pre>

<pre><code>// unit test

it('should return a empty observable', () =&gt; {
   this.moviesServiceSpy.and.return(throwError('Error in service'));

   action$ = hot('a', a: { loadMovies() });

   const expected = cold('|');

   expect(loadMovies$).toBeObservable(expected);

})
</code></pre>
","1399262","","","","","2021-04-17 21:57:49","How to test with the marble approach when the returm is a EMPTY observable in effect?","<javascript><jasmine><rxjs5><ngrx-effects><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"61990267","1","61991980","","2020-05-24 18:10:52","","1","41","<p>Im looking a way to simplify this and avoid managing subscriptions inside my pipe.</p>

<p>The general idea abought my code:</p>

<pre class=""lang-js prettyprint-override""><code>this.start$ubject // waiting for users call to start
  .pipe(
    mergeMap(() =&gt; from(this.thirdPartyService.start())), // now i need to wait for smth to start
    tap(() =&gt; {
      // only after thirdPartyService started i can subscribe because prior to that they are undefined
      this.subscriptions.push(
        this.thirdPartyService.alfa$.subscribe(this.first$ubject),
        this.thirdPartyService.beta$.subscribe(this.second$ubject),
      );
    }),
  );
</code></pre>

<p>Is there any way to deal with that? Something like <code>takeWhile</code> but for subscription?</p>
","6950901","","6950901","","2020-05-25 11:14:14","2020-05-25 11:36:43","Managing subscriptions based on async event","<asynchronous><rxjs><rxjs5><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61991980","2","","61990267","2020-05-24 20:20:55","","1","","<p>try like that:</p>

<pre class=""lang-js prettyprint-override""><code>// waits for start$ubject, then waits for thirdPartyService, then starts.
this.subscriptions.push(
  this.start$ubject.pipe(
    switchMap(() =&gt; from(this.thirdPartyService.start())), // waiting start
    switchMap(() =&gt; merge( // listening on both of the streams
      this.thirdPartyService.alfa$.pipe(
        tap(this.first$ubject),
      ),
      this.thirdPartyService.beta$.pipe(
        tap(this.second$ubject),
      ),
    )),
  ).subscribe(),
);
</code></pre>

<pre class=""lang-js prettyprint-override""><code>// waits for start$ubject or for thirdPartyService, then starts.
this.subscriptions.push(
  merge(this.start$ubject, from(this.thirdPartyService.start()).pipe(
    switchMap(() =&gt; merge( // listening on both of the streams
      this.thirdPartyService.alfa$.pipe(
        tap(this.first$ubject),
      ),
      this.thirdPartyService.beta$.pipe(
        tap(this.second$ubject),
      ),
    )),
  ).subscribe(),
);
</code></pre>
","13112018","","13112018","","2020-05-25 11:36:43","2020-05-25 11:36:43","","","","6","","","","CC BY-SA 4.0"
"62057510","1","","","2020-05-28 05:17:05","","0","92","<p>I am using Angular 5 and loading a list of items using a selector with my NGRX library. My selector returs a list of items which I used to dynamically create tabs on a page using the async pipe. Now, when a user clicks on a tab, I want to fire off another selector to go fetch data from my NGRX store, which may or may not exist, ad could trigger an API request in the effect and updated by the reducer. All that works fine.</p>

<p>My issue is, I have a variable number of tabs, which could potentially trigger multiple async requests, and I want to bind the response to each of these requests to the right tab. I'm not sure how to do that? 
I have my code like this:</p>

<p>this.store$
            .select(getTabContent(id)).pipe(takeUntil(this.onDestroy$), take(1)).subscribe((data) => { ...};</p>

<p>but would rather use an async pipe, and I'm not sure if this is the best way to do it using the reactive library. How can I create variable async pipes and be able to bind to specific tabs in my case?</p>
","4849537","","","","","2020-05-28 08:07:55","Creating multiple async pipes of unknown number","<angular><rxjs><rxjs5><async.js><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"62247638","1","","","2020-06-07 15:30:58","","2","93","<p>I dont have a lot experience in RxJS and I want to do the following thing with a RxJS pipe in my Angular service.</p>

<p>I tried with the iif function but I simply have not enough experience in it.</p>

<p>Angular Version is: <strong>Angular 9</strong><br>
RxJS Version: <strong>6.5.5</strong></p>

<p>check response from GET request true via HttpClient<br>
.... true -> check if can access website via HttpClient<br>
................ true -> set this.isOnline = true<br>
............................ get a response from another url via HttpClient<br>
............................ true -> set this.result = responseFromUrl<br>
........................................ end pipe<br>
............................ false -> throwError(""cant get result"")<br>
................ false -> set this.isOnline = false<br>
............................. end pipe<br>
.... false -> end pipe  </p>
","9313852","","","","","2020-06-07 16:22:26","complicated pipe chain with the HttpClient in Angular with RxJS","<javascript><angular><rxjs><rxjs5><rxjs6>","1","2","0","","","CC BY-SA 4.0"
"62304937","1","62305125","","2020-06-10 13:34:44","","-1","23","<p>I have tried to call forkJoin in <code>switchMap</code>:</p>

<pre><code>this.route.params.pipe(
  pluck('cadnum'),
  tap((cadnum) =&gt; {
    this.r1.repositoryModel.findallversionbycadnum.model.cadnum = cadnum;
    this.r2.repositoryModel.findallversionbycadnum.model.cadnum = cadnum;
    this.r3.repositoryModel.findallversionbycadnum.model.cadnum = cadnum;
  }),
  switchMap(() =&gt; forkJoin(
    egrn.parcels.versions.load(),
    egrn.premisses.versions.load(),
    egrn.rights.versions.load()).pipe(
      tap(([res1, res2, res3]) =&gt; {
        egrn.parcels.versions.set(res1);
        egrn.premisses.versions.set(res2);
        egrn.rights.versions.set(res3);
      }),
      catchError((error) =&gt; of(error)),
    ),
  ),
)).subscribe((response) =&gt; {
  console.log(response);
});
</code></pre>

<p>But it does not work, how to call <code>forkJoin</code> inside <code>switchMap</code>?</p>
","","user13664319","6324775","","2020-06-11 11:06:53","2020-06-11 11:06:53","How to call forkJoin in switchOperator?","<typescript><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"62305125","2","","62304937","2020-06-10 13:43:01","","0","","<p>To forkJoin emit the results all <code>egrn.parcels.versions.load(), egrn.premisses.versions.load(), egrn.rights.versions.load()</code> have to be complete.</p>

<p>You can try to switch <code>forkJoin</code> to <code>combineLatest</code> or finish the streams after the first emission with <code>take(1)</code>, example: <code>egrn.parcels.versions.load().pipe(take(1))</code></p>
","11864065","","","","","2020-06-10 13:43:01","","","","2","","","","CC BY-SA 4.0"
"62311328","1","62311847","","2020-06-10 19:10:03","","-1","47","<p>How to correctly send RxJS requests, when there are 4 different API endpoints, I need to request each endpoint until previous does not return data.</p>

<p><strong>Schema is:</strong></p>

<pre><code>Request 1 -&gt; Return Void
Request 2 -&gt; Returned data, stop working and return data
Request 3 -&gt; Will fail
</code></pre>

<p><strong>Result is:</strong></p>

<p>Only one result from one of request.</p>

<p><strong>I tried this:</strong></p>

<pre><code>req1$ = of(response);
req2$ = of(response);

req1$.pipe( flatMap((result) =&gt; {
   if (result) { return of(result); } else {return of([]);}
}));
</code></pre>
","","user13664319","","user13664319","2020-06-10 19:16:38","2020-06-10 20:08:33","How to send requests to server one after one RxJS?","<rxjs><rxjs5><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"62311847","2","","62311328","2020-06-10 19:41:20","","0","","<p>I think you need to do a manual chain, something like:</p>

<pre class=""lang-js prettyprint-override""><code>const getValueFromServer$  = req1$.pipe(flatMap =&gt; result ? of(result) : firstFallback$);
const firstFallback$       = req2$.pipe(flatMap =&gt; result ? of(result) : secondFallback$)
const secondFallback$      = req3$.pipe(flatMap =&gt; result ? of(result) : req4$)

getValueFromServer$.subscribe(console.log)
</code></pre>
","11864065","","11864065","","2020-06-10 20:08:33","2020-06-10 20:08:33","","","","2","","","","CC BY-SA 4.0"
"62321197","1","62321285","","2020-06-11 09:28:22","","-1","21","<p>I have the following Rxjs statement:</p>

<pre><code>    const versionsRequest2$ = (num: string) =&gt;
        request2$(num).pipe(
            map((versions) =&gt; {
                const p = new P();
                p.setVersions(versions);
                return p;
            }),
        );
</code></pre>

<p>How to improve <code>map()</code> statement? I dislike, I have tried to create instance of class and fill it by data from response.</p>

<p>I can improve this using:</p>

<pre><code>map((versions) =&gt;  new P().setVersions(versions)),
</code></pre>

<p>If constructor <code>P</code> and <code>setVersions</code> returns <code>this</code> inside</p>
","","user13664319","3558960","","2020-06-11 09:38:39","2020-06-11 09:38:39","How to improve Rxjs statement?","<javascript><rxjs><rxjs5>","1","0","","","","CC BY-SA 4.0"
"62321285","2","","62321197","2020-06-11 09:32:47","","0","","<p>You could write a constructor for <code>P</code> that accepts a <code>versions</code> argument. Then you can just do:</p>

<pre><code>const versionsRequest2$ = (num: string) =&gt;
  request2$(num).pipe(
    map((versions) =&gt; new P(versions)),
  );
</code></pre>
","3558960","","","","","2020-06-11 09:32:47","","","","3","","","","CC BY-SA 4.0"
"62404350","1","","","2020-06-16 08:37:21","","0","123","<pre><code>getInactiveTimerTabSynchronizer() {
    return fromEvent(window, 'storage').pipe(
      filter((x: StorageEvent) =&gt; {
        return x.key === this.inactivityTabSynchronizerStorageKey;
      }),
      debounceTime(350));
  }
</code></pre>

<p>The above code has unit test case as below:</p>

<pre><code>import { Observable, of as observableOf } from 'rxjs';


it(
    'getInactiveTimerTabSynchronizer() function should return an observable that looks for storage events ' +
      'and filters it to only ""INACTIVE_TIMER_RESET"" keyed events',
    fakeAsync(
      inject([AuthService], (service: AuthService) =&gt; {
        spyOn(Observable, 'fromEvent').and.returnValue(
          observableOf({ key: 'INACTIVE_TIMER_RESET' } as StorageEvent, { key: 'SOME_OTHER_KEY' } as StorageEvent)
        );

        let counter = 0;
        service.getInactiveTimerTabSynchronizer().subscribe(x =&gt; {
          counter++;
          expect(counter).toBe(1);
        });
        tick(350);
        tick(350);
      })
    )
  );
</code></pre>

<p>It was working fine when i had angluar 6 and rxjs 5.5, but after i upgraded to angular 7 and rxjs 6.5 it throws error as:</p>

<pre><code>Argument of type '""fromEvent""' is not assignable to parameter of type '""prototype"" | ""create"" | ""if"" | ""throw""'
</code></pre>

<p>Any help for the fix or workaround ?</p>
","7068024","","","","","2020-06-16 09:42:01","spyOn(Observable, 'fromEvent') throws error after upgrading to rxjs 6.5","<angular><jasmine><rxjs5><rxjs6><spyon>","1","0","","","","CC BY-SA 4.0"
"62524894","1","62531433","","2020-06-22 23:11:50","","0","114","<p>I have a Rxjs:</p>
<pre><code>   private loading = new BehaviorSubject(false);
</code></pre>
<p>The <code>loading</code> can be changed fast from <code>true</code> to <code>false</code>. How to smooth this stream and pass values only if time between <strong>false</strong> and <strong>true</strong> is more then 3 seconds, otherwise pass false by default?</p>
","","user13763587","","","","2020-06-23 09:23:06","How to smooth stream Rxjs?","<rxjs><rxjs5>","2","1","","","","CC BY-SA 4.0"
"62531433","2","","62524894","2020-06-23 09:23:06","","0","","<p>Hello Megan you can check out the following demo, I think it will help you sort out the issue you are facing. (I'm using 1500ms instead of 3000ms but it doesn't matter that much)</p>
<p>So the first part of the issue is that you want to be able to get info about past states of the loading state (the value that is stored in the <code>BehavourSubject</code>) at a certain interval.</p>
<p>This is achieved by the combination of the <code>buffer</code> operator and <code>interval</code> observable. The idea is that the <code>buffer</code> will record all events emitted trough the stream and pass them on whenever the observable that is passed as it's argument emits a value (in our case each 1500 ms the <code>interval</code> observable will emit new value)</p>
<p>So each 1500ms we will get new value from the loading subject.</p>
<p>The next thing that we need to handle is to guarantee that the subject has been unchanged for the past 1500ms, the way that I had achieve that is by using the <code>scan</code> operator to store the last emitted values from the subject.</p>
<p>With this aggregated data in the follow up <code>filter</code> operator I'am checking if there had been any new values written in the subject (if there were any they would've been accessible trough the <code>newEvents</code> variable, which will be an array of the last buffered Subject values)</p>
<p>So the filter condition pretty much states that if there are no events for the past 1500ms, the latest loading value should be passed.</p>
<p>At the end of the pipe <code>distinctUntilChanged</code> is used to filter out any duplicated states of loading, so only when new load/loaded state is present, the values in the HTML is changed.</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let {
  BehaviorSubject,
  interval
} = rxjs
let {
  buffer,
  scan,
  map,
  filter,
  distinctUntilChanged
} = rxjs.operators

let someFlagToSaveTheCurrentState = false;
let currentState = document.getElementById('currentState')

let loading = document.getElementById('loading')
let loadingBtn = document.getElementById('loadingbtn')

let loader = new BehaviorSubject(false)

loadingBtn.addEventListener('click', () =&gt; {
  someFlagToSaveTheCurrentState = !someFlagToSaveTheCurrentState;
  loader.next(someFlagToSaveTheCurrentState);

  currentState.innerHTML = someFlagToSaveTheCurrentState;
})

let interval$ = interval(1500)

loader.pipe(
  buffer(interval$),
  scan((acc,e) =&gt; ([...acc.slice(1),e]), [[false], [false]]),
  filter(([lastEvents, newEvents]) =&gt; newEvents.length === 0 &amp;&amp; lastEvents.length !== 0),
  map(([lastEvents, newEvents]) =&gt; {
  let result = false;
  if (newEvents.length === 0 &amp;&amp; lastEvents.length !== 0) {
    result = lastEvents[lastEvents.length - 1]
  }
  return result;
}),
distinctUntilChanged()
  
).subscribe((loadingState) =&gt; {
  console.log(loadingState)
  if (loadingState) {
    loading.innerHTML = 'Element loading'
  } else {
    loading.innerHTML = 'Element is loaded'
  }
})</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.5.5/rxjs.umd.js""&gt;&lt;/script&gt;

&lt;h1 id=""loading""&gt;Loading&lt;/h1&gt;

&lt;button id=""loadingbtn""&gt;Toggle loading&lt;/button&gt;
&lt;h1 id=""currentState""&gt;false&lt;/h1&gt;</code></pre>
</div>
</div>
</p>
<h2>Try running the code snippet</h2>
","7177558","","","","","2020-06-23 09:23:06","","","","0","","","","CC BY-SA 4.0"
"62955152","1","","","2020-07-17 13:36:17","","0","68","<p>I need to make API call for get/set method. But these Service need previous state to make a next call.
In this pattern, in state prop I wanted to maintain previous state of this stream so that when I make next get/set call I can pass the previous state to service. And once I receive the response from service it will update state for next iteration.</p>
<p>But problem is this merge state is executing get$ and set$ map even before sending value with next.
Can someone please suggest what am I missing here?</p>
<pre><code>const { Subject, merge} = require('rxjs');
const { map,switchMap,scan } = require('rxjs/operators');

function stream(){
  
  const get$= new Subject()
  const set$= new Subject()
  
  const store$=merge(
    get$.pipe(
      map(options=&gt;{
        return acc=&gt;{
          
          return {
            state:{â¦acc.state},
            service:state=&gt;{
              return getCall(options,state)
            }
          }
        }
        
      })
    ),
    set$.pipe(
      map(options=&gt;{
        return acc=&gt;{
          
          return {
            state:{â¦acc.state},
            service:state=&gt;{
              return setCall(options,state)
            }
          }
        }
        
      })
    )
    
  ).pipe(
    scan((acc,update)=&gt;{
      return update(acc)
    },{state:{},service:()=&gt;{}}),
    switchMap(
      ({state,service})=&gt;{
        return service(state)
      }
    )
  )
  
  return {
    get:options=&gt;{
      get$.next(options)
      return store$
    },
    set:options=&gt;{
      set$.next(options)
      return store$
    }
  }
}
const{get,set}=stream()
get({prop:1}).subscribe(console.log)
set({prop:2}).subscribe(console.log)
</code></pre>
","13948362","","13948362","","2020-07-17 17:17:37","2020-07-17 17:17:37","RXJS Share state between merge streams","<javascript><rxjs><rxjs5>","0","3","","","","CC BY-SA 4.0"
"63316478","1","63317510","","2020-08-08 14:25:44","","0","74","<p>I am trying to use the merge operator is given below. I want to put only 'Mr' before login but I am getting an error, your help is much appreciated, thank you</p>
<pre><code>  let data=this.http.get('https://api.github.com/users');
  let output=data.pipe(map(data=&gt;{'Mr, '+data.login}));
            output.subscribe(data=&gt;{
  console.log(data);
})
</code></pre>
","4747554","","1188074","","2020-08-09 01:25:22","2020-08-09 01:25:22","How do I map a list of objects from an HTTP API to a list of strings?","<angular><rxjs><rxjs5><rxjs6><rxjs-pipeable-operators>","2","1","","2020-08-09 01:29:02","","CC BY-SA 4.0"
"63317510","2","","63316478","2020-08-08 16:05:23","","2","","<p>As in my comment, the API returns an array of users. You therefore need to use the JavaScript array <code>map</code> operator inside the rxjs <code>map</code> to transform each individual user to the required string:</p>
<pre><code>let data = this.http.get&lt;any[]&gt;('https://api.github.com/users');
let output = data.pipe(map(users =&gt; users.map(user =&gt; 'Mr, ' + user.login)));

output.subscribe(data =&gt; console.log(data));
</code></pre>
<p>Working example here: <a href=""https://stackblitz.com/edit/so-map-github-users?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/so-map-github-users?file=src%2Fapp%2Fapp.component.ts</a></p>
","1188074","","1188074","","2020-08-08 22:51:07","2020-08-08 22:51:07","","","","1","","","","CC BY-SA 4.0"
"63411207","1","","","2020-08-14 10:41:57","","0","23","<p>I'm trying to paginate a search and I need to prevent it from concatenating the list of results from the previous search.</p>
<p>Ex Search: %Dog%</p>
<p>1st page of results:
&quot;Dog Barks&quot;, &quot;Dog Growls&quot;, &quot;Dog Itches&quot;</p>
<p>2nd page of results:
&quot;Dog Barks&quot;, &quot;Dog Growls&quot;, &quot;Dog Itches&quot;, &quot;Dog Jumps&quot;, &quot;Dog Eats&quot;, &quot;Dog Sits&quot;</p>
<p>Ex Search: %Cat%</p>
<p>1st page of results:
&quot;Cat Meows&quot;, &quot;Cat Itches&quot;, &quot;Cat Runs&quot;</p>
<p>2nd page of results:
&quot;Cat Meows&quot;, &quot;Cat Itches&quot;, &quot;Cat Runs&quot;, &quot;Cat Jumps&quot;, &quot;Cat Eats&quot;, &quot;Cat Sits&quot;</p>
<p>Code:</p>
<pre class=""lang-js prettyprint-override""><code>const offsetId$ = new Rx.BehaviorSubject(null);
const fooBar$ = new Rx.BehaviorSubject(null);

const observable = Rx.Observable
    .combineLatest(offsetId$, fooBar$)
    .startWith([])
    .switchMap(([offsetId, fooBar]) =&gt; fooBarCollection.find({
        fooBar: new RegExp(&quot;^&quot; + fooBar, &quot;i&quot;)
    }, {
        skip: offsetId * 200,
        limit: 200
    }).debounce(() =&gt; Rx.Observable.timer(10)))
    .scan((acc, value) =&gt; acc.concat(value));
    
observable.subscribe((result) =&gt; {
    console.log(result);
});
</code></pre>
","10733081","","","","","2020-08-14 10:41:57","Using RXJS 5 for Paginating a Search","<javascript><rxjs><observable><rxjs5>","0","3","","2020-08-14 12:48:07","","CC BY-SA 4.0"
"63491389","1","63492139","","2020-08-19 16:39:27","","1","102","<p>Theoretically, I know what mergeMap is and how it works, but when I try to understand using
practical approach I get confused, this is what I have done so far</p>
<pre><code>const input1$= of(&quot;value 1&quot;,&quot;value 2&quot;,&quot;value 3&quot;);
const input2$= of(1,2,3,4);
const obs=input1$.pipe(
            mergeMap(data1=&gt;{
              return input2$
              .pipe(map(ch=&gt;{ch+' '+data1}))})
        )   
</code></pre>
<p>unfortunately, I am getting undefined when I try to merge them, your help would be appreciated to make me understand how it works.</p>
","4747554","","","","","2020-08-19 17:30:55","undefined output while using mergeMap in Rxjs","<angular><rxjs><rxjs5><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"63492139","2","","63491389","2020-08-19 17:30:55","","2","","<p>You are not returning anything in your second pipe</p>
<p>Try this</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const obs=input1$.pipe(
            mergeMap(data1=&gt;{
              return input2$
              .pipe(map(ch=&gt;{
              return ch+' '+data1
              }))})
        )</code></pre>
</div>
</div>
</p>
","10674797","","","","","2020-08-19 17:30:55","","","","2","","","","CC BY-SA 4.0"
"63561907","1","63562542","","2020-08-24 13:21:05","","0","41","<p>I made this functionality, each iteration i have 7 requests that sent each environment.dashboard.frequency time,
but at the beginning, I see that i send 14 requests to the server instead of 7 :</p>
<pre><code>let requests: Observable&lt;ResourceResponse&gt;[] = initRequests(this.durationService.resourceDataDuration)
    timer(0, environment.dashboard.frequency)
      .pipe(
        takeUntil(this.destroy),
        startWith(0),
        switchMap(() =&gt; forkJoin(requests))
      )
      .subscribe((responsesArr: ResourceResponse[]) =&gt; {
        this.updateBegin()
        for (const response of responsesArr) {
          this.durationService.resourceDurationHandler.setPresentedDataRanges(
            response,
            this.durationService.resourceDataDuration,
            this.durationService.resourcePresnetedDataDurations
          )
          this.updateMany(response.Resource, response.Response, true)
        }
        this.updateEnd()
        requests = initRequests(this.durationService.resourceDataDuration)
      })
</code></pre>
","14157627","","","","","2020-08-24 13:57:59","rxjs : get duplicate http requests on the first set that I send","<rxjs><rxjs5><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63562542","2","","63561907","2020-08-24 13:57:59","","0","","<p><code>timer(0, environment.dashboard.frequency)</code> -&gt; <code>dueTime = 0</code> -&gt; not need <code>startWith</code></p>
","11191424","","","","","2020-08-24 13:57:59","","","","0","","","","CC BY-SA 4.0"
"64149074","1","","","2020-10-01 04:27:38","","1","58","<p>I've inherited some old <code>RxJs 5</code> code that smells awkward:</p>
<pre class=""lang-js prettyprint-override""><code>  myFunc = (tag: TagModel): Observable&lt;TagModel&gt; =&gt; {
    try {
      const foundTag = this.mappedTags.find((x) =&gt; {
        return x.name === tag;
      });
      const isAllowedToAdd = foundTag ? false : true;

      return Observable
        .of(tag)
        .filter(() =&gt; isAllowedToAdd)
        .mapTo(tag);

    } catch (err) {
      console.log(&quot;err: &quot;, err);
    }
  }
</code></pre>
<p>Is the purpose of that code to create an Observable with either a value of tag if it's found, otherwise empty? It looks so convoluted (plus some other choice words which I can't share here).</p>
<p><code>RxJs</code> introduced breaking changes where <code>of</code> and <code>mapTo</code> are no longer chainable. Would this be the correct way to refactor?</p>
<pre class=""lang-js prettyprint-override""><code>  return of(tag)
    .filter(() =&gt; isAllowedToAdd)
    .pipe(mapTo(tag));
</code></pre>
","705483","","13680115","","2020-10-19 17:15:11","2020-10-19 17:15:11","RxJs 5 of.filter.mapTo operators -> RxJs 6","<rxjs><observable><rxjs5><rxjs6>","1","2","","","","CC BY-SA 4.0"
"64208725","1","","","2020-10-05 12:35:23","","0","74","<p>I need to subscribe &amp; do some actions, when mouseover on particular elements in the DOM.</p>
<p>For Example: home.component.html</p>
<pre><code>        &lt;div class=&quot;container&quot;&gt;
              &lt;div class=&quot;row1&quot;&gt; &lt;/div&gt;
              &lt;div class=&quot;row2&quot;&gt; &lt;/div&gt;
              &lt;div class=&quot;row3&quot;&gt; &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<p>home.component.ts:</p>
<pre><code>         import {
                 AfterViewInit,
                 Component,
                 Input,
                 OnInit,
                } from '@angular/core';

                @Component({
                             selector: 'app-home',
                             templateUrl: './home.component.html',
                             styleUrls: ['./home.component.scss'],
                           })
          export class homeComponent implements OnInit {
          
               public hover: boolean;

               constructor() {}

               ngOnInit(): void {
                     this.hover= true;       // it may be false also.
               }

          }
</code></pre>
<p>In the above example when mouseover on row1 &amp; row3 elements then I need to subscribe. Also I need to check one variable called &quot;hover&quot;, if it is true then only I need todo the above action(mouseover). If the variable is false then no need to check for mouseover(no need to do any action), just I need to unsubscribe it. Can any one help me to achieve this.</p>
","7148829","","","","","2020-10-05 14:15:26","subscribing when mouseover on particular element in the DOM","<javascript><angular><rxjs5><rxjs6><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"64386222","1","","","2020-10-16 09:13:04","","1","35","<p>Let's say I have following situation:</p>
<pre><code>allItems$: &lt;(TypeA | TypeB)[]&gt;;
arr1$: TypeA[]; // [{a: 1, b: 2}, {a: 3, b: 4}]
arr2$: TypeA[];
arr3$: TypeB[]; // [{ b:1, c: 2}, { b:3, c: 4}]
arr4$: TypeB[];
</code></pre>
<p>I would like to concat all together into one single array, but some of these streams might not emit any value, do you know which is a proper operator?</p>
<pre><code>this.allItems$ = operator([
  arr1$,
  arr2$,
  arr3$,
  arr4$
]).pipe(
   // returned value
);
</code></pre>
<p>Desired output:</p>
<pre><code>// [{a: 1, b: 2}, {a: 3, b: 4}, { b:1, c: 2}, { b:3, c: 4}]
</code></pre>
","2549912","","","","","2020-10-16 10:28:41","How to concat multiple array observables that some might not emit any stream","<angular><rxjs5>","1","0","","","","CC BY-SA 4.0"
"64570545","2","","48420900","2020-10-28 10:04:44","","1","","<p>After some investigation I discovered that the fact that we can or cannot mock this single exported functions is directly dependen in how our bundler resolves the modules when testing.</p>
<p>So for example, you may stumble to this error or similarly:</p>
<pre><code>Error: : myFunctionName is not declared writable or has no setter
</code></pre>
<p>Caused because the bundler just wrapped those lonely exported functions into a getter property, making them impossible to mock.</p>
<p>The solution that I ended using is <strong>compile modules in <code>'commonjs'</code></strong> when testing.</p>
<p>For example, if you are working with typescript, you would need to change change your <code>tsconfig.spec.ts</code> to use commonjs module:</p>
<pre><code>&quot;compilerOptions&quot;: {
     ....
      // force commonjs module output, since it let mock exported members on modules to anywhere in the application (even in the same file)
      &quot;module&quot;: &quot;commonjs&quot;,
  },
</code></pre>
<p>The resultant output of any exported member of a module in commonjs would be like: <code>exports.myFunc = function() {}</code>. This led use spyOn without worries since it is wrapped on the 'exports' object. One great use case of that, is that it would be mocked anywhere, <strong>including the usages in its own file</strong>!</p>
<p>Example:</p>
<pre><code>// some-module.js
export function functionToMock() {
     return 'myFuncToMock';
}
export function functionToTest() {
     return functionToMock();
}

// testing-module.spec.js
import * as SomeModule from ./some-module
spyOn(SomeModule, 'functionToMock').and.returnValue('mockedCorrectly');
SomeModule.functionToTest().toBe('mockedCorrectly')
</code></pre>
","6099651","","","","","2020-10-28 10:04:44","","","","0","","","","CC BY-SA 4.0"
"64625561","1","64626728","","2020-10-31 19:18:51","","1","95","<p>I want to incrementally increase the delay for this:</p>
<pre><code>const source = from(839283, 1123123, 63527, 4412454); // note: this is random
const spread = source.pipe(concatMap(value =&gt; of(value).pipe(delay(1000)))); // how to incrementally increase the delay where the first item emits in a second, the second item emits in three seconds, the third item emits in five seconds, and the last item emits in seven seconds.
spread.subscribe(value =&gt; console.log(value));
</code></pre>
<p>I'm aware of using interval to incrementally increase the delay time as below. But I also need to consume this source <code>const source = from(839283, 1123123, 63527, 4412454); </code></p>
<pre><code>const source = interval(1000); // But I also need to use have this from(839283, 1123123, 63527, 4412454)
const spread = source.pipe(concatMap(value =&gt; of(value).pipe(delay(value * 200))));
spread.subscribe(value =&gt; console.log(value
</code></pre>
<p>How to incrementally increase the delay time when starting with <code>const source = from(839283, 1123123, 63527, 4412454); </code>?</p>
","3073280","","","","","2020-11-01 00:47:46","RxJS - How to incrementally increase the delay time without using interval?","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64626728","2","","64625561","2020-10-31 21:47:45","","3","","<p>You can use the index of the emitted value and calculate the delay based on that.</p>
<pre class=""lang-ts prettyprint-override""><code>concatMap((value, index) =&gt; {
  return of(value).pipe(delay((index &gt; 2 ? 7 : index) * 1000));
})
</code></pre>
<p>Here is a stackblitz for a complete example with your snippet:
<a href=""https://stackblitz.com/edit/rxjs-jjmlta?devtoolsheight=60"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-jjmlta?devtoolsheight=60</a></p>
","9237784","","9423231","","2020-11-01 00:47:46","2020-11-01 00:47:46","","","","0","","","","CC BY-SA 4.0"
"64730299","1","64770214","","2020-11-07 17:06:52","","0","592","<p>I got several components subscribing to my data service and they are all working fine. But in one of my components, I try to subscribe twice (inside ngOnInit and ngAfterViewInit) but this doesn't work. Here is the component:</p>
<pre><code>ngOnInit() {
    this.dataService.data$.pipe(first()).subscribe(subscribeToData =&gt; {
        this.title = this.dataService.getData(&quot;...&quot;);
            this.anotherService.getData
                .subscribe(another =&gt; {
                    this.data = data;
                },
                ...
        });
    }

ngAfterViewInit() {
    this.dataService.data$.pipe(first()).subscribe(subscribeToData =&gt; {
        let options = {
            data: {
            }
            ...
            {
            title: this.dataService.getData(&quot;...&quot;);
            },
            ...

        };
        ...

    });
}
</code></pre>
<p>If I remove subscribe from ngOnInit then ngAfterViewInit works fine, else it fails. So is there a way to subscribe two or more times from within the same component at the same time?</p>
<p>Here is the data service:</p>
<pre><code>private dataSource = new ReplaySubject(1);
data$ = this.dataSource.asObservable();

loadData(... : void) {
    if (sessionStorage[&quot;data&quot;] == null {
        this.http.request(...)
        .map((response: Response) =&gt; response.json()).subscribe(data =&gt; {
            ...
            sessionStorage.setItem(&quot;data&quot;, JSON.stringify(this.data));
            this.dataSource.next(this.data);
            ...
        });
    } else {
        this.dataSource.next(this.data);
    }
}

getData(... : string){
    ...
}
</code></pre>
","7061548","","7061548","","2020-11-09 05:04:17","2020-11-10 13:51:13","Subscribe to one observable twice from a component doesn't work","<angular><rxjs><observable><angular5><rxjs5>","1","9","","","","CC BY-SA 4.0"
"64770214","2","","64730299","2020-11-10 13:51:13","","1","","<p>There are no problems with double subscribe in your code - probably you are facing some asynchronous code issues. The browser is fast enough to quickly go through component's lifecycle and to quickly call <code>ngOnInit</code> and <code>ngAfterViewInit</code>. Both of them will be executed almost simultaneously and lightning fast - definitely faster than a http call. In this case, in your <code>ngOnInit</code>'s subscribe you have another call that might be executed <em>after</em> the <code>ngAfterViewInit</code> (although I'm not sure).</p>
<p>Here is an example that shows that double subscribe in a single component works:
<a href=""https://stackblitz.com/edit/double-subscribe?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/double-subscribe?file=src/app/app.component.ts</a></p>
<p>Try to refactor your logic to be more consecutive: if your <code>ngAfterViewInit</code> must be executed <em>after</em> all the asynchronous code in <code>ngOnInit</code> is done - store the result of the <code>ngOnInit</code>'s chain somewhere in a variable; if your <code>ngAfterViewInit</code> does not care about the <code>ngOnInit</code> try to avoid accessing the same variables, especially <code>this.data</code>.</p>
<p>Also try to avoid nested <code>subscribe</code>s - they can be replaced with <code>switchMap</code>/<code>flatMap</code>:</p>
<pre><code>ngOnInit() {
    this.dataService.data$.pipe(
      first(),
      tap(data =&gt; this.title = this.dataService.getData(data)), // note that this should be synchronous
      switchMap(data =&gt; {
        // another asynchronous call here
        return this.anotherService.getData(data)
      })
    ).subscribe(finalData =&gt; {
        this.data = finalData
    }
</code></pre>
<p>To refactor your <code>ngAfterViewInit</code> to be executed <em>after</em> <code>ngOnInit</code> do the following:</p>
<pre><code>onInitData$: Observable&lt;any&gt;;

ngOnInit() {
  this.onInitData$ = this.dataService.data$.pipe(
      first(),
      tap(data =&gt; this.title = this.dataService.getData(data)), // note that this should be synchronous
      switchMap(data =&gt; {
        // another asynchronous call here
        return this.anotherService.getData(data)
      }),
      shareReplay(1) // shareReplay(1) is important to avoid doing double http requests per subscribe
    );
  this.onInitData$.subscribe(data =&gt; console.log('data from ngOnInit', data));
}

ngAfterViewInit() {
  this.onInitData$.pipe(switchMap(thatData) =&gt; {
     // will be executed only AFTER the ngOnInit is done
     return this.dataService.data$.pipe(first()).subscribe(subscribeToData =&gt; {
        let options = {
            data: {
            }
            ...
            {
            title: this.dataService.getData(&quot;...&quot;);
            },
            ...

        };
        ...

    });
  }).subscribe(dataFromAfterViewInit =&gt; {})
}

</code></pre>
<p>In general, you'd want to think why do you even need <code>ngAfterViewInit</code>? What do you want to achieve by splitting those calls between <code>onInit</code>/<code>afterViewInit</code>? Why do they access the same data in a component?</p>
","10836220","","","","","2020-11-10 13:51:13","","","","7","","","","CC BY-SA 4.0"
"65446887","1","","","2020-12-25 09:31:19","","1","90","<p>How to combine the distinct, switchMap and mergeMap operators, so that when the source emits repeated values (detected by distinct.keySelector), the previous subscription is canceled (as in the switchMap), but if the value is not repeated follow the behavior of mergeMap?</p>
<p>Example:</p>
<pre><code>source = from(1, 2, 1, 2, 3) // 'abcde'
result = source.pipe(delay(), combination() // '--cde'
</code></pre>
<p>I'm currently doing something like:</p>
<pre><code>const activeSubscriptions = new Map();
source$.pipe(
  mergeMap((value) =&gt; {
    const pendingSubscription = activeSubscriptions.get(value);
    if (pendingSubscription) {
      pendingSubscription.unsubscribe();
      activeSubscriptions.delete(value);
    }
    const request$ = new Subject();
    const subscription = this.service.get(value).subscribe({
      complete: () =&gt; request$.complete(),
      error: (err) =&gt; request$.error(err),
      next: (value) =&gt; request$.next(value),
    });
    activeSubscriptions.set(value, subscription);
    return request$;
  })
);
</code></pre>
<p>But looking for a better way to do that.</p>
<p>Thank you in advance</p>
","4233401","","","","","2020-12-26 12:16:14","Cancel repeated subscription in mergeMap","<rxjs><rxjs5><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65578867","1","","","2021-01-05 12:23:38","","0","48","<p>While I try to update formArray values I get <code>RangeError: Maximum call stack size exceeded</code></p>
<pre><code>onLastTestDateChange(lastTest: Date, index: number): void {
    const newIntervals: any[] = [...this.equipmentForm.controls.testIntervals.value];
    const intervalPeriod: any = this.testIntervals[index].value;

    const nextTest: Date = lastTest
      ? new Date(lastTest.getFullYear() + intervalPeriod, lastTest.getMonth(), lastTest.getDate())
      : null;

    newIntervals[index].lastTestDate = lastTest;
    newIntervals[index].nextTestDate = nextTest;

    this.testIntervalsControls.patchValue(newIntervals);
    this.testIntervalsControls.markAsTouched();
  }
</code></pre>
<p>this is my function that is called on the <code>ngModelChange</code>. I found out that the problem is from <code>pathValue</code>. Does anybody have an idea how to fix this?</p>
<p>Thank you in advance!</p>
","9384633","","","","","2021-01-05 12:23:38","RangeError: Maximum call stack size exceeded using reactive forms","<angular><angular-reactive-forms><rxjs5><ng-bootstrap><bootstrap-datepicker>","0","2","","","","CC BY-SA 4.0"
"65675901","2","","40582054","2021-01-11 23:19:32","","3","","<p><a href=""https://github.com/reactivex/rxjs/commit/f5278aa89ea164caf5cf10e77d7bd00eff26fc0f"" rel=""nofollow noreferrer"">This is now in RXJS 7</a>.</p>
<pre><code>const res = combineLatest({ foo: a$, bar: b$, baz: c$ });

res.subscribe(({ foo, bar, baz }) =&gt; { console.log(foo, bar, baz); });
</code></pre>
<p>Note: Angular as of today is not yet on v7.</p>
","16940","","16940","","2021-07-07 18:24:57","2021-07-07 18:24:57","","","","1","","","","CC BY-SA 4.0"
"65721408","1","","","2021-01-14 14:57:35","","0","52","<p>How do I fix this problem, when I click on a box it changes the other boxes too.
Is there any way to fix this?</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const board = [0, 0, 0, 0, 0, 0, 0, 0, 0];
turn = 1;
locked = [0, 0, 0, 0, 0, 0, 0, 0, 0];

function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(255);

  function grid() {
    strokeWeight(2);

    //up
    u1 = rect(80, 92, 75, 70);
    u2 = rect(155, 92, 75, 70);
    u3 = rect(230, 92, 75, 70);
    //middle
    rect(230, 162, 75, 70);
    rect(80, 162, 75, 70);
    rect(155, 162, 75, 70);
    //bottom
    rect(230, 232, 75, 70);
    rect(80, 232, 75, 70);
    rect(155, 232, 75, 70);

    if (board[0] === 1) {
      if (turn === 0) {
        line(90, 100, 145, 150);
        line(90, 150, 145, 100);
      } else if (turn === 1) {
        circle(118, 128, 50);
      }
    }

    if (board[1] === 1) {
      if (turn === 0) {
        line(165, 100, 220, 150);
        line(165, 150, 220, 100);
      } else if (turn === 1) {
        circle(193, 128, 50);
      }
    }
  }

  function cursor() {
    strokeWeight(5);
    cursor = circle(mouseX, mouseY, 2);
    text(""X:"" + mouseX, 0, height / 4);
    text(""Y:"" + mouseY, 0, height / 2);
  }

  grid();
  cursor();
}

function mousePressed() {
  if (mouseX &gt; 80 &amp;&amp; mouseX &lt; 155 &amp;&amp; mouseY &gt; 92 &amp;&amp; mouseY &lt; 160 &amp;&amp; locked[0] === 0) {
    board[0] = 1;
    locked[0] = 1;
    if (turn === 0) {
      turn = 1;
    } else if (turn === 1) {
      turn = 0;
    }
    console.log('1');

  } else if (mouseX &gt; 155 &amp;&amp; mouseX &lt; 230 &amp;&amp; mouseY &gt; 92 &amp;&amp; mouseY &lt; 160 &amp;&amp; locked[1] === 0) {
    board[1] = 1;
    locked[1] = 1;
    if (turn === 0) {
      turn = 1;
    } else if (turn === 1) {
      turn = 0;
    }
    console.log('2');

  } else if (mouseX &gt; 230 &amp;&amp; mouseX &lt; 300 &amp;&amp; mouseY &gt; 92 &amp;&amp; mouseY &lt; 160) {
    console.log('3');
  } else if (mouseX &gt; 80 &amp;&amp; mouseX &lt; 155 &amp;&amp; mouseY &gt; 105 &amp;&amp; mouseY &lt; 230) {
    console.log('4');
  } else if (mouseX &gt; 155 &amp;&amp; mouseX &lt; 230 &amp;&amp; mouseY &gt; 105 &amp;&amp; mouseY &lt; 230) {
    console.log('5');
  } else if (mouseX &gt; 230 &amp;&amp; mouseX &lt; 300 &amp;&amp; mouseY &gt; 105 &amp;&amp; mouseY &lt; 230) {
    console.log('6');
  } else if (mouseX &gt; 80 &amp;&amp; mouseX &lt; 155 &amp;&amp; mouseY &gt; 230 &amp;&amp; mouseY &lt; 300) {
    console.log('7');
  } else if (mouseX &gt; 155 &amp;&amp; mouseX &lt; 230 &amp;&amp; mouseY &gt; 230 &amp;&amp; mouseY &lt; 300) {
    console.log('8');
  } else if (mouseX &gt; 230 &amp;&amp; mouseX &lt; 300 &amp;&amp; mouseY &gt; 230 &amp;&amp; mouseY &lt; 300) {
    console.log('9');
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=""utf-8""&gt;
  &lt;meta name=""viewport"" content=""width=device-width""&gt;
  &lt;title&gt;repl.it&lt;/title&gt;
  &lt;link href=""style.css"" rel=""stylesheet"" type=""text/css"" /&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;script src=""script.js""&gt;&lt;/script&gt;
  &lt;script src=""https://cdn.jsdelivr.net/npm/p5@1.2.0/lib/p5.js""&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","14777028","","754119","","2021-01-14 15:02:36","2021-01-14 15:02:36","p5js fix click to change shape","<javascript><html><rxjs5>","0","0","","","","CC BY-SA 4.0"
"66202096","1","66202280","","2021-02-15 02:35:53","","0","24","<p>Here is what I want to achieve:</p>
<pre class=""lang-js prettyprint-override""><code>this.jobManager
    .queue(
        // start a job
    )
    .then(
        // do more stuff, but abort if `ABORT` action dispatched before it finishes
    )
    .finally(
        // still do some cleanup even if `ABORT` dispatched
    );
</code></pre>
<p>Here is what I have &quot;tried&quot;:</p>
<pre class=""lang-js prettyprint-override""><code>this.actions$.pipe(
    ofActionDispatched(ABORT)
    .subscribe(() =&gt; {
        // somehow interrupt the promise chain in the above code block...
    })
);
</code></pre>
<p>Hopefully, I have sufficiently communicated the required logic. I would assume the two would need to be combined into a single promise chain but am unsure how to do this.</p>
","8667436","","","","","2021-02-15 03:14:02","Abort promise chain upon action dispatch (rxjs)","<javascript><angular><rxjs5>","1","0","","","","CC BY-SA 4.0"
"66202280","2","","66202096","2021-02-15 03:14:02","","1","","<p>I'm not 100% sure how your ofActionDispatched function is working but can you get it to throw an error if it needs to abort and then use catchError to return a null value and then check for that in the subscription, like so:</p>
<pre><code>this.actions$.pipe(
            map(obj =&gt; {
                // do stuff
            }),
            catchError(err =&gt; {
                return of(null);
            }))
        .subscribe((res) =&gt; {
                if (!res) {
                    // do stuff if error was caught in pipe
                }
            })
</code></pre>
","8917310","","","","","2021-02-15 03:14:02","","","","0","","","","CC BY-SA 4.0"
"66230474","1","","","2021-02-16 18:54:18","","0","113","<p>I am trying to pass an email from accountrecovery component to password-reset component with BehaviorSubject but Im not receiving the email in password-reset component instead I get the initial value. I receive the new email in the service tho.</p>
<p>accountrecovery.component</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { MyseatDataService } from '../../storitve/myseat-data.service';
import { SendemailbetweencompService } from '../../storitve/sendemailbetweencomp.service';
@Component({...})
export class AccountRecoveryComponent implements OnInit {
  constructor(private myseatdata: MyseatDataService,
              private givemailtopasscomp:SendemailbetweencompService) { }

  public resetEmailData = {email: &quot;&quot;}
  public sendEmailData(): void {
    this.givemailtopasscomp.sendMail(this.resetEmailData.email);
    //... do backend
  }
}
</code></pre>
<p>sendemailbetweencomp.service</p>
<pre><code>import { Injectable } from '@angular/core'
import { BehaviorSubject } from 'rxjs'
@Injectable({providedIn: 'root'})
export class SendemailbetweencompService {
    private emailsource = new BehaviorSubject&lt;string&gt;('test@gmail.com');
    emailsource$ = this.emailsource.asObservable();

    constructor(){ }
    sendMail(email: string){
        this.emailsource.next(email); //console.log(this.emailsource.getValue()); value arrives here
    }
}
</code></pre>
<p>password-reset.component</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { MyseatDataService} from '../../storitve/myseat-data.service';
import { SendemailbetweencompService } from '../../storitve/sendemailbetweencomp.service';
@Component({...})
export class PasswordResetComponent implements OnInit {
  constructor(private myseatdata: MyseatDataService,
              private givemailtopasscomp: SendemailbetweencompService) { }

  public resetPassword(): void {
    this.givemailtopasscomp.emailsource$.subscribe( email =&gt; {
      console.log(email); // returns test@gmail.com instead of a new value
    });
    // do backend
  }
  ngOnInit(): void {
    this.givemailtopasscomp.emailsource$.subscribe( email =&gt; {
      console.log(email); // returns test@gmail.com instead of a new value
    });
  }
}
</code></pre>
","14695083","","","","","2021-02-16 20:17:13","BehaviorSubject not working as expected Angular","<angular><observable><rxjs5>","1","4","","","","CC BY-SA 4.0"
"66633711","1","66638793","","2021-03-15 07:13:43","","1","176","<p>I've following interfaces and <code>Observable&lt;Machine[]&gt;</code>, what I want to achive is group by Machine <code>symbol</code> property in  <code>Observable&lt;Machine[]&gt;</code> and return mapped observable <code>Observable&lt;Order[]&gt;</code>.</p>
<pre><code>export interface Machine {
    symbol: string;
    price: number;
    amount: number;
    id: number;
}

export interface Order {
    symbol: string;
    machines: OrderMachine[];
}

export interface OrderMachine {
    price: number;
    amount: number;
    id: number;
}
</code></pre>
<p>I've tried to use RxJS gropBy operator but it seems it return grouped array one by one.</p>
<pre><code>machines: Machine[] = [
        { amount: 1,  id: 1, symbol: &quot;A&quot;, price: 1 },
        { amount: 1,  id: 2, symbol: &quot;A&quot;, price: 2 }
    ];


of(machines).pipe(
        takeUntil(this.unsubscribe),
        mergeMap(res =&gt; res),
        groupBy(m =&gt; m.symbol),
        mergeMap(group =&gt; zip(of(group.key), group.pipe(toArray()))),
        map(x =&gt; { // here I have probably wrong model [string, Machine[]]
            const orderMachines = x[1].map(y =&gt; { return &lt;OrderMachine&gt;{price: y.price, amount: y.amount, id: y.id }})
            return &lt;Order&gt;{ symbol: x[0], machines: orderMachines }  })
        );
</code></pre>
<p>as in result I have <code>Observable&lt;Order&gt;</code> istead of<code>Observable&lt;Order[]&gt;</code>.</p>
<p>expected result model:</p>
<pre><code>orders: Order[] = [
        {   
            symbol: &quot;A&quot;, 
            machines: [
                { amount: 1, price: 1, id: 1 },
                { amount: 1, price: 2, id: 2 }
            ]
        }
    ];
</code></pre>
","5953169","","5953169","","2021-03-15 11:02:08","2021-03-17 12:47:55","RxJS group by field and return new observable","<rxjs><rxjs5><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66638793","2","","66633711","2021-03-15 13:20:17","","2","","<p>Here a possible solution based on your approach but with a few changes:</p>
<pre><code>const machines = [
  { amount: 1, id: 1, symbol: &quot;A&quot;, price: 1 },
  { amount: 1, id: 2, symbol: &quot;A&quot;, price: 2 },
  { amount: 1, id: 3, symbol: &quot;B&quot;, price: 3 }
];

from(machines) // (1)
  .pipe(
    // (2)
    groupBy((m) =&gt; m.symbol),
    mergeMap((group) =&gt; group.pipe(toArray())),
    map((arr) =&gt; ({
      symbol: arr[0].symbol, // every group has at least one element
      machines: arr.map(({ price, amount, id }) =&gt; ({
        price,
        amount,
        id
      }))
    })),
    toArray(), // (3)
  )
  .subscribe(console.log);
</code></pre>
<p><strong>(1)</strong> I changed <code>of(machines)</code> to <code>from(machines)</code> in order to emit the objects from <code>machines</code> one by one into the stream. Before that change the whole array was emitted at once and thus the stream was broken.</p>
<p><strong>(2)</strong> I removed <code>takeUntil(this.unsubscribe)</code> and <code>mergeMap(res =&gt; res)</code> from the pipe since there is no reason to have them in your example. <code>takeUntil</code> wouldn't have any effect since the stream is finite and synchronous. An identity function (<code>res =&gt; res</code>) applied with <code>mergeMap</code> would make sense in a stream of streams which is not the case  in your example. Or do you actually need these operators for your project because you have an infinite stream of observables?</p>
<p><strong>(3)</strong> <code>toArray()</code> is what transforms <code>Observable&lt;Order&gt;</code> to <code>Observable&lt;Order[]&gt;</code>. It waits until the stream ends and emits all streamed values at once as an array.</p>
<p><strong>edit:</strong></p>
<p>The op has mentioned that he rather needs a solution that is compatible with an infinite stream but because <code>toArray</code> only works with finite streams the provided answer above would never emit anything in such scenario.</p>
<p>To solve this I would avoid using <code>groupBy</code> from rxjs. It cvan be a very  powerful tool in other cases where you need to split one stream into several groups of streams but in your case you simply want to group an array and there are easier methods for that that.</p>
<pre><code>this.store.pipe(
    select(fromOrder.getMachines)
    map((arr) =&gt;
        // (*) group by symbol
        arr.reduce((acc, { symbol, price, amount, id }) =&gt; {
            acc[symbol] = {
                symbol,
                machines: (acc[symbol] ? acc[symbol].machines : [])
                    .concat({ price, amount, id })
            };
            return acc;
        }, {})
    ),
)
.subscribe((result) =&gt; 
    // (**)
    console.log(Object.values(result))
);
</code></pre>
<p><strong>(*)</strong> you could use a vanilla <a href=""https://stackoverflow.com/questions/14446511/most-efficient-method-to-groupby-on-an-array-of-objects"">groupBy implementation</a> that returns an object of the shape <code>{[symbol: string]: Order}</code>.</p>
<p><strong>(**)</strong> <code>result</code> is an object here but you can convert it to an array easily but applying <code>Object.values(result)</code></p>
","6485687","","6485687","","2021-03-17 12:47:55","2021-03-17 12:47:55","","","","0","","","","CC BY-SA 4.0"
"66650336","1","","","2021-03-16 06:56:28","","0","50","<p>How to handle asynchronous calls in angular. I know i am getting array as undefined due to asynchronous nature but how do i solve it</p>
<pre><code>
private fetchData(id){
   var array = [];
   this.httpClient.get('someUrl/'+id).subscribe((organisation)=&gt;{
      console.log(organisation.teams);   // ['team1','team2','team3']
      organisation.teams.forEach((team)=&gt;{
          this.httpClient/get('someUrl/'+team).subscribe((teamData)=&gt;{
             array.push(teamData);
          })
       })
       console.log(array);    // undefined
    })
}

</code></pre>
","15291280","","15291280","","2021-03-16 07:01:54","2021-03-16 07:46:37","Issue with asynchronous angular requests","<javascript><angular><typescript><rxjs5>","1","4","","","","CC BY-SA 4.0"
"66690603","1","66691323","","2021-03-18 11:54:42","","0","31","<p>Hi I am having an angular2 project.
I have two rxjs expressions. how can i combine both of them . the following is my rxjs expressions.</p>
<pre><code>this.trafficTypeControl.valueChanges
      .pipe(
        filter(x =&gt; x !== null),
        switchMap(x =&gt; {
          if (x === TrafficType.TRANSACTIONAL || x === TrafficType.BULK_SEND) {
            this.campaignControl.setValue(null);
            this.flightControl.setValue(null);
            this.campaigns = [];
            this.flights = [];
          }
          return x;
        })
      ).subscribe();



this.trafficTypeControl.valueChanges
  .pipe(
    filter(x =&gt; x !== null),
    switchMap(x =&gt; {
      if (x === TrafficType.CAMPAIGN) {
        return this.campaignsService.getUnpaginatedCampaignsWithinRange({
          accountIds: this.currentUser.account
            ? this.currentUser.account.id
            : null,
          campaignStatuses: this.campaignStatusIds,
          rangeStartDate: this.rangeControl.value[0].toISOString(),
          rangeEndDate: this.rangeControl.value[1].toISOString()
        });
      }
    }),
    tap(campaigns =&gt; {
      console.log(&quot;TrafficType.CAMPAIGN :&quot; + JSON.stringify(campaigns));
      this.campaigns = campaigns;
    })
  ).subscribe();
</code></pre>
<p>i would like to have a single expression that incorporate both logic.</p>
<p>appreciate if you can help
thank you</p>
","14820140","","14820140","","2021-03-18 12:43:47","2021-03-18 12:55:00","How can i combine my RXJS expressions that represents two different logic?","<rxjs><rxjs5><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"66691323","2","","66690603","2021-03-18 12:43:08","","0","","<p>Hi I have rewritten as follows</p>
<pre><code> this.trafficTypeControl.valueChanges
      .pipe(
        filter(x =&gt; x !== null),
        switchMap(x =&gt; {

          if (x === TrafficType.TRANSACTIONAL || x === TrafficType.BULK_SEND) {

            this.campaignControl.setValue(null);
            this.flightControl.setValue(null);
            this.campaigns = [];
            this.flights = [];
            return [];
          } else if (x === TrafficType.CAMPAIGN) {

            return this.campaignsService.getUnpaginatedCampaignsWithinRange({
              accountIds: this.currentUser.account
                ? this.currentUser.account.id
                : null,
              campaignStatuses: this.campaignStatusIds,
              rangeStartDate: this.rangeControl.value[0].toISOString(),
              rangeEndDate: this.rangeControl.value[1].toISOString()
            });

          }
        }),
        tap(campaigns =&gt; {
          this.campaigns = campaigns;
        })
      ).subscribe();
</code></pre>
<p>not sure this is the cleaner solution.</p>
","14820140","","","","","2021-03-18 12:43:08","","","","0","","","","CC BY-SA 4.0"
"66705407","1","66706435","","2021-03-19 09:15:46","","1","66","<p>I would like to implement gap / delay between every interval call,
i have tried below but it seems not working.</p>
<pre><code>  pollOnInterval(threshold = 4000): Observable&lt;any&gt; {
    let thresholdValue = threshold;
    const increaseBy = 2000;
    const maxCount = 10;
    return interval(thresholdValue).pipe(take(maxCount)).pipe(delay(increaseBy)).pipe(map(() =&gt; {
      thresholdValue = thresholdValue + increaseBy;
      console.log((new Date).toLocaleTimeString());
    }));
  }
</code></pre>
<p><strong>output</strong><br />
2:34:21 PM<br />
2:34:25 PM<br />
2:34:29 PM<br />
2:34:33 PM<br />
2:34:37 PM<br />
2:34:41 PM<br />
2:34:45 PM<br />
2:34:49 PM<br />
2:34:53 PM<br />
2:34:57 PM</p>
<p><strong>Edit -1</strong> I have tried debounce and debouceTime, It didn't work too,
Stackbliz link: <a href=""https://stackblitz.com/edit/angular-ivy-tinm4r?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-tinm4r?file=src%2Fapp%2Fapp.component.ts</a></p>
<p><strong>Edit - 2</strong> I need in below way<br />
2:34:21 PM<br />
2:34:27 PM<br />
2:34:35 PM</p>
","1432240","","1432240","","2021-03-19 09:47:52","2021-03-19 10:28:48","How to put custom gap between interval for polling in Rxjs angular?","<angular><rxjs><rxjs5><rxjs6>","1","3","","","","CC BY-SA 4.0"
"66706435","2","","66705407","2021-03-19 10:28:48","","2","","<ol>
<li><p>You could pipe all the operators in a single <code>pipe()</code>. Each operator doesn't require it's own pipe.</p>
</li>
<li><p>As mentioned in my comment, once the <code>interval()</code> is triggered using the <code>thresholdValue</code>, the subsequent changes to the <code>thresholdValue</code> variable won't have any effect on the <code>interval()</code> function. It will continue to emit for each time interval denoted by the <code>thresholdValue</code> <em>initally</em>.</p>
</li>
<li><p>At the moment the observable is emitting <code>undefined</code>s since nothing is returned from the <code>map</code>.</p>
</li>
<li><p>You need to use <code>concatMap</code> and pipe the delay to each emission individually. If not, the <code>delay</code> would be piped to the <code>interval</code> as a whole as seen in the question.</p>
</li>
</ol>
<p>Try the following</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var { from, of, Observable, interval } = rxjs;
var { tap, delay, take, map, concatMap } = rxjs.operators;

var displayBox = document.getElementById('display');

function pollOnInterval(threshold = 4000) {
  let increaseBy = 4000;     // delay for first emission from `interval`
  const maxCount = 10;
  return interval(4000).pipe(
    concatMap(value =&gt; of(value).pipe(
      tap(() =&gt; 
        displayBox.innerHTML += `
          Interval: ${new Date().toLocaleTimeString()}; 
          Delay: ${increaseBy/1000}s
          &lt;br /&gt;
        `
      ),
      delay(increaseBy)
    )),
    tap(() =&gt; increaseBy += 2000),     // &lt;-- adjust `increaseBy`
    take(maxCount),
    map(() =&gt; new Date().toLocaleTimeString())
  );
}

pollOnInterval().subscribe({
  next: value =&gt; displayBox.innerHTML += `Subscription: ${value}&lt;br /&gt;&lt;hr&gt;`,
  error: null,
  complete: () =&gt; displayBox.innerHTML += 'Observable complete.'
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://unpkg.com/rxjs@6.6.0/bundles/rxjs.umd.min.js""&gt;&lt;/script&gt;

&lt;p id=""display""&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>
","6513921","","","","","2021-03-19 10:28:48","","","","1","","","","CC BY-SA 4.0"
"66782748","1","","","2021-03-24 14:03:43","","0","32","<p>Angular also goes into the &quot;first&quot; place when I get data from the service. However, without clicking any button on the page, it does not enter the place where I write &quot;second&quot;.</p>
<pre><code> GetAllVessels(){ 
      alert('first');
   this.AllVessels=this.http.get&lt;Vessel[]&gt;(this.baseUrl+'Vessel/GetAllVessels',httpOptions).pipe(
   map((result: Vessel[]) =&gt; {
     console.log(result);
     alert('second');
   return result;
   })
   ); 
</code></pre>
","11011467","","5437671","","2021-03-24 14:05:58","2021-03-24 14:39:00","Angular data not loading","<angular><http><web-services><rxjs5>","1","2","","","","CC BY-SA 4.0"
"67003010","1","","","2021-04-08 11:25:30","","1","61","<p>I'm finding it hard to implement debounce on an HTTP request with Rxjs once a button is clicked. What I'm trying to achieve is when the button is click, it should wait for x seconds before the post is been made to the server.</p>
<pre><code>btnClick() {
    this.loader = true;
    let send = &quot;&quot;;
    send = this.checkForm.username.value;
    this.checkService
      .validate(send)
      .pipe(finalize(() =&gt; (this.loader = false)))
      .subscribe((response) =&gt; {
        console.log(response)
      });
  }
</code></pre>
","15504759","","5437671","","2021-04-08 11:28:11","2021-04-08 11:49:00","debounce request on button click with angular","<angular><rxjs5>","1","0","","","","CC BY-SA 4.0"
"67294007","1","","","2021-04-28 05:00:41","","0","63","<p>What i am trying to do is</p>
<ol>
<li>call a service and bind the data on ngOnit()</li>
<li>In the given textbox, when a user types something, instead of calling API call for every letter, wait for a second, if user doesn't type further, then make API call (need to debounce between user strokes).</li>
<li>When the search is done, i want to bind that data back.</li>
</ol>
<p>Issue: For the below API call, for the same search keyword 3 to 4 calls are made, i want to make 1 call instead, any help will be appreciated, thanks.</p>
<p>In my html file</p>
<pre><code>&lt;div *ngIf=let result in result$ | async&gt;
  
&lt;/div&gt;
&lt;input type=&quot;text&quot; (keyup)=&quot;filterData($event)&quot;&gt;
</code></pre>
<p>In my component file</p>
<pre><code>ngOnInit(){

this.result$ =  someServiceCall(); //result$ is an observable
}

filterData(event)
{
  fromEvent(event.target, 'keyup')
  .pipe(debounceTime(1000), distinctUntilChanged(),
  mergeMap((search) =&gt; {
    this.result$ = someServiceCall(event.target.value)
    }))
observable.subscribe(value) =&gt; {
})
}
return this.result$
}
</code></pre>
","441664","","","","","2021-04-28 05:43:31","Avoiding duplicate calls inside keyup event in angular","<angular><rxjs><angular-material><rxjs5><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68058956","1","","","2021-06-20 18:33:18","","1","58","<p>I've been using Observables in Angular in the state layer to store the app data and to share that data among the components of the app. With a belief, using observables, that data would passively update itself in the template whenever it changes, without checking it manually.</p>
<p>So out of curiosity, I've made the following demonstration to see the result of not using Observables: <a href=""https://stackblitz.com/github/joaqra/Observables"" rel=""nofollow noreferrer"">stackblitz</a></p>
<p>It turns out that the template passively updates itself by using a normal array instead of using observables.</p>
<p>I'm wondering, what's the added value of using observable instead of a normal array to store/share data in the angular app?</p>
","12954985","","12954985","","2021-06-20 21:24:55","2021-06-20 21:24:55","What's the added value of using Observable over normal Array?","<javascript><angular><typescript><observable><rxjs5>","1","5","0","2021-06-20 19:14:20","","CC BY-SA 4.0"
"68738483","1","68746729","","2021-08-11 08:26:31","","2","34","<p>I created an Observable Alert in AG Grid (using Adaptable) which is correctly firing when an order is stale for 2 minutes.
But I only see the Alert in the Toolbar and not as a popup notification in the grid like happens in this demo: <a href=""https://demo.adaptabletools.com/alertsmessages/aggridobservablealertdemo"" rel=""nofollow noreferrer"">https://demo.adaptabletools.com/alertsmessages/aggridobservablealertdemo</a></p>
<p>The Expression for the Alert is</p>
<pre><code>GRID_CHANGE( [order_tick] ), TIMEFRAME('2m') ) 
</code></pre>
<p>What am I doing wrong?</p>
","11857476","","","","","2021-08-11 17:51:00","How can I make an Alert appear in the screen using AG Grid and Adaptable/","<ag-grid><rxjs5><rxjs6><ag-grid-react><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68746729","2","","68738483","2021-08-11 17:44:52","","4","","<p>You don't say in your question if you are providing the Alert at run-time or design-time.</p>
<p>If the latter then in your Alert Predefined Config definition you need to set 'DisplayNotification' to true in the <code>AlertProperties</code> section:</p>
<pre><code> AlertProperties: {
   DisplayNotification: true,
 }
</code></pre>
<p>If you are creating it at run-time then in the 3 step of the Wizard ('Type and Display'), you need to enable the checkbox: 'Show a Notification when Alert is triggered'.</p>
","8542104","","1839439","","2021-08-11 17:51:00","2021-08-11 17:51:00","","","","0","","","","CC BY-SA 4.0"
"68858067","1","","","2021-08-20 06:54:36","","0","53","<p>I am basically calling an API on keyup event of a textbox using switchmap. The problem that I am facing is that switchmap doesn't cancel the previous ongoing API call when a new API call is made</p>
<pre><code>import {AfterViewInit, Component, ElementRef, OnInit, ViewChild} from '@angular/core';
import {fromEvent, Observable} from &quot;rxjs&quot;;
import {debounceTime, distinctUntilChanged, map, switchMap} from &quot;rxjs/operators&quot;;

@Component({
  selector: 'app-debounce-component',
  templateUrl: './debounce-component.component.html',
  styleUrls: ['./debounce-component.component.css']
})
export class DebounceComponentComponent implements OnInit,AfterViewInit {

  constructor() { }
  @ViewChild('searchinput') ele:ElementRef

  ngOnInit(): void {
  }

  ngAfterViewInit(): void {
    fromEvent(this.ele.nativeElement , 'keyup').pipe(
      debounceTime(1000),
      map(evt=&gt;{

             return evt['target']['value']
      }),
      switchMap(value=&gt;{
        console.log(value);
        return this.createObservable(value);
      }),
      distinctUntilChanged()
    ).subscribe() ;
  }

  createObservable(value):Observable&lt;any&gt;{

    return Observable.create(observer=&gt;{
      fetch(`http://localhost:3000/courses/${value}`).then(res=&gt;{
        res.json();
      }).then(body=&gt;{
        observer.next(body);
        observer.complete();
      });
    })

  }

}
</code></pre>
","16711559","","1838804","","2021-08-20 12:41:38","2021-08-20 12:41:38","Swicthmap in rxjs doesnt cancel the previous request","<javascript><angular><rxjs><rxjs5><switchmap>","1","5","","","","CC BY-SA 4.0"
"69281399","1","","","2021-09-22 09:18:41","","0","45","<p>I have implemented autocomplete research in my Angular project. I am now trying to remove the list from the dropdown when option is selected. Problem is I am getting my data async so my data is a stream and I am not sure how to remove the object from the stream. Any help is welcome:</p>
<p>HTML</p>
<pre><code> input type=&quot;text&quot; placeholder=&quot;Placeholder&quot;
      aria-label=&quot;area-label&quot; matInput 
      [formControl]=&quot;searchedOption&quot;
      [matAutocomplete]=&quot;auto&quot;&gt;
 &lt;mat-autocomplete autoActiveFirstOption #auto=&quot;matAutocomplete&quot; [displayWith]=&quot;displayFn&quot;&gt;
      &lt;mat-option *ngFor=&quot;let option of filteredOptions| async&quot; [value]=&quot;option&quot; 
        (onSelectionChange)=&quot;onSearchSelect($event)&quot;&gt;
        {{option.name}}
      &lt;/mat-option&gt;
    &lt;/mat-autocomplete&gt;
</code></pre>
<p>TS</p>
<p>searchedOption = new FormControl();
filteredOptions: Observable&lt;any[]&gt;;</p>
<pre><code>    initAutocompleteSearch() {
    this.filteredOptions = this.searchedOption.valueChanges.pipe(
      startWith(''),
      debounceTime(400),
      switchMap(value =&gt; this.doFilter(value))
    )
  }

  doFilter(value: string) {
    return this.myService.getMyData()
      .pipe(
        map(response =&gt; response.filter((option: any) =&gt; {
          { return option.name.toString().toLowerCase().trim().indexOf(value.toString().toLowerCase().trim()) === 0}
        })
      ))
  }
</code></pre>
<p>I have looked into documentation and other simillar questions on Stack owerflow but seeing that my array is and observeable I couldn't find the solution.
Thank you</p>
","11746772","","","","","2021-09-22 09:18:41","Remove item from Observable<any[]> Angular autocomplete with dropdown","<angular><typescript><observable><rxjs5>","0","0","","","","CC BY-SA 4.0"
"69541466","1","69542013","","2021-10-12 13:29:42","","-1","26","<p>I have tried to get data from BehSubject <code>this.visible$</code> only in case when <code>this.redraw$</code> happends.</p>
<p>It works, but if the <code>this.visible$</code> is changed somewhere the prev stream again works. How to avoid it?</p>
<pre><code>this.redraw$.pipe(mergeMap(() =&gt; this.visible$)).subscribe((userfavourite: UserFavourite[]) =&gt; {}
</code></pre>
<p>As solution I can do this:</p>
<pre><code>this.redraw$.subcribe(() =&gt; {
   this.visible$.subscribe((userfavourite: UserFavourite[]) =&gt; {}
});
</code></pre>
","","user16382159","598683","","2021-10-12 13:50:52","2021-10-12 14:13:03","How to get data from second stream by first?","<angular><rxjs><rxjs5>","1","1","","","","CC BY-SA 4.0"
"69542013","2","","69541466","2021-10-12 14:05:32","","0","","<p>Maybe something like:</p>
<pre class=""lang-ts prettyprint-override""><code>this.redraw$.pipe(
  withLatestFrom(this.visible$),
  map(([_,v]) =&gt; v)
).subscribe(visible =&gt; {
  /* Do Something */
});
</code></pre>
","13500986","","13500986","","2021-10-12 14:13:03","2021-10-12 14:13:03","","","","0","","","","CC BY-SA 4.0"
"70200042","1","","","2021-12-02 13:06:10","","1","85","<p>I have a scenario, my child component takes BehaviourSubject as Input and that(child) subscribes it internally.
I need to filter/map on BehaviourSubject in the parent, so that when somewhere next() is called then child subscription receives map/filtered values.</p>
<pre><code>export class ParentComponent {
    public myBSubject: BehaviorSubject&lt;ListFilter[]&gt; = new BehaviorSubject&lt;ListFilter[]&gt;(undefined);
    public ngOnInit(): void {
        this.myBSubject = this.myBSubject.pipe(
          map((filters): ListFilter[] =&gt; {
            // Do some manipulation with filters
          return filters;
        }));
    }
}
</code></pre>
<p>tempalate</p>
<pre><code>&lt;child [myBSubject]=&quot;myBSubject&quot;&gt; &lt;/child&gt;
</code></pre>
<p>ChildComponent (I have no control on it.)</p>
<pre><code>export class ChildComponent {
 @Input()
  public myBSubject: BehaviorSubject&lt;ListFilter[]&gt; = new BehaviorSubject&lt;ListFilter[]&gt;(undefined);
  
  // somewhere subscription of myBSubject

}
</code></pre>
<p>the problem is the .pipe(map) converting BehaviourSubject to Observable, which is not assignable. and without assigning map callback not called because immutable map.</p>
<p>by making
<code>.pipe(map..) as BehaviourSubject&lt;ListFilter&gt;</code> working fine but i'm feeling its not a good solution.
Please help me to achieve this in a better way, Thank you.</p>
","6310485","","6310485","","2021-12-03 05:06:08","2021-12-03 05:06:08","Map behavioursubject and assign it to same variable after mapping rxjs","<angular><rxjs><rxjs5>","1","5","","","","CC BY-SA 4.0"