Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"26968674","1","26969028","","2014-11-17 08:46:02","","36","11011","<p>I am going to start using reactive programming in my Android project. I am using Kotlin as primary language and now I would like to apply Rx. My first choice was RxAndroid but then I noticed that there is RxKotlin.</p>

<p>As far as I know both are forked from RxJava so RxAndroid probably provides some API for android common tasks. On the other hand RxKotlin support lambas out of the box and allow me avoiding mixing kotlin with java.</p>

<p>Which one is preferred library in that case?   </p>
","1456931","","1456931","","2014-11-17 08:56:37","2016-04-01 03:23:55","Use RxAndroid or RxKotlin when programming in Kotlin for Android?","<android><rx-android><rx-kotlin>","1","1","8","2014-11-18 13:08:24","","CC BY-SA 3.0"
"29882922","1","29939049","","2015-04-26 20:08:43","","1","578","<p>The error in the title appears in Android Studio as a warning bar above all my code: <img src=""https://i.stack.imgur.com/JVvo5.png"" alt=""Error""></p>

<p>Android Studio version: <code>1.1.0</code><br>
Kotlin plugin version for Android Studio: <code>0.11.91.AndroidStudio.4</code><br>
<code>build.gradle</code> file that seems to be using all the most recent versions of the Kotlin libraries:</p>

<pre><code>apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'

android {
    compileSdkVersion 22
    buildToolsVersion ""22.0.1""

    defaultConfig {
        applicationId ""ca.amandeep.simpletransit""
        minSdkVersion 16
        targetSdkVersion 22
        versionCode 1
        versionName ""1.0""
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.0.0'
    compile ""org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version""
    compile 'com.squareup.retrofit:retrofit:1.9.0'
    compile('com.squareup.retrofit:converter-simplexml:1.9.0') {
        exclude module: 'stax'
        exclude module: 'stax-api'
        exclude module: 'xpp3'
    }
    compile 'com.squareup.okhttp:okhttp:2.3.0'
    compile 'com.squareup.okhttp:okhttp-urlconnection:2.3.0'
    compile 'com.google.guava:guava:18.0'
    compile 'com.facebook.stetho:stetho:1.0.1'
    compile 'com.facebook.stetho:stetho-okhttp:1.0.1'
    compile 'com.jakewharton.timber:timber:2.7.1'
    compile 'io.reactivex:rxkotlin:0.21.0'
    compile 'io.reactivex:rxandroid:0.24.0'
    compile 'com.github.techfreak:wizardpager:1.0.0'
}
buildscript {
    ext.kotlin_version = '0.11.91.1'
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath ""org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version""
        classpath ""org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version""
        classpath 'com.jakewharton.hugo:hugo-plugin:1.2.1'
    }
}
repositories {
    mavenCentral()
}

apply plugin: 'com.jakewharton.hugo'
</code></pre>
","137081","","","","","2016-01-04 18:39:25","Kotlin library 'rxkotlin-0.21.0.jar' has an unsupported format. Please update the library or the plugin","<android><android-studio><kotlin><rx-android><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"34583595","1","34587372","","2016-01-04 01:25:32","","5","862","<p>I was having some issues using RxJava and Kotlin earlier. I made some interesting discoveries which I'm still puzzled about. </p>

<p>There is the simple <code>Func1</code> interface in RxJava</p>

<pre><code>public interface Func1&lt;T, R&gt; extends Function {
    R call(T t);
}
</code></pre>

<p>I was trying to add an extension method to an <code>Observable</code>, also an RxJava class. This would collect the emissions into a Google Guava <code>ImmutableListMulitmap</code> using a <code>Func1</code> to map the key off each item. </p>

<pre><code>fun &lt;K,T&gt; Observable&lt;T&gt;.toImmutableListMultimap(keyMapper: Func1&lt;T, K&gt;): Observable&lt;ImmutableListMultimap&lt;K,T&gt;&gt; {
    return this.collect({ ImmutableListMultimap.builder&lt;K,T&gt;()},{ b, t -&gt; b.put(keyMapper.call(t), t)}).map { it.build() }
}
</code></pre>

<p>When I tried to invoke this extension method I could not get it to compile, and it was not understanding the lambda expression at all. </p>

<pre><code>ScheduledItem.all.flatMap { it.rebuildSoftTransactions }
.toImmutableListMultimap { it.id /*compile error */ } .cache()
</code></pre>

<p>However, the strangest thing happened when I modified the extension method to use the <a href=""https://kotlinlang.org/docs/reference/lambdas.html#function-types"">function type</a>.</p>

<pre><code>fun &lt;K,T&gt; Observable&lt;T&gt;.toImmutableListMultimap(keyMapper: (T) -&gt; K): Observable&lt;ImmutableListMultimap&lt;K,T&gt;&gt; {
    return this.collect({ ImmutableListMultimap.builder&lt;K,T&gt;()},{ b, t -&gt; b.put(keyMapper(t), t)}).map { it.build() }
}
</code></pre>

<p>And then everything compiled fine. But this is what puzzled me: How come it did not infer the lambda onto the interface? When I use the standard <code>map()</code> method on the <code>Observable</code> it infers the lambda just fine using the curly bracket <code>{ }</code> syntax. But why does it not work for my extension method above?</p>
","1373258","","","","","2016-01-04 08:44:23","Behavior with Kotlin Higher-Order Functions and Single-method interfaces?","<lambda><rx-java><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"34966999","1","34971416","","2016-01-23 18:14:59","","13","4691","<p>I'm confused by Kotlin lambda syntax. </p>

<p>At first, I have</p>

<pre><code>.subscribe(
          { println(it) }
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p><strong>which works fine</strong>.</p>

<p>Then I moved the onNext to another class called GroupRecyclerViewAdapter which implements <code>Action1&lt;ArrayList&lt;Group&gt;&gt;</code>. </p>

<pre><code>.subscribe(
          view.adapter as GroupRecyclerViewAdapter
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p>However, I got the error:</p>

<p><a href=""https://i.stack.imgur.com/0GAwv.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/0GAwv.png"" alt=""error""></a></p>

<pre><code>Error:(42, 17) Type mismatch: inferred type is () -&gt; ??? but rx.functions.Action1&lt;kotlin.Throwable!&gt;! was expected
Error:(42, 27) Unresolved reference: it
Error:(43, 17) Type mismatch: inferred type is () -&gt; kotlin.Unit but rx.functions.Action0! was expected
</code></pre>

<p>I can fix the error by changing to:</p>

<pre><code>.subscribe(
          view.adapter as GroupRecyclerViewAdapter
          , Action1&lt;kotlin.Throwable&gt; { println(it.message) }
          , Action0 { println(""completed"") }
      )
</code></pre>

<p><strong>Is there a way to write the lambda without specifying a type?</strong> (<code>Action1&lt;kotlin.Throwable&gt;</code>, <code>Action0</code>) </p>

<p><a href=""https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Observable.java"" rel=""noreferrer"">Note: subscribe is RxJava method</a></p>

<p><strong>Edit 1</strong></p>

<pre><code>class GroupRecyclerViewAdapter(private val groups: MutableList&lt;Group&gt;,
                           private val listener: OnListFragmentInteractionListener?) :
RecyclerView.Adapter&lt;GroupRecyclerViewAdapter.ViewHolder&gt;(), Action1&lt;ArrayList&lt;Group&gt;&gt; {
</code></pre>
","1104902","","1104902","","2016-01-24 22:34:48","2016-01-25 14:19:58","Kotlin lambda syntax confusion","<kotlin><rx-kotlin>","2","3","2","","","CC BY-SA 3.0"
"35524980","1","35527773","","2016-02-20 15:04:15","","3","980","<p>This is working code but I have a few questions as well as a request for advice on improving it. I am new to RxJava and I have not fully wrapped my head around how to chain these type of observables together. </p>

<p>I have two model objects, <code>ListItem</code> and <code>UserInfo</code>. <code>ListItem</code>s exists in a local database and the <code>UserInfo</code> is fetched from the server by using an ID provided from the <code>ListItem</code>. </p>

<p>The <code>UserInfo</code> web service accepts an array of IDs for which it will return a list of <code>UserInfo</code> objects. </p>

<p>The flow of this code is as follows:</p>

<ol>
<li>Load <code>ListItem</code>s from database</li>
<li>Using the <code>ListItem</code>s fetched from the database, check an in memory cache to see if I've already fetched the <code>UserInfo</code> for a particular <code>ListItem</code></li>
<li>For any items whose <code>UserInfo</code> is not cached, fetch them from the network</li>
<li>Place the fetched <code>UserInfo</code> objects into the cache</li>
<li>Re-run step 2 ( the method is <code>loadCachedUserInfo</code>)</li>
<li>Return results to subscriber</li>
</ol>

<p>NOTE: The <code>UserInfo</code> objects should only be fetched for a <code>ListItem</code> if the list has been deemed a <code>isUserList</code>.</p>

<p>Here is the code:</p>

<pre><code>fun itemsInList(list : ATList, parentValue : String? = null, searchString : String? = null, limit : Int = defaultFetchLimit, sortOrder: SortDescriptor? = null) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        val listItems = listItemsInList(list, parentValue = parentValue, searchString = searchString, limit = limit, sortOrder = sortOrder)
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
        }
        return@flatMap Observable.just(listItems)
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap fetchUserInfoForListItems(listItems, list.userIDIndex!!, force = false)
        }
        return@flatMap Observable.just(listItems)
    }
}

fun loadCachedUserInfo(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        for ( listItem in listItems ) {
            listItem.coreUserInfo = coreUserMap[listItem.valueForAttributeIndex(userIDIndex)?.toLowerCase()]
        }
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }
}

fun fetchUserInfoForListItems(listItems : List&lt;ATListItem&gt;, userIDIndex: Int, force: Boolean) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    val itemsToFetch = if ( force ) listItems else listItems.filter { it.coreUserInfo == null }
    val ids = itemsToFetch.map { it.valueForAttributeIndex(userIDIndex) ?: """" }.filter { !it.isEmpty() }
    val records = hashMapOf(""records"" to ids)
    if ( itemsToFetch.count() == 0 ) {
        return Observable.just(listItems)
    }
    return RuntimeDataController.dataService.fetchCoreUserInfo(recordsMap = records)
            .map { json -&gt;
                val recordsArray = json.arrayValue(""records"")
                for ( i in 0..recordsArray.length() - 1) {
                    val coreUserInfo = CoreUserInfo(recordsArray.getJSONObject(i))
                    coreUserMap[coreUserInfo.username.toLowerCase()] = coreUserInfo
                    coreUserMap[coreUserInfo.userID] = coreUserInfo
                    coreUserInfo.externalUserID?.let { coreUserMap[it] = coreUserInfo }
                }
                return@map listItems
            }.flatMap { loadCachedUserInfo(listItems, userIDIndex = userIDIndex) }
}
</code></pre>

<p>The user would initiate the sequence of events by calling:</p>

<p><code>ListController.itemsInList(list)</code></p>

<p>My questions about this code are:</p>

<ol>
<li>Currently <code>loadCachedUserInfo</code> takes in an array of <code>ListItem</code> and returns that same array as an observable after the cached items have been associated with it. This feels wrong to me. I think instead this call should only return the items that have a cached <code>UserInfo</code> associated with it. However, I need to continue passing the full array of <code>ListItem</code> to the next method</li>
</ol>

<p>2.) Do I need to do additional work to support unsubscribing?</p>

<p>3.) This is similar question 1. My <code>fetchUserInfoForListItems</code> takes an array of list items and returns an observable with that same array of list items after they have been fetched and re-run through the cache method. This also feels incorrect to me. I would rather this method return an <code>Observable&lt;List&lt;UserInfo&gt;&gt;</code> for the objects that were fetched. I am not understanding how in <code>itemsInList</code> to then associate the <code>ListItem</code>s with the newly fetched <code>UserInfo</code> and return an Observable of those <code>ListItem</code>s.</p>

<p><strong>Edit</strong>: After writing this post it gave helped me realize a few things. I can flatMap wrap my calls in an Observable.create that can contain the smarts I wanted to take out of my <code>fetchUserInfoForListItems</code>, letting me address question #3. Here is the updated code:</p>

<pre><code> fun itemsInList(list : ATList, parentValue : String? = null, searchString : String? = null, limit : Int = defaultFetchLimit, sortOrder: SortDescriptor? = null) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        val listItems = listItemsInList(list, parentValue = parentValue, searchString = searchString, limit = limit, sortOrder = sortOrder)
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
        }
        return@flatMap Observable.just(listItems)
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
                fetchUserInfoForListItems(listItems, list.userIDIndex!!, force = false).map { userInfoList -&gt;
                    for (coreUserInfo in userInfoList) {
                        coreUserMap[coreUserInfo.username.toLowerCase()] = coreUserInfo
                        coreUserMap[coreUserInfo.userID] = coreUserInfo
                        coreUserInfo.externalUserID?.let { coreUserMap[it] = coreUserInfo }
                    }
                }.flatMap {
                    loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
                }.subscribe {
                    subscriber.onNext(listItems)
                    subscriber.onCompleted()
                }
            }
        }
        return@flatMap Observable.just(listItems)
    }
}

fun loadCachedUserInfo(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        listItems.forEach { listItem -&gt; listItem.coreUserInfo = coreUserMap[listItem.valueForAttributeIndex(userIDIndex)?.toLowerCase()] }
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }
}

fun fetchUserInfoForListItems(listItems : List&lt;ATListItem&gt;, userIDIndex: Int, force: Boolean) : Observable&lt;List&lt;CoreUserInfo&gt;&gt; {
    val itemsToFetch = if ( force ) listItems else listItems.filter { it.coreUserInfo == null }
    val ids = itemsToFetch.map { it.valueForAttributeIndex(userIDIndex) ?: """" }.filter { !it.isEmpty() }
    val records = hashMapOf(""records"" to ids)
    if ( itemsToFetch.count() == 0 ) { return Observable.just(ArrayList&lt;CoreUserInfo&gt;()) }
    return RuntimeDataController.dataService.fetchCoreUserInfo(recordsMap = records)
            .map { json -&gt;
                val userInfo = ArrayList&lt;CoreUserInfo&gt;()
                json.arrayValue(""records"").eachObject { userInfo.add(CoreUserInfo(it)) }
                return@map userInfo
            }
}
</code></pre>
","4586842","","4586842","","2016-02-20 17:25:44","2016-02-20 19:16:44","Using RxJava to join local data with remote ( or cached ) data","<android><rx-java><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"35612056","1","","","2016-02-24 20:10:27","","1","536","<p>I'm currently using the Android-ReactiveLocation Library (<a href=""https://github.com/mcharmas/Android-ReactiveLocation"" rel=""nofollow"">Github</a>). The <code>LastKnownLocationObservable</code> (<a href=""https://github.com/mcharmas/Android-ReactiveLocation/blob/master/android-reactive-location/src/main/java/pl/charmas/android/reactivelocation/observables/location/LastKnownLocationObservable.java"" rel=""nofollow"">Code</a>) is working as intended. I'm using a <code>flatMap</code> to fetch nearby stations from a db and (because of realm) I'm creating a model from the data. So I have a list of items and I'm creating the new Observable in <code>flatMap</code> with <code>Observable.from(data)</code>.</p>

<p>Then I want to sort the locations, filter them and group them.</p>

<pre><code>.toSortedList()
.flatMap { Observable.from(it) }
.filter { it.distance &lt;= (maxDistance.toDouble() * 1000) }
.groupBy { //Group the stations in categories
    if (it.distance &lt;= maxDistance &amp;&amp; it.favorite) {
        ""nearbyFavorite""
    } else if (it.favorite) {
        ""outOfReachFavorite""
    } else {
        ""nearby""
    }
}
</code></pre>

<p>However the onComplete is never called when I subscribe to the Observable. The Observable just stalls at <code>toSortedList()</code>.</p>

<p>The Subscribe:</p>

<pre><code>.subscribe(object: Subscriber&lt;GroupedObservable&lt;String, NearbyLocationItem&gt;&gt;() {
    override fun onNext(p0: GroupedObservable&lt;String, NearbyLocationItem&gt;?) {
        val locationItems = ArrayList&lt;NearbyLocationItem&gt;()
        p0.subscribe { loc -&gt;
            locationItems.add(loc)
        }
        locations.put(p0.key, locationItems)
    }


    override fun onCompleted() {
        Log.d(javaClass.simpleName, ""Never called"")
    }

    override fun onError(p0: Throwable?) {

    }
}
</code></pre>
","1501857","","","","","2016-02-24 20:10:27","OnComplete never called with toSortedList() and groupBy()","<android><rx-java><kotlin><rx-android><rx-kotlin>","0","9","","","","CC BY-SA 3.0"
"35818449","1","35820705","","2016-03-05 19:00:58","","4","3680","<p>I created a function which returns an <code>Observable&lt;String&gt;</code> with file names, but I don't get any event in my subscription where I call this method. Also there is no call of onError, or onComplete <br>
See my code:</p>

<pre><code>fun getAllFiles(): Observable&lt;String&gt; {

    val allFiles = File(""/Users/stephan/Projects/Playground/kotlinfiles/"")
            .listFiles { file -&gt; !file.isDirectory() }
    return observable { subscriber -&gt;
        allFiles.toObservable()
                .map { f -&gt; ""${f.name}"" }
                .doOnNext { println(""Found file $it"") }
                .subscribe { subscriber}
    }
}

fun test() {
    getAllFiles()
            .doOnNext { println(""File name$it"") }
            .subscribe(
                    {n -&gt; println(""File: $n"")},
                    {e -&gt; println(""Damn: $e"")},
                    {println(""Completed"")})
}
</code></pre>

<p>Though everything is being called in the <code>getAllFiles()</code> function, so what am I missing?</p>
","1031556","","","","","2016-03-06 00:07:43","rx kotlin subscription not working, not receiving items","<kotlin><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"35995630","1","35998109","","2016-03-14 18:48:09","","2","603","<p>I've been playing with Kotlin/RxJava and tried to create an extension method for adding a <code>Subscription</code> to a <code>CompositeSubscription</code>, that would work like:</p>

<pre><code>search.subscribe {
       //do stuff
}.addToComposite(compositeSubscription)
</code></pre>

<p>This is my attempt so far:</p>

<pre><code>fun Subscription.addToComposite(composite: CompositeSubscription) = { composite.add(this) }
</code></pre>

<p>It compiles and runs without errors but doesn't seem to actually add the <code>Subscription</code> to the <code>CompositeSubscription</code>. Am I doing something wrong?</p>
","1607552","","1363438","","2018-01-01 17:34:28","2018-01-01 17:34:28","Can I create a Kotlin extension method for adding an rxJava Subscription to a CompositeSubscription?","<rx-java><kotlin><kotlin-extension><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"36809467","1","","","2016-04-23 10:16:23","","6","1905","<p>I'm using rxAndroid and rxKotlin in my Android app to handle network requests asynchronously. Now I would like to retry a failed network request only after click on Snackbar button.</p>

<p>My code now:</p>

<pre><code>val citiesService = ApiFactory.citiesService

citiesService.cities()
    .subscribeOn(Schedulers.newThread()) // fetch List&lt;String&gt;
    .flatMap { Observable.from(it) }     // convert to sequence of String
    .flatMap { city -&gt;
        citiesService.coordinates(city)  // fetch DoubleArray
            .map { City(city, it) }      // convert to City(String, DoubleArray)
        }
    .toList()
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext {
        listView.setOnItemClickListener { adapterView, view, position, id -&gt;
            onItemClick(it[position])
        }
    }
    .map { it.map { it.getName(activity) } }
    .subscribe(
        { listAdapter = setupAdapter(it) },
        { showErrorSnackbar() }  // handle error
    )

fun showErrorSnackbar() {
        Snackbar.make(listView, getString(R.string.not_available_msg), Snackbar.LENGTH_INDEFINITE)
                .setAction(getString(R.string.snack_retry_btn), {
                    // retry observable
                })
                .show()
    }
</code></pre>

<p>Cities interface for retrofit:</p>

<pre><code>interface CitiesService {

    @GET(""api/v1/cities"")
    fun cities(): Observable&lt;List&lt;String&gt;&gt;

    @GET(""api/v1/cities/{city}/coordinates"")
    fun coordinates(@Path(""city"") city: String): Observable&lt;DoubleArray&gt;
}
</code></pre>

<p>Api factory:</p>

<pre><code>object ApiFactory {

    val citiesService: CitiesService
        get() = retrofit.create(CitiesService::class.java)

    private val retrofit: Retrofit
        get() = Retrofit
            .Builder()
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(BASE_URL)
            .build()
}
</code></pre>

<p>How can I restart the observable in such way?</p>
","4589262","","4589262","","2016-04-23 10:59:33","2017-03-28 21:47:05","RxAndroid - retry observable on click","<android><rx-java><retrofit2><rx-android><rx-kotlin>","1","3","2","","","CC BY-SA 3.0"
"37421742","1","37423378","","2016-05-24 18:57:18","","4","2827","<p>I know this breaks a lot of Rx rules, but I really like <a href=""https://github.com/davidmoten/rxjava-jdbc"" rel=""nofollow"">RxJava-JDBC</a> and so do my teammates. Relational databases are very core to what we do and so is Rx.</p>

<p>However there are some occasions where we do not want to emit as an <code>Observable&lt;ResultSet&gt;</code> but would rather just have a pull-based Java 8 <code>Stream&lt;ResultSet&gt;</code> or Kotlin <code>Sequence&lt;ResultSet&gt;</code>. But we are very accustomed to the RxJava-JDBC library which only returns an <code>Observable&lt;ResultSet&gt;</code>. </p>

<p>Therefore, I am wondering if there is a way I can turn an <code>Observable&lt;ResultSet&gt;</code> into a <code>Sequence&lt;ResultSet&gt;</code> using an extension function, and not do any intermediary collection or <code>toBlocking()</code> calls. Below is all I have so far but my head is spinning now trying to connect push and pull based systems, and I cannot buffer either as the <code>ResultSet</code> is stateful with each <code>onNext()</code> call. Is this an impossible task?</p>

<pre><code>import rx.Observable
import rx.Subscriber
import java.sql.ResultSet

fun Observable&lt;ResultSet&gt;.asSequence() = object: Iterator&lt;ResultSet&gt;, Subscriber&lt;ResultSet&gt;() {

    private var isComplete = false

    override fun onCompleted() {
        isComplete = true
    }

    override fun onError(e: Throwable?) {
        throw UnsupportedOperationException()
    }

    override fun onNext(rs: ResultSet?) {
        throw UnsupportedOperationException()
    }


    override fun hasNext(): Boolean {
        throw UnsupportedOperationException()
    }

    override fun next(): ResultSet {
        throw UnsupportedOperationException()
    }

}.asSequence()
</code></pre>
","1373258","","1373258","","2016-05-24 19:25:19","2016-05-25 05:10:26","RxJava- Turn Observable into Iterator, Stream, or Sequence","<stream><sequence><rx-java><kotlin><rx-kotlin>","2","3","2","","","CC BY-SA 3.0"
"38666086","1","38670838","","2016-07-29 19:19:01","","3","872","<p>I'm trying to port an RxJava library and leverage extension functions in Kotlin.</p>

<pre><code>fun &lt;T,R: MutableCollection&lt;T&gt;&gt; Observable&lt;T&gt;.collectWhile(factory: (() -&gt; R), condition: (R,T) -&gt; Boolean) =
        compose(Transformers.collectWhile(factory,condition))
</code></pre>

<p>The <code>Transformers.collectWhile()</code> is written in Java and has this signature: </p>

<pre><code>public static &lt;T, R extends Collection&lt;T&gt;&gt; Transformer&lt;T, R&gt; collectWhile(final Func0&lt;R&gt; factory,
            final Action2&lt;? super R, ? super T&gt; collect)
</code></pre>

<p>However, I am getting an issue with mapping the <code>collect</code> argument and I'm not good at generics. How do I express <code>super</code> with a functional type?</p>

<p><strong>UPDATE</strong></p>

<p>Stupid mistake on my part. I should not have been posting on SO late at night. </p>

<p>I was actually targeting this</p>

<pre><code>public static &lt;T, R extends Iterable&lt;?&gt;&gt; Transformer&lt;T, R&gt; collectWhile(final Func0&lt;R&gt; factory,
        final Action2&lt;? super R, ? super T&gt; collect, final Func2&lt;? super R, ? super T, Boolean&gt; condition)
</code></pre>

<p>And this is what I should have done. </p>

<pre><code>fun &lt;T,R: MutableCollection&lt;T&gt;&gt; Observable&lt;T&gt;.collectWhile(factory: (() -&gt; R), action: (R,T) -&gt; Unit, condition: (R,T) -&gt; Boolean) =
    compose(Transformers.collectWhile(factory,action,condition))
</code></pre>
","1373258","","1373258","","2016-07-30 18:02:52","2016-07-30 18:02:52","Expressing ""super"" generics in Kotlin functional types?","<java><generics><rx-java><kotlin><rx-kotlin>","1","1","1","","","CC BY-SA 3.0"
"39057409","1","39069635","","2016-08-20 18:25:27","","0","537","<p>Here's a fun RxJava problem. </p>

<p>I want to use RxJava backpressure operators to quickly lookup a typed input while each character is being typed, much like Google does on its search page. I went through the <a href=""https://github.com/ReactiveX/RxJava/wiki/Backpressure"" rel=""nofollow"">Backpressure</a> documentation and I came up with this (I am using RxJavaFX/RxKotlinFX to leverage JavaFX). </p>

<pre><code>val myControl: Node = ...
val burstyMulticast = myControl.events(KeyEvent.KEY_TYPED).publish().refCount()
val burstyDebounced = burstyMulticast.debounce(200, TimeUnit.MILLISECONDS)
val burstyBuffered = burstyMulticast.buffer(burstyDebounced)

burstyBuffered
        .flatMap { it.toObservable().map { it.character }.reduce("""") { x,y -&gt; x + y } }
        .subscribe { println(it) }
</code></pre>

<p>This works great. If I type ""Hello"" against the control it will emit the <code>String</code> ""Hello"" after 200 ms of no typing. But if I want this to truly be more responsive, I should actually have some sort of rolling accumulation for each keystroke input.  Then my console output should really look like this:</p>

<pre><code>H
He
Hel
Hell
Hello
</code></pre>

<p>Those should be all my emissions when I type the word ""Hello"", and the 200ms defines how much time should elapse before the accumulation resets. How do I do this?</p>
","1373258","","1373258","","2016-08-22 03:42:44","2016-08-22 03:42:44","RxJava - Backpressuring keyboard inputs?","<javafx><rx-java><kotlin><backpressure><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"40335952","1","","","2016-10-31 02:48:00","","8","6434","<p>I have got <code>Observable&lt;Rates&gt;</code> and Rate is just a simple object: </p>

<pre><code>Rate(val value:String){}
Rates(val rates: List&lt;Rate&gt;)
</code></pre>

<p>and i wanna change that <code>Observable&lt;Rates&gt;</code> into <code>Observable&lt;HashMap&lt;String,Long&gt;</code>. </p>

<p>so for example for rates <code>Rates(arrayOf(Rate(""1""),Rate(""2""), Rate(""3""),Rate(""3""), Rate(""2""),Rate(""2"")))</code> i expect result: </p>

<pre><code>(1 -&gt; 1)
(2 -&gt; 3)
(3 -&gt; 2)
(4 -&gt; 0)
(5 -&gt; 0)
</code></pre>

<p>I start creating something like that : </p>

<pre><code>service.getRates()
        .flatMap {it-&gt; Observable.from(it.rates) }
        .filter { !it.value.isNullOrEmpty() }
        .groupBy {it -&gt; it.value}
        .collect({ HashMap&lt;String,Long&gt;()}, { b, t -&gt; b.put(t.key, t.count???)}
</code></pre>

<p>but I am stuck here and i do not know count all values? and i do not know how to add empty values (0) if there is no 5 of 4. Is there any way to do this using rx? </p>
","1568605","","1137789","","2016-10-31 12:39:27","2016-10-31 12:39:27","How to do a groupBy and collect using RxJava and Kotlin?","<rx-java><reactive-programming><kotlin><rx-kotlin>","3","0","1","","","CC BY-SA 3.0"
"40630716","1","40661241","","2016-11-16 11:14:02","","3","1485","<p>We're trying to observe either a 15s interval, or whenever we're firing <code>onNext</code> on our subject <code>refreshEventsSubject</code>, but without success.</p>

<p>The subject is initiated like so</p>

<p><code>private val refreshEventsSubject = PublishSubject&lt;Long&gt;()</code></p>

<p>And then we try to observe it like this</p>

<p><code>Observable.merge(Observable.interval(0, 15, TimeUnit.SECONDS), refreshEventsSubject)
    .subscribe { ... }</code></p>

<p>We get the events from the interval every 15s, but the subject is not firing after running</p>

<p><code>refreshEventsSubject.onNext(0)</code></p>

<p>Any ideas appreciated.</p>

<p>(Everything is written in Kotlin)</p>
","1639409","","1639409","","2016-11-16 11:35:15","2016-11-17 17:21:24","RxJava(Kotlin), Observable.amb and PublishSubject is not firing","<android><rx-java><kotlin><rx-kotlin>","2","2","","","","CC BY-SA 3.0"
"40818410","1","40819077","","2016-11-26 12:39:42","","10","17853","<p>I have some problem. I'm a beginer in RxJava/RxKotlin/RxAndroid, and dont understand some features. For Example:</p>

<pre><code>import rus.pifpaf.client.data.catalog.models.Category
import rus.pifpaf.client.data.main.MainRepository
import rus.pifpaf.client.data.main.models.FrontDataModel
import rus.pifpaf.client.data.product.models.Product
import rx.Observable
import rx.Single
import rx.lang.kotlin.observable
import java.util.*


class MainInteractor {

    private var repository: MainRepository = MainRepository()

    fun getFrontData() {

        val cats = getCategories()
        val day = getDayProduct()
        val top = getTopProducts()

        return Observable.zip(cats, day, top, MainInteractor::convert)
    }

    private fun getTopProducts(): Observable&lt;List&lt;Product&gt;&gt; {
        return repository.getTop()
                .toObservable()
                .onErrorReturn{throwable -&gt; ArrayList() }

    }

    private fun getDayProduct(): Observable&lt;Product&gt; {
        return repository.getSingleProduct()
                .toObservable()
                .onErrorReturn{throwable -&gt; Product()}

    }

    private fun getCategories(): Observable&lt;List&lt;Category&gt;&gt; {
        return repository.getCategories()
                .toObservable()
                .onErrorReturn{throwable -&gt; ArrayList() }
    }

    private fun convert(cats: List&lt;Category&gt;, product: Product, top: List&lt;Product&gt;): FrontDataModel {

    }
}
</code></pre>

<p>Then I'm use <strong>MainInteractor::convert</strong> Android studio tell me next</p>

<p><a href=""https://i.stack.imgur.com/Caoua.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Caoua.jpg"" alt=""enter image description here""></a></p>

<p>I tried a lot of variant and tried to understand what does it want, but no success. Help me please... Best Regards.</p>
","3775934","","3775934","","2019-10-08 10:54:03","2021-01-27 21:18:18","How to zip few observables in Kotlin language with RxAndroid","<android><rx-java><kotlin><rx-android><rx-kotlin>","3","0","1","","","CC BY-SA 4.0"
"41223466","1","41608056","","2016-12-19 13:17:20","","2","1370","<p>RuntimeExceptions are supposed to indicate programming error and I want my application to crash when something inside my observables throws RuntimeException. </p>

<p>What is the best way to do this? Right now I'm considering this solution (it's Kotlin, but I hope it's understandable)</p>

<pre><code>fun &lt;T&gt; Observable&lt;T&gt;.subscribeCrashOnRuntimeException(onNext: (T) -&gt; Unit, onError: (Throwable) -&gt; Unit) {
  this.subscribe({
    onNext(it)
  }, { e -&gt;
    if (e is RuntimeException) {
      throw e
    } else {
      onError(e)
    }
  })
}

fun usageExample() {
  val observable = Observable.just(1)
  observable.subscribeCrashOnRuntimeExceptions(
    { next -&gt; Log.d(""TAG"", ""next: $next"") },
    { e -&gt; Log.d(""TAG"", ""error: $e"") }
  )
}
</code></pre>

<p>But I have doubts about it. For example it is hard to occasionally ""catch"" specific RuntimeExceptions with this solution. Perhaps there is a well known way to deal with situation that I just don't know how to google?</p>
","544406","","697313","","2017-01-12 11:27:52","2017-01-12 11:51:51","RuntimeException handling best practices","<android><rx-java><rx-kotlin>","1","3","1","","","CC BY-SA 3.0"
"41987704","1","41990290","","2017-02-01 19:08:56","","1","306","<p>I thought this is how it works, seems like I'm missing something..</p>

<pre><code>@Test
fun singleCompletes()
{
    val testSubscriber = TestSubscriber&lt;Boolean&gt;()

    Single.just(true)
            .subscribeOn(Schedulers.immediate())
            .subscribe { testSubscriber }

    testSubscriber.assertNoErrors()
    testSubscriber.assertValue(true)
}
</code></pre>

<blockquote>
  <p>java.lang.AssertionError: Number of items does not match. Provided: 1  Actual: 0.</p>
</blockquote>
","2192545","","","","","2017-02-01 21:40:45","RxKotlin - Single.just() does not emit when subscribing TestSubscriber","<kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"42066066","1","42126960","","2017-02-06 10:55:51","","83","26677","<p>Why would I want to use Kotlin's coroutines?</p>
<p>It seems that the RxKotlin library is much more versatile.
Kotlin's coroutines look significantly less powerful and more cumbersome to use in comparison.</p>
<p>I base my opinion on coroutines on <a href=""https://www.youtube.com/watch?v=4W3ruTWUhpw"" rel=""noreferrer"">this design talk by Andrey Breslav (JetBrains)</a></p>
<p>Slideshow from the talk is <a href=""https://www.slideshare.net/abreslav/jvmls-2016-coroutines-in-kotlin"" rel=""noreferrer"">accessible here.</a></p>
<hr />
<p>EDIT (thanks to @hotkey):</p>
<p>Better source on the current state of coroutines <a href=""https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md"" rel=""noreferrer"">here.</a></p>
","3160531","","13363205","","2020-07-26 21:55:18","2021-01-10 10:39:13","How Kotlin coroutines are better than RxKotlin?","<kotlin><rx-kotlin>","5","0","40","","","CC BY-SA 4.0"
"42727899","1","","","2017-03-10 21:20:29","","-1","1445","<p>So I have an observable with a debounce of 300ms.<br>
It does an API-call after a key-up event.</p>

<p>There's an API-lock in place to prevent future calls until it is completed, but I would also like to check if the observable is running (that's making the API call) and stop it.</p>

<p>How would this be accomplished?</p>
","2368378","","2368378","","2017-03-10 21:40:53","2017-03-10 21:40:53","How do I check if an observable is running and stop it?","<android><thread-safety><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"42772319","1","42774592","","2017-03-13 19:55:38","","0","87","<p>I'm trying to write an Android app with Kotlin. Now, I want to show a counter in the ActionBar. I added an item called show_timer for that. Each second, it should count up by one:</p>

<pre><code>override fun onWindowFocusChanged(hasFocus: Boolean) {
    val item = findViewById(R.id.show_timer) as ActionMenuItemView
    PublishSubject.interval(1, java.util.concurrent.TimeUnit.SECONDS, Schedulers.newThread())
            .subscribeBy(onNext = {item.text = it.toString()})

    super.onWindowFocusChanged(hasFocus)
}
</code></pre>

<p>But somehow this doesn't work. It updates the default text to 0, but after that it does nothing. Does someone know why this doesn't work?</p>

<p>Thank you in advance,</p>

<p>Niklas</p>
","7544860","","","","","2017-03-13 22:30:09","Can't Change Text of ActionMenuItemView with RxKotlin","<android><system.reactive><kotlin><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"42927824","1","","","2017-03-21 12:56:54","","0","208","<p>is it possible to send the same object to subscribers in Rx repeatedly? 
For exmaple this code(on Kotlin): </p>

<pre><code> val exmp = listOf(""–ê"")
        var observable = exmp.toObservable()
            observable.subscribeBy(
                    onNext = {
                        it + ""1""
                        println(it)
                    },
                    onError = { it.printStackTrace() },
                    onComplete = { println(""Done!"") }
            )
</code></pre>

<p>I try to send string value ""A"" repeatedly to method onNext() and get ""A111111"". 
Method replay() of Rx library as I understand starting sending date again for new subsribers. In circle <code>for</code> date from observable not changing, just  method is called several times</p>
","7745622","","","","","2017-03-21 14:45:36","Repeat sending object to subsriber on Rx","<rx-java><reactive-programming><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"43285064","1","43320828","","2017-04-07 18:40:43","","20","8721","<p>I'm trying to test the following RxKotlin/RxJava 2 code:</p>

<pre class=""lang-java prettyprint-override""><code>validate(data)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .flatMap { ... }
</code></pre>

<p>I'm attempting to override the schedulers as follows:</p>

<pre class=""lang-java prettyprint-override""><code>// Runs before each test suite
RxJavaPlugins.setInitIoSchedulerHandler { Schedulers.trampoline() }
RxAndroidPlugins.setInitMainThreadSchedulerHandler { Schedulers.trampoline() }
</code></pre>

<p>However, I get the following error when running the test:</p>

<pre class=""lang-java prettyprint-override""><code>java.lang.ExceptionInInitializerError
...
Caused by: java.lang.NullPointerException: Scheduler Callable result can't be null
    at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39)
    at io.reactivex.plugins.RxJavaPlugins.applyRequireNonNull(RxJavaPlugins.java:1317)
    at io.reactivex.plugins.RxJavaPlugins.initIoScheduler(RxJavaPlugins.java:306)
    at io.reactivex.schedulers.Schedulers.&lt;clinit&gt;(Schedulers.java:84)
</code></pre>

<p>Has anyone experienced this problem? </p>

<hr>

<p>The test worked fine when using RxKotlin/RxJava 1 and the following scheduler overrides:</p>

<pre class=""lang-java prettyprint-override""><code>RxAndroidPlugins.getInstance().registerSchedulersHook(object : RxAndroidSchedulersHook() {
    override fun getMainThreadScheduler() = Schedulers.immediate()
})

RxJavaPlugins.getInstance().registerSchedulersHook(object : RxJavaSchedulersHook() {
    override fun getIOScheduler() = Schedulers.immediate()
})
</code></pre>
","1261256","","1000551","","2019-11-06 10:06:31","2019-11-26 17:20:37","RxJava 2 overriding IO scheduler in unit test","<kotlin><rx-java><rx-kotlin>","4","4","7","","","CC BY-SA 4.0"
"43564621","1","","","2017-04-22 21:06:33","","7","4603","<p>I'm trying to observe observable on main thread by using:</p>

<pre><code>    // Kotlin Code
    Observable
      .observeOn(AndroidSchedulers.mainThread())
</code></pre>

<p>but I'm getting following error:</p>

<pre><code>    Type Mismatch:
      Required: rx.Scheduler!
      Found: io.reactivex.Scheduler!
</code></pre>

<p>The Observable I'm subscribing to is from a Library that is written in Java and therefore uses RxJava.</p>

<p>Am i being stupid and missing something? I'm puzzeled :$</p>

<p>Thanks in advance :)</p>
","6411538","","","","","2021-02-19 01:10:08","Cant 'observeOn' main thread with RxKotlin","<android><kotlin><rx-java2><rx-kotlin><kotlin-interop>","4","2","2","","","CC BY-SA 3.0"
"43681939","1","","","2017-04-28 13:54:04","","4","1711","<p>In a JavaFX Gradle-based application that I develop using RxJava and Kotlin in IntelliJ IDEA 2017.1.2 (Build #IC-171.4249.39), I'm getting an exception:</p>

<blockquote>
  <p>Exception in thread ""JavaFX Application Thread"" java.lang.NoClassDefFoundError: org/reactivestreams/Publisher</p>
</blockquote>

<p>everytime a code like this</p>

<pre><code>return Completable.complete()
</code></pre>

<p>is executed. Following a suggestion of a similar question <a href=""https://stackoverflow.com/questions/43231477/why-i-am-getting-noclassdeffounderror-org-reactivestreams-publisher"">Why I am getting NoClassDefFoundError: org/reactivestreams/Publisher</a>, I've tried to add include the reactive-streams to the <code>dependencies</code> block of my <code>build.gradle</code> script</p>

<pre><code>dependencies {
    compile 'org.jetbrains.kotlin:kotlin-stdlib:1.1.2'
    compile 'org.reactivestreams:reactive-streams:1.0.0'
    compile 'io.reactivex.rxjava2:rxkotlin:2.0.0'
}
</code></pre>

<p>but the problem persists. The dependency tree looks like this one:</p>

<pre><code>compile - Dependencies for source set 'main' (deprecated, use 'implementation ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

compileClasspath - Compile classpath for source set 'main'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

\--- org.jetbrains.kotlin:kotlin-annotation-processing:1.1.2
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
          \--- org.jetbrains:annotations:13.0

kaptTest
\--- org.jetbrains.kotlin:kotlin-annotation-processing:1.1.2
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
          \--- org.jetbrains:annotations:13.0

runtime - Runtime dependencies for source set 'main' (deprecated, use 'runtimeOnly ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

runtimeClasspath - Runtime classpath of source set 'main'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testCompile - Dependencies for source set 'test' (deprecated, use 'testImplementation ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testCompileClasspath - Compile classpath for source set 'test'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testRuntime - Runtime dependencies for source set 'test' (deprecated, use 'testRuntimeOnly ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testRuntimeClasspath - Runtime classpath of source set 'test'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)
</code></pre>

<p>As you can see, <strong>org.reactivestreams:reactive-streams</strong> is present in each environment. </p>

<p>Now, I've managed to resolve the problem by adding manually dependency on a <a href=""https://jar-download.com/?detail_search=g%3A%22io.reactivex.rxjava2%22&amp;g=io.reactivex.rxjava2"" rel=""nofollow noreferrer"">reactive-streams-1.0.0.jar</a>, but I don't like this solution at all. </p>

<p>Could somebody advice a better solution? Thanks!</p>
","2114895","","-1","","2017-05-23 10:31:25","2017-05-08 14:58:51","Exception caused by: java.lang.ClassNotFoundException: org.reactivestreams.Publisher","<intellij-idea><gradle><kotlin><rx-java2><rx-kotlin>","0","1","1","","","CC BY-SA 3.0"
"43771854","1","43774178","","2017-05-04 00:00:00","","3","868","<p>I am trying to get a better understanding of how to do unit tests with Rx-Kotlin, but I have not been able to successfully set the subject to ""completed"". As a result, I am always waiting for the timeout of 5 seconds (the onComplete should be immediate) and then fail on assertComplete.</p>

<p>My understanding of <a href=""http://reactivex.io/RxJava/javadoc/rx/observers/TestSubscriber.html#awaitTerminalEvent()"" rel=""nofollow noreferrer"">awaitTerminalEvent</a> is that it should only block until the onComplete is called. I have also looked into <a href=""http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html"" rel=""nofollow noreferrer"">TestScheduler,</a> but I do not believe that it should be required here. </p>

<p>Any help or documentation that can lead me in the right direction would be much appreciated.</p>

<pre><code>@Test
fun testObservable() {
    val subject = BehaviorSubject.create&lt;Int&gt;()
    subject.onNext(0)

    TestSubscriber&lt;Int&gt;().apply {
        subject.subscribe({
            System.out.println(it)
            subject.onNext(1)
            subject.onComplete()
        })

        this.awaitTerminalEvent(5, TimeUnit.SECONDS)
        this.assertComplete()
        this.assertValue(1)
    }
}
</code></pre>
","2461717","","3903847","","2017-05-04 04:57:25","2017-05-04 04:57:25","Rx-Kotlin awaitTerminalEvent never getting onComplete","<unit-testing><testing><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"43807056","1","43807850","","2017-05-05 14:04:38","","9","6017","<p>In an app that connects to bluetooth devices, I am using the following function using RxKotlin:</p>

<pre><code>private fun startBluetoothPair(device: BluetoothDevice) {
    Observable.just(device)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .map {
            var uuid: UUID = BLUETOOTH_UUID
            var socket = it.createRfcommSocketToServiceRecord(uuid)
            socket.connect()
            return socket
        }
        .subscribe {
            // Do something with the BluetoothSocket
        }
}
</code></pre>

<p>This function should simply connect with the bluetoothdevice on the background and then do something with the socket (in the mainthread again). However, the <code>map</code> can't handle the <code>return socket</code> part, telling me there is a <code>Type mismatch</code>, it found a <code>BluetoothSocket</code> where it required a <code>Unit</code>.</p>

<p>What is going wrong here? I thought a map should be able to infer the return type.</p>
","1506976","","","","","2021-02-03 06:40:33","Rx Kotlin: map function can't infer return type","<android><reactivex><rx-kotlin>","2","3","2","","","CC BY-SA 3.0"
"43821571","1","43822648","","2017-05-06 14:22:47","","3","1340","<p>I have a Observables which emits some numbers and I simply want to take last N elements. </p>

<p>I have following code (I'm using RxKotlin which is simply a wrapper on RxJava):</p>

<pre><code>val list = listOf(1,2,3,4,5,6,7,8,9,10)
Observable.fromIterable(list)
          .buffer(3, 1)
          .lastOrError()
          .subscribe{value -&gt; println(value)}
</code></pre>

<p>Unfortunately the result is <code>[10]</code>, as I looked closer what the buffer operator returns, I saw this:</p>

<pre><code>[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
[9, 10]
[10] 
</code></pre>

<p>is there a way to get last ""full"" buffer -> <code>[8, 9, 10]</code> ?</p>
","2794332","","2794332","","2017-05-06 14:28:01","2017-05-06 16:13:01","Get N last objects emitted by observable in RxJava2","<java><kotlin><reactive-programming><rx-java2><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"43945068","1","","","2017-05-12 19:22:03","","1","1290","<p>(Working in RxKotlin and RxJava, but using metacode for simplicity)</p>

<p>Many <code>Reactive Extensions</code> guides begin by creating an <code>Observable</code> from already available data.  From <a href=""https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"" rel=""nofollow noreferrer"">The introduction to Reactive Programming you've been missing</a>, it's created from a single string</p>

<pre><code>var soureStream= Rx.Observable.just('https://api.github.com/users');
</code></pre>

<p>Similarly, from the frontpage of <a href=""https://github.com/ReactiveX/RxKotlin"" rel=""nofollow noreferrer"">RxKotlin</a>, from a populated list</p>

<pre><code>val list = listOf(1,2,3,4,5)
list.toObservable()     
</code></pre>

<p>Now consider a simple filter that yields an <code>outStream</code>,  </p>

<pre><code>var outStream = sourceStream.filter({x &gt; 3})
</code></pre>

<p>In both guides the source events are declared <em>apriori</em>.  Which means the timeline of events has some form</p>

<pre><code>source: ----1,2,3,4,5-------
out:    --------------4,5---
</code></pre>

<p>How can I modify <code>sourceStream</code> to become more of a pipeline?  In other words, no input data is available during <code>sourceStream</code> creation?  When a source event becomes available, it is immediately processed by out:</p>

<pre><code>source: ---1--2--3-4---5-------
out:    ------------4---5-------
</code></pre>

<p>I expected to find an <code>Observable.add()</code> for dynamic updates</p>

<pre><code>var sourceStream = Observable.empty()
var outStream = sourceStream.filter({x&gt;3})

//print each element as its added 
sourceStream .subscribe({println(it)})
outStream.subscribe({println(it)})

for i in range(5):
    sourceStream.add(i)
</code></pre>

<p>Is this possible?</p>
","4076764","","4076764","","2017-05-12 19:30:10","2017-05-14 01:48:58","How to dynamically update an RX Observable?","<java><rx-java><reactive-programming><rx-kotlin>","1","9","","","","CC BY-SA 3.0"
"43945102","1","43945802","","2017-05-12 19:25:06","","2","2464","<p>I'm kind of new to Kotlin and I'm trying to Inject a value (in this example it is just an Int but in the real code it is a Provider class)
What am I doing wrong here? and why is x is an unresolved reference?</p>

<pre><code>class Test
@Inject constructor(private val x: Int) {

companion object {
    var y: Int = 0

        @BeforeClass @JvmStatic
        fun beforeClass() {
            y = x * 2
        }
    }
}
</code></pre>
","2811244","","1502352","","2017-05-12 20:19:48","2017-05-12 20:19:48","Inject constructor and companion object","<java><junit><kotlin><guice><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44211577","1","44211963","","2017-05-26 23:57:14","","1","96","<p>In Kotlin the final statement of a function can be interpreted as its return value.</p>

<p>Can a situation like the following example be simplified to be less verbose?</p>

<pre><code>{ text: String -&gt;
  val validated = validateText(text)
  if (validated) {
    actOnValidation()
  }
  validated
}
</code></pre>

<p>A concrete case where I would like to do this is below in an example using RxJava - even if there's a better Rx approach I'm also interested in a pure Kotlin solution if it exists.</p>

<pre><code>fun inputChainObservable(targetField: TextView, chainedField: TextView): Observable&lt;Boolean&gt; {
  return targetField.textChanges()
      .observeOn(AndroidSchedulers.mainThread())
      .map { cs: CharSequence? -&gt;
        val hasInput = validateText(cs.toString())
        if (hasInput) {
          chainedField.requestFocus()
        }
        hasInput
      }
}
</code></pre>
","2087534","","","","","2017-05-27 01:12:32","For a Kotlin function used as an expression, is there concise way to operate on and return a value?","<android><rx-java><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44245780","1","44246048","","2017-05-29 15:15:43","","1","575","<p>I'm converting some Java code to Kotlin and I'm having some trouble with <code>flattenAsObservable()</code></p>

<p>Here's what the code looked like in Java:</p>

<pre><code>discogsInteractor.search(query)
    .map(RootSearchResponse::getSearchResults)
    .flattenAsObservable(searchResults -&gt; searchResults)
    .take(12)
</code></pre>

<p>Here's what I have so far in Kotlin:</p>

<pre><code>discogsInteractor.search(query)
    .map { RootSearchResponse::searchResults }
    .flattenAsObservable&lt;SearchResult&gt; { searchResults -&gt; searchResults }
    .take(12)
</code></pre>

<p>It underlines the second <code>searchResults</code> and gives me the following error:</p>

<pre><code>Required: (Mutable)Iterable&lt;SearchResult!&gt;!
Found: KProperty1&lt;RootSearchResponse, List&lt;SearchResult&gt;&gt;!
</code></pre>

<p>I can replace </p>

<pre><code>.map { RootSearchResponse::searchResults }
</code></pre>

<p>with </p>

<pre><code>.map { searchResponse -&gt; searchResponse.searchResults }
</code></pre>

<p>and it will work. How do I correctly method reference? Or what's the reason that I can't in this instance?</p>

<p><strong>RootSearchResponse:</strong></p>

<pre><code>data class RootSearchResponse(val pagination: Pagination,
                              @SerializedName(""results"") val searchResults: List&lt;SearchResult&gt;)
</code></pre>
","4624156","","","","","2017-05-29 15:31:18","RxKotlin flattenAsObservable(): type mismatch with method reference","<kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44274144","1","","","2017-05-31 01:10:15","","1","99","<p>This is in Kotlin, but I think anyone who writes Java will be able to understand.</p>

<p>I'm trying to make a stopwatch with Rx and I'm having a little trouble with doing the actual stopping and starting. The big problem is that I don't know how to keep the current time, while modifying it as different actions (starting and stopping) come in. Here's what I've got right now.</p>

<pre><code>fullTime.switchMap { startTime -&gt;
    controlCommands.switchMap { command -&gt;
        when (command) {
            ControlState.PLAY -&gt; Observable.interval(1L, TimeUnit.SECONDS).map {
                ControlState.PLAY
            }
            ControlState.PAUSE -&gt; Observable.just(ControlState.PAUSE)
            else -&gt; Observable.just(ControlState.STOP)
        }
    }
}
</code></pre>

<p>Where <code>fullTime</code> and <code>controlCommands</code> are <code>Observable</code>s that emit events about the current starting time to count down from and say what to do next, respectively. I want to chain off of <code>controlCommands</code> and be able to keep state starting at <code>startTime</code> that will count down when a <code>PLAY</code> event appears, pause when <code>PAUSE</code> appears, and reset at <code>startTime</code> when <code>STOP</code> appears.</p>

<p><code>scan</code> almost works, but I don't know how to stop after the timer hits 0 and <code>PLAY</code> is still being sent every second, since it would be sending duplicate info. Also it doesn't allow a separation between the state and the observed value. So the value I accumulate with <code>scan</code> has to be the same type as the value inside the <code>Observable</code> (if that makes sense).</p>

<p>Any ideas what I should do?</p>
","1828448","","","","","2017-05-31 05:43:43","Repeating actions on state with RxJava","<java><rx-java><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44525885","1","44525981","","2017-06-13 15:34:49","","6","924","<p>I've been working through the examples in the book <a href=""https://www.amazon.co.uk/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1497368108&amp;sr=1-1&amp;keywords=reactive%20programming%20with%20rxjava"" rel=""noreferrer"">Reactive Programming with RxJava</a>, which is targeted at version 1 not 2. An introduction to infinite streams has the following example (and notes there are better ways to deal with the concurrency):</p>

<pre><code>Observable&lt;BigInteger&gt; naturalNumbers = Observable.create(subscriber -&gt; {
    Runnabler = () -&gt; {
        BigInteger i = ZERO;
        while (!subscriber.isUnsubscribed()) {
            subscriber.onNext(i);
            i = i.add(ONE);
        }
    };
    new Thread(r).start();
});

...

Subscription subscription = naturalNumbers.subscribe(x -&gt; log(x));
/* after some time... */
subscription.unsubscribe();
</code></pre>

<p>However, in RxJava 2, the lambda expression passed to the <code>create()</code> method is of type <code>ObservableEmitter</code> and this doesn't have an <code>isUnsubscribed()</code> method. I've had a look in <a href=""https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0"" rel=""noreferrer"">What's Different in 2.0</a> and also performed a search of the repository but can't find any such method.</p>

<p>How would this same functionality be achieved in 2.0?</p>

<p><strong>Edited to include solution as given below (n.b. using kotlin):</strong></p>

<pre><code>val naturalNumbers = Observable.create&lt;BigInteger&gt; { emitter -&gt;
    Thread({
        var int: BigInteger = BigInteger.ZERO
        while (!emitter.isDisposed) {
            emitter.onNext(int)
            int = int.add(BigInteger.ONE)
        }
    }).start()
}

val first = naturalNumbers.subscribe { log(""First: $it"") }
val second = naturalNumbers.subscribe { log(""Second: $it"") }

Thread.sleep(5)
first.dispose()
Thread.sleep(5)
second.dispose()
</code></pre>
","8086746","","8086746","","2017-06-13 17:11:05","2017-06-13 17:11:05","RxJava 2 equivalent to isUnsubscribed","<rx-java><rx-java2><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"44578211","1","44587447","","2017-06-15 22:54:48","","3","1578","<p>The following code is my attempt to convert an RxJava example into Kotlin. It's supposed to collect a bunch of <code>Int</code>'s into a <code>MutableList</code>, but I get a host of errors.</p>

<pre><code>val all: Single&lt;MutableList&lt;Int&gt;&gt; = Observable
        .range(10, 20)
        .collectInto(::MutableList, MutableList::add)
</code></pre>

<p>The errors:</p>

<pre><code>    Error:(113, 36) Kotlin: Type inference failed: Not enough information to infer parameter T in inline fun &lt;T&gt; MutableList(size: Int, init: (index: Int) -&gt; T): MutableList&lt;T&gt;
Please specify it explicitly.

Error:(113, 49) Kotlin: One type argument expected for interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; defined in kotlin.collections

    Error:(113, 67) Kotlin: None of the following functions can be called with the arguments supplied: 
public abstract fun add(element: Int): Boolean defined in kotlin.collections.MutableList
public abstract fun add(index: Int, element: Int): Unit defined in kotlin.collections.MutableList
</code></pre>

<p>If I change <code>ImmutableList::add</code> to <code>ImmutableList&lt;Int&gt;::add</code>, I get rid of the type argument expected error, which is replaced with:</p>

<pre><code>Error:(113, 22) Kotlin: Type inference failed: fun &lt;U : Any!&gt; collectInto(initialValue: U!, collector: ((U!, Int!) -&gt; Unit)!): Single&lt;U!&gt;!
        cannot be applied to
        (&lt;unknown&gt;,&lt;unknown&gt;)
</code></pre>

<p>This is a straight copy of the following in Java:</p>

<pre><code>Observable&lt;List&lt;Integer&gt;&gt; all = Observable
    .range(10, 20)
    .collect(ArrayList::new, List::add);
</code></pre>

<p>I understand that the first error is telling me it's either inferring the incorrect type and I need to be more explicit (where?), but I thought that <code>::MutableList</code> would be the equivalent of <code>() -&gt; MutableList&lt;Int&gt;</code>. The third error is telling me that it can't call any of the <code>add()</code> methods with the arguments, but again, I thought that <code>MutableList::add</code> is equivalent to <code>{ list, value -&gt; list.add(value) }</code>. The fourth error tells me it can't figure out the types being applied to the <code>collector</code>.</p>

<p>If I use a lambda expression instead, there are no errors:</p>

<pre><code>val all: Single&lt;MutableList&lt;Int&gt;&gt; = Observable
        .range(10, 20)
        .collectInto(mutableListOf(), { list, value -&gt; list.add(value) })

all.subscribe { x -&gt; println(x) }
</code></pre>

<p>I'd appreciate some comments on what I'm doing wrong with the method references, as there's clearly something I've misunderstood (looking through the <a href=""https://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11"" rel=""nofollow noreferrer"">Kotlin Language Reference</a>, I'm wondering if it's even a language feature at this time?). Much appreciated.</p>
","8086746","","8086746","","2017-06-16 06:34:29","2017-06-16 10:51:46","RxKotlin collectInto() MutableList using method references","<kotlin><method-reference><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"44617459","1","44637593","","2017-06-18 17:03:12","","1","472","<p>I'm trying to wrap my head around how to implement something in RxJava (2.0). It's for Android and I'm using Kotlin, although the choice of platform and language shouldn't matter here.</p>

<p>The idea is that I'd base some sort of MVP architecture on RxJava. In this implementation I'm thinking about an <code>Activity</code> (could be a <code>Fragment</code> or a custom <code>View</code> as well) exposes a stream of values (<code>Boolean</code>s for simplicity) which indicate lifecycle events, or whether the view is attached or detached.</p>

<p>The underlying idea is basically this:</p>

<pre><code>private val lifecycleEvents = PublishSubject.create&lt;Boolean&gt;()
val screenStates: Observable&lt;Boolean&gt; = lifecycleEvents.hide()

override fun onResume() {
    super.onResume()
    lifecycleEvents.onNext(true) // I'm attached!
}

override fun onPause() {
    lifecycleEvents.onNext(false) // I'm detached!
    super.onPause()
}

override fun onDestroy() {
    lifecycleEvents.onComplete() // I'm gone        
    super.onDestroy()
}
</code></pre>

<p>And then from the other end, the Presenter exposes an <code>Observable</code> that is a stream of objects representing screen states - to be rendered by the View. </p>

<p>(This follows the concept explained in this series <a href=""http://hannesdorfmann.com/android/mosby3-mvi-1"" rel=""nofollow noreferrer"">http://hannesdorfmann.com/android/mosby3-mvi-1</a> - which boils down to the fact that the Presenter feeds the View with standalone objects encapsulating screen states in their entirety rather than multiple different methods on the View). </p>

<p>And then I'd like to bind these two observable streams so that:</p>

<ul>
<li><p>Whenever the View gets detached, input from the Presenter is disregarded (and it's not buffered, so as not to run into any backpressure problems)</p></li>
<li><p>However, once the View gets reattached, it picks up the <em>latest</em> state the Presenter emmitted. In other words, only one state instance is to be buffered at most.</p></li>
</ul>

<p>It would work as follows (assuming the states are of <code>String</code> type for simplicity):</p>

<pre><code>val merged: Observable&lt;String&gt; = ???

val attached = true
val disattached = false        

screenStates.onNext(attached)
fromPresenter.onNext(""state A"")
fromPresenter.onNext(""state B"")

screenStates.onNext(disattached)
fromPresenter.onNext(""state C"") // this won't survive at the end
fromPresenter.onNext(""state D"") // this will ""override"" the previous one.
// as that's the last state from BEFORE the screen is reattached

screenStates.onNext(attached)
// ""state D"" should be replayed at this point, ""state C"" is skipped and lost

fromPresenter.onNext(""state E"")

// what ""merged"" is supposed to have received at this point:
// ""state A"", ""state B"", ""state D"", ""state E""
</code></pre>

<p>I'm not sure what the best, idiomatic solution is. </p>

<p>I tried to implement it as an <code>ObservableTransformer</code>, but I couldn't quite get it right. I believe the transformer should be stateless, whereas my solution gravitated towards explicitly keeping track of what was emmitted and buffering the last element ""manually"" etc., which feels messy and too imperative, so I suppose it's wrong. </p>

<p>I found <a href=""https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableValve.java"" rel=""nofollow noreferrer"">https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableValve.java</a>, but the implementation looks very complex and I can't believe it couldn't be done in a simpler manner (I don't need all the flexibility, I only want something that works for the described usecase).</p>

<p>Any insights would be appreciated, including whether there's something else I should take into consideration still, within the context of Android. Also note that I don't use RxKotlin bindings (I may, I just didn't suppose they should be required here).</p>

<p><strong>EDIT:</strong></p>

<p>Below is my current implementation. As I said, I'm not too happy about it because it's explicitly stateful, and I believe this should be achieved declaratively, leveraging some constructs of RxJava.</p>

<p>I needed to merge two streams of different types, and because <code>combineLatest</code> nor <code>zip</code> didn't quite do it, I resorted to a trick, creating a common wrapper for both distinct type of events. It introduces certain overhead again.</p>

<pre><code>sealed class Event
class StateEvent(val state: String): Event()
class LifecycleEvent(val attached: Boolean): Event()

class ValveTransformer(val valve: Observable&lt;Boolean&gt;) : ObservableTransformer&lt;String, String&gt; {
    var lastStateEvent: Event? = null
    var lastLifecycleEvent = LifecycleEvent(false)

    private fun buffer(event: StateEvent) {
        lastStateEvent = event
    }

    private fun buffer(event: LifecycleEvent) {
        lastLifecycleEvent = event
    }

    private fun popLastState(): String {
        val bufferedState = (lastStateEvent as StateEvent).state
        lastStateEvent = null
        return bufferedState
    }

    override fun apply(upstream: Observable&lt;String&gt;): ObservableSource&lt;String&gt; = Observable
            .merge(
                    upstream.map(::StateEvent).doOnNext { buffer(it) }, 
                    valve.distinctUntilChanged().map(::LifecycleEvent).doOnNext { buffer (it) })
            .switchMap { when {
                it is LifecycleEvent &amp;&amp; it.attached &amp;&amp; lastStateEvent != null -&gt;
                    // the screen is attached now, pump the pending state out of the buffer
                    just(popLastState())
                it is StateEvent &amp;&amp; lastLifecycleEvent.attached -&gt; just(it.state)
                else -&gt; empty&lt;String&gt;()
            } }
}
</code></pre>
","168719","","168719","","2017-06-18 20:35:30","2017-07-01 18:25:29","Implementation of a ""valve"" for Observable streams, including buffering the last element emmitted before the valve reopened","<android><rx-java><observable><reactive-programming><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"44627173","1","","","2017-06-19 09:44:48","","2","1264","<p>Is there a better / more idiomatic way to use a <code>Maybe</code> type from JavaRx 2 than <code>flatMap</code> and <code>try/catch</code>? The following example takes a <code>Maybe&lt;User&gt;</code> and tries to book them a random ticket for a flight. If the user doesn't exist, return an empty <code>Observable</code>.</p>

<pre><code>fun bookRandomTicketFor(userId: UUID): Observable&lt;Ticket&gt; {
    val agencies = travelAgents() // Observable&lt;TravelAgency&gt;
    val user = findById(userId) // Maybe&lt;User&gt;
    val location = locate() // Observable&lt;GeoLocation&gt;

    return Observable
            .just(user.toObservable())
            .flatMap { usr -&gt;
                try {
                    usr.zipWith(location, { aUser, location -&gt;
                        agencies
                                .flatMap { agency -&gt;
                                    agency
                                            .search(aUser, location) // Observable&lt;Flight&gt;.
                                            .toList() // Convert to List&lt;Flight&gt;.
                                            .toObservable() // And to Observable&lt;List&lt;Flight&gt;&gt;.
                                            .flatMap { flights -&gt; // So it can be shuffled,
                                                Observable.just( // giving a random order.
                                                        shuffle(flights as MutableList&lt;Flight&gt;)[0]
                                                )
                                            }
                                }.firstElement() // Now take the first randomly shuffled Flight.
                    }).flatMap { flight -&gt;
                        book(user.toObservable(), flight.toObservable())
                    }
                } catch (ex: Exception) {
                    Observable.empty&lt;Ticket&gt;()
                }
            }
            .doOnSubscribe { Logger.log(""Random ticket: start for $userId"") }
            .doOnComplete { Logger.log(""Random ticket: exit for $userId"") }
}
</code></pre>

<p>It seems a bit of a fudge to have to convert the <code>Maybe&lt;User&gt;</code> to an <code>Observable</code> and start with an <code>Observable&lt;Observable&lt;User&gt;&gt;</code> that I can then <code>flatMap</code> and <code>try/catch</code>. Just wondering if there is a neater approach to doing this?</p>
","8086746","","3385212","","2017-06-27 14:01:37","2017-06-27 14:01:37","RxJava2 Maybe return empty Observable if no element","<kotlin><rx-java2><rx-kotlin>","0","1","","","","CC BY-SA 3.0"
"44640465","1","44640799","","2017-06-19 21:44:56","","3","734","<p>I'm trying to get an example working that uses two different timeout values. An initial larger value for the first emission and then shorter values for all subsequent emissions. The example is converted to Kotlin from Java for RxJava v1x, although I am attempting this is v2x (not sure if that makes any difference). </p>

<p>The problem is that the timeout for the first event doesn't throw a <code>TimeoutException</code>. With the value set below 500ms, I'm expecting a stack trace to be printed, but I get output as if no timeout has occurred (subsequent emissions with timeout set to 40ms results in stack trace as expected). What is wrong with the following example that prevents the initial timeout from succeeding?</p>

<pre><code>fun nextSolarEclipse(after: LocalDate): Observable&lt;LocalDate&gt; {
    return Observable
            .just(
                    LocalDate.of(2016, Month.MARCH, 9),
                    LocalDate.of(2016, Month.SEPTEMBER, 1),
                    LocalDate.of(2017, Month.FEBRUARY, 26),
                    LocalDate.of(2017, Month.AUGUST, 21),
                    LocalDate.of(2018, Month.FEBRUARY, 15),
                    LocalDate.of(2018, Month.JULY, 13),
                    LocalDate.of(2018, Month.AUGUST, 11),
                    LocalDate.of(2019, Month.JANUARY, 6),
                    LocalDate.of(2019, Month.JULY, 2),
                    LocalDate.of(2019, Month.DECEMBER, 26)
            )
            .skipWhile { date -&gt;
                !date.isAfter(after)
            }
            .zipWith(
                    Observable.interval(500, 50, TimeUnit.MILLISECONDS),
                    { date, _ -&gt; date }
            )
}

fun main(args: Array&lt;String&gt;) {
    nextSolarEclipse(LocalDate.now())
            .timeout&lt;Long, Long&gt;(
                    { Observable.timer(400, TimeUnit.MILLISECONDS) },
                    { Observable.timer(40, TimeUnit.MILLISECONDS) }
            )
            .subscribe(
                    { println(it) },
                    { it.printStackTrace() },
                    { println(""Completed"") }
            )

    TimeUnit.MILLISECONDS.sleep(2000)
}
</code></pre>

<p><strong>Edit: 20-Jun-17</strong></p>

<p>With Kotlin 1.1.2-5, using IntelliJ, with the suggested alteration applied, I still get the error. Attempting to run the code anyway results, as I would expect, with:</p>

<p><code>Error:(34, 21) Kotlin: Interface Function does not have constructors</code></p>

<p><a href=""https://i.stack.imgur.com/dM3D1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dM3D1.png"" alt=""Interface Function does not have constructors""></a></p>
","8086746","","8086746","","2017-06-20 13:47:03","2017-06-20 13:47:03","RxKotlin (RxJava2) timeout() doesn't throw TimeoutException","<rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44709940","1","44722241","","2017-06-22 21:54:10","","1","84","<p>Can someone help me find the proper solution for this problem I face? </p>

<ol>
<li>I have a backend service that give me <code>Observables</code> of the data I need, which are <code>Events</code>.</li>
<li>Form the Event I can get an <code>EventGroup</code>, which contains Ids of all events in the same group.</li>
<li>Next I can get all the <code>Event</code>s that are part of this group.</li>
</ol>

<p>However, I get a <code>Observable&lt;List&lt;Observable&lt;Event&gt;&gt;&gt;</code>, where I'd like to get a <code>Observable&lt;List&lt;Event&gt;&gt;</code>. How can I achive this, without actually subscribing to the nested <code>Observables</code>?</p>

<pre><code>val events : Observable&lt;List&lt;Observable&lt;Event&gt;&gt;&gt; = 
   eventProvider.observable
      .flatMap { myBackend.getEventGroup(it.eventGroupId) }
      .map { 
         it.eventIds.map { myBackend.getEvent(it) } 
      }
</code></pre>

<p><strong>TL:DR</strong></p>

<p>How do I get <code>Observable&lt;List&lt;X&gt;&gt;</code> from a <code>Observable&lt;List&lt;Observable&lt;X&gt;&gt;&gt;</code>?</p>
","3108709","","","","","2017-06-23 13:07:37","RxJava1: How to convert Observable<List<Observable<X>>> to Observable<List<X>>","<rx-java><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"44883593","1","","","2017-07-03 10:43:06","","8","22560","<p>Am using kotlin for developing the application.Now i want to get JSON data from server. </p>

<p>In java am implemented Asyntask as well as  Rxjava for read JSON from Url . Am also search in google but i cant get proper details for my requirement.</p>

<p>How can i  read JSON from Url  using kotlin?</p>
","3710865","","","","","2021-01-08 00:10:27","How to read JSON from Url using kotlin Android?","<android><kotlin><rx-kotlin>","7","0","2","","","CC BY-SA 3.0"
"44997284","1","44997285","","2017-07-09 14:11:35","","0","650","<p>Docs in the RxKotlin repository on GitHub doesn't specify a way to explicitly depend on the latest RxJava versionn.</p>

<p>If we see the <code>build.gradle</code> file of the library, it as of now uses <code>compile 'io.reactivex.rxjava2:rxjava:2.1.0'</code></p>

<p>But what if we want to keep up with the latest RxJava releases and not the one present in the library.</p>
","4173071","","","","","2017-07-10 05:23:06","How to specify the version of RxJava when using RxKotlin?","<android><rx-java><kotlin><rx-java2><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"45118207","1","45126490","","2017-07-15 12:28:01","","-2","228","<p>I using rxjava 2 in kotlin but it is not compiling how should i resolve it ?</p>

<pre><code>var emailField = name.textChanges().skipInitialValue().toFlowable(BackpressureStrategy.LATEST)
var passField = password.textChanges().skipInitialValue().toFlowable(BackpressureStrategy.LATEST)

Flowable.combineLatest(emailField,passField, BiFunction { t1, t2 -&gt;  t1.isNotEmpty() &amp;&amp; t2.isNotEmpty()    })
</code></pre>

<p><a href=""https://i.stack.imgur.com/HRSUu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HRSUu.png"" alt=""enter image description here""></a></p>
","3700517","","","","","2017-07-16 08:19:06","Rxjava with kotlin","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45195799","1","45200122","","2017-07-19 16:09:42","","1","1168","<p>I am writing following code snippet to fetch list of saved food from firebase database and then using that list, I am again fetching individual food details from firebase database.</p>

<p>Following code working fine, except i am unable to figure out how to let second flatMap know that emission of first flatMap has finished(All food list has been processed). So I am unable to call <code>onCompleted()</code> method hence unable to detect when whole process finishes.</p>

<p>Have a look at comments in following snippet:</p>

<pre><code>Observable.create&lt;List&lt;PersonalizedFood&gt;&gt; {

            FirebaseDTDatabase.getSavedDietFoodQuery(user.uid).addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onCancelled(p0: DatabaseError?) {

                }

                override fun onDataChange(p0: DataSnapshot?) {
                    val list = ArrayList&lt;PersonalizedFood&gt;()
                    p0?.let {
                        for (dateObject in p0.children) {
                            for (foodItem in dateObject.children) {
                                val food = foodItem.getValue(FBPersonalizedFood::class.java) as FBPersonalizedFood
                                list.add(PersonalizedFood(food))
                            }
                        }
                    }
                    it.onNext(list)
                    it.onCompleted()
                }
            })
        }.subscribeOn(Schedulers.io()).flatMap {
            Observable.from(it) // returning a Observable that emits items of list (""it"" is the list here) 
        }.observeOn(Schedulers.io()).flatMap {
        // How does this flatMap know that emission of all item has been finished so that onCompleted() method could be called.
            personalizedFood -&gt;

            Observable.create&lt;Boolean&gt;{
                FirebaseDTDatabase.getFoodListReference(personalizedFood.foodId).addListenerForSingleValueEvent(object :ValueEventListener{
                    override fun onCancelled(p0: DatabaseError?) {
                        it.onError(p0?.toException())
                    }

                    override fun onDataChange(p0: DataSnapshot?) {
                        if(p0 != null) {
                            val food = p0.getValue(FBFood::class.java)!!
                            val repo = LocalFoodRepository()
                            doAsync {
                                repo.insertFood(this@LoginActivity, Food(food.foodId, food.foodName, food.foodDesc))
                                repo.insertServingDetails(this@LoginActivity, food.servingList.map { it.component2() })
                                repo.saveFood(this@LoginActivity, personalizedFood)
                                it.onNext(true)
                            }

                        }else {
                            it.onNext(false)
                        }
                    }

                })
            }
        }.observeOn(Schedulers.io()).doOnCompleted{
            dismissProgressDialog()
            finish()
        }.doOnError{
            it.printStackTrace()
            dismissProgressDialog()
            finish()
        }.subscribe()
</code></pre>

<p>Thanks.</p>
","5039950","","","","","2017-07-19 20:08:50","RxAndroid, How to detect if observable has finished emission","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"45234134","1","","","2017-07-21 09:32:04","","-2","1098","<p>How can I make it in kotlin using for loop?</p>

<pre><code>for (double i = 0; i &lt; 10.0; i += 0.25) {
    System.out.println(""value is:"" + i);
}
</code></pre>
","7602736","","4467208","","2017-07-21 09:32:48","2020-12-05 21:01:18","How do i make a loop like mentioned below in kotlin programming language?","<android><android-studio><kotlin><rx-kotlin><kotlin-interop>","4","4","","","","CC BY-SA 3.0"
"45294524","1","45371201","","2017-07-25 05:23:01","","19","22434","<p>I initialize my variable like this:-</p>

<pre><code> val user: BehaviorSubject&lt;User?&gt; user = BehaviorSubject.create()
</code></pre>

<p>But I can't do this. IDE throws an error:-</p>

<pre><code>user.onNext(null)
</code></pre>

<p>And doing this, IDE says u will never be null:-</p>

<pre><code>user.filter( u -&gt; u!=null)
</code></pre>
","4908259","","4908259","","2017-07-25 05:36:33","2021-05-19 17:50:57","How to pass null to an Observable with nullable type in RxJava 2 and Kotlin","<android><kotlin><rx-java><rx-java2><rx-kotlin>","7","7","1","","","CC BY-SA 3.0"
"45380773","1","45382149","","2017-07-28 19:09:18","","1","234","<p>I've got a buffered stream, waiting for a predetermined amount of silence time, before publishing a list of elements that have been buffered:</p>

<pre><code>INTEGERS
     .share()
     .buffer(INTEGERS.debounce(DEBOUNCE_TIME,TimeUnit.MILLISECONDS,scheduler))
     .map { durations -&gt;
       ... 
     }
</code></pre>

<p>I'd like to make <code>DEBOUNCE_TIME</code> dynamically adjust depending on the average of the buffered items, but I'm having a hard time figuring out how to achieve this. </p>
","3692626","","3692626","","2017-07-28 19:14:59","2017-07-28 20:46:54","How to dynamically scale debounce of burst emission stream?","<java><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45404606","1","45405457","","2017-07-30 20:53:25","","0","917","<p>I have a custom Android TextView which shows the amount of time left in a game via a CountDownTimer</p>

<pre><code>class CountdownTextView(context: Context, attrs: AttributeSet) : TextView(context, attrs) {

    private lateinit var countDownTimer: CountDownTimer
    private lateinit var onFinishObservable: Observable&lt;Unit&gt;

    fun setTime(initTime: Int) {
        this.text = ""$initTime:00""
        countDownTimer = object : CountDownTimer((initTime *1000).toLong(), 1000) {
            override fun onTick(millisUntilFinished: Long) {
            val minutes = millisUntilFinished / 60000
            val seconds = (millisUntilFinished % 60000) / 1000
            if (seconds / 10 &gt; 0) {
                text = ""$minutes:${(millisUntilFinished % 60000) / 1000}""
            } else {
                text = ""$minutes:0${(millisUntilFinished % 60000) / 1000}""
            }
        }

        override fun onFinish() {

        }
    }


    fun startCountdown() {
        countDownTimer.start()
    }
}
</code></pre>

<p>How do I set up an observable that emits a value when the countDownTimer's onFinish() method is called? I need this so that on the main activity, I can subscribe to that observable and perform the necessary actions when the countdowntimer expires. </p>
","6407499","","","","","2017-07-30 22:49:16","How to notify Observable when CountdownTimer is finished","<android><kotlin><rx-java><rx-kotlin>","1","0","2","","","CC BY-SA 3.0"
"45441074","1","45502088","","2017-08-01 14:48:34","","1","1554","<p>In order to improve my skills in kotlin, Rx, Retrofit2 I've decided to do a demo project.
The demo project consist to display posts in a recycler view then display details of the post in a detail activity.<br>
I've encountered difficulties displaying data coming from different api call: the user name, the title, the body of the post and the number of comments of the post.</p>

<p>My problem is that I would like to do multiple request and then have all the data needed in order to display them in the detail activity. Which mean doing a call that give me the user name and then a call that give me the number of comments for the post. The title and the body of the post are coming from a request done in the main activity I just transmit it with the bundle to the detail activity.</p>

<p>Api calls:<br>
// return the comments for the post 1<br>
<a href=""http://jsonplaceholder.typicode.com/comments?postId=1"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/comments?postId=1</a> </p>

<p>// return the information of the user 2<br>
<a href=""http://jsonplaceholder.typicode.com/users/2"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/users/2</a>  </p>

<p>// call used to display posts in the main activity<br>
http:/jsonplaceholder.typicode.com/posts</p>

<p>I'm still new on Rx, I was thinking to use a flatMap but I don't know how to use it with Flowable in kotlin..   </p>

<pre><code>var post = viewModel.getPost()
var userStream: Flowable&lt;User&gt; = postService.getUser(post.userId)
var commentsByPostIdCall: Flowable&lt;List&lt;Comment&gt;&gt; = postService.getCommentsByPostId(post.id)

userStream.subscribeOn(Schedulers.io())
        .subscribe(object : Subscriber&lt;User&gt; {
            override fun onError(t: Throwable?) {
                Log.d(this.toString(), "" Read of users failed with the following message: "" + t?.message);
            }

            override fun onNext(user: User) {
                userTextView.text = user.name
                title.text = post.title
                body.text = post.body
            }

            override fun onComplete() {
            }

            override fun onSubscribe(s: Subscription?) {
                if (s != null) {
                    s.request(1)
                }
            }
        })
</code></pre>

<p>I have put the second call in a method <em>getNumberComments</em>:</p>

<pre><code>    private fun getNumberComments(commentsByPostIdCall: Flowable&lt;List&lt;Comment&gt;&gt;): Int {
    var listComments = listOf&lt;Comment&gt;()
    var listCommentSize = 0

     commentsByPostIdCall
             .subscribeOn(Schedulers.io())
             .subscribe(object : Subscriber&lt;List&lt;Comment&gt;&gt; {
                override fun onError(t: Throwable?) {
                    Log.d(this.toString(), "" Read of comments failed with the following message: "" + t?.message);
                }

                override fun onNext(comment: List&lt;Comment&gt;) {
                    listComments = comment
                }

                override fun onComplete() {
                    print(""onComplete!"")
                    listCommentSize = listComments.size
                }

                override fun onSubscribe(s: Subscription?) {
                    if (s != null) {
                        s.request(1)
                    }
                }
            })
    return listCommentSize

}
</code></pre>

<p>Other think that I've noticed is that sometimes the stream didn't go to onComplete, sometimes it remains blocked on onNext. Don't understand why?</p>

<p>Any help will be much appreciate! Thanks a lot :)</p>
","5065580","","5065580","","2017-08-04 15:07:27","2017-08-04 15:07:27","Multiple retrofit2 requests using Flowable in Kotlin","<android><kotlin><retrofit2><rx-kotlin>","2","4","","","","CC BY-SA 3.0"
"45489971","1","","","2017-08-03 16:34:05","","4","1609","<p>I am a beginner with rxjava/rxkotlin/rxandroid.</p>

<p>I need to deal with three diferent async-calls in a sequence.
The problem is that the first step returns a <code>Single&lt;LocationResult&gt;</code>, the second a <code>Completable</code>and the third again a <code>Completable</code>.</p>

<p>(Single -> Completable -> Completable)</p>

<p>The problem is now that the last <code>Completable</code> depends on the data of the first <code>Single</code></p>

<p>My current solution:</p>

<p>I think this is a bad solution, but I don't know how to do this right.</p>

<pre><code>val ft = FenceTransaction(applicationContext, apiClient)
        stream
            .flatMap { locationResult -&gt;
                ft.removeAll()
                return@flatMap ft.commit().toSingle({ return@toSingle locationResult })
            }
            .flatMapCompletable {
                ft.recycle()
                ft.setZone(it.location.longitude, it.location.latitude, ZONE_RADIUS)
                val dots = DotFilter().getFilteredDots()
                for (dot in dots) {
                    ft.addDot(dot)
                }
                return@flatMapCompletable ft.commit()
            }
            .subscribeBy(
                onComplete = {
                    ""transaction complete"".logi(this)
                },
                onError = {
                    ""transaction error"".logi(this)
                })
</code></pre>

<p>Is this approch the correct way to do it?</p>

<p>And how should I dispose the <code>Completeables</code>?
Generally when should I dispose <code>Observables</code>?</p>
","6255743","","6255743","","2017-08-03 16:48:11","2018-04-24 19:13:14","How to chain ""Single - Completeable - Completable"" in rxkotlin?","<android><rx-java2><reactivex><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45517571","1","45520704","","2017-08-05 02:09:10","","1","3113","<p>I am trying to build a presenter that calculates some events within some time period, shows a loading only the first time of loading, and updates the ui when it is done. Because the events can be updated via multiple ways (such as user preferences) I need to be able to tell the presenter that the events were updated and that it has to refresh them again. Here is what I have right now:</p>

<pre><code>                      subject
                            .map&lt;List&lt;UpcomingRowViewModel&gt;&gt; {
                                provider.calculateEventsBetween(TimePeriod.aYearFrom(firstDay))
                            }
                            .doOnSubscribe {
                                view.showLoading()
                            }
                            .observeOn(resultScheduler)
                            .subscribeOn(workScheduler)
                            .subscribe { upcomingRowViewModels -&gt;
                                view.display(upcomingRowViewModels)
                            }
                      subject.onNext(TRIGGER)
</code></pre>

<p>The subject is a <code>PublishSubject</code> of Int. I do the <code>onNext()</code> right after the subscription because I want the data to be refreshed as soon as I subscribe to them. </p>

<p>The above code works wonders in my unit tests and also only when I am running it on a device <em>with the debugger attached</em>. If I just run it (without any debugger), it reaches the <code>view.showLoading()</code> part, but never the <code>provider.calculateEventsBetween(TimePeriod.aYearFrom(firstDay)</code> so the UI gets 'stuck' with the loading. </p>

<p>Any ideas?</p>
","1315110","","","","","2017-08-05 10:10:50","onNext() never gets called on a PublishSubject","<rx-java><rx-kotlin><publishsubject>","1","0","","","","CC BY-SA 3.0"
"45737107","1","45931105","","2017-08-17 13:55:40","","1","4046","<p>I am using <code>retorift</code> to hit <code>getAricle</code> api and get list of articles related to the user. <code>getArticle</code> api will throw error if token passed is expired if so then I have to call <code>refreshToken</code> api to get new token then again I have to call the <code>getArticle</code> api </p>

<pre><code> ApiController.createRx().getArticle(token)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ response -&gt; toast(response.body().url) }, { e -&gt;
                println(e.printStackTrace())
                if(e is HttpException &amp;&amp; e.code() in  arrayOf(401,403)){                      
                   //Here I want to call refresh tolken api
                   toast(""Auth error"")
                }
                else
                   toast(R.string.something_went_wrong)
            })
</code></pre>

<p><strong>Edit</strong></p>

<p>Even though given answers showed some direction but those are not a direct answer to my question. This is how solved it but I feel this can be refactored into much better code</p>

<pre><code>ApiController.createRx().getArticle(Preference.getToken())
            .flatMap { value -&gt;
                if (value.code() in arrayOf(403, 401)) {
                    ApiController.refreshToken()
                    ApiController.createRx().getArticle(Preference.getToken())
                } else Observable.just(value)
            }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ response -&gt; println(""Success"") }, { e -&gt;
                e.printStackTrace()
                toast(R.string.something_went_wrong)
            })



fun refreshToken() {
        val token:String?=ApiController.createRx().refreshToken(Preferences.getRefreshToken()).blockingFirst()?.body()?.token
        if (token != null) Preferences.setAuthToken(token)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>I refactored my code to little more cleaner version</p>

<pre><code>Observable.defer { ApiController.createRx().getArticle(Preferences.getToken()) }
            .flatMap {
                if (it.code() in arrayOf(401, 403)) {
                    ApiController.refreshToken()
                    Observable.error(Throwable())
                } else Observable.just(it)
            }
            .retry(1)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({println(""Success"") }, {
              it.printStackTrace()
              toast(R.string.something_went_wrong)
            })



 fun refreshToken() {
        var token: String? = null
        try {
            token = createRx().refreshToken(Preferences.getRefreshToken()).blockingFirst().body()!!.token
        } catch (e: Exception) {
            throw e
        }
        println(""saving token"")
        if (token != null) Preferences.setAuthToken(token)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>Please check my answer for the final refactored code</p>
","2085698","","2085698","","2017-08-29 05:17:22","2017-08-29 05:24:02","RxJava: Execute second observables only if first one throws an error and repeat from the first","<android><rx-java><retrofit2><rx-java2><rx-kotlin>","4","4","","","","CC BY-SA 3.0"
"45826626","1","45827707","","2017-08-22 20:42:18","","1","1474","<p>I have some methods</p>

<pre><code>Maybe&lt;Foo&gt; getLocalFoo()
Single&lt;List&lt;Foo&gt;&gt; getFooFromInternet()
</code></pre>

<p>And want to check local item and if it's empty then fetch that item from network for example.</p>

<pre><code>storage
            .getLocalFoo()
            .switchIfEmpty { network.getFooFromInternet().map { it[0] }.toMaybe() }
            .subscribe({}, {})
</code></pre>

<p>But seens that code doesn't execute <em>network.getBarcodeTemplates()</em> this function.  </p>
","2093032","","2093032","","2017-08-23 08:02:40","2017-08-23 08:02:40","SwitchIfEmpty not executing maybesource inside","<android><rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45834989","1","","","2017-08-23 08:52:07","","3","1047","<p>Let's take two methods written with Rx:</p>

<pre><code>Maybe&lt;Foo&gt; getFooFromLocal
Single&lt;Foo&gt; getFooFromNetwork
</code></pre>

<p>I want to write a chain when we check our local storage for <em>Foo</em>. If we don't have any <em>Foo</em> we should get it from the network then save it to the local storage and again get it from local storage and pass it to our subscriber. </p>

<pre><code>storage
            .getFooFromLocal()
            .switchIfEmpty(network.getFooFromNetwork().map { it[0] }
                    .flatMapCompletable { storage.saveFoo(it) }
                    .andThen(storage.getFooFromLocal()))
                    .subscriber(/**/)
</code></pre>

<p>The problem is that <code>andThen</code> part completes before completable passed into <code>flatMapCompletable</code>. I found out that I can get rid of this problem if I wrap into <code>Maybe.defer{}</code>. But according to the documentation of <code>andThen</code>
it </p>

<blockquote>
  <p>Returns a <code>Maybe</code> which will subscribe to this Completable.</p>
</blockquote>

<p>And maybe is already</p>

<blockquote>
  <p>Represents a <strong>deferred</strong> computation and emission of a maybe value or exception </p>
</blockquote>

<p>So the question is why my <code>andThen</code> part run before completable finished. And what is the best and elegant way to write such chains. </p>

<p>Calls log :</p>

<pre><code>06:05:58.803 getFooFromLocal
06:05:58.804 getFooFromLocal
06:05:58.804 getFooFromNetwork
06:05:59.963 saveFoo
</code></pre>
","2093032","","2093032","","2017-08-23 13:10:22","2017-08-23 13:29:19","AndThen executes before completable finished","<android><rx-java><rx-kotlin>","1","4","","","","CC BY-SA 3.0"
"45870757","1","45871210","","2017-08-24 20:57:23","","0","286","<p>The question is about RxJava2. </p>

<p>Noticed that zipping <code>Throwable</code> that comes from <code>retryWhen</code> with <code>range</code> emits all items from <code>Observable.range</code> before zipper function has been applied. Also, <code>range</code> emits sequence even if <code>zipWith</code> wasn't called. For example this source code </p>

<pre><code>Observable.create&lt;String&gt; {
        println(""subscribing"")
        it.onError(RuntimeException(""always fails""))
    }
    .retryWhen {
        it.zipWith(Observable.range(1, 3).doOnNext { println(""range $it"") },
                BiFunction { t: Throwable, i: Int -&gt; i })
                .flatMap {
                    System.out.println(""delay retry by $it + second(s)"")
                    Observable.timer(it.toLong(), TimeUnit.SECONDS)
                }
    }./*subscribe*/
</code></pre>

<p>gives the following result </p>

<pre><code> range 1
 range 2
 range 3
 subscribing
 delay retry by 1 + second(s)
 subscribing
 delay retry by 2 + second(s)
 subscribing
 delay retry by 3 + second(s)
 subscribing
 onComplete
</code></pre>

<p>Replacing <code>onError</code> in <code>observable</code> creation also don't eliminate emitting <code>range</code> items. So the question is why it's happening as <code>Range</code> is cold.</p>
","2093032","","61158","","2017-08-24 21:26:48","2017-08-24 21:32:36","Using range in zipWith also emits all items from range sequence before zipper function applied","<reactive-programming><rx-java2><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"45872463","1","45872598","","2017-08-24 23:43:47","","0","735","<p>I have a data flow like this:</p>

<pre><code>Observable
    .fromFuture(
        CompletableFuture.supplyAsync { // First remote call returns Future&lt;List&lt;Type&gt;&gt;
            listOf(1, 2, 3, 57005, 5)
        },
        Schedulers.computation()
    )
    .flatMap { it.toObservable() } // I turn that list into a stream of single values to process them one by one
    .map {
        CompletableFuture.supplyAsync { // This remote call may fail if it does not like the input. I want to skip that failures and continue the stream like the fail never occurred.
            if (it == 0xDEAD) {
                throw IOException(""Dead value!"")
            }

            it
        }
    }
    .flatMap {
        Observable.fromFuture(it) // Turn that Futures into a stream of Observables once again
    }
    .doOnNext {
        println(it) // Debug
    }
    .blockingSubscribe()
</code></pre>

<p>I've replaced business logic (that actually return <code>Future</code>s) with <code>CompletableFuture.supplyAsync</code>.
And, yes, this is Kotlin, but I guess you got the intent.</p>

<p>When I comment ""dead"" value (<code>57005</code>, <code>0xDEAD</code>) the output is:</p>

<pre><code>1
4
9
25
</code></pre>

<p>But if that ""dead"" value appears in the stream, it fails:</p>

<pre><code>1
4
9
Exception in thread ""main"" java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:45)
    at io.reactivex.internal.operators.observable.ObservableBlockingSubscribe.subscribe(ObservableBlockingSubscribe.java:86)
    at io.reactivex.Observable.blockingSubscribe(Observable.java:5035)
    at by.dev.madhead.rx.TestKt.main(test.kt:41)
Caused by: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
...
</code></pre>

<p>I'm a newbie in RX, so quickly googled for a solution: <code>onExceptionResumeNext</code>: <code>Observable.fromFuture(it)</code> --> <code>Observable.fromFuture(it).onExceptionResumeNext { Observable.empty&lt;Int&gt;() }</code>. But now my application hangs forever (after producing the output I expect).
Looks like the stream never ends.</p>

<p>Should I ""shutdown"" that <code>Observable</code> somehow or what?
Or, more generally, is it a good approach when working with RX?
Should I rethink it in another way?</p>
","750510","","750510","","2018-12-18 01:14:32","2018-12-18 01:14:32","How to skip exceptions silently in RxJava2?","<rx-java><reactive-programming><rx-java2><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"45975091","1","","","2017-08-31 06:55:53","","1","408","<p>I have a problem which I was unable to solve so far
I'm new to RxKotlin so it might be easy. Please have a look at the code:</p>

<pre><code>    override fun infos(): Stream&lt;Info&gt; =
        client.infoAboutItem(identifier)
                .map {
                    val itemId = it.itemId ?: """"
                    val item = client.itemForId(itemId)
                    ClientInfo(client, it, source, item) as Info
                }
                .let { AccessStream(it) }
</code></pre>

<p>Where stream is our self-made collection. Map is a method that allows you to iterate over every item inside that collection.</p>

<p>The problem here is that </p>

<pre><code> client.itemForId(itemId)
</code></pre>

<p>is an http call that returns a Single which is not ideal.</p>

<p>I would want to create an asynchronous call inside map that would return Item instead of Single and then pass it to ClientInfo. The things that I've tried so far was was using subscribing inside the map and using blockingGet() method but this blocks the main thread even if I observe and subscribe on a different thread</p>

<p>So it involves making an asynchronous call for every thing in the collection.</p>

<p>Thanks for help</p>
","1840040","","","","","2017-08-31 19:59:08","Asynchronous call for every item inside a collection","<java><kotlin><rx-java><rx-kotlin>","2","5","","","","CC BY-SA 3.0"
"46224173","1","46224508","","2017-09-14 16:27:53","","1","316","<p>Here's a simplified version of what I'm trying to do (using Kotlin and RxJava)</p>

<pre><code>makeServerCall()
                .doOnNext {
                    doStuff(it)
                }
                //TODO: if it == 0, call asyncOperation() and wait for its callback to fire 
                //before running the rest of the stream. Otherwise immediately run the rest
                //of the stream
                .flatMap {
                    observable1(it)
                    observable2(it)
                    Observable.merge(
                            getSpotSearchObservable(observable1),
                            getSpotSearchObservable(observable2)
                }
                .subscribeBy(onNext = {
                allDone()
                    view?
                })
</code></pre>

<p>How do I squeeze in the call to <code>asyncOperation()</code> and make the rest of the stream wait for its callback to fire, but only when a certain condition is met? This seems like it's probably a trivial operation in Rx, but no obvious solution is coming to mind.</p>
","967131","","","","","2017-09-14 16:47:18","How can I conditionally add an asynchronous operation in the middle of an RxJava stream?","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"46459795","1","46459906","","2017-09-28 01:58:34","","-2","510","<p>I'm trying to make a network request using RxKotlin, but keep getting a <code>NetworkOnMainThreadException</code> I'm subscribing on the main thread, so I'm not sure why it's not taking it off of the UI thread.</p>

<p>Here is where I subscribe to the Observable</p>

<pre><code>weatherInteractor.getWeather(lat, lng)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        {response -&gt;
                            try {
                                val jsonData = response.body().string()
                                val currentWeather = getCurrentWeatherData(jsonData)
                                view!!.displayCurrentWeather(currentWeather)
                            } catch (e: JSONException) {
                                Log.d(""Present JSON Exception"", e.message)
                            } catch (e: IOException) {
                                Log.d(""Present IO Exception"", e.message)
                            }
                        },
                        {
                            error -&gt;
                            error.printStackTrace()
                        }
                )
    }
</code></pre>

<p>Here is where I create my Observable</p>

<pre><code>fun getWeather(lat: Double, lng: Double): Observable&lt;Response&gt; {
        val URL = """"
        val client = OkHttpClient()
        val request = Request.Builder()
                .url(URL)
                .build()

        return Observable.create { em -&gt;
            try {
                val response = client.newCall(request).execute()
                em.onNext(response)
                em.onComplete()
            } catch (err: IOException) {
                err.printStackTrace()
                em.onError(err)
            }
        }
    }
</code></pre>
","3079130","","3079130","","2017-09-28 15:56:38","2017-09-28 15:56:38","Getting NetworkOnMainThreadException with RxKotlin","<android><kotlin><rx-java><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"46546041","1","46547211","","2017-10-03 13:42:01","","0","406","<p>I'm using Kotlin 1.1.4-3 with Spring-context 5.0.0.RELEASE. </p>

<p>On starting project I get this error:</p>

<pre><code>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'coroutineAnnotationBeanPostProcessor' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/ProxyCoroutineConfiguration.class]: Unsatisfied dependency expressed through method 'coroutineAnnotationBeanPostProcessor' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalCoroutineContextResolver' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/CoroutineContextResolverConfiguration.class]: Unexpected exception during bean creation; nested exception is java.lang.reflect.InvocationTargetException
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:723)
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:458)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1249)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1098)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:502)
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:205)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalCoroutineContextResolver' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/CoroutineContextResolverConfiguration.class]: Unexpected exception during bean creation; nested exception is java.lang.reflect.InvocationTargetException
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:518)
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:251)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1133)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1060)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:809)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:715)
Caused by: java.lang.reflect.InvocationTargetException: null
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotationArguments(ReflectKotlinClass.kt:173)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotation(ReflectKotlinClass.kt:162)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.loadMethodAnnotations(ReflectKotlinClass.kt:97)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.visitMembers(ReflectKotlinClass.kt:87)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectKotlinClass.visitMembers(ReflectKotlinClass.kt:68)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.AbstractBinaryClassAnnotationAndConstantLoader.loadAnnotationsAndInitializers(AbstractBinaryClassAnnotationAndConstantLoader.kt:257)
Caused by: java.lang.TypeNotPresentException: Type rx.Scheduler not present
        at sun.reflect.annotation.TypeNotPresentExceptionProxy.generateException(TypeNotPresentExceptionProxy.java:46)
        at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:84)
        at com.sun.proxy.$Proxy166.value(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotationArguments(ReflectKotlinClass.kt:173)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotation(ReflectKotlinClass.kt:162)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.loadMethodAnnotations(ReflectKotlinClass.kt:97)
Caused by: java.lang.ClassNotFoundException: rx.Scheduler
        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:348)
        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114)
        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125)
        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
        at sun.reflect.annotation.AnnotationParser.parseSig(AnnotationParser.java:439)
        at sun.reflect.annotation.AnnotationParser.parseClassValue(AnnotationParser.java:420)
</code></pre>

<p>It seems spring is looking for <code>rx.Scheduler</code> class but it's not in the classpath. It's obvious that corresponding dependency of <code>rx.Scheduler</code> is not added. but I couldn't find anything relevant on the Internet.</p>

<p>I added RxJava2 (<code>io.reactivex.rxjava2</code>) to project but it didn't work.
 What can I do?</p>

<p>Final Answer - based on Rafal G. response:</p>

<p>This error is because of using <a href=""https://github.com/konrad-kaminski/spring-kotlin-coroutine"" rel=""nofollow noreferrer"">konrad-kaminski/spring-kotlin-coroutine</a> library.
However, I used these dependencies in my project:</p>

<pre><code>  ""org.springframework.kotlin"" % ""spring-kotlin-coroutine"" % ""0.2.2"" exclude(""org.jetbrains.kotlinx"", ""kotlinx-coroutines""),

  ""org.springframework"" % ""spring-context"" % ""5.0.0.RELEASE"",
  ""org.springframework.data"" % ""spring-data-jpa"" % ""2.0.0.RELEASE"",

  // https://mvnrepository.com/artifact/io.reactivex.rxjava2/rxjava
  ""io.reactivex.rxjava2"" % ""rxjava"" % ""2.1.4"",

  // https://mvnrepository.com/artifact/io.reactivex/rxjava
  ""io.reactivex"" % ""rxjava"" % ""1.3.2"",

  // https://mvnrepository.com/artifact/io.projectreactor/reactor-core
  ""io.projectreactor"" % ""reactor-core"" % ""3.1.0.RELEASE""
</code></pre>
","2250391","","2250391","","2017-10-04 10:19:04","2017-10-04 10:19:04","Spring 5 and Kotlin 1.1 Coroutines: Type rx.Scheduler not present","<java><spring><kotlin><rx-kotlin><kotlinx.coroutines>","1","2","","","","CC BY-SA 3.0"
"46828909","1","46855916","","2017-10-19 11:32:10","","1","245","<p>I've encountered a strange problem which I'm struggling to understand. I have written some code that creates an observable from callable. It compiles fine, but as soon as I specify a scheduler for it it changes the return type and doesn't compile.</p>

<p>Here is the code without the subscribeOn (which compiles):</p>

<pre><code>/**
 * Gets all the room bookings for the specified day
 */
override fun getRoomBookingsForDay(date: Date): Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt; =
        Observable.fromCallable {
            Realm.getDefaultInstance().use { realm -&gt;
                // Get all the bookings that begin and end within the specified date
                val dbRoomBookings =
                        realm.where(DBRoomBooking::class.java)
                                .greaterThan(""timeFromUtc"", date)
                                .lessThan(""timeToUtc"", date)
                                .findAllSorted(""timeFromUtc"")

                if (dbRoomBookings.isEmpty()) {
                    emptyList()
                } else {
                    dbRoomBookings.asSequence().map { dbRoomBooking -&gt;
                        makeRoomBookingModel(dbRoomBooking)
                    }.filterNotNull().toList()
                }
            }
        }
</code></pre>

<p>And here is the code with subscribeOn (which doesn't compile):</p>

<pre><code>/**
 * Gets all the room bookings for the specified day
 */
override fun getRoomBookingsForDay(date: Date): Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt; =
        Observable.fromCallable {
            Realm.getDefaultInstance().use { realm -&gt;
                // Get all the bookings that begin and end within the specified date
                val dbRoomBookings =
                        realm.where(DBRoomBooking::class.java)
                                .greaterThan(""timeFromUtc"", date)
                                .lessThan(""timeToUtc"", date)
                                .findAllSorted(""timeFromUtc"")

                if (dbRoomBookings.isEmpty()) {
                    emptyList()
                } else {
                    dbRoomBookings.asSequence().map { dbRoomBooking -&gt;
                        makeRoomBookingModel(dbRoomBooking)
                    }.filterNotNull().toList()
                }
            }
        }.subscribeOn(AndroidRealmSchedulers.realmThread())
</code></pre>

<p>The compile time error message is:</p>

<pre><code>Type mismatch.
Required: Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt;
Found: Observable&lt;List&lt;Model.RoomBooking&gt;!&gt;!
</code></pre>

<p>Surely, specifying the scheduler shouldn't change the type that is being returned? Any ideas?</p>
","5963279","","","","","2017-10-20 19:17:18","Adding subscribeOn() is changing return type of observable","<android><kotlin><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"47046329","1","47107834","","2017-11-01 00:09:01","","9","30445","<p>I have an object <em>QuickSort</em> that I am attempting to create 2 instances of. When I try to create 2 separate instances I can see that it is only using one instance because I have a count in the <em>QuickSort</em> class that is inaccurate. Kotlin does not use <strong>new</strong> in the syntax, so how would I go about this?</p>

<pre><code>object QuickSort {
      var count = 0;
      quickSortOne(...){
          ...
          count++
          ...
      }
      quickSortTwo(...){
          ...
          count++
          ...
      }
  } 
</code></pre>

<p>Here is how I am attempting to create my 2 instances.My goal is to have <em>quickSort1</em> and <em>quickSort2</em> be 2 separate instances.</p>

<pre><code>var quickSort1 = QuickSort
quickSort1.quickSortOne(...)

var quickSort2 = QuickSort
quickSort2.quickSortTwo(...)
</code></pre>

<p><strong>Attempted Solution</strong>: Converting <em>QuickSort</em> from an object to a class. This still results in the same instance being used as seen by the count of the second method including the first calls count.</p>

<pre><code>class QuickSort {
      var count = 0;
      quickSortOne(...){
          ...
          count++
          ...
      }
      quickSortTwo(...){
          ...
          count++
          ...
      }
  }
</code></pre>

<p>...</p>

<pre><code>var quickSortFirst = QuickSort()
printTest(quickSortFirst.quickSortFirst(arrayList, 0, arrayList.size - 1))

var quickSortLast = QuickSort()
printTest(quickSortLast.quickSortLast(arrayList, 0, arrayList.size - 1))
</code></pre>
","2253682","","2253682","","2017-11-01 03:49:29","2017-11-04 05:42:23","Create New Instance of Kotlin Object","<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin>","4","5","1","","","CC BY-SA 3.0"
"47173475","1","50465274","","2017-11-08 07:02:43","","0","1598","<p><strong>Kotlin Code:</strong></p>

<pre class=""lang-kotlin prettyprint-override""><code>fun &lt;T&gt; Observable&lt;T&gt;.circuitBreaker(): Observable&lt;T&gt; {
  val relay = PublishRelay.create&lt;T&gt;()
  this.subscribe(relay)
  return relay.toFlowable(BackpressureStrategy.LATEST).toObservable()
}
</code></pre>

<p>Above is a Kotlin code which I'm trying to convert into Swift. But, I'm facing an error saying <strong>Cannot convert value of type 'PublishRelay' to expected argument type '(Event&lt;_>) -> Void'</strong></p>

<p><strong>Swift Code:</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension Observable {
  func circuitBreaker&lt;T&gt;() -&gt; Observable&lt;T&gt; {
    let relay = PublishRelay&lt;T&gt;()
    self.subscribe(relay)
    return relay.asObservable()
  }
}
</code></pre>

<p>Any help would be appreciated.</p>
","1083859","","6584288","","2017-11-08 07:09:57","2018-05-22 10:20:39","How to subscribe to PublishRelay from generic observable?","<generics><rx-swift><rx-cocoa><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"47187808","1","","","2017-11-08 19:12:29","","2","1712","<p>When im using the following dependencies in my pom file:</p>

<pre><code>&lt;properties&gt;
    &lt;rxkotlinfx.version&gt;2.2.0&lt;/rxkotlinfx.version&gt;
    &lt;rxkotlin.version&gt;2.1.0&lt;/rxkotlin.version&gt;
    &lt;kotlin.version&gt;1.1.51&lt;/kotlin.version&gt;
    &lt;tornadofx.version&gt;1.7.12&lt;/tornadofx.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.github.thomasnield&lt;/groupId&gt;
        &lt;artifactId&gt;rxkotlinfx&lt;/artifactId&gt;
        &lt;version&gt;${rxkotlinfx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;
        &lt;artifactId&gt;rxkotlin&lt;/artifactId&gt;
        &lt;version&gt;${rxkotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;no.tornado&lt;/groupId&gt;
        &lt;artifactId&gt;tornadofx&lt;/artifactId&gt;
        &lt;version&gt;${tornadofx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-test&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>And running the following code:</p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    val source = listOf(""A"", ""B"", ""C"").toObservable()
            .filter { it == ""B"" }
            .subscribeBy(
                    onNext = { println(it) }
            )
}
</code></pre>

<p>Im getting the following error:</p>

<pre><code>Error:(37, 40) Kotlin: Cannot access class 'io.reactivex.Observable'. Check your module classpath for missing or conflicting dependencies
</code></pre>

<p>Why am I getting this error and what setup of dependencies do I need to be able to work with this stack?</p>
","3139545","","3139545","","2017-11-08 19:29:18","2017-11-09 18:07:28","Kotlin with RxKotlinFX stack gives Cannot access class error","<kotlin><rx-kotlin>","2","1","","","","CC BY-SA 3.0"
"47196773","1","","","2017-11-09 08:04:50","","0","475","<p>I'm using RxKotlin together with Retrofit 2</p>

<p>I'm trying figure out how to have dynamic list of observers on a single operation.</p>

<p>The first observer should trigger the operation, and all additional observers should wait until the operation complete/fails</p>

<p>Once the operation complete,I need to make data manipulation (Store in cache/Memory) and then notify all the observers.</p>

<p>Here's what I did:</p>

<pre><code>class UserManager
{
    val observers = ArrayList&lt;Observer&lt;ArrayList&lt;User&gt;&gt;&gt;()
    var isFetchingUsers = false

    fun getUsers(observer: Observer&lt;ArrayList&lt;User&gt;&gt;)
    {
        observers.add(observer)

        if (isFetchingUsers)
        {
            return
        }

        api.getUserList.observeOn(AndroidSchedulers.mainThread()).subscribe(object : Observer&lt;UserListResponse&gt;
        {
            override fun onNext(response: UserListResponse)
            {
                // Do some manipulations on the response and notify all

                observers.forEach {
                    it.onNext(response.getUsers())
                }
            }

            override fun onError(e: Throwable)
            {
                observers.forEach {
                    it.onError(Throwable())
                }
            }

            override fun onComplete()
            {
                isFetchingUsers = false
                observers.clear()
            }

            override fun onSubscribe(d: Disposable)
            {
            }
        })
    }
}
</code></pre>

<p>Here's Retrofit observable creation (this one is in Java..)</p>

<pre><code>   /**
     * Get users
     */
    public Observable&lt;UserListResponse&gt; getUserList()
    {
        return mService.getUserList().subscribeOn(Schedulers.io());
    }
</code></pre>

<p>I'm sure there's a better way for doing this</p>

<p>Thanks!</p>
","1039477","","1039477","","2017-11-09 08:10:38","2017-11-09 18:15:54","RxKotlin - Dynamic observers array","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"47294290","1","47294652","","2017-11-14 20:04:16","","0","314","<p>I have a stream of <code>ResponseMessage</code> which can be of different subtypes. I would like to split the stream into streams where I can handle each type in its own stream.</p>

<p>My first try resulted in this which I can not see working out.</p>

<pre><code>file.readLines()
        .toObservable()
        .map { mapper.readValue(it, ResponseMessage::class.java) }
        .groupBy { when(it) {
            is MarketChangeMessage -&gt; it::class
            else -&gt; it::class
        }}
        .map { it.????? } //How can possible this work?
</code></pre>

<p>My question is now:
What is the idiomatic way to divide a stream into streams on one specific sub type?</p>
","3139545","","2597143","","2018-10-24 13:19:55","2018-10-24 13:19:55","RxJava/RxKotlin split stream depending on subtype","<kotlin><rx-java><rx-kotlin><rx-kotlin2><rx-javafx>","1","0","","","","CC BY-SA 3.0"
"47376858","1","","","2017-11-19 12:28:54","","1","414","<p>Im stuck getting the following example working as expected, I have tried using <code>zip</code> and <code>combineLatest</code> and as show below <code>withLatestFrom</code> however non of them gives the expected output.</p>
<pre><code>@Test
fun thereCanBeOnlyOne() {
    val s1 = BehaviorSubject.create&lt;Int&gt;()
    val s2 = BehaviorSubject.create&lt;Int&gt;()

    s2.withLatestFrom&lt;Int, Int, Int&gt;(s1)
            .subscribe { (a, b) -&gt;
                println(&quot;$a - $b&quot;)
            }

    s1.onNext(1)
    s1.onNext(2)
    s2.onNext(1)
    s2.onNext(2)
    s1.onNext(333)
    s2.onNext(444)
}
</code></pre>
<p>What I want is the following to print:</p>
<blockquote>
<p>2 - 1</p>
<p>2 - 2</p>
<p>333 - 444</p>
</blockquote>
","3139545","","-1","","2020-06-20 09:12:55","2017-11-19 12:42:14","Combine two subject only when one changes and get latest from other","<rx-java><rx-java2><reactivex><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"47534447","1","","","2017-11-28 14:50:47","","16","9783","<p>Suppose you want to insert a Completable in your Observable chain, such as for each emitted element, there is a completable that runs and blocks until it completes, what option would you choose? (here the <code>Completable.complete()</code> is just to make an example)</p>

<ol>
<li><p><code>.flatMap { Completable.complete().andThen(Observable.just(it)) }</code></p></li>
<li><p><code>.doOnNext { Completable.complete().blockingAwait() }</code></p></li>
<li><p>something else?</p></li>
</ol>
","1855855","","","","","2018-04-26 05:27:53","Chain Completable into Observable flow","<rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"47730952","1","47731024","","2017-12-09 17:02:25","","2","814","<pre><code>class TaskRepo(taskData: TaskData) {

companion object {
    private val repoByTask: LRUMap&lt;String, OrderFormRepo&gt; = LRUMap(2, 10);

     fun getInstance(taskData: TaskData): OrderFormRepo {
        if (notFoundObject(taskData.taskId)) {
            repoByTask[taskData.taskId] = OrderFormRepo(taskData);
        }
        return repoByTask[taskData.taskId];//PROBLEM HERE
    }

    private fun notFoundObject(taskId: String): Boolean {
        if (repoByTask.containsKey(taskId) &amp;&amp; repoByTask[taskId] != null) {
            return false
        }
        return true
    }
}
</code></pre>

<p>}</p>

<p>in getInstance method of companion object I am getting compile time <strong>error:</strong>
<strong>Required TaskRepo and found TaskRepo?</strong></p>
","1412900","","4465208","","2017-12-09 17:51:06","2017-12-09 17:51:06","Required <Object> and found <Object>?","<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin><kotlin-interop>","1","0","","","","CC BY-SA 3.0"
"47735111","1","47900911","","2017-12-10 01:53:59","","-3","82","<p>could you please help me for this <a href=""https://stackoverflow.com/questions/47595813/rxkotlin-groupby-is-not-working"">rxkotlin groupby is not working</a>? working in rxjava but not kotlin. highly apreciate your help</p>
","1820178","","","","","2017-12-20 07:33:13","I can't get map from groupby in rxkotlin","<kotlin><rx-java><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"47770059","1","","","2017-12-12 10:14:32","","2","3224","<p>
this is my xml :</p>

<pre><code>&lt;data&gt;

    &lt;variable
        name=""notificationViewmodel""
        type=""com.kdcos.contsync.viewmodel.notification.NotificationViewModel""&gt;&lt;/variable&gt;

&lt;/data&gt;


&lt;RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""
    android:background=""@color/colorpalegrey""&gt;

    &lt;RelativeLayout
        android:id=""@+id/header""
        android:layout_width=""match_parent""
        android:layout_height=""wrap_content""
        android:layout_alignParentTop=""true""
        android:layout_gravity=""center""
        android:background=""#689F38""
        android:gravity=""center""&gt;

        &lt;include
            android:id=""@+id/layout_toolbar""
            layout=""@layout/toolbar_white_bg"" /&gt;
    &lt;/RelativeLayout&gt;


    &lt;LinearLayout
        android:layout_width=""match_parent""
        android:layout_height=""wrap_content""
        android:layout_below=""@+id/header""
        android:layout_marginTop=""20dp""
        android:background=""@drawable/topbottomborder""
        android:orientation=""vertical""&gt;


        &lt;RelativeLayout
            android:layout_width=""fill_parent""
            android:layout_height=""wrap_content""
            android:layout_marginTop=""18dp""
            android:paddingBottom=""20dp""
            android:paddingLeft=""@dimen/margin_20dp""&gt;


            &lt;TextView
                android:layout_width=""match_parent""
                android:layout_height=""wrap_content""
                android:fontFamily=""sans-serif-medium""
                android:lineSpacingExtra=""30sp""
                android:text=""@={notificationViewmodel.getText()}""
                android:textColor=""@color/colorDusk""
                android:textSize=""16sp""
                android:textStyle=""normal"" /&gt;

            &lt;Switch
                android:layout_width=""wrap_content""
                android:layout_height=""wrap_content""
                android:layout_alignParentRight=""true""
                android:paddingRight=""10dp""
                android:onCheckedChanged=""@={notificationViewmodel.checked}""
                android:textColor=""@android:color/black"" /&gt;

        &lt;/RelativeLayout&gt;
    &lt;/LinearLayout&gt;


&lt;/RelativeLayout&gt;
</code></pre>

<p></p>

<p>this is my View Model</p>

<pre><code>class NotificationViewModel(val context: Context, val bus: Bus, val manager: CNotificationManager) : BaseObservable() {
    private var checked: Boolean = false
    fun getToolbarTitle(): String? {
        return manager.getToolbarTitle()
    }

    fun setToolbarTextColor(): Int {
        return ContextCompat.getColor(context, R.color.colorDusk)
    }

    fun isChecked(): Boolean {
        return checked
    }

    fun setChecked(checked: Boolean) {
        this.checked = checked
    }

    fun getText(): String {
        if (isChecked()) {
            return ""Notfication On""
        } else {
            return ""Notification Off""
        }
        notifyChange()
    }
}
</code></pre>

<p>I want to apply data binding in <code>switch</code> so that when I on <code>switch</code> then  <code>textView</code> should display Notification off and checked value should set to true when I off then it <code>textview</code> should display  notification off and checked Boolean variable should set false. please suggest me how I will implement using Data-binding .</p>
","7108422","","5400914","","2017-12-12 11:20:22","2021-02-26 12:18:27","how to implement Switch using Data binding in android","<android><data-binding><kotlin><rx-kotlin>","2","2","","","","CC BY-SA 3.0"
"47993122","1","47993505","","2017-12-27 13:33:13","","0","59","<p>I am using firebase in android with some complex data. I need to save references and I'm getting problems with my zip operation, or the way I'm handling RX overall.</p>

<p>I want to create a new <code>A object</code> with information about a certain <code>B</code>, and update my <code>B object</code> to have information about the created <code>A</code>. When the firebase operations have both been successful I will return the <code>Single&lt;A&gt;</code></p>

<pre><code>val singleA = firebaseCall(A(""ABC"", bKey))

val singleB = singleA.flatMap{ a -&gt; firebaseCall(B(aKey)) }

return Single.zip(singleA, singleB, BiFunction { a, b -&gt; a })
</code></pre>

<p>When going through logcat I can see that <code>SingleA</code> get subscribed to twice, and pushes twice to firebase. I want to avoid this!</p>

<p>So, how can I use a zip function on A and B, when B is dependent on A; and not have A being performed twice?</p>
","1570640","","7505436","","2017-12-27 15:16:03","2017-12-27 15:16:03","How do I avoid .zip(stream1, stream2, BiFun) subscribing to stream1 twice, when stream2 is based on stream1?","<android><firebase-realtime-database><reactive-programming><rx-java2><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"48055716","1","","","2018-01-02 04:49:16","","-6","730","<pre><code> override fun itemclick(position: Int) {
        binding.progressbar.visibility=View.VISIBLE
        binding?.barcode?.setImageBitmap(exchngeViewModel.getQrImageBitmap(qrCodeData[position], this!!.activity!!))
        showDetail(position)
        binding.progressbar.visibility=View.GONE
    }    

fun getQrImageBitmap(data: String, context: Context): Bitmap? {
        bitMap = AppUtils.TextToImageEncode(data, context, bus) 
        return this!!.bitMap
    }
</code></pre>

<p>This is my code i want to display Progress <code>dialog</code> on item click it should dismiss till that time when  <code>getQrImageBitmap</code> and showDetail function  completed but i its not working please suggest me how to achieve this how to show and hide detail on item click.Thanks!! </p>
","7251198","","5110595","","2018-01-02 05:35:42","2018-01-02 05:44:39","How to show Progress dialog and dismiss on Item click","<android><kotlin><rx-java><rx-kotlin>","1","6","","","","CC BY-SA 3.0"
"48126761","1","51862452","","2018-01-06 11:15:03","","6","1728","<p>I am using RxJava/Kotlin with Room and Retrofit. I am sure I'm not making something write as I just started learning RxJava. The scenario is that I make a call to check if there are favorite records in DB and get them in a List, fetch data from API and insert it in DB, update the DB with the previous favorites list and get all records as an, now updated, List. I get the result in my fragment but each time I get it it's as if I get 1 less favorite item until I get no favorite items.</p>

<p><code>Repository</code></p>

<pre><code>fun getKafaniFromApi(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return apiService.getKafani().toObservable().doOnNext {
        insertKafaniInDb(it)
    }
}

fun getKafaniFromDb(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return kafanaDao.getKafani().toObservable()
}

fun insertKafaniInDb(kafani: List&lt;Kafana&gt;) {
    Observable.fromCallable { kafanaDao.insertAll(kafani) }
            .subscribeOn(Schedulers.io())
            .subscribe {
                Timber.d(""Inserted ${kafani.size} kafani from API in DB..."")
            }
}

fun getFavoriteKafani(): Single&lt;List&lt;Kafana&gt;&gt; {
    return kafanaDao.getFavoriteKafani()
}

fun setKafanaFavorite(kafana: Kafana, isFavorite: Int) {
    return kafanaDao.setFavourite(kafana.name, isFavorite)
}

fun updateFavoriteKafana(kafana: Kafana) {
    return kafanaDao.updateFavoriteKafana(kafana)
}
</code></pre>

<p>And in my <code>viewmodel</code></p>

<pre><code>fun get(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return kafanaRepository.getFavoriteKafani()
            .toObservable()
            .doOnNext { kafaniList = it }
            .flatMap { kafanaRepository.getKafaniFromApi() }
            .doOnNext { kafaniList?.forEach { kafanaRepository.updateFavoriteKafana(it) } }
            .flatMap { kafanaRepository.getKafaniFromDb() }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
}
</code></pre>

<p>I will actually get the list in my fragment but, as I said, it will always be one less favorite until there are none.</p>
","6638520","","","","","2018-08-15 16:13:16","Chaining multiple calls RxJava, Room and Retrofit","<android><retrofit2><rx-java2><android-room><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"48129498","1","52319803","","2018-01-06 16:43:21","","9","5049","<p>I have issue that I cannot solve. Im trying to .zip(List, ) multiple Singles into one using Kotlin and none of Functions i supply as second argument fits.</p>

<pre><code>    fun getUserFriendsLocationsInBuckets(token: String) {
    roomDatabase.userFriendsDao().getUserFriendsDtosForToken(token).subscribe(
            { userFriends: List&lt;UserFriendDTO&gt; -&gt;
                Single.zip(getLocationSingleForEveryUser(userFriends),
                        Function&lt;Array&lt;List&lt;Location&gt;&gt;, List&lt;Location&gt;&gt; { t: Array&lt;List&lt;Location&gt;&gt; -&gt; listOf&lt;Location&gt;() })
            },
            { error: Throwable -&gt; }
    )
}

private fun getLocationSingleForEveryUser(userFriends: List&lt;UserFriendDTO&gt;): List&lt;Single&lt;List&lt;Location&gt;&gt;&gt; =
        userFriends.map { serverRepository.locationEndpoint.getBucketedUserLocationsInLast24H(it.userFriendId) }
</code></pre>

<p><a href=""https://i.stack.imgur.com/1ByNM.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/1ByNM.png"" alt=""Android studio error""></a></p>
","5396120","","","","","2018-09-13 18:30:20","RxJava 2.0 and Kotlin Single.zip() with list of singles","<kotlin><rx-java><rx-kotlin>","1","2","1","","","CC BY-SA 3.0"
"48225258","1","48225383","","2018-01-12 11:22:37","","16","19674","<pre><code>val mutableList1: MutableList&lt;TeamInvitationData?&gt;?
val mutableList2: MutableList&lt;TeamInvitationData?&gt;?
</code></pre>

<p><strong>addAll</strong> method can be use to merge nullable mutable list but, here it throws me compile time error. </p>

<p>Example:</p>

<pre><code>val map1 = listOne?.map { TeamInvitationData(it) }
val map2 = listTwo?.map { TeamInvitationData(it) }
map1.addAll(map2)
</code></pre>

<blockquote>
  <p>Type interface failed ,Please try to specify type argument explicitly.</p>
</blockquote>

<p>Here Any way can I merge this two array , thanks in advance.</p>
","1339473","","1339473","","2018-01-12 12:50:44","2019-12-31 06:22:57","Kotlin merge two nullable mutable list","<android><kotlin><rx-kotlin>","3","4","3","","","CC BY-SA 3.0"
"48261094","1","48374540","","2018-01-15 10:28:48","","2","593","<p>I'm writing a wrapper around FirebaseFirestore snapshot listener that emits the changes using RxKotlin Observable.</p>

<p>I wrote the following class which makes use of create() method to create the observable and emit the changes asynchronously when a new data snapshot is available. </p>

<p>The problem is that I'm leaking memory every time I create an instance of this class and I stop using it. What is the best way to rewrite this class without leaking memory?</p>

<p>Any resources about how to create Observables that can emit objects from listeners would be really helpful!</p>

<pre><code>class DocumentRepository&lt;T : ModelWithMetadata&gt;(
        path: List&lt;String&gt;,
        private val model: Class&lt;T&gt;) {

    private var documentReference: DocumentReference

    val observable: Observable&lt;T&gt;

    private var emitter: ObservableEmitter&lt;T&gt;? = null
    private lateinit var item: T


    init {
        documentReference = FirebaseFirestore.getInstance().collection(path[0]).document(path[1])
        for (i in 2..path.lastIndex step 2)
            documentReference = documentReference.collection(path[i]).document(path[i + 1])

        observable = Observable.create(this::listenChanges)
    }

    private fun listenChanges(emitter: ObservableEmitter&lt;T&gt;) {
        this.emitter = emitter
        documentReference.addSnapshotListener { documentSnapshot, _ -&gt;
            item = documentSnapshot.toObject(this.model)
            this.emitter?.onNext(item)
        }
    }

    fun get() {
        emitter?.onNext(item)
    }

    fun put(item: T) {
        item.updatedAt = TimeExtension.now()
        documentReference.set(item)
    }

    fun delete(item: T) {
        documentReference.delete()
    }
}
</code></pre>
","3723306","","","","","2018-01-22 04:08:50","Avoid memory leak when Observable.create() to emit listener objects","<google-cloud-firestore><rx-java2><rx-android><reactivex><rx-kotlin>","1","1","1","","","CC BY-SA 3.0"
"48347759","1","48357786","","2018-01-19 18:52:09","","0","623","<p>perform a task with an observable and emit value</p>

<pre><code>private val performTask = io.reactivex.Observable.create&lt;Boolean&gt;({ emitter -&gt;
// do somethinf
    emitter.onNext(true)
    emitter.onComplete()
})
</code></pre>

<p>// this is also another observable with retry. I want to retry 2 times, but only if perform task is successful. </p>

<pre><code>fun &lt;T&gt; io.reactivex.Observable&lt;T&gt;.retryAuth(): Observable&lt;T&gt; {
    return this.retry ({ count, error -&gt; 
        if (count == 2 &amp;&amp; error is ApolloException) {
            // do something with performTask and return the value

        } else false
    })
</code></pre>

<p>just need illustration on achieving this</p>
","3100757","","3100757","","2018-01-20 07:24:39","2018-01-20 15:23:23","execute and return value from observable on retry predicate","<java><android><rx-java><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"48398348","1","48411925","","2018-01-23 09:35:22","","1","1068","<p>I have my observables defined like this </p>

<pre><code>    val initLoading = Observable.fromCallable { println(""${System.currentTimeMillis()}"") }
            .subscribeOn(Schedulers.computation())
            .delay(WAIT_TIME, TimeUnit.SECONDS)
            .map { ""loading ${System.currentTimeMillis()}"" }
            .observeOn(AndroidSchedulers.mainThread())

    val click = RxView.clicks(button).map { ""click ${System.currentTimeMillis()}"" }
    initLoading.concatWith(click)
            .subscribeBy(
                    onNext = { println(""result $it"") },
                    onError = { throw it }
            )
</code></pre>

<p><code>initialLoading</code> starts running at Activity's <code>onCreate</code> method. <code>click</code> is executed on button click. I have two cases and first is working, second isn't.</p>

<p><strong>case 1</strong> </p>

<p>activity starts and button is clicked <strong>after</strong> <code>WAIT_TIME</code> seconds. Output: </p>

<pre><code>   01-23 13:08:07.170  I/System.out: 1516698487170
   01-23 13:08:17.174  I/System.out: result loading 1516698497172
   01-23 13:08:29.258  I/System.out: result click 1516698509258
</code></pre>

<p><strong>case 2</strong></p>

<p>activity starts and button is clicked <strong>before</strong> <code>WAIT_TIME</code> period is over. Output</p>

<pre><code>   01-23 13:09:07.392 I/System.out: 1516698547392
   01-23 13:09:17.398 I/System.out: result loading 1516698557395
</code></pre>

<p>so, the problem is that the click event is lost. I want the click event to wait for the loading, and then continue working. in short, case 2 output should be the same as case 1.</p>

<p>How can i chive this using rx operators. I tried <code>merge</code> but it just combines both and click event doesn't wait for loading. </p>

<p>I also tried <code>reply, cache, publish, share</code> but couldn't get the right combination of them to work as I want. </p>
","3904645","","","","","2018-01-23 22:32:22","RxJava: Combining hot and cold observable to wait for each other","<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 3.0"
"48414894","1","","","2018-01-24 04:36:42","","2","2675","<p>I am new in Spring 5 and Reactive Programming. My problem is creating the export feature for the database by a rest API.
User hits GET request -> Server reads data and returns data as a zip file. Because zip file is large, so I need to stream these data.
My code as below:</p>

<pre><code>    @GetMapping(
    value = ""/export"",
    produces = [""application/octet-stream""],
    headers = [
              ""Content-Disposition: attachment; filename=\""result.zip\"""",
              ""Content-Type: application/zip""])
    fun streamData(): Flux&lt;Resource&gt; = service.export()
</code></pre>

<p>I use curl as below:</p>

<pre><code>curl http://localhost/export -H ""Accept: application/octet-stream""
</code></pre>

<p>But it always returns 406 Not Acceptable.
Anyone helps?</p>

<p>Thank you so much</p>
","5867133","","","","","2018-01-26 02:25:07","Response zip file with WebFlux","<stream><kotlin><reactive-programming><spring-webflux><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"48468325","1","48468793","","2018-01-26 19:33:12","","1","458","<p>I am writing a method in Kotlin:</p>

<pre><code>fun fetchDepositSession(): Completable =
        Observable.fromIterable(session.accounts)
                .map(DepositSession::DepositAccount)
                .toList()
                .doOnSuccess(depositSession::depositAccounts::set)
                .flatMapObservable(Observable::fromIterable)
                .map(DepositSession.DepositAccount::account::get)
                .toCompletable()
</code></pre>

<p>The line <code>.flatMapObservable(Observable::fromIterable)</code> is causing an error:</p>

<p><a href=""https://i.stack.imgur.com/WKMsm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WKMsm.png"" alt=""enter image description here""></a></p>
","2836797","","","","","2018-01-26 20:07:28","Generic Function References in Rx and Kotlin -- type inference failed","<android><kotlin><rx-java><rx-java2><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"48528325","1","48528504","","2018-01-30 18:36:40","","1","317","<p>This never completes:</p>

<pre><code>Completable.complete()
        .andThen{ Completable.complete() }
        .test()
        .assertComplete()
</code></pre>

<p>This does complete:</p>

<pre><code>Completable.complete()
        .andThen(Completable.complete())
        .test()
        .assertComplete()
</code></pre>

<p>According to Jake Wharton:</p>

<p>""You want <code>andThen(Completable.complete())</code>. Note the use of parenthesis and
not curly braces. The latter creates a lambda that doesn't call its emitter.""</p>

<p>Reference: <a href=""https://github.com/ReactiveX/RxJava/issues/5551"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxJava/issues/5551</a></p>

<p>Can anyone explain this in more detail? I thought I understood lambda's but this has really thrown me. </p>
","5963279","","8073652","","2018-01-30 18:51:51","2018-01-30 18:51:51","RXKotlin Lambda Understanding","<lambda><kotlin><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"48568178","1","","","2018-02-01 17:08:04","","1","543","<p>Currently I'm building a project in Kotlin using RxKotlin. My background with Rx is primarily grounded in RxJS. </p>

<p>A pattern I would regularly use for creating <code>hot observables</code> in Typescript would look something along the lines of this: </p>

<pre><code>  private dataStore: IFoo;
  private dataStoreSubject: BehaviorSubject&lt;IFoo&gt; = new BehaviorSubject(this.dataStore);
  public dataStoreObservable: Observable&lt;IFoo&gt; = Observable.from(this.dataStoreSubject);

  public getNetworkData(): Observable&lt;IFoo[]&gt; {
      return this.http.get()
         .map((response: IResponse) =&gt; {
             this.dataStore = &lt;IFoo[]&gt;response;
             this.dataStoreSubject.next(this.dataStore);
             return this.dataStore;
          });
   }
</code></pre>

<p>This would allow me to expose an <code>Observable</code>, without exposing the <code>Subject</code> and subsequently the <code>subject.next();</code> method.</p>

<p>My question is: What would be the most idiomatic way to establish similar logic in RxKotlin or RxJava?</p>
","6754267","","","","","2019-02-18 19:59:26","Idiomatically creating hot observables with BehaviorSubject in RxKotlin / RxJava","<java><rxjs><rx-java><rx-java2><rx-kotlin>","1","5","","","","CC BY-SA 3.0"
"48689211","1","48689307","","2018-02-08 15:35:11","","0","162","<p>I'm developing an android app using room and RxAndroid. The problem is that i'm using the next code to refresh the info in my recycler view.</p>

<pre><code>observable.subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe{adapter.data = it}
</code></pre>

<p>if i implement this in my activity it works like a charm. But i want to create an extension function to make the code cleaner when using flowables from the database. I create this funtion </p>

<pre><code>fun &lt;T&gt; Flowable&lt;T&gt;.uiSubscribe(x : (T) -&gt; Unit)  {
this.subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe{x}
</code></pre>

<p>but when i tried to use it, it does nothing. It doesn't trow an error or anything. Does somebody know a way to archive this? or does somebody know why it is not working?</p>
","5420543","","1843331","","2018-02-08 16:25:45","2018-02-08 16:25:45","How to create a extension function to make rx subscription to flowable cleaner?","<android><kotlin><rx-java2><rx-android><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"48753572","1","48753835","","2018-02-12 18:57:09","","6","5050","<pre><code>    Observable.just(1)
            .flatMap(object : Function&lt;Int, Observable&lt;Int&gt;&gt; {
                override fun apply(integer: Int): Observable&lt;Int&gt; {
                    return Observable.just(integer * 10)
                }
            })
            .flatMap(object : Function&lt;Int, Observable&lt;Int&gt;&gt; {
                override fun apply(integer: Int): Observable&lt;Int&gt; {
                    return Observable.just(integer * 20)
                }
            })
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(object : Observer&lt;Int&gt; {
                override fun onComplete() {
                }

                override fun onSubscribe(d: Disposable) {
                }

                override fun onNext(t: Int) {
                    Log.d(""result"", """" + t)
                }

                override fun onError(e: Throwable) {
                    e.printStackTrace()
                }
            })
</code></pre>
","2069407","","","","","2018-08-01 09:23:17","How can I convert this rxjava/rxkotlin flatMap into lambda expression?","<android><lambda><rx-java><flatmap><rx-kotlin>","2","0","1","","","CC BY-SA 3.0"
"48845703","1","48851716","","2018-02-17 20:35:45","","0","1403","<p>I'm trying to sort the emissions of an <code>Observable</code> using either <code>sorted()</code> or <code>toSortedList()</code>.</p>

<p>Here's my code:</p>

<pre><code>bookshelfUseCase.addedBooks(uid, BookshelfRepositoryContract.READ_LIST)
            .flatMap { Observable.fromIterable(it) }
            .doOnNext { Log.d(""RLP1"", it.toString()) }
            .toSortedList { first, second -&gt; first.timestamp.compareTo(second.timestamp) }
            .toObservable()
            .doOnNext { Log.d(""RLP2"", it.toString()) }
            .subscribe { getView().showBooks(it) }
</code></pre>

<p>Here, I'm comparing the timestamp of each <code>Book</code> to get a sorted list for showing it to the user.</p>

<h2>What's the problem?</h2>

<p>The <code>Observable</code> or <code>Single</code> returned by <code>sorted()</code> or <code>toSortedList()</code> doesn't emit anything. Just blank. Zero emissions.</p>

<p>Here's the output of log printed by the <code>doOnNext()</code> before and after <code>toSortedList()</code> is called:</p>

<pre><code>02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=368593, title=The 4-Hour Workweek, year=2007, author=Author(id=210456, name=Timothy Ferriss), rating=3.85, coverImageUrl=https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png, coverImageUrlSmall=https://s.gr-assets.com/assets/nophoto/book/50x75-a91bf249278a81aabab721ef782c4a74.png, checkInTime=0, timestamp=1518895501664)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=12605157, title=The $100 Startup: Reinvent the Way You Make a Living, Do What You Love, and Create a New Future, year=2012, author=Author(id=3367145, name=Chris Guillebeau), rating=3.85, coverImageUrl=https://images.gr-assets.com/books/1345666854m/12605157.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1345666854s/12605157.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=13497818, title=The Casual Vacancy, year=2012, author=Author(id=1077326, name=J.K. Rowling), rating=3.28, coverImageUrl=https://images.gr-assets.com/books/1509893913m/13497818.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1509893913s/13497818.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=29095176, title=Lyrebird, year=2016, author=Author(id=7116, name=Cecelia Ahern), rating=3.76, coverImageUrl=https://images.gr-assets.com/books/1465023152m/29095176.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1465023152s/29095176.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=31823677, title=Tools of Titans: The Tactics, Routines, and Habits of Billionaires, Icons, and World-Class Performers, year=2016, author=Author(id=210456, name=Timothy Ferriss), rating=4.25, coverImageUrl=https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png, coverImageUrlSmall=https://s.gr-assets.com/assets/nophoto/book/50x75-a91bf249278a81aabab721ef782c4a74.png, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=36204090, title=Crushing It!: How Great Entrepreneurs Build Their Business and Influence‚Äîand How You Can, Too, year=0, author=Author(id=1371305, name=Gary Vaynerchuk), rating=4.58, coverImageUrl=https://images.gr-assets.com/books/1514065832m/36204090.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1514065832s/36204090.jpg, checkInTime=0, timestamp=0)
</code></pre>

<p>As you can see, no logs are being printed after the <code>toSortedList()</code> has been called in the chain.</p>

<p>What could I be missing here?</p>

<p>Any help is highly appreciated. Thanks in advance.</p>
","3922919","","","","","2018-02-18 12:32:40","Sorting emissions in Rx using sorted() or toSortedList() not working","<android><kotlin><rx-java2><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"48922214","1","48922453","","2018-02-22 07:55:34","","3","1324","<p>I have code to listen to exactly three fields using <strong>Observables.combineLatest</strong> </p>

<pre><code>Observables.combineLatest(text_name.asObservable(),text_username.asObservable(), text_email.asObservable()).subscribe({ t -&gt;
            if (t.first.toString() != currentName || t.second.toString() != currentUsername) {
                startActionMode()
            } else {
                finishActionMode()
            }
        })
</code></pre>

<p>but when I add another parameter to the <strong>Observables.combineLatest</strong> it throughs error since only 3 inline-parameters can be passed..</p>

<p>Now I would wish to pass 4 parameters in the parameter list for <strong>Observables.combineLatest</strong>.. I know it should be done using an array or a list, passed in as parameter but It's hard for me to figure it out using <strong>Kotlin</strong>.</p>

<p>Help me out.. Thanks in Advance..</p>
","7813796","","6296561","","2018-02-22 10:03:47","2018-02-22 10:03:47","How to Listen to more than Three Fields in Observables.combineLatest","<android><kotlin><kotlin-android-extensions><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"48967171","1","48971608","","2018-02-24 20:17:23","","0","712","<p>In my application I'm using RxJava2 and new class from Architecture Components ViewModel. In my case, I need to push SQL clause to ViewModel, which will do some magic and return Observable that will give me the data I need. Everything works fine, but I am not sure if I am using RX in the best way. </p>

<p>My data flow:
ViewModel has PublishSubject on which I am pushing SQL's. ViewModel has also Observable which is created by mapping subject. Also, I used distinctUntilChanged on Subject, to prevent from executing the same query again. 
 To cache data I used replay(1).autoconnect(1) on Observable, but that approach had a flaw. Sometimes my Subject pushed Sql when Observable wasn't yet connect, and my data never arrived to me. Should I use BehaviourSubject? Or maybe I shouldn't use replay(1).autoconnect(1) in the first place? Or maybe my whole flow is wrong? Example:</p>

<pre><code>val listSubject: Subject&lt;RawSql&gt; = PublishSubject.create()
val sqlListEmitter: Observable&lt;List&lt;T&gt;&gt; =
        listSubject
                .subscribeOn(Schedulers.computation())
                .map { // SOME MAGIC HERE }
                .replay(1).autoConnect(1, { compositeDisposable.add(it) })
</code></pre>
","7799729","","8551764","","2018-12-02 19:58:28","2018-12-02 19:58:28","Best way to cache data in Android with ViewModel and RxJava2","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"49031599","1","49811981","","2018-02-28 14:14:42","","3","597","<p>I was first introduced to reactive programming with <strong>ReactiveCocoa</strong> several years ago. In there they had the notion on <code>RACCommand</code>s, which was carried over to <strong>RxSwift</strong> with the extension library <strong><a href=""https://github.com/RxSwiftCommunity/Action"" rel=""nofollow noreferrer"">Action</a></strong>.</p>
<p>As stated on their GitHub page:</p>
<blockquote>
<p>An action is a way to say &quot;hey, later I'll need you to subscribe to this thing.&quot;</p>
<p>Actions accept a <code>workFactory</code>: a closure that takes some input and produces an observable. When <code>execute()</code> is called, it passes its parameter to this closure and subscribes to the work.</p>
<ul>
<li>Can only be executed while &quot;enabled&quot; (true if unspecified).</li>
<li>Only execute one thing at a time.</li>
<li>Aggregates next/error events across individual executions.</li>
</ul>
</blockquote>
<p>In my experience it is an absolutely <em>indispensable</em> tool in the reactive programming toolbox when doing robust, reactive iOS development.</p>
<hr />
<p>Now we would like to carry this over to <strong>Android</strong> app as well. But after countless hours of research I have not been able to find a corresponding component for either <strong>RxJava</strong> or <strong>RxKotlin</strong>.</p>
<p>The implementation in Swift is relatively straight forward, so we <em>could</em> just port it, but I'd first like to hear if:</p>
<ol>
<li>This really does not exists, and if so</li>
<li>Is there an Android specific reason for this to not exist, i.e. a reason <strong>not</strong> to port it</li>
</ol>
","746968","","-1","","2020-06-20 09:12:55","2018-04-13 07:55:37","RxSwift like Actions for Android","<android><ios><rx-java><rx-swift><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"49188172","1","49189651","","2018-03-09 06:55:39","","4","1872","<p>Facing Problem on getting Response in ArrayList. </p>

<p>I have following Respose on String value </p>

<pre><code> var res_message: String = """"
 res_message = ""${result.vehicletypes} ""
</code></pre>

<p>Getting below Value on this String</p>

<pre><code>     [VehicleType(_id=1, vehicleType=Hatchback, __v=0), 
      VehicleType(_id=2, vehicleType=Maruti, __v=0), 
      VehicleType(_id=3, vehicleType=Honda, __v=0), 
      VehicleType(_id=4, vehicleType=Bike, __v=0)] 
</code></pre>

<p>Retrofit Result is </p>

<pre><code> vehicletypes = {ArrayList@6055}  size = 4
 0 = {Model$VehicleType@6058} ""VehicleType(_id=1, 
vehicleType=Hatchback, __v=0)""
 1 = {Model$VehicleType@6059} ""VehicleType(_id=2, 
 vehicleType=Maruti, __v=0)""
  2 = {Model$VehicleType@6060} ""VehicleType(_id=3, 
 vehicleType=Honda, __v=0)""
  3 = {Model$VehicleType@6061} ""VehicleType(_id=4, 
  vehicleType=Bike, __v=0)""
</code></pre>

<p>Below Code snippest sending request to API. </p>

<pre><code>            disposable = apiServices.getVehicle(token)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { result -&gt;


                        res_message = ""${result.vehicletypes} ""
                        Log.d(""Type=="", res_message)
                    },
                    { error -&gt;
                        res_message = ""${error.message}""
                        // validateToken()
                    }
            )
</code></pre>

<p><em>Model Class</em></p>

<pre><code>  data class Vehicles(val success: Boolean, val vehicletypes: List&lt;VehicleType&gt;, val message: String)
  data class VehicleType(val _id: String, val vehicleType: String, val __v: String)
</code></pre>

<p>I want to get this value on Arralist <strong>VehicleType</strong> List on below <strong>vehicleListArray</strong></p>

<pre><code>   private var vehicleListArray: ArrayList&lt;Model.VehicleType&gt;? = null
</code></pre>

<p>How we can achieve this. 
<strong>Thanks in advance.</strong> </p>
","3992260","","3992260","","2018-03-09 08:40:14","2018-03-09 13:04:40","How to get Json Response in Arraylist from List<Item> using RxJava and Kotlin","<android><kotlin><retrofit2><rx-kotlin>","2","1","","","","CC BY-SA 3.0"
"49541333","1","49543422","","2018-03-28 18:05:30","","0","737","<p>Let imagine situation on Kotlin, when we try get request but hasn't internet connection and we get error, then show AlertDialog, and we need retry request if user click on ""positive button"".</p>

<p>This method check for exist user by phone number:</p>

<pre><code>override fun checkPhone(phone: String, context: Context) {
    view?.let {
        it.showOrHideProgressBar(true)
        apiManager.checkPhone(phone)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe({ result -&gt;
                    view?.showOrHideProgressBar(false)
                    if (result.user_exists) {
                        view?.showLogin()
                    } else {
                        val code = result.confirmation_code
                        confirmPhone(phone, code, context)
                    }
                }, { error -&gt;
                    handleAnyError(error, context)
                }).addToCompositeDisposable(compositeDisposable)
    }
}
</code></pre>

<p>And here common method for handle errors:</p>

<pre><code>private fun handleAnyError(it: Throwable, context: Context) {
    view?.showOrHideProgressBar(false)
    when (it) {
        is SocketTimeoutException -&gt; showDialogWithException(context)
        is UnknownHostException -&gt; showDialogWithException(context)
        else -&gt; {
            if (it.message.equals(MESS_429)) {
                view?.showAnyError(context.getString(R.string.err_429))
            } else if (it.message.equals(MESS_422)) {
                view?.showAnyError(context.getString(R.string.err_422))
            }
        }
    }
}
</code></pre>

<p>Finally, method to show dialog suggesting retrying request when click positive button:</p>

<pre><code>fun showDialogWithException(context: Context) {
if (!(context as Activity).isFinishing) {
    DialogInternetUtils().showOkDialog(
            context,
            context.getString(R.string.no_internet_connection),
            DialogInterface.OnClickListener
            { dialogInterface, i -&gt;
                dialogInterface?.dismiss()
                if (i == Dialog.BUTTON_NEGATIVE) {
                    dialogInterface!!.dismiss()
                    return@OnClickListener
                } else if (i == Dialog.BUTTON_POSITIVE) {
                    // here handle click button positive, need retry request
                }
            })
}
</code></pre>

<p>}</p>

<p>Please, help me finish handle click on positive button to retry request.
I guess, need handle error in methods <code>.doOnError()</code> or <code>.onErrorResumeNext()</code> but I'm stuck here...</p>
","7369357","","","","","2018-03-28 20:15:59","Kotlin, how can retry request if get error when tap on button of dialog","<android><kotlin><kotlin-extension><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"49644088","1","","","2018-04-04 06:19:27","","0","413","<p>This is my code template</p>

<pre><code>getLastMessageSingle()
.flatmap(
    message-&gt;
    if(message.image==null)
        Single.Just(message)
    else
        Single.zip(t1,t2,BiFunction&lt;String,String,String&gt;{
            s1,s2-&gt;
          //body sets data to message

          message
        })
)
//subscribe part
</code></pre>

<p>I found that Single.Just will execute but zip part is never executed. Am i doing any thing wrong or flat function does not support zip in it.</p>

<p>Any help will be appreciated thanks.</p>

<p>Solution:</p>

<p>It was my mistake second single t2 did not produce a response.</p>
","5311864","","5311864","","2018-04-04 06:56:18","2018-04-04 06:56:18","RxKotlin zip inside flatmap","<android><reactivex><rx-kotlin>","2","3","","","","CC BY-SA 3.0"
"49782036","1","49782471","","2018-04-11 18:22:43","","0","1420","<p>I have this problem. I'm trying to sync a local database into my android app with a remote app. I'm creating the logic to upload the new info created locally and the server responds with the remote id save it in the server. To archive this, I'm using a method that takes an array of objects an return an Observable which emit the response of the server for each element.
Like this.</p>

<pre><code>val dailyEntries = App.db.dailyEntryDao().getDailyEntriesCreated()
            dailyEntries.sync(context) //Return an observable
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({                        
                        val response = DailyEntry(it)//Creates a daily entry using 
                                                      the response from the server
                        thread {                                
                          App.db.dailyEntryDao().update(response)
                        }
                    }, {
                        it.printStackTrace()
                    }, {
                        uploadEnclosures()
                    })
</code></pre>

<p>How you can see, in the onSuccess from the current observable calls another method. It uses the same logic and is showing ahead. </p>

<pre><code>private fun uploadEnclosures() {
        thread {
            val enclosures = App.db.enclosureDao().getEnclosuresCreated()
            enclosures.sync(context)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        val response = Enclosure(it)
                        thread {                                
                            App.db.enclosureDao().update(response)
                        }
                    }, {
                        it.printStackTrace()
                    }, {
                        uploadSmokeTest()
                    })
        }
    }
</code></pre>

<p>It goes on with all the tables. Always we perform the update of the next table in the onSuccess of the current Observable. It is done like this because i need to make the sync in a specific order.</p>

<p>My question is, Is there a way to merge all these Observables in just one to perform a single Subscribe and controlling each onNext emotion?</p>

<p>Thanks for the answers </p>
","5420543","","","","","2018-04-11 19:16:21","How to Merge multiple Observables with diferents call backs into one single Stream?","<android><kotlin><rx-java><reactive-programming><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"49851127","1","","","2018-04-16 06:50:47","","1","279","<p>I was looking other questions but this one is using a different method.</p>

<p>I‚Äôm using MVVM in my Android app.</p>

<p>Actually this is the way that I‚Äôm getting data from my server: </p>

<ul>
<li>Inject dataManager into viewModel.</li>
<li>viewModel calls dataManager->fetchUsers</li>
<li>fetchUsers make request to server and return an Observable of Several which in this case should be Several but it‚Äôs generic.</li>
<li>viewModel subscribe to this request and expect a Several.</li>
<li>At this point everything works besides Several doesn‚Äôt have a list of User. This several have a list of LinkedTreeMap</li>
</ul>

<p><a href=""https://i.stack.imgur.com/UDn9X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UDn9X.png"" alt=""enter image description here""></a> </p>

<p>I tried to change my dataManager to return a string then map the response in my viewModel but the thing with this is that I will have to do that in every request.</p>

<p>Also I tried to map the request in my dataManager but I got the same link tree map array. </p>

<p>The thing with TypeToken approach is that I have to map in my viewModel. </p>

<p><strong>UPDATED</strong></p>

<p>UsersViewModel</p>

<pre><code> private fun fetchUsers() {
        isLoading.set(false)
        compositeDisposable += dataManager.GET&lt;User&gt;(classJava = User::class)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe( { response -&gt;
                    isLoading.set(false)
                   // Here the response should be a several with a list of users.
                }, { err -&gt;
                    isLoading.set(false)
                })
    }
</code></pre>

<p>GET function:</p>

<pre><code> override fun &lt;T&gt; GET(classJava: KClass&lt;*&gt;): Single&lt;Several&lt;T&gt;&gt; {

    return Rx2AndroidNetworking.get(""EndPoint"")
            .addHeaders(""Authorization"",  apiHeader.protectedAPIHeader.accessToken!!)
            .setOkHttpClient(APIClient.getUnsafeClient())
            .build()
             // Also I tested with
             // .getObjectSingle(Several::class.java) // The thing is that I can't assign the type &lt;T&gt; with this approach.
            .stringSingle
            .map {

                val fromJSON = fromJson&lt;Several&lt;T&gt;&gt;(it)
                fromJSON

            }
}
</code></pre>

<p>fromJson function:</p>

<pre><code>inline fun &lt;reified T&gt; fromJson(json: String): T = Gson().fromJson(json, object: TypeToken&lt;T&gt;() {}.type)
</code></pre>

<p>Several.kt</p>

<pre><code>data class Several&lt;T&gt;(val items: MutableList&lt;T&gt;)
</code></pre>

<p>If I change my GET function to return a String then in UsersViewModel I add a .map like this</p>

<pre><code>private fun fetchUsers() {
        isLoading.set(false)
        compositeDisposable += dataManager.GET&lt;User&gt;(classJava = User::class)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .map(
                    val severalUsers = fromJson&lt;Several&lt;User&gt;&gt;(it)
                    severalUsers 

                )
                .subscribe( { response -&gt;
                    isLoading.set(false)
                   // usersLiveData.value = response
                }, { err -&gt;
                    Log.e(""tag"", ""Ocurred some error"")
                    isLoading.set(false)
                })
    }
</code></pre>

<p>Then I would have a list of Users as expected but What I dont want to do is map the response in UsersViewModel because I would have to do in every single request that expect a list of items.</p>

<p>Is there any way that I could get a several object without map in my viewmodel?</p>
","6606971","","6606971","","2018-04-16 13:40:01","2018-04-16 13:40:01","Kotlin Generic List Parsing","<android><kotlin><android-databinding><kotlin-extension><rx-kotlin>","0","3","","","","CC BY-SA 3.0"
"49929073","1","49931641","","2018-04-19 19:45:02","","0","300","<p>What I would like to do is create a function which runs another function every second. The second function returns <code>Observables&lt;A&gt;</code> and I want the first function to return <code>Observables&lt;A&gt;</code> as well instead of <code>Observable&lt;Observable&lt;A&gt;&gt;</code></p>

<p>for example:</p>

<pre><code>private A calcA(){
   ...
   return new A(...)
}

public Observable&lt;A&gt; getAs(){
   return Observable.create( subscriber -&gt; {
      Bool condition = ...
      do {
         subscriber.onNext(calcA())
      } while (condition)
      subscriber.onComplete()
   })
}

public Observable&lt;A&gt; pollAs(){
   return Observable.create(subscriber -&gt; {
      do {
         subscriber.onNext(getAs()) // Flatten here I guess
         Thread.sleep(1000)
      } while(true)
   })
</code></pre>

<p>So I would like to do something similar (I tried to write this in a Java-ish way, but I will use Kotlin)</p>
","2092686","","","","","2018-04-20 20:22:19","Flatten Observable of Observables","<rx-java><observable><reactivex><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"50019891","1","50056968","","2018-04-25 10:26:22","","0","1023","<p>My outer <code>RecyclerView</code> crashes either with</p>

<pre><code>IllegalArgumentException: Scrapped or attached views may not be recycled. isScrap:false isAttached:true...
</code></pre>

<p>or</p>

<pre><code>IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first.
</code></pre>

<p>Like the title suggests I have an <code>RecyclerView</code> in the list item layout of the first <code>RecyclerView</code>. This layout is used to display messages and the 
inner <code>RecyclerView</code> to display attachments that come with the message. The inner <code>RecyclerViews</code> visibility is set to either <code>GONE</code> or <code>VISIBLE</code> depending whether the message has any attachments or not. The simplified outer list item layout looks like this</p>

<pre><code>ConstraintLayout
    TextView
    TextView
    TextView
    RecyclerView
</code></pre>

<p>And the part of the adapter that handles the inner <code>RecyclerView</code> looks like this</p>

<pre><code>private fun bindFiles(message: Message?) = with(itemView) {
      if (message != null &amp;&amp; message.attachments.isNotEmpty())
      {
            sent_message_attachments.setAsVisible()
            sent_message_attachments.layoutManager = GridLayoutManager(this.context,Math.min(message.attachments.size,3))
            sent_message_attachments.adapter = AttachmentAdapter(message.attachments)
            sent_message_attachments.itemAnimator = null
            sent_message_attachments.setHasFixedSize(true)
      }
      else{
            sent_message_attachments.setAsGone()
            sent_message_attachments.adapter = null
            sent_message_attachments.layoutManager = null
      }
    }
</code></pre>

<p>The bug has something to do with the way I fetch the attachments in the inner adapter since once I disable the part that start the download process, everything is fine. There's no problem when loading images from the device, but once I start the download process, everything goes to hell. This is the part that handles images and kicks off the download process in the inner adapter. I have functions for videos and for other file types that are pretty much the same exact thing but use slightly different layout.</p>

<pre><code>private fun bindImage(item: HFile?) = with(itemView) {
      if (item != null)
      {
        if (item.isOnDevice &amp;&amp; !item.path.isNullOrEmpty())
        {
          if (item.isGif)
          {
            attachment_image.displayGif(File(item.path))
          }
          else
          {
            attachment_image.displayImage(File(item.path))
          }
        }
        else
        {
          //TODO: Add option to load images manually
          FileHandler(item.id).downloadFileAsObservable(false)
              .subscribeOn(Schedulers.io())
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe(
                  { progress -&gt;
                    //TODO: Show download process
                  },
                  { error -&gt; 
                  error.printStackTrace()
                  //TODO: Enable manual retry 
                  },
                  { notifyItemChanged(adapterPosition)} //onComplete
              )
        }
      }
  }
</code></pre>

<p>I use the same structure as above in my <code>DiscussionListAdapter</code> to load discussion portraits (profile pictures etc.) and it does not have the same issue.</p>

<p>These are the extensions functions used to inflate the viewHolders and to display the images</p>

<pre><code>fun ViewGroup.inflate(layoutRes: Int): View
{
  return LayoutInflater.from(context).inflate(layoutRes, this, false)
}

fun ImageView.displayGif(file:File){
  GlideApp.with(context).asGif().load(file).transforms(CenterCrop(), RoundedCorners(30)).into(this)
}

fun ImageView.displayImage(file:File){
  GlideApp.with(context).load(file).transforms(CenterCrop(), RoundedCorners(30)).into(this)
}
</code></pre>

<p>I've been on this for the past couple of days and just can't get my head around it. Any help in any direction is greatly appreciated. I know my explanations can be a bit all over the place so just ask for clarification when needed :)</p>

<h2>UPDATE</h2>

<p>I have now been able to produce this with a <code>GridLayout</code> as well as with <code>RecyclerView</code>. It's safe to assume that the nested <code>RecyclerViews</code> were not the culprit here. I even tried to ditch the Rx-piece that handled loading the images and created an <code>IntentService</code> for the process, but the same crashes still occur.</p>

<p>With <code>GridLayout</code> I mean that instead of having another adapter to populate the nested <code>RecyclerView</code> I use only one adapter to populate the message and to inflate and populate views for the attachments as well and to attach those views to the nested <code>GridLayout</code>.</p>

<p>The crash happens when I start to download a file and then scroll the view, that is supposed to show the downloaded file, out of the screen. That view should get recycled but for some reason the download process (which in my test cases only takes around 100ms-400ms) causes the app to throw one of the two errors mentioned in the original question. It might be worth noting that I'm using <code>Realm</code> and the adapter takes in a <code>RealmResults&lt;Message&gt;</code> list as it's dataset. My presenter looks for changes in the list and then notifies the adapter when needed (changed due to the implementation of <code>IntentService</code>).</p>

<p>This is how I'm capable to reproduce this time and time again:</p>

<ol>
<li>Open a discussion that has messages with attachments</li>
<li>Start to scroll upwards for more messages</li>
<li>Pass a message with an attachment and scroll it off screen while it's still loading</li>
<li>Crash</li>
</ol>

<p>There is no crash if I stop and wait for the download to complete and everything works as intended. The image/video/file gets updated with a proper thumbnail and the app wont crash if I scroll that out of view.</p>

<h2>UPDATE 2</h2>

<p>I tried swapping the nested <code>ViewGroup</code> for a single <code>ImageView</code> just to see is the problem within the nestedness. Lo and behold! It still crashes. Now I'm really confused, since the <code>DiscussionListAdapter</code> I mentioned before has the same exact thing in it and that one works like a charm... My search continues. I hope someone, some day will benefit from my agony.</p>

<h2>UPDATE 3</h2>

<p>I started to log the parent of every <code>ViewHolder</code> in the <code>onBindViewHolder()</code> function. Like expected I got <code>nulls</code> after <code>nulls</code> after <code>nulls</code>, before the app crashed and spew this out.</p>

<pre><code>04-26 21:54:50.718 27075-27075/com.hailer.hailer.dev D/MsgAdapter: Parent of ViewHolder: android.view.ViewOverlay$OverlayViewGroup{82a9fbc V.E...... .......D 0,0-1440,2168}
</code></pre>

<p>There's a method to my madness after all! But this just poses more questions. Why is <code>ViewOverlay</code> used here? As a part of RecyclerView or as a part of the dark magicians plans to deprive me of my sanity?</p>

<p><strong>Sidenote</strong></p>

<p>I went digging into <code>RecyclerViews</code> code to check if I could find a reason for the <code>ViewOverlay</code>mystery. I found out that <code>RecyclerView</code> calls the adapters <code>onCreateViewHolder()</code> function only twice. Both times providing itself as the <code>parent</code> argument for the function. So no luck there... What the hell can cause the item view to have the <code>ViewOverlay</code> as it's parent? The parent is an immutable value, so the only way for the <code>ViewOverlay</code> to be set as the parent, is for something to construct a new <code>ViewHolder</code> and supply the <code>ViewOverlay</code> as the parent object.</p>

<h2>UPDATE 4</h2>

<p>Sometimes I amaze myself with my own stupidity. The <code>ViewOverlay</code> is used because the items are being animated. I didn't even consider this to be an option since I've set the <code>itemAnimator</code> for the <code>RecyclerView</code> as <code>null</code>, but for some odd reason that does not work. The items are still being animated and that is causing this whole charade. So what could be the cause of this? <em>(How I chose to ignore the moving items, I do not know, but the animations became very clear when I forced the app to download same picture over and over again and the whole list went haywire.)</em></p>

<p>My <code>DiscussionInstanceFragment</code> contains the RecyclerView in question and a nested ConstraintLayout that in turn contains an <code>EditText</code> for user input and a send button.</p>

<pre><code>    val v = inflater.inflate(R.layout.fragment_discussion_instance, container, false)
    val lm = LinearLayoutManager(context)
    lm.reverseLayout = true
    v.disc_instance_messages_list.layoutManager = lm
    v.disc_instance_messages_list.itemAnimator = null
    v.disc_instance_messages_list.adapter = mPresenter.messageAdapter
</code></pre>

<p>This is the piece that handles the initialization of the <code>RecyclerView</code>. I'm most definitely setting the <code>itemAnimator</code> as <code>null</code>, but the animations just wont stop! I've tried setting the <code>animateLayoutChanges</code> xml attribute on the root <code>ConstraintLayout</code> and on the <code>RecyclerView</code> but neither of them worked. It's worth mentioning that I also checked whether the <code>RecyclerView</code> had an <code>itemAnimator</code> in different states of the program, and every time I check the animator, it is null. So what is animating my <code>RecyclerView</code>?!</p>
","5778533","","5778533","","2018-04-26 22:50:31","2018-05-09 10:17:39","Setting RecyclerViews itemAnimator to null does not remove animations","<android><android-recyclerview><kotlin><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"50293583","1","50294698","","2018-05-11 13:36:22","","5","3030","<p>I have a list <code>List&lt;FileModel&gt;</code> </p>

<p><code>FileModel</code> is just a class contains <code>id: Int</code></p>

<p><code>id</code> - is ID of photo file I need to fetch and cast to Bitmap</p>

<p>I have a request:</p>

<pre><code>fun getFile(fileId: Int): Single&lt;ResponseBody&gt;
</code></pre>

<p>This request returns <code>ResponseBody</code> which we can cast to Bitmap</p>

<p>And</p>

<pre><code>fun generatePhoto(responseBody: ResponseBody): Single&lt;Bitmap?&gt;
</code></pre>

<p>What I want is to create a function </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    // Execute getFile(...) for each item in the list
    // Cast getFile(...) result to Bitmap using generatePhoto(...)
    // Return a list of Bitmaps
}
</code></pre>

<p>I've tried something like this but it's completely wrong </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    return Observable.fromIterable(list)
        .flatMap { getFile(it.id) }
        // How to call generatePhoto(...) here?
}
</code></pre>
","4932519","","4932519","","2018-05-11 13:41:37","2018-05-11 14:52:25","RxJava2. Execute a request for every item in a list","<android><kotlin><rx-java2><rx-android><rx-kotlin>","3","2","","","","CC BY-SA 4.0"
"50536642","1","50566723","","2018-05-25 20:46:03","","0","265","<p>I have a scenario where I have a function, scanForTargets, that returns an Observable of type FoundNumber. In FoundNumber I just need an ID field I can grab out of it. As each element comes back in the scanResults Observable, I want to check to see if the name field matches one of the names on a target list. If so, then I want to emit that. For example, if I am looking for numbers 1, and 2, and scanForTargets() emits back 1, 2, 3, and 4, then I want scanForValues to emit back only 1 and 2.</p>

<p>The caveat is that I only want to continue doing this until either:
 1) A time period elapses (in which case I throw and error)
 2) All items on the String list are found before the timeout.</p>

<p>What I have so far looks like this, but I cannot get it to work for me mostly due to the shortcut of stopping once/if all of the targets are found before the timeout. </p>

<pre><code>fun scanForValues(targetList: List&lt;String&gt;): Observable&lt;FoundNumber&gt; {
    val scanResult = scanForTargets()

    return scanResult.doOnNext {scanResult -&gt; Log.d(TAG, ""Found potential target: "" + scanResult.name) }
            .filter(TargetPredicate(targetList)) //See if it's one of those we want
            .timeout(5, TimeUnit.SECONDS) //Wait a max of 5 seconds to find all items
            .doOnError { Log.w(TAG, ""Failed to scan""}"") }
            .map{s-&gt;scanResult.name}  
}

class TargetPredicate(private val targetList: List&lt;String&gt;) : Predicate&lt;ScanResult&gt; { override fun test(scanResult: ScanResult): Boolean {
        if(scanResult == null) {
            return false
        }
        return scanResult.name in targetList 
    }
}
</code></pre>

<p>How can I also add the check to stop if I find all of the items in the list? I can't just add another predicate right?</p>

<p>Thanks.</p>

<p>Update: As requested, here is some data to show what I mean.</p>

<p>Let's say that the scanForTargets() and supporting code looks like this:</p>

<pre><code>var emittedList: List&lt;String?&gt; = listOf(null, ""0"", ""1"", ""2"", ""3"")


fun scanForTargets(): Observable&lt;FoundNumber&gt; = Observable
    .intervalRange(0, emittedList.size.toLong(), 0, 1, TimeUnit.SECONDS)
    .map { index -&gt; FoundNumber(emittedList[index.toInt()]) }

data class FoundNumber(val targetId: String?)
</code></pre>

<p>Now if scanForValues was called with a list of 1 and 2, then it should emit back an Observable of 1 and then 2.</p>
","443654","","443654","","2018-06-05 21:02:28","2018-06-06 08:54:17","Checking a list and timing out if all entries not found in RxJava/RxKotlin","<rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"50625166","1","","","2018-05-31 13:10:41","","1","1903","<p><em>I have seen other questions here related to this error but still not able to fix. Plus I'm asking this question because unlike other questions here, I'm getting this error only when I convert the code to Kotlin from Java.</em></p>

<p>I'm using this same RxJava code in Java, it works fine. 
I converted to Kotlin and it gives this error - </p>

<blockquote>
  <p>Kotlin Compilation Error : None of the following functions can be
  called with the arguments supplied</p>
</blockquote>

<pre><code>var observable : Observable&lt;Bitmap&gt; = Observable.just(bitmap)

var observer:Observer&lt;Bitmap&gt; = Observer&lt;Bitmap&gt;() {
                fun onSubscribe(d: Disposable) {
                    disposable = d
                }
                fun onNext(orientedBitmap:Bitmap) {
                    // do something
                }
                fun onError(e:Throwable) {
                }
                fun onComplete() {

                }
            }

observable.subscribeOn(Schedulers.io())
          .observeOn(AndroidSchedulers.mainThread())

          // It shows the error here
          .subscribe(observer)
</code></pre>

<p>Can anyone explain what's wrong here?</p>
","1724453","","","","","2018-05-31 14:42:01","Error: None of the following functions can be called with the arguments supplied when converted to Kotlin from Java","<android><kotlin><rx-java><android-bitmap><rx-kotlin>","1","3","","","","CC BY-SA 4.0"
"50724513","1","50731185","","2018-06-06 15:46:08","","7","9522","<p>I am stuck at this problem, which should be fairly simple. I need subscriber to execute a code block when the <code>Maybe</code> has completed as an <code>Empty Maybe</code>. I found that </p>

<ol>
<li>we can pass default Maybe value or use switchIfEmpty but I feel both are hacky. </li>
<li>Also there is a subscribe function which takes onComplete function (along with handlers for other two events), but onComplete does not take any argument which can be used to find if maybe was completed empty.</li>
<li>Another way could be <code>Maybe.isEmpty.blockingGet()</code>, but it is dirty too.</li>
</ol>

<p>I have tried following (<em>Kotlin Syntax</em>):-</p>

<pre><code>fun &lt;T&gt; Maybe&lt;T&gt;.subscribeWithEmptyHandler(onSuccess: (T) -&gt; Unit, onError: (Throwable) -&gt; Unit, onEmpty: () -&gt; Unit) {
    this.isEmpty.subscribe({ if (it) onEmpty() }, { onError(it) })
    this.subscribe({ onSuccess(it) }, { onError(it) })
}
</code></pre>

<p>But as expected it is running subscription twice, tested here:-</p>

<pre><code>Maybe.create&lt;Int&gt; {
    println(""subscribing"")
    //Remove line below to create Empty Maybe
    it.onSuccess(5)
    it.onComplete()
}
    .subscribeWithEmptyHandler({println(""success"")},{println(""error"")},{println(""empty"")})
</code></pre>

<p>Could somebody please suggest neater way to solve this?</p>
","1699956","","1000551","","2019-01-18 11:23:45","2021-03-14 22:49:50","RxJava Maybe: Any neat way to handle Empty case?","<kotlin><rx-java><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"50937317","1","50937413","","2018-06-19 21:40:58","","0","1288","<p>There seems to be a limit to the number of Observables to use as parameters in the zip method for Kotlin. If this is accurate, what is the best alternative?</p>

<p>For instance, when I use 9 parameters it works as expected. When I add a 10th parameter I receive the error <strong>Cannot infer a type for this parameter. Please specify it explicitly</strong></p>

<pre><code>Observable.zip(
            //TODO: parameterize exchange symbols based on pair
            methodOne() as Observable&lt;Any&gt;),
            methodTwo() as Observable&lt;Any&gt;),
            methodThree() as Observable&lt;Any&gt;),
            methodFour() as Observable&lt;Any&gt;),
            methodFive() as Observable&lt;Any&gt;),
            methodSix() as Observable&lt;Any&gt;),
            methodSeven() as Observable&lt;Any&gt;),
            methodEight() as Observable&lt;Any&gt;),
            methodNine() as Observable&lt;Any&gt;),
            { oneResult, twoResult, threeResult, fourResult, fiveResult, sixResult, sevenResult, eightResult, nineResult -&gt;
                    //logic here applying computation to results
            })
            .subscribe(
                    {},
                    {
                        println(String.format(""Error: %s"", it.message))
                    })
            .unsubscribe()
}
</code></pre>
","2253682","","2253682","","2018-06-19 21:46:00","2018-06-19 21:54:55","Is There A Limit to The Number of Observables in .zip Method?","<java><android><kotlin><rx-java><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"50939047","1","50939320","","2018-06-20 01:43:26","","0","887","<p>Sorry nooby kotlin question</p>

<pre><code>func someThingElse(): Observable&lt;String&gt; {
   return Observable.just(""aasd"")
} 

fun doSomething(): Observable&lt;Void&gt; {
    return someThisElse().fetch().map { () } 
}
</code></pre>

<p>How do i return an observable of void?
I tried <code>void</code>, <code>Void()</code>, <code>Void</code></p>
","242769","","242769","","2018-06-20 02:01:45","2018-06-20 21:24:17","RXKotlin how do you map to void?","<android><kotlin><rx-java><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"50945144","1","50945458","","2018-06-20 09:46:04","","0","480","<p>Here is my Retrofit Interface and creation code:</p>

<pre><code>interface SSApi {
companion object {
    private fun create(): SSApi {
        val httpClient = OkHttpClient().newBuilder()
        val networkInterceptor = Interceptor { chain -&gt;
            val request = chain.request()?.newBuilder()?.addHeader(""api-key"", SSConstants.API_KEY)?.build()
            chain.proceed(request!!)
        }

        val loggingInterceptor = HttpLoggingInterceptor()
        loggingInterceptor.level = HttpLoggingInterceptor.Level.BODY

        httpClient.addNetworkInterceptor(networkInterceptor).addInterceptor(loggingInterceptor)

        val retrofit = Retrofit.Builder()
                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create())
                .baseUrl(SSConstants.BASE_URL)
                .client(httpClient.build())
                .build()

        return retrofit.create(SSApi::class.java)
    }

    val api by lazy {
        SSApi.create()
    }

    var disposable: Disposable? = null
}

@GET
fun getWeatherInfo(@Url url: String): Observable&lt;OpenWeatherMapInfo&gt;
}
</code></pre>

<p>And here is how I use the <code>disposable</code>:</p>

<pre><code>    private fun getWeather() {
    disposable = api
            .getWeatherInfo(SSConstants.OPEN_WEATHER_MAP_API_ENDPOINT)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { results -&gt; Log.i(""Dale"", results.toString())},
                    { error -&gt; Log.i(""Dale"", error.message)}
            )
    }
</code></pre>

<p>When I execute the request, I can see that it my <code>OPEN_WEATHER_MAP_API_ENDPOINT</code> still appends to my <code>baseUrl</code>. </p>

<p>Here is my Constants class for reference:</p>

<pre><code>object SSConstants {
const val OPEN_WEATHER_MAP_API_ENDPOINT = ""api.openweathermap.org/data/2.5/weather?q=Catbalogan,PH&amp;units=metric""
const val BASE_URL = ""https://api.xxx.xxx/""
}
</code></pre>
","6243778","","6243778","","2018-06-20 09:53:29","2018-06-20 10:01:27","Retrofit Dynamic URL still appends to the Base URL","<android><kotlin><retrofit2><rx-android><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"50949942","1","","","2018-06-20 13:53:49","","0","68","<p>I'm working on an Android App. I have a list of photos loaded in memory. I want to make use of Reactive library, so I declare a memory-base datasource where I save the list:</p>

<pre><code>    @Singleton
    class MemoryPhotosSource @Inject constructor() {
         var photos: MutableList&lt;Image&gt; = mutableListOf()
         ...

         // Here is my function to add items to list.
         fun addPhoto(image: Image) {
              photos.add(image)
         }

         // Here is my function to list the items.
         fun listPhotos(): List&lt;Image&gt; = photos

         // Here is my function to remove items from list.
         fun removePhoto(image: Image): Image {
               photos.remove(image)
               return image
         }
    }
</code></pre>

<p>Then, I have a ViewModel where I call these methods:</p>

<pre><code>class CreateDocumentFromPhotosViewModel @Inject constructor(): ViewModel() {
       @Inject
       lateinit var source: MemoryPhotosSource

       fun listImages(): Observable&lt;List&lt;Image&gt;&gt; = Observable.fromCallable {
           source.listPhotos()
       }.applySchedulers()

       fun addImage(image: Image) {
           source.addPhoto(image)
       }

       fun removeImage(image: Image): Image {
           source.removePhoto(image)
           return image
       }
}
</code></pre>

<p>Finally, I subscribe in my application:</p>

<pre><code>    dis add viewModel.listImages()
            .subscribe {
                adapter.data = it
            }

    dis add onDelete
            .map { viewModel.removeImage(it) }
            .map { showSnackbar(parentView, resources.getString(R.string.document_removed), resources.getString(R.string.undo), it)}
            .map { it.subscribe { viewModel.addImage(it) } }
            .subscribe()
</code></pre>

<p>Listing and adding images work nicely. However, when I press the delete button, which publish in the onDelete subject, the snackbar is shown, but no change is performed to the RecyclerView adapter. Debugging, I noticed that the <code>removePhoto</code> function is being called in <code>MemoryPhotosSource</code> class, and the list is being successfuly modified. However, it does not emit the changes, that's why the RecyclerView is not updated. I confirmed this behavior by leaving the application and entering again, which forced the repainting of the Recycler, and then, the removed element didn't show up, as it should be. So, I think the problem is the list doesn't emit the changes when an item is removed. </p>

<p>Does anybody know a way to solve this? Any help would be much appreciated.</p>

<p>Thanks!</p>
","9858922","","","","","2018-06-20 14:00:04","List not emitting on remove item (RxKotlin)","<android><kotlin><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"50992991","1","51000130","","2018-06-22 17:31:32","","2","1584","<p>Can someone please explain me why <code>PublishSubject</code> is not working nicely with <code>firstOrError()</code>?</p>

<p>I'm expecting <code>firstOrError</code> to return a <code>NoSuchElementException</code> when the <code>PublishSubject</code> is created without any value.</p>

<p>I wrote some tests in order to better explain the problem:</p>

<pre><code>@Test
fun `test one`() {
    // THIS TEST FAILS
    val publishSubject = PublishSubject.create&lt;Boolean&gt;()

    val testSubscriber = publishSubject
        // .toFlowable(BackpressureStrategy.LATEST) // With or without this doesn't make any difference
        .firstOrError()
        .test()

    testSubscriber
        .assertNotComplete()
        .assertError(NoSuchElementException::class.java)
}

@Test
fun `test two`() {
    // THIS TEST PASSES
    val flowable = Flowable.empty&lt;Boolean&gt;()

    val testSubscriber = flowable
        .firstOrError()
        .test()

    testSubscriber
        .assertNotComplete()
        .assertError(NoSuchElementException::class.java)
}
</code></pre>
","3096313","","1115491","","2018-06-22 20:51:45","2018-06-23 21:42:48","PublishSubject does not work with firstOrError()","<android><rx-java><rx-java2><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"51072877","1","","","2018-06-27 23:49:45","","0","26","<p>I tried the following:</p>

<pre><code>$ git clone https://github.com/ReactiveX/RxKotlin.git    
$ cd RxKotlin/    
$ gradle build
</code></pre>

<p>It fails with:</p>

<blockquote>
  <p>...FAILURE: Build failed with an exception.</p>
  
  <ul>
  <li><p>Where: Build file '/home/myuser/RxKotlin/build.gradle' line: 13</p></li>
  <li><p>What went wrong: A problem occurred evaluating root project 'rxkotlin'.</p>
  
  <blockquote>
    <p>org/gradle/api/internal/project/AbstractProject</p>
  </blockquote></li>
  </ul>
</blockquote>
","1988515","","","","","2018-06-28 00:14:16","RxKotlin repo gradle build compilation fails with gradle 4.7 (JDK 1.8)","<kotlin><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"51144111","1","51144570","","2018-07-02 21:44:56","","0","353","<p>I have an function in <code>@Dao</code>. Lets call that class <code>DaoClass</code></p>

<p><code>abstract fun getData() : Flowable&lt;List&lt;Data&gt;&gt;</code></p>

<p>Now, I want to check if list of data returned is empty or not. I dug through the DaoClass_Impl (generated at build time) and I found out that the Flowable won't be empty. So, </p>

<p><code>getData().isEmpty</code> will always return false.</p>

<p>So what I did was 
<code>getData().singleOrError().map{it.isEmpty()}</code> to return if the returned list is actually empty. </p>

<p>But I am having problem as the value is not getting emitted.</p>
","1042124","","","","","2018-07-02 22:48:44","Converting Flowable<List<T>> to Single<Boolean>","<android><kotlin><android-room><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"51185759","1","51186490","","2018-07-05 07:39:56","","3","3527","<p>I have code that does blocking operation in while loop (downloads some data from a server). Client does not know how many items are going to be returned in each step. Loop breaks when N items are downloaded.</p>

<pre><code>val n = 10
val list = ArrayList&lt;T&gt;()

while (list.size &lt; n) {
    val lastItemId = list.last()?.id ?: 0
    val items = downloadItems(lastItemId)
    list.addAll(items)
}
</code></pre>

<p><code>downloadItems</code> performs blocking HTTP call and returns list. Now let's assume <code>downloadItems</code> changes and new return type is <code>Observable&lt;Item&gt;</code>. How could I change the code to use RxJava without performing something like <code>blockingGet</code>?</p>
","1740335","","1740335","","2018-07-05 16:54:07","2018-07-05 18:24:13","Converting loop with condition into RxJava stream","<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 4.0"
"51368000","1","","","2018-07-16 18:25:22","","1","508","<p>I am using following Kotlin code to generate proxy (This will also generate Rx methods)</p>

<pre><code>@ProxyGen
@VertxGen
interface JobService {
    @Fluent
    fun getCertain(jobId: Int, handler: Handler&lt;AsyncResult&lt;Job?&gt;&gt;): JobService
}
</code></pre>

<p>When I see generated Rx Code it is as follows.</p>

<pre><code>public Single&lt;Job&gt; rxGetCertain(int jobId) { 
   return new io.vertx.reactivex.core.impl.AsyncResultSingle&lt;Job&gt;(handler -&gt; {
     getCertain(jobId, handler);
   });
}
</code></pre>

<p><strong>Issue:-</strong></p>

<p>Unfortunately i am not able to use this in Kotlin as kotlin won't allow null values for non-null fields and it is throwing following exception.</p>

<pre><code>java.lang.IllegalArgumentException: Parameter specified as non-null is null
</code></pre>

<p>How do i force Vertx CodeGen to generate return type as MayBe so that my code works without any issues in kotlin.</p>
","2631567","","","","","2019-02-01 08:00:01","How to Force Vertx Rx CodeGen To Generate MayBe As Return Type","<kotlin><rx-java2><vert.x><rx-kotlin><codegen>","1","4","","","","CC BY-SA 4.0"
"51422390","1","","","2018-07-19 12:11:03","","0","1311","<p>I tried it by the following program but it shows the error that kotlin variable is expected:  </p>

<p>[<img src=""https://i.stack.imgur.com/eQqNp.png"" alt=""enter image description here""></p>
","9921917","","1797950","","2018-07-19 12:28:13","2019-03-14 09:52:37","can we swap two numbers in kotlin using two variables and take input from user?","<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin><kotlin-interop>","4","2","","","","CC BY-SA 4.0"
"51679808","1","","","2018-08-03 20:35:48","","2","231","<p>I use rxjava to read from the room database on the Schedulers.io thread. I've noticed that when my app is killed and reopened it always crashes with </p>

<blockquote>
  <p>Cannot access database on the main thread since it may potentially
  lock the UI for a long period of time.</p>
</blockquote>

<p>I use MVVM architecture with Dagger and instantiate view model with lazy</p>

<pre><code>private val viewModel by lazy { ViewModelProviders.of(this, viewModelFactory).get(StudentsListViewModel::class.java) }
</code></pre>

<p>All my requests to database look like this: </p>

<pre><code>compositeDisposable.add(viewModel.students
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnNext {
                    &lt;I do things here&gt;
                }
                .doOnError { it.printStackTrace() }
                .subscribe()
        )
</code></pre>

<p>I kill disposable onDestroy with </p>

<pre><code>compositeDisposable.apply {
            clear()
            dispose()
        }
</code></pre>

<p>So, why is it crushing on recreate and what is it trying to do on the main thread?</p>

<p>My ModelView class:</p>

<pre><code>class StudentsListViewModel@Inject
constructor(private val studioRepository: StudioRepository): ViewModel() {

val students: Flowable&lt;List&lt;Student&gt;&gt; = studioRepository.students

fun getStudentById(studentId: Int): Maybe&lt;Student&gt; {
    return studioRepository.getStudentById(studentId)
}

fun insertStudent(student: Student): Unit = studioRepository.insertStudent(student)
fun insertStudentFlat(student: Student) = studioRepository.insertStudentFlat(student)

fun updateStudent(student: Student) {
    studioRepository.updateStudent(student)
}

fun deleteAllStudents() {
    studioRepository.deleteAllStudents()
}

fun getStudentsNames(): Flowable&lt;List&lt;String&gt;&gt; = studioRepository.studentNames

val studentsCount: Flowable&lt;Int&gt; = studioRepository.studentsCount

fun getTicketById(ticketId: Int): Maybe&lt;Ticket&gt; {
    return studioRepository.getTicketById(ticketId)
}

fun getTicketByIdFlat(ticketId: Int): Ticket {
    return studioRepository.getTicketByIdFlat(ticketId)
}

fun updateTicket(ticket: Ticket) = studioRepository.updateTicket(ticket)

val activeTicketsStudentIds: Flowable&lt;List&lt;Int&gt;&gt; = studioRepository.activeTicketsStudentIds

fun getClassesByIdFlat(values: List&lt;Int&gt;): List&lt;YClass&gt; = studioRepository.getYclassesByIdFlat(values)

private fun getStudent(studentId: Int): Maybe&lt;Student&gt; = studioRepository.getStudentById(studentId)

private fun getAllActiveTicketsForAStudent(studentId: Int): Maybe&lt;List&lt;Ticket&gt;&gt; = studioRepository.getAllActiveTicketsForAStudent(studentId)

fun archiveStudentByIdAndDeactivateHisTickets(id: Int) {
    getStudent(id)
            .subscribeOn(Schedulers.io())
            .observeOn(Schedulers.io())
            .doOnSuccess {
                it.isArchived = true
                studioRepository.updateStudent(it)
                getAllActiveTicketsForAStudent(id)
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .doOnSuccess { list -&gt;
                            list.forEach {
                                it.actual = false
                                updateTicket(it)
                            }
                        }
                        ?.subscribe()
            }
            .doOnError {
                it.printStackTrace()
            }
            .subscribe()
}
</code></pre>

<p>}</p>

<pre><code>08-03 22:17:45.601 7776-7776/com.labfoodandfriends.nikitagudkovs.jlogOpenClasses E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.labfoodandfriends.nikitagudkovs.jlogOpenClasses, PID: 7776
    java.lang.RuntimeException: **Unable to start activity** ComponentInfo{com.labfoodandfriends.nikitagudkovs.jlogOpenClasses/com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity}: java.lang.RuntimeException: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2778)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856)
        at android.app.ActivityThread.-wrap11(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589)
        at android.os.Handler.dispatchMessage(Handler.java:106)
        at android.os.Looper.loop(Looper.java:164)
        at android.app.ActivityThread.main(ActivityThread.java:6494)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
     Caused by: java.lang.RuntimeException: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at com.labfoodandfriends.nikitagudkovs.jlog.factory.AppViewModelFactory.create(AppViewModelFactory.java:55)
        at android.arch.lifecycle.ViewModelProvider.get(ViewModelProvider.java:134)
        at android.arch.lifecycle.ViewModelProvider.get(ViewModelProvider.java:102)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity$viewModel$2.invoke(StudentsActivity.kt:83)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity$viewModel$2.invoke(StudentsActivity.kt:69)
        at kotlin.SynchronizedLazyImpl.getValue(LazyJVM.kt:74)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.getViewModel(Unknown Source:7)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.observeStudents(StudentsActivity.kt:136)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.onCreate(StudentsActivity.kt:103)
        at android.app.Activity.performCreate(Activity.java:7009)
        at android.app.Activity.performCreate(Activity.java:7000)
        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1214)
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2731)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856)¬†
        at android.app.ActivityThread.-wrap11(Unknown Source:0)¬†
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589)¬†
        at android.os.Handler.dispatchMessage(Handler.java:106)¬†
        at android.os.Looper.loop(Looper.java:164)¬†
        at android.app.ActivityThread.main(ActivityThread.java:6494)¬†
        at java.lang.reflect.Method.invoke(Native Method)¬†
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)¬†
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)¬†
     Caused by: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at android.arch.persistence.room.RoomDatabase.assertNotMainThread(RoomDatabase.java:204)
        at android.arch.persistence.room.RoomDatabase.query(RoomDatabase.java:232)
        at com.labfoodandfriends.nikitagudkovs.jlog.database.dao.StudentDAO_Impl.getStudents(StudentDAO_Impl.java:272)
        at com.labfoodandfriends.nikitagudkovs.jlog.repository.StudioRepositoryImpl.&lt;init&gt;(StudioRepositoryImpl.kt:50)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule.provideStudioRepository(AppModule.kt:26)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule_ProvideStudioRepositoryFactory.get(AppModule_ProvideStudioRepositoryFactory.java:24)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule_ProvideStudioRepositoryFactory.get(AppModule_ProvideStudioRepositoryFactory.java:10)
        at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsListViewModel_Factory.get(StudentsListViewModel_Factory.java:17)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsListViewModel_Factory.get(StudentsListViewModel_Factory.java:8)
        at com.labfoodandfriends.nikitagudkovs.jlog.factory.AppViewModelFactory.create(AppViewModelFactory.java:53)
</code></pre>
","7663625","","7663625","","2018-08-04 14:16:27","2018-08-04 14:16:27","rxJava and app lifecycle error","<android><rx-java><rx-android><android-room><rx-kotlin>","0","11","","","","CC BY-SA 4.0"
"51786847","1","51822996","","2018-08-10 12:44:07","","0","216","<p>I have an object that generates different strings in the random moments of time, and i need to sudscribe to this generator to take these strings and provide them to ui (maybe it will be multiple subscribers in different activities).
Suppose, i got the following code: </p>

<p>generator:</p>

<pre><code>class Generator {

    private var stringToGenerate = """"

    var subject: BehaviorSubject&lt;String&gt; = BehaviorSubject.create&lt;String&gt;()

    init {
        //seems like these instructions are skipped
        subject
                .subscribeOn(AndroidSchedulers.mainThread())
                .doOnNext { t -&gt; Log.i(""subject doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .observeOn(AndroidSchedulers.mainThread())
                .map { _ -&gt; Log.i(""subject map"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }

        //imitation of async creating of strings in separate thread
        timer(""timerThread"", false, 2000L, 2000L) {
            stringToGenerate = System.currentTimeMillis().toString()
            subject.onNext(stringToGenerate)
        }
    }
}
</code></pre>

<p>One of the activities that must consume generated strings:</p>

<pre><code>class TestActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_test)

        val wrongThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""wrongThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val generator = Generator()
        generator.subject.subscribe(wrongThreadObserver)

        //for correct work illustration
        val correctThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""correctThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val mainThreadSubject = BehaviorSubject.create&lt;String&gt;()
        mainThreadSubject
                .doOnNext { obj -&gt; Log.i(""correctThread doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .subscribeOn(Schedulers.io())
                .observeOn(Schedulers.newThread())
                .subscribe(correctThreadObserver)
        mainThreadSubject.onNext(""test thread"")
        val handler = Handler()
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 2"") }, 1000)
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 3"") }, 2000)
    }
}
</code></pre>

<p>In this case <strong>correctThreadObserver</strong>, created just in activity, works fine, but <strong>wrongThreadObserver</strong> keeps work in timer thread, it seems like it ignoring instructions <strong>subscribeOn, ObserveOn, doOnNext</strong> in Generator, no matter where these instuctions called - in init, in timer thread, in activity by getting object to it from generator - <strong>wrongThreadObserver</strong> still work in timer thread. 
So log is:</p>

<blockquote>
  <p><em>I/correctThread¬†doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/correctThread¬†doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/correctThread¬†doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
</blockquote>

<p>No <code>doOnNext</code> and no main thread for <code>wrongThreadObserver</code>
What i do wrong?</p>
","10208467","","9389285","","2018-08-10 12:58:15","2018-08-13 12:59:37","RxKotlin - Wrong subscribeOn, observeOn thread changing for Subject out of Activity?","<android><multithreading><kotlin-android-extensions><rx-kotlin><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"51981476","1","51988382","","2018-08-23 08:34:43","","0","2844","<p>My code-</p>

<pre><code>val accessTokenRequest: JsonObjectRequest = JsonObjectRequest(Request.Method.GET, url,
            Response.Listener { response -&gt;
            },
            Response.ErrorListener { error -&gt;
                Toast.makeText(activity,error.toString(), Toast.LENGTH_LONG).show()
            }
    )

    AppController.instance!!.addToRequestQueue(accessTokenRequest)
</code></pre>

<p>Header I wat to put -
""Search""&amp;
""Authorization""</p>
","8188198","","","","","2018-08-23 14:39:33","How to put header in url using volley in Kotlin?","<kotlin><android-volley><kotlin-android-extensions><kotlin-extension><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"52033814","1","52039569","","2018-08-27 06:42:41","","3","9927","<p>I need to parse this information-</p>

<pre><code>[
{
    ""artist"": ""12"",
    ""image"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
}]
</code></pre>

<p>As you can see the first field is different, how to parse below information differently and the first field differently in Kotlin.</p>

<p>I am parsing 1st part as-</p>

<pre><code>response -&gt;

                for (i in 0..(response.length() -1)){

                    /**
                        FIRST SONG
                     **/
                    val song = response.get(0).toString()

                    val listOfSongs = response.toString()

                    val parser = Parser()
                    val stringBuilder = StringBuilder(song)
                    val json: JsonObject = parser.parse(stringBuilder) as JsonObject
                    val firstArtist = json.string(""artist"")
                    val firstImage = json.string(""image"")
                    val intent = Intent(activity,ResultPage::class.java)
                    intent.putExtra(""firstArtist"",firstArtist)
                    intent.putExtra(""firstImage"",firstImage)

                    startActivity(intent)
                    /**
                        FIRST SONG
                    **/


                }
            }
</code></pre>

<p>and am also using KLAXON library here.</p>
","8188198","","","","","2019-10-30 07:22:49","How to parse below Json data in Kotlin?","<kotlin><android-volley><kotlin-android-extensions><kotlin-extension><rx-kotlin>","2","0","2","","","CC BY-SA 4.0"
"52096003","1","52096151","","2018-08-30 11:32:16","","2","1032","<p>So i have been trying to convert my EditText input  that i get from my TextWatcher to an observable of stream but i cannot convert it.</p>

<p>I am trying the following</p>

<pre><code>etSearch.addTextChangedListener(object: TextWatcher{
        override fun afterTextChanged(p0: Editable?) {
            //I want to create an observable here to send events
               Observable.create(e-&gt;e.next(p0));
        }

        override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {

        }

        override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {

        }
    })
</code></pre>

<p>I am not able to figure out where i should create my events so that i am able to subscribe to it.</p>
","6048312","","","","","2018-08-30 11:39:42","Convert my EditText Input to an observable stream","<android><kotlin><rx-kotlin>","2","0","1","","","CC BY-SA 4.0"
"52098683","1","","","2018-08-30 13:47:56","","1","78","<p>I have Extension of EditText where I'm listenig to events from keyboard of EditText. I need to know when user press any button for showing (or not showing) error. So I make Observable for keys (rxbinding2) and I'm getting any press but when I press back button and cursor still in this EditText method onBackPressed doesn`t work.
How to filter onBack pressed?</p>

<pre><code>fun EditText.changeWithFormatting(formatter: (String) -&gt; String): Observable&lt;String&gt; {
    return Observable.merge(
            afterTextChangeEvents()
                    .map { editableText },
            keys()
                    .filter { it.action == KeyEvent.ACTION_UP }
                    .map { editableText }
    )
            .map { changeText(formatter(it.toString())) }
}
</code></pre>
","5555912","","","","","2018-08-30 14:11:56","OnBackPressed doesn't work when observe EditText KEys","<android><kotlin><rx-android><rx-kotlin><rx-binding>","1","0","","","","CC BY-SA 4.0"
"52140410","1","","","2018-09-02 19:33:45","","0","1569","<p>I need to show error view if status is error and <code>call.isEmpty()</code> returns <code>true</code>.</p>

<p>Is there a better way to achieve this result?</p>

<pre><code>val errorVisible = states.asFlowable()
    .map { it.status == Status.ERROR }
    .flatMap { isError -&gt;
        if (isError) call.isEmpty()
        else Flowable.just(false)
    }
</code></pre>

<p><code>call.isEmpty()</code> returns <code>Flowable&lt;Boolean&gt;</code> but can return something else like <code>Single&lt;Boolean&gt;</code>.</p>

<p><strong>EDIT:</strong> Another question, if <code>call.isEmpty()</code> returns <code>Flowable&lt;Boolean&gt;</code> how can I merge two streams (two <code>Flowable&lt;Boolean&gt;</code>s - <code>states.isError</code> and <code>call.isEmpty()</code>) and map it to one <code>Flowable&lt;Boolean&gt;</code> so it's one condition?</p>
","2897341","","2897341","","2018-09-02 20:51:00","2019-11-28 14:25:44","rx - Conditional flatMap / add condition to flowable boolean","<kotlin><rxjs><rx-java><rx-java2><rx-kotlin>","3","2","","","","CC BY-SA 4.0"
"52190121","1","","","2018-09-05 16:55:30","","0","2314","<p>I am new to the Rx world so please bear with me.</p>

<p>My code is in Kotlin but a Java code will help also.</p>

<p>I have 2 methods, one of them loads tasks from the database, if there are tasks, I want to send them to the server.</p>

<pre><code>fun getListFromDb(): Single&lt;List&lt;TaskEntity&gt;&gt; {
    return taskEntityDao.getAll()
}

 fun syncTasks(localTasks: TaskSyncRequest): Observable&lt;ApiResponse&lt;List&lt;TaskEntity&gt;&gt;&gt; {
    return taskServices.syncTasks(localTasks)
}
</code></pre>

<p>I know I can use flatmap to chain observables, but just couldn't get it working between Single and Observables.</p>
","10216356","","","","","2018-09-28 23:32:37","How to chain an Observable with a Single in RxJava?","<rx-java><rx-java2><flatmap><rx-kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"52198889","1","52231733","","2018-09-06 07:40:10","","0","358","<p>I have trying to parse actual response body even if server returns 401 HTTP Exception.</p>

<pre><code>protected inline fun &lt;RESPONSE : ParentResponse&gt; executeNetworkCall(
        crossinline request: () -&gt; Single&lt;RESPONSE&gt;,
        crossinline successful: (t: RESPONSE) -&gt; Unit,
        crossinline error: (t: RESPONSE) -&gt; Unit) {

    request().subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { t: RESPONSE -&gt;
                        errorHandler!!.checkApiResponseError(t)?.let {
                            listener?.onErrorWithId(t.message!!)
                            error(t)
                            return@subscribe
                        }
                        successful(t)
                    }
                    ,
                    { t: Throwable -&gt;
                        listener?.onErrorWithId(t.message!!)
                    }
            )
}
</code></pre>

<p>This is what I have written. It parses response and error very well when both are separate in usual ways. But I want to parse success response when I get even 401 HTTP Exception.</p>

<p>Thanks in advance..</p>

<p>Response with 401 HTTP looks like below.</p>

<pre><code>401 Unauthorized - HTTP Exception 
{""Message"":""Authentication unsuccessful"",""otherData"":""//Some data""}
</code></pre>

<p>By the way I have to check HTTP error code..</p>

<pre><code>if (statusCode==401){
 print(""Authentication unsuccessful"")
}
</code></pre>
","3282461","","","","","2018-09-08 03:31:55","How to parse success body response on http exception 401?","<android><kotlin><rx-java2><rx-kotlin><android-mvvm>","1","2","","","","CC BY-SA 4.0"
"52219187","1","53335756","","2018-09-07 09:10:07","","4","7810","<p>Here is my Code that for Volley Request:- </p>

<pre><code>    val searchRequest = object : JsonArrayRequest(Request.Method.GET,url,
            Response.Listener { response -&gt;

                val result = response.toString()


            },
            Response.ErrorListener { error -&gt;
                Toast.makeText(activity, ""Error!"",Toast.LENGTH_LONG)
                        .show()
                Log.d(""ERROR"",error.toString())
            })
    {
        override fun getBody(): ByteArray {

           //   TODO add Body, Header section works  //////////

            return super.getBody()
        }

        override fun getBodyContentType(): String {
            return ""application/json""
        }


        override fun getHeaders() : Map&lt;String,String&gt; {
            val params: MutableMap&lt;String, String&gt; = HashMap()
            params[""Search-String""] = songName
            params[""Authorization""] = ""Bearer ${accessTx.text}""
            return params
        }
    }
    AppController.instance!!.addToRequestQueue(searchRequest)
</code></pre>

<p>I want to add this information in the body section</p>

<p>video_id =  ""BDJIAH"" , 
audio_quality = ""256"" </p>

<p>here is the sample to add above information in the below segment.</p>

<p>{
""video_id"":""ABCDE"",
 ""audio_quality"":""256""
}</p>

<p>Basically, I am facing problem in ByteArray section. That doesn't work for me.</p>
","8188198","","","","","2020-02-05 06:51:58","How to add Body in Url in Volley request in Kotlin?","<json><kotlin><android-volley><kotlin-android-extensions><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"52255995","1","","","2018-09-10 10:39:42","","0","67","<p>I'm looking to make a sample project with a clean architecture approach and i have some difficulties to transform a single to another.</p>

<p>I have my retrofit service (with a Single) :</p>

<pre><code>@GET(""nearbysearch/json"") fun getNearbyPlaces(@Query(""type"") type: String, @Query(""location"") location: String, @Query(""radius"") radius: Int): Single&lt;GooglePlacesNearbySearchResult&gt;
</code></pre>

<p>And i use it in my repository implementation :</p>

<pre><code>override fun getNearbyPlaces(type: String, location: String, radius: Int): Single&lt;List&lt;Place&gt;&gt; {
    return googlePlacesApi.getNearbyPlaces(type, location, radius)
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.computation())
        .doOnSuccess { googlePlacesNearbySearchResult -&gt; nearbyPlaceListResultMapper.transform(googlePlacesNearbySearchResult) }
}
</code></pre>

<p>In this single, i want to transform my <code>Single&lt;GooglePlacesNearbyResultSearch&gt;</code> to a <code>Single&lt;List&lt;Place&gt;&gt;</code>, and i want to do this with my mapper <code>NearbyPlaceListResultMapper</code></p>

<p>The issue is i don't succeed in having a <code>Single&lt;List&lt;Place&gt;&gt;</code> at the end. I can transform it to an Observable or a Completable but not the Single one.</p>

<p>Can anyone help me to have it in a cleaner way ?</p>

<p>Thanks</p>
","10291684","","","","","2018-09-10 17:56:22","ReactiveX - Single<T> to Single<R>","<rx-java><retrofit2><reactivex><clean-architecture><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"52331198","1","","","2018-09-14 11:38:18","","0","71","<p>I have following code that works well.</p>

<pre><code>Observable.from(...)
    .map { // List&lt;Object&gt;
        if (My_Condition_is_true) {
            //...
        }
        val newList = getNewListIfConditionIsOkay(it)
        newList.map { item -&gt; toSomethingElse(item) }
    }
    .subscribeBy(myErrorFun) {
        //...
    }
</code></pre>

<p>I feel <code>map</code> operator does not looks cool but I have no idea how to fix it. This is what is in my mind.</p>

<pre><code>Observable.from(...)
        .doOnNext {// List&lt;Object&gt;
            if (My_Condition_is_true) {
                //...
                return getNewListIfConditionIsOkay(it)
            }
            return it
        .map { // List&lt;Object&gt;
            it.map { item -&gt; toSomethingElse(item) }
        }
        .subscribeBy(myErrorFun) {
            //...
        }
</code></pre>

<p>My Observable returns only a list. What is your recommendation? </p>
","513413","","472495","","2018-09-18 09:03:43","2018-09-18 09:03:43","How to pass modified list downstream in RxJava in Android?","<android><rx-java2><rx-kotlin>","2","2","","","","CC BY-SA 4.0"
"52387704","1","53049617","","2018-09-18 13:27:46","","0","232","<p>I'm trying to set up a DrawerLayout in the MvRx sample project but i am kind of stuck.</p>

<p>Totally new to both epoxy and MvRx in general and i have been playing around for a week now learning about the framework and testing components i need to convert our app to MvRx.</p>

<p><strong>What i am wondering is how you setup a DrawerLayout view using MvRx.</strong></p>

<p>Also the current examples are very comprehensive for noobs. Anyone has a minimalist starter available?</p>

<p>// JQ</p>
","2333802","","4438601","","2018-09-19 06:35:44","2018-10-29 16:12:15","MvRX DrawerLayout + generally more examples wanted","<android><kotlin><drawerlayout><rx-kotlin><epoxy>","1","0","1","","","CC BY-SA 4.0"
"52435122","1","","","2018-09-21 00:45:44","","0","454","<p><a href=""https://i.stack.imgur.com/FDdi6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FDdi6.png"" alt=""enter image description here""></a></p>

<p>So I have a database in Firebase Cloud Firestore that stores users and tasks. Each user has a number of fields such as name, username,etc. I want to know how to fetch each field that is associated with each user using Kotlin. </p>

<p>I'm trying to get all these accounts so I can display them in an activity called friends, that's why I want to collect all these accounts from the database. Here is a picture of my database to have a clear understanding of what I'm trying to do. </p>
","5730289","","10191554","","2018-09-21 05:03:19","2018-09-21 05:03:19","how to get data from Firebase Cloud Firestore in Kotlin","<android><android-studio><kotlin><google-cloud-firestore><rx-kotlin>","0","3","","","","CC BY-SA 4.0"
"52446947","1","52448032","","2018-09-21 15:31:52","","2","511","<p>I'm trying to use combineLatest with several RxTextViews and I thought that I was disposing my Disposables properly but it looks like I'm still getting a memory leak.</p>

<pre><code>val one = RxTextView.afterTextChangeEvents(one)
            val two = RxTextView.afterTextChangeEvents(two)
            val three = RxTextView.afterTextChangeEvents(three)
            val four = RxTextView.afterTextChangeEvents(four)
            val five = RxTextView.afterTextChangeEvents(five)

            val disposable = Observables.combineLatest(one, two, three, four, five) { oneEvent, twoEvent, threeEvent, fourEvent, fiveEvent -&gt;
                 //combining happening with these strings: oneEvent.view().text.toString  }
                    .skip(1) 
                    .debounce(1000, TimeUnit.MILLISECONDS)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe {
                        //network call
                    }
            compositeDisposable.add(disposable)
        }
</code></pre>

<p>And then in my <code>onStop</code> I dispose of it.</p>

<pre><code>override fun onStop() {
    super.onStop()
    if (!compositeDisposable.isDisposed) {
        compositeDisposable.dispose()
    }
}
</code></pre>

<p>I read that if some Views are referenced in the onNext() method, then there‚Äôs a potential NullPointerException which is what I believe is happening. Here's my NPE I'm getting:</p>

<pre><code>fatal Exception: java.lang.NullPointerException: view == null
       at com.jakewharton.rxbinding2.internal.Preconditions.checkNotNull(Preconditions.java:27)
       at com.jakewharton.rxbinding2.widget.RxTextView.afterTextChangeEvents(RxTextView.java:159)
       at MyFragment$setUpTextListeners$1.execute(MyFragment.kt:170)
</code></pre>

<p>Here's the fragment I'm using:</p>

<pre><code>private lateinit var viewModel: MyViewModel
private lateinit var binding: FragmentMyThingsBinding

private val compositeDisposable = CompositeDisposable()

override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {

    binding = FragmentMyThingsBinding.inflate(inflater, container, false)
    viewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)
    binding.viewModel = viewModel

    //calls to kick off business logic

    return binding.root
}


override fun onStart() {
    super.onStart()

    setUpTextListeners()
}

override fun onStop() {
    super.onStop()
    if (!compositeDisposable.isDisposed) {
        compositeDisposable.dispose()
    }
}

private fun setUpTextListeners() {

    val one = RxTextView.afterTextChangeEvents(one)
    val two = RxTextView.afterTextChangeEvents(two)
    val three = RxTextView.afterTextChangeEvents(three)
    val four = RxTextView.afterTextChangeEvents(four)
    val five = RxTextView.afterTextChangeEvents(five)

    compositeDisposable.add(Observables.combineLatest(one, two, three, four, five) { oneEvent, twoEvent, threeEvent, fourEvent, fiveEvent -&gt;
            //combine here using oneEvent.view().text.toString  }
            .skip(1)
            .debounce(1000, TimeUnit.MILLISECONDS)
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                //network call
            })

    }
}
</code></pre>
","2752082","","2752082","","2018-09-21 17:28:04","2018-09-23 12:59:32","Rxjava, combineLatest with RxTextView memory leak","<android><memory-leaks><rx-java><rx-kotlin><rx-binding>","1","0","","","","CC BY-SA 4.0"
"52544735","1","","","2018-09-27 20:33:27","","2","995","<p>I have a data provider that has an <code>Observable&lt;Int&gt;</code> as part of the public API. My class under test maps this into a <code>Observable&lt;String&gt;</code>.</p>

<p>How do I create a mock so that it can send out different values on the data provider's observable?</p>

<p>I can do it using a <code>Fake</code> object, but that is a lot of work that I don't think is necessary with MockK.</p>

<p>Simplified code:</p>

<pre><code>interface DataProvider {
    val numberData:Observable&lt;Int&gt;
}

class FakeDataProvider():DataProvider {

    private  val _numberData = BehaviorSubject.createDefault(0)
    override val  numberData = _numberData.hide()

    // Note: the internals of this class cause the _numberData changes.
    // I can use this method to fake the changes for this fake object,
    // but the real class doesn't have this method.

    fun fakeNewNumber( newNumber:Int ) {
        _numberData.onNext( newNumber )
    }
}

interface ClassUnderTest {
    val stringData:Observable&lt;String&gt;

}
class MyClassUnderTest( dataProvider: DataProvider ):ClassUnderTest {

    override val stringData = dataProvider.numberData.map { ""string = "" + it.toString() }
}

class MockKTests {

    @Test fun testUsingFakeDataProvider() {

        val fakeDataProvider        = FakeDataProvider()
        val classUnderTest          = MyClassUnderTest( fakeDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )

        fakeDataProvider.fakeNewNumber( 1 )
        fakeDataProvider.fakeNewNumber( 2 )
        fakeDataProvider.fakeNewNumber( 3 )

        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }

    // How do you write the mock to trigger the dataProvider observable?
    @Test fun testUsingMockDataProvider() {
        val mockDataProvider        = mockk&lt;DataProvider&gt;()

//        every { ... what goes here ... } just Runs

        val classUnderTest          = MyClassUnderTest( mockDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )


        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }
}
</code></pre>
","5135551","","","","","2018-11-15 12:33:03","How to use MockK to mock an observable","<rx-kotlin><rx-kotlin2><mockk>","1","0","","","","CC BY-SA 4.0"
"52566383","1","52588056","","2018-09-29 07:58:20","","0","760","<p>I have a dummy network data source:</p>

<pre><code>    fun networkDataSource(): Single&lt;List&lt;Int&gt;&gt; {
        return Single.just((0 until 100).toList())
                .delay(150, TimeUnit.MILLISECONDS)
    }
</code></pre>

<p>Here is an endless observable. It's main use is that it's calculation should be 'protected', so that <strong>it calculates it's single value only once</strong>. <em>(Here the value is the 1.)</em></p>

<pre><code>    val endless = Observable
            .just(1)
            .observeOn(Schedulers.io())
            .delay(500, TimeUnit.MILLISECONDS)
            // Counts as heavy operation, do not calculate this here once again
            .doOnNext { println(""=&gt; E: Calculated once"") }
            .cache()
            //.doOnNext { println(""=&gt; E: From cache"") }
            .repeat()
</code></pre>

<p>The main stream just simply emits values:</p>

<pre><code>    val mainStream = Observable.range(0, 6)
            .doOnNext { println(""=&gt; M: Main stream $it"") }
</code></pre>

<p>The task:</p>

<p>Zip the 3 observables together, and optimize the network usage, so that it will not be called more than necessary. (Once the number of data - integers in this case - is met.</p>

<p>Approach:</p>

<pre><code>    mainStream
            .concatMap {index -&gt;
                Observables.zip(
                        Observable.just(index),
                        endless,
                        networkDataSource()
                                .toObservable()
                                .doOnNext { println(""#&gt; N: Network data fetch $index"") }
                )
            }
            .doOnNext { println(""=&gt; After concatmap: ${it.first}"") }
            .take(4)
            .doOnNext { println(""=&gt; After take: ${it.first}"") }
            .subscribe(
                    { println(""=&gt; Last onnext"") },
                    { it.printStackTrace() },
                    { synchronized(check) { check.notifyAll() } }
            )
</code></pre>

<p>Finishing the locked thread - only needed for testing:</p>

<pre><code>synchronized(check) {
    check.wait()
}
println(""Ending"")
</code></pre>

<p>Here is the output:</p>

<pre><code>=&gt; M: Main stream 0
=&gt; M: Main stream 1
=&gt; M: Main stream 2
=&gt; M: Main stream 3
=&gt; M: Main stream 4
=&gt; M: Main stream 5
#&gt; N: Network data fetch 0
=&gt; E: Calculated once
=&gt; After concatmap: 0
=&gt; After take: 0
=&gt; Last onnext
#&gt; N: Network data fetch 1
=&gt; After concatmap: 1
=&gt; After take: 1
=&gt; Last onnext
</code></pre>

<p>This the output and it is stuck after the second take. (Doesn't proceed in a minute). My question is, why does that happen? </p>

<p>As a sidenote, if I uncomment the line from the <code>endless</code> observable:</p>

<pre><code>.doOnNext { println(""=&gt; E: From cache"") }
</code></pre>

<p>It is going to flood the console with that line. Why is <code>endless</code> called so many times instead for each iteration?</p>

<p><code>flatMap()</code> is not a solution here, because it does not take <code>take(4)</code> into account and proceeds to finish all network calls.</p>

<p>So how could I make <code>concatMap()</code> work?</p>

<p>(I also added <em>RxJS</em> tag because this is a reactive problem and absolutely not about Kotlin. JS solutions are also welcome, if those functions exist in the RxJava library.)</p>

<p>Edit.:</p>

<p>I looked into the code and the 2 outputs are probably because of the <code>prefetch</code> parameter:</p>

<pre><code>@CheckReturnValue
@SchedulerSupport(SchedulerSupport.NONE)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) {
    return concatMap(mapper, 2);
}
</code></pre>

<p>But I still don't understand how it works. I've only read that <code>concatMap()</code> is <code>flatmap()</code>, but it waits for the results of each.</p>
","4420543","","4420543","","2018-09-29 08:03:25","2018-10-01 09:25:10","RxJava: concatMap() with zip() gets stuck","<kotlin><rxjs><rx-java><rx-java2><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"52603665","1","","","2018-10-02 07:20:55","","1","1614","<p>Rx noobie here: any idea on how to achieve this?:</p>

<p>I have a list of items from the UI and would like to POST them to the server. I need the list of POSTed items back from the server (to use the server-issued IDs, timestamps etc).</p>

<p>Pardon my long examples but here's the code I'm struggle to make work:</p>

<pre><code>/**
 * create each item (POST) in the list and return the list
 * of newly created ones
 */
fun postItems(items: List&lt;Item&gt;): Maybe&lt;List&lt;Item&gt;&gt; {
    // loop through all items, making a network call for each and return the
    // list of POSTed items

    // attempt 1
    // Failed type inference. Expected type mismatch:
    // Expected: Maybe&lt;List&lt;Item&gt;&gt;
    // Found: List&lt;Maybe&lt;Item&gt;&gt;
    return items.map {
        postItem(it)
    }

    // attempt 2: 'extract' each item in resulting observable and
    // shove it back to original list
    return Maybe.just(items.map {
        postItem(it!!)
                // 'extract' item from observable
                .flatMap {
                    // error: Type mismatch.
                    // Required ((Item) -&gt; MaybeSource&lt;out (???...???)&gt;!)!
                    // Found (Item) -&gt; Item
                    it
                }
    })

    // attempt 3: convert a Maybe to Flowable to collect all items from post
    // and emit them as a single list
    // Type mismatch. Required:(((Mutable)List&lt;Item!&gt;) -&gt; SingleSource&lt;out (???...???)&gt;!)!
    // Found: ((Mutable)List&lt;Item!&gt;) -&gt; (Mutable)List&lt;Item!&gt;
    return items.forEach {
        postItem(it!!).toFlowable().toList().flatMap { it }
    }

    // attempt 4: modify attempt 3 with concatMap:
    // Type mismatch. Required:((List&lt;Item!&gt;) -&gt; MaybeSource&lt;out (???...???)&gt;!)!
    // Found: (List&lt;Item!&gt;) -&gt; List&lt;Maybe&lt;Item&gt;&gt;
    return Maybe.just(items)
            // wait for each observable to finish all the work 
            // until the next one is processed
            .concatMap({
                it.map { addItem(it!!) }
            }).toFlowable()
            .toList().toMaybe()

    // attempt 6: blocking call on each API request.
    // results in android.os.NetworkOnMainThreadException
    return Maybe.just(places.map {
        addPlace(it!!).blockingGet()
    })
}

fun postItem(item: Item): Maybe&lt;Item&gt; {
    return networkService.post(item) // async call to API, returns Maybe&lt;Item&gt;
}
</code></pre>

<p><strong>UPDATE</strong></p>

<p>I have tried the approach suggested by @AlexeySoshin below but still have some points of confusion:</p>

<p>I have tried the second, shorter approach but the retrofit call doesn't go thru for some reason :(, i.e the network service endpoints aren't hit). It's slightly modified because I couldn't get rx-kotlin wrapper to work, but I imagine it's roughly equivalent to this:</p>

<pre><code>fun addItems(items: List&lt;Item?&gt;): Flowable&lt;Maybe&lt;Item&gt;&gt; {
    return Flowable.fromIterable(items).map {
        // tried items.toFlowable().map but got 'Unresolved reference toFlowable
        // even after adding rx-kotlin to project via gradle
        return@map postItem(it)
    }
}
</code></pre>

<p>My network service works successfully for a single Item with this code:</p>

<pre><code>// works as expected
fun postOneItem(item: Item): Maybe&lt;Item&gt; {
    return postItem(item)
}

// also works
fun postOneItemFlowable(item: Item): Flowable&lt;Item&gt; {
    return postItem(item).toFlowable()
}


// this variant didn't work
fun postOneItemFlowable(item: Item): Flowable&lt;Maybe&lt;Item&gt;&gt; {
    return Flowable.just(postItem(item))
}
</code></pre>

<p>How to make <code>Flowable&lt;Maybe&lt;Item&gt;&gt;</code> calls go thru successfully? (or <code>Flowable&lt;List&lt;Item&gt;&gt;</code>, which would be closer to what I need eventually)</p>

<p>Finally, how to obtain the actual output list from a
    <code>Flowable&lt;Maybe&lt;Item&gt;&gt;</code>? It would help to see how the <code>.subscribe()</code>
    block might look like to 'extract' that final list. Here is how my current subscribe code looks like:</p>

<pre><code>...
private fun createItem(item: Item) {
    disposables.add(
            addItemUseCase.postOneItem(item)
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        Timber.d(""one item posted: $it"")
                    }, { /* error handler *//})
}
...
</code></pre>
","1145905","","1145905","","2018-10-04 07:58:27","2018-10-04 07:58:27","RxJava: Create items in list and return new list","<java><android><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"52642493","1","","","2018-10-04 08:39:30","","1","59","<p>Probably an rx newbee question.</p>

<p>If I have two rx streams, which have some common parts, is there a possibility to extract and to reuse them?</p>

<p>Here is pseudo code example:</p>

<pre><code>someManager.getInfo(id) returns a Single&lt;SometInfo&gt;
</code></pre>

<p>This fun takes an id and should return just a single with status</p>

<pre><code>fun getStatus(id: String): Single&lt;Status&gt; =
    someManager.getInfo(id)
        .flattenAsObservable { it.items }
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
</code></pre>

<p>and this one doesn't take an id but already an object and should check if a status is ok</p>

<pre><code>fun isStatusOk(info: SomeInfo): Single&lt;Boolean&gt; =
    Observable.fromIterable(info.items)
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
        .map { it == Status.OK }
</code></pre>

<p>Thank you in advance</p>
","408780","","408780","","2018-10-04 08:53:42","2018-10-22 10:22:01","Reuse part of RxJava stream","<rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","3","","","","CC BY-SA 4.0"
"52756197","1","52758673","","2018-10-11 09:03:02","","3","627","<p>Here is a kotlin activity which should display a list of events (from sample.json)</p>

<pre><code>class TalksActivity : AppCompatActivity(), TalkAdapter.Listener {

private val TAG = TalksActivity::class.java.simpleName

private var mCompositeDisposable: CompositeDisposable? = null
private var mAdapter: TalkAdapter? = null
private var disposable: Disposable? = null
private val mapper = createMapper()

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_talks)
    pbWaiting.visibility = View.VISIBLE

    mCompositeDisposable = CompositeDisposable()

    initRecyclerView()
    loadTalks()
}


private fun initRecyclerView() {
    rv_talks_list.setHasFixedSize(true)
    val layoutManager: RecyclerView.LayoutManager = LinearLayoutManager(this)
    rv_talks_list.layoutManager = layoutManager
    rv_talks_list.adapter = TalkAdapter(ArrayList(Collections.emptyList()), this)
}

private fun loadTalks() {
    disposable = getTalks()
            .subscribeOn(AndroidSchedulers.mainThread())
            .observeOn(Schedulers.io())
            .subscribe ({ result -&gt; handleResponse(result) }, { error -&gt; handleError(error) })
}

private fun handleResponse(talkList: List&lt;Talk&gt;) {
    mAdapter = TalkAdapter(ArrayList(talkList), this)
    rv_talks_list.adapter = mAdapter
    pbWaiting.visibility = View.GONE
}

private fun handleError(error: Throwable) {
    pbWaiting.visibility = View.GONE
    throw error
}

private fun createMapper(): ObjectMapper {
    val mapper = jacksonObjectMapper()
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
    return mapper
}

override fun onItemClick(talk: Talk) {
    startActivity(CountdownActivity.newIntent(this, talk))
}

private fun getTalks() : Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.create&lt;List&lt;Talk&gt;&gt; {
        mapper.readValue(text, collectionType)
    }
}

}
</code></pre>

<p>The problem: When I call <code>loadTalks()</code>, handleResponse(result) or handleError(error) are never called and the screen stay white with only the progressbar running.</p>

<p>I have no error in the console.</p>

<p>Here is my very simple activity_talks.xml</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""
xmlns:app=""http://schemas.android.com/apk/res-auto""
xmlns:tools=""http://schemas.android.com/tools""
android:layout_width=""match_parent""
android:layout_height=""match_parent""
tools:context="".TalksActivity""&gt;

&lt;android.support.v7.widget.RecyclerView
    android:id=""@+id/rv_talks_list""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""
    app:layout_constraintBottom_toBottomOf=""parent""
    app:layout_constraintLeft_toLeftOf=""parent""
    app:layout_constraintRight_toRightOf=""parent""
    app:layout_constraintTop_toTopOf=""parent"" /&gt;

&lt;ProgressBar
    android:id=""@+id/pbWaiting""
    android:layout_width=""wrap_content""
    android:layout_height=""wrap_content""
    android:visibility=""gone""
    app:layout_constraintBottom_toBottomOf=""parent""
    app:layout_constraintEnd_toEndOf=""parent""
    app:layout_constraintHorizontal_bias=""0.5""
    app:layout_constraintStart_toStartOf=""parent""
    app:layout_constraintTop_toTopOf=""parent"" /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre>

<p>What's wrong?</p>

<p>This was working without rxKotlin and observable code.</p>

<p><strong>EDIT</strong></p>

<p>Here is my Adapter:</p>

<pre><code>class TalkAdapter(private val dataList: ArrayList&lt;Talk&gt;, private val listener: Listener) : RecyclerView.Adapter&lt;TalkAdapter.ViewHolder&gt;() {

interface Listener {

    fun onItemClick(talk: Talk)
}

private val colors: Array&lt;String&gt; = arrayOf(""#EF5350"", ""#EC407A"", ""#AB47BC"", ""#7E57C2"", ""#5C6BC0"", ""#42A5F5"")

override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    holder.bind(dataList[position], listener, colors, position)
}

override fun getItemCount(): Int = dataList.count()

override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {

    val view = LayoutInflater.from(parent.context).inflate(R.layout.adapter_talk, parent, false)

    return ViewHolder(view)
}

class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {

    fun bind(talk: Talk, listener: Listener, colors: Array&lt;String&gt;, position: Int) {

        itemView.title.text = talk.title
        itemView.recap.text = talk.summary
        itemView.eventId.text = talk.eventId
        itemView.setBackgroundColor(Color.parseColor(colors[position % 6]))

        itemView.setOnClickListener { listener.onItemClick(talk) }
    }
}
}
</code></pre>

<p><strong>EDIT</strong></p>

<p><em>Found the solution thanks to Demigod answer.</em></p>

<p>When I create an Observable with <code>Observable.create</code> I have to trigger  <code>onNext()</code> and <code>onError()</code> manually. </p>

<p>To fix it, change </p>

<pre><code>private fun getTalks() : Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.create&lt;List&lt;Talk&gt;&gt; {
        mapper.readValue(text, collectionType)
    }
}
</code></pre>

<p>with </p>

<pre><code>private fun getTalks(): Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.fromCallable { mapper.readValue&lt;List&lt;Talk&gt;&gt;(text, collectionType) }
}
</code></pre>

<p>and for better perfs:</p>

<pre><code>private fun getTalks(): Observable&lt;List&lt;Talk&gt;&gt; {
    return Observable.fromCallable {
        val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
        val typeFactory = mapper.typeFactory
        val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
        mapper.readValue&lt;List&lt;Talk&gt;&gt;(text, collectionType)
    }
}
</code></pre>
","2683000","","2683000","","2018-10-11 13:31:17","2018-10-11 13:31:17","Populate a RecyclerView with rxkotlin: The Recyclerview stay empty","<android><android-recyclerview><kotlin><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"52761570","1","","","2018-10-11 13:40:18","","0","113","<p>I've successfully compiled and able to run the app into the device, since I am getting this issue trying to use any JNIs function.</p>

<p>Here is the error which I am stuck at -</p>

<p><a href=""https://i.stack.imgur.com/8AhfN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8AhfN.png"" alt=""enter image description here""></a></p>
","1180661","","","","","2018-10-11 13:40:18","Cannot resolve corresponding JNI Function | Open CV | Android | Kotlin","<android><kotlin><android-ndk><java-native-interface><rx-kotlin>","0","4","","","","CC BY-SA 4.0"
"52973193","1","","","2018-10-24 15:49:22","","0","397","<p>I am trying to bridge some existing rx code and api that uses futures. When I 
manually dispose an observable I would expect onDispose() to be always called. It usually does but when I specify a custom scheduler it sometimes does not get called. My example:</p>

<pre><code>class Work {

private val disposables = CompositeDisposable()

fun getFuture(): ListenableFuture&lt;String&gt; {

    val future = ResolvableFuture.create&lt;String&gt;()

    disposables.add(

            Observable.fromCallable {
                try {
                    Thread.sleep(2000)
                } catch (ex: InterruptedException) {

                }
                ""1""
            }.firstOrError()
                .onErrorReturn { ""2"" }
                .doOnDispose {
                    println(""disposing 1 on ${Thread.currentThread().name}"")
                    //sometimes this dispose does not get called
                    future.set(""2"")
                }
                .subscribeOn(Schedulers.io())
                .doOnDispose {
                    println(""disposing 2 on ${Thread.currentThread().name}"")
                    //only this dispose gets called every time
                    //future.set(""2"")
                }
                .subscribe(Consumer {
                    future.set(""2"")
                })
    )

    return future
}

fun stop() {
    disposables.clear()
}

}

@Test
fun `doOnDispose does not get called`() {
    println(""------------"")

    for (i in 1..100) {

        val work = Work()

        val future = work.getFuture()

        println(""Cancelling"")

        work.stop()

        println(""Getting ${Thread.currentThread().name}"")
        val result = future.get(2, TimeUnit.SECONDS)

        assertEquals(""2"", result)

        println(""------------"")
    }
}
</code></pre>

<p>What happens is only the second onDispose gets called every time. The one before .subscribeOn() is sometimes not called at all.  </p>
","935553","","","","","2018-10-24 20:52:06","doOnDispose does not get called when subscribing on a background scheduler","<rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53281983","1","53283004","","2018-11-13 13:22:43","","1","240","<p>i am using rx kotlin newly and didn't understand all of it yet. I am trying to loop over a list of queries, and execute them one by one. in this list i have a special string that once reached, i want to break the loop and perform another function</p>

<p>how can i do this in the below example?</p>

<pre><code>fun runQueries() {

     Observable.fromIterable(queriesTemp)

                    .subscribeOn(Schedulers.computation())
                    .doOnNext { query -&gt;
                        if (query.contains(""COMPLETION OF SDF QUERIES"")) {
                            if (loginStatus == StaticVariables.FT_CASE_NEW_LOGIN) {
                                tasksQueriesTemp = arrayOfNulls(queries.size - queries.indexOf(query))
                                System.arraycopy(queries, queries.indexOf(query), tasksQueriesTemp, 0, tasksQueriesTemp!!.size)
                            }
                          // break the loop here 
                            runOtherQueries()
                             break
                        }
                        if (!TextUtils.isEmpty(query)) {
                            mDatabase.execSQL(query, false, """")
                        }
                        action(tasksQueriesTemp!!.indexOf(query))
                    }
                    .doOnComplete { executeOtherUpdates(tasksQueriesTemp) }
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe()
}

fun runOtherQueries() {
}
</code></pre>
","1950784","","13302","","2019-12-17 21:28:23","2019-12-17 21:28:23","RXKotlin Break Inside doOnNext and Call Another Function","<android><rx-java><rx-kotlin>","1","2","1","","","CC BY-SA 4.0"
"53307056","1","53307691","","2018-11-14 18:59:17","","0","706","<p>What are the differences in the following cases: </p>

<pre><code>fun a(params: String) = Completable.fromAction {
        if (params.isEmpty()) {
            throw EmptyRequiredFieldException() 
        }
    }
</code></pre>

<p>VS</p>

<pre><code>fun b(params: String) = if(params.isEmpty()) 
       Completable.error(EmptyRequiredFieldException()) 
else 
       Completable.complete()
</code></pre>

<p>Specifically in the context of android, if it matters (even though I don't think it does)
Thanks!</p>
","10614184","","","","","2018-11-14 19:43:23","In RxJava/RxKotlin, what are the differences between returning a Completable.error(Exception()) and throwing?","<error-handling><kotlin><observable><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53352838","1","53353032","","2018-11-17 15:52:14","","1","345","<p>I am using RxJava/Kotlin <code>Observable#take()</code> to get first 50 items from the list. But <code>#take()</code> operator is not behaving as it should as per Rx docs. </p>

<p>In Rx docs, <code>#take()</code> is defined as:</p>

<blockquote>
  <p>""Emit only the first n items emitted by an Observable""</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/q4oTZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q4oTZ.png"" alt=""enter image description here""></a></p>

<p>I have a function like this:</p>

<p>As we can see the <code>pageSize</code> argument is <code>50</code> </p>

<p><a href=""https://i.stack.imgur.com/DbyoV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DbyoV.png"" alt=""enter image description here""></a></p>

<p>And initial <code>size</code> of the <code>list</code> is <code>300</code> </p>

<p><a href=""https://i.stack.imgur.com/mK0Ai.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mK0Ai.png"" alt=""enter image description here""></a></p>

<p>After that <code>#take(50)</code> is applied to that <code>Observable</code> and at next breakpoint I still get the <strong>full size</strong> list <code>i.e. size = 300</code> </p>

<p><a href=""https://i.stack.imgur.com/hpBBD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hpBBD.png"" alt=""enter image description here""></a></p>

<p>But <code>just for the check</code>, if something is wrong with the debugger or observable, I tried to take only items whose displayName contains ""9"", but this time I get the expected result of <code>smaller list</code> with <code>9</code> in each of their <code>#displayName field</code>.</p>

<p><a href=""https://i.stack.imgur.com/zZOK5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zZOK5.png"" alt=""enter image description here""></a></p>

<p>I believe <code>RxJava/Kotlin's #take()</code> operator is not that crazy and it's just me.</p>
","2581314","","472495","","2019-01-14 20:41:53","2019-01-14 20:41:53","Observable#take(Long) not returning desired size of items in RxJava","<java><kotlin><rx-java><rx-android><rx-kotlin>","2","1","","","","CC BY-SA 4.0"
"53360939","1","","","2018-11-18 12:35:35","","0","82","<p>I am working on a feature where I need to filter out the network response data based on local database data.</p>

<p>For example, my network layers return me a list of items and my database layer returns an observable list of ids. Now I want to only return those objects from network layer whose id matches anyone from the database layer response.</p>

<p>Below code fetches data from the network and saves the result to a database(cache).</p>

<pre><code>factory.getRemoteDataStore()
                .searchForVenues(query)
                .toObservable()
                .distinctUntilChanged()
                .flatMap { venues -&gt;
                    factory.getCacheDataStore()
                            .saveVenues(venues)
                            .andThen(Observable.just(venues))
                }
</code></pre>

<p>I also have a method that returns a list of venues that needs to be filtered</p>

<pre><code>factory.getCacheDataStore().getDislikedVenues()
</code></pre>

<p>Now, how do I extend the previous chain to use getDislikedVenues() Observable to filter them from the response of network response?</p>

<p>Sorry for such noob question, I really am struggling with this.</p>
","5421753","","","","","2018-11-18 14:29:27","Create a filtered observable from 2 observable of list of items in RxJava","<android><rx-java><observable><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53509536","1","53514768","","2018-11-27 22:59:35","","0","77","<p>I am trying to convert examples from <a href=""https://www.androidhive.info/RxJava/android-getting-started-with-reactive-programming/#example5"" rel=""nofollow noreferrer"">this article</a> from Java to Kotlin.
I get error from picture at Exmaple 5:</p>

<p><a href=""https://i.stack.imgur.com/Vhp81.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vhp81.png"" alt=""enter image description here""></a></p>

<p>And I noticed, that without map() function I don't get this error</p>

<p><a href=""https://i.stack.imgur.com/ZOVsj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZOVsj.png"" alt=""enter image description here""></a></p>

<p>So, what the point of this error and how to write it right?</p>
","8230672","","","","","2018-11-28 08:05:37","mapping custom data RxAndroid with Kotlin","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53546662","1","","","2018-11-29 19:59:20","","1","64","<p>I'm using RxRoom with Kotlin. In my Dao class 
If I use this: </p>

<p><code>@Insert
    fun insertPaymentRef(paymentRef: PaymentRef): Single&lt;Long&gt;</code></p>

<p>Or this:</p>

<pre><code>@Insert
fun insertPaymentRef(paymentRef: PaymentRef): Completable
</code></pre>

<p>the generated <code>Dao</code> class throws this error </p>

<blockquote>
  <p>error: local variable paymentRef is accessed from within inner class; needs to be declared final</p>
</blockquote>

<p>A sneek peak in the generated class is this:</p>

<pre><code>public Single&lt;Long&gt; insertPaymentRef(PaymentRef paymentRef) {
return Single.fromCallable(new Callable&lt;Long&gt;() {
  @Override
  public Long call() throws Exception {
    __db.beginTransaction();
    try {
      long _result = __insertionAdapterOfPaymentRef.insertAndReturnId(paymentRef);
      __db.setTransactionSuccessful();
      return _result;
    } finally {
      __db.endTransaction();
    }
  }
});
</code></pre>

<p>}</p>

<p>The only time I don't get this error is if I only make my <code>insert</code> call like this:</p>

<pre><code>@Insert(onConflict = OnConflictStrategy.REPLACE)
fun insertPaymentRef(paymentRef: PaymentRef)
</code></pre>

<p>How do I make the <code>INSERT</code> call work in RxRoom: I've included RxRoom dependency and it works because if I try doing <code>GET</code> calls like this </p>

<pre><code>@Query(PaymentRefDbConstants.QUERY_PAYMENT_REF)
fun getPaymentRef(): Single&lt;PaymentRef&gt;
</code></pre>

<p>It works</p>
","7338759","","7338759","","2018-11-30 00:05:05","2018-11-30 00:05:05","RxRoom Kotlin: Generated Dao - error: local variable users is accessed from within inner class; needs to be declared final","<java><android><kotlin><android-room><rx-kotlin>","0","3","","","","CC BY-SA 4.0"
"53684317","1","53684470","","2018-12-08 16:04:24","","3","710","<p>I want to implement method to edit a note, save it to local database (cache) and then send it to the server as a POST request. I am learning RxJava and I wanted to create <code>Observable</code> from the note and then apply transformations on it, like to map it to an Entity model and saving. The issue that my method returns Completable and this chain returns <code>Observable&lt;Completable&gt;</code>. How to unwrap the <code>Completable</code> from this <code>Observable</code> which I used only to start RxJava stuff. Each <code>editNote()</code> methods returns a <code>Completable</code>.</p>

<pre><code> override fun editNote(note: Note): Completable {
    return Observable.just(note)
        .map { mapper.mapToEntity(it) }
        .map { noteEntity -&gt;
            factory.getCacheDataStore().editNote(noteEntity)
                .andThen { factory.getRemoteDataStore().editNote(noteEntity) }
        }
}
</code></pre>

<p>=======================================================</p>

<h1>UPDATE</h1>

<p>Finally, I managed to find ""a solution"" but I am not sure it is correct :-)</p>

<pre><code>override fun editNote(note: Note): Completable {
    return Observable.just(note)
        .map { mapper.mapToEntity(it) }
        .flatMapCompletable { noteEntity -&gt;
            factory.getCacheDataStore().editNote(noteEntity)
                .andThen { factory.getRemoteDataStore().editNote(noteEntity) }
        }
}
</code></pre>
","9188790","","9188790","","2018-12-08 16:19:01","2018-12-08 16:19:33","RxJava/Kotlin Observable method call chain - how to terminate?","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53761781","1","53764341","","2018-12-13 12:23:23","","0","135","<p>I have a State(Enum) that contains (Good, Non-Critical, Critical) values</p>

<p>So requirement is :</p>

<ol>
<li>should trigger when state goes in non-critical state.</li>
<li>should trigger when state goes in critical state.</li>
<li>should trigger when state stays in critical state for 15 seconds.</li>
</ol>

<p>Input : </p>

<pre><code>publishSubject.onNext(""Good"")
publishSubject.onNext(""Critcal"") 
publishSubject.onNext(""Critcal"") 
publishSubject.onNext(""NonCritical"")  
publishSubject.onNext(""Critacal"") 
publishSubject.onNext(""Critical"") 
publishSubject.onNext(""Good"")
and so on...
</code></pre>

<p>See Code Structure for Reference:</p>

<pre><code>    var publishSubject = PublishSubject.create&lt;State&gt;()
    publishSubject.onNext(stateObject)


    publishSubject
            /* Business Logic Required Here ?? */
            .subscribeOn(Schedulers.computation())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                AppLogger.printLog(""Trigger Success --&gt; "")
            }
</code></pre>

<p>Please help,
Thanks in Advance,</p>
","4051419","","4051419","","2018-12-13 13:02:06","2018-12-13 14:49:18","How can I achieve this requirement using Rx Java","<android><rx-java><rx-java2><rx-android><rx-kotlin>","2","5","","","","CC BY-SA 4.0"
"53812184","1","54114882","","2018-12-17 09:22:51","","1","73","<p>I have the following call to retrieve some data from server and update the UI according to response.</p>

<pre><code>    poiAPIService.getPoiDetails(poiId!!)
            .observeOn(AndroidSchedulers.mainThread())
            .doOnSubscribe { showProgressBar(true) }
            .doFinally { showProgressBar(false) }
            .subscribeOn(Schedulers.io()).subscribe(
                    { poiDetails -&gt;
                        bindPoiDetails(poiDetails)
                    },
                    {
                        (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                    })

}
</code></pre>

<p>It complains about showProgressBar that the Views are only accessable on thread that created them.
If I change the call like this, everything seems to be fine again.</p>

<pre><code>showProgressBar(true)
poiAPIService.getPoiDetails(poiId!!)
        .observeOn(AndroidSchedulers.mainThread())
        .subscribeOn(Schedulers.io()).subscribe(
                { poiDetails -&gt;
                    showProgressBar(false)
                    bindPoiDetails(poiDetails)
                },
                {
                    showProgressBar(false)
                    (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                })

}
</code></pre>
","859742","","","","","2019-01-10 07:31:07","RxJava/RxKotlin complains about accessing views","<android><rx-java><reactive-programming><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"53910822","1","","","2018-12-24 08:10:51","","0","84","<p>I'v got this method from <a href=""https://developer.android.com/guide/topics/providers/document-provider#open-client"" rel=""nofollow noreferrer"">here</a> and it works well:</p>

<pre><code>@Throws(IOException::class)
fun readTextFromUri(ctx: Context, uri: Uri): String {
    val stringBuilder = StringBuilder()
    ctx.contentResolver.openInputStream(uri)?.use { inputStream -&gt;
        BufferedReader(InputStreamReader(inputStream)).use { reader -&gt;
            var line: String? = reader.readLine()
            while (line != null) {
                stringBuilder.append(""$line\n"")
                line = reader.readLine()
            }
        }
    }
    return stringBuilder.toString()
}
</code></pre>

<p>Then converted it to this method that returns each line using Observable:</p>

<pre><code>fun getUriAsStringObservable(ctx: Context, uri: Uri): Observable&lt;String&gt; {
    return Observable.create {
        try {
            ctx.contentResolver.openInputStream(uri)?.use { inputStream -&gt;
                BufferedReader(InputStreamReader(inputStream)).use { reader -&gt;
                    var line: String? = reader.readLine()
                    while (line != null) {
                        it.onNext(line)
                        line = reader.readLine()
                    }
                    it.onComplete()
                }
            }
        } catch (e: IOException) {
            it.onError(e)
        }
    }
}
</code></pre>

<p>But it didn't work as I expected, after subscribing to it nothing is printed:</p>

<pre><code>getUriAsStringObservable(this, uri)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext {
        print(""Next: $it"")
    }
    .doOnError {
        print(""Error: $it"")
    }
    .doOnComplete {
        print(""completed"")
    }
    .subscribe()
</code></pre>

<p>What is my mistake?</p>
","3678849","","3678849","","2018-12-26 10:25:44","2018-12-27 05:52:11","Custom RxJava Observable emits nothing on subscribe","<observable><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"54040468","1","","","2019-01-04 14:04:07","","1","107","<p>I am trying to do some instrumented tests of a boilerplate code after migrating it to AndroidX. Note that before migration, all of them worked, but after, only unit tests work, the instrumented test crashes on Null Pointer exception, where it shouldnt.</p>

<p>Here is the errror: </p>

<pre><code>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'io.reactivex.Flowable io.reactivex.Flowable.subscribeOn(io.reactivex.Scheduler)' on a null object reference
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.data.interactor.FlowableUseCase.execute(FlowableUseCase.kt:26)
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.ui.browse.BrowseBufferoosViewModel.fetchBufferoos(BrowseBufferoosViewModel.kt:25)
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.ui.browse.BrowseActivity.onCreate(BrowseActivity.kt:40)
</code></pre>

<p>as you see, it's in the declaration of my ""UseCase"" in this case, get bufferoos. For reference, here is the class that fails:</p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/data/src/main/java/org/buffer/android/boilerplate/data/browse/interactor/GetBufferoos.kt"" rel=""nofollow noreferrer"">GetBufferoos</a></p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/data/src/main/java/org/buffer/android/boilerplate/data/interactor/FlowableUseCase.kt"" rel=""nofollow noreferrer"">Flowable Use case</a></p>

<p>Here is the test that fails </p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/mobile-ui/src/androidTest/java/org/buffer/android/boilerplate/ui/browse/BrowseActivityTest.kt"" rel=""nofollow noreferrer"">ActivityTest</a></p>

<p>Here is modules.kt for koin</p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/mobile-ui/src/main/java/org/buffer/android/boilerplate/ui/di/modules.kt"" rel=""nofollow noreferrer"">Modules</a></p>
","4806502","","4806502","","2019-01-04 15:05:45","2019-01-04 15:05:45","Koin testing on Androidx with Activity","<android><kotlin><rx-java><rx-kotlin><koin>","0","7","","","","CC BY-SA 4.0"
"54060856","1","","","2019-01-06 11:01:10","","0","144","<p>I've wanted to try RxJava with kotlin to make coding easier, so I've produced this:</p>

<pre><code>fun postAnswers() {
    disposable = getToken.execute().subscribe({ token -&gt;
        questions.forEach { form -&gt;
            val answers = form.answers?.filter { it.isChecked }?.map { it.answer_id }
            disposable = postAnswer.execute(token?.token!!, SavedAnswer(form.form_id, answers)).subscribe({
                //Post live data about success
            }, {
                //Post live data failure
            })
        }
    }, {
        //Post live data failure
    })
}
</code></pre>

<p>But I have an impression it can be done better, but I do not know how. Basically what I am trying to achieve is getting a Token object from database, that returns Flowable Token? and then use it to call postAnswer in a for cycle, because I need to post each answer separately (That's how the API is designed). After that, postAnswer only returns Completable, but I need to let the Activity know (this is from ViewModel code) how many answers were posted</p>

<p>I've thought about using .flatMap or .concat functions, but I am not sure if it will be helpful in this case. Also, do I need to assign getToken.execute() to disposable?</p>

<p>Thank you for your answers</p>

<p>EDIT:</p>

<p>Here is my questions list:</p>

<pre><code>private var questions: List&lt;Form&gt; = emptyList()
</code></pre>

<p>It gets filled by viewModel functions</p>
","4806502","","4806502","","2019-01-06 12:53:22","2019-01-24 23:09:32","Simplify the statement using rxkotlin","<kotlin><retrofit><rx-java><android-room><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"54379123","1","","","2019-01-26 14:04:51","","0","1061","<p>I've inherited this codebase which uses RxJava2 and kotlin with a rather peculiar Result pattern for API calls. i.e. all API calls return Singles with a Result object (which is a sealed class of Success and Error types as shown below) i.e.</p>

<pre><code>sealed class Result&lt;T, E&gt; {
    data class Success&lt;T, E&gt;(
            val data: T
    ): Result&lt;T, E&gt;()

    data class Error&lt;T, E&gt;(
            val error: E
    ): Result&lt;T, E&gt;()
}
</code></pre>

<p>Now I'm trying to chain together a bunch of API calls of these but need to terminate the chain on the first Result.Error in it and continue if not.</p>

<p>The only way I can think of is to zip all of the Singles and then have a zipper function that checks the type of each parameter and returns a <code>Result.Error()</code> with the first error it encounters. i.e. something like,</p>

<pre><code>Singles.zip(
    repo1.makeCall1(arg),
    repo1.makeCall2(arg2),
    repo2.makeCall1(arg3)
) { result1, result2, result3 -&gt;
    val data1 = when (result1) {
        is Result.Error -&gt; return@zip Result.Error(result1.error)
        is Result.Success -&gt; result1.data
    }
    val data2 = when (result2) {
        is Result.Error -&gt; return@zip Result.Error(result2.error)
        is Result.Success -&gt; result2.data
    }
    val data3 = when (result3) {
        is Result.Error -&gt; return@zip Result.Error(result3.error)
        is Result.Success -&gt; result3.data
    }

    return@zip Result.Success(MergedData(data1, data2, data3))
}
</code></pre>

<p>which works but looks really weird (and feels like a code smell with this huge ass zipper method). Also does not allow me to chain anything more after the last method (that checks if the Result is a Success / Error).</p>

<p>I feel it would be a lot more readable to be able to chain these calls and terminate on the first error but I don't know enough Rx to do this. Is there an operator or an approach that could help make this better?</p>
","2104070","","2413303","","2019-01-26 14:25:59","2019-01-29 20:27:52","How to break RxJava chain on error Result?","<android><rx-java><reactive-programming><rx-java2><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"54480893","1","54487008","","2019-02-01 13:50:57","","0","199","<p>I am writing some repository logic for android application, I have this logic for retrieving data from database and updating the database with data from api immediately after that.</p>

<pre><code>   fun fetchData(): Single&lt;Data&gt; {
    return Single.concatArrayEager(
            fetchFromDb(),
            fetchFromApi())
            .firstOrError()
}
</code></pre>

<p>By the way - database is Room and api is Retrofit. Now what happens is that room emits almost instantly, but for some reason api request is not fired - the second <code>Single</code> doesn't start. </p>

<p>I read the documentation on the eager operator and I am not sure if this is correct behavior. I even tried to delay the database fetch, by like 20 miliseconds - which resulted in that second single being actually fired</p>
","6855603","","","","","2019-02-01 20:52:51","Single concatArrayEager doesnt subscribe to all sources","<android><rx-java><rx-kotlin>","1","6","","","","CC BY-SA 4.0"
"54782735","1","54782844","","2019-02-20 09:19:39","","2","139","<p>I'm using a custom repository to get observables for data in a room database, e.g:</p>

<pre><code>fun getUsers(): Observable&lt;List&lt;User&gt;&gt; = userDao.getAll()
        .toObservable()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .doOnError { Logger.error(tag, ""error getting users: ${it.message}"") }
        .doOnNext { Logger.debug(tag, ""fetched ${it.size} users"") }
</code></pre>

<p>In my UI (Fragment) I start the subscription in <code>onResume</code>:</p>

<pre><code>override fun onResume() {
        super.onResume()
        userObserver = repository.getUsers()
            .subscribe {
                // handle user
            }
    }
</code></pre>

<p>And in the <code>onPause</code> I have:</p>

<pre><code>override fun onPause() {
        super.onPause()
        userObserver.dispose()
    }
</code></pre>

<p>Since each time <code>repository.getUsers()</code> is called, I'm creating a new Observable-object. Could this lead to memory leaks and should I rather try to reuse the observer instead of disposing and recreating it?</p>
","7855177","","7855177","","2019-02-20 09:57:42","2019-02-20 09:57:42","Reusing or recreating an observer?","<android><kotlin><android-room><rx-android><rx-kotlin>","1","0","0","","","CC BY-SA 4.0"
"55174860","1","55176706","","2019-03-15 02:48:59","","7","9785","<p>I'm confusing about use case for doOnSuccess in rxJava.<br>
Let's see the code:  </p>

<p>Case 1:  </p>

<pre><code>networkApi.callSomething()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())               
    .doOnSuccess(__ -&gt; showLog(SUCCESS))
    .doOnError(__ -&gt; showLog(ERROR))
    .subscribeBy(
             onSuccess = {//Do something}, 
             onError = {//Show log here}
          )
</code></pre>

<p>Case 2:</p>

<pre><code>networkApi.callSomething()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())               
    .subscribeBy(
             onSuccess = {
               //Do something
               showLog(SUCCESS)
             }, 
             onError = {showLog(ERROR)}
          )
</code></pre>

<p>As normal, I think case 2 is fine.<br>
I also have referred some source code in github and I saw some people do like case 1.<br>
I try to ask myself what is the use case for <code>doOnSuccess</code> here ?  </p>

<p>Is there any use case that we need apply <strong><code>doOnSuccess()</code></strong> operator ?</p>
","951917","","","","","2019-03-15 06:21:37","What is the use case for doOnSuccess vs onSuccess in rxJava","<android><retrofit><rx-java><rx-kotlin>","2","1","","","","CC BY-SA 4.0"
"55244285","1","55244679","","2019-03-19 15:13:18","","0","352","<p>I'm using the <code>io.reactivex.rxkotlin</code> extension function: </p>

<pre><code>fun &lt;T : Any&gt; Observable&lt;T&gt;.subscribeBy(
        onError: (Throwable) -&gt; Unit = onErrorStub,
        onComplete: () -&gt; Unit = onCompleteStub,
        onNext: (T) -&gt; Unit = onNextStub
        ): Disposable
</code></pre>

<p>And when I use this extension there is a difference if I choose to send a parameter or if I use lambda.
For example</p>

<p><strong>first implementation:</strong></p>

<pre><code>myObservable.subscribeBy { str -&gt;
    // onNext
}
</code></pre>

<p><strong>Second implementation:</strong></p>

<pre><code>myObservable.subscribeBy({ throwable -&gt;
    // onError
})
</code></pre>

<ul>
<li>in the <strong>first implementation</strong> the function is the <code>onNext</code></li>
<li>and in the <strong>second implementation</strong> the function is the <code>onError</code></li>
</ul>

<p>And I'm not sure why.</p>
","4409815","","","","","2019-03-19 15:34:01","Kotlin pass function as a parameter vs lambda implementation","<kotlin><kotlin-extension><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"55253503","1","55253850","","2019-03-20 04:14:30","","0","43","<p>i am trying the upload the image through rxkotlin, my problem is when i close my screen in my application, the uploading process gets terminated because am adding that subscription to my disposal, so when my screen closes or destroys i will be disposing. because of this dispose my job getting terminated, since anyway i need to dispose else it my leads to the memory leak                                                               </p>

<pre><code>fun uploadImage(imagePath : String){
   uploadToServer(imagePath)
        .subscribe()
        .addTo(disposal)   
}

override onCleared(){
   disposal.dispose()
}
</code></pre>

<p>So in this way i doing this, is there is any other way to continue this work, even after the screen destroys or cleared without memory leak ?</p>
","9344496","","","","","2019-03-20 05:01:53","RxKotlin - Process gets terminated when dispose is called","<android><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"55411838","1","55412118","","2019-03-29 06:45:11","","0","315","<p>i have a list of some strings, where i need to iterate the list in batch.<br>
Example :</p>

<pre><code>val list = [""a"",""b"",""c"",""d"",""e"",""f""]
Observable.fromIteratable(list)
          .map{
          //here i need to get 4 items at a time
          //like in first iteration i need to get [""a"",""b"",""c"",""d""]
          //in second iteration i need to get [""e"",""f""]
        }
</code></pre>

<p>Is there is any option to do perform this ?</p>
","9344496","","","","","2019-03-29 07:19:26","Rxjava - Iterate the list with batch","<android><rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"55437513","1","","","2019-03-31 03:02:06","","0","80","<p>I am using the RXKotlin combineLatest and I have a multiple source. but I am calling this like</p>

<pre><code>Observables.combineLatest(source1, source2)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
        },
        {

        }
    )
</code></pre>

<p>and</p>

<pre><code>Observables.combineLatest(source3, source4)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
        },
        {

        }
    )
</code></pre>

<p>now I just want to ask on how to use the combineLatest to my sources only once.</p>

<p>like this.</p>

<pre><code>Observables.combineLatest(source1, source2, source3, source4)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
            val third = it.third
            val fourth = it.fourth
            //...
        },
        {

        }
    )
</code></pre>

<p>I am always using this combineLatest but only with three parameters and I really don't know how or what should I do when I add more parameters to it.</p>

<p>Any help is appreciated, Thank you.</p>
","5693082","","5693082","","2019-03-31 04:52:19","2019-03-31 04:52:19","How to use combineLatest with multiple sources","<android><kotlin><rx-kotlin>","0","2","","2019-03-31 04:28:54","","CC BY-SA 4.0"
"55645167","1","55645276","","2019-04-12 05:43:20","","7","2265","<p>What is the difference between <code>rxjava2</code> dependency and <code>rxkotlin</code> dependency.
 If I'm using <code>rxkotlin</code> dependency, should i need to add <code>rxjava2</code> dependency along with that.</p>

<pre><code>implementation 'io.reactivex.rxjava2:rxkotlin:x.y.z'
// do i need to add the below dependencies also?
implementation 'io.reactivex.rxjava2:rxjava:2.2.4'
implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'
</code></pre>
","5351055","","","","","2020-08-13 12:17:54","What is the difference between rxjava2 and rxkotlin?","<android><kotlin><rx-java2><rx-kotlin>","4","0","","","","CC BY-SA 4.0"
"55727396","1","55737305","","2019-04-17 12:18:07","","0","182","<p>After struggling for a few days now, on what seems to be a simple task, I come to you guys:)</p>

<p>Idea is simple. I have two streams/observables, 'left' and 'right'.
I want items from 'right' to buffer/collect/aggregate to 'current' item in 'left'.<br>
Thus, each item in 'left' defines a new 'window', while all 'right' items will bind to that window, until a new 'left' item is emitted. So, to visualize:</p>

<p><strong>Task:</strong><br>
'left' &nbsp;&nbsp;&nbsp; : |- A - - - - - B - - C - - - -|<br>
'right' &nbsp; :       |- 1 - 2 - 3 -4 - 5 - 6 - - -|<br>
'result' : |- - - - - - - -x - - -y - - - -z| &nbsp;&nbsp;( <code>Pair&lt;Left, List&lt;Right&gt;&gt;</code>)<br>
<em>Where: <strong>A,1</strong> ; <strong>B,4</strong> (so x) ; <strong>C</strong> (so y) are emitted on the same time</em><br>
<em>So: &nbsp; &nbsp; &nbsp; x = Pair(A, [1,2,3]), &nbsp;&nbsp;y = Pair(B, [4, 5])</em><br>
<em>And: &nbsp; &nbsp;'right' &amp; 'result' complete/terminate when 'left' does</em><br>
<em>So: &nbsp; &nbsp; &nbsp;z = Pair(C, [6]) - emitted as a result of 'left' completing</em>  </p>

<p><strong>----</strong><br>
<strong>EDIT 2 - FINAL SOLUTION!</strong><br>
In order to aggregate 'right' items with the next 'left' and not the previous one, I changed the code to this much shorter/simpler one:  </p>

<pre><code>fun &lt;L, R&gt; Observable&lt;L&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;L, List&lt;R&gt;&gt;&gt; {
    return this.share().run {
        zipWith(right.buffer(this), BiFunction { left, rightList -&gt;
            Pair(left, rightList)
        })
    }
}  
</code></pre>

<p><strong>EDIT 1 - initial solution!</strong><br>
Taken from @Mark's (accepted) answer below, here's what I came up with.<br>
It is separated into smaller methods because I also do <code>multiRightGroupJoin()</code> to join in as many (right) streams as I want.  </p>

<pre><code>fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {
    return this.share().let { thisObservable -&gt;    //use 'share' to avoid multi-subscription complications, e.g. multi calls to **preceding** doOnComplete
        thisObservable.flatMapSingle { t -&gt;        //treat each 'left' as a Single
            bufferRightOnSingleLeft(thisObservable, t, right)
        }
    }
}
</code></pre>

<p>Where:  </p>

<pre><code>private fun &lt;T, R&gt; bufferRightOnSingleLeft(left: Observable&lt;*&gt;, leftSingleItem: T, right: Observable&lt;R&gt;)
    : Single&lt;Pair&lt;T, MutableList&lt;R&gt;&gt;&gt; {

    return right.buffer(left)                              //buffer 'right' until 'left' onNext() (for each 'left' Single) 
        .map { Pair(leftSingleItem, it) }
        .first(Pair(leftSingleItem, emptyList()))   //should be only 1 (list). THINK firstOrError
}  
</code></pre>

<p><strong>----</strong>  </p>

<p><strong>What I got so far</strong><br>
After much reading and the understanding that somehow there's no implementation for this out of the box, I've decided to use <code>groupJoin</code>, mostly using <a href=""https://leecampbell.com/2011/03/14/rx-part-9-join-window-buffer-and-group-join/"" rel=""nofollow noreferrer"">this link</a>, like so: <em>(many problems and places to improve here, don't use this code)</em>  </p>

<pre><code>private fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {

var thisCompleted = false //THINK is it possible to make the groupJoin complete on the left(this)'s onComplete automatically?
val thisObservable = this.doOnComplete { thisCompleted = true }
        .share() //avoid weird side-effects of multiple onSubscribe calls

//join/attach 'right/other' stream to windows (buffers), starting and ending on each 'this/left' onNext
return thisObservable.groupJoin(

    //bind 'right/other' stream to 'this/left'
    right.takeUntil { thisCompleted }//have an onComplete rule THINK add share() at the end?

    //define when windows start/end ('this/left' onNext opens new window and closes prev)
    , Function&lt;T, ObservableSource&lt;T&gt;&gt; { thisObservable }

    //define 'right/other' stream to have no windows/intervals/aggregations by itself
    // -&gt; immediately bind each emitted item to a 'current' window(T) above
    , Function&lt;R, ObservableSource&lt;R&gt;&gt; { Observable.empty() }

    //collect the whole 'right' stream in 'current' ('left') window
    , BiFunction&lt;T, Observable&lt;R&gt;, Single&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt;&gt; { t, rObs -&gt;
        rObs.collect({ mutableListOf&lt;R&gt;() }) { acc, value -&gt;
            acc.add(value)
        }.map { Pair(t, it.toList()) }

    }).mergeAllSingles()
}  
</code></pre>

<p>I also used similar usage to create a <code>timedBuffer()</code> - same as <code>buffer(timeout)</code> but with a timestamp on each buffer(<code>List</code>) to know when it started. Basically by running the same code on an <code>Observable.interval(timeout)</code> (as the 'left')</p>

<p><strong>Problems / Questions (from the easiest to the hardest)</strong>  </p>

<ol>
<li>Is it the best way of doing something like that? Isn't it an overkill?</li>
<li>Is there a better way (must be) for completing the 'result' (and 'right') when 'left' is completed? Without this ugly boolean logic?</li>
<li><p>This usage seem to mess up the order of the rx. See code and print below:  </p>

<pre><code>leftObservable
.doOnComplete {
    log(""doOnComplete - before join"")
 }
.doOnComplete {
    log(""doOnComplete 2 - before join"")
 }
.rightGroupJoin(rightObservable)
.doOnComplete {
    log(""doOnComplete - after join"")
 }
</code></pre></li>
</ol>

<p>Prints (sometimes! Looks like a race condition) the following:<br>
<code>doOnComplete - before join</code><br>
<code>doOnComplete - after join</code><br>
<code>doOnComplete 2 - before join</code>  </p>

<ol start=""4"">
<li><p>On first run of the above code, <code>doOnComplete - after join</code> is not called, on the second time it's called <strong>twice</strong>. Third time is like the first, forth is like the second, etc...<br>
Both 3,4 are ran using this code. Probably has something to do with the subscribe {} usage? Note that I don't hold the disposable.
This stream finishes because I GC the 'left' observable</p>

<pre><code>leftObservable.subscribeOn().observeOn()
.doOnComplete{log...}
.rightGroupJoin()
.doOnComplete{log...}
.subscribe {}  
</code></pre></li>
</ol>

<p>Note1: adding <code>.takeUntil { thisCompleted }</code> after <code>mergeAllSingles()</code> seems to fix #4.   </p>

<p>Note2: After using this method to join multiple streams and applying 'Note1', it's apparent that the onComplete (before the groupJoin() call !!!) will be called as many times as there are 'right' Observables, probably meaning that the cause is the <code>right.takeUntil { thisCompleted }</code>, is it really important to close the 'right' stream?  </p>

<p>Note3: concerning Note1, it seems very much related to takeUntil vs. takeWhile. Using takeWhile lowers the doOnComplete calls, and it's somehow logical. Still trying to figure it out better.</p>

<ol start=""5"">
<li>Can you think of a multiGroupJoin, or in our case, multiRightGroupJoin, other than running zip on groupJoin * rightObservablesCount?</li>
</ol>

<p>Please ask anything you like. I know for a fact the my usage of the subscribe/disposable and the manual onComplete are not the way, I'm just not sure enough what is..</p>
","2774781","","2774781","","2019-04-24 17:39:03","2019-04-24 18:01:18","Rx (RxKotlin) - rightGroupJoin using groupJoin - merge / combine two observables of different types","<rxjs><rx-java><reactive-programming><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 4.0"
"55874840","1","","","2019-04-26 20:56:34","","4","2653","<p>Why do I get different results when unit testing my ViewModel?</p>

<p>I got two tests. When I launch each test individually that's ok but when I launch all tests in a row I got an error.
It's a ViewModel that change state each time I got a return from an 
API. I expect to get <code>android.arch.lifecycle.Observer.onChanged</code> called two times but it's just called once for the second test.
Unit test works fine when I replace <code>verify(view, times(2)).onChanged(arg.capture())</code> with <code>verify(view, atLeastOnce()).onChanged(arg.capture())</code> at the first test.</p>

<p>UserViewModel :</p>

<pre><code>class UserViewModel(
        private val leApi: LeApi
): ViewModel() {
    private val _states = MutableLiveData&lt;ViewModelState&gt;()
    val states: LiveData&lt;ViewModelState&gt;
        get() = _states

    fun getCurrentUser() {
        _states.value = LoadingState
        leApi.getCurrentUser()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        { user -&gt; _states.value = UserConnected(user) },
                        { t -&gt; _states.value = FailedState(t) }
                )
        }
    }
}
</code></pre>

<p>UserViewModelTest :</p>

<pre><code>@RunWith(MockitoJUnitRunner::class)
class UserViewModelTest {

    lateinit var userViewModel: UserViewModel

    @Mock
    lateinit var view: Observer&lt;ViewModelState&gt;

    @Mock
    lateinit var leApi: LeApi

    @get:Rule
    val rule = InstantTaskExecutorRule()

    @Before
    fun setUp() {
        RxAndroidPlugins.setInitMainThreadSchedulerHandler { Schedulers.trampoline() }
        userViewModel = UserViewModel(leApi)
        userViewModel.states.observeForever(view)
    }

    @Test
    fun testGetCurrentUser() {
        val user = Mockito.mock(User::class.java)
        `when`(leApi.getCurrentUser()).thenReturn(Single.just(user))
        userViewModel.getCurrentUser()

        val arg = ArgumentCaptor.forClass(ViewModelState::class.java)
        verify(view, times(2)).onChanged(arg.capture())

        val values = arg.allValues

        assertEquals(2, values.size)
        assertEquals(LoadingState, values[0])
        assertEquals(UserConnected(user), values[1])
    }

    @Test
    fun testGetCurrentUserFailed() {
        val error = Throwable(""Got error"")
        `when`(leApi.getCurrentUser()).thenReturn(Single.error(error))
        userViewModel.getCurrentUser()

        val arg = ArgumentCaptor.forClass(ViewModelState::class.java)
        verify(view, times(2)).onChanged(arg.capture()) // Error occurred here. That's the 70th line from stack trace.

        val values = arg.allValues
        assertEquals(2, values.size)
        assertEquals(LoadingState, values[0])
        assertEquals(FailedState(error), values[1])
    }
}
</code></pre>

<p>Expected :
All tests passed.</p>

<p>Actual :</p>

<pre><code>org.mockito.exceptions.verification.TooLittleActualInvocations: 
view.onChanged(&lt;Capturing argument&gt;);
Wanted 2 times:
-&gt; at com.dev.titi.toto.mvvm.UserViewModelTest.testGetCurrentUserFailed(UserViewModelTest.kt:70)
But was 1 time:
-&gt; at android.arch.lifecycle.LiveData.considerNotify(LiveData.java:109)
</code></pre>
","11417436","","8134164","","2019-04-27 06:04:12","2019-08-25 09:26:08","Unit Test : Observer onChanged should be called twice instead of once","<android><unit-testing><mockito><android-viewmodel><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"55897609","1","55902557","","2019-04-29 05:46:08","","0","127","<p>I need to zip more than 3 observables with zip operator in rxkotlin, but when i try to zip more than 3 it shows me compile time error.<br>
<strong>Example</strong></p>

<pre><code> Observables.zip(Observable.just(someFun(0),Observable.just(someFun(1),Observable.just(someFun(2),Observable.just(someFun(3))
</code></pre>

<p>Is there we can zip more than 3 observable ?<br>
Any help</p>
","9344496","","","","","2019-04-29 11:38:03","Rxkotlin - How to zip more than three observables with zip operator","<rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"55914451","1","","","2019-04-30 05:27:21","","0","43","<p>I have a three layers in my application <strong>app</strong>, <strong>data</strong>, <strong>domain</strong>, i will be getting my result entity for my <strong>app</strong> from <strong>domain</strong> layer , the result entity class will be implementing with some interface <strong>L1</strong>, my need is when the result reaches app layer i need to replace the interface <strong>L1</strong> which is implemented in result entity  to interface <strong>L2</strong></p>

<p>Example<br>
<strong>Domain</strong></p>

<pre><code>interface L1
</code></pre>

<p>The above interface will not contain any methods or variables </p>

<pre><code>data class Result(val data : Any) : L1
</code></pre>

<p><strong>App</strong> </p>

<pre><code>interface L2
</code></pre>

<p>same as like interface L1</p>

<pre><code>data class Result(val data : Any) : L2
</code></pre>

<p>I am not sure whether i can achieve using rxkotlin, i had a rough idea about it like</p>

<pre><code>@Binds
abstract fun bindL1WithL2(l2 : L2) : L1
</code></pre>

<p>Is there is any solution for this ?<br>
Any help</p>
","9344496","","","","","2019-04-30 05:27:21","Android - Replacing One interface with other one using rx-kotlin","<android><kotlin><rx-java><rx-kotlin>","0","3","","","","CC BY-SA 4.0"
"55963637","1","","","2019-05-03 05:11:40","","-1","287","<p>I am using retrofit2 for making service call in my application, i need to show the progress percentage for the service call which is made using retrofit, the result of the call will be of some JSON object. we know that for downloading files we can use <code>@Streaming</code> and <code>ResponseBody</code> in retrofit for getting progress percent, but am unaware for the JSON response.</p>

<p>Example</p>

<pre><code>@POST(""/getdata"")
fun callSomeApi(@Query(""id"") id : String) : Observable&lt;Data&gt;
</code></pre>

<p>Is there is any option to get progress percent for JSON response using retrofit ?<br>
Any help</p>
","9344496","","","","","2019-05-03 11:06:58","Android - How to get progress for normal http call using retrofit","<android><kotlin><retrofit2><rx-kotlin>","1","1","1","","","CC BY-SA 4.0"
"56117279","1","","","2019-05-13 17:33:37","","1","39","<p>I'm using rxAndroid with an MVVM architecture. In my Activity, I need to bind my streams then fetch data from the server, which will eventually call the downstream.</p>

<p>My reasoning is the following:<br>
- I need to unsubscribe my streams in <code>onStop()</code> (<code>onDestroy</code> can cause memory leaks).<br>
-> therefore I need to subscribe to them in <code>onStart()</code> (otherwise coming back from background doesn't recreate the stream).<br>
-> therefore I need to fetch my data in or after <code>onStart()</code>, because the stream has to be bound before I can start calling the upstream.  </p>

<p>But in this case, every time I come back to the app after background, it's going to call the fetch method, which is not a behavior I want. Ideally I'd like to call the fetch method once, for example in <code>onCreate()</code>.</p>

<p>How can I nicely deal with this problem? I've tried finding solutions on SO and other websites but no luck.</p>
","10909037","","","","","2019-09-13 19:21:31","When to subscribe/bind streams in android lifecycle?","<android><kotlin><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56252342","1","56252954","","2019-05-22 08:23:21","","0","53","<p>I am trying to get access_token with RXjava.</p>

<p>I ran the program and called the function that requests the access_token, but the process finishes with code 0.</p>

<p>I think the main thread is dead while connecting the server</p>

<p>my solution was
<code>Thread.sleep(sometime)</code>
to give short time to get the response.</p>

<p>and I also tried </p>

<pre><code>val runnable = Runnable{ getToken() }
val thread = Thread(runnable)
thread.run()
thread.join()
</code></pre>

<p>but it didn't work..</p>

<p>here is my code below</p>

<pre><code>fun main(args : Array&lt;String&gt;) {
    getToken()

//    Thread.sleep(10000) // it works but don't want to do with this
}



fun getToken() {
    val id = ""test""
    val pw = ""test""
    println(id + "" "" + pw)

    val oAuthService = Retrofit.Builder()
        .baseUrl(URL)
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .addConverterFactory(GsonConverterFactory.create())
        .client(httpClient)
        .build()
        .create(OAuthService::class.java)

    oAuthService.getAccessToken(
        CLIENT_ID,
        CLIENT_SECRET,
        id,
        pw
    ).subscribeOn(Schedulers.io())
        .flatMap {
            when(it.error){
                null -&gt; Single.just(TokenDto.Success(it.access_token?:"""", it.expires_int?:0, it.token_type?:"""", it.refresh_token?:""""))
                else -&gt; Single.just(TokenDto.Failure(""failed""))
            }
        }
        .retry { times, throwable -&gt;
            println(throwable)
            times &lt; 3 }
        .subscribeBy(
            onSuccess = {
                println(""onSuccess"")
                when(it){
                    is TokenDto.Success -&gt; {
                        println(""accessToken : ${it.access_token}"")
                    }
                    is TokenDto.Failure -&gt; {
                        println(""failed : ${it.msg}"")
                    }
                }
            },
            onError = {
                println(""onError"")
            }
        )
}


</code></pre>

<p>retrofit</p>

<pre><code>interface OAuthService {

    @FormUrlEncoded
    @POST(""oauth2/token"")
    fun getAccessToken(
        @Field(""client_id"") client_id:String,
        @Field(""client_secret"") client_secret:String,
        @Field(""username"") username:String,
        @Field(""password"") password:String
    ):Single&lt;TokenResponse&gt;
</code></pre>
","11532568","","8200936","","2019-05-22 10:11:38","2019-05-22 10:42:46","main function is dead while rxjava is working. any solution please","<kotlin><rx-java><retrofit2><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56362602","1","56363137","","2019-05-29 14:12:05","","3","129","<p>I have a simple setup to a problem but the solution seems to be more complicated.</p>

<p>Setup: I have a hot observable which originates from a scanner that will emit every number as a different element and an <code>R</code> when a code is complete.</p>

<p>Problem: From this I want a hot observable that emits every full code as 1 element.</p>

<p><a href=""https://i.stack.imgur.com/Rh5Xg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Rh5Xg.png"" alt=""RxMarbles example""></a></p>

<p>I tried playing around with different <code>flatMap</code>, <code>takeUntil</code> and <code>groupBy</code>operators but haven't been able to come to a solution.</p>
","776141","","","","","2019-05-29 15:41:56","Take elements until a certain character and group them with RxJava","<java><kotlin><rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56547732","1","56556776","","2019-06-11 16:04:36","","0","165","<p>How can I collect emitted values from observable to array?</p>

<p><strong>Input:</strong></p>

<pre><code>Observable.just(1,2,3,4,5,6)
</code></pre>

<p><strong>Expected output:</strong></p>

<pre><code>[1,2,3,4,5,6]
</code></pre>
","2543013","","2543013","","2019-06-11 16:57:10","2019-06-12 07:29:11","RxJava collect emitted values to array","<rx-java><rx-java2><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"56569345","1","","","2019-06-12 19:42:30","","1","318","<p>How can I collect emitted items from observable to List when observable never completes?</p>

<p>Example I have something similar so Observable emits series of values, but never completes unless you unsubscribe, because of that <code>.toList()</code> not gonna work.</p>

<pre><code>Observable&lt;User&gt;
 .flatMap {}
 .toList()
</code></pre>

<p>How can I collect All users to List and emit it once after applying flatMap function to it?</p>
","2543013","","","","","2019-06-12 20:40:43","RxJava Collect emission to list","<android><rx-java><rx-java2><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"56660075","1","","","2019-06-19 04:29:48","","1","90","<p>I have a list of items say for example list of integers, if any of the integer is null, i need to consume the error and proceed with the next item</p>

<p>For example</p>

<pre><code>Observable.fromIterable(listOf(1, 2, 3, null, 5))
                .map {
                    doSomeProcess(it)
                }
                .onErrorReturnItem(-1)
                .subscribeBy(
                        onNext = {
                           print(it)
                        },
                        onError = {

                        },
                        onComplete = {

                        })
</code></pre>

<p>I am expecting the output like this</p>

<pre><code>1
2
3
-1
5
</code></pre>

<p>But my problem is after <code>-1</code> it is not getting proceeded with item <code>5</code>, it stops there, Can anyone help me out with this ?</p>
","9344496","","","","","2019-06-19 06:49:24","How to handle errors in rxjava chain in android?","<android><rx-java><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"56740292","1","","","2019-06-24 16:03:53","","0","272","<p>I've tried some examples with viewmodels and databinding using BehaviorSubjects and other Observables. Now I have real (data class) object in Kotlin, which holds most of the state. It is basically pojo, but independent from viewmodel and has no observables.
I don't understand how can I bind this automatically to ex. TextView in android without creating external observable variables in viewmodel and some boilercode. I'd think this is something very common in mvvm pattern. Or am I missing something totally?</p>
","4070660","","4070660","","2019-06-24 16:17:42","2019-06-25 15:20:03","Model properties binding in android viewmodel","<rx-java><rx-java2><rx-android><rx-kotlin><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"56867353","1","56867985","","2019-07-03 09:49:17","","2","145","<p>I need to make a lot of API calls asynchronously and obviously make sure that they all pass so I can handle error/success in a single place.</p>

<p>Is there a way to easily extend Singles.zip() functionality in Kotlin to take more than base 9 parameters (in best case scenario, to make it take any given number of parameters) without doing massive amounts of copy-paste work when writing your own extensions for t10, t11, etc. ?</p>

<p>Well, writing dozens of extensions simply works, but is cumbersome, not very elegant and adds additional work.</p>
","10675759","","","","","2019-07-03 12:17:18","Extending Rx Singles zip infinitely","<java><android><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"57049336","1","57051371","","2019-07-16 02:32:23","","2","187","<p>I have a <code>Category</code> data class and a <code>Plan</code> data class.
Each <code>Category</code> has a list of plan ids. There are Categories and Plans stored via Room.  I am trying to construct a local <code>List&lt;Any&gt;</code> where I add each category to a list, and then add each of it's plans.</p>

<p>So for each category, add the category to the list, then add each plan that belongs to that category.</p>

<p>The final result would look something like this...</p>

<pre><code>0 -&gt; a Category
1 -&gt; a Plan
2 -&gt; a Plan
3 -&gt; a Plan
4 -&gt; a Category
5 -&gt; a Plan
</code></pre>

<p>etc.</p>

<p>The following calls sucessfully return an <code>Observable&lt;List&lt;Category&gt;&gt;</code> and an <code>Observable&lt;Plan&gt;</code></p>

<pre><code>AppDatabase
   .getDatabase(context)
   .categoryDao()
   .getAll()

AppDatabase.getDatabase(context).planDao().getPlan(planId)
</code></pre>

<p>Here I am trying to build my list, but it actually never emits when I subscribe to it. No completion, or error. Everything else in the stream get's hit. Why can't I get my final result?</p>

<pre><code>    fun fetchCategoriesAndPlans() {
    val items = mutableListOf&lt;Any&gt;()
    AppDatabase
        .getDatabase(context)
        .categoryDao()
        .getAll()
        .concatMap { listOfCategories -&gt;
            listOfCategories.toObservable()
        }
        .doOnNext { category -&gt;
            items.add(category)
        }
        .concatMap { category -&gt;
            category.getPlanIds()!!.toObservable()
        }
        .flatMap { planId -&gt;
            AppDatabase.getDatabase(context).planDao().getPlan(planId)
        }.collectInto(items, BiConsumer{ list, i -&gt;
            Log.d(TAG, ""Collect into"")
            list.add(i)
        })
        .subscribeBy(
            onSuccess = {
                Log.d(TAG, ""Got the list"")
            },
            onError = {
                Log.e(TAG, ""Couldn't build list ${it.message}"", it)
            })
}
</code></pre>
","629259","","629259","","2019-07-16 02:54:01","2019-07-16 06:38:48","Building a list from two observable sources in RxKotlin/RxJava using collectInto","<android><rx-java2><android-room><collect><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"57063614","1","57928983","","2019-07-16 18:41:56","","1","365","<p>1) The code below fails to compile with an error: ""not enough information to infer type variable R""</p>

<pre><code>keywordChanges
  .withLatestFrom(searchParamsSubject)
  .subscribe { (keyword, searchParams) -&gt;
     ...
  }
</code></pre>

<p>2) The code below compiles and works, but I would prefer not to have an empty <code>subscribe()</code> and not to put side effects into the combiner function.</p>

<pre><code>keywordChanges
  .withLatestFrom(searchParamsSubject) { keyword, searchParams -&gt;
    searchParamsSubject.onNext(searchParams.copy(keyword = keyword))
  }
  .subscribe()
</code></pre>

<p>3) Below is the code from the RxKotlin library, that I am trying to call in 1)</p>

<pre><code>/**
 * Emits a `Pair`
 */
inline fun &lt;T, U, R&gt; Observable&lt;T&gt;.withLatestFrom(other: ObservableSource&lt;U&gt;): Observable&lt;Pair&lt;T,U&gt;&gt;
        = withLatestFrom(other, BiFunction{ t, u -&gt; Pair(t,u)  }
</code></pre>

<h3>How could I modify the code in 1) to make it work?</h3>
","133309","","","","","2019-09-13 18:55:30","RxKotlin ""withLatestFrom(...)"" compile error: not enough information to infer type variable R","<kotlin><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"57188728","1","","","2019-07-24 17:56:16","","1","266","<p>I am new to Android development, I'm trying to make form validation using RxKotlin and RxBinding.</p>

<p>I need a guidance how to make form validation with more than 9 fields?
Actually I can combine the result using <code>Observable.combinelatest</code>.</p>

<p>This is the code I've been trying:</p>

<pre><code>Observable.combineLatest(profileObserver, shopName, shopAddress, ownerName, idCard, ownerHp, ownerEmail, pin, confirmPin,
                Function9&lt;CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence,
                        Boolean&gt; {profile, name, address, owner, card, hpNumber, email, currentPin, confirmationPin -&gt;
                    return@Function9 isShopNameValid(name.toString()) &amp;&amp; isShopAddressValid(address.toString())
                            &amp;&amp; isOwnerNameValid(owner.toString())
                            &amp;&amp; isIdCardValid(card.toString())
                            &amp;&amp; isOwnerHpValid(hpNumber.toString())
                            &amp;&amp; isOwnerEmail(email.toString())
                            &amp;&amp; isPinValid(currentPin.toString())
                            &amp;&amp; isConfirmPinValid(confirmationPin.toString())
                }).subscribe {
                registrationProcess.isEnabled = it
            }
</code></pre>

<p>I still have 3 more fields to be validated.</p>
","5501860","","8412192","","2019-08-02 07:41:36","2019-09-13 15:01:37","RxKotlin combine latest more than 9 fields","<rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"57404599","1","57404794","","2019-08-08 02:58:31","","1","270","<p>Unfortunately, my REST Delete operation work only for one item. So what I was trying to do is,</p>

<pre><code>Observable.just(items).flatMapIterable { items -&gt; items }.flatMap {
                //call REST DELETE for every item
            }.flatMap {
                // call REST GET
            }
</code></pre>

<p>The problem is the GET call is being called for every item. How can I wait for finishing all the delete done and then perform the GET call? </p>

<p>Thanks in Advance.</p>
","1077539","","3633468","","2019-08-08 09:48:56","2019-08-08 09:48:56","Perform a task for all items in a list and then perform another task in RxJava","<java><android><kotlin><rx-java><rx-kotlin>","3","5","","","","CC BY-SA 4.0"
"57469647","1","57480686","","2019-08-13 00:10:33","","0","158","<p>I'm trying for some time now to implement an extension function (just becuse it's easier to me) that is capable of delaying both normal item emissions and errors. The existing delay operators only delays normal item emissions, errors are delivered ASAP.</p>

<p>For context, I'm trying to immitate an Android LiveData's behavior (kinda). LiveDatas are a observable pattern implementation that is lifecycle aware. Their observers are only notified if they are in a state where they can process that emission. If they are not ready, the emission is cached in the livedata and delivered as soon as they become ready.</p>

<p>I created a BehaviourSubject that emits the state of my Activities and Fragments when it changes. With that I created a delay operator like this:</p>

<pre><code>fun &lt;T&gt; Flowable&lt;T&gt;.delayUntilActive(): Flowable&lt;T&gt; = delay { lifecycleSubject.toFlowable(BackpressureStrategy.LATEST).filter { it.isActive } }
</code></pre>

<p>and then use it like this</p>

<pre><code>myUseCase.getFlowable(Unit)
                .map { it.map { it.toDisplayModel() } }
                .delayUntilActive()
                .subscribe({
                    view.displaySomethings(
                }, { }).addTo(disposables)
</code></pre>

<p>So even if myUseCase emits when the view is not ready to display somethings, the emission won't reach onNext() until the view does become ready. The problem is that I also want the view to displayError() when onError is triggered, but that too is lifecycle sensitive. If the view isn't ready, the app will crash.</p>

<p>So I'm looking for a way to delay both emissions and errors (onComplete would be good too). Is this possible?
I tried some things with zip, onErrorReturn, delay inside delay, but nothing seemed right. I'd be equally unimpressed if this had a really easy solution I'm overlooking, or is impossible. Any ideas are welcome.</p>

<p>Bonus: any better way to do that for Single and Completable too? currently I'm just converting them to flowable. </p>

<p>Thanks in advance!</p>
","10614184","","10614184","","2019-10-05 03:34:53","2019-10-05 03:34:53","Is it possible to implement an operator like delay but that also delays errors?","<android><rx-java2><reactivex><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"57618052","1","57672830","","2019-08-22 23:13:53","","0","166","<p>I have 2 observable sources where <code>fetchProductList()</code> returns <code>Observable&lt;Datasource&gt;</code> and other <code>canInvite.execute()</code> takes a value and returns a <code>Single&lt;Boolean&gt;</code>. I need to compose the stream to feed every emission from first source to the second in a way that I can return all the emission from <code>fetchProductList()</code> with the <code>true</code> value as a list. I tried to compose it this way but it looks a bit clunky, Any better/simpler ways to do it?</p>

<pre><code>fetchProductList()
                    .map { dataSource -&gt; dataSource.data }
                    .flatMap{ data -&gt;
                        Observable.from(data.roles.map { role -&gt;
                            canInvite.execute(role.key).map { canInvite -&gt;
                                role to canInvite
                            }
                        })
                    }

                    .compose { it -&gt; Single.merge(it) }
                    .filter { it -&gt; it.second == true}
                    .map { it -&gt; it.first }
                    .toList()
                    .subscribe {
</code></pre>
","2231099","","","","","2019-08-27 10:36:20","Composing two observable sources using one as a predicate in RxJava","<android><rx-java><reactive-programming><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"57874011","1","","","2019-09-10 15:31:57","","0","113","<p>In my project, I use RxJava/RxKotlin bindings to communicate with REST API. The API sometimes returns a list of elements, that need to be altered/mapped, before I can use them.</p>

<p>Currently, mapping of these elements is done by nested <code>.map()</code> and <code>.apply()</code> functions, like this:</p>

<pre><code>fun getSampleObjects(): Single&lt;List&lt;SampleObject&gt;&gt; =
    sampleService.getSampleObjects()
        .map { list -&gt;
            list.map { sampleObject -&gt;
                sampleObject.apply {
                    sampleProperty = otherSampleService.getSampleProperty()
                }
            }
        }
</code></pre>

<p>where <code>sampleService.getSampleObjects()</code> returns and RxKotlin <code>Single&lt;List&lt;SampleObject&gt;&gt;</code></p>

<p>I'm looking for an easier-to-read and more efficient way to archive the same result, possibly without the need to alter data models.</p>
","5930112","","","","","2019-09-10 20:02:51","Mapping elements of collection from RX Single/Observable","<generics><kotlin><collections><rx-java><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"57889004","1","","","2019-09-11 12:19:02","","3","73","<p>I am making 2 RX calls that are nested within each other and are co-dependent. There is an issue with the server (which cannot be solved right now for various reasons) which returns errors in the 2nd nested call. </p>

<p>Until this gets solved, I need to have it that if the 2nd call returns an error, the results of the first call are discarded as well. Right now, the entire iterative process stops the moment any of these error responses occur, and so my goal is to skip over them. </p>

<p>Here is what my call structure currently looks like: </p>

<pre><code> fun getAllDynamicUtterances(module: String) {

    var uttList: ArrayList&lt;DynamicUtterance&gt;? = ArrayList()
    rxSubs?.add(
        repository.getDynamicUtterances(module).map{res -&gt;
            res.uttSets.forEach {utt -&gt;
                    utt.module = res.module!!
                    utt.transferInputValues()
                    utt.generateDefaultFlatTree()
                    uttList?.add(utt)
                    insertDynamicUtterance(utt)
                    repository.updateDynamicUtteranceView(utt).blockingForEach {
                        utt.assignSelectionStrings(it)
                        repository.storeDynamicUttPieces(utt.inputUttPieces)
                        utt.uttLinearisations = it.linearisations
                        updateDynamicUtterance(utt)
                    }
            }
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread()).subscribe ({
                allDynamicUtterances?.postValue(uttList)
            },{
                Log.e(""errorHandle"",it.toString())
            })
    )
}
</code></pre>

<p>My thinking is to include an if statement that almost does a ""peek"" of the second call before proceeding, but I'm not sure how to go about it. This is what I came up with so far to give an idea of my thinking: </p>

<pre><code>fun getAllDynamicUtterances(module: String) {

    var uttList: ArrayList&lt;DynamicUtterance&gt;? = ArrayList()
    rxSubs?.add(
        repository.getDynamicUtterances(module).map{res -&gt;
            res.uttSets.forEach {utt -&gt;
                    utt.module = res.module!!
                    utt.transferInputValues()
                    utt.generateDefaultFlatTree()
                if (doesNotReturnError(utt)){ // &lt;- add this
                    uttList?.add(utt)
                    insertDynamicUtterance(utt)
                    repository.updateDynamicUtteranceView(utt).blockingForEach {
                        utt.assignSelectionStrings(it)
                        repository.storeDynamicUttPieces(utt.inputUttPieces)
                        utt.uttLinearisations = it.linearisations
                        updateDynamicUtterance(utt)
                    }
                }
            }
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread()).subscribe ({
                allDynamicUtterances?.postValue(uttList)
            },{
                Log.e(""errorHandle"",it.toString())
            })
    )
}
</code></pre>

<p>and then adding this function, or a function that performs what it is im trying to achieve in any case.</p>

<pre><code>private fun doesNotReturnError(utt: DynamicUtterance): Boolean{
   rxSubs?.add(
       repository.updateDynamicUtteranceView(utt).subscribeOn(Schedulers.io())
           .observeOn(AndroidSchedulers.mainThread())
           .subscribe({
             //cant put a return here :(
           }, {
               Timber.e(it)
           })
   )
    //returning over here will return nothing wont it? 
}
</code></pre>

<p>I welcome comments on how to improve my <em>getAllDynamicUtterances</em> function</p>
","860233","","13860","","2019-09-11 13:51:29","2019-09-13 15:43:34","How can I use the response result of an RXJava call as a condition for an if statement inside another RXJava function?","<android><kotlin><rx-java><okhttp><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"58108921","1","58333082","","2019-09-26 02:49:50","","1","38","<p>Basically my Android app have some meta data which need to report to backend server in different scenarios:</p>

<pre><code>data class SearchMetaData(
    val searchId: String?,
    val isRateLimit: Boolean
)
</code></pre>

<p>In order to make the code clean, I make the minimal case as follows. All the report logic are similar, each of the function <code>subscribe</code> the metadata provider and get the value that need to report.</p>

<pre><code>fun logEvent1() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event1.session = sessionMetadata
        ...
        report(event1)
    })
}

fun logEvent2() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event2.session = sessionMetadata
        ...
        report(event2)
    })
}

fun logEvent3() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event3.session = sessionMetadata
        ...
        report(event3)
    })
}
</code></pre>

<p>My concern is every time we change the schema of metadata, we need to update all the <code>logEventX</code> , I was wondering if maybe we could extract all the <code>subscribe</code> in different functions and get the metadata?</p>
","1319619","","13302","","2019-09-29 21:07:34","2019-10-11 01:28:00","RxJava: How to extract same observeOn from different functions?","<android><rx-java><reactive-programming><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"58492711","1","","","2019-10-21 19:07:28","","0","96","<p>A, B, C are objects</p>

<p>All function calls are made to a Rooms DB</p>

<p>This code snippet is inside a ViewModel</p>

<p>repo = Repository</p>

<p>So I'm making an android app (can't provide details) and for a particular screen I need to do the following.</p>

<p>My first call is repo.getInfo, which returns a Single Observable ListOfA: <code>Single&lt;List&lt;A&gt;&gt;</code> //perform some operations</p>

<p>for every element of ListOfA I need to call another function repo.getB(A) which returns a Single Observable ListOfB: <code>Single&lt;List&lt;B&gt;&gt;</code>  //perform some operations</p>

<p>for every element of ListOfB I need to call another function repo.getC(B) which returns a Single Observable ListOfC: <code>Single&lt;List&lt;C&gt;&gt;</code>  //perform some operations</p>

<p>after I have the required data I need to call another function that combines the data to display on the UI.</p>

<p>Now I can't get this to work. Here's what I've tried. But the flow stops at the line marked THIS LINE and jumps to subscribe block.
Individual calls to the functions work so the data is not the problem.
I'm pretty new at this and quite frankly out of my depth. Any help or hint is appreciated. Thanks</p>

<pre><code>localListOfA = emptyList&lt;A&gt;()
localListOfB = emptyList&lt;B&gt;()
localListOfC = emptyList&lt;C&gt;()
compositeDisposable.add(
    getInfo.map{listOfA -&gt;
        localListOfA.addAll(listofA)
        listOfA.map {elementA -&gt;   ////THIS LINE
            getB(elementA.id).map{listOfB -&gt;
                listOfB.filter {
                    //some logic to select a few objects
                }
            }.map { it // filtered list of B
                localListofB.addAll(it)
                localListOfB.last() //I only need the top element of this list
            }.map{elementB -&gt;
                getC(elementB.id).map{ listOfC -&gt;
                    localListOfC.addAll(listOfC)
                    //do some operations
                }
            }
        }
    }
    .subscribeOn(DEFAULT_CACHED_SCHEDULERS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnError(/*take log*/)
    .subscribe{
        prepareUi()
    }
)
</code></pre>
","12253227","","","","","2019-10-21 20:42:00","Fetching a Single<List> for all elements of another Single<List> in RxKotlin","<android><rx-java><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"58788392","1","","","2019-11-10 11:55:26","","1","46","<p>How to get value <code>time</code> from this code </p>

<pre><code>val TAG = MainActivity::class.java.name
TrueTimeRx.build()

    .initializeRx(""time.google.com"")

    .subscribeOn(Schedulers.io())

    .subscribe({ time -&gt;
        Log.v(TAG, ""TrueTime was initialized and we have a time: $time"") },
        { throwable -&gt; throwable.printStackTrace() }

    )
</code></pre>

<p>and put it in this code</p>

<pre><code>helloWorld=findViewById(R.id.helloWorld)

val newTime=getString(R.string.hello, time)
helloWorld.text=newTime
</code></pre>

<p>how to take <code>time</code> from the first part of the code and to put it in the second</p>

<p>code above is in <code>onCreate()</code></p>

<p>and if it's important i have this </p>

<pre><code>internal lateinit var helloWorld: TextView
</code></pre>
","12343312","","9968399","","2019-11-10 12:32:54","2019-11-10 12:55:14","How to pass value","<android><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"58795905","1","58796309","","2019-11-11 05:21:00","","1","330","<p>I've created rx function to call a network call from <code>view-model</code> in android, it parses network on main thread function. </p>

<p>I just change few line of code it worked. but i need to know the reason for this because its use same builder pattern to create a <code>rx-call</code>.
once I tried with changing <code>.doOnSubscribe()</code> ,<code>doOnComplete ()</code>           , <code>.applySchedulers()</code> after the flatmap call it worked? how is  this happened?</p>

<pre><code>fun loadjobs(var countryID:String){
subscription.add(
repository.getMainJobsFromLocal(countryID)
          .doOnSubscribe { postProgress(StatusModel(Status.IN_PROGRESS))}
          .doOnComplete { postProgress(StatusModel(Status.COMPLETED)) }
          .applySchedulers()
          .flatMap {
           if (it.isNullOrEmpty()) {
              repository.getMainJobsFromServer(countryID)
           } else {
              Flowable.just(Response.success(it))
           }
          }
          .subscribe({
            if (it.isResponseOk()) {
             postProgress(StatusModel(Status.SUCCESS))
             mainJobResponse.postValue(it.body())
           } else {
             postProgress(StatusModel(Status.FAILED))
             mainJobResponse.postValue(null)
           }
          }, {
           postProgress(StatusModel(Status.FAILED))
           mainJobResponse.postValue(null)
        }))
}


fun loadjobs(var countryID){
subscription.add(
repository.getMainJobsFromLocal(countryID)
          .flatMap {
           if (it.isNullOrEmpty()) {
             repository.getMainJobsFromServer(countryID).flatMap {
               Flowable.just(it)
             }
           } else {
             Flowable.just(Response.success(it))
           }
          }.doOnSubscribe { postProgress(StatusModel(Status.IN_PROGRESS)) }
            .doOnComplete { postProgress(StatusModel(Status.COMPLETED)) }
            .applySchedulers()
            .subscribe({
              if (it.isResponseOk()) {
                postProgress(StatusModel(Status.SUCCESS))
                mainJobResponse.postValue(it.body())
               } else {
               postProgress(StatusModel(Status.FAILED))
               mainJobResponse.postValue(null)
              }
           }, {
            postProgress(StatusModel(Status.FAILED))
            mainJobResponse.postValue(null)
    }))
}
</code></pre>
","8415366","","2185295","","2019-11-11 06:27:43","2019-11-11 06:27:43","Retrofit - android.os.NetworkOnMainThreadException with RxKotlin","<android><android-viewmodel><flatmap><rx-kotlin>","2","2","","","","CC BY-SA 4.0"
"59104815","1","59104982","","2019-11-29 12:27:22","","1","55","<p>I have this function which gets a parameter and first checks for its value. if it was null then gets its value from the result of fisrtFun() which returns a Single&lt; String>.</p>

<p>after that either that parameter was null or not, it returns the result of secondFun() which gets that parameter as input</p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    return if (userId == null) {
        firstFun().flatMap { id-&gt;
            secondFun(id)
        }
    } else {
        secondFun(id)
    }
}
</code></pre>

<p>But as you see I used if-else blocks and have written secondFun() multiple times</p>

<p>so I tried to make it cleaner </p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    val id = userId ?: fisrtFun().blockingGet()!!
    return secondFun(id)
}
</code></pre>

<p>I want to know if there is a better way to achieve this functionality without using blockingGet() to avoid blocking the thread </p>
","8838667","","","","","2019-11-29 12:38:33","How to make this block of code written with RxKotlin cleaner and avoid blocking thread?","<android><kotlin><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"59352476","1","","","2019-12-16 07:56:18","","0","61","<p>I have PublishSubject for observing status change and also I have method with multiple steps, which I execute in another thread. How I can force stop this thread when subject received changes?</p>
","7185703","","","","","2019-12-16 08:24:12","How to force stop thread","<android><multithreading><kotlin><rx-java><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"59523262","1","59525955","","2019-12-29 21:02:42","","1","257","<p>TL;DR Looking for recommendations on robust offline support using rx-kotlin. </p>

<p>I've followed a nice <a href=""https://medium.com/@eslam.hussein/dominate-remote-local-data-with-rx-retrofit-room-mvp-f2b13a0ac27b"" rel=""nofollow noreferrer"">guide on offline-support in Android apps</a>. 
It works like this: </p>

<ol>
<li>Load data from the Internet, go to step 3 if error</li>
<li>Store the data in the local database</li>
<li>Load the data from the local database</li>
<li>Display the data in the UI</li>
</ol>

<p>The code is:</p>

<pre><code> Observable.mergeDelayError(
                loadRemoteData()
                    .doOnNext { writeDataToLocalDatabase(it) }
                    .subscribeOn(Schedulers.io()), 
                loadDataFromLocalDatabase()
                    .subscribeOn(Schedulers.io())
            )
</code></pre>

<p>Unfortunately, this approach relies on the database code always working. If the database operations for some reason fail, everything fails, even when the data is loaded successfully from the remote server.</p>

<p>Is there a way I can achieve the following using rx-kotlin/rx-java?:</p>

<ol>
<li>Load data from the Internet, go to step 3 if error</li>
<li>Store the data in the local database</li>
<li>Load the data from the local database</li>
<li><strong>(if steps 2 or 3 failed) Use the data from step 1</strong></li>
<li>Display the data in the UI</li>
</ol>

<p>I'd like to avoid loading the data from the Internet twice. I'm using room + retrofit, if that matters.</p>

<p>EDIT:
Thanks to @MinseongPark, I ended up with the code below. 
The mergeDelayError reports an error only if both the remote and the local source fails, and if the <em>writeDataToLocalDatabase</em> method fails (throws an Exception), then that does not keep the remote data from being reported to the UI. The information about errors in <em>writeDataToLocalDatabase</em> is saved by reporting it  remotely. 
Now, the code is robust to one of the two sources failing, and to writing new entries to the database failing. </p>

<pre><code>        return Observable.mergeDelayError(
            loadRemoteData().doOnNext {
                try {
                    writeDataToLocalDatabase(it)
                } catch (error: Throwable) {
                    Timber.d(error)
                    Crashlytics.logException(error)
                }
            },
            loadDataFromLocalDatabase()
        )
            .subscribeOn(Schedulers.io())
</code></pre>
","788913","","788913","","2019-12-31 16:28:21","2019-12-31 16:28:21","How to implement robust offline support with rx-kotlin?","<android><rx-java><rx-kotlin>","1","3","","","","CC BY-SA 4.0"
"59536511","1","","","2019-12-30 20:28:20","","1","33","<p>I wanna fetch data from roomDB when variable changed. When folderName changed and when task changed.
I use <code>MediatorLiveData</code>, but it doesn't work.
How can I fix it?</p>

<p>This is a view model class.</p>

<pre><code> val folderName = ViewModelFolder.selectedFolder // MutableLiveData&lt;String&gt;
 val filteredTasks = MediatorLiveData&lt;LiveData&lt;List&lt;Task&gt;&gt;&gt;()
 init {
   filteredTasks.addSource(folderName) { name -&gt;
     filteredTasks.value = getTasksByFolderIsDone(name, false)
   }
}
</code></pre>

<p>Main activity</p>

<pre><code>taskViewModel.filteredTasks.observe(viewLifecycleOwner, Observer { tasks -&gt;
  tasks?.let { taskAdapter.setTasks(tasks as List&lt;Task&gt;) }
})
</code></pre>
","7359831","","","","","2019-12-30 20:28:20","Android: want to fetch data from roomDB when 2 variables changed","<android><kotlin><android-room><rx-kotlin>","0","2","","","","CC BY-SA 4.0"
"59708108","1","59708986","","2020-01-12 21:03:49","","2","1105","<p>I have a problem and I don't know how to resolve it with a better aproach. The problem is that I'm requesting to Spotify Web API and in some methods the artist image is returned and in others only basic artist info is obtained.</p>

<p>I have this two methods:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;SpotifyAlbumDTO&gt;

fun getArtist(artistId: String): Single&lt;SpotifyArtistDTO&gt;
</code></pre>

<p>When I get an album, the artist info doesn't contains the artist image url. So, I need to call the getAlbum() method and use the result to obtain the artistId and then call to getArtist() method. </p>

<p>I have the following method to do all this stuff:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;Album&gt;
</code></pre>

<p>On this method I need to call the previous two to return an Album object (my domain object). The only solution that worked for me it's the following:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;Album&gt; {
  return Single.create { emitter -&gt;
    _spotifyService.getAlbum(albumId).subscribe { spotifyAlbum -&gt;
      _spotifyService.getArtist(spotifyAlbum.artist.id).subscribe { spotifyArtist -&gt;
        val artistImage = spotifyArtist.imageUrl
        spotifyAlbum.artist.image = artistImage
        emitter.onNext(spotifyAlbum.toAlbum())
      }
    }
  }
}
</code></pre>

<p>I think that must exist another better way to do this than concating subscribe calls in other subscribes and creating deeper calls. I also try the following:</p>

<pre><code>_spotifyService.getAlbum(albumId).flatMap { spotifyAlbum -&gt;
  _spotifyService.getArtist(spotifyAlbum.artist.id)
}.flatMap { spotifyArtist -&gt;
  // Here I don't have the album and I can't to asign the image         
}
</code></pre>
","3828964","","","","","2020-01-13 10:33:15","RXJava/Kotlin - Chaining Single results in one","<rx-java><system.reactive><rx-kotlin>","2","0","1","","","CC BY-SA 4.0"
"59775506","1","","","2020-01-16 18:09:01","","2","488","<p>So I have the following test that keeps failing with the following error: </p>

<blockquote>
  <p>java.lang.AssertionError: No values (latch = 1, values = 0, errors = 0, completions = 0) </p>
</blockquote>

<pre><code>val ocrProcessor = mockk&lt;FirebaseFormProcessor&gt;()
        val date = listOf(DateTextExtraction())

        every { ocrProcessor.scan(any(), any(), any()) } answers {
            thirdArg&lt;OcrResultCallback&gt;().invoke(date)
        }

        viewModel = FormViewModel(ocrProcessor)

        viewModel.addImage(bitmap)

        viewModel.ocrAlert
            .test()
            .assertValue {
                it == date
            }
            .addTo(disposeBag)
</code></pre>

<p>What this tries to test is the following:</p>

<pre><code>override val ocrAlert: PublishSubject&lt;List&lt;TextExtractionInterface&gt;&gt; = PublishSubject.create()

override fun addImage(bitmap: Bitmap) {
    if (files.value.isEmpty())
        ocrProcessor.scan(bitmap, extract = textExtractionItems) { ocrResult -&gt;
            ocrAlert.onNext(ocrResult)
        }
}
</code></pre>

<p>I am not quite sure what I am doing wrong here but I think it might have to do with threading problems.</p>

<p>edit:</p>

<p>I changed the code to this now:</p>

<pre><code>        val toBeTested = viewModel.ocrAlert
            .subscribeOn(scheduler)
            .observeOn(scheduler)
            .test()

        viewModel.addImage(bitmap)

         toBeTested   
            .assertValue {
                it == date
            }
            .addTo(disposeBag)
</code></pre>
","1453253","","1453253","","2020-01-20 11:09:31","2020-01-20 11:09:31","UnitTesting async code rxjava/rxkotlin fails with latch = 1 error","<android><rx-java2><rx-kotlin>","0","16","1","","","CC BY-SA 4.0"
"59874945","1","59878149","","2020-01-23 09:14:08","","0","95","<p>I want to print at a time of ArrayList.</p>

<p>Before:</p>

<pre><code>class ExampleUnitTest {
    @Test
    fun test(){
        val stringArray = arrayOf(""10"", ""20"", ""30"", ""40"", ""30"", ""20"", ""10"", ""5"", ""20"", ""30"", ""20"", ""30"").map { it }
        println(stringArray.toString())
    }
}

# output is :
[10, 20, 30, 40, 30, 20, 10, 5, 20, 30, 20, 30]
</code></pre>

<p>After:</p>

<pre><code># I Want to output Like this :
10, 20, 30, 40, 30, 20, 10, 5, 20, 30, 20, 30
</code></pre>

<p>How can I do this coding by Reactivex Java(RxJava)</p>

<pre><code># something like... e.g..
Observable ...{
   ... ...
}.subscribeOn(Schedulers.io())
.subscribe({
   ... ...
})
</code></pre>
","12029427","","","","","2020-10-10 02:07:10","Kotlin: How to Output at a time the ArrayList from Rxjava","<java><android><kotlin><rx-java><rx-kotlin>","2","1","","","","CC BY-SA 4.0"
"60065075","1","60095956","","2020-02-04 20:28:02","","1","61","<p>Good afternoon.
So I got a list with a list inside like this:</p>

<pre><code>    {
  ""category"" : [
    {
      ""name"": ""Bathroom"",
      ""products"": [
        {
          ""name"": ""Sink01""
        },
        {
          ""name"": ""Shower01""
        }
      ]
    },{
      ""name"": ""Kitchen"",
      ""products"": [
        {
          ""name"": ""Table""
        },
        {
          ""name"": ""Stove""
        }
      ]
    }
  ]
}
</code></pre>

<p>So if the user for example selects the category ""Bathroom"" I want to use rxjava to filter the list of products from the category ""Bathroom"" and if they select the category ""Kitchen"" I want to get the list of products from the category ""Kitchen"".</p>

<p>This is what I've tried so far:</p>

<pre><code>    fun getProducts(category: Category): Single&lt;MutableList&lt;Product&gt;&gt; {
         return service.getProductsByCategories().filter{ response -&gt;
             response.categoriesList.forEach {
                if (it.name == category.name) {
                  category.products
                }
             }
         }
    }
</code></pre>

<p>Right now I am getting ""Typed mismatch. Requieres: <code>Single&lt;MutableList&lt;Product&gt;&gt;</code>, Found: <code>Maybe&lt;MyResponse!&gt;!</code>""</p>

<p>Why is this happening?
What is the correct way to filter?</p>

<p>Thanks in advance.</p>

<p>Greetings</p>
","1344550","","61158","","2020-02-06 14:29:44","2020-02-06 14:29:44","How to do the filter operator from a list of a list in rxjava","<kotlin><rx-java><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"60088358","1","","","2020-02-06 05:41:04","","0","74","<p>I want to emit events after non periodic intervals and I want to set the interval for emission of each event programatically using Rxjava in Android. How do I do that?</p>
","12759574","","208273","","2020-03-12 03:53:25","2020-03-12 03:53:25","Emit events after non periodic intervals using rx java","<java><android><rx-java><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60162061","1","60162271","","2020-02-11 04:31:21","","3","1210","<p>I am calling one api which gives Http status code 400 </p>

<p>This is my NetworkBoundResourceNoDb</p>

<pre><code>public abstract class NetworkBoundResourceNoDb&lt;RequestType&gt; {

    private Observable&lt;Resource&lt;RequestType&gt;&gt; result;

    @MainThread
    protected NetworkBoundResourceNoDb() {
        Observable&lt;Resource&lt;RequestType&gt;&gt; source;
        source = createCall()
            .subscribeOn(Schedulers.io())
            .doOnError(t -&gt; onFetchFailed())
            .observeOn(AndroidSchedulers.mainThread());

        result = Observable.ambArray(source);
    }


    public Observable&lt;Resource&lt;RequestType&gt;&gt; getAsObservable() {return result;}

    protected boolean onFetchFailed() {
        return false;
    }


    @NonNull
    @MainThread
    protected abstract Observable&lt;Resource&lt;RequestType&gt;&gt; createCall();
}
</code></pre>

<p>This is API code </p>

<pre><code>@GET(""api/content/count"")
Observable&lt;List&lt;WordCountData&gt;&gt; wordCount();
</code></pre>

<p>This is repository Function</p>

<pre><code>    fun wordCount(): Observable&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt;? {
    return object : NetworkBoundResourceNoDb&lt;List&lt;WordCountData&gt;&gt;() {

        override fun createCall(): Observable&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt; {
            return courseApi.wordCount()
                .flatMap { learntWords -&gt;
                    Observable.just(
                        if (learntWords == null) Resource.error("""", emptyList())
                        else Resource.success(learntWords)
                    )
                }
        }

    }.asObservable
}
</code></pre>

<p>This is viewmodel Code</p>

<pre><code>private var wordCount = MutableLiveData&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt;()

fun getWordCountLiveData() = wordCount

fun getWordCountList() {
    courseRepository.wordCount()?.subscribe { resource -&gt; getWordCountLiveData().postValue(resource) }
}
</code></pre>

<p>This is my view code</p>

<pre><code>private fun loadWordCount() {
    crViewModel = ViewModelProviders.of(this, viewModelFactory).get(CrViewModel::class.java)
    crViewModel.getWordCountLiveData().observe(this, androidx.lifecycle.Observer {
        resource -&gt; when {
        resource.isLoading -&gt; println(""loading"")
        resource.data != null -&gt; {
            drawChart(resource.data)
        }
        else -&gt; handleErrorResponse()
    }
    })
    crViewModel.getWordCountList()
}
</code></pre>

<p>I need to pass Http Status code to view. i am able to get the error in onFetchfailed in repository while implementing it with throwable parameter but not able to handle it after that</p>

<p>it gives  me ""io.reactivex.exceptions.OnErrorNotImplementedException: HTTP 400 "" Error</p>

<p>please help me thanks in advance  </p>
","6846277","","","","","2020-02-11 04:58:46","Error Handling of Rxjava in mvvm using retrofit","<android><mvvm><retrofit><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60256254","1","","","2020-02-17 05:10:11","","0","116","<p>I am getting:</p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: The exception
  was not handled due to missing onError handler in the subscribe()
  method call</p>
</blockquote>

<p>I had tried to add</p>

<pre><code>.doOnError { error -&gt;
            Log.i(""reverser code error"",error.localizedMessage)
       }.onErrorReturn { err -&gt;
          ""Return method""
     }
</code></pre>

<p>But it's not working.</p>
","8946399","","9141664","","2020-02-17 05:15:47","2020-02-17 05:37:59","How to handle errors on RxKotlin + Graphql","<android><kotlin><graphql><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60367289","1","60367442","","2020-02-23 22:01:04","","0","115","<p>I'm trying to implement redux state update pattern using RXJava</p>

<pre><code>val subject=PublishSubject.create()
val subject1=PublishSubject.create()

// multiple threads posting 
// on subject and subject1 here. Concurrently 


subject.mergeWith(subject1)
       .scan(
             getInitState(),
             {state, event -&gt;
               // state update here 
             }
         )
        .subscribe({state -&gt;
          // use state here
        })
</code></pre>

<p>As you can see, I'm using <code>scan</code> operator to maintain the state. </p>

<p>How can I be sure that the state updates happen sequentially even when multiple threads are producing events? </p>

<p>Is there some mechanism in <code>scan</code> operator which makes the events stand in some queue while waiting for current state update function to finish?</p>

<p><strong>What I have done:</strong></p>

<p>I have successfully implemented this pattern in Android environment. It's really easy because if you always do the state update in </p>

<p><code>AndroidSchedulers.mainThread()</code> </p>

<p>And make state object immutable you are guaranteed to have atomic and sequential state update. But what happens if you don't have dedicated scheduler for state updates? What if you are not on Android?</p>

<p><strong>What I have researched:</strong></p>

<ul>
<li><p>I have read the source code for <code>scan</code> operator and there is no
waiting ""queue"" involved. Just simple state update and emission</p></li>
<li><p>I have also read SerializedSubject source code. There indeed is a waiting queue which serializes emissions. But what happens if I have two subjects? Serializing both of them doesn't mean that they don't interfere with each other.</p></li>
</ul>
","3904645","","","","","2020-02-23 22:32:47","Ensure sequential state update when using RXJava scan operator","<android><redux><rx-java2><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60652490","1","","","2020-03-12 10:47:27","","0","116","<p>I have a function in repository that calls three APIs which return three different type of Objects. </p>

<pre><code>fun scanSource(code: String) =
    firstApi.DataV11Get(code)
        .flatMap {
            firstApi.sccGet(it.sscc)
        }
        .flatMap {
            lastApi.lsccGet(it.id)
        }
</code></pre>

<p>currently it is only returning the result of last API in the ViewModel .Now I want to have result of all of these in viewmodel.</p>

<p>plus the api must be sequential as they are using the data from the last API.</p>

<p>Also each API returns a different Object type.And I want all of three objects once all three calls are finished.</p>

<p>Thanks</p>
","2877863","","","","","2020-03-12 10:59:50","Combine three APIs' result in RxKotlin","<android><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60653309","1","60655058","","2020-03-12 11:34:31","","0","367","<p>I am trying to parse the data from the server to my mobile device and I am using <code>Rx</code> , <code>Kotlin</code> , <code>retrofit</code> for this </p>

<p><strong>ApiInterface.kt</strong></p>

<pre><code>@GET(""api/v1/admin/class/getUsers/learner/{classId}"")
    fun getStudentsRx(
        @Header(""access_token"") accessToken: String,
        @Path(""classId"") apiKey: String
    ): Observable&lt;StudentResultResponse&gt;
</code></pre>

<p><strong>I am trying to subscribe as follows:</strong></p>

<pre><code> private fun getServerDataDisposable(dataService: ApiInterface): Disposable {
        return dataService.getStudentsRx(accessToken,classId)
            .subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeWith(object: DisposableSingleObserver&lt;List&lt;StudentModel&gt;&gt;(), Observer&lt;StudentResultResponse&gt; {

                override fun onSuccess(movies: List&lt;StudentModel&gt;) {
                }

                override fun onError(e: Throwable) {

                }

                override fun onChanged(t: StudentResultResponse?) {
                    TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.
                }

            })
    }
</code></pre>

<p><strong>I am getting error:</strong></p>

<p><a href=""https://i.stack.imgur.com/AaAyf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AaAyf.png"" alt=""enter image description here""></a></p>
","1083093","","","","","2020-03-12 13:23:28","Using Observable in Kotlin to parse a API response","<android><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60796695","1","","","2020-03-22 06:54:06","","0","97","<p>I am new to Rx and I am making one API call using Rx. It is working but the problem is that it is continuously making the API after I received response or error. I am using the MVVM pattern. </p>

<p>Here is my code how I am observing result in View Model:</p>

<pre><code>val usersList = getGitHubUsersUseCase.getUsers(since.toInt())

        usersList?.subscribeOn(Schedulers.io())
            ?.observeOn(AndroidSchedulers.mainThread())
            ?.subscribe({
                if (it.error == null) {
                    var sinceState = SinceState(since, since.isNotEmpty(), it.users)
                    stateLiveData.postValue(sinceState)
                } else {
                    var sinceState =
                        SinceState(since, since.isNotEmpty(), emptyList(), it.error?.message)
                    stateLiveData.postValue(sinceState)
                }
            }, {
                var sinceState = SinceState(since, since.isNotEmpty(), emptyList(), it.message)
                stateLiveData.postValue(sinceState)
            })
</code></pre>

<p>How do I stop observing once I received a response or an error? Am I missing something?</p>

<p>If I don't stop this continuously making calls, then it makes too many API calls and server start returning:</p>

<blockquote>
  <p>HTTP 403 forbidden</p>
</blockquote>
","4623481","","391691","","2020-03-23 00:01:08","2020-03-23 00:01:08","Android KotlinRx API call making continuously in background","<android><kotlin><rx-kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"60905481","1","60930218","","2020-03-28 18:54:21","","0","43","<p>I'm failing to get into the ReactiveX mindset or the codebase I am working in is just poorly written.</p>

<p>Suppose I have some Observable A() and I need data from another Observable B() in order to do validation on data coming through A, how do I accomplish this in RxJava (would prefer RxKotlin implementation). Note that both A and B return a Single of a List of objects.</p>

<pre><code>fun B(): Single&lt;List&lt;Bar&gt;&gt; {
  ...
}

fun A() : Single&lt;List&lt;Foo&gt;&gt; {
  Single.just(readRecords()).map { record -&gt;
    // val bar = B.getAll()??? This seems like an anti-pattern and I'm not sure if it would necessarily be right to .subscribe()???

    if (bar.contains(record)) {
      // ... some validation
    }
  }
}
</code></pre>

<p>Update 1: Should emphasize that the validation requires multiple sources so you could have B, C, D, etc.</p>
","10303350","","10303350","","2020-03-30 13:55:31","2020-03-30 14:19:00","Using data from another observable","<rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"61201439","1","61202156","","2020-04-14 05:49:47","","1","68","<p>Trying to come with a offline-first app, I managed to make a working repository pattern which first check the cache, then the database and finally, the api. I do that like this:</p>

<pre><code>private fun cachedTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }
private fun databaseTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }
private fun apiTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }

Maybe.concat(cachedTopics(), databaseTopics(), apiTopics())
     .firstOrError()
     .subscribeOn(scheduler)
</code></pre>

<p>Now, the thing is that I save partial data in the database (not all topics). If a user is connected to internet and browse the data displayed will only be the data in the database. But that's not all the content a user should access (if they are connected to internet). I'm aware this is due to the <code>.firstOrError()</code> call.</p>

<p><strong>But I wonder if there is a way to concatenate the distinct results of database + api (api might fail and thus return 0 results) and return a Single.</strong> </p>

<h2>Edit</h2>

<p>To be clearer I want something like the following:</p>

<pre><code>IF CACHE IS NOT EMPTY
   RETURN DISTINCT(DB + CACHE)
ELSE
   UPDATE CACHE WITH API RESULT
   RETURN DISTINCT(DB + API)
</code></pre>

<p>Where API calls will automatically result in having nor results if it fails.</p>
","11269045","","11269045","","2020-04-14 07:02:23","2020-04-14 07:16:25","Repository pattern concatenating results in RXKotlin","<android><kotlin><repository-pattern><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"61225108","1","","","2020-04-15 09:11:08","","1","90","<p>If I have 2 apps and the user had logged in one of them. How can I make the user automatically login in the other app? So, one login in either app is sufficient for accessing both of them.</p>

<p>For e.g. like if I have Amazon app I don't have to login in to my Amazon prime app if I am already logged in Amazon app. </p>
","8416125","","9851608","","2020-04-15 12:05:06","2020-04-15 12:05:06","How to have single login in my all other apps like Amazon do","<android><kotlin><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"61399761","1","61400101","","2020-04-24 01:48:39","","0","100","<p>Learning android with a two friends and right now we're focusing on just UI portion. One friend gave us the task of creating a display with dashed line divider. We're trying to add it in the Adapter file so it can be loaded in our fragment as part of the recycler view but can't figure out how.</p>

<p>Here's the layout in where the dotted line drawable gets passed in </p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:app=""http://schemas.android.com/apk/res-auto""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""&gt;
    &lt;ImageView
        android:id=""@+id/dashes""
        android:background=""@drawable/dashes_line""
        android:layout_width=""match_parent""
        android:layout_height=""match_parent""/&gt;
&lt;/LinearLayout&gt;
</code></pre>
","13373484","","13373484","","2020-04-24 02:43:35","2020-04-24 02:43:35","Android line divider","<android><kotlin><android-recyclerview><rx-kotlin><data-class>","2","0","","","","CC BY-SA 4.0"
"61443660","1","","","2020-04-26 15:49:47","","0","369","<p>I have a drawable that's being displayed in a layout. The drawable has default properties such as color and width. I'm creating a data class to be able to update those when the recycler view is created. The part that fills in the color in the middle is working. But I'm stuck on how to actually update the drawable width and the ImageView margins from the viewHolder.</p>

<p>mydrawable.xml
    
    
        
    </p>

<p>The layout file</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:app=""http://schemas.android.com/apk/res-auto""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""&gt;
    &lt;ImageView
        android:id=""@+id/rect_outline""
        android:src=""@drawable/mydrawable""
        android:layout_width=""match_parent""
        android:layout_height=""match_parent""
        android:layout_gravity=""center""
        android:layout_marginStart=""12dp""
        android:layout_marginEnd=""12dp""
        app:layout_constraintBottom_toBottomOf=""parent""
        app:layout_constraintEnd_toEndOf=""parent""
        app:layout_constraintHorizontal_chainStyle=""spread""
        app:layout_constraintStart_toStartOf=""parent""
        app:layout_constraintTop_toTopOf=""parent""/&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>The data class</p>

<pre><code>data class ImageData(
    val c: String
    val width: Int
    val marginLeft : Int
</code></pre>

<p>)</p>

<p>MyViewHoler.kt</p>

<pre><code>internal class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
fun bind(item: ImageData) {
   itemView.rect_outline.setColorFilter(Color.parseColor(item.c))

}
</code></pre>

<p>}</p>
","13373484","","","","","2020-04-26 16:53:44","Update Image width and Margins programmatically","<android><kotlin><android-recyclerview><rx-kotlin><data-class>","1","2","","","","CC BY-SA 4.0"
"62023546","1","62023948","","2020-05-26 13:43:52","","0","248","<p>How do to use operators so that i always get the previous and the current value? If possible i want to avoid creating state outside the pipe.</p>
<pre><code>- time -&gt;
1      2      3      4
|      |      |      |
Operations
       |      |      |
       (1,2)  (2,3)  (3,4)

</code></pre>
<p>Note that every value besides the first and the last one have to appear twice, so a simple buffer won't do.</p>
<p>I thought about combining <code>skip</code> with <code>merge</code> and <code>buffer</code> but merge does not seem to guarantee ordering.</p>
<pre><code>val s = PublishSubject.create&lt;Int&gt;()
s.mergeWith(s.skip(1)).buffer(2).subscribe{i -&gt; print(i)}
s.onNext(1)
s.onNext(2)
s.onNext(3)
s.onNext(4)


</code></pre>
<blockquote>
<p>output:<br />
[1, 2][2, 3][3, 4]</p>
</blockquote>
<pre><code>val o = Observable.just(1,2,3,4)
o.mergeWith(o.skip(1)).buffer(2).subscribe{i -&gt; print(i)}
</code></pre>
<blockquote>
<p>output:<br />
[1, 2][3, 4][2, 3][4]</p>
</blockquote>
<p>(the sole 4 is fine, and expected)</p>
","7479173","","7479173","","2021-07-16 16:33:33","2021-07-16 16:33:33","Rxjava - How to get the current and the previous item?","<kotlin><rx-java><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"62044835","1","","","2020-05-27 13:54:28","","0","48","<p>I believe there is some big gap in my understanding about RxJava</p>

<p>suppose we have this interface:</p>

<pre><code> interface SecretInterface {
    fun getSecretKey(): Single&lt;Int&gt;
  }

  interface Vault {
    fun openSecret(): Single&lt;String&gt;
  }
</code></pre>

<p>and then I have this test:</p>

<pre><code> @Test
  fun should_check_on_this() {
    val mockSecret = mock&lt;SecretInterface&gt; {
      on { this.getSecretKey() }.thenReturn(Single.just(1), Single.just(2),
          Single.just(3))
    }

    val mockVault = mock&lt;Vault&gt; {
      on { this.openSecret() }.thenReturn(Single.error(Exception(""no can do"")),
          Single.just(""secret opened""))
    }

    val complexStuff = mockSecret.getSecretKey().doOnSuccess {
      System.err.println(""onSuccess secret top $it"")
    }.flatMap {
      mockVault.openSecret()
    }.retryWhen {
      it.flatMapSingle {
        mockSecret.getSecretKey().doOnSuccess { System.err.println(""onSuccess secret bottom: $it"") }
      }
    }

    val test = complexStuff.test()
    test.assertValue { it == ""secret opened"" }
    verify(mockSecret, Times(3)).getSecretKey()
  }
</code></pre>

<p>the test failed, because mockSecret.getSecretKey() invocated only twice, but in output:</p>

<pre><code>onSuccess secret top 1
onSuccess secret bottom: 2
onSuccess secret top 1

org.mockito.exceptions.verification.TooFewActualInvocations: 
secretInterface.getSecretKey();
Wanted 3 times:
</code></pre>

<p>things that I can not understand is:</p>

<pre><code>    -It's already resubscribed, but how come still using old value?
    -How I can make it, that every time I resubscribed always return the latest value?
  in this case it should return 3 not 1.
</code></pre>

<p>thank you</p>
","6908091","","","","","2020-05-27 13:54:28","Rx java subscribe 3 times but invocation only 2 times","<kotlin><rx-java2><rx-kotlin>","0","2","","","","CC BY-SA 4.0"
"62258222","1","62260657","","2020-06-08 08:44:33","","0","924","<p>I can't convert this method to RxJava3 despite having upgraded the dependencies</p>

<pre><code>fun setSearchField(searchField: EditText) {
        searchDisposable = searchField.afterTextChangeEvents()
            .skipInitialValue()
            .debounce(400, TimeUnit.MILLISECONDS)
            .map { it.editable()?.toString() ?: """" }
            .distinctUntilChanged()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(::onSearchQueryUpdated)
    }
</code></pre>

<p>Type mismatch.
Required:
io.reactivex.rxjava3.disposables.Disposable?
Found:
io.reactivex.disposables.Disposable!</p>

<pre><code>    def retrofit_version = '2.9.0'
    implementation ""io.reactivex.rxjava3:rxjava:3.0.4""
    implementation ""io.reactivex.rxjava3:rxkotlin:3.0.0""
    implementation ""io.reactivex.rxjava3:rxandroid:3.0.0""
    implementation ""com.jakewharton.rxbinding3:rxbinding:3.1.0""
    implementation ""com.squareup.retrofit2:retrofit:$retrofit_version""
    implementation ""com.squareup.retrofit2:converter-gson:$retrofit_version""
    implementation ""com.github.akarnokd:rxjava3-retrofit-adapter:3.0.0""
    implementation ""com.squareup.okhttp3:logging-interceptor:4.7.2""
</code></pre>

<p>How should I accurately clean  the project from RxJava2?</p>

<p>I tried Invalidate caches/Restart: nothing happened.</p>

<p><a href=""https://i.stack.imgur.com/Vy89v.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vy89v.png"" alt=""enter image description here""></a></p>
","13072160","","13072160","","2020-06-08 09:25:33","2020-06-08 11:07:30","Can't migrate accurately from RxJava2 to RxJava3","<android><rx-java2><rx-kotlin><rx-binding><rx-java3>","1","2","","","","CC BY-SA 4.0"
"62497713","1","","","2020-06-21 11:13:50","","0","41","<p>I'm trying to do calculating one by one, asynchronously.</p>
<pre><code>fun method1(): Int{
return 2+2
}

fun method2(value: Int): Int{
return value * 2
}

fun method3(value: Int): Int{
return value * 3
}
</code></pre>
<p>Now I want method 2 work after method 1 and take result from her. Also method 3 work after method 2 and take result from her.
Is it possible to do that with rxkotlin and make it in one stream ?</p>
","10405000","","10405000","","2020-06-21 11:22:35","2020-08-10 08:03:31","Combine 3 single results - one stream","<rx-java><reactive-programming><rx-java2><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"62767181","1","62767231","","2020-07-07 02:19:41","","0","110","<p>Excuse the pun, had to do it to em.</p>
<p>I have an observable that is declared like so:</p>
<pre><code>Observable
        .interval(20, TimeUnit.MILLISECONDS)
        .subscribe {
            val timeDiff = System.currentTimeMillis() - testSum
            Log.i(&quot;LOG&quot;, &quot;TIME DIFF: $timeDiff&quot;)
            testSum = System.currentTimeMillis()

            mVisualizer.getWaveForm(waveformByteArray)
            onWaveFormDataCaptureManual(waveformByteArray)
        }
</code></pre>
<p>And no matter what I try to do, this observable will not die. disposables.add() (which seems to be the answer in Java) gives me an unresolved reference error. Before that, I can't even save it to a variable either, as that also shows a lot of red on the screen.</p>
<p>FYI I've Googled this problem. Nothing works.</p>
","5196674","","","","","2020-07-07 02:33:05","To Kill an Observable","<android><kotlin><rx-java><reactivex><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"63131880","1","","","2020-07-28 10:18:44","","0","34","<p>Hello friends to improve the code below; Is there a way to directly &quot;bind&quot; the &quot;event.position&quot; value without having to subscribe?
Or better?</p>
<pre><code>var index: BehaviorRelay&lt;Int&gt; = BehaviorRelay.createDefault(0)

mainViewPager.pageScrollEvents().subscribe(
        { event -&gt;
            index.accept(event.position)
        }
    )
</code></pre>
<p>I think I'm looking for something like the following (This code will not work, just an example);</p>
<pre><code>mainViewPager.pageScrollEvents().position.bind(index)
</code></pre>
","10018819","","13727175","","2020-07-28 14:03:18","2020-07-28 14:03:18","Subscribe with Bind","<android><rx-java><rx-android><rx-kotlin>","0","2","","","","CC BY-SA 4.0"
"63499500","1","","","2020-08-20 06:32:20","","0","80","<p>Have been banging my head over this for a while, I am lost here in managing a requirement where I have to use Rx in Kotlin.</p>
<p>Let me explain.</p>
<p>There is a set of ids whose equivalent items needs to be deleted from server and eventually in local based on server success.</p>
<p>Basically</p>
<ol>
<li>Make network call to delete for a single <code>id</code>(Supported network call returns a <code>Completable</code>)</li>
<li>if <code>complete</code>(success) callback is received store the <code>id</code> in a <code>list</code> (memory)</li>
<li>Do step one and two for all <code>id</code> to delete</li>
<li>Once every network call is complete pass the list to delete from local DB</li>
</ol>
<p>So these functions are available which cannot be modified.</p>
<ol>
<li><code>fun deleteId(id: String): Completable { networkCall.deleteId(id) }</code></li>
<li><code>fun deleteIds(ids: List&lt;String&gt;): Unit { localDb.deleteId(ids) }</code></li>
</ol>
<p>This is what I have tried but obviously incomplete and stuck...</p>
<pre class=""lang-kotlin prettyprint-override""><code>val deleted = CopyOnWriteArrayList&lt;String&gt;()
val error = CopyOnWriteArrayList&lt;String&gt;()
items?.filter { it.isChecked }
    ?.map { Pair(it.id, dataManager.deleteId(it.id)) }
    ?.forEach { (Id, deleteOp) -&gt;
        deleteOp.subscribeOn(Schedulers.io())
                .subscribe(object: CompletableObserver {
                    override fun onComplete() { deleted.add(Id) }

                    override fun onSubscribe(d: Disposable) { disposableManager += d }

                    override fun onError(e: Throwable) { error.add(Id) }

                })
    }
</code></pre>
<p>So now there are multiple problems here, One of them is the requirement where I am unable to find a place to know that all requests are completed so as to initiate a localDb delete.</p>
<p>Is there a way where I can use <code>Flowable.fromIterable()</code> or <code>zip</code> or <code>merge</code> somehow following the chain of commands like above to achieve the above scenario?</p>
","1731048","","1731048","","2020-08-20 09:11:35","2020-08-20 13:23:21","How to perform operation based on result of multiple RxJava Completable results","<java><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"63777591","1","63787395","","2020-09-07 12:25:27","","3","3703","<p>I am new to Android development with Kotlin and I am struggling on finding any useful documentation on how to create a simple GET and POST requests with the best current practices as possible. I am coming from an Angular development and there we used a reactive development using RxJS.</p>
<p>Normally I would create a service file that would hold all my request functions, then I would use this service in whichever component and subscribe to the observable.</p>
<p>How would you do this in Android? Is there a good started example of things that have to be created. From the first look, everything looks so complicated and over-engineered</p>
","8358839","","","","","2020-09-08 05:05:18","Simple HTTP request example in Android using Kotlin","<android><kotlin><rx-android><rx-kotlin><rx-kotlin2>","3","1","1","","","CC BY-SA 4.0"
"64296967","1","","","2020-10-10 18:41:05","","0","28","<p>I am really new to Clean Architecture with Kotlin and I have some questions.
I followed this tutorial <a href=""https://android.jlelse.eu/mvp-with-rxjava2-room-koin-6f9492b94500"" rel=""nofollow noreferrer"">https://android.jlelse.eu/mvp-with-rxjava2-room-koin-6f9492b94500</a> and it was pretty clear on a lot of new concepts.</p>
<p>However I am not sure about use case (it is some another name for interactor?)</p>
<p>I am developing in MVP using Room, Retrofit, RxKotlin and Koin.
I fetch some data from an API and I want to deal with this data once I inserted it in my BDD.</p>
<p>UserResponseDAO.kt</p>
<pre><code>@Dao
interface UserResponseDAO {

    @Insert
    fun insertUser(vararg user: UserResponse) : Completable
}
</code></pre>
<p>UserResponsePresenter.kt</p>
<pre><code>class UserResponsePresenter(private val iUserResponseInteractor: IUserResponseInteractor): IUserResponsePresenter, ViewModel() {

    override fun insertUserResponse(userResponse: UserResponse) {
        iUserResponseInteractor.insertUserResponse(userResponse)
    }
} 
</code></pre>
<p>UserResponseInteractor.kt</p>
<pre><code>class UserResponseInteractor(private val iUserResponseRepository: IUserResponseRepository) :
    IUserResponseInteractor {

    override fun insertUserResponse(userResponse: UserResponse) {
        iUserResponseRepository.insertUserResponse(userResponse)
    }
}
</code></pre>
<p>UserResponseRepository.kt</p>
<pre><code>class UserResponseRepository(private val userResponseDAO: UserResponseDAO) :
    IUserResponseRepository {

    private val appUtility: AppUtility by inject()

    @SuppressLint(&quot;CheckResult&quot;)
    override fun insertUserResponse(userResponse: UserResponse) {

        userResponseDAO.insertUser(userResponse)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                {
                    when (userResponse.profilePOJO.role) {
                        Role.CLIENT -&gt; appUtility.redirectToMainPage(MainClientPageActivity())
                        Role.TATTOOIST -&gt; appUtility.redirectToMainPage(MainTattooistActivity())
                        else -&gt; return@subscribe
                    }
                },
                { Log.d(&quot;RxJava&quot;, &quot;Insert Error&quot;) }
            )

    }
}
</code></pre>
<p>AppUtility.kt</p>
<pre><code>class AppUtility(var context: Context) {

    fun redirectToMainPage(activity: Activity) {
        val intent: Intent = Intent(context, activity.javaClass)
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        context.startActivity(intent)
    }
}
</code></pre>
<p>I have no idea if my code in subscribe() from UserResponseRepository.kt is in the right place. And considering that I need the Context to start a new Activity, do I inject it the right way?</p>
<p>Thank you for any piece of advice!</p>
","9684955","","","","","2020-10-10 18:41:05","Clean Architecture with RxKotlin & Koin - Where to put my logic?","<retrofit><androidx><koin><rx-kotlin><room>","0","0","","","","CC BY-SA 4.0"
"64571621","1","64573000","","2020-10-28 11:10:55","","1","40","<p>I have a method that returns an Observable. I have this case where, in case of error I need to check error type, and for some specific error I need to return MyObject instead of error.</p>
<p>Example:</p>
<pre><code>    override fun getSomething(param: String): Observable&lt;State&gt; {
        return someInterface.getSingleResult(param)
            .flatMapObservable {
                when(something) {
                    true -&gt; {
                        Observable.just(State.ACTIVE)
                    }
                    false -&gt; {
                        Observable.just(State.PAUSED)
                    }
                }
            }
            .onErrorReturn {
                 if(it is Something) {
                      State.INACTIVE
                 } else {
//                    returns Throwable  &lt;- don;t know how to handle this
                 } 
            } 
    }
</code></pre>
","3524475","","","","","2020-10-28 16:12:48","Rx how to return Throwable or Object based on error type","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"64735549","1","","","2020-11-08 06:51:41","","0","24","<p><a href=""https://i.stack.imgur.com/0mo2bl.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0mo2bl.jpg"" alt=""Image"" /></a></p>
<p>I have got 3 seekbars on my screen, each controlling the R, G, B colour of the background.</p>
<p>I am using the combineLatest operator to combine the Observables.</p>
<p>The issue is that, the background colour only changes when I have all 3 of the seekbars changed.</p>
<p>Which operator should I use if I want the background colour to change, even if I only changing 1 seekbar?</p>
<pre><code>    override fun onStart() {
        super.onStart()

        val redColorStream = createSeekBarRedObservable()
        val greenColorStream = createSeekBarGreenObservable()
        val blueColorStream = createSeekBarBlueObservable()

        val colorPalette = Observable.combineLatest(redColorStream, greenColorStream, blueColorStream) { r,g,b -&gt;
            Color.rgb(r,g,b)
        }

        colorPalette
            .subscribe {
                main_activity.setBackgroundColor(it)
            }
    }
</code></pre>
","11007537","","","","","2020-11-08 06:51:41","RxKotlin: What is the correct operator in this case?","<android><rx-kotlin>","0","1","","","","CC BY-SA 4.0"
"65217193","1","65217381","","2020-12-09 12:55:24","","0","27","<p>could someone help, please?</p>
<p>I have these functions</p>
<pre><code>fun getBooks(): Single&lt;List&lt;Book&gt;&gt; {
    return getCollections()
        .map {
            it.map(::collectonToBook)
        }
}

fun getCollections(): Single&lt;List&lt;Collection&gt;&gt; {
   return db.fetchCollections()
       .filter(::isBook)
}

fun collectonToBook(collection: Collection): Maybe&lt;Book&gt; {
    return collection.toBook()
}
            
</code></pre>
<p>The problem is getBooks returns <code>Single&lt;List&lt;Maybe&lt;Book&gt;&gt;&gt;</code> when I need <code>Single&lt;List&lt;Book&gt;&gt;</code>. Can I do that inside the stream without calling blockingGet?</p>
","1158918","","","","","2020-12-09 13:05:58","Transform Single<List<Maybe<Book>>> to Single<List<Book>>","<kotlin><rx-java2><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"65289300","1","65504254","","2020-12-14 12:51:18","","0","32","<p>My server api looks like this:</p>
<pre><code>data class ArticleDTO(val id: Int, val title: String, val typeId: Int)
data class Type(val id: Int, val name: String) 

interface API {
    fun getArticles(): Single&lt;List&lt;ArticleDTO&gt;&gt;
    fun getTypes(): Single&lt;List&lt;Type&gt;&gt;
}
</code></pre>
<p>And I have one model which I use in UI:</p>
<pre><code>data class Article(val title: String, val typeName: String)
</code></pre>
<p>I created map method:</p>
<pre><code>fun ArticleDTO.toArticle(type: Type) = Article(this.title, typeName = type.name)
</code></pre>
<p>And in the repository class I did this:</p>
<pre><code>fun getArticles() =
    Observables.combineLatest(api.getArticles().toObservable(), api.getTypes().toObservable())
        .flatMap {
            Observable.just(it.first.map { articleDTO -&gt;
                articleDTO
                    .toArticle(it.second.find { type -&gt; type.id == articleDTO.typeId }!!)
            })
        }
</code></pre>
<p>Is there a way to do it better?</p>
<p>And what if my api will looks like this:</p>
<pre><code>interface API {
    fun getArticles(): Single&lt;List&lt;ArticleDTO&gt;&gt;
    fun getTypes(typeId: Int): Single&lt;Type&gt;
}
</code></pre>
","8145152","","","","","2020-12-30 08:45:12","Which is right way to map few server models into one domains?","<android><rx-java><clean-architecture><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"65587608","1","65588658","","2021-01-05 22:42:03","","0","21","<p>I have a queue of items that will send once the server is reachable:<br>
<code>val queueHistory: Observable&lt;QueuedItem&gt;</code></p>
<p>A QueuedItem is:<br>
<code>data class QueuedItem(val item: Item, val sent: Boolean = false)</code></p>
<p>The queueHistory never completes, it just records when an item is being queued to be sent <code>onNext(QueuedItem(item1, false)</code>, and then later records it was sent <code>onNext(QueuedItem(item1, true)</code>.</p>
<p><strong>What I want to do is get a current count of how many unsent items there are.</strong></p>
<p>The main source of my trouble is due to the list not completing, I was initially thinking of using <code>collect</code> but that needs a completed list.</p>
<p>I was playing around with using <code>scan</code> with something like<br>
<code>queueHistory.scan { items: ScannedItems, item -&gt; ScannedItems(arrayOf(*items, item), 0) }</code><br>
Where I could keep the current list of items I have encountered so far, but scan wants everything to be the same type.</p>
<p>Another idea I had was</p>
<pre><code>queueHistory
            .groupBy { it.item }
            .flatMapSingle { it.toList() }
            .map { it.size % 2 }
</code></pre>
<p>But toList() needs a finite list.</p>
<p>Any ideas would be appreciated!</p>
","103777","","","","","2021-01-06 00:46:28","Applying an operation to all previously emitted items","<rx-java><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"66539018","1","66543084","","2021-03-09 00:10:54","","0","46","<p>I have a <code>PublishSubject</code>:</p>
<pre><code>val myPublishSubject = remember {
    PublishSubject.create&lt;Long&gt;().apply {
        doOnNext {
            Logger.debug(TAG) { &quot;Got new Long $it&quot; }
        }
            .takeUntil(someObservable)
            .subscribe()
    }
}
</code></pre>
<p>and I have a service what gets a stream of Long values, somewhere in another function:</p>
<pre><code>while(notFinished){
    val newLong = getSomeLong()
    myPublishSubject.onNext(newLong)
}
</code></pre>
<p>Here, the upper <code>doOnNext{}</code> is logging forever. How can I for instance only allow first 20 Long values? <code>.take(20)</code> did not work!</p>
","15122239","","15122239","","2021-03-09 07:02:37","2021-03-09 08:14:36","How to doOnNext only consumes the first n items of a PublishSubject?","<kotlin><rx-java2><rx-android><android-jetpack-compose><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"66832744","1","66835123","","2021-03-27 15:01:18","","0","160","<p>My Question is so clear, I wanna know what is the reason that you prefer using third-party libraries like RxJava or RxKotlin, or using coroutines for setting item click listener for Recyclerview items click, dialogs button or anything else, instead of using Interfaces, is there any performance reason?
what is the difference between these tools?</p>
","9972675","","","","","2021-03-27 19:06:25","What is the benefit of using RxJava, RxKotlin, or Even Kotlin coroutines instead of Interfaces for On Click listener?","<android><android-studio><rx-java><kotlin-coroutines><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"67040162","1","67055925","","2021-04-10 23:25:57","","1","41","<p>I have a list of recurring elements in Kotlin, say:</p>
<pre><code>val result = arrayListOf&lt;String&gt;(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;BB&quot;)
</code></pre>
<p>I would like to group them by their value along with how many times they appear, so the output would be pairs of:</p>
<pre><code>{&quot;AA&quot;, 2}, {&quot;BB&quot;, 2}, {&quot;CC&quot;, 1}
</code></pre>
<p>I have resolved the problem using in Kotlin as follows:</p>
<pre><code>val ans = result.map { it.value }
            .groupBy { it }
            .map { Pair(it.key, it.value.size) }
            .sortedByDescending { it.second }
</code></pre>
<p>I want to write same code in RxKotlin for learning and tried with the following but do not know how to apply <code>map</code>/<code>flatMap</code> to achieve the result.</p>
<pre><code>val source = Observable.fromIterable(result)
source.groupBy{ it }.subscribe { showresult(it) }
</code></pre>
","1154390","","10082297","","2021-04-10 23:28:30","2021-04-12 09:27:43","RxKotlin COUNT with GROUP BY and return a list","<kotlin><rx-java><rx-kotlin><rx-kotlin2>","1","2","","","","CC BY-SA 4.0"
"67128528","1","","","2021-04-16 16:00:22","","0","22","<p>So I have an object of contactId and I convert it to flux and then I query the contact details using each Id respectively and after that convert it to Mono using collectList method and map it to another object let's call it DomainContactDetails like this.</p>
<pre class=""lang-kotlin prettyprint-override""><code>Flux.just(identifier.regContactId, identifier.billingContactId ,identifier.adminContactId, identifier.techContactId)
      .flatMap { resellerGetContact(it) }
      .collectList()
      .map { DomainContactDetails.fromList(it) }
      .toFuture()
</code></pre>
<p>Are there anyways to collect flux element into key map instead of list. for now I'm using index of list to indentify which data belongs to the property</p>
<pre class=""lang-kotlin prettyprint-override""><code>data class DomainContactDetails(
  val registrantContact: ContactInfo,
  val billingContact: ContactInfo,
  val adminContact: ContactInfo,
  val techContact: ContactInfo
) {
  companion object {
    fun fromList(contacts: List&lt;ContactInfo&gt;) = DomainContactDetails(
      registrantContact = contacts[0],
      billingContact = contacts[1],
      adminContact = contacts[2],
      techContact = contacts[3]
    )
  }
}
</code></pre>
<p>I want it to be key map so it might be a bit better like this</p>
<pre class=""lang-kotlin prettyprint-override""><code>fun fromKeyMap(contacts: Map&lt;String, ContactInfo&gt;) = DomainContactDetails(
  registrantContact = contacts[&quot;reg&quot;],
  billingContact = contacts[&quot;bil&quot;],
  adminContact = contacts[&quot;adm&quot;],
  techContact = contacts[&quot;tec&quot;]
)
</code></pre>
","9740664","","8976","","2021-04-17 07:49:20","2021-04-17 07:49:20","How can I convert flux element to a key map mono","<kotlin><reactor><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"67394991","1","","","2021-05-05 03:54:49","","0","22","<p>I'm using kotlin/java to develop android apps and reactiveX is something new to me.</p>
<p>How do we append similar data in an array using reactiveX?</p>
<p>I have this data and I want to merge same dates and append their progress.</p>
<p>So how do we transform this data</p>
<pre><code>{
  &quot;data&quot;: [
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 1
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 5
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 2
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 3
    },
    {
      &quot;date&quot;: &quot;05-06-22&quot;,
      &quot;progress&quot;: 2
    }
  ]
}
</code></pre>
<p>to</p>
<pre><code>{
  &quot;data&quot;: [
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 11
    },
    {
      &quot;date&quot;: &quot;05-06-22&quot;,
      &quot;progress&quot;: 2
    }
  ]
}
</code></pre>
","6104745","","6104745","","2021-05-05 04:19:06","2021-05-05 04:19:06","Merging data in an array using ReactiveX in Android","<android><kotlin><rx-java><reactivex><rx-kotlin>","0","0","","","","CC BY-SA 4.0"
"67589564","1","67796289","","2021-05-18 15:39:43","","0","43","<p>I'm using refCount to hold onto a BLE connection for 5 mins. This works well until I have a connection issue, refCount still keeps the connection and replay replays the error.</p>
<p>Is there a way I can make either make refCount disconnect as soon as there is an error, or make replay not replay errors?</p>
<pre><code>        bleDevice
            .establishConnection(false)
            .replay(1)
            .refCount(1, 5, TimeUnit.MINUTES)
</code></pre>
","103777","","","","","2021-06-01 21:36:04","refCount keeping connection even after an error","<rx-java><reactive-programming><rxandroidble><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"67960660","1","67966935","","2021-06-13 16:52:15","","0","75","<p>I am a newbie to RXKotlin/RXJava.
I am developing the background service in Android.</p>
<p>In my service, I have</p>
<ul>
<li>Bluetooth socket</li>
<li>TCP Socket</li>
</ul>
<p>Whenever the data is available on the Bluetooth socket, read and write to the TCP socket. And whenever data is received in the TCP socket, write to the Bluetooth socket.</p>
<p>Can someone help me:</p>
<ul>
<li>how to achieve this using Observables?</li>
<li>how to exchange the socket id information?</li>
<li>how to exchange the data?
Thanks</li>
</ul>
","16216084","","2801860","","2021-06-14 18:21:18","2021-06-14 18:21:18","RXKOTLIN/RXJAVA: Communication between the socket using Observables","<android><rx-java><rxjs-observables><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"68191518","1","","","2021-06-30 08:54:00","","0","57","<p>In my Android App I'm trying to save a file with input- and outputStream from the contentResolver. I'm using this saveImageExternal function in a Rx Completable.fromCallable and I got a FileNotFoundException because my uri was wrong, but the onError function from my observer was not called and the Completable completed. Why was onError not called? Can someone explain?</p>
<pre><code>private fun saveImageExternal(file: File, uri: Uri, context: Context) {
        val resolver = context.contentResolver
        val outputStream = FileOutputStream(file)
        val inputStream = resolver.openInputStream(uri)
        val buffer = ByteArray(4096)
        var length: Int
        if (inputStream != null) {
            while (inputStream.read(buffer).also { length = it } &gt; 0) {
                outputStream.write(buffer, 0, length)
            }
            outputStream.flush()
        }

    }
</code></pre>
<pre><code>Completable.fromCallable { saveImageExternal(file, uri, context) }
            .subscribeOn(Schedulers.io())
            .subscribe(object : CompletableObserver{
                override fun onSubscribe(d: Disposable) {
                    Timber.d(&quot;onSubscribe&quot;)
                }

                override fun onComplete() {
                   Timber.d(&quot;onComplete&quot;)
                }

                override fun onError(e: Throwable) {
                    Timber.d(&quot;onError&quot;) // never called 
                }

            })
</code></pre>
","14718579","","14718579","","2021-06-30 09:48:04","2021-06-30 09:48:04","Rx Error Handling in Completable.fromCallable","<android><rx-java><rx-kotlin><rx-java-completable>","0","1","","","","CC BY-SA 4.0"
"68667754","1","68668270","","2021-08-05 13:43:10","","3","47","<p>I am studying RxKotlin and the question arose: what is the difference between <code>defer()</code>  and  <code>defer{}</code></p>
","14729932","","","","","2021-08-05 14:14:12","What is the difference between defer() and defer{}","<kotlin><rx-java><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"68865912","1","","","2021-08-20 17:16:38","","0","24","<p>Is it possible to call handler right at start of every minute? Mean check current time and call handler only when seconds are 00. Using RX2. Thanks.</p>
<p><code>Observable.interval(1, TimeUnit.MINUTES)</code></p>
","1621111","","","","","2021-08-20 17:16:38","Call handler right at start of every minute","<android><rx-java2><rx-kotlin>","0","2","","","","CC BY-SA 4.0"